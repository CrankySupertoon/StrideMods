/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/egg2pg -Ipanda/src/egg2pg -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3egg2pg_igate.cxx -od built/pandac/input/libp3egg2pg.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/egg2pg -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.egg -library libp3egg2pg load_egg_file.h save_egg_file.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "coordinateSystem.h"
#include "eggData.h"
#include "load_egg_file.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "save_egg_file.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[0].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[1].type)
  {"BamCacheRecord", nullptr},
#define Dtool_Ptr_BamCacheRecord (imports[2].type)
  {"EggData", nullptr},
#define Dtool_Ptr_EggData (imports[3].type)
  {nullptr, nullptr},
};
#endif

// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// BamCacheRecord
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BamCacheRecord;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamCacheRecord = &Dtool_BamCacheRecord;
#endif
// EggData
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_EggData;
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggData = &Dtool_EggData;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * PointerTo< PandaNode > load_egg_file(Filename const &filename, CoordinateSystem cs = ::CS_default, BamCacheRecord *record = nullptr)
 */
static PyObject *Dtool_load_egg_file_1(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-PointerTo< PandaNode > load_egg_file(Filename const &filename, CoordinateSystem cs = ::CS_default, BamCacheRecord *record = nullptr)
  PyObject *param0;
  int param1 = ::CS_default;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"filename", "cs", "record", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|iO:load_egg_file", (char **)keyword_list, &param0, &param1, &param2)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "load_egg_file", "Filename");
    }
    BamCacheRecord *param2_this = nullptr;
    if (param2 != nullptr && param2 != Py_None) {
      param2_this = (BamCacheRecord *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_BamCacheRecord, 2, "load_egg_file", false, true);
    }
    if ((param2 == nullptr || param2 == Py_None || param2_this != nullptr)) {
      PointerTo< PandaNode > return_value = (::load_egg_file)(*param0_this, (CoordinateSystem)param1, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      PandaNode *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_egg_file(const Filename filename, int cs, BamCacheRecord record)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_load_egg_file_1_comment =
  "C++ Interface:\n"
  "load_egg_file(const Filename filename, int cs, BamCacheRecord record)\n";
#else
static const char *Dtool_load_egg_file_1_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > load_egg_data(EggData *data, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_load_egg_data_2(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-PointerTo< PandaNode > load_egg_data(EggData *data, CoordinateSystem cs = ::CS_default)
  PyObject *param0;
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"data", "cs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:load_egg_data", (char **)keyword_list, &param0, &param1)) {
    EggData *param0_this = (EggData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_EggData, 0, "load_egg_data", false, true);
    if (param0_this != nullptr) {
      PointerTo< PandaNode > return_value = (::load_egg_data)(param0_this, (CoordinateSystem)param1);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      PandaNode *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_egg_data(EggData data, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_load_egg_data_2_comment =
  "C++ Interface:\n"
  "load_egg_data(EggData data, int cs)\n";
#else
static const char *Dtool_load_egg_data_2_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool save_egg_file(Filename const &filename, PandaNode *node, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_save_egg_file_3(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool save_egg_file(Filename const &filename, PandaNode *node, CoordinateSystem cs = ::CS_default)
  PyObject *param0;
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"filename", "node", "cs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:save_egg_file", (char **)keyword_list, &param0, &param1, &param2)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "save_egg_file", "Filename");
    }
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "save_egg_file", false, true);
    if (param1_this != nullptr) {
      bool return_value = (::save_egg_file)(*param0_this, param1_this, (CoordinateSystem)param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "save_egg_file(const Filename filename, PandaNode node, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_save_egg_file_3_comment =
  "C++ Interface:\n"
  "save_egg_file(const Filename filename, PandaNode node, int cs)\n";
#else
static const char *Dtool_save_egg_file_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool save_egg_data(EggData *data, PandaNode *node)
 */
static PyObject *Dtool_save_egg_data_4(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool save_egg_data(EggData *data, PandaNode *node)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"data", "node", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:save_egg_data", (char **)keyword_list, &param0, &param1)) {
    EggData *param0_this = (EggData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_EggData, 0, "save_egg_data", false, true);
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "save_egg_data", false, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      bool return_value = (::save_egg_data)(param0_this, param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "save_egg_data(EggData data, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_save_egg_data_4_comment =
  "C++ Interface:\n"
  "save_egg_data(EggData data, PandaNode node)\n";
#else
static const char *Dtool_save_egg_data_4_comment = nullptr;
#endif


/**
 * Module Object Linker ..
 */
void Dtool_libp3egg2pg_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_libp3egg2pg_BuildInstants(PyObject *module) {
  (void) module;
}

static PyMethodDef python_simple_funcs[] = {
  {"load_egg_file", (PyCFunction) &Dtool_load_egg_file_1, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_load_egg_file_1_comment},
  {"loadEggFile", (PyCFunction) &Dtool_load_egg_file_1, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_load_egg_file_1_comment},
  {"load_egg_data", (PyCFunction) &Dtool_load_egg_data_2, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_load_egg_data_2_comment},
  {"loadEggData", (PyCFunction) &Dtool_load_egg_data_2, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_load_egg_data_2_comment},
  {"save_egg_file", (PyCFunction) &Dtool_save_egg_file_3, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_save_egg_file_3_comment},
  {"saveEggFile", (PyCFunction) &Dtool_save_egg_file_3, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_save_egg_file_3_comment},
  {"save_egg_data", (PyCFunction) &Dtool_save_egg_data_4, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_save_egg_data_4_comment},
  {"saveEggData", (PyCFunction) &Dtool_save_egg_data_4, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_save_egg_data_4_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3egg2pg_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3egg2pg_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583614136,  /* file_identifier */
  "libp3egg2pg",  /* library_name */
  "KLrJ",  /* library_hash_name */
  "panda3d.egg",  /* module_name */
  "libp3egg2pg.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  20  /* next_index */
};

Configure(_in_configure_libp3egg2pg);
ConfigureFn(_in_configure_libp3egg2pg) {
  interrogate_request_module(&_in_module_def);
}

