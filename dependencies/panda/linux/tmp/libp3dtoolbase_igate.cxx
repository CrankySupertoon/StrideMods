/*
 * This file was generated by:
 * built/bin/interrogate -srcdir dtool/src/dtoolbase -Idtool/src/dtoolbase -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3dtoolbase_igate.cxx -od built/pandac/input/libp3dtoolbase.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Idtool/src/dtoolbase -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3dtoolbase p3dtoolbase_composite1.cxx p3dtoolbase_composite2.cxx typeHandle.h typeHandle_ext.h typeRegistry.h typedObject.h neverFreeMemory.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "dtoolbase.h"
#include "extension.h"
#include "neverFreeMemory.h"
#include "py_panda.h"
#include "typeHandle.h"
#include "typeHandle_ext.h"
#include "typeRegistry.h"
#include "typedObject.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class NeverFreeMemory
 */
typedef NeverFreeMemory NeverFreeMemory_localtype;
Define_Module_Class(panda3d.core, NeverFreeMemory, NeverFreeMemory_localtype, NeverFreeMemory);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NeverFreeMemory = &Dtool_NeverFreeMemory;
static void Dtool_PyModuleClassInit_NeverFreeMemory(PyObject *module);

/**
 * Forward declarations for top-level class TypeHandle
 */
typedef TypeHandle TypeHandle_localtype;
Define_Module_Class(panda3d.core, TypeHandle, TypeHandle_localtype, TypeHandle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
static void Dtool_PyModuleClassInit_TypeHandle(PyObject *module);
TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);

/**
 * Forward declarations for top-level class TypeRegistry
 */
typedef TypeRegistry TypeRegistry_localtype;
Define_Module_Class(panda3d.core, TypeRegistry, TypeRegistry_localtype, TypeRegistry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeRegistry = &Dtool_TypeRegistry;
static void Dtool_PyModuleClassInit_TypeRegistry(PyObject *module);

/**
 * Forward declarations for top-level class TypedObject
 */
typedef TypedObject TypedObject_localtype;
Define_Module_Class(panda3d.core, TypedObject, TypedObject_localtype, TypedObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
static void Dtool_PyModuleClassInit_TypedObject(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"NeverFreeMemory", &Dtool_NeverFreeMemory},
  {"TypeHandle", &Dtool_TypeHandle},
  {"TypeRegistry", &Dtool_TypeRegistry},
  {"TypedObject", &Dtool_TypedObject},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class NeverFreeMemory
 */
/**
 * Python function wrapper for:
 * static inline std::size_t NeverFreeMemory::get_total_alloc(void)
 */
static PyObject *Dtool_NeverFreeMemory_get_total_alloc_2(PyObject *, PyObject *) {
  // 1-static inline std::size_t NeverFreeMemory::get_total_alloc(void)
  std::size_t return_value = (NeverFreeMemory::get_total_alloc)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NeverFreeMemory_get_total_alloc_2_comment =
  "C++ Interface:\n"
  "get_total_alloc()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes consumed by all the pages allocated\n"
  " * internally by this object.\n"
  " */";
#else
static const char *Dtool_NeverFreeMemory_get_total_alloc_2_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t NeverFreeMemory::get_total_used(void)
 */
static PyObject *Dtool_NeverFreeMemory_get_total_used_3(PyObject *, PyObject *) {
  // 1-static inline std::size_t NeverFreeMemory::get_total_used(void)
  std::size_t return_value = (NeverFreeMemory::get_total_used)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NeverFreeMemory_get_total_used_3_comment =
  "C++ Interface:\n"
  "get_total_used()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes requested by the application in calls to\n"
  " * NeverFreeMemory::alloc().\n"
  " */";
#else
static const char *Dtool_NeverFreeMemory_get_total_used_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t NeverFreeMemory::get_total_unused(void)
 */
static PyObject *Dtool_NeverFreeMemory_get_total_unused_4(PyObject *, PyObject *) {
  // 1-static inline std::size_t NeverFreeMemory::get_total_unused(void)
  std::size_t return_value = (NeverFreeMemory::get_total_unused)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NeverFreeMemory_get_total_unused_4_comment =
  "C++ Interface:\n"
  "get_total_unused()\n"
  "\n"
  "/**\n"
  " * Returns the difference between get_total_alloc() and get_total_used().\n"
  " * This represents bytes in allocated pages that have not (yet) been used by\n"
  " * the application.\n"
  " */";
#else
static const char *Dtool_NeverFreeMemory_get_total_unused_4_comment = nullptr;
#endif

static int Dtool_Init_NeverFreeMemory(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_NeverFreeMemory(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NeverFreeMemory) {
    printf("NeverFreeMemory ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NeverFreeMemory *local_this = (NeverFreeMemory *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NeverFreeMemory) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NeverFreeMemory(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NeverFreeMemory) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TypeHandle
 */
/**
 * Python function wrapper for:
 * static TypeHandle TypeHandle::make(PyTypeObject *classobj)
 */
static PyObject *Dtool_TypeHandle_make_9(PyObject *, PyObject *arg) {
  // 1-static TypeHandle TypeHandle::make(PyTypeObject *classobj)
  if (PyType_Check(arg)) {
    TypeHandle *return_value = new TypeHandle(Extension<TypeHandle>::make((PyTypeObject *)arg));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(type classobj)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_make_9_comment =
  "C++ Interface:\n"
  "make(type classobj)\n";
#else
static const char *Dtool_TypeHandle_make_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TypeHandle::compare_to(TypeHandle const &other) const
 */
static PyObject *Dtool_TypeHandle_compare_to_16(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-inline int TypeHandle::compare_to(TypeHandle const &other) const
  TypeHandle arg_local;
  TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TypeHandle.compare_to", "TypeHandle");
  }
  int return_value = ((*(const TypeHandle*)local_this).compare_to)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(TypeHandle self, const TypeHandle other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_compare_to_16_comment =
  "C++ Interface:\n"
  "compare_to(TypeHandle self, const TypeHandle other)\n"
  "\n"
  "/**\n"
  " * Sorts TypeHandles arbitrarily (according to <, >, etc.).  Returns a number\n"
  " * less than 0 if this type sorts before the other one, greater than zero if\n"
  " * it sorts after, 0 if they are equivalent.\n"
  " */";
#else
static const char *Dtool_TypeHandle_compare_to_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TypeHandle::get_hash(void) const
 */
static PyObject *Dtool_TypeHandle_get_hash_17(PyObject *self, PyObject *) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-inline std::size_t TypeHandle::get_hash(void) const
  std::size_t return_value = ((*(const TypeHandle*)local_this).get_hash)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_hash_17_comment =
  "C++ Interface:\n"
  "get_hash(TypeHandle self)\n"
  "\n"
  "/**\n"
  " * Returns a hash code suitable for phash_map.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_hash_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string TypeHandle::get_name(TypedObject *object = nullptr) const
 */
static PyObject *Dtool_TypeHandle_get_name_18(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-inline std::string TypeHandle::get_name(TypedObject *object = nullptr) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "object")) {
    TypedObject *param1_this = nullptr;
    if (param1 != nullptr && param1 != Py_None) {
      param1_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedObject, 1, "TypeHandle.get_name", false, true);
    }
    if ((param1 == nullptr || param1 == Py_None || param1_this != nullptr)) {
      std::string return_value = ((*(const TypeHandle*)local_this).get_name)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_name(TypeHandle self, TypedObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_name_18_comment =
  "C++ Interface:\n"
  "get_name(TypeHandle self, TypedObject object)\n"
  "\n"
  "/**\n"
  " * Returns the name of the type.\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_name_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TypeHandle::is_derived_from(TypeHandle parent, TypedObject *object = nullptr) const
 */
static PyObject *Dtool_TypeHandle_is_derived_from_19(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-inline bool TypeHandle::is_derived_from(TypeHandle parent, TypedObject *object = nullptr) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"parent", "object", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:is_derived_from", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeHandle.is_derived_from", "TypeHandle");
    }
    TypedObject *param2_this = nullptr;
    if (param2 != nullptr && param2 != Py_None) {
      param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedObject, 2, "TypeHandle.is_derived_from", false, true);
    }
    if ((param2 == nullptr || param2 == Py_None || param2_this != nullptr)) {
      bool return_value = ((*(const TypeHandle*)local_this).is_derived_from)(*param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_derived_from(TypeHandle self, TypeHandle parent, TypedObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_is_derived_from_19_comment =
  "C++ Interface:\n"
  "is_derived_from(TypeHandle self, TypeHandle parent, TypedObject object)\n"
  "\n"
  "/**\n"
  " * Returns true if this type is derived from the indicated type, false\n"
  " * otherwise.\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeHandle_is_derived_from_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TypeHandle::get_num_parent_classes(TypedObject *object = nullptr) const
 */
static PyObject *Dtool_TypeHandle_get_num_parent_classes_20(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-inline int TypeHandle::get_num_parent_classes(TypedObject *object = nullptr) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "object")) {
    TypedObject *param1_this = nullptr;
    if (param1 != nullptr && param1 != Py_None) {
      param1_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedObject, 1, "TypeHandle.get_num_parent_classes", false, true);
    }
    if ((param1 == nullptr || param1 == Py_None || param1_this != nullptr)) {
      int return_value = ((*(const TypeHandle*)local_this).get_num_parent_classes)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_parent_classes(TypeHandle self, TypedObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_num_parent_classes_20_comment =
  "C++ Interface:\n"
  "get_num_parent_classes(TypeHandle self, TypedObject object)\n"
  "\n"
  "/**\n"
  " * Returns the number of parent classes that this type is known to have.  This\n"
  " * may then be used to index into get_parent_class().  The result will be 0 if\n"
  " * this class does not inherit from any other classes, 1 if normal, single\n"
  " * inheritance is in effect, or greater than one if multiple inheritance is in\n"
  " * effect.\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_num_parent_classes_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TypeHandle TypeHandle::get_parent_class(int index) const
 */
static PyObject *Dtool_TypeHandle_get_parent_class_21(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-inline TypeHandle TypeHandle::get_parent_class(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle(((*(const TypeHandle*)local_this).get_parent_class)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent_class(TypeHandle self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_parent_class_21_comment =
  "C++ Interface:\n"
  "get_parent_class(TypeHandle self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth parent class of this type.  The index should be in the\n"
  " * range 0 <= index < get_num_parent_classes().\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_parent_class_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TypeHandle::get_num_child_classes(TypedObject *object = nullptr) const
 */
static PyObject *Dtool_TypeHandle_get_num_child_classes_22(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-inline int TypeHandle::get_num_child_classes(TypedObject *object = nullptr) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "object")) {
    TypedObject *param1_this = nullptr;
    if (param1 != nullptr && param1 != Py_None) {
      param1_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedObject, 1, "TypeHandle.get_num_child_classes", false, true);
    }
    if ((param1 == nullptr || param1 == Py_None || param1_this != nullptr)) {
      int return_value = ((*(const TypeHandle*)local_this).get_num_child_classes)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_child_classes(TypeHandle self, TypedObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_num_child_classes_22_comment =
  "C++ Interface:\n"
  "get_num_child_classes(TypeHandle self, TypedObject object)\n"
  "\n"
  "/**\n"
  " * Returns the number of child classes that this type is known to have.  This\n"
  " * may then be used to index into get_child_class().\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_num_child_classes_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TypeHandle TypeHandle::get_child_class(int index) const
 */
static PyObject *Dtool_TypeHandle_get_child_class_23(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-inline TypeHandle TypeHandle::get_child_class(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle(((*(const TypeHandle*)local_this).get_child_class)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child_class(TypeHandle self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_child_class_23_comment =
  "C++ Interface:\n"
  "get_child_class(TypeHandle self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth child class of this type.  The index should be in the range\n"
  " * 0 <= index < get_num_child_classes().\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_child_class_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TypeHandle TypeHandle::get_parent_towards(TypeHandle ancestor, TypedObject *object = nullptr) const
 */
static PyObject *Dtool_TypeHandle_get_parent_towards_24(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-inline TypeHandle TypeHandle::get_parent_towards(TypeHandle ancestor, TypedObject *object = nullptr) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"ancestor", "object", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:get_parent_towards", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeHandle.get_parent_towards", "TypeHandle");
    }
    TypedObject *param2_this = nullptr;
    if (param2 != nullptr && param2 != Py_None) {
      param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedObject, 2, "TypeHandle.get_parent_towards", false, true);
    }
    if ((param2 == nullptr || param2 == Py_None || param2_this != nullptr)) {
      TypeHandle *return_value = new TypeHandle(((*(const TypeHandle*)local_this).get_parent_towards)(*param1_this, param2_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent_towards(TypeHandle self, TypeHandle ancestor, TypedObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_parent_towards_24_comment =
  "C++ Interface:\n"
  "get_parent_towards(TypeHandle self, TypeHandle ancestor, TypedObject object)\n"
  "\n"
  "/**\n"
  " * Returns the parent class that is in a direct line of inheritance to the\n"
  " * indicated ancestor class.  This is useful in the presence of multiple\n"
  " * inheritance to try to determine what properties an unknown type may have.\n"
  " *\n"
  " * The return value is TypeHandle::none() if the type does not inherit from\n"
  " * the ancestor.  If ancestor is the same as this type, the return value is\n"
  " * this type.\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_parent_towards_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t TypeHandle::get_memory_usage(TypeHandle::MemoryClass memory_class) const
 */
static PyObject *Dtool_TypeHandle_get_memory_usage_26(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-std::size_t TypeHandle::get_memory_usage(TypeHandle::MemoryClass memory_class) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = ((*(const TypeHandle*)local_this).get_memory_usage)((TypeHandle::MemoryClass)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_memory_usage(TypeHandle self, int memory_class)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_memory_usage_26_comment =
  "C++ Interface:\n"
  "get_memory_usage(TypeHandle self, int memory_class)\n"
  "\n"
  "/**\n"
  " * Returns the total allocated memory used by objects of this type, for the\n"
  " * indicated memory class.  This is only updated if track-memory-usage is set\n"
  " * true in your Config.prc file.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_memory_usage_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TypeHandle::inc_memory_usage(TypeHandle::MemoryClass memory_class, std::size_t size)
 */
static PyObject *Dtool_TypeHandle_inc_memory_usage_27(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeHandle, (void **)&local_this, "TypeHandle.inc_memory_usage")) {
    return nullptr;
  }
  // 1-void TypeHandle::inc_memory_usage(TypeHandle::MemoryClass memory_class, std::size_t size)
  int param1;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"memory_class", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "in:inc_memory_usage", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    ((*local_this).inc_memory_usage)((TypeHandle::MemoryClass)param1, (std::size_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "inc_memory_usage(const TypeHandle self, int memory_class, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_inc_memory_usage_27_comment =
  "C++ Interface:\n"
  "inc_memory_usage(const TypeHandle self, int memory_class, int size)\n"
  "\n"
  "/**\n"
  " * Adds the indicated amount to the record for the total allocated memory for\n"
  " * objects of this type.\n"
  " */";
#else
static const char *Dtool_TypeHandle_inc_memory_usage_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TypeHandle::dec_memory_usage(TypeHandle::MemoryClass memory_class, std::size_t size)
 */
static PyObject *Dtool_TypeHandle_dec_memory_usage_28(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeHandle, (void **)&local_this, "TypeHandle.dec_memory_usage")) {
    return nullptr;
  }
  // 1-void TypeHandle::dec_memory_usage(TypeHandle::MemoryClass memory_class, std::size_t size)
  int param1;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"memory_class", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "in:dec_memory_usage", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    ((*local_this).dec_memory_usage)((TypeHandle::MemoryClass)param1, (std::size_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dec_memory_usage(const TypeHandle self, int memory_class, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_dec_memory_usage_28_comment =
  "C++ Interface:\n"
  "dec_memory_usage(const TypeHandle self, int memory_class, int size)\n"
  "\n"
  "/**\n"
  " * Subtracts the indicated amount from the record for the total allocated\n"
  " * memory for objects of this type.\n"
  " */";
#else
static const char *Dtool_TypeHandle_dec_memory_usage_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TypeHandle::get_index(void) const
 */
static PyObject *Dtool_TypeHandle_get_index_29(PyObject *self, PyObject *) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-inline int TypeHandle::get_index(void) const
  int return_value = ((*(const TypeHandle*)local_this).get_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_index_29_comment =
  "C++ Interface:\n"
  "get_index(TypeHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the integer index associated with this TypeHandle.  Each different\n"
  " * TypeHandle will have a different index.  However, you probably shouldn't be\n"
  " * using this method; you should just treat the TypeHandles as opaque classes.\n"
  " * This is provided for the convenience of non-C++ scripting languages to\n"
  " * build a hashtable of TypeHandles.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_index_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TypeHandle::output(std::ostream &out) const
 */
static PyObject *Dtool_TypeHandle_output_30(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeHandle)) {
    return nullptr;
  }
  // 1-inline void TypeHandle::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "TypeHandle.output", false, true);
  if (arg_this != nullptr) {
    ((*(const TypeHandle*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(TypeHandle self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_output_30_comment =
  "C++ Interface:\n"
  "output(TypeHandle self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TypeHandle_output_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr TypeHandle TypeHandle::none(void)
 */
static PyObject *Dtool_TypeHandle_none_31(PyObject *, PyObject *) {
  // 1-static constexpr TypeHandle TypeHandle::none(void)
  TypeHandle *return_value = new TypeHandle((TypeHandle::none)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_none_31_comment =
  "C++ Interface:\n"
  "none()\n";
#else
static const char *Dtool_TypeHandle_none_31_comment = nullptr;
#endif

static PyObject *Dtool_TypeHandle_index_Getter(PyObject *self, void *) {
  const TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TypeHandle::get_index(void) const
  int return_value = ((*(const TypeHandle*)local_this).get_index)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TypeHandle_name_Getter(PyObject *self, void *) {
  const TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string TypeHandle::get_name(TypedObject *object) const
  std::string return_value = ((*(const TypeHandle*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property TypeHandle::parent_classes
 */
static Py_ssize_t Dtool_TypeHandle_parent_classes_Len(PyObject *self) {
  TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_parent_classes)();
}

/**
 * sequence getter for property TypeHandle::parent_classes
 */
static PyObject *Dtool_TypeHandle_parent_classes_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_parent_classes)()) {
    PyErr_SetString(PyExc_IndexError, "TypeHandle.parent_classes[] index out of range");
    return nullptr;
  }
  // 1-inline TypeHandle TypeHandle::get_parent_class(int index) const
  TypeHandle *return_value = new TypeHandle(((*(const TypeHandle*)local_this).get_parent_class)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent_class(TypeHandle self, index)\n");
  }
}

static PyObject *Dtool_TypeHandle_parent_classes_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "TypeHandle.parent_classes");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_TypeHandle_parent_classes_Len;
    wrap->_getitem_func = &Dtool_TypeHandle_parent_classes_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property TypeHandle::child_classes
 */
static Py_ssize_t Dtool_TypeHandle_child_classes_Len(PyObject *self) {
  TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_child_classes)();
}

/**
 * sequence getter for property TypeHandle::child_classes
 */
static PyObject *Dtool_TypeHandle_child_classes_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_child_classes)()) {
    PyErr_SetString(PyExc_IndexError, "TypeHandle.child_classes[] index out of range");
    return nullptr;
  }
  // 1-inline TypeHandle TypeHandle::get_child_class(int index) const
  TypeHandle *return_value = new TypeHandle(((*(const TypeHandle*)local_this).get_child_class)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child_class(TypeHandle self, index)\n");
  }
}

static PyObject *Dtool_TypeHandle_child_classes_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "TypeHandle.child_classes");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_TypeHandle_child_classes_Len;
    wrap->_getitem_func = &Dtool_TypeHandle_child_classes_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * TypeHandle::TypeHandle(void) noexcept = default
 * inline TypeHandle::TypeHandle(TypeHandle const &) = default
 */
static int Dtool_Init_TypeHandle(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TypeHandle() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-TypeHandle::TypeHandle(void) noexcept = default
      TypeHandle *return_value = new TypeHandle(TypeHandle::none());
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TypeHandle, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline TypeHandle::TypeHandle(TypeHandle const &) = default
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 0, "TypeHandle.TypeHandle", "TypeHandle");
        return -1;
      }
      TypeHandle *return_value = new TypeHandle(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TypeHandle, true, false);
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TypeHandle() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TypeHandle()\n"
      "TypeHandle(const TypeHandle param0)\n");
  }
  return -1;
}

TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  TypeHandle *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_TypeHandle)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const TypeHandle *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static TypeHandle TypeHandle::make(PyTypeObject *classobj)
    if (PyType_Check(arg)) {
      coerced = Extension<TypeHandle>::make((PyTypeObject *)arg);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_TypeHandle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TypeHandle) {
    printf("TypeHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TypeHandle *local_this = (TypeHandle *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TypeHandle) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TypeHandle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TypeHandle) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TypeRegistry
 */
/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::register_dynamic_type(std::string const &name)
 */
static PyObject *Dtool_TypeRegistry_register_dynamic_type_43(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.register_dynamic_type")) {
    return nullptr;
  }
  // 1-TypeHandle TypeRegistry::register_dynamic_type(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    TypeHandle *return_value = new TypeHandle(((*local_this).register_dynamic_type)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_dynamic_type(const TypeRegistry self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_register_dynamic_type_43_comment =
  "C++ Interface:\n"
  "register_dynamic_type(const TypeRegistry self, str name)\n"
  "\n"
  "/**\n"
  " * Registers a new type on-the-fly, presumably at runtime.  A new TypeHandle\n"
  " * is returned if the typename was not seen before; otherwise the same\n"
  " * TypeHandle that was last used for this typename is returned.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_register_dynamic_type_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TypeRegistry::record_derivation(TypeHandle child, TypeHandle parent)
 */
static PyObject *Dtool_TypeRegistry_record_derivation_44(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.record_derivation")) {
    return nullptr;
  }
  // 1-void TypeRegistry::record_derivation(TypeHandle child, TypeHandle parent)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"child", "parent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:record_derivation", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.record_derivation", "TypeHandle");
    }
    TypeHandle param2_local;
    TypeHandle *param2_this = Dtool_Coerce_TypeHandle(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TypeRegistry.record_derivation", "TypeHandle");
    }
    ((*local_this).record_derivation)(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "record_derivation(const TypeRegistry self, TypeHandle child, TypeHandle parent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_record_derivation_44_comment =
  "C++ Interface:\n"
  "record_derivation(const TypeRegistry self, TypeHandle child, TypeHandle parent)\n"
  "\n"
  "/**\n"
  " * Records that the type referenced by child inherits directly from the type\n"
  " * referenced by parent.  In the event of multiple inheritance, this should be\n"
  " * called once for each parent class.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_record_derivation_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TypeRegistry::record_alternate_name(TypeHandle type, std::string const &name)
 */
static PyObject *Dtool_TypeRegistry_record_alternate_name_45(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.record_alternate_name")) {
    return nullptr;
  }
  // 1-void TypeRegistry::record_alternate_name(TypeHandle type, std::string const &name)
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"type", "name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:record_alternate_name", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.record_alternate_name", "TypeHandle");
    }
    ((*local_this).record_alternate_name)(*param1_this, std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "record_alternate_name(const TypeRegistry self, TypeHandle type, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_record_alternate_name_45_comment =
  "C++ Interface:\n"
  "record_alternate_name(const TypeRegistry self, TypeHandle type, str name)\n"
  "\n"
  "/**\n"
  " * Indicates an alternate name for the same type.  This is particularly useful\n"
  " * when a type has changed names, since the type is stored in a Bam file by\n"
  " * name; setting the original name as the alternate will allow the type to be\n"
  " * correctly read from old Bam files.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_record_alternate_name_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TypeRegistry::record_python_type(TypeHandle type, PyObject *python_type)
 */
static PyObject *Dtool_TypeRegistry_record_python_type_46(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.record_python_type")) {
    return nullptr;
  }
  // 1-void TypeRegistry::record_python_type(TypeHandle type, PyObject *python_type)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"type", "python_type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:record_python_type", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.record_python_type", "TypeHandle");
    }
    ((*local_this).record_python_type)(*param1_this, param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "record_python_type(const TypeRegistry self, TypeHandle type, object python_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_record_python_type_46_comment =
  "C++ Interface:\n"
  "record_python_type(const TypeRegistry self, TypeHandle type, object python_type)\n"
  "\n"
  "/**\n"
  " * Records the given Python type pointer in the type registry for the benefit\n"
  " * of interrogate, which expects this to contain a Dtool_PyTypedObject.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_record_python_type_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::find_type(std::string const &name) const
 */
static PyObject *Dtool_TypeRegistry_find_type_47(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeRegistry)) {
    return nullptr;
  }
  // 1-TypeHandle TypeRegistry::find_type(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    TypeHandle *return_value = new TypeHandle(((*(const TypeRegistry*)local_this).find_type)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_type(TypeRegistry self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_find_type_47_comment =
  "C++ Interface:\n"
  "find_type(TypeRegistry self, str name)\n"
  "\n"
  "/**\n"
  " * Looks for a previously-registered type of the given name.  Returns its\n"
  " * TypeHandle if it exists, or TypeHandle::none() if there is no such type.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_find_type_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::find_type_by_id(int id) const
 */
static PyObject *Dtool_TypeRegistry_find_type_by_id_48(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeRegistry)) {
    return nullptr;
  }
  // 1-TypeHandle TypeRegistry::find_type_by_id(int id) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle(((*(const TypeRegistry*)local_this).find_type_by_id)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_type_by_id(TypeRegistry self, int id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_find_type_by_id_48_comment =
  "C++ Interface:\n"
  "find_type_by_id(TypeRegistry self, int id)\n"
  "\n"
  "/**\n"
  " * Looks for a previously-registered type with the given id number (as\n"
  " * returned by TypeHandle::get_index()). Returns its TypeHandle if it exists,\n"
  " * or TypeHandle::none() if there is no such type.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_find_type_by_id_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string TypeRegistry::get_name(TypeHandle type, TypedObject *object) const
 */
static PyObject *Dtool_TypeRegistry_get_name_49(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeRegistry)) {
    return nullptr;
  }
  // 1-std::string TypeRegistry::get_name(TypeHandle type, TypedObject *object) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"type", "object", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_name", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_name", "TypeHandle");
    }
    TypedObject *param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedObject, 2, "TypeRegistry.get_name", false, true);
    if (param2_this != nullptr) {
      std::string return_value = ((*(const TypeRegistry*)local_this).get_name)(*param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_name(TypeRegistry self, TypeHandle type, TypedObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_name_49_comment =
  "C++ Interface:\n"
  "get_name(TypeRegistry self, TypeHandle type, TypedObject object)\n"
  "\n"
  "/**\n"
  " * Returns the name of the indicated type.\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_get_name_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TypeRegistry::is_derived_from(TypeHandle child, TypeHandle base, TypedObject *child_object)
 */
static PyObject *Dtool_TypeRegistry_is_derived_from_50(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.is_derived_from")) {
    return nullptr;
  }
  // 1-bool TypeRegistry::is_derived_from(TypeHandle child, TypeHandle base, TypedObject *child_object)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"child", "base", "child_object", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:is_derived_from", (char **)keyword_list, &param1, &param2, &param3)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.is_derived_from", "TypeHandle");
    }
    TypeHandle param2_local;
    TypeHandle *param2_this = Dtool_Coerce_TypeHandle(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TypeRegistry.is_derived_from", "TypeHandle");
    }
    TypedObject *param3_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_TypedObject, 3, "TypeRegistry.is_derived_from", false, true);
    if (param3_this != nullptr) {
      bool return_value = ((*local_this).is_derived_from)(*param1_this, *param2_this, param3_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_derived_from(const TypeRegistry self, TypeHandle child, TypeHandle base, TypedObject child_object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_is_derived_from_50_comment =
  "C++ Interface:\n"
  "is_derived_from(const TypeRegistry self, TypeHandle child, TypeHandle base, TypedObject child_object)\n"
  "\n"
  "/**\n"
  " * Returns true if the first type is derived from the second type, false\n"
  " * otherwise.\n"
  " *\n"
  " * The \"child_object\" pointer is an optional pointer to the TypedObject class\n"
  " * that owns the child TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertently undefined.\n"
  " *\n"
  " * This function definition follows the definitions for look_up() and\n"
  " * freshen_derivations() just to maximize the chance the the compiler will be\n"
  " * able to inline the above functions.  Yeah, a compiler shouldn't care, but\n"
  " * there's a big different between \"shouldn't\" and \"doesn't\".\n"
  " */";
#else
static const char *Dtool_TypeRegistry_is_derived_from_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TypeRegistry::get_num_typehandles(void)
 */
static PyObject *Dtool_TypeRegistry_get_num_typehandles_51(PyObject *self, PyObject *) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.get_num_typehandles")) {
    return nullptr;
  }
  // 1-int TypeRegistry::get_num_typehandles(void)
  int return_value = ((*local_this).get_num_typehandles)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_num_typehandles_51_comment =
  "C++ Interface:\n"
  "get_num_typehandles(const TypeRegistry self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of unique TypeHandles in the system.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_get_num_typehandles_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::get_typehandle(int n)
 */
static PyObject *Dtool_TypeRegistry_get_typehandle_52(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.get_typehandle")) {
    return nullptr;
  }
  // 1-TypeHandle TypeRegistry::get_typehandle(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle(((*local_this).get_typehandle)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_typehandle(const TypeRegistry self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_typehandle_52_comment =
  "C++ Interface:\n"
  "get_typehandle(const TypeRegistry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth TypeHandle in the system.  See get_num_typehandles().\n"
  " */";
#else
static const char *Dtool_TypeRegistry_get_typehandle_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TypeRegistry::get_num_root_classes(void)
 */
static PyObject *Dtool_TypeRegistry_get_num_root_classes_54(PyObject *self, PyObject *) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.get_num_root_classes")) {
    return nullptr;
  }
  // 1-int TypeRegistry::get_num_root_classes(void)
  int return_value = ((*local_this).get_num_root_classes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_num_root_classes_54_comment =
  "C++ Interface:\n"
  "get_num_root_classes(const TypeRegistry self)\n"
  "\n"
  "/**\n"
  " * Returns the number of root classes--that is, classes that do not inherit\n"
  " * from any other classes--known in the system.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_get_num_root_classes_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::get_root_class(int n)
 */
static PyObject *Dtool_TypeRegistry_get_root_class_55(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.get_root_class")) {
    return nullptr;
  }
  // 1-TypeHandle TypeRegistry::get_root_class(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle(((*local_this).get_root_class)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_root_class(const TypeRegistry self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_root_class_55_comment =
  "C++ Interface:\n"
  "get_root_class(const TypeRegistry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth root class in the system.  See get_num_root_classes().\n"
  " */";
#else
static const char *Dtool_TypeRegistry_get_root_class_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TypeRegistry::get_num_parent_classes(TypeHandle child, TypedObject *child_object) const
 */
static PyObject *Dtool_TypeRegistry_get_num_parent_classes_57(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeRegistry)) {
    return nullptr;
  }
  // 1-int TypeRegistry::get_num_parent_classes(TypeHandle child, TypedObject *child_object) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"child", "child_object", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_num_parent_classes", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_num_parent_classes", "TypeHandle");
    }
    TypedObject *param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedObject, 2, "TypeRegistry.get_num_parent_classes", false, true);
    if (param2_this != nullptr) {
      int return_value = ((*(const TypeRegistry*)local_this).get_num_parent_classes)(*param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_parent_classes(TypeRegistry self, TypeHandle child, TypedObject child_object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_num_parent_classes_57_comment =
  "C++ Interface:\n"
  "get_num_parent_classes(TypeRegistry self, TypeHandle child, TypedObject child_object)\n"
  "\n"
  "/**\n"
  " * Returns the number of parent classes that the indicated type is known to\n"
  " * have.  This may then be used to index into get_parent_class().  The result\n"
  " * will be 0 if this class does not inherit from any other classes, 1 if\n"
  " * normal, single inheritance is in effect, or greater than one if multiple\n"
  " * inheritance is in effect.\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_get_num_parent_classes_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::get_parent_class(TypeHandle child, int index) const
 */
static PyObject *Dtool_TypeRegistry_get_parent_class_58(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeRegistry)) {
    return nullptr;
  }
  // 1-TypeHandle TypeRegistry::get_parent_class(TypeHandle child, int index) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"child", "index", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_parent_class", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_parent_class", "TypeHandle");
    }
    TypeHandle *return_value = new TypeHandle(((*(const TypeRegistry*)local_this).get_parent_class)(*param1_this, (int)param2));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent_class(TypeRegistry self, TypeHandle child, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_parent_class_58_comment =
  "C++ Interface:\n"
  "get_parent_class(TypeRegistry self, TypeHandle child, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth parent class of this type.  The index should be in the\n"
  " * range 0 <= index < get_num_parent_classes().\n"
  " */";
#else
static const char *Dtool_TypeRegistry_get_parent_class_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TypeRegistry::get_num_child_classes(TypeHandle child, TypedObject *child_object) const
 */
static PyObject *Dtool_TypeRegistry_get_num_child_classes_59(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeRegistry)) {
    return nullptr;
  }
  // 1-int TypeRegistry::get_num_child_classes(TypeHandle child, TypedObject *child_object) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"child", "child_object", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_num_child_classes", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_num_child_classes", "TypeHandle");
    }
    TypedObject *param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedObject, 2, "TypeRegistry.get_num_child_classes", false, true);
    if (param2_this != nullptr) {
      int return_value = ((*(const TypeRegistry*)local_this).get_num_child_classes)(*param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_child_classes(TypeRegistry self, TypeHandle child, TypedObject child_object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_num_child_classes_59_comment =
  "C++ Interface:\n"
  "get_num_child_classes(TypeRegistry self, TypeHandle child, TypedObject child_object)\n"
  "\n"
  "/**\n"
  " * Returns the number of child classes that the indicated type is known to\n"
  " * have.  This may then be used to index into get_child_class().\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_get_num_child_classes_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::get_child_class(TypeHandle child, int index) const
 */
static PyObject *Dtool_TypeRegistry_get_child_class_60(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeRegistry)) {
    return nullptr;
  }
  // 1-TypeHandle TypeRegistry::get_child_class(TypeHandle child, int index) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"child", "index", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_child_class", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_child_class", "TypeHandle");
    }
    TypeHandle *return_value = new TypeHandle(((*(const TypeRegistry*)local_this).get_child_class)(*param1_this, (int)param2));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child_class(TypeRegistry self, TypeHandle child, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_child_class_60_comment =
  "C++ Interface:\n"
  "get_child_class(TypeRegistry self, TypeHandle child, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth child class of this type.  The index should be in the range\n"
  " * 0 <= index < get_num_child_classes().\n"
  " */";
#else
static const char *Dtool_TypeRegistry_get_child_class_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::get_parent_towards(TypeHandle child, TypeHandle base, TypedObject *child_object)
 */
static PyObject *Dtool_TypeRegistry_get_parent_towards_61(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.get_parent_towards")) {
    return nullptr;
  }
  // 1-TypeHandle TypeRegistry::get_parent_towards(TypeHandle child, TypeHandle base, TypedObject *child_object)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"child", "base", "child_object", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:get_parent_towards", (char **)keyword_list, &param1, &param2, &param3)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_parent_towards", "TypeHandle");
    }
    TypeHandle param2_local;
    TypeHandle *param2_this = Dtool_Coerce_TypeHandle(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TypeRegistry.get_parent_towards", "TypeHandle");
    }
    TypedObject *param3_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_TypedObject, 3, "TypeRegistry.get_parent_towards", false, true);
    if (param3_this != nullptr) {
      TypeHandle *return_value = new TypeHandle(((*local_this).get_parent_towards)(*param1_this, *param2_this, param3_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent_towards(const TypeRegistry self, TypeHandle child, TypeHandle base, TypedObject child_object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_parent_towards_61_comment =
  "C++ Interface:\n"
  "get_parent_towards(const TypeRegistry self, TypeHandle child, TypeHandle base, TypedObject child_object)\n"
  "\n"
  "/**\n"
  " * Returns the parent of the indicated child class that is in a direct line of\n"
  " * inheritance to the indicated ancestor class.  This is useful in the\n"
  " * presence of multiple inheritance to try to determine what properties an\n"
  " * unknown type may have.\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_get_parent_towards_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void TypeRegistry::reregister_types(void)
 */
static PyObject *Dtool_TypeRegistry_reregister_types_62(PyObject *, PyObject *) {
  // 1-static void TypeRegistry::reregister_types(void)
  (TypeRegistry::reregister_types)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_reregister_types_62_comment =
  "C++ Interface:\n"
  "reregister_types()\n"
  "\n"
  "/**\n"
  " * Walks through the TypeRegistry tree and makes sure that each type that was\n"
  " * previously registered is *still* registered.  This seems to get broken in\n"
  " * certain circumstances when compiled against libc5--it is as if the static\n"
  " * initializer stomps on the _type_handle values of each class after they've\n"
  " * been registered.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_reregister_types_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TypeRegistry::write(std::ostream &out) const
 */
static PyObject *Dtool_TypeRegistry_write_63(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypeRegistry)) {
    return nullptr;
  }
  // 1-void TypeRegistry::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "TypeRegistry.write", false, true);
  if (arg_this != nullptr) {
    ((*(const TypeRegistry*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TypeRegistry self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_write_63_comment =
  "C++ Interface:\n"
  "write(TypeRegistry self, ostream out)\n"
  "\n"
  "/**\n"
  " * Makes an attempt to format the entire TypeRegistry in a nice way that shows\n"
  " * the derivation tree as intelligently as possible.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_write_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline TypeRegistry *TypeRegistry::ptr(void)
 */
static PyObject *Dtool_TypeRegistry_ptr_64(PyObject *, PyObject *) {
  // 1-static inline TypeRegistry *TypeRegistry::ptr(void)
  TypeRegistry *return_value = (TypeRegistry::ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeRegistry, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_ptr_64_comment =
  "C++ Interface:\n"
  "ptr()\n"
  "\n"
  "// ptr() returns the pointer to the global TypeRegistry object.\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the global TypeRegistry object.\n"
  " */";
#else
static const char *Dtool_TypeRegistry_ptr_64_comment = nullptr;
#endif

/**
 * sequence length function for property TypeRegistry::typehandles
 */
static Py_ssize_t Dtool_TypeRegistry_typehandles_Len(PyObject *self) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_typehandles)();
}

/**
 * sequence getter for property TypeRegistry::typehandles
 */
static PyObject *Dtool_TypeRegistry_typehandles_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_typehandles)()) {
    PyErr_SetString(PyExc_IndexError, "TypeRegistry.typehandles[] index out of range");
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // 1-TypeHandle TypeRegistry::get_typehandle(int n)
    TypeHandle *return_value = new TypeHandle(((*local_this).get_typehandle)(index));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call TypeRegistry.get_typehandle() on a const object.");
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_typehandle(const TypeRegistry self, index)\n");
  }
}

static PyObject *Dtool_TypeRegistry_typehandles_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "TypeRegistry.typehandles");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_TypeRegistry_typehandles_Len;
    wrap->_getitem_func = &Dtool_TypeRegistry_typehandles_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property TypeRegistry::root_classes
 */
static Py_ssize_t Dtool_TypeRegistry_root_classes_Len(PyObject *self) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_root_classes)();
}

/**
 * sequence getter for property TypeRegistry::root_classes
 */
static PyObject *Dtool_TypeRegistry_root_classes_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_root_classes)()) {
    PyErr_SetString(PyExc_IndexError, "TypeRegistry.root_classes[] index out of range");
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // 1-TypeHandle TypeRegistry::get_root_class(int n)
    TypeHandle *return_value = new TypeHandle(((*local_this).get_root_class)(index));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call TypeRegistry.get_root_class() on a const object.");
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_root_class(const TypeRegistry self, index)\n");
  }
}

static PyObject *Dtool_TypeRegistry_root_classes_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "TypeRegistry.root_classes");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_TypeRegistry_root_classes_Len;
    wrap->_getitem_func = &Dtool_TypeRegistry_root_classes_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline TypeRegistry::TypeRegistry(TypeRegistry const &) = default
 */
static int Dtool_Init_TypeRegistry(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TypeRegistry() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline TypeRegistry::TypeRegistry(TypeRegistry const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    TypeRegistry const *param0_this = (TypeRegistry *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TypeRegistry, 0, "TypeRegistry.TypeRegistry", true, true);
    if (param0_this != nullptr) {
      TypeRegistry *return_value = new TypeRegistry(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TypeRegistry, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TypeRegistry(const TypeRegistry param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TypeRegistry_get_typehandles(PyObject *self, PyObject *) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_typehandles)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TypeRegistry_get_typehandle_52(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TypeRegistry_get_root_classes(PyObject *self, PyObject *) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_root_classes)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TypeRegistry_get_root_class_55(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_TypeRegistry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TypeRegistry) {
    printf("TypeRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TypeRegistry *local_this = (TypeRegistry *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TypeRegistry) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TypeRegistry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TypeRegistry) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TypedObject
 */
/**
 * Python function wrapper for:
 * virtual TypeHandle TypedObject::get_type(void) const = 0
 */
static PyObject *Dtool_TypedObject_get_type_73(PyObject *self, PyObject *) {
  TypedObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypedObject)) {
    return nullptr;
  }
  // 1-virtual TypeHandle TypedObject::get_type(void) const = 0
  TypeHandle *return_value = new TypeHandle(((*(const TypedObject*)local_this).get_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedObject_get_type_73_comment =
  "C++ Interface:\n"
  "get_type(TypedObject self)\n"
  "\n"
  "// Derived classes should override this function to return get_class_type().\n"
  "\n"
  "// Derived classes should override this function to return get_class_type().\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TypedObject_get_type_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TypedObject::get_type_index(void) const
 */
static PyObject *Dtool_TypedObject_get_type_index_75(PyObject *self, PyObject *) {
  TypedObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypedObject)) {
    return nullptr;
  }
  // 1-inline int TypedObject::get_type_index(void) const
  int return_value = ((*(const TypedObject*)local_this).get_type_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypedObject_get_type_index_75_comment =
  "C++ Interface:\n"
  "get_type_index(TypedObject self)\n"
  "\n"
  "/**\n"
  " * Returns the internal index number associated with this object's TypeHandle,\n"
  " * a unique number for each different type.  This is equivalent to\n"
  " * get_type().get_index().\n"
  " */";
#else
static const char *Dtool_TypedObject_get_type_index_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TypedObject::is_of_type(TypeHandle handle) const
 */
static PyObject *Dtool_TypedObject_is_of_type_76(PyObject *self, PyObject *arg) {
  TypedObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypedObject)) {
    return nullptr;
  }
  // 1-inline bool TypedObject::is_of_type(TypeHandle handle) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TypedObject.is_of_type", "TypeHandle");
  }
  bool return_value = ((*(const TypedObject*)local_this).is_of_type)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_of_type(TypedObject self, TypeHandle handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypedObject_is_of_type_76_comment =
  "C++ Interface:\n"
  "is_of_type(TypedObject self, TypeHandle handle)\n"
  "\n"
  "/**\n"
  " * Returns true if the current object is or derives from the indicated type.\n"
  " */";
#else
static const char *Dtool_TypedObject_is_of_type_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TypedObject::is_exact_type(TypeHandle handle) const
 */
static PyObject *Dtool_TypedObject_is_exact_type_77(PyObject *self, PyObject *arg) {
  TypedObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypedObject)) {
    return nullptr;
  }
  // 1-inline bool TypedObject::is_exact_type(TypeHandle handle) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TypedObject.is_exact_type", "TypeHandle");
  }
  bool return_value = ((*(const TypedObject*)local_this).is_exact_type)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_exact_type(TypedObject self, TypeHandle handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypedObject_is_exact_type_77_comment =
  "C++ Interface:\n"
  "is_exact_type(TypedObject self, TypeHandle handle)\n"
  "\n"
  "/**\n"
  " * Returns true if the current object is the indicated type exactly.\n"
  " */";
#else
static const char *Dtool_TypedObject_is_exact_type_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TypedObject::get_class_type(void)
 */
static PyObject *Dtool_TypedObject_get_class_type_78(PyObject *, PyObject *) {
  // 1-static TypeHandle TypedObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TypedObject::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedObject_get_class_type_78_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TypedObject_get_class_type_78_comment = nullptr;
#endif

static PyObject *Dtool_TypedObject_type_Getter(PyObject *self, void *) {
  const TypedObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypedObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual TypeHandle TypedObject::get_type(void) const = 0
  TypeHandle *return_value = new TypeHandle(((*(const TypedObject*)local_this).get_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

static int Dtool_Init_TypedObject(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TypedObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TypedObject) {
    printf("TypedObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TypedObject *local_this = (TypedObject *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TypedObject) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TypedObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for NeverFreeMemory (NeverFreeMemory)
 */
static PyMethodDef Dtool_Methods_NeverFreeMemory[] = {
  {"get_total_alloc", &Dtool_NeverFreeMemory_get_total_alloc_2, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_alloc_2_comment},
  {"getTotalAlloc", &Dtool_NeverFreeMemory_get_total_alloc_2, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_alloc_2_comment},
  {"get_total_used", &Dtool_NeverFreeMemory_get_total_used_3, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_used_3_comment},
  {"getTotalUsed", &Dtool_NeverFreeMemory_get_total_used_3, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_used_3_comment},
  {"get_total_unused", &Dtool_NeverFreeMemory_get_total_unused_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_unused_4_comment},
  {"getTotalUnused", &Dtool_NeverFreeMemory_get_total_unused_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_unused_4_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NeverFreeMemory = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_NeverFreeMemory = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NeverFreeMemory",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NeverFreeMemory,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NeverFreeMemory,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to allocate bytes of memory from a pool that is never\n"
    " * intended to be freed.  It is particularly useful to support DeletedChain,\n"
    " * which allocates memory in just such a fashion.\n"
    " *\n"
    " * When it is known that memory will not be freed, it is preferable to use\n"
    " * this instead of the standard malloc() (or global_operator_new()) call,\n"
    " * since this will help reduce fragmentation problems in the dynamic heap.\n"
    " * Also, memory allocated from here will exhibit less wasted space.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NeverFreeMemory,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NeverFreeMemory,
    PyType_GenericAlloc,
    Dtool_new_NeverFreeMemory,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NeverFreeMemory,
  Dtool_UpcastInterface_NeverFreeMemory,
  Dtool_DowncastInterface_NeverFreeMemory,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NeverFreeMemory(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NeverFreeMemory._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NeverFreeMemory._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NeverFreeMemory) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NeverFreeMemory)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NeverFreeMemory);
  }
}

/**
 * Python method tables for TypeHandle (TypeHandle)
 */
static PyMethodDef Dtool_Methods_TypeHandle[] = {
  {"make", &Dtool_TypeHandle_make_9, METH_O | METH_STATIC, (const char *)Dtool_TypeHandle_make_9_comment},
  {"compare_to", &Dtool_TypeHandle_compare_to_16, METH_O, (const char *)Dtool_TypeHandle_compare_to_16_comment},
  {"compareTo", &Dtool_TypeHandle_compare_to_16, METH_O, (const char *)Dtool_TypeHandle_compare_to_16_comment},
  {"get_hash", &Dtool_TypeHandle_get_hash_17, METH_NOARGS, (const char *)Dtool_TypeHandle_get_hash_17_comment},
  {"getHash", &Dtool_TypeHandle_get_hash_17, METH_NOARGS, (const char *)Dtool_TypeHandle_get_hash_17_comment},
  {"get_name", (PyCFunction) &Dtool_TypeHandle_get_name_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_name_18_comment},
  {"getName", (PyCFunction) &Dtool_TypeHandle_get_name_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_name_18_comment},
  {"is_derived_from", (PyCFunction) &Dtool_TypeHandle_is_derived_from_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_is_derived_from_19_comment},
  {"isDerivedFrom", (PyCFunction) &Dtool_TypeHandle_is_derived_from_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_is_derived_from_19_comment},
  {"get_num_parent_classes", (PyCFunction) &Dtool_TypeHandle_get_num_parent_classes_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_num_parent_classes_20_comment},
  {"getNumParentClasses", (PyCFunction) &Dtool_TypeHandle_get_num_parent_classes_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_num_parent_classes_20_comment},
  {"get_parent_class", &Dtool_TypeHandle_get_parent_class_21, METH_O, (const char *)Dtool_TypeHandle_get_parent_class_21_comment},
  {"getParentClass", &Dtool_TypeHandle_get_parent_class_21, METH_O, (const char *)Dtool_TypeHandle_get_parent_class_21_comment},
  {"get_num_child_classes", (PyCFunction) &Dtool_TypeHandle_get_num_child_classes_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_num_child_classes_22_comment},
  {"getNumChildClasses", (PyCFunction) &Dtool_TypeHandle_get_num_child_classes_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_num_child_classes_22_comment},
  {"get_child_class", &Dtool_TypeHandle_get_child_class_23, METH_O, (const char *)Dtool_TypeHandle_get_child_class_23_comment},
  {"getChildClass", &Dtool_TypeHandle_get_child_class_23, METH_O, (const char *)Dtool_TypeHandle_get_child_class_23_comment},
  {"get_parent_towards", (PyCFunction) &Dtool_TypeHandle_get_parent_towards_24, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_parent_towards_24_comment},
  {"getParentTowards", (PyCFunction) &Dtool_TypeHandle_get_parent_towards_24, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_parent_towards_24_comment},
  {"get_memory_usage", &Dtool_TypeHandle_get_memory_usage_26, METH_O, (const char *)Dtool_TypeHandle_get_memory_usage_26_comment},
  {"getMemoryUsage", &Dtool_TypeHandle_get_memory_usage_26, METH_O, (const char *)Dtool_TypeHandle_get_memory_usage_26_comment},
  {"inc_memory_usage", (PyCFunction) &Dtool_TypeHandle_inc_memory_usage_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_inc_memory_usage_27_comment},
  {"incMemoryUsage", (PyCFunction) &Dtool_TypeHandle_inc_memory_usage_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_inc_memory_usage_27_comment},
  {"dec_memory_usage", (PyCFunction) &Dtool_TypeHandle_dec_memory_usage_28, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_dec_memory_usage_28_comment},
  {"decMemoryUsage", (PyCFunction) &Dtool_TypeHandle_dec_memory_usage_28, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_dec_memory_usage_28_comment},
  {"get_index", &Dtool_TypeHandle_get_index_29, METH_NOARGS, (const char *)Dtool_TypeHandle_get_index_29_comment},
  {"getIndex", &Dtool_TypeHandle_get_index_29, METH_NOARGS, (const char *)Dtool_TypeHandle_get_index_29_comment},
  {"output", &Dtool_TypeHandle_output_30, METH_O, (const char *)Dtool_TypeHandle_output_30_comment},
  {"none", &Dtool_TypeHandle_none_31, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypeHandle_none_31_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TypeHandle slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_TypeHandle_operator_typecast_bool_32_nb_bool(PyObject *self) {
  TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TypeHandle slot tp_compare -> compare_to
//////////////////
static int Dtool_TypeHandle_compare_to_16_tp_compare(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int TypeHandle::compare_to(TypeHandle const &other) const
  TypeHandle arg_local;
  TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TypeHandle.compare_to", "TypeHandle");
    return -1;
  }
  int return_value = ((*(const TypeHandle*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(TypeHandle self, const TypeHandle other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TypeHandle slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_TypeHandle_get_hash_17_tp_hash(PyObject *self) {
  TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_hash)();
}

//////////////////
//  A __repr__ function
//     TypeHandle
//////////////////
static PyObject *Dtool_Repr_TypeHandle(PyObject *self) {
  TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     TypeHandle
//////////////////
static PyObject *Dtool_RichCompare_TypeHandle(PyObject *self, PyObject *arg, int op) {
  TypeHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool TypeHandle::operator ==(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const TypeHandle*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool TypeHandle::operator !=(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const TypeHandle*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool TypeHandle::operator <(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const TypeHandle*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LE:
    {
      // 1-inline bool TypeHandle::operator <=(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const TypeHandle*)local_this).operator <=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GT:
    {
      // 1-inline bool TypeHandle::operator >(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const TypeHandle*)local_this).operator >)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GE:
    {
      // 1-inline bool TypeHandle::operator >=(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const TypeHandle*)local_this).operator >=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_TypeHandle_compare_to_16_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_TypeHandle[] = {
  {(char *)"index", &Dtool_TypeHandle_index_Getter, nullptr, nullptr, nullptr},
  {(char *)"name", &Dtool_TypeHandle_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"parent_classes", &Dtool_TypeHandle_parent_classes_Getter, nullptr, nullptr, nullptr},
  {(char *)"child_classes", &Dtool_TypeHandle_child_classes_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TypeHandle = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_TypeHandle_operator_typecast_bool_32_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TypeHandle = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TypeHandle",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TypeHandle,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_TypeHandle_compare_to_16_tp_compare,
#endif
    &Dtool_Repr_TypeHandle,
    &Dtool_NumberMethods_TypeHandle,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &Dtool_TypeHandle_get_hash_17_tp_hash,
    nullptr,
    &Dtool_Repr_TypeHandle,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * TypeHandle is the identifier used to differentiate C++ class types.  Any\n"
    " * C++ classes that inherit from some base class, and must be differentiated\n"
    " * at run time, should store a static TypeHandle object that can be queried\n"
    " * through a static member function named get_class_type().  Most of the time,\n"
    " * it is also desirable to inherit from TypedObject, which provides some\n"
    " * virtual functions to return the TypeHandle for a particular instance.\n"
    " *\n"
    " * At its essence, a TypeHandle is simply a unique identifier that is assigned\n"
    " * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so\n"
    " * that ancestry of a particular type may be queried, and the type name may be\n"
    " * retrieved for run-time display.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_TypeHandle,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TypeHandle,
    nullptr, // tp_members
    Dtool_Properties_TypeHandle,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TypeHandle,
    PyType_GenericAlloc,
    Dtool_new_TypeHandle,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypeHandle,
  Dtool_UpcastInterface_TypeHandle,
  Dtool_DowncastInterface_TypeHandle,
  nullptr,
  (CoerceFunction)Dtool_Coerce_TypeHandle,
};

static void Dtool_PyModuleClassInit_TypeHandle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TypeHandle._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_TypeHandle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TypeHandle::MemoryClass;
    PyDict_SetItemString(dict, "MC_singleton", Dtool_WrapValue(TypeHandle::MC_singleton));
    PyDict_SetItemString(dict, "MCSingleton", Dtool_WrapValue(TypeHandle::MC_singleton));
    PyDict_SetItemString(dict, "MC_array", Dtool_WrapValue(TypeHandle::MC_array));
    PyDict_SetItemString(dict, "MCArray", Dtool_WrapValue(TypeHandle::MC_array));
    PyDict_SetItemString(dict, "MC_deleted_chain_active", Dtool_WrapValue(TypeHandle::MC_deleted_chain_active));
    PyDict_SetItemString(dict, "MCDeletedChainActive", Dtool_WrapValue(TypeHandle::MC_deleted_chain_active));
    PyDict_SetItemString(dict, "MC_deleted_chain_inactive", Dtool_WrapValue(TypeHandle::MC_deleted_chain_inactive));
    PyDict_SetItemString(dict, "MCDeletedChainInactive", Dtool_WrapValue(TypeHandle::MC_deleted_chain_inactive));
    PyDict_SetItemString(dict, "MC_limit", Dtool_WrapValue(TypeHandle::MC_limit));
    PyDict_SetItemString(dict, "MCLimit", Dtool_WrapValue(TypeHandle::MC_limit));
    if (PyType_Ready((PyTypeObject *)&Dtool_TypeHandle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypeHandle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypeHandle);
  }
}

/**
 * Python method tables for TypeRegistry (TypeRegistry)
 */
static PyMethodDef Dtool_Methods_TypeRegistry[] = {
  {"register_dynamic_type", &Dtool_TypeRegistry_register_dynamic_type_43, METH_O, (const char *)Dtool_TypeRegistry_register_dynamic_type_43_comment},
  {"registerDynamicType", &Dtool_TypeRegistry_register_dynamic_type_43, METH_O, (const char *)Dtool_TypeRegistry_register_dynamic_type_43_comment},
  {"record_derivation", (PyCFunction) &Dtool_TypeRegistry_record_derivation_44, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_record_derivation_44_comment},
  {"recordDerivation", (PyCFunction) &Dtool_TypeRegistry_record_derivation_44, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_record_derivation_44_comment},
  {"record_alternate_name", (PyCFunction) &Dtool_TypeRegistry_record_alternate_name_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_record_alternate_name_45_comment},
  {"recordAlternateName", (PyCFunction) &Dtool_TypeRegistry_record_alternate_name_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_record_alternate_name_45_comment},
  {"record_python_type", (PyCFunction) &Dtool_TypeRegistry_record_python_type_46, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_record_python_type_46_comment},
  {"recordPythonType", (PyCFunction) &Dtool_TypeRegistry_record_python_type_46, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_record_python_type_46_comment},
  {"find_type", &Dtool_TypeRegistry_find_type_47, METH_O, (const char *)Dtool_TypeRegistry_find_type_47_comment},
  {"findType", &Dtool_TypeRegistry_find_type_47, METH_O, (const char *)Dtool_TypeRegistry_find_type_47_comment},
  {"find_type_by_id", &Dtool_TypeRegistry_find_type_by_id_48, METH_O, (const char *)Dtool_TypeRegistry_find_type_by_id_48_comment},
  {"findTypeById", &Dtool_TypeRegistry_find_type_by_id_48, METH_O, (const char *)Dtool_TypeRegistry_find_type_by_id_48_comment},
  {"get_name", (PyCFunction) &Dtool_TypeRegistry_get_name_49, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_name_49_comment},
  {"getName", (PyCFunction) &Dtool_TypeRegistry_get_name_49, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_name_49_comment},
  {"is_derived_from", (PyCFunction) &Dtool_TypeRegistry_is_derived_from_50, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_is_derived_from_50_comment},
  {"isDerivedFrom", (PyCFunction) &Dtool_TypeRegistry_is_derived_from_50, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_is_derived_from_50_comment},
  {"get_num_typehandles", &Dtool_TypeRegistry_get_num_typehandles_51, METH_NOARGS, (const char *)Dtool_TypeRegistry_get_num_typehandles_51_comment},
  {"getNumTypehandles", &Dtool_TypeRegistry_get_num_typehandles_51, METH_NOARGS, (const char *)Dtool_TypeRegistry_get_num_typehandles_51_comment},
  {"get_typehandle", &Dtool_TypeRegistry_get_typehandle_52, METH_O, (const char *)Dtool_TypeRegistry_get_typehandle_52_comment},
  {"getTypehandle", &Dtool_TypeRegistry_get_typehandle_52, METH_O, (const char *)Dtool_TypeRegistry_get_typehandle_52_comment},
  {"get_num_root_classes", &Dtool_TypeRegistry_get_num_root_classes_54, METH_NOARGS, (const char *)Dtool_TypeRegistry_get_num_root_classes_54_comment},
  {"getNumRootClasses", &Dtool_TypeRegistry_get_num_root_classes_54, METH_NOARGS, (const char *)Dtool_TypeRegistry_get_num_root_classes_54_comment},
  {"get_root_class", &Dtool_TypeRegistry_get_root_class_55, METH_O, (const char *)Dtool_TypeRegistry_get_root_class_55_comment},
  {"getRootClass", &Dtool_TypeRegistry_get_root_class_55, METH_O, (const char *)Dtool_TypeRegistry_get_root_class_55_comment},
  {"get_num_parent_classes", (PyCFunction) &Dtool_TypeRegistry_get_num_parent_classes_57, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_num_parent_classes_57_comment},
  {"getNumParentClasses", (PyCFunction) &Dtool_TypeRegistry_get_num_parent_classes_57, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_num_parent_classes_57_comment},
  {"get_parent_class", (PyCFunction) &Dtool_TypeRegistry_get_parent_class_58, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_parent_class_58_comment},
  {"getParentClass", (PyCFunction) &Dtool_TypeRegistry_get_parent_class_58, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_parent_class_58_comment},
  {"get_num_child_classes", (PyCFunction) &Dtool_TypeRegistry_get_num_child_classes_59, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_num_child_classes_59_comment},
  {"getNumChildClasses", (PyCFunction) &Dtool_TypeRegistry_get_num_child_classes_59, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_num_child_classes_59_comment},
  {"get_child_class", (PyCFunction) &Dtool_TypeRegistry_get_child_class_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_child_class_60_comment},
  {"getChildClass", (PyCFunction) &Dtool_TypeRegistry_get_child_class_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_child_class_60_comment},
  {"get_parent_towards", (PyCFunction) &Dtool_TypeRegistry_get_parent_towards_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_parent_towards_61_comment},
  {"getParentTowards", (PyCFunction) &Dtool_TypeRegistry_get_parent_towards_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_parent_towards_61_comment},
  {"reregister_types", &Dtool_TypeRegistry_reregister_types_62, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypeRegistry_reregister_types_62_comment},
  {"reregisterTypes", &Dtool_TypeRegistry_reregister_types_62, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypeRegistry_reregister_types_62_comment},
  {"write", &Dtool_TypeRegistry_write_63, METH_O, (const char *)Dtool_TypeRegistry_write_63_comment},
  {"ptr", &Dtool_TypeRegistry_ptr_64, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypeRegistry_ptr_64_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_typehandles", (PyCFunction) &MakeSeq_TypeRegistry_get_typehandles, METH_NOARGS, nullptr},
  { "getTypehandles", (PyCFunction) &MakeSeq_TypeRegistry_get_typehandles, METH_NOARGS, nullptr},
  {"get_root_classes", (PyCFunction) &MakeSeq_TypeRegistry_get_root_classes, METH_NOARGS, nullptr},
  { "getRootClasses", (PyCFunction) &MakeSeq_TypeRegistry_get_root_classes, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     TypeRegistry
//////////////////
static PyObject *Dtool_Str_TypeRegistry(PyObject *self) {
  TypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_TypeRegistry[] = {
  {(char *)"typehandles", &Dtool_TypeRegistry_typehandles_Getter, nullptr, nullptr, nullptr},
  {(char *)"root_classes", &Dtool_TypeRegistry_root_classes_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TypeRegistry = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TypeRegistry = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TypeRegistry = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TypeRegistry = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TypeRegistry = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TypeRegistry = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TypeRegistry",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TypeRegistry,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TypeRegistry,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TypeRegistry,
    &Dtool_SequenceMethods_TypeRegistry,
    &Dtool_MappingMethods_TypeRegistry,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_TypeRegistry,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TypeRegistry,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The TypeRegistry class maintains all the assigned TypeHandles in a given\n"
    " * system.  There should be only one TypeRegistry class during the lifetime of\n"
    " * the application.  It will be created on the local heap initially, and it\n"
    " * should be migrated to shared memory as soon as shared memory becomes\n"
    " * available.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TypeRegistry,
    nullptr, // tp_members
    Dtool_Properties_TypeRegistry,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TypeRegistry,
    PyType_GenericAlloc,
    Dtool_new_TypeRegistry,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypeRegistry,
  Dtool_UpcastInterface_TypeRegistry,
  Dtool_DowncastInterface_TypeRegistry,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TypeRegistry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TypeRegistry._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TypeRegistry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TypeRegistry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypeRegistry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypeRegistry);
  }
}

/**
 * Python method tables for TypedObject (TypedObject)
 */
static PyMethodDef Dtool_Methods_TypedObject[] = {
  {"get_type", &Dtool_TypedObject_get_type_73, METH_NOARGS, (const char *)Dtool_TypedObject_get_type_73_comment},
  {"getType", &Dtool_TypedObject_get_type_73, METH_NOARGS, (const char *)Dtool_TypedObject_get_type_73_comment},
  {"get_type_index", &Dtool_TypedObject_get_type_index_75, METH_NOARGS, (const char *)Dtool_TypedObject_get_type_index_75_comment},
  {"getTypeIndex", &Dtool_TypedObject_get_type_index_75, METH_NOARGS, (const char *)Dtool_TypedObject_get_type_index_75_comment},
  {"is_of_type", &Dtool_TypedObject_is_of_type_76, METH_O, (const char *)Dtool_TypedObject_is_of_type_76_comment},
  {"isOfType", &Dtool_TypedObject_is_of_type_76, METH_O, (const char *)Dtool_TypedObject_is_of_type_76_comment},
  {"is_exact_type", &Dtool_TypedObject_is_exact_type_77, METH_O, (const char *)Dtool_TypedObject_is_exact_type_77_comment},
  {"isExactType", &Dtool_TypedObject_is_exact_type_77, METH_O, (const char *)Dtool_TypedObject_is_exact_type_77_comment},
  {"get_class_type", &Dtool_TypedObject_get_class_type_78, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedObject_get_class_type_78_comment},
  {"getClassType", &Dtool_TypedObject_get_class_type_78, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedObject_get_class_type_78_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_TypedObject[] = {
  {(char *)"type", &Dtool_TypedObject_type_Getter, nullptr, (char *)
    "// Returns the TypeHandle representing this object's type.",
    nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TypedObject = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TypedObject = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TypedObject = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TypedObject = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TypedObject = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TypedObject = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TypedObject",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TypedObject,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TypedObject,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TypedObject,
    &Dtool_SequenceMethods_TypedObject,
    &Dtool_MappingMethods_TypedObject,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TypedObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an abstract class that all classes which use TypeHandle, and also\n"
    " * provide virtual functions to support polymorphism, should inherit from.\n"
    " * Each derived class should define get_type(), which should return the\n"
    " * specific type of the derived class.  Inheriting from this automatically\n"
    " * provides support for is_of_type() and is_exact_type().\n"
    " *\n"
    " * All classes that inherit directly or indirectly from TypedObject should\n"
    " * redefine get_type() and force_init_type(), as shown below.  Some classes\n"
    " * that do not inherit from TypedObject may still declare TypeHandles for\n"
    " * themselves by defining methods called get_class_type() and init_type().\n"
    " * Classes such as these may serve as base classes, but the dynamic type\n"
    " * identification system will be limited.  Classes that do not inherit from\n"
    " * TypedObject need not define the virtual functions get_type() and\n"
    " * force_init_type() (or any other virtual functions).\n"
    " *\n"
    " * There is a specific layout for defining the overrides from this class.\n"
    " * Keeping the definitions formatted just like these examples will allow\n"
    " * someone in the future to use a sed (or similar) script to make global\n"
    " * changes, if necessary.  Avoid rearranging the braces or the order of the\n"
    " * functions unless you're ready to change them in every file all at once.\n"
    " *\n"
    " * What follows are some examples that can be used in new classes that you\n"
    " * create.\n"
    " *\n"
    " * @par In the class definition (.h file):\n"
    " * @code\n"
    " * public:\n"
    " *   static TypeHandle get_class_type() {\n"
    " *     return _type_handle;\n"
    " *   }\n"
    " *   static void init_type() {\n"
    " *     <<<BaseClassOne>>>::init_type();\n"
    " *     <<<BaseClassTwo>>>::init_type();\n"
    " *     <<<BaseClassN>>>::init_type();\n"
    " *     register_type(_type_handle, \"<<<ThisClassStringName>>>\",\n"
    " *                   <<<BaseClassOne>>>::get_class_type(),\n"
    " *                   <<<BaseClassTwo>>>::get_class_type(),\n"
    " *                   <<<BaseClassN>>>::get_class_type());\n"
    " *   }\n"
    " *   virtual TypeHandle get_type() const {\n"
    " *     return get_class_type();\n"
    " *   }\n"
    " *   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}\n"
    " *\n"
    " * private:\n"
    " *   static TypeHandle _type_handle;\n"
    " * @endcode\n"
    " *\n"
    " * @par In the class .cxx file:\n"
    " * @code\n"
    " * TypeHandle <<<ThisClassStringName>>>::_type_handle;\n"
    " * @endcode\n"
    " *\n"
    " * @par In the class config_<<<PackageName>>>.cxx file:\n"
    " * @code\n"
    " * ConfigureFn(config_<<<PackageName>>>) {\n"
    " *   <<<ClassOne>>>::init_type();\n"
    " *   <<<ClassTwo>>>::init_type();\n"
    " *   <<<ClassN>>>::init_type();\n"
    " * }\n"
    " * @endcode\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TypedObject,
    nullptr, // tp_members
    Dtool_Properties_TypedObject,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TypedObject,
    PyType_GenericAlloc,
    Dtool_new_TypedObject,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypedObject,
  Dtool_UpcastInterface_TypedObject,
  Dtool_DowncastInterface_TypedObject,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TypedObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TypedObject._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TypedObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TypedObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypedObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypedObject);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3dtoolbase_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    TypedObject::init_type();
    TypeHandle handle = TypedObject::get_class_type();
    Dtool_TypedObject._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TypedObject);
  }
}

void Dtool_libp3dtoolbase_BuildInstants(PyObject *module) {
  (void) module;
  PyModule_AddStringConstant(module, "END_PUBLISH", "__end_publish");
  PyModule_AddStringConstant(module, "ENDPUBLISH", "__end_publish");
  // NeverFreeMemory
  Dtool_PyModuleClassInit_NeverFreeMemory(module);
  PyModule_AddObject(module, "NeverFreeMemory", (PyObject *)&Dtool_NeverFreeMemory);
  // TypeHandle
  Dtool_PyModuleClassInit_TypeHandle(module);
  PyModule_AddObject(module, "TypeHandle", (PyObject *)&Dtool_TypeHandle);
  // TypeRegistry
  Dtool_PyModuleClassInit_TypeRegistry(module);
  PyModule_AddObject(module, "TypeRegistry", (PyObject *)&Dtool_TypeRegistry);
  // TypedObject
  Dtool_PyModuleClassInit_TypedObject(module);
  PyModule_AddObject(module, "TypedObject", (PyObject *)&Dtool_TypedObject);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3dtoolbase_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3dtoolbase_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583612446,  /* file_identifier */
  "libp3dtoolbase",  /* library_name */
  "NSJh",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3dtoolbase.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  160  /* next_index */
};

Configure(_in_configure_libp3dtoolbase);
ConfigureFn(_in_configure_libp3dtoolbase) {
  interrogate_request_module(&_in_module_def);
}

