/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/recorder -Ipanda/src/recorder -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3recorder_igate.cxx -od built/pandac/input/libp3recorder.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/recorder -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3recorder config_recorder.h mouseRecorder.h p3recorder_composite1.cxx p3recorder_composite2.cxx recorderBase.h recorderController.h recorderFrame.h recorderHeader.h recorderTable.h socketStreamRecorder.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "buttonEventList.h"
#include "config_recorder.h"
#include "dataNode.h"
#include "dataNodeTransmit.h"
#include "dconfig.h"
#include "linmath_events.h"
#include "mouseRecorder.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "recorderBase.h"
#include "recorderController.h"
#include "recorderFrame.h"
#include "recorderHeader.h"
#include "recorderTable.h"
#include "socketStreamRecorder.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class RecorderBase
 */
typedef RecorderBase RecorderBase_localtype;
Define_Module_ClassRef(panda3d.core, RecorderBase, RecorderBase_localtype, RecorderBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RecorderBase = &Dtool_RecorderBase;
static void Dtool_PyModuleClassInit_RecorderBase(PyObject *module);

/**
 * Forward declarations for top-level class MouseRecorder
 */
typedef MouseRecorder MouseRecorder_localtype;
Define_Module_ClassRef(panda3d.core, MouseRecorder, MouseRecorder_localtype, MouseRecorder);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseRecorder = &Dtool_MouseRecorder;
static void Dtool_PyModuleClassInit_MouseRecorder(PyObject *module);

/**
 * Forward declarations for top-level class RecorderController
 */
typedef RecorderController RecorderController_localtype;
Define_Module_ClassRef(panda3d.core, RecorderController, RecorderController_localtype, RecorderController);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RecorderController = &Dtool_RecorderController;
static void Dtool_PyModuleClassInit_RecorderController(PyObject *module);

/**
 * Forward declarations for top-level class SocketStreamRecorder
 */
typedef SocketStreamRecorder SocketStreamRecorder_localtype;
Define_Module_ClassRef(panda3d.core, SocketStreamRecorder, SocketStreamRecorder_localtype, SocketStreamRecorder);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SocketStreamRecorder = &Dtool_SocketStreamRecorder;
static void Dtool_PyModuleClassInit_SocketStreamRecorder(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"RecorderBase", &Dtool_RecorderBase},
  {"MouseRecorder", &Dtool_MouseRecorder},
  {"RecorderController", &Dtool_RecorderController},
  {"SocketStreamRecorder", &Dtool_SocketStreamRecorder},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[0].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[3].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[4].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[5].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[6].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[7].type)
  {"Datagram", nullptr},
#define Dtool_Ptr_Datagram (imports[8].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[9].type)
  {"DataNode", nullptr},
#define Dtool_Ptr_DataNode (imports[10].type)
  {"SocketStream", nullptr},
#define Dtool_Ptr_SocketStream (imports[11].type)
  {nullptr, nullptr},
};
#endif

// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// Datagram
#ifndef LINK_ALL_STATIC
inline static Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced) {
  nassertr(Dtool_Ptr_Datagram != nullptr, nullptr);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != nullptr, nullptr);
  return ((Datagram *(*)(PyObject *, Datagram &))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced);
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// DataNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DataNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DataNode = &Dtool_DataNode;
#endif
// SocketStream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_SocketStream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_SocketStream = &Dtool_SocketStream;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class RecorderBase
 */
/**
 * Python function wrapper for:
 * inline bool RecorderBase::is_recording(void) const
 */
static PyObject *Dtool_RecorderBase_is_recording_3(PyObject *self, PyObject *) {
  RecorderBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderBase)) {
    return nullptr;
  }
  // 1-inline bool RecorderBase::is_recording(void) const
  bool return_value = ((*(const RecorderBase*)local_this).is_recording)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderBase_is_recording_3_comment =
  "C++ Interface:\n"
  "is_recording(RecorderBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if this recorder is presently recording data for saving to a\n"
  " * session file, false otherwise.  If this is true, record_data() will be\n"
  " * called from time to time.\n"
  " */";
#else
static const char *Dtool_RecorderBase_is_recording_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderBase::is_playing(void) const
 */
static PyObject *Dtool_RecorderBase_is_playing_4(PyObject *self, PyObject *) {
  RecorderBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderBase)) {
    return nullptr;
  }
  // 1-inline bool RecorderBase::is_playing(void) const
  bool return_value = ((*(const RecorderBase*)local_this).is_playing)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderBase_is_playing_4_comment =
  "C++ Interface:\n"
  "is_playing(RecorderBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if this recorder is presently playing back data from session\n"
  " * file, false otherwise.  If this is true, play_data() will be called from\n"
  " * time to time.\n"
  " */";
#else
static const char *Dtool_RecorderBase_is_playing_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RecorderBase::get_class_type(void)
 */
static PyObject *Dtool_RecorderBase_get_class_type_5(PyObject *, PyObject *) {
  // 1-static TypeHandle RecorderBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RecorderBase::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RecorderBase_get_class_type_5_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RecorderBase_get_class_type_5_comment = nullptr;
#endif

static int Dtool_Init_RecorderBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_RecorderBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RecorderBase) {
    printf("RecorderBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RecorderBase *local_this = (RecorderBase *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RecorderBase) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RecorderBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RecorderBase) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MouseRecorder
 */
/**
 * Python function wrapper for:
 * static TypeHandle MouseRecorder::get_class_type(void)
 */
static PyObject *Dtool_MouseRecorder_get_class_type_14(PyObject *, PyObject *) {
  // 1-static TypeHandle MouseRecorder::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MouseRecorder::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseRecorder_get_class_type_14_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MouseRecorder_get_class_type_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DataNode *MouseRecorder::upcast_to_DataNode(void)
 */
static PyObject *Dtool_MouseRecorder_upcast_to_DataNode_8(PyObject *self, PyObject *) {
  MouseRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseRecorder, (void **)&local_this, "MouseRecorder.upcast_to_DataNode")) {
    return nullptr;
  }
  // 1-DataNode *MouseRecorder::upcast_to_DataNode(void)
  DataNode *return_value = (DataNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DataNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MouseRecorder_upcast_to_DataNode_8_comment =
  "C++ Interface:\n"
  "upcast_to_DataNode(const MouseRecorder self)\n"
  "\n"
  "upcast from MouseRecorder to DataNode";
#else
static const char *Dtool_MouseRecorder_upcast_to_DataNode_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * RecorderBase *MouseRecorder::upcast_to_RecorderBase(void)
 */
static PyObject *Dtool_MouseRecorder_upcast_to_RecorderBase_10(PyObject *self, PyObject *) {
  MouseRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseRecorder, (void **)&local_this, "MouseRecorder.upcast_to_RecorderBase")) {
    return nullptr;
  }
  // 1-RecorderBase *MouseRecorder::upcast_to_RecorderBase(void)
  RecorderBase *return_value = (RecorderBase *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_RecorderBase, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseRecorder_upcast_to_RecorderBase_10_comment =
  "C++ Interface:\n"
  "upcast_to_RecorderBase(const MouseRecorder self)\n"
  "\n"
  "upcast from MouseRecorder to RecorderBase";
#else
static const char *Dtool_MouseRecorder_upcast_to_RecorderBase_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit MouseRecorder::MouseRecorder(std::string const &name)
 */
static int Dtool_Init_MouseRecorder(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "MouseRecorder() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit MouseRecorder::MouseRecorder(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      MouseRecorder *return_value = new MouseRecorder(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseRecorder, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MouseRecorder(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MouseRecorder(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MouseRecorder) {
    printf("MouseRecorder ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MouseRecorder *local_this = (MouseRecorder *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MouseRecorder) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_RecorderBase) {
    return (RecorderBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MouseRecorder(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MouseRecorder) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_RecorderBase) {
    RecorderBase* other_this = (RecorderBase*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MouseRecorder*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RecorderController
 */
/**
 * Python function wrapper for:
 * bool RecorderController::begin_record(Filename const &filename)
 */
static PyObject *Dtool_RecorderController_begin_record_18(PyObject *self, PyObject *arg) {
  RecorderController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.begin_record")) {
    return nullptr;
  }
  // 1-bool RecorderController::begin_record(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RecorderController.begin_record", "Filename");
  }
  bool return_value = ((*local_this).begin_record)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_record(const RecorderController self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_begin_record_18_comment =
  "C++ Interface:\n"
  "begin_record(const RecorderController self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Begins recording data to the indicated filename.  All of the recorders in\n"
  " * use should already have been added.\n"
  " */";
#else
static const char *Dtool_RecorderController_begin_record_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool RecorderController::begin_playback(Filename const &filename)
 */
static PyObject *Dtool_RecorderController_begin_playback_19(PyObject *self, PyObject *arg) {
  RecorderController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.begin_playback")) {
    return nullptr;
  }
  // 1-bool RecorderController::begin_playback(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RecorderController.begin_playback", "Filename");
  }
  bool return_value = ((*local_this).begin_playback)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_playback(const RecorderController self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_begin_playback_19_comment =
  "C++ Interface:\n"
  "begin_playback(const RecorderController self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Begins playing back data from the indicated filename.  All of the recorders\n"
  " * in use should already have been added, although this may define additional\n"
  " * recorders if they are present in the file (these new recorders will not be\n"
  " * used).  This may also undefine recorders that were previously added but are\n"
  " * not present in the file.\n"
  " */";
#else
static const char *Dtool_RecorderController_begin_playback_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RecorderController::close(void)
 */
static PyObject *Dtool_RecorderController_close_20(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.close")) {
    return nullptr;
  }
  // 1-void RecorderController::close(void)
  ((*local_this).close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_close_20_comment =
  "C++ Interface:\n"
  "close(const RecorderController self)\n"
  "\n"
  "/**\n"
  " * Finishes recording data to the indicated filename.\n"
  " */";
#else
static const char *Dtool_RecorderController_close_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline time_t RecorderController::get_start_time(void) const
 */
static PyObject *Dtool_RecorderController_get_start_time_21(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderController)) {
    return nullptr;
  }
  // 1-inline time_t RecorderController::get_start_time(void) const
  time_t return_value = ((*(const RecorderController*)local_this).get_start_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_start_time_21_comment =
  "C++ Interface:\n"
  "get_start_time(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns the time (and date) at which the current session was originally\n"
  " * recorded (or, in recording mode, the time at which the current session\n"
  " * began).\n"
  " */";
#else
static const char *Dtool_RecorderController_get_start_time_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RecorderController::set_random_seed(int random_seed)
 */
static PyObject *Dtool_RecorderController_set_random_seed_22(PyObject *self, PyObject *arg) {
  RecorderController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.set_random_seed")) {
    return nullptr;
  }
  // 1-inline void RecorderController::set_random_seed(int random_seed)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_random_seed)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_random_seed(const RecorderController self, int random_seed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_set_random_seed_22_comment =
  "C++ Interface:\n"
  "set_random_seed(const RecorderController self, int random_seed)\n"
  "\n"
  "/**\n"
  " * Indicates an arbitrary number to be recorded in the session file as a\n"
  " * random seed, should the application wish to take advantage of it.  This\n"
  " * must be set before begin_record() is called.\n"
  " */";
#else
static const char *Dtool_RecorderController_set_random_seed_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RecorderController::get_random_seed(void) const
 */
static PyObject *Dtool_RecorderController_get_random_seed_23(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderController)) {
    return nullptr;
  }
  // 1-inline int RecorderController::get_random_seed(void) const
  int return_value = ((*(const RecorderController*)local_this).get_random_seed)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_random_seed_23_comment =
  "C++ Interface:\n"
  "get_random_seed(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns the random seed that was set by a previous call to\n"
  " * set_random_seed(), or the number read from the session file after\n"
  " * begin_playback() has been called.\n"
  " */";
#else
static const char *Dtool_RecorderController_get_random_seed_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::is_recording(void) const
 */
static PyObject *Dtool_RecorderController_is_recording_24(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderController)) {
    return nullptr;
  }
  // 1-inline bool RecorderController::is_recording(void) const
  bool return_value = ((*(const RecorderController*)local_this).is_recording)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_is_recording_24_comment =
  "C++ Interface:\n"
  "is_recording(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns true if the controller has been opened for output, false otherwise.\n"
  " */";
#else
static const char *Dtool_RecorderController_is_recording_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::is_playing(void) const
 */
static PyObject *Dtool_RecorderController_is_playing_25(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderController)) {
    return nullptr;
  }
  // 1-inline bool RecorderController::is_playing(void) const
  bool return_value = ((*(const RecorderController*)local_this).is_playing)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_is_playing_25_comment =
  "C++ Interface:\n"
  "is_playing(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns true if the controller has been opened for input, false otherwise.\n"
  " */";
#else
static const char *Dtool_RecorderController_is_playing_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::is_open(void) const
 */
static PyObject *Dtool_RecorderController_is_open_26(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderController)) {
    return nullptr;
  }
  // 1-inline bool RecorderController::is_open(void) const
  bool return_value = ((*(const RecorderController*)local_this).is_open)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_is_open_26_comment =
  "C++ Interface:\n"
  "is_open(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns true if the controller has been opened for either input or output,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_RecorderController_is_open_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &RecorderController::get_filename(void) const
 */
static PyObject *Dtool_RecorderController_get_filename_27(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderController)) {
    return nullptr;
  }
  // 1-inline Filename const &RecorderController::get_filename(void) const
  Filename const *return_value = &(((*(const RecorderController*)local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_filename_27_comment =
  "C++ Interface:\n"
  "get_filename(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns the filename that was passed to the most recent call to\n"
  " * begin_record() or begin_playback().\n"
  " */";
#else
static const char *Dtool_RecorderController_get_filename_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::is_error(void)
 */
static PyObject *Dtool_RecorderController_is_error_28(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.is_error")) {
    return nullptr;
  }
  // 1-inline bool RecorderController::is_error(void)
  bool return_value = ((*local_this).is_error)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_is_error_28_comment =
  "C++ Interface:\n"
  "is_error(const RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns true if the controller has been opened for input or output output\n"
  " * and there is an error on the stream, or false if the controller is closed\n"
  " * or if there is no problem.\n"
  " */";
#else
static const char *Dtool_RecorderController_is_error_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double RecorderController::get_clock_offset(void) const
 */
static PyObject *Dtool_RecorderController_get_clock_offset_29(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderController)) {
    return nullptr;
  }
  // 1-inline double RecorderController::get_clock_offset(void) const
  double return_value = ((*(const RecorderController*)local_this).get_clock_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_clock_offset_29_comment =
  "C++ Interface:\n"
  "get_clock_offset(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns the delta offset between the actual frame time and the frame time\n"
  " * written to the log.  This is essentially the time at which the recording\n"
  " * (or playback) started.\n"
  " */";
#else
static const char *Dtool_RecorderController_get_clock_offset_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RecorderController::get_frame_offset(void) const
 */
static PyObject *Dtool_RecorderController_get_frame_offset_30(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderController)) {
    return nullptr;
  }
  // 1-inline int RecorderController::get_frame_offset(void) const
  int return_value = ((*(const RecorderController*)local_this).get_frame_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_frame_offset_30_comment =
  "C++ Interface:\n"
  "get_frame_offset(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns the delta offset between the actual frame count and the frame count\n"
  " * written to the log.  This is essentially the frame number at which the\n"
  " * recording (or playback) started.\n"
  " */";
#else
static const char *Dtool_RecorderController_get_frame_offset_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RecorderController::add_recorder(std::string const &name, RecorderBase *recorder)
 */
static PyObject *Dtool_RecorderController_add_recorder_31(PyObject *self, PyObject *args, PyObject *kwds) {
  RecorderController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.add_recorder")) {
    return nullptr;
  }
  // 1-inline void RecorderController::add_recorder(std::string const &name, RecorderBase *recorder)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "recorder", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:add_recorder", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    RecorderBase *param2_this = (RecorderBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_RecorderBase, 2, "RecorderController.add_recorder", false, true);
    if (param2_this != nullptr) {
      ((*local_this).add_recorder)(std::string(param1_str, param1_len), param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_recorder(const RecorderController self, str name, RecorderBase recorder)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_add_recorder_31_comment =
  "C++ Interface:\n"
  "add_recorder(const RecorderController self, str name, RecorderBase recorder)\n"
  "\n"
  "/**\n"
  " * Adds the named recorder to the set of recorders that are in use.\n"
  " *\n"
  " * If the controller is in recording mode, the named recorder will begin\n"
  " * recording its status to the session file.  If the controller is in playback\n"
  " * mode and the name and type matches a recorder in the session file, the\n"
  " * recorder will begin receiving data.\n"
  " */";
#else
static const char *Dtool_RecorderController_add_recorder_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::has_recorder(std::string const &name) const
 */
static PyObject *Dtool_RecorderController_has_recorder_32(PyObject *self, PyObject *arg) {
  RecorderController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderController)) {
    return nullptr;
  }
  // 1-inline bool RecorderController::has_recorder(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const RecorderController*)local_this).has_recorder)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_recorder(RecorderController self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_has_recorder_32_comment =
  "C++ Interface:\n"
  "has_recorder(RecorderController self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if the named recorder has been added to the table by a\n"
  " * previous call to add_recorder(), false otherwise.\n"
  " *\n"
  " * If the controller is in playback mode, this will also return false for a\n"
  " * recorder that was found in the session file but was never explicitly added\n"
  " * via add_recorder(); see get_recorder().\n"
  " */";
#else
static const char *Dtool_RecorderController_has_recorder_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RecorderBase *RecorderController::get_recorder(std::string const &name) const
 */
static PyObject *Dtool_RecorderController_get_recorder_33(PyObject *self, PyObject *arg) {
  RecorderController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderController)) {
    return nullptr;
  }
  // 1-inline RecorderBase *RecorderController::get_recorder(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    RecorderBase *return_value = ((*(const RecorderController*)local_this).get_recorder)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_RecorderBase, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_recorder(RecorderController self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_recorder_33_comment =
  "C++ Interface:\n"
  "get_recorder(RecorderController self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the recorder with the indicated name, or NULL if there is no such\n"
  " * recorder.\n"
  " *\n"
  " * If the controller is in playback mode, this may return the recorder\n"
  " * matching the indicated name as read from the session file, even if it was\n"
  " * never added to the table by the user.  In this case, has_recorder() may\n"
  " * return false, but get_recorder() will return a non-NULL value.\n"
  " */";
#else
static const char *Dtool_RecorderController_get_recorder_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::remove_recorder(std::string const &name)
 */
static PyObject *Dtool_RecorderController_remove_recorder_34(PyObject *self, PyObject *arg) {
  RecorderController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.remove_recorder")) {
    return nullptr;
  }
  // 1-inline bool RecorderController::remove_recorder(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).remove_recorder)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_recorder(const RecorderController self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_remove_recorder_34_comment =
  "C++ Interface:\n"
  "remove_recorder(const RecorderController self, str name)\n"
  "\n"
  "/**\n"
  " * Removes the named recorder from the table.  Returns true if successful,\n"
  " * false if there was no such recorder.\n"
  " *\n"
  " * If the controller is in recording mode, the named recorder will stop\n"
  " * recording.  If the controller is in playback mode, the named recorder will\n"
  " * disassociate itself from the session file (but if the session file still\n"
  " * has data for this name, a default recorder will take its place to decode\n"
  " * the data from the session file).\n"
  " */";
#else
static const char *Dtool_RecorderController_remove_recorder_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RecorderController::set_frame_tie(bool frame_tie)
 */
static PyObject *Dtool_RecorderController_set_frame_tie_35(PyObject *self, PyObject *arg) {
  RecorderController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.set_frame_tie")) {
    return nullptr;
  }
  // 1-inline void RecorderController::set_frame_tie(bool frame_tie)
  ((*local_this).set_frame_tie)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_tie(const RecorderController self, bool frame_tie)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_set_frame_tie_35_comment =
  "C++ Interface:\n"
  "set_frame_tie(const RecorderController self, bool frame_tie)\n"
  "\n"
  "/**\n"
  " * Sets the frame_tie flag.\n"
  " *\n"
  " * When this is true, sessions are played back frame-for-frame, based on the\n"
  " * frame count of the recorded session.  This gives the most accurate\n"
  " * playback, but the playback rate will vary according to the frame rate of\n"
  " * the playback machine.\n"
  " *\n"
  " * When this is false, sessions are played back at real time, based on the\n"
  " * clock of the recorded session.  This may introduce playback discrepencies\n"
  " * if the frames do not fall at exactly the same times as they did in the\n"
  " * original.\n"
  " */";
#else
static const char *Dtool_RecorderController_set_frame_tie_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::get_frame_tie(void) const
 */
static PyObject *Dtool_RecorderController_get_frame_tie_36(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RecorderController)) {
    return nullptr;
  }
  // 1-inline bool RecorderController::get_frame_tie(void) const
  bool return_value = ((*(const RecorderController*)local_this).get_frame_tie)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_frame_tie_36_comment =
  "C++ Interface:\n"
  "get_frame_tie(RecorderController self)\n"
  "\n"
  "/**\n"
  " * See set_frame_tie().\n"
  " */";
#else
static const char *Dtool_RecorderController_get_frame_tie_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RecorderController::record_frame(void)
 */
static PyObject *Dtool_RecorderController_record_frame_37(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.record_frame")) {
    return nullptr;
  }
  // 1-void RecorderController::record_frame(void)
  ((*local_this).record_frame)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_record_frame_37_comment =
  "C++ Interface:\n"
  "record_frame(const RecorderController self)\n"
  "\n"
  "/**\n"
  " * Gets the next frame of data from all of the active recorders and adds it to\n"
  " * the output file.\n"
  " */";
#else
static const char *Dtool_RecorderController_record_frame_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RecorderController::play_frame(void)
 */
static PyObject *Dtool_RecorderController_play_frame_38(PyObject *self, PyObject *) {
  RecorderController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.play_frame")) {
    return nullptr;
  }
  // 1-void RecorderController::play_frame(void)
  ((*local_this).play_frame)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_play_frame_38_comment =
  "C++ Interface:\n"
  "play_frame(const RecorderController self)\n"
  "\n"
  "/**\n"
  " * Gets the next frame of data from all of the active recorders and adds it to\n"
  " * the output file.\n"
  " */";
#else
static const char *Dtool_RecorderController_play_frame_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RecorderController::get_class_type(void)
 */
static PyObject *Dtool_RecorderController_get_class_type_39(PyObject *, PyObject *) {
  // 1-static TypeHandle RecorderController::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RecorderController::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_class_type_39_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RecorderController_get_class_type_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * RecorderController::RecorderController(void)
 */
static int Dtool_Init_RecorderController(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("RecorderController() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RecorderController() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-RecorderController::RecorderController(void)
  RecorderController *return_value = new RecorderController();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RecorderController, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RecorderController()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RecorderController(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RecorderController) {
    printf("RecorderController ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RecorderController *local_this = (RecorderController *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RecorderController) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RecorderController(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RecorderController) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RecorderController*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RecorderController*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (RecorderController*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SocketStreamRecorder
 */
/**
 * Python function wrapper for:
 * bool SocketStreamRecorder::receive_datagram(Datagram &dg)
 */
static PyObject *Dtool_SocketStreamRecorder_receive_datagram_48(PyObject *self, PyObject *arg) {
  SocketStreamRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.receive_datagram")) {
    return nullptr;
  }
  // 1-bool SocketStreamRecorder::receive_datagram(Datagram &dg)
  Datagram arg_local;
  Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SocketStreamRecorder.receive_datagram", "Datagram");
  }
  bool return_value = ((*local_this).receive_datagram)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_datagram(const SocketStreamRecorder self, Datagram dg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_receive_datagram_48_comment =
  "C++ Interface:\n"
  "receive_datagram(const SocketStreamRecorder self, Datagram dg)\n"
  "\n"
  "/**\n"
  " * Receives a datagram over the socket by expecting a little-endian 16-bit\n"
  " * byte count as a prefix.  If the socket stream is non-blocking, may return\n"
  " * false if the data is not available; otherwise, returns false only if the\n"
  " * socket closes.\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_receive_datagram_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SocketStreamRecorder::send_datagram(Datagram const &dg)
 */
static PyObject *Dtool_SocketStreamRecorder_send_datagram_49(PyObject *self, PyObject *arg) {
  SocketStreamRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.send_datagram")) {
    return nullptr;
  }
  // 1-inline bool SocketStreamRecorder::send_datagram(Datagram const &dg)
  Datagram arg_local;
  Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SocketStreamRecorder.send_datagram", "Datagram");
  }
  bool return_value = ((*local_this).send_datagram)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send_datagram(const SocketStreamRecorder self, const Datagram dg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_send_datagram_49_comment =
  "C++ Interface:\n"
  "send_datagram(const SocketStreamRecorder self, const Datagram dg)\n"
  "\n"
  "/**\n"
  " * See SocketStream::send_datagram().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_send_datagram_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SocketStreamRecorder::is_closed(void)
 */
static PyObject *Dtool_SocketStreamRecorder_is_closed_50(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.is_closed")) {
    return nullptr;
  }
  // 1-inline bool SocketStreamRecorder::is_closed(void)
  bool return_value = ((*local_this).is_closed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_is_closed_50_comment =
  "C++ Interface:\n"
  "is_closed(const SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::is_closed().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_is_closed_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SocketStreamRecorder::close(void)
 */
static PyObject *Dtool_SocketStreamRecorder_close_51(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.close")) {
    return nullptr;
  }
  // 1-inline void SocketStreamRecorder::close(void)
  ((*local_this).close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_close_51_comment =
  "C++ Interface:\n"
  "close(const SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::close().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_close_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SocketStreamRecorder::set_collect_tcp(bool collect_tcp)
 */
static PyObject *Dtool_SocketStreamRecorder_set_collect_tcp_52(PyObject *self, PyObject *arg) {
  SocketStreamRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.set_collect_tcp")) {
    return nullptr;
  }
  // 1-inline void SocketStreamRecorder::set_collect_tcp(bool collect_tcp)
  ((*local_this).set_collect_tcp)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collect_tcp(const SocketStreamRecorder self, bool collect_tcp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_set_collect_tcp_52_comment =
  "C++ Interface:\n"
  "set_collect_tcp(const SocketStreamRecorder self, bool collect_tcp)\n"
  "\n"
  "/**\n"
  " * See SocketStream::set_collect_tcp().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_set_collect_tcp_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SocketStreamRecorder::get_collect_tcp(void) const
 */
static PyObject *Dtool_SocketStreamRecorder_get_collect_tcp_53(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SocketStreamRecorder)) {
    return nullptr;
  }
  // 1-inline bool SocketStreamRecorder::get_collect_tcp(void) const
  bool return_value = ((*(const SocketStreamRecorder*)local_this).get_collect_tcp)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_get_collect_tcp_53_comment =
  "C++ Interface:\n"
  "get_collect_tcp(SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::get_collect_tcp().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_get_collect_tcp_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SocketStreamRecorder::set_collect_tcp_interval(double interval)
 */
static PyObject *Dtool_SocketStreamRecorder_set_collect_tcp_interval_54(PyObject *self, PyObject *arg) {
  SocketStreamRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.set_collect_tcp_interval")) {
    return nullptr;
  }
  // 1-inline void SocketStreamRecorder::set_collect_tcp_interval(double interval)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_collect_tcp_interval)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collect_tcp_interval(const SocketStreamRecorder self, double interval)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_set_collect_tcp_interval_54_comment =
  "C++ Interface:\n"
  "set_collect_tcp_interval(const SocketStreamRecorder self, double interval)\n"
  "\n"
  "/**\n"
  " * See SocketStream::set_collect_tcp_interval().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_set_collect_tcp_interval_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double SocketStreamRecorder::get_collect_tcp_interval(void) const
 */
static PyObject *Dtool_SocketStreamRecorder_get_collect_tcp_interval_55(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SocketStreamRecorder)) {
    return nullptr;
  }
  // 1-inline double SocketStreamRecorder::get_collect_tcp_interval(void) const
  double return_value = ((*(const SocketStreamRecorder*)local_this).get_collect_tcp_interval)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_get_collect_tcp_interval_55_comment =
  "C++ Interface:\n"
  "get_collect_tcp_interval(SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::get_collect_tcp_interval().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_get_collect_tcp_interval_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SocketStreamRecorder::consider_flush(void)
 */
static PyObject *Dtool_SocketStreamRecorder_consider_flush_56(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.consider_flush")) {
    return nullptr;
  }
  // 1-inline bool SocketStreamRecorder::consider_flush(void)
  bool return_value = ((*local_this).consider_flush)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_consider_flush_56_comment =
  "C++ Interface:\n"
  "consider_flush(const SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::consider_flush()\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_consider_flush_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SocketStreamRecorder::flush(void)
 */
static PyObject *Dtool_SocketStreamRecorder_flush_57(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.flush")) {
    return nullptr;
  }
  // 1-inline bool SocketStreamRecorder::flush(void)
  bool return_value = ((*local_this).flush)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_flush_57_comment =
  "C++ Interface:\n"
  "flush(const SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::flush()\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_flush_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SocketStreamRecorder::get_class_type(void)
 */
static PyObject *Dtool_SocketStreamRecorder_get_class_type_58(PyObject *, PyObject *) {
  // 1-static TypeHandle SocketStreamRecorder::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((SocketStreamRecorder::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_get_class_type_58_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SocketStreamRecorder_get_class_type_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * RecorderBase *SocketStreamRecorder::upcast_to_RecorderBase(void)
 */
static PyObject *Dtool_SocketStreamRecorder_upcast_to_RecorderBase_41(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.upcast_to_RecorderBase")) {
    return nullptr;
  }
  // 1-RecorderBase *SocketStreamRecorder::upcast_to_RecorderBase(void)
  RecorderBase *return_value = (RecorderBase *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_RecorderBase, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_upcast_to_RecorderBase_41_comment =
  "C++ Interface:\n"
  "upcast_to_RecorderBase(const SocketStreamRecorder self)\n"
  "\n"
  "upcast from SocketStreamRecorder to RecorderBase";
#else
static const char *Dtool_SocketStreamRecorder_upcast_to_RecorderBase_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *SocketStreamRecorder::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_44(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.upcast_to_ReferenceCount")) {
    return nullptr;
  }
  // 1-ReferenceCount *SocketStreamRecorder::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_44_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const SocketStreamRecorder self)\n"
  "\n"
  "upcast from SocketStreamRecorder to ReferenceCount";
#else
static const char *Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SocketStreamRecorder::SocketStreamRecorder(void)
 * inline explicit SocketStreamRecorder::SocketStreamRecorder(SocketStream *stream, bool owns_stream)
 */
static int Dtool_Init_SocketStreamRecorder(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline SocketStreamRecorder::SocketStreamRecorder(void)
      SocketStreamRecorder *return_value = new SocketStreamRecorder();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SocketStreamRecorder, true, false);
    }
    break;
  case 2:
    {
      // 1-inline explicit SocketStreamRecorder::SocketStreamRecorder(SocketStream *stream, bool owns_stream)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"stream", "owns_stream", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:SocketStreamRecorder", (char **)keyword_list, &param0, &param1)) {
        SocketStream *param0_this = (SocketStream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_SocketStream, 0, "SocketStreamRecorder.SocketStreamRecorder", false, true);
        if (param0_this != nullptr) {
          SocketStreamRecorder *return_value = new SocketStreamRecorder(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SocketStreamRecorder, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SocketStreamRecorder() takes 0 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SocketStreamRecorder()\n"
      "SocketStreamRecorder(SocketStream stream, bool owns_stream)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SocketStreamRecorder(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SocketStreamRecorder) {
    printf("SocketStreamRecorder ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SocketStreamRecorder *local_this = (SocketStreamRecorder *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SocketStreamRecorder) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_RecorderBase) {
    return (RecorderBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SocketStreamRecorder(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SocketStreamRecorder) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_RecorderBase) {
    RecorderBase* other_this = (RecorderBase*)from_this;
    return (SocketStreamRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SocketStreamRecorder*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for RecorderBase (RecorderBase)
 */
static PyMethodDef Dtool_Methods_RecorderBase[] = {
  {"is_recording", &Dtool_RecorderBase_is_recording_3, METH_NOARGS, (const char *)Dtool_RecorderBase_is_recording_3_comment},
  {"isRecording", &Dtool_RecorderBase_is_recording_3, METH_NOARGS, (const char *)Dtool_RecorderBase_is_recording_3_comment},
  {"is_playing", &Dtool_RecorderBase_is_playing_4, METH_NOARGS, (const char *)Dtool_RecorderBase_is_playing_4_comment},
  {"isPlaying", &Dtool_RecorderBase_is_playing_4, METH_NOARGS, (const char *)Dtool_RecorderBase_is_playing_4_comment},
  {"get_class_type", &Dtool_RecorderBase_get_class_type_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_RecorderBase_get_class_type_5_comment},
  {"getClassType", &Dtool_RecorderBase_get_class_type_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_RecorderBase_get_class_type_5_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_RecorderBase = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_RecorderBase = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RecorderBase",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RecorderBase,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RecorderBase,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class to a number of objects that record particular kinds\n"
    " * of user input (like a MouseRecorder) to use in conjunction with a\n"
    " * RecorderController to record the user's inputs for a session.\n"
    " *\n"
    " * Note that RecorderBase does not actually inherit from TypedObject, even\n"
    " * though it defines get_type().  The assumption is that the classes that\n"
    " * derive from RecorderBase might also inherit independently from TypedObject.\n"
    " *\n"
    " * It also does not inherit from TypedWritable, but it defines a method called\n"
    " * write_recorder() which is very similar to a TypedWritable's\n"
    " * write_datagram(). Classes that derive from RecorderBase and also inherit\n"
    " * from TypedWritable may choose to remap write_recorder() to do exactly the\n"
    " * same thing as write_datagram(), or they may choose to write something\n"
    " * slightly different.\n"
    " *\n"
    " * Most types of recorders should derive from Recorder, as it derives from\n"
    " * ReferenceCount, except for MouseRecorder, which would otherwise doubly\n"
    " * inherit from ReferenceCount.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RecorderBase,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RecorderBase,
    PyType_GenericAlloc,
    Dtool_new_RecorderBase,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RecorderBase,
  Dtool_UpcastInterface_RecorderBase,
  Dtool_DowncastInterface_RecorderBase,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RecorderBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_RecorderBase._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RecorderBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RecorderBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RecorderBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RecorderBase);
  }
}

/**
 * Python method tables for MouseRecorder (MouseRecorder)
 */
static PyMethodDef Dtool_Methods_MouseRecorder[] = {
  {"get_class_type", &Dtool_MouseRecorder_get_class_type_14, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseRecorder_get_class_type_14_comment},
  {"getClassType", &Dtool_MouseRecorder_get_class_type_14, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseRecorder_get_class_type_14_comment},
  {"upcast_to_DataNode", &Dtool_MouseRecorder_upcast_to_DataNode_8, METH_NOARGS, (const char *)Dtool_MouseRecorder_upcast_to_DataNode_8_comment},
  {"upcastToDataNode", &Dtool_MouseRecorder_upcast_to_DataNode_8, METH_NOARGS, (const char *)Dtool_MouseRecorder_upcast_to_DataNode_8_comment},
  {"upcast_to_RecorderBase", &Dtool_MouseRecorder_upcast_to_RecorderBase_10, METH_NOARGS, (const char *)Dtool_MouseRecorder_upcast_to_RecorderBase_10_comment},
  {"upcastToRecorderBase", &Dtool_MouseRecorder_upcast_to_RecorderBase_10, METH_NOARGS, (const char *)Dtool_MouseRecorder_upcast_to_RecorderBase_10_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MouseRecorder = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MouseRecorder = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MouseRecorder = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MouseRecorder = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MouseRecorder = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MouseRecorder = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MouseRecorder",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseRecorder,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MouseRecorder,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MouseRecorder,
    &Dtool_SequenceMethods_MouseRecorder,
    &Dtool_MappingMethods_MouseRecorder,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MouseRecorder,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object records any data generated by a particular MouseAndKeyboard\n"
    " * node on the datagraph for a session for eventual playback via a\n"
    " * DataGraphPlayback (and a PlaybackController).  To use it, make it a child\n"
    " * of the node you wish to record.  It also serves as a pass-through, so that\n"
    " * additional child nodes may be parented directly to it.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MouseRecorder,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MouseRecorder,
    PyType_GenericAlloc,
    Dtool_new_MouseRecorder,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseRecorder,
  Dtool_UpcastInterface_MouseRecorder,
  Dtool_DowncastInterface_MouseRecorder,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MouseRecorder(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != nullptr);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_RecorderBase(nullptr);
    Dtool_MouseRecorder._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_DataNode, (PyTypeObject *)&Dtool_RecorderBase);
    Dtool_MouseRecorder._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MouseRecorder._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseRecorder) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseRecorder)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseRecorder);
  }
}

/**
 * Python method tables for RecorderController (RecorderController)
 */
static PyMethodDef Dtool_Methods_RecorderController[] = {
  {"begin_record", &Dtool_RecorderController_begin_record_18, METH_O, (const char *)Dtool_RecorderController_begin_record_18_comment},
  {"beginRecord", &Dtool_RecorderController_begin_record_18, METH_O, (const char *)Dtool_RecorderController_begin_record_18_comment},
  {"begin_playback", &Dtool_RecorderController_begin_playback_19, METH_O, (const char *)Dtool_RecorderController_begin_playback_19_comment},
  {"beginPlayback", &Dtool_RecorderController_begin_playback_19, METH_O, (const char *)Dtool_RecorderController_begin_playback_19_comment},
  {"close", &Dtool_RecorderController_close_20, METH_NOARGS, (const char *)Dtool_RecorderController_close_20_comment},
  {"get_start_time", &Dtool_RecorderController_get_start_time_21, METH_NOARGS, (const char *)Dtool_RecorderController_get_start_time_21_comment},
  {"getStartTime", &Dtool_RecorderController_get_start_time_21, METH_NOARGS, (const char *)Dtool_RecorderController_get_start_time_21_comment},
  {"set_random_seed", &Dtool_RecorderController_set_random_seed_22, METH_O, (const char *)Dtool_RecorderController_set_random_seed_22_comment},
  {"setRandomSeed", &Dtool_RecorderController_set_random_seed_22, METH_O, (const char *)Dtool_RecorderController_set_random_seed_22_comment},
  {"get_random_seed", &Dtool_RecorderController_get_random_seed_23, METH_NOARGS, (const char *)Dtool_RecorderController_get_random_seed_23_comment},
  {"getRandomSeed", &Dtool_RecorderController_get_random_seed_23, METH_NOARGS, (const char *)Dtool_RecorderController_get_random_seed_23_comment},
  {"is_recording", &Dtool_RecorderController_is_recording_24, METH_NOARGS, (const char *)Dtool_RecorderController_is_recording_24_comment},
  {"isRecording", &Dtool_RecorderController_is_recording_24, METH_NOARGS, (const char *)Dtool_RecorderController_is_recording_24_comment},
  {"is_playing", &Dtool_RecorderController_is_playing_25, METH_NOARGS, (const char *)Dtool_RecorderController_is_playing_25_comment},
  {"isPlaying", &Dtool_RecorderController_is_playing_25, METH_NOARGS, (const char *)Dtool_RecorderController_is_playing_25_comment},
  {"is_open", &Dtool_RecorderController_is_open_26, METH_NOARGS, (const char *)Dtool_RecorderController_is_open_26_comment},
  {"isOpen", &Dtool_RecorderController_is_open_26, METH_NOARGS, (const char *)Dtool_RecorderController_is_open_26_comment},
  {"get_filename", &Dtool_RecorderController_get_filename_27, METH_NOARGS, (const char *)Dtool_RecorderController_get_filename_27_comment},
  {"getFilename", &Dtool_RecorderController_get_filename_27, METH_NOARGS, (const char *)Dtool_RecorderController_get_filename_27_comment},
  {"is_error", &Dtool_RecorderController_is_error_28, METH_NOARGS, (const char *)Dtool_RecorderController_is_error_28_comment},
  {"isError", &Dtool_RecorderController_is_error_28, METH_NOARGS, (const char *)Dtool_RecorderController_is_error_28_comment},
  {"get_clock_offset", &Dtool_RecorderController_get_clock_offset_29, METH_NOARGS, (const char *)Dtool_RecorderController_get_clock_offset_29_comment},
  {"getClockOffset", &Dtool_RecorderController_get_clock_offset_29, METH_NOARGS, (const char *)Dtool_RecorderController_get_clock_offset_29_comment},
  {"get_frame_offset", &Dtool_RecorderController_get_frame_offset_30, METH_NOARGS, (const char *)Dtool_RecorderController_get_frame_offset_30_comment},
  {"getFrameOffset", &Dtool_RecorderController_get_frame_offset_30, METH_NOARGS, (const char *)Dtool_RecorderController_get_frame_offset_30_comment},
  {"add_recorder", (PyCFunction) &Dtool_RecorderController_add_recorder_31, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RecorderController_add_recorder_31_comment},
  {"addRecorder", (PyCFunction) &Dtool_RecorderController_add_recorder_31, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RecorderController_add_recorder_31_comment},
  {"has_recorder", &Dtool_RecorderController_has_recorder_32, METH_O, (const char *)Dtool_RecorderController_has_recorder_32_comment},
  {"hasRecorder", &Dtool_RecorderController_has_recorder_32, METH_O, (const char *)Dtool_RecorderController_has_recorder_32_comment},
  {"get_recorder", &Dtool_RecorderController_get_recorder_33, METH_O, (const char *)Dtool_RecorderController_get_recorder_33_comment},
  {"getRecorder", &Dtool_RecorderController_get_recorder_33, METH_O, (const char *)Dtool_RecorderController_get_recorder_33_comment},
  {"remove_recorder", &Dtool_RecorderController_remove_recorder_34, METH_O, (const char *)Dtool_RecorderController_remove_recorder_34_comment},
  {"removeRecorder", &Dtool_RecorderController_remove_recorder_34, METH_O, (const char *)Dtool_RecorderController_remove_recorder_34_comment},
  {"set_frame_tie", &Dtool_RecorderController_set_frame_tie_35, METH_O, (const char *)Dtool_RecorderController_set_frame_tie_35_comment},
  {"setFrameTie", &Dtool_RecorderController_set_frame_tie_35, METH_O, (const char *)Dtool_RecorderController_set_frame_tie_35_comment},
  {"get_frame_tie", &Dtool_RecorderController_get_frame_tie_36, METH_NOARGS, (const char *)Dtool_RecorderController_get_frame_tie_36_comment},
  {"getFrameTie", &Dtool_RecorderController_get_frame_tie_36, METH_NOARGS, (const char *)Dtool_RecorderController_get_frame_tie_36_comment},
  {"record_frame", &Dtool_RecorderController_record_frame_37, METH_NOARGS, (const char *)Dtool_RecorderController_record_frame_37_comment},
  {"recordFrame", &Dtool_RecorderController_record_frame_37, METH_NOARGS, (const char *)Dtool_RecorderController_record_frame_37_comment},
  {"play_frame", &Dtool_RecorderController_play_frame_38, METH_NOARGS, (const char *)Dtool_RecorderController_play_frame_38_comment},
  {"playFrame", &Dtool_RecorderController_play_frame_38, METH_NOARGS, (const char *)Dtool_RecorderController_play_frame_38_comment},
  {"get_class_type", &Dtool_RecorderController_get_class_type_39, METH_NOARGS | METH_STATIC, (const char *)Dtool_RecorderController_get_class_type_39_comment},
  {"getClassType", &Dtool_RecorderController_get_class_type_39, METH_NOARGS | METH_STATIC, (const char *)Dtool_RecorderController_get_class_type_39_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_RecorderController = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RecorderController = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RecorderController = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RecorderController = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RecorderController = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RecorderController = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RecorderController",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RecorderController,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RecorderController,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RecorderController,
    &Dtool_SequenceMethods_RecorderController,
    &Dtool_MappingMethods_RecorderController,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RecorderController,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object manages the process of recording the user's runtime inputs to a\n"
    " * bam file so that the session can be recreated later.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RecorderController,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RecorderController,
    PyType_GenericAlloc,
    Dtool_new_RecorderController,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RecorderController,
  Dtool_UpcastInterface_RecorderController,
  Dtool_DowncastInterface_RecorderController,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RecorderController(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_RecorderController._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_RecorderController._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RecorderController._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RecorderController) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RecorderController)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RecorderController);
  }
}

/**
 * Python method tables for SocketStreamRecorder (SocketStreamRecorder)
 */
static PyMethodDef Dtool_Methods_SocketStreamRecorder[] = {
  {"receive_datagram", &Dtool_SocketStreamRecorder_receive_datagram_48, METH_O, (const char *)Dtool_SocketStreamRecorder_receive_datagram_48_comment},
  {"receiveDatagram", &Dtool_SocketStreamRecorder_receive_datagram_48, METH_O, (const char *)Dtool_SocketStreamRecorder_receive_datagram_48_comment},
  {"send_datagram", &Dtool_SocketStreamRecorder_send_datagram_49, METH_O, (const char *)Dtool_SocketStreamRecorder_send_datagram_49_comment},
  {"sendDatagram", &Dtool_SocketStreamRecorder_send_datagram_49, METH_O, (const char *)Dtool_SocketStreamRecorder_send_datagram_49_comment},
  {"is_closed", &Dtool_SocketStreamRecorder_is_closed_50, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_is_closed_50_comment},
  {"isClosed", &Dtool_SocketStreamRecorder_is_closed_50, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_is_closed_50_comment},
  {"close", &Dtool_SocketStreamRecorder_close_51, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_close_51_comment},
  {"set_collect_tcp", &Dtool_SocketStreamRecorder_set_collect_tcp_52, METH_O, (const char *)Dtool_SocketStreamRecorder_set_collect_tcp_52_comment},
  {"setCollectTcp", &Dtool_SocketStreamRecorder_set_collect_tcp_52, METH_O, (const char *)Dtool_SocketStreamRecorder_set_collect_tcp_52_comment},
  {"get_collect_tcp", &Dtool_SocketStreamRecorder_get_collect_tcp_53, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_get_collect_tcp_53_comment},
  {"getCollectTcp", &Dtool_SocketStreamRecorder_get_collect_tcp_53, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_get_collect_tcp_53_comment},
  {"set_collect_tcp_interval", &Dtool_SocketStreamRecorder_set_collect_tcp_interval_54, METH_O, (const char *)Dtool_SocketStreamRecorder_set_collect_tcp_interval_54_comment},
  {"setCollectTcpInterval", &Dtool_SocketStreamRecorder_set_collect_tcp_interval_54, METH_O, (const char *)Dtool_SocketStreamRecorder_set_collect_tcp_interval_54_comment},
  {"get_collect_tcp_interval", &Dtool_SocketStreamRecorder_get_collect_tcp_interval_55, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_get_collect_tcp_interval_55_comment},
  {"getCollectTcpInterval", &Dtool_SocketStreamRecorder_get_collect_tcp_interval_55, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_get_collect_tcp_interval_55_comment},
  {"consider_flush", &Dtool_SocketStreamRecorder_consider_flush_56, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_consider_flush_56_comment},
  {"considerFlush", &Dtool_SocketStreamRecorder_consider_flush_56, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_consider_flush_56_comment},
  {"flush", &Dtool_SocketStreamRecorder_flush_57, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_flush_57_comment},
  {"get_class_type", &Dtool_SocketStreamRecorder_get_class_type_58, METH_NOARGS | METH_STATIC, (const char *)Dtool_SocketStreamRecorder_get_class_type_58_comment},
  {"getClassType", &Dtool_SocketStreamRecorder_get_class_type_58, METH_NOARGS | METH_STATIC, (const char *)Dtool_SocketStreamRecorder_get_class_type_58_comment},
  {"upcast_to_RecorderBase", &Dtool_SocketStreamRecorder_upcast_to_RecorderBase_41, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_upcast_to_RecorderBase_41_comment},
  {"upcastToRecorderBase", &Dtool_SocketStreamRecorder_upcast_to_RecorderBase_41, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_upcast_to_RecorderBase_41_comment},
  {"upcast_to_ReferenceCount", &Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_44, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_44_comment},
  {"upcastToReferenceCount", &Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_44, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_44_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_SocketStreamRecorder = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SocketStreamRecorder = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SocketStreamRecorder = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SocketStreamRecorder = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SocketStreamRecorder = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SocketStreamRecorder = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SocketStreamRecorder",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SocketStreamRecorder,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SocketStreamRecorder,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SocketStreamRecorder,
    &Dtool_SequenceMethods_SocketStreamRecorder,
    &Dtool_MappingMethods_SocketStreamRecorder,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SocketStreamRecorder,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Records any data received from the indicated socket stream.  On playback,\n"
    " * it will act as if the incoming data is coming over the wire again even if\n"
    " * an actual connection is not available.\n"
    " *\n"
    " * Outbound data will not be recorded, but will be sent straight through to\n"
    " * the socket if it is connected, or silently ignored if it is not.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SocketStreamRecorder,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SocketStreamRecorder,
    PyType_GenericAlloc,
    Dtool_new_SocketStreamRecorder,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SocketStreamRecorder,
  Dtool_UpcastInterface_SocketStreamRecorder,
  Dtool_DowncastInterface_SocketStreamRecorder,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SocketStreamRecorder(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RecorderBase(nullptr);
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_SocketStreamRecorder._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_RecorderBase, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_SocketStreamRecorder._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SocketStreamRecorder._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SocketStreamRecorder) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SocketStreamRecorder)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SocketStreamRecorder);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3recorder_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    RecorderBase::init_type();
    TypeHandle handle = RecorderBase::get_class_type();
    Dtool_RecorderBase._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RecorderBase);
  }
  {
    MouseRecorder::init_type();
    TypeHandle handle = MouseRecorder::get_class_type();
    Dtool_MouseRecorder._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MouseRecorder);
  }
  {
    RecorderController::init_type();
    TypeHandle handle = RecorderController::get_class_type();
    Dtool_RecorderController._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RecorderController);
  }
  {
    SocketStreamRecorder::init_type();
    TypeHandle handle = SocketStreamRecorder::get_class_type();
    Dtool_SocketStreamRecorder._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_SocketStreamRecorder);
  }
}

void Dtool_libp3recorder_BuildInstants(PyObject *module) {
  (void) module;
  // RecorderBase
  Dtool_PyModuleClassInit_RecorderBase(module);
  PyModule_AddObject(module, "RecorderBase", (PyObject *)&Dtool_RecorderBase);
  // MouseRecorder
  Dtool_PyModuleClassInit_MouseRecorder(module);
  PyModule_AddObject(module, "MouseRecorder", (PyObject *)&Dtool_MouseRecorder);
  // RecorderController
  Dtool_PyModuleClassInit_RecorderController(module);
  PyModule_AddObject(module, "RecorderController", (PyObject *)&Dtool_RecorderController);
  // SocketStreamRecorder
  Dtool_PyModuleClassInit_SocketStreamRecorder(module);
  PyModule_AddObject(module, "SocketStreamRecorder", (PyObject *)&Dtool_SocketStreamRecorder);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3recorder_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3recorder_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613946,  /* file_identifier */
  "libp3recorder",  /* library_name */
  "ayCl",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3recorder.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  134  /* next_index */
};

Configure(_in_configure_libp3recorder);
ConfigureFn(_in_configure_libp3recorder) {
  interrogate_request_module(&_in_module_def);
}

