/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/movies -Ipanda/src/movies -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3movies_igate.cxx -od built/pandac/input/libp3movies.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/movies -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -S/usr/include/opus -module panda3d.core -library libp3movies config_movies.h dr_flac.h flacAudio.h flacAudioCursor.h inkblotVideo.h inkblotVideoCursor.h microphoneAudio.h movieAudio.h movieAudioCursor.h movieTypeRegistry.h movieVideo.h movieVideoCursor.h opusAudio.h opusAudioCursor.h p3movies_composite1.cxx userDataAudio.h userDataAudioCursor.h vorbisAudio.h vorbisAudioCursor.h wavAudio.h wavAudioCursor.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableBool.h"
#include "configVariableList.h"
#include "config_movies.h"
#include "dconfig.h"
#include "dr_flac.h"
#include "filename.h"
#include "flacAudio.h"
#include "flacAudioCursor.h"
#include "inkblotVideo.h"
#include "inkblotVideoCursor.h"
#include "microphoneAudio.h"
#include "movieAudio.h"
#include "movieAudioCursor.h"
#include "movieTypeRegistry.h"
#include "movieVideo.h"
#include "movieVideoCursor.h"
#include "notifyCategoryProxy.h"
#include "opusAudio.h"
#include "opusAudioCursor.h"
#include "pandabase.h"
#include "pmap.h"
#include "pointerTo.h"
#include "reMutex.h"
#include <stddef.h>
#include <stdint.h>
#include "texture.h"
#include "threadPriority.h"
#include "userDataAudio.h"
#include "userDataAudioCursor.h"
#include "vorbisAudio.h"
#include "vorbisAudioCursor.h"
#include "wavAudio.h"
#include "wavAudioCursor.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class MovieAudio
 */
typedef MovieAudio MovieAudio_localtype;
Define_Module_ClassRef(panda3d.core, MovieAudio, MovieAudio_localtype, MovieAudio);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieAudio = &Dtool_MovieAudio;
static void Dtool_PyModuleClassInit_MovieAudio(PyObject *module);

/**
 * Forward declarations for top-level class FlacAudio
 */
typedef FlacAudio FlacAudio_localtype;
Define_Module_ClassRef(panda3d.core, FlacAudio, FlacAudio_localtype, FlacAudio);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FlacAudio = &Dtool_FlacAudio;
static void Dtool_PyModuleClassInit_FlacAudio(PyObject *module);
bool Dtool_ConstCoerce_FlacAudio(PyObject *args, CPT(FlacAudio) &coerced);
bool Dtool_Coerce_FlacAudio(PyObject *args, PT(FlacAudio) &coerced);

/**
 * Forward declarations for top-level class MovieAudioCursor
 */
typedef MovieAudioCursor MovieAudioCursor_localtype;
Define_Module_ClassRef(panda3d.core, MovieAudioCursor, MovieAudioCursor_localtype, MovieAudioCursor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieAudioCursor = &Dtool_MovieAudioCursor;
static void Dtool_PyModuleClassInit_MovieAudioCursor(PyObject *module);
bool Dtool_ConstCoerce_MovieAudioCursor(PyObject *args, CPT(MovieAudioCursor) &coerced);
bool Dtool_Coerce_MovieAudioCursor(PyObject *args, PT(MovieAudioCursor) &coerced);

/**
 * Forward declarations for top-level class FlacAudioCursor
 */
typedef FlacAudioCursor FlacAudioCursor_localtype;
Define_Module_ClassRef(panda3d.core, FlacAudioCursor, FlacAudioCursor_localtype, FlacAudioCursor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FlacAudioCursor = &Dtool_FlacAudioCursor;
static void Dtool_PyModuleClassInit_FlacAudioCursor(PyObject *module);

/**
 * Forward declarations for top-level class MovieVideo
 */
typedef MovieVideo MovieVideo_localtype;
Define_Module_ClassRef(panda3d.core, MovieVideo, MovieVideo_localtype, MovieVideo);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieVideo = &Dtool_MovieVideo;
static void Dtool_PyModuleClassInit_MovieVideo(PyObject *module);
bool Dtool_ConstCoerce_MovieVideo(PyObject *args, CPT(MovieVideo) &coerced);
bool Dtool_Coerce_MovieVideo(PyObject *args, PT(MovieVideo) &coerced);

/**
 * Forward declarations for top-level class InkblotVideo
 */
typedef InkblotVideo InkblotVideo_localtype;
Define_Module_ClassRef(panda3d.core, InkblotVideo, InkblotVideo_localtype, InkblotVideo);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InkblotVideo = &Dtool_InkblotVideo;
static void Dtool_PyModuleClassInit_InkblotVideo(PyObject *module);

/**
 * Forward declarations for top-level class MovieVideoCursor
 */
typedef MovieVideoCursor MovieVideoCursor_localtype;
Define_Module_ClassRef(panda3d.core, MovieVideoCursor, MovieVideoCursor_localtype, MovieVideoCursor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieVideoCursor = &Dtool_MovieVideoCursor;
static void Dtool_PyModuleClassInit_MovieVideoCursor(PyObject *module);

/**
 * Forward declarations for top-level class MovieVideoCursor_Buffer
 */
typedef MovieVideoCursor::Buffer MovieVideoCursor_Buffer_localtype;
Define_Module_ClassRef(panda3d.core, MovieVideoCursor_Buffer, MovieVideoCursor_Buffer_localtype, Buffer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieVideoCursor_Buffer = &Dtool_MovieVideoCursor_Buffer;
static void Dtool_PyModuleClassInit_MovieVideoCursor_Buffer(PyObject *module);

/**
 * Forward declarations for top-level class InkblotVideoCursor
 */
typedef InkblotVideoCursor InkblotVideoCursor_localtype;
Define_Module_ClassRef(panda3d.core, InkblotVideoCursor, InkblotVideoCursor_localtype, InkblotVideoCursor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InkblotVideoCursor = &Dtool_InkblotVideoCursor;
static void Dtool_PyModuleClassInit_InkblotVideoCursor(PyObject *module);
bool Dtool_ConstCoerce_InkblotVideoCursor(PyObject *args, CPT(InkblotVideoCursor) &coerced);
bool Dtool_Coerce_InkblotVideoCursor(PyObject *args, PT(InkblotVideoCursor) &coerced);

/**
 * Forward declarations for top-level class MicrophoneAudio
 */
typedef MicrophoneAudio MicrophoneAudio_localtype;
Define_Module_ClassRef(panda3d.core, MicrophoneAudio, MicrophoneAudio_localtype, MicrophoneAudio);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MicrophoneAudio = &Dtool_MicrophoneAudio;
static void Dtool_PyModuleClassInit_MicrophoneAudio(PyObject *module);

/**
 * Forward declarations for top-level class UserDataAudio
 */
typedef UserDataAudio UserDataAudio_localtype;
Define_Module_ClassRef(panda3d.core, UserDataAudio, UserDataAudio_localtype, UserDataAudio);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UserDataAudio = &Dtool_UserDataAudio;
static void Dtool_PyModuleClassInit_UserDataAudio(PyObject *module);
bool Dtool_ConstCoerce_UserDataAudio(PyObject *args, CPT(UserDataAudio) &coerced);
bool Dtool_Coerce_UserDataAudio(PyObject *args, PT(UserDataAudio) &coerced);

/**
 * Forward declarations for top-level class UserDataAudioCursor
 */
typedef UserDataAudioCursor UserDataAudioCursor_localtype;
Define_Module_ClassRef(panda3d.core, UserDataAudioCursor, UserDataAudioCursor_localtype, UserDataAudioCursor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UserDataAudioCursor = &Dtool_UserDataAudioCursor;
static void Dtool_PyModuleClassInit_UserDataAudioCursor(PyObject *module);
bool Dtool_ConstCoerce_UserDataAudioCursor(PyObject *args, CPT(UserDataAudioCursor) &coerced);
bool Dtool_Coerce_UserDataAudioCursor(PyObject *args, PT(UserDataAudioCursor) &coerced);

/**
 * Forward declarations for top-level class VorbisAudio
 */
typedef VorbisAudio VorbisAudio_localtype;
Define_Module_ClassRef(panda3d.core, VorbisAudio, VorbisAudio_localtype, VorbisAudio);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VorbisAudio = &Dtool_VorbisAudio;
static void Dtool_PyModuleClassInit_VorbisAudio(PyObject *module);
bool Dtool_ConstCoerce_VorbisAudio(PyObject *args, CPT(VorbisAudio) &coerced);
bool Dtool_Coerce_VorbisAudio(PyObject *args, PT(VorbisAudio) &coerced);

/**
 * Forward declarations for top-level class VorbisAudioCursor
 */
typedef VorbisAudioCursor VorbisAudioCursor_localtype;
Define_Module_ClassRef(panda3d.core, VorbisAudioCursor, VorbisAudioCursor_localtype, VorbisAudioCursor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VorbisAudioCursor = &Dtool_VorbisAudioCursor;
static void Dtool_PyModuleClassInit_VorbisAudioCursor(PyObject *module);

/**
 * Forward declarations for top-level class WavAudio
 */
typedef WavAudio WavAudio_localtype;
Define_Module_ClassRef(panda3d.core, WavAudio, WavAudio_localtype, WavAudio);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WavAudio = &Dtool_WavAudio;
static void Dtool_PyModuleClassInit_WavAudio(PyObject *module);
bool Dtool_ConstCoerce_WavAudio(PyObject *args, CPT(WavAudio) &coerced);
bool Dtool_Coerce_WavAudio(PyObject *args, PT(WavAudio) &coerced);

/**
 * Forward declarations for top-level class WavAudioCursor
 */
typedef WavAudioCursor WavAudioCursor_localtype;
Define_Module_ClassRef(panda3d.core, WavAudioCursor, WavAudioCursor_localtype, WavAudioCursor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WavAudioCursor = &Dtool_WavAudioCursor;
static void Dtool_PyModuleClassInit_WavAudioCursor(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"MovieAudio", &Dtool_MovieAudio},
  {"FlacAudio", &Dtool_FlacAudio},
  {"MovieAudioCursor", &Dtool_MovieAudioCursor},
  {"FlacAudioCursor", &Dtool_FlacAudioCursor},
  {"MovieVideo", &Dtool_MovieVideo},
  {"InkblotVideo", &Dtool_InkblotVideo},
  {"MovieVideoCursor", &Dtool_MovieVideoCursor},
  {"MovieVideoCursor::Buffer", &Dtool_MovieVideoCursor_Buffer},
  {"InkblotVideoCursor", &Dtool_InkblotVideoCursor},
  {"MicrophoneAudio", &Dtool_MicrophoneAudio},
  {"UserDataAudio", &Dtool_UserDataAudio},
  {"UserDataAudioCursor", &Dtool_UserDataAudioCursor},
  {"VorbisAudio", &Dtool_VorbisAudio},
  {"VorbisAudioCursor", &Dtool_VorbisAudioCursor},
  {"WavAudio", &Dtool_WavAudio},
  {"WavAudioCursor", &Dtool_WavAudioCursor},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::istream", nullptr},
#define Dtool_Ptr_std_istream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[2].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[3].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[4].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[5].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[6].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[7].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[8].type)
  {"Datagram", nullptr},
#define Dtool_Ptr_Datagram (imports[9].type)
  {"DatagramIterator", nullptr},
#define Dtool_Ptr_DatagramIterator (imports[10].type)
  {"SubfileInfo", nullptr},
#define Dtool_Ptr_SubfileInfo (imports[11].type)
  {"Texture", nullptr},
#define Dtool_Ptr_Texture (imports[12].type)
  {nullptr, nullptr},
};
#endif

// std::istream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_istream = &Dtool_std_istream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// Datagram
#ifndef LINK_ALL_STATIC
inline static Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced) {
  nassertr(Dtool_Ptr_Datagram != nullptr, nullptr);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != nullptr, nullptr);
  return ((Datagram *(*)(PyObject *, Datagram &))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced);
#endif
// DatagramIterator
#ifndef LINK_ALL_STATIC
inline static DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  nassertr(Dtool_Ptr_DatagramIterator != nullptr, nullptr);
  nassertr(Dtool_Ptr_DatagramIterator->_Dtool_Coerce != nullptr, nullptr);
  return ((DatagramIterator *(*)(PyObject *, DatagramIterator &))Dtool_Ptr_DatagramIterator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DatagramIterator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
extern DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);
#endif
// SubfileInfo
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_SubfileInfo;
static struct Dtool_PyTypedObject *const Dtool_Ptr_SubfileInfo = &Dtool_SubfileInfo;
#endif
// Texture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class MovieAudio
 */
/**
 * Python function wrapper for:
 * virtual PointerTo< MovieAudioCursor > MovieAudio::open(void)
 */
static PyObject *Dtool_MovieAudio_open_10(PyObject *self, PyObject *) {
  MovieAudio *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieAudio, (void **)&local_this, "MovieAudio.open")) {
    return nullptr;
  }
  // 1-virtual PointerTo< MovieAudioCursor > MovieAudio::open(void)
  PointerTo< MovieAudioCursor > return_value = ((*local_this).open)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  MovieAudioCursor *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MovieAudioCursor, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MovieAudio_open_10_comment =
  "C++ Interface:\n"
  "open(const MovieAudio self)\n"
  "\n"
  "/**\n"
  " * Open this audio, returning a MovieAudioCursor\n"
  " */";
#else
static const char *Dtool_MovieAudio_open_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< MovieAudio > MovieAudio::get(Filename const &name)
 */
static PyObject *Dtool_MovieAudio_get_11(PyObject *, PyObject *arg) {
  // 1-static PointerTo< MovieAudio > MovieAudio::get(Filename const &name)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "MovieAudio.get", "Filename");
  }
  PointerTo< MovieAudio > return_value = (MovieAudio::get)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  MovieAudio *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MovieAudio, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get(const Filename name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovieAudio_get_11_comment =
  "C++ Interface:\n"
  "get(const Filename name)\n"
  "\n"
  "/**\n"
  " * Obtains a MovieAudio that references a file.  Just calls\n"
  " * MovieTypeRegistry::make_audio().\n"
  " */";
#else
static const char *Dtool_MovieAudio_get_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &MovieAudio::get_filename(void) const
 */
static PyObject *Dtool_MovieAudio_get_filename_12(PyObject *self, PyObject *) {
  MovieAudio *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieAudio)) {
    return nullptr;
  }
  // 1-inline Filename const &MovieAudio::get_filename(void) const
  Filename const *return_value = &(((*(const MovieAudio*)local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudio_get_filename_12_comment =
  "C++ Interface:\n"
  "get_filename(MovieAudio self)\n"
  "\n"
  "/**\n"
  " * Returns the movie's filename.  A movie is not guaranteed to have a\n"
  " * filename, if not, then this function returns a null filename.\n"
  " */";
#else
static const char *Dtool_MovieAudio_get_filename_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MovieAudio::get_class_type(void)
 */
static PyObject *Dtool_MovieAudio_get_class_type_16(PyObject *, PyObject *) {
  // 1-static TypeHandle MovieAudio::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MovieAudio::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudio_get_class_type_16_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovieAudio_get_class_type_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *MovieAudio::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_3(PyObject *self, PyObject *) {
  MovieAudio *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieAudio, (void **)&local_this, "MovieAudio.upcast_to_TypedWritableReferenceCount")) {
    return nullptr;
  }
  // 1-TypedWritableReferenceCount *MovieAudio::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_3_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const MovieAudio self)\n"
  "\n"
  "upcast from MovieAudio to TypedWritableReferenceCount";
#else
static const char *Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *MovieAudio::upcast_to_Namable(void)
 */
static PyObject *Dtool_MovieAudio_upcast_to_Namable_6(PyObject *self, PyObject *) {
  MovieAudio *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieAudio, (void **)&local_this, "MovieAudio.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *MovieAudio::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudio_upcast_to_Namable_6_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const MovieAudio self)\n"
  "\n"
  "upcast from MovieAudio to Namable";
#else
static const char *Dtool_MovieAudio_upcast_to_Namable_6_comment = nullptr;
#endif

static PyObject *Dtool_MovieAudio_filename_Getter(PyObject *self, void *) {
  const MovieAudio *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieAudio, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename const &MovieAudio::get_filename(void) const
  Filename const *return_value = &(((*(const MovieAudio*)local_this).get_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

/**
 * Python function wrapper for:
 * inline MovieAudio::MovieAudio(MovieAudio const &) = default
 * explicit MovieAudio::MovieAudio(std::string const &name = "Blank Audio")
 */
static int Dtool_Init_MovieAudio(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit MovieAudio::MovieAudio(std::string const &name)
      MovieAudio *return_value = new MovieAudio();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieAudio, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline MovieAudio::MovieAudio(MovieAudio const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          MovieAudio const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_MovieAudio);
          if (param0_this != nullptr) {
            MovieAudio *return_value = new MovieAudio(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieAudio, true, false);
          }
        }
      }

      {
        // -2 explicit MovieAudio::MovieAudio(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:MovieAudio", (char **)keyword_list, &param0_str, &param0_len)) {
          MovieAudio *return_value = new MovieAudio(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieAudio, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline MovieAudio::MovieAudio(MovieAudio const &) = default
      // No coercion possible: explicit MovieAudio::MovieAudio(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MovieAudio() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MovieAudio()\n"
      "MovieAudio(const MovieAudio param0)\n"
      "MovieAudio(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MovieAudio(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MovieAudio) {
    printf("MovieAudio ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MovieAudio *local_this = (MovieAudio *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MovieAudio) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MovieAudio(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MovieAudio) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovieAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovieAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovieAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovieAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovieAudio*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class FlacAudio
 */
/**
 * Python function wrapper for:
 * static PointerTo< MovieAudio > FlacAudio::make(Filename const &name)
 */
static PyObject *Dtool_FlacAudio_make_19(PyObject *, PyObject *arg) {
  // 1-static PointerTo< MovieAudio > FlacAudio::make(Filename const &name)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "FlacAudio.make", "Filename");
  }
  PointerTo< MovieAudio > return_value = (FlacAudio::make)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  MovieAudio *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MovieAudio, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const Filename name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FlacAudio_make_19_comment =
  "C++ Interface:\n"
  "make(const Filename name)\n"
  "\n"
  "/**\n"
  " * Obtains a MovieAudio that references a file.\n"
  " */";
#else
static const char *Dtool_FlacAudio_make_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle FlacAudio::get_class_type(void)
 */
static PyObject *Dtool_FlacAudio_get_class_type_20(PyObject *, PyObject *) {
  // 1-static TypeHandle FlacAudio::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((FlacAudio::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FlacAudio_get_class_type_20_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FlacAudio_get_class_type_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * FlacAudio::FlacAudio(Filename const &name)
 * inline FlacAudio::FlacAudio(FlacAudio const &) = default
 */
static int Dtool_Init_FlacAudio(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "FlacAudio() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline FlacAudio::FlacAudio(FlacAudio const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      FlacAudio const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_FlacAudio);
      if (param0_this != nullptr) {
        FlacAudio *return_value = new FlacAudio(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FlacAudio, true, false);
      }
    }
  }

  {
    // -2 FlacAudio::FlacAudio(Filename const &name)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "name")) {
      Filename const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
      if (param0_this != nullptr) {
        FlacAudio *return_value = new FlacAudio(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FlacAudio, true, false);
      }
    }
  }

  {
    // -2 inline FlacAudio::FlacAudio(FlacAudio const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(FlacAudio) param0_this;
      if (Dtool_ConstCoerce_FlacAudio(param0, param0_this)) {
        FlacAudio *return_value = new FlacAudio(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FlacAudio, true, false);
      }
    }
  }

  {
    // -2 FlacAudio::FlacAudio(Filename const &name)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "name")) {
      Filename param0_local;
      Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
      if ((param0_this != nullptr)) {
        FlacAudio *return_value = new FlacAudio(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FlacAudio, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FlacAudio(const FlacAudio param0)\n"
      "FlacAudio(const Filename name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_FlacAudio(PyObject *args, CPT(FlacAudio) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_FlacAudio)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 FlacAudio::FlacAudio(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        FlacAudio *return_value = new FlacAudio(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

    {
      // -2 static PointerTo< MovieAudio > FlacAudio::make(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        PointerTo< MovieAudio > return_value = (FlacAudio::make)(*arg_this);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move(DCAST(FlacAudio, return_value.p()));
          return true;
        }
      }
    }

  }
  return false;
}

bool Dtool_Coerce_FlacAudio(PyObject *args, PT(FlacAudio) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_FlacAudio)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 FlacAudio::FlacAudio(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        FlacAudio *return_value = new FlacAudio(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

    {
      // -2 static PointerTo< MovieAudio > FlacAudio::make(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        PointerTo< MovieAudio > return_value = (FlacAudio::make)(*arg_this);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move(DCAST(FlacAudio, return_value.p()));
          return true;
        }
      }
    }

  }
  return false;
}

static void *Dtool_UpcastInterface_FlacAudio(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FlacAudio) {
    printf("FlacAudio ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FlacAudio *local_this = (FlacAudio *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FlacAudio) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieAudio) {
    return (MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FlacAudio(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FlacAudio) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieAudio) {
    MovieAudio* other_this = (MovieAudio*)from_this;
    return (FlacAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (FlacAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FlacAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FlacAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (FlacAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (FlacAudio*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MovieAudioCursor
 */
/**
 * Python function wrapper for:
 * inline PointerTo< MovieAudio > MovieAudioCursor::get_source(void) const
 */
static PyObject *Dtool_MovieAudioCursor_get_source_23(PyObject *self, PyObject *) {
  MovieAudioCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieAudioCursor)) {
    return nullptr;
  }
  // 1-inline PointerTo< MovieAudio > MovieAudioCursor::get_source(void) const
  PointerTo< MovieAudio > return_value = ((*(const MovieAudioCursor*)local_this).get_source)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  MovieAudio *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MovieAudio, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_get_source_23_comment =
  "C++ Interface:\n"
  "get_source(MovieAudioCursor self)\n"
  "\n"
  "/**\n"
  " * Returns the MovieAudio which this cursor references.\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_get_source_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int MovieAudioCursor::audio_rate(void) const
 */
static PyObject *Dtool_MovieAudioCursor_audio_rate_24(PyObject *self, PyObject *) {
  MovieAudioCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieAudioCursor)) {
    return nullptr;
  }
  // 1-inline int MovieAudioCursor::audio_rate(void) const
  int return_value = ((*(const MovieAudioCursor*)local_this).audio_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_audio_rate_24_comment =
  "C++ Interface:\n"
  "audio_rate(MovieAudioCursor self)\n"
  "\n"
  "/**\n"
  " * Returns the audio sample rate.\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_audio_rate_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int MovieAudioCursor::audio_channels(void) const
 */
static PyObject *Dtool_MovieAudioCursor_audio_channels_25(PyObject *self, PyObject *) {
  MovieAudioCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieAudioCursor)) {
    return nullptr;
  }
  // 1-inline int MovieAudioCursor::audio_channels(void) const
  int return_value = ((*(const MovieAudioCursor*)local_this).audio_channels)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_audio_channels_25_comment =
  "C++ Interface:\n"
  "audio_channels(MovieAudioCursor self)\n"
  "\n"
  "/**\n"
  " * Returns the number of audio channels (ie, two for stereo, one for mono).\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_audio_channels_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double MovieAudioCursor::length(void) const
 */
static PyObject *Dtool_MovieAudioCursor_length_26(PyObject *self, PyObject *) {
  MovieAudioCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieAudioCursor)) {
    return nullptr;
  }
  // 1-inline double MovieAudioCursor::length(void) const
  double return_value = ((*(const MovieAudioCursor*)local_this).length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_length_26_comment =
  "C++ Interface:\n"
  "length(MovieAudioCursor self)\n"
  "\n"
  "/**\n"
  " * Returns the length of the movie.  Attempting to read audio samples beyond\n"
  " * the specified length will produce silent samples.\n"
  " *\n"
  " * Some kinds of Movie, such as internet TV station, might not have a\n"
  " * predictable length.  In that case, the length will be set to a very large\n"
  " * number: 1.0E10.\n"
  " *\n"
  " * Some AVI files have incorrect length values encoded into them - they may be\n"
  " * a second or two long or short.  When playing such an AVI using the Movie\n"
  " * class, you may see a slightly truncated video, or a slightly elongated\n"
  " * video (padded with black frames).  There are utilities out there to fix the\n"
  " * length values in AVI files.\n"
  " *\n"
  " * An audio consumer needs to check the length, the ready status, and the\n"
  " * aborted flag.\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_length_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MovieAudioCursor::can_seek(void) const
 */
static PyObject *Dtool_MovieAudioCursor_can_seek_27(PyObject *self, PyObject *) {
  MovieAudioCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieAudioCursor)) {
    return nullptr;
  }
  // 1-inline bool MovieAudioCursor::can_seek(void) const
  bool return_value = ((*(const MovieAudioCursor*)local_this).can_seek)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_can_seek_27_comment =
  "C++ Interface:\n"
  "can_seek(MovieAudioCursor self)\n"
  "\n"
  "/**\n"
  " * Returns true if the movie can seek.  If this is true, seeking is still not\n"
  " * guaranteed to be fast: for some movies, seeking is implemented by rewinding\n"
  " * to the beginning and then fast-forwarding to the desired location.  Even if\n"
  " * the movie cannot seek, the seek method can still advance to an arbitrary\n"
  " * location by reading samples and discarding them.  However, to move\n"
  " * backward, can_seek must return true.\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_can_seek_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MovieAudioCursor::can_seek_fast(void) const
 */
static PyObject *Dtool_MovieAudioCursor_can_seek_fast_28(PyObject *self, PyObject *) {
  MovieAudioCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieAudioCursor)) {
    return nullptr;
  }
  // 1-inline bool MovieAudioCursor::can_seek_fast(void) const
  bool return_value = ((*(const MovieAudioCursor*)local_this).can_seek_fast)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_can_seek_fast_28_comment =
  "C++ Interface:\n"
  "can_seek_fast(MovieAudioCursor self)\n"
  "\n"
  "/**\n"
  " * Returns true if seek operations are constant time.\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_can_seek_fast_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double MovieAudioCursor::tell(void) const
 */
static PyObject *Dtool_MovieAudioCursor_tell_29(PyObject *self, PyObject *) {
  MovieAudioCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieAudioCursor)) {
    return nullptr;
  }
  // 1-inline double MovieAudioCursor::tell(void) const
  double return_value = ((*(const MovieAudioCursor*)local_this).tell)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_tell_29_comment =
  "C++ Interface:\n"
  "tell(MovieAudioCursor self)\n"
  "\n"
  "/**\n"
  " * Returns the current offset within the file.\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_tell_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void MovieAudioCursor::skip_samples(int n)
 */
static PyObject *Dtool_MovieAudioCursor_skip_samples_30(PyObject *self, PyObject *arg) {
  MovieAudioCursor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieAudioCursor, (void **)&local_this, "MovieAudioCursor.skip_samples")) {
    return nullptr;
  }
  // 1-inline void MovieAudioCursor::skip_samples(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).skip_samples)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "skip_samples(const MovieAudioCursor self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_skip_samples_30_comment =
  "C++ Interface:\n"
  "skip_samples(const MovieAudioCursor self, int n)\n"
  "\n"
  "/**\n"
  " * Skip audio samples from the stream.  This is mostly for debugging purposes.\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_skip_samples_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MovieAudioCursor::aborted(void) const
 */
static PyObject *Dtool_MovieAudioCursor_aborted_31(PyObject *self, PyObject *) {
  MovieAudioCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieAudioCursor)) {
    return nullptr;
  }
  // 1-inline bool MovieAudioCursor::aborted(void) const
  bool return_value = ((*(const MovieAudioCursor*)local_this).aborted)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_aborted_31_comment =
  "C++ Interface:\n"
  "aborted(MovieAudioCursor self)\n"
  "\n"
  "/**\n"
  " * If aborted is true, it means that the \"ready\" samples are not being\n"
  " * replenished.  See the method \"ready\" for an explanation.\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_aborted_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int MovieAudioCursor::ready(void) const
 */
static PyObject *Dtool_MovieAudioCursor_ready_32(PyObject *self, PyObject *) {
  MovieAudioCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieAudioCursor)) {
    return nullptr;
  }
  // 1-virtual int MovieAudioCursor::ready(void) const
  int return_value = ((*(const MovieAudioCursor*)local_this).ready)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_ready_32_comment =
  "C++ Interface:\n"
  "ready(MovieAudioCursor self)\n"
  "\n"
  "/**\n"
  " * Returns the number of audio samples that are ready to read.  This is\n"
  " * primarily relevant for sources like microphones which produce samples at a\n"
  " * fixed rate.  If you try to read more samples than are ready, the result\n"
  " * will be silent samples.\n"
  " *\n"
  " * Some audio streams do not have a limit on how fast they can produce\n"
  " * samples.  Such streams will always return 0x40000000 as the ready-count.\n"
  " * This may well exceed the length of the audio stream.  You therefore need to\n"
  " * check length separately.\n"
  " *\n"
  " * If the aborted flag is set, that means the ready count is no longer being\n"
  " * replenished.  For example, a MovieAudioCursor might be reading from an\n"
  " * internet radio station, and it might buffer data to avoid underruns.  If it\n"
  " * loses connection to the radio station, it will set the aborted flag to\n"
  " * indicate that the buffer is no longer being replenished.  But it is still\n"
  " * ok to read the samples that are in the buffer, at least until they run out.\n"
  " * Once those are gone, there will be no more.\n"
  " *\n"
  " * An audio consumer needs to check the length, the ready status, and the\n"
  " * aborted flag.\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_ready_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void MovieAudioCursor::seek(double offset)
 */
static PyObject *Dtool_MovieAudioCursor_seek_33(PyObject *self, PyObject *arg) {
  MovieAudioCursor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieAudioCursor, (void **)&local_this, "MovieAudioCursor.seek")) {
    return nullptr;
  }
  // 1-virtual void MovieAudioCursor::seek(double offset)
  if (PyNumber_Check(arg)) {
    ((*local_this).seek)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "seek(const MovieAudioCursor self, double offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_seek_33_comment =
  "C++ Interface:\n"
  "seek(const MovieAudioCursor self, double offset)\n"
  "\n"
  "/**\n"
  " * Skips to the specified offset within the file.\n"
  " *\n"
  " * If the movie reports that it cannot seek, then this method can still\n"
  " * advance by reading samples and discarding them.  However, to move backward,\n"
  " * can_seek must be true.\n"
  " *\n"
  " * If the movie reports that it can_seek, it doesn't mean that it can do so\n"
  " * quickly.  It may have to rewind the movie and then fast forward to the\n"
  " * desired location.  Only if can_seek_fast returns true can seek operations\n"
  " * be done in constant time.\n"
  " *\n"
  " * Seeking may not be precise, because AVI files often have inaccurate\n"
  " * indices.  After seeking, tell will indicate that the cursor is at the\n"
  " * target location.  However, in truth, the data you read may come from a\n"
  " * slightly offset location.\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_seek_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * vector_uchar MovieAudioCursor::read_samples(int n)
 * void MovieAudioCursor::read_samples(int n, Datagram *dg)
 */
static PyObject *Dtool_MovieAudioCursor_read_samples_34(PyObject *self, PyObject *args, PyObject *kwds) {
  MovieAudioCursor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieAudioCursor, (void **)&local_this, "MovieAudioCursor.read_samples")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "n")) {
        // 1-vector_uchar MovieAudioCursor::read_samples(int n)
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          vector_uchar return_value = ((*local_this).read_samples)((int)arg_val);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-void MovieAudioCursor::read_samples(int n, Datagram *dg)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "dg", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:read_samples", (char **)keyword_list, &param1, &param2)) {
        Datagram param2_local;
        Datagram *param2_this = Dtool_Coerce_Datagram(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "MovieAudioCursor.read_samples", "Datagram");
        }
        ((*local_this).read_samples)((int)param1, param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "read_samples() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_samples(const MovieAudioCursor self, int n)\n"
      "read_samples(const MovieAudioCursor self, int n, Datagram dg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_read_samples_34_comment =
  "C++ Interface:\n"
  "read_samples(const MovieAudioCursor self, int n)\n"
  "read_samples(const MovieAudioCursor self, int n, Datagram dg)\n"
  "\n"
  "/**\n"
  " * Read audio samples from the stream.  N is the number of samples you wish to\n"
  " * read.  Your buffer must be equal in size to N * channels.  Multiple-channel\n"
  " * audio will be interleaved.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Read audio samples from the stream into a Datagram.  N is the number of\n"
  " * samples you wish to read.  Multiple-channel audio will be interleaved.\n"
  " *\n"
  " * This is not particularly efficient, but it may be a convenient way to\n"
  " * manipulate samples in python.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Read audio samples from the stream and returns them as a string.  The\n"
  " * samples are stored little-endian in the string.  N is the number of samples\n"
  " * you wish to read.  Multiple-channel audio will be interleaved.\n"
  " *\n"
  " * This is not particularly efficient, but it may be a convenient way to\n"
  " * manipulate samples in python.\n"
  " */";
#else
static const char *Dtool_MovieAudioCursor_read_samples_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MovieAudioCursor::get_class_type(void)
 */
static PyObject *Dtool_MovieAudioCursor_get_class_type_35(PyObject *, PyObject *) {
  // 1-static TypeHandle MovieAudioCursor::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MovieAudioCursor::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovieAudioCursor_get_class_type_35_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovieAudioCursor_get_class_type_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * MovieAudioCursor::MovieAudioCursor(MovieAudio *src)
 * inline MovieAudioCursor::MovieAudioCursor(MovieAudioCursor const &) = default
 */
static int Dtool_Init_MovieAudioCursor(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "MovieAudioCursor() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 MovieAudioCursor::MovieAudioCursor(MovieAudio *src)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "src")) {
      MovieAudio *param0_this = (MovieAudio *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_MovieAudio, 0, "MovieAudioCursor.MovieAudioCursor", false, false);
      if (param0_this != nullptr) {
        MovieAudioCursor *return_value = new MovieAudioCursor(param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieAudioCursor, true, false);
      }
    }
  }

  // No coercion possible: MovieAudioCursor::MovieAudioCursor(MovieAudio *src)
  {
    // -2 inline MovieAudioCursor::MovieAudioCursor(MovieAudioCursor const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(MovieAudioCursor) param0_this;
      if (Dtool_ConstCoerce_MovieAudioCursor(param0, param0_this)) {
        MovieAudioCursor *return_value = new MovieAudioCursor(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieAudioCursor, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MovieAudioCursor(MovieAudio src)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_MovieAudioCursor(PyObject *args, CPT(MovieAudioCursor) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_MovieAudioCursor)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-MovieAudioCursor::MovieAudioCursor(MovieAudio *src)
    MovieAudio *arg_this = (MovieAudio *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MovieAudio, 0, "MovieAudioCursor.MovieAudioCursor", false, false);
    if (arg_this != nullptr) {
      MovieAudioCursor *return_value = new MovieAudioCursor(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_MovieAudioCursor(PyObject *args, PT(MovieAudioCursor) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_MovieAudioCursor)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-MovieAudioCursor::MovieAudioCursor(MovieAudio *src)
    MovieAudio *arg_this = (MovieAudio *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MovieAudio, 0, "MovieAudioCursor.MovieAudioCursor", false, false);
    if (arg_this != nullptr) {
      MovieAudioCursor *return_value = new MovieAudioCursor(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_MovieAudioCursor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MovieAudioCursor) {
    printf("MovieAudioCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MovieAudioCursor *local_this = (MovieAudioCursor *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MovieAudioCursor) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MovieAudioCursor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MovieAudioCursor) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovieAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovieAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovieAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovieAudioCursor*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class FlacAudioCursor
 */
/**
 * Python function wrapper for:
 * static TypeHandle FlacAudioCursor::get_class_type(void)
 */
static PyObject *Dtool_FlacAudioCursor_get_class_type_38(PyObject *, PyObject *) {
  // 1-static TypeHandle FlacAudioCursor::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((FlacAudioCursor::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FlacAudioCursor_get_class_type_38_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FlacAudioCursor_get_class_type_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit FlacAudioCursor::FlacAudioCursor(FlacAudio *src, std::istream *stream)
 * inline FlacAudioCursor::FlacAudioCursor(FlacAudioCursor const &) = default
 */
static int Dtool_Init_FlacAudioCursor(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline FlacAudioCursor::FlacAudioCursor(FlacAudioCursor const &) = default
      FlacAudioCursor const *arg_this = (FlacAudioCursor *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FlacAudioCursor, 0, "FlacAudioCursor.FlacAudioCursor", true, true);
      if (arg_this != nullptr) {
        FlacAudioCursor *return_value = new FlacAudioCursor(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FlacAudioCursor, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-explicit FlacAudioCursor::FlacAudioCursor(FlacAudio *src, std::istream *stream)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"src", "stream", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:FlacAudioCursor", (char **)keyword_list, &param0, &param1)) {
        PT(FlacAudio) param0_this;
        if (!Dtool_Coerce_FlacAudio(param0, param0_this)) {
          Dtool_Raise_ArgTypeError(param0, 0, "FlacAudioCursor.FlacAudioCursor", "FlacAudio");
          return -1;
        }
        std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "FlacAudioCursor.FlacAudioCursor", false, true);
        if (param1_this != nullptr) {
          FlacAudioCursor *return_value = new FlacAudioCursor(std::move(param0_this), param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FlacAudioCursor, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "FlacAudioCursor() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FlacAudioCursor(const FlacAudioCursor param0)\n"
      "FlacAudioCursor(FlacAudio src, istream stream)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_FlacAudioCursor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FlacAudioCursor) {
    printf("FlacAudioCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FlacAudioCursor *local_this = (FlacAudioCursor *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FlacAudioCursor) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieAudioCursor) {
    return (MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FlacAudioCursor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FlacAudioCursor) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieAudioCursor) {
    MovieAudioCursor* other_this = (MovieAudioCursor*)from_this;
    return (FlacAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FlacAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FlacAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (FlacAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (FlacAudioCursor*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MovieVideo
 */
/**
 * Python function wrapper for:
 * virtual PointerTo< MovieVideoCursor > MovieVideo::open(void)
 */
static PyObject *Dtool_MovieVideo_open_46(PyObject *self, PyObject *) {
  MovieVideo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieVideo, (void **)&local_this, "MovieVideo.open")) {
    return nullptr;
  }
  // 1-virtual PointerTo< MovieVideoCursor > MovieVideo::open(void)
  PointerTo< MovieVideoCursor > return_value = ((*local_this).open)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  MovieVideoCursor *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MovieVideoCursor, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MovieVideo_open_46_comment =
  "C++ Interface:\n"
  "open(const MovieVideo self)\n"
  "\n"
  "/**\n"
  " * Open this video, returning a MovieVideoCursor of the appropriate type.\n"
  " * Returns NULL on error.\n"
  " */";
#else
static const char *Dtool_MovieVideo_open_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< MovieVideo > MovieVideo::get(Filename const &name)
 */
static PyObject *Dtool_MovieVideo_get_47(PyObject *, PyObject *arg) {
  // 1-static PointerTo< MovieVideo > MovieVideo::get(Filename const &name)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "MovieVideo.get", "Filename");
  }
  PointerTo< MovieVideo > return_value = (MovieVideo::get)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  MovieVideo *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MovieVideo, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get(const Filename name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovieVideo_get_47_comment =
  "C++ Interface:\n"
  "get(const Filename name)\n"
  "\n"
  "/**\n"
  " * Obtains a MovieVideo that references a file.  Just calls\n"
  " * MovieTypeRegistry::make_video().\n"
  " */";
#else
static const char *Dtool_MovieVideo_get_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &MovieVideo::get_filename(void) const
 */
static PyObject *Dtool_MovieVideo_get_filename_48(PyObject *self, PyObject *) {
  MovieVideo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideo)) {
    return nullptr;
  }
  // 1-inline Filename const &MovieVideo::get_filename(void) const
  Filename const *return_value = &(((*(const MovieVideo*)local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideo_get_filename_48_comment =
  "C++ Interface:\n"
  "get_filename(MovieVideo self)\n"
  "\n"
  "/**\n"
  " * Returns the movie's filename.  A movie is not guaranteed to have a\n"
  " * filename, if not, then this function returns an empty filename.\n"
  " */";
#else
static const char *Dtool_MovieVideo_get_filename_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SubfileInfo const &MovieVideo::get_subfile_info(void) const
 */
static PyObject *Dtool_MovieVideo_get_subfile_info_49(PyObject *self, PyObject *) {
  MovieVideo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideo)) {
    return nullptr;
  }
  // 1-inline SubfileInfo const &MovieVideo::get_subfile_info(void) const
  SubfileInfo const *return_value = &(((*(const MovieVideo*)local_this).get_subfile_info)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SubfileInfo, false, true);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideo_get_subfile_info_49_comment =
  "C++ Interface:\n"
  "get_subfile_info(MovieVideo self)\n"
  "\n"
  "/**\n"
  " * If the movie is to be loaded from a subfile on disk, this returns the\n"
  " * subfile info.  Check info.is_empty() to see if this is valid data.\n"
  " */";
#else
static const char *Dtool_MovieVideo_get_subfile_info_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MovieVideo::get_class_type(void)
 */
static PyObject *Dtool_MovieVideo_get_class_type_54(PyObject *, PyObject *) {
  // 1-static TypeHandle MovieVideo::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MovieVideo::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideo_get_class_type_54_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovieVideo_get_class_type_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *MovieVideo::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_40(PyObject *self, PyObject *) {
  MovieVideo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieVideo, (void **)&local_this, "MovieVideo.upcast_to_TypedWritableReferenceCount")) {
    return nullptr;
  }
  // 1-TypedWritableReferenceCount *MovieVideo::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_40_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const MovieVideo self)\n"
  "\n"
  "upcast from MovieVideo to TypedWritableReferenceCount";
#else
static const char *Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *MovieVideo::upcast_to_Namable(void)
 */
static PyObject *Dtool_MovieVideo_upcast_to_Namable_42(PyObject *self, PyObject *) {
  MovieVideo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieVideo, (void **)&local_this, "MovieVideo.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *MovieVideo::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideo_upcast_to_Namable_42_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const MovieVideo self)\n"
  "\n"
  "upcast from MovieVideo to Namable";
#else
static const char *Dtool_MovieVideo_upcast_to_Namable_42_comment = nullptr;
#endif

static PyObject *Dtool_MovieVideo_filename_Getter(PyObject *self, void *) {
  const MovieVideo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieVideo, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename const &MovieVideo::get_filename(void) const
  Filename const *return_value = &(((*(const MovieVideo*)local_this).get_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_MovieVideo_subfile_info_Getter(PyObject *self, void *) {
  const MovieVideo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieVideo, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SubfileInfo const &MovieVideo::get_subfile_info(void) const
  SubfileInfo const *return_value = &(((*(const MovieVideo*)local_this).get_subfile_info)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SubfileInfo, false, true);
}

/**
 * Python function wrapper for:
 * inline MovieVideo::MovieVideo(MovieVideo const &) = default
 * MovieVideo::MovieVideo(std::string const &name = "Blank Video")
 */
static int Dtool_Init_MovieVideo(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-MovieVideo::MovieVideo(std::string const &name)
      MovieVideo *return_value = new MovieVideo();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieVideo, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline MovieVideo::MovieVideo(MovieVideo const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          MovieVideo const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_MovieVideo);
          if (param0_this != nullptr) {
            MovieVideo *return_value = new MovieVideo(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieVideo, true, false);
          }
        }
      }

      {
        // -2 MovieVideo::MovieVideo(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:MovieVideo", (char **)keyword_list, &param0_str, &param0_len)) {
          MovieVideo *return_value = new MovieVideo(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieVideo, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline MovieVideo::MovieVideo(MovieVideo const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          CPT(MovieVideo) param0_this;
          if (Dtool_ConstCoerce_MovieVideo(param0, param0_this)) {
            MovieVideo *return_value = new MovieVideo(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieVideo, true, false);
          }
        }
      }

      // No coercion possible: MovieVideo::MovieVideo(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MovieVideo() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MovieVideo()\n"
      "MovieVideo(const MovieVideo param0)\n"
      "MovieVideo(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_MovieVideo(PyObject *args, CPT(MovieVideo) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_MovieVideo)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-MovieVideo::MovieVideo(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      MovieVideo *return_value = new MovieVideo(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_MovieVideo(PyObject *args, PT(MovieVideo) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_MovieVideo)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-MovieVideo::MovieVideo(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      MovieVideo *return_value = new MovieVideo(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_MovieVideo(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MovieVideo) {
    printf("MovieVideo ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MovieVideo *local_this = (MovieVideo *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MovieVideo) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MovieVideo(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MovieVideo) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovieVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovieVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovieVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovieVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovieVideo*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InkblotVideo
 */
/**
 * Python function wrapper for:
 * static TypeHandle InkblotVideo::get_class_type(void)
 */
static PyObject *Dtool_InkblotVideo_get_class_type_57(PyObject *, PyObject *) {
  // 1-static TypeHandle InkblotVideo::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((InkblotVideo::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InkblotVideo_get_class_type_57_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_InkblotVideo_get_class_type_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InkblotVideo::InkblotVideo(InkblotVideo const &) = default
 * explicit InkblotVideo::InkblotVideo(int x, int y, int fps)
 */
static int Dtool_Init_InkblotVideo(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline InkblotVideo::InkblotVideo(InkblotVideo const &) = default
      InkblotVideo const *arg_this = (InkblotVideo *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InkblotVideo, 0, "InkblotVideo.InkblotVideo", true, true);
      if (arg_this != nullptr) {
        InkblotVideo *return_value = new InkblotVideo(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InkblotVideo, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-explicit InkblotVideo::InkblotVideo(int x, int y, int fps)
      int param0;
      int param1;
      int param2;
      static const char *keyword_list[] = {"x", "y", "fps", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:InkblotVideo", (char **)keyword_list, &param0, &param1, &param2)) {
        InkblotVideo *return_value = new InkblotVideo((int)param0, (int)param1, (int)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InkblotVideo, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "InkblotVideo() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "InkblotVideo(const InkblotVideo param0)\n"
      "InkblotVideo(int x, int y, int fps)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_InkblotVideo(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InkblotVideo) {
    printf("InkblotVideo ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InkblotVideo *local_this = (InkblotVideo *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InkblotVideo) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieVideo) {
    return (MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InkblotVideo(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InkblotVideo) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieVideo) {
    MovieVideo* other_this = (MovieVideo*)from_this;
    return (InkblotVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (InkblotVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (InkblotVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (InkblotVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (InkblotVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (InkblotVideo*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MovieVideoCursor
 */
/**
 * Python function wrapper for:
 * PointerTo< MovieVideo > MovieVideoCursor::get_source(void) const
 */
static PyObject *Dtool_MovieVideoCursor_get_source_59(PyObject *self, PyObject *) {
  MovieVideoCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor)) {
    return nullptr;
  }
  // 1-PointerTo< MovieVideo > MovieVideoCursor::get_source(void) const
  PointerTo< MovieVideo > return_value = ((*(const MovieVideoCursor*)local_this).get_source)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  MovieVideo *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MovieVideo, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_get_source_59_comment =
  "C++ Interface:\n"
  "get_source(MovieVideoCursor self)\n"
  "\n"
  "/**\n"
  " * Get the MovieVideo which this cursor references.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_get_source_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int MovieVideoCursor::size_x(void) const
 */
static PyObject *Dtool_MovieVideoCursor_size_x_60(PyObject *self, PyObject *) {
  MovieVideoCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor)) {
    return nullptr;
  }
  // 1-inline int MovieVideoCursor::size_x(void) const
  int return_value = ((*(const MovieVideoCursor*)local_this).size_x)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_size_x_60_comment =
  "C++ Interface:\n"
  "size_x(MovieVideoCursor self)\n"
  "\n"
  "/**\n"
  " * Get the horizontal size of the movie.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_size_x_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int MovieVideoCursor::size_y(void) const
 */
static PyObject *Dtool_MovieVideoCursor_size_y_61(PyObject *self, PyObject *) {
  MovieVideoCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor)) {
    return nullptr;
  }
  // 1-inline int MovieVideoCursor::size_y(void) const
  int return_value = ((*(const MovieVideoCursor*)local_this).size_y)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_size_y_61_comment =
  "C++ Interface:\n"
  "size_y(MovieVideoCursor self)\n"
  "\n"
  "/**\n"
  " * Get the vertical size of the movie.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_size_y_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int MovieVideoCursor::get_num_components(void) const
 */
static PyObject *Dtool_MovieVideoCursor_get_num_components_62(PyObject *self, PyObject *) {
  MovieVideoCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor)) {
    return nullptr;
  }
  // 1-inline int MovieVideoCursor::get_num_components(void) const
  int return_value = ((*(const MovieVideoCursor*)local_this).get_num_components)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_get_num_components_62_comment =
  "C++ Interface:\n"
  "get_num_components(MovieVideoCursor self)\n"
  "\n"
  "/**\n"
  " * Returns 4 if the movie has an alpha channel, 3 otherwise.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_get_num_components_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double MovieVideoCursor::length(void) const
 */
static PyObject *Dtool_MovieVideoCursor_length_63(PyObject *self, PyObject *) {
  MovieVideoCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor)) {
    return nullptr;
  }
  // 1-inline double MovieVideoCursor::length(void) const
  double return_value = ((*(const MovieVideoCursor*)local_this).length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_length_63_comment =
  "C++ Interface:\n"
  "length(MovieVideoCursor self)\n"
  "\n"
  "/**\n"
  " * Returns the length of the movie.\n"
  " *\n"
  " * Some kinds of Movie, such as internet TV station, might not have a\n"
  " * predictable length.  In that case, the length will be set to a very large\n"
  " * number: 1.0E10. If the internet TV station goes offline, the video or audio\n"
  " * stream will set its abort flag.  Reaching the end of the movie (ie, the\n"
  " * specified length) normally does not cause the abort flag to be set.\n"
  " *\n"
  " * The video and audio streams produced by get_video and get_audio are always\n"
  " * of unlimited duration - you can always read another video frame or another\n"
  " * audio sample.  This is true even if the specified length is reached, or an\n"
  " * abort is flagged.  If either stream runs out of data, it will synthesize\n"
  " * blank video frames and silent audio samples as necessary to satisfy read\n"
  " * requests.\n"
  " *\n"
  " * Some AVI files have incorrect length values encoded into them - usually,\n"
  " * they're a second or two long or short.  When playing such an AVI using the\n"
  " * Movie class, you may see a slightly truncated video, or a slightly\n"
  " * elongated video (padded with black frames).  There are utilities out there\n"
  " * to fix the length values in AVI files.\n"
  " *\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_length_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MovieVideoCursor::can_seek(void) const
 */
static PyObject *Dtool_MovieVideoCursor_can_seek_64(PyObject *self, PyObject *) {
  MovieVideoCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor)) {
    return nullptr;
  }
  // 1-inline bool MovieVideoCursor::can_seek(void) const
  bool return_value = ((*(const MovieVideoCursor*)local_this).can_seek)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_can_seek_64_comment =
  "C++ Interface:\n"
  "can_seek(MovieVideoCursor self)\n"
  "\n"
  "/**\n"
  " * Returns true if the movie can seek.  If this is true, seeking is still not\n"
  " * guaranteed to be fast: for some movies, seeking is implemented by rewinding\n"
  " * to the beginning and then fast-forwarding to the desired location.  Even if\n"
  " * the movie cannot seek, the fetch methods can still advance to an arbitrary\n"
  " * location by reading frames and discarding them.  However, to move backward,\n"
  " * can_seek must return true.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_can_seek_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MovieVideoCursor::can_seek_fast(void) const
 */
static PyObject *Dtool_MovieVideoCursor_can_seek_fast_65(PyObject *self, PyObject *) {
  MovieVideoCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor)) {
    return nullptr;
  }
  // 1-inline bool MovieVideoCursor::can_seek_fast(void) const
  bool return_value = ((*(const MovieVideoCursor*)local_this).can_seek_fast)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_can_seek_fast_65_comment =
  "C++ Interface:\n"
  "can_seek_fast(MovieVideoCursor self)\n"
  "\n"
  "/**\n"
  " * Returns true if seek operations are constant time.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_can_seek_fast_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MovieVideoCursor::aborted(void) const
 */
static PyObject *Dtool_MovieVideoCursor_aborted_66(PyObject *self, PyObject *) {
  MovieVideoCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor)) {
    return nullptr;
  }
  // 1-inline bool MovieVideoCursor::aborted(void) const
  bool return_value = ((*(const MovieVideoCursor*)local_this).aborted)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_aborted_66_comment =
  "C++ Interface:\n"
  "aborted(MovieVideoCursor self)\n"
  "\n"
  "/**\n"
  " * Returns true if the video has aborted prematurely.  For example, this could\n"
  " * occur if the Movie was actually an internet TV station, and the connection\n"
  " * was lost.  Reaching the normal end of the video does not constitute an\n"
  " * 'abort' condition.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_aborted_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MovieVideoCursor::ready(void) const
 */
static PyObject *Dtool_MovieVideoCursor_ready_67(PyObject *self, PyObject *) {
  MovieVideoCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor)) {
    return nullptr;
  }
  // 1-inline bool MovieVideoCursor::ready(void) const
  bool return_value = ((*(const MovieVideoCursor*)local_this).ready)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_ready_67_comment =
  "C++ Interface:\n"
  "ready(MovieVideoCursor self)\n"
  "\n"
  "/**\n"
  " * Returns true if the cursor is a streaming source, and if a video frame is\n"
  " * ready to be read.  For non- streaming sources, this is always false.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_ready_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MovieVideoCursor::streaming(void) const
 */
static PyObject *Dtool_MovieVideoCursor_streaming_68(PyObject *self, PyObject *) {
  MovieVideoCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor)) {
    return nullptr;
  }
  // 1-inline bool MovieVideoCursor::streaming(void) const
  bool return_value = ((*(const MovieVideoCursor*)local_this).streaming)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_streaming_68_comment =
  "C++ Interface:\n"
  "streaming(MovieVideoCursor self)\n"
  "\n"
  "/**\n"
  " * Returns true if the video frames are being \"pushed\" at us by something that\n"
  " * operates at its own speed - for example, a webcam.  In this case, the\n"
  " * frames come when they're ready to come.  Attempting to read too soon will\n"
  " * produce nothing, reading too late will cause frames to be dropped.  In this\n"
  " * case, the ready flag can be used to determine whether or not a frame is\n"
  " * ready for reading.\n"
  " *\n"
  " * When streaming, you should still pay attention to last_start, but the value\n"
  " * of next_start is only a guess.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_streaming_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void MovieVideoCursor::setup_texture(Texture *tex) const
 */
static PyObject *Dtool_MovieVideoCursor_setup_texture_69(PyObject *self, PyObject *arg) {
  MovieVideoCursor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor)) {
    return nullptr;
  }
  // 1-void MovieVideoCursor::setup_texture(Texture *tex) const
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "MovieVideoCursor.setup_texture", false, true);
  if (arg_this != nullptr) {
    ((*(const MovieVideoCursor*)local_this).setup_texture)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_texture(MovieVideoCursor self, Texture tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_setup_texture_69_comment =
  "C++ Interface:\n"
  "setup_texture(MovieVideoCursor self, Texture tex)\n"
  "\n"
  "/**\n"
  " * Set up the specified Texture object to contain content from this movie.\n"
  " * This should be called once, not every frame.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_setup_texture_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool MovieVideoCursor::set_time(double timestamp, int loop_count)
 */
static PyObject *Dtool_MovieVideoCursor_set_time_70(PyObject *self, PyObject *args, PyObject *kwds) {
  MovieVideoCursor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieVideoCursor, (void **)&local_this, "MovieVideoCursor.set_time")) {
    return nullptr;
  }
  // 1-virtual bool MovieVideoCursor::set_time(double timestamp, int loop_count)
  double param1;
  int param2;
  static const char *keyword_list[] = {"timestamp", "loop_count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "di:set_time", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*local_this).set_time)((double)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_time(const MovieVideoCursor self, double timestamp, int loop_count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_set_time_70_comment =
  "C++ Interface:\n"
  "set_time(const MovieVideoCursor self, double timestamp, int loop_count)\n"
  "\n"
  "/**\n"
  " * Updates the cursor to the indicated time.  If loop_count >= 1, the time is\n"
  " * clamped to the movie's length * loop_count.  If loop_count <= 0, the time\n"
  " * is understood to be modulo the movie's length.\n"
  " *\n"
  " * Returns true if a new frame is now available, false otherwise.  If this\n"
  " * returns true, you should immediately follow this with exactly *one* call to\n"
  " * fetch_buffer().\n"
  " *\n"
  " * If the movie reports that it can_seek, you may also specify a time value\n"
  " * less than the previous value you passed to set_time().  Otherwise, you may\n"
  " * only specify a time value greater than or equal to the previous value.\n"
  " *\n"
  " * If the movie reports that it can_seek, it doesn't mean that it can do so\n"
  " * quickly.  It may have to rewind the movie and then fast forward to the\n"
  " * desired location.  Only if can_seek_fast returns true can it seek rapidly.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_set_time_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PointerTo< MovieVideoCursor::Buffer > MovieVideoCursor::fetch_buffer(void)
 */
static PyObject *Dtool_MovieVideoCursor_fetch_buffer_77(PyObject *self, PyObject *) {
  MovieVideoCursor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieVideoCursor, (void **)&local_this, "MovieVideoCursor.fetch_buffer")) {
    return nullptr;
  }
  // 1-virtual PointerTo< MovieVideoCursor::Buffer > MovieVideoCursor::fetch_buffer(void)
  PointerTo< MovieVideoCursor::Buffer > return_value = ((*local_this).fetch_buffer)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  MovieVideoCursor::Buffer *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MovieVideoCursor_Buffer, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_fetch_buffer_77_comment =
  "C++ Interface:\n"
  "fetch_buffer(const MovieVideoCursor self)\n"
  "\n"
  "/**\n"
  " * Gets the current video frame (as specified by set_time()) from the movie\n"
  " * and returns it in a pre-allocated buffer.  You may simply let the buffer\n"
  " * dereference and delete itself when you are done with it.\n"
  " *\n"
  " * This may return NULL (even if set_time() returned true) if the frame is not\n"
  " * available for some reason.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_fetch_buffer_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void MovieVideoCursor::apply_to_texture(MovieVideoCursor::Buffer const *buffer, Texture *t, int page)
 */
static PyObject *Dtool_MovieVideoCursor_apply_to_texture_78(PyObject *self, PyObject *args, PyObject *kwds) {
  MovieVideoCursor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieVideoCursor, (void **)&local_this, "MovieVideoCursor.apply_to_texture")) {
    return nullptr;
  }
  // 1-virtual void MovieVideoCursor::apply_to_texture(MovieVideoCursor::Buffer const *buffer, Texture *t, int page)
  PyObject *param1;
  PyObject *param2;
  int param3;
  static const char *keyword_list[] = {"buffer", "t", "page", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:apply_to_texture", (char **)keyword_list, &param1, &param2, &param3)) {
    MovieVideoCursor::Buffer const *param1_this = (MovieVideoCursor::Buffer *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_MovieVideoCursor_Buffer, 1, "MovieVideoCursor.apply_to_texture", true, true);
    Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "MovieVideoCursor.apply_to_texture", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).apply_to_texture)(param1_this, param2_this, (int)param3);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_to_texture(const MovieVideoCursor self, const Buffer buffer, Texture t, int page)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_apply_to_texture_78_comment =
  "C++ Interface:\n"
  "apply_to_texture(const MovieVideoCursor self, const Buffer buffer, Texture t, int page)\n"
  "\n"
  "/**\n"
  " * Stores this buffer's contents in the indicated texture.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_apply_to_texture_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void MovieVideoCursor::apply_to_texture_rgb(MovieVideoCursor::Buffer const *buffer, Texture *t, int page)
 */
static PyObject *Dtool_MovieVideoCursor_apply_to_texture_rgb_79(PyObject *self, PyObject *args, PyObject *kwds) {
  MovieVideoCursor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieVideoCursor, (void **)&local_this, "MovieVideoCursor.apply_to_texture_rgb")) {
    return nullptr;
  }
  // 1-virtual void MovieVideoCursor::apply_to_texture_rgb(MovieVideoCursor::Buffer const *buffer, Texture *t, int page)
  PyObject *param1;
  PyObject *param2;
  int param3;
  static const char *keyword_list[] = {"buffer", "t", "page", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:apply_to_texture_rgb", (char **)keyword_list, &param1, &param2, &param3)) {
    MovieVideoCursor::Buffer const *param1_this = (MovieVideoCursor::Buffer *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_MovieVideoCursor_Buffer, 1, "MovieVideoCursor.apply_to_texture_rgb", true, true);
    Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "MovieVideoCursor.apply_to_texture_rgb", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).apply_to_texture_rgb)(param1_this, param2_this, (int)param3);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_to_texture_rgb(const MovieVideoCursor self, const Buffer buffer, Texture t, int page)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_apply_to_texture_rgb_79_comment =
  "C++ Interface:\n"
  "apply_to_texture_rgb(const MovieVideoCursor self, const Buffer buffer, Texture t, int page)\n"
  "\n"
  "/**\n"
  " * Copies this buffer's contents into the RGB channels of the supplied\n"
  " * texture.  The alpha channel of the texture is not touched.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_apply_to_texture_rgb_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void MovieVideoCursor::apply_to_texture_alpha(MovieVideoCursor::Buffer const *buffer, Texture *t, int page, int alpha_src)
 */
static PyObject *Dtool_MovieVideoCursor_apply_to_texture_alpha_80(PyObject *self, PyObject *args, PyObject *kwds) {
  MovieVideoCursor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieVideoCursor, (void **)&local_this, "MovieVideoCursor.apply_to_texture_alpha")) {
    return nullptr;
  }
  // 1-virtual void MovieVideoCursor::apply_to_texture_alpha(MovieVideoCursor::Buffer const *buffer, Texture *t, int page, int alpha_src)
  PyObject *param1;
  PyObject *param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"buffer", "t", "page", "alpha_src", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOii:apply_to_texture_alpha", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    MovieVideoCursor::Buffer const *param1_this = (MovieVideoCursor::Buffer *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_MovieVideoCursor_Buffer, 1, "MovieVideoCursor.apply_to_texture_alpha", true, true);
    Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "MovieVideoCursor.apply_to_texture_alpha", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).apply_to_texture_alpha)(param1_this, param2_this, (int)param3, (int)param4);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_to_texture_alpha(const MovieVideoCursor self, const Buffer buffer, Texture t, int page, int alpha_src)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_apply_to_texture_alpha_80_comment =
  "C++ Interface:\n"
  "apply_to_texture_alpha(const MovieVideoCursor self, const Buffer buffer, Texture t, int page, int alpha_src)\n"
  "\n"
  "/**\n"
  " * Copies this buffer's contents into the alpha channel of the supplied\n"
  " * texture.  The RGB channels of the texture are not touched.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_apply_to_texture_alpha_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MovieVideoCursor::get_class_type(void)
 */
static PyObject *Dtool_MovieVideoCursor_get_class_type_81(PyObject *, PyObject *) {
  // 1-static TypeHandle MovieVideoCursor::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MovieVideoCursor::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_get_class_type_81_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovieVideoCursor_get_class_type_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline MovieVideoCursor::MovieVideoCursor(MovieVideoCursor const &) = default
 */
static int Dtool_Init_MovieVideoCursor(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("MovieVideoCursor() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline MovieVideoCursor::MovieVideoCursor(MovieVideoCursor const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    MovieVideoCursor const *param0_this = (MovieVideoCursor *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_MovieVideoCursor, 0, "MovieVideoCursor.MovieVideoCursor", true, true);
    if (param0_this != nullptr) {
      MovieVideoCursor *return_value = new MovieVideoCursor(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieVideoCursor, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MovieVideoCursor(const MovieVideoCursor param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MovieVideoCursor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MovieVideoCursor) {
    printf("MovieVideoCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MovieVideoCursor *local_this = (MovieVideoCursor *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MovieVideoCursor) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MovieVideoCursor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MovieVideoCursor) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovieVideoCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovieVideoCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovieVideoCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovieVideoCursor*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MovieVideoCursor::Buffer
 */
/**
 * Python function wrapper for:
 * virtual int MovieVideoCursor::Buffer::compare_timestamp(MovieVideoCursor::Buffer const *other) const
 */
static PyObject *Dtool_MovieVideoCursor_Buffer_compare_timestamp_73(PyObject *self, PyObject *arg) {
  MovieVideoCursor::Buffer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor_Buffer)) {
    return nullptr;
  }
  // 1-virtual int MovieVideoCursor::Buffer::compare_timestamp(MovieVideoCursor::Buffer const *other) const
  MovieVideoCursor::Buffer const *arg_this = (MovieVideoCursor::Buffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MovieVideoCursor_Buffer, 1, "Buffer.compare_timestamp", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const MovieVideoCursor::Buffer*)local_this).compare_timestamp)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_timestamp(Buffer self, const Buffer other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_Buffer_compare_timestamp_73_comment =
  "C++ Interface:\n"
  "compare_timestamp(Buffer self, const Buffer other)\n"
  "\n"
  "/**\n"
  " * Used to sort different buffers to ensure they correspond to the same source\n"
  " * frame, particularly important when synchronizing the different pages of a\n"
  " * multi-page texture.\n"
  " *\n"
  " * Returns 0 if the two buffers are of the same frame, <0 if this one comes\n"
  " * earlier than the other one, and >0 if the other one comes earlier.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_Buffer_compare_timestamp_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual double MovieVideoCursor::Buffer::get_timestamp(void) const
 */
static PyObject *Dtool_MovieVideoCursor_Buffer_get_timestamp_74(PyObject *self, PyObject *) {
  MovieVideoCursor::Buffer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovieVideoCursor_Buffer)) {
    return nullptr;
  }
  // 1-virtual double MovieVideoCursor::Buffer::get_timestamp(void) const
  double return_value = ((*(const MovieVideoCursor::Buffer*)local_this).get_timestamp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_Buffer_get_timestamp_74_comment =
  "C++ Interface:\n"
  "get_timestamp(Buffer self)\n"
  "\n"
  "/**\n"
  " * Returns the nearest timestamp value of this particular buffer.  Ideally,\n"
  " * MovieVideoCursor::set_time() for this timestamp would return this buffer\n"
  " * again.  This need be defined only if compare_timestamp() is also defined.\n"
  " */";
#else
static const char *Dtool_MovieVideoCursor_Buffer_get_timestamp_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MovieVideoCursor::Buffer::get_class_type(void)
 */
static PyObject *Dtool_MovieVideoCursor_Buffer_get_class_type_75(PyObject *, PyObject *) {
  // 1-static TypeHandle MovieVideoCursor::Buffer::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MovieVideoCursor::Buffer::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovieVideoCursor_Buffer_get_class_type_75_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovieVideoCursor_Buffer_get_class_type_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline MovieVideoCursor::Buffer::Buffer(MovieVideoCursor::Buffer const &) = default
 */
static int Dtool_Init_MovieVideoCursor_Buffer(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Buffer() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline MovieVideoCursor::Buffer::Buffer(MovieVideoCursor::Buffer const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    MovieVideoCursor::Buffer const *param0_this = (MovieVideoCursor::Buffer *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_MovieVideoCursor_Buffer, 0, "Buffer.Buffer", true, true);
    if (param0_this != nullptr) {
      MovieVideoCursor::Buffer *return_value = new MovieVideoCursor::Buffer(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieVideoCursor_Buffer, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Buffer(const Buffer param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MovieVideoCursor_Buffer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MovieVideoCursor_Buffer) {
    printf("MovieVideoCursor_Buffer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MovieVideoCursor::Buffer *local_this = (MovieVideoCursor::Buffer *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MovieVideoCursor_Buffer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MovieVideoCursor_Buffer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MovieVideoCursor_Buffer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovieVideoCursor::Buffer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovieVideoCursor::Buffer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (MovieVideoCursor::Buffer*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InkblotVideoCursor
 */
/**
 * Python function wrapper for:
 * static TypeHandle InkblotVideoCursor::get_class_type(void)
 */
static PyObject *Dtool_InkblotVideoCursor_get_class_type_85(PyObject *, PyObject *) {
  // 1-static TypeHandle InkblotVideoCursor::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((InkblotVideoCursor::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InkblotVideoCursor_get_class_type_85_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_InkblotVideoCursor_get_class_type_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * InkblotVideoCursor::InkblotVideoCursor(InkblotVideo *src)
 * inline InkblotVideoCursor::InkblotVideoCursor(InkblotVideoCursor const &) = default
 */
static int Dtool_Init_InkblotVideoCursor(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "InkblotVideoCursor() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 InkblotVideoCursor::InkblotVideoCursor(InkblotVideo *src)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "src")) {
      InkblotVideo *param0_this = (InkblotVideo *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_InkblotVideo, 0, "InkblotVideoCursor.InkblotVideoCursor", false, false);
      if (param0_this != nullptr) {
        InkblotVideoCursor *return_value = new InkblotVideoCursor(param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InkblotVideoCursor, true, false);
      }
    }
  }

  // No coercion possible: InkblotVideoCursor::InkblotVideoCursor(InkblotVideo *src)
  {
    // -2 inline InkblotVideoCursor::InkblotVideoCursor(InkblotVideoCursor const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(InkblotVideoCursor) param0_this;
      if (Dtool_ConstCoerce_InkblotVideoCursor(param0, param0_this)) {
        InkblotVideoCursor *return_value = new InkblotVideoCursor(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InkblotVideoCursor, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "InkblotVideoCursor(InkblotVideo src)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_InkblotVideoCursor(PyObject *args, CPT(InkblotVideoCursor) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_InkblotVideoCursor)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-InkblotVideoCursor::InkblotVideoCursor(InkblotVideo *src)
    InkblotVideo *arg_this = (InkblotVideo *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InkblotVideo, 0, "InkblotVideoCursor.InkblotVideoCursor", false, false);
    if (arg_this != nullptr) {
      InkblotVideoCursor *return_value = new InkblotVideoCursor(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_InkblotVideoCursor(PyObject *args, PT(InkblotVideoCursor) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_InkblotVideoCursor)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-InkblotVideoCursor::InkblotVideoCursor(InkblotVideo *src)
    InkblotVideo *arg_this = (InkblotVideo *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InkblotVideo, 0, "InkblotVideoCursor.InkblotVideoCursor", false, false);
    if (arg_this != nullptr) {
      InkblotVideoCursor *return_value = new InkblotVideoCursor(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_InkblotVideoCursor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InkblotVideoCursor) {
    printf("InkblotVideoCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InkblotVideoCursor *local_this = (InkblotVideoCursor *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InkblotVideoCursor) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieVideoCursor) {
    return (MovieVideoCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieVideoCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieVideoCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieVideoCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieVideoCursor *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InkblotVideoCursor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InkblotVideoCursor) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieVideoCursor) {
    MovieVideoCursor* other_this = (MovieVideoCursor*)from_this;
    return (InkblotVideoCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (InkblotVideoCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (InkblotVideoCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (InkblotVideoCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (InkblotVideoCursor*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MicrophoneAudio
 */
/**
 * Python function wrapper for:
 * static int MicrophoneAudio::get_num_options(void)
 */
static PyObject *Dtool_MicrophoneAudio_get_num_options_87(PyObject *, PyObject *) {
  // 1-static int MicrophoneAudio::get_num_options(void)
  int return_value = (MicrophoneAudio::get_num_options)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MicrophoneAudio_get_num_options_87_comment =
  "C++ Interface:\n"
  "get_num_options()\n"
  "\n"
  "/**\n"
  " * Returns the number of microphone options.  An \"option\" consists of a device\n"
  " * plus a set of configuration parameters.  For example, \"Soundblaster Audigy\n"
  " * Line in at 44,100 samples/sec\" would be an option.\n"
  " */";
#else
static const char *Dtool_MicrophoneAudio_get_num_options_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< MicrophoneAudio > MicrophoneAudio::get_option(int n)
 */
static PyObject *Dtool_MicrophoneAudio_get_option_88(PyObject *, PyObject *arg) {
  // 1-static PointerTo< MicrophoneAudio > MicrophoneAudio::get_option(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< MicrophoneAudio > return_value = (MicrophoneAudio::get_option)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    MicrophoneAudio *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MicrophoneAudio, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_option(int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MicrophoneAudio_get_option_88_comment =
  "C++ Interface:\n"
  "get_option(int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth microphone option.\n"
  " */";
#else
static const char *Dtool_MicrophoneAudio_get_option_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int MicrophoneAudio::get_channels(void) const
 */
static PyObject *Dtool_MicrophoneAudio_get_channels_90(PyObject *self, PyObject *) {
  MicrophoneAudio *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MicrophoneAudio)) {
    return nullptr;
  }
  // 1-inline int MicrophoneAudio::get_channels(void) const
  int return_value = ((*(const MicrophoneAudio*)local_this).get_channels)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MicrophoneAudio_get_channels_90_comment =
  "C++ Interface:\n"
  "get_channels(MicrophoneAudio self)\n"
  "\n"
  "/**\n"
  " * Returns the number of channels.\n"
  " */";
#else
static const char *Dtool_MicrophoneAudio_get_channels_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int MicrophoneAudio::get_rate(void) const
 */
static PyObject *Dtool_MicrophoneAudio_get_rate_91(PyObject *self, PyObject *) {
  MicrophoneAudio *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MicrophoneAudio)) {
    return nullptr;
  }
  // 1-inline int MicrophoneAudio::get_rate(void) const
  int return_value = ((*(const MicrophoneAudio*)local_this).get_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MicrophoneAudio_get_rate_91_comment =
  "C++ Interface:\n"
  "get_rate(MicrophoneAudio self)\n"
  "\n"
  "/**\n"
  " * Returns the sample rate.\n"
  " */";
#else
static const char *Dtool_MicrophoneAudio_get_rate_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MicrophoneAudio::get_class_type(void)
 */
static PyObject *Dtool_MicrophoneAudio_get_class_type_97(PyObject *, PyObject *) {
  // 1-static TypeHandle MicrophoneAudio::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MicrophoneAudio::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MicrophoneAudio_get_class_type_97_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MicrophoneAudio_get_class_type_97_comment = nullptr;
#endif

/**
 * sequence length function for property MicrophoneAudio::options
 */
static Py_ssize_t Dtool_MicrophoneAudio_options_Len(PyObject *self) {
  return (Py_ssize_t)(MicrophoneAudio::get_num_options)();
}

/**
 * sequence getter for property MicrophoneAudio::options
 */
static PyObject *Dtool_MicrophoneAudio_options_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  if (index < 0 || index >= (Py_ssize_t)(MicrophoneAudio::get_num_options)()) {
    PyErr_SetString(PyExc_IndexError, "MicrophoneAudio.options[] index out of range");
    return nullptr;
  }
  // 1-static PointerTo< MicrophoneAudio > MicrophoneAudio::get_option(int n)
  PointerTo< MicrophoneAudio > return_value = (MicrophoneAudio::get_option)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  MicrophoneAudio *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MicrophoneAudio, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_option(index)\n");
  }
}

static PyObject *Dtool_MicrophoneAudio_options_Getter(PyObject *self, void *) {
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "MicrophoneAudio.options");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_MicrophoneAudio_options_Len;
    wrap->_getitem_func = &Dtool_MicrophoneAudio_options_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_MicrophoneAudio_channels_Getter(PyObject *self, void *) {
  const MicrophoneAudio *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MicrophoneAudio, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int MicrophoneAudio::get_channels(void) const
  int return_value = ((*(const MicrophoneAudio*)local_this).get_channels)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MicrophoneAudio_rate_Getter(PyObject *self, void *) {
  const MicrophoneAudio *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MicrophoneAudio, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int MicrophoneAudio::get_rate(void) const
  int return_value = ((*(const MicrophoneAudio*)local_this).get_rate)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_MicrophoneAudio(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_MicrophoneAudio_get_options(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)(MicrophoneAudio::get_num_options)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_MicrophoneAudio_get_option_88(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_MicrophoneAudio(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MicrophoneAudio) {
    printf("MicrophoneAudio ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MicrophoneAudio *local_this = (MicrophoneAudio *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MicrophoneAudio) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieAudio) {
    return (MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MicrophoneAudio(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MicrophoneAudio) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieAudio) {
    MovieAudio* other_this = (MovieAudio*)from_this;
    return (MicrophoneAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MicrophoneAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MicrophoneAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MicrophoneAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MicrophoneAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MicrophoneAudio*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class UserDataAudio
 */
/**
 * Python function wrapper for:
 * void UserDataAudio::append(DatagramIterator *src, int len = 1073741824)
 * void UserDataAudio::append(vector_uchar const &)
 */
static PyObject *Dtool_UserDataAudio_append_100(PyObject *self, PyObject *args, PyObject *kwds) {
  UserDataAudio *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UserDataAudio, (void **)&local_this, "UserDataAudio.append")) {
    return nullptr;
  }
  {
    // -2 void UserDataAudio::append(DatagramIterator *src, int len = 1073741824)
    PyObject *param1;
    int param2 = 1073741824;
    static const char *keyword_list[] = {"src", "len", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:append", (char **)keyword_list, &param1, &param2)) {
      DatagramIterator *param1_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_DatagramIterator, 1, "UserDataAudio.append", false, false);
      if (param1_this != nullptr) {
        ((*local_this).append)(param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void UserDataAudio::append(vector_uchar const &)
    unsigned char *param1_str = nullptr;
    Py_ssize_t param1_len;
    if ((kwds == nullptr || PyDict_Size(kwds) == 0) && PyArg_ParseTuple(args, "" FMTCHAR_BYTES "#:append", &param1_str, &param1_len)) {
      ((*local_this).append)(vector_uchar(param1_str, param1_str + param1_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void UserDataAudio::append(DatagramIterator *src, int len = 1073741824)
    PyObject *param1;
    int param2 = 1073741824;
    static const char *keyword_list[] = {"src", "len", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:append", (char **)keyword_list, &param1, &param2)) {
      DatagramIterator param1_local;
      DatagramIterator *param1_this = Dtool_Coerce_DatagramIterator(param1, param1_local);
      if ((param1_this != nullptr)) {
        ((*local_this).append)(param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void UserDataAudio::append(vector_uchar const &)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append(const UserDataAudio self, DatagramIterator src, int len)\n"
      "append(const UserDataAudio self, bytes param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UserDataAudio_append_100_comment =
  "C++ Interface:\n"
  "append(const UserDataAudio self, DatagramIterator src, int len)\n"
  "append(const UserDataAudio self, bytes param0)\n"
  "\n"
  "/**\n"
  " * Appends audio samples to the buffer.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Appends audio samples to the buffer from a datagram.  This is intended to\n"
  " * make it easy to send streaming raw audio over a network.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Appends audio samples to the buffer from a string.  The samples must be\n"
  " * stored little-endian in the string.  This is not particularly efficient,\n"
  " * but it may be convenient to deal with samples in python.\n"
  " */";
#else
static const char *Dtool_UserDataAudio_append_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void UserDataAudio::done(void)
 */
static PyObject *Dtool_UserDataAudio_done_101(PyObject *self, PyObject *) {
  UserDataAudio *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UserDataAudio, (void **)&local_this, "UserDataAudio.done")) {
    return nullptr;
  }
  // 1-void UserDataAudio::done(void)
  ((*local_this).done)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_UserDataAudio_done_101_comment =
  "C++ Interface:\n"
  "done(const UserDataAudio self)\n"
  "\n"
  "// A promise not to write any more samples.\n"
  "\n"
  "/**\n"
  " * Promises not to append any more samples, ie, this marks the end of the\n"
  " * audio stream.\n"
  " */";
#else
static const char *Dtool_UserDataAudio_done_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UserDataAudio::get_class_type(void)
 */
static PyObject *Dtool_UserDataAudio_get_class_type_102(PyObject *, PyObject *) {
  // 1-static TypeHandle UserDataAudio::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((UserDataAudio::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UserDataAudio_get_class_type_102_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UserDataAudio_get_class_type_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UserDataAudio::UserDataAudio(UserDataAudio const &) = default
 * UserDataAudio::UserDataAudio(int rate, int channels, bool remove_after_read = true)
 */
static int Dtool_Init_UserDataAudio(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline UserDataAudio::UserDataAudio(UserDataAudio const &) = default
      CPT(UserDataAudio) arg_this;
      if (!Dtool_ConstCoerce_UserDataAudio(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "UserDataAudio.UserDataAudio", "UserDataAudio");
        return -1;
      }
      UserDataAudio *return_value = new UserDataAudio(*std::move(arg_this));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UserDataAudio, true, false);
    }
    break;
  case 2:
  case 3:
    {
      // 1-UserDataAudio::UserDataAudio(int rate, int channels, bool remove_after_read = true)
      int param0;
      int param1;
      PyObject *param2 = Py_True;
      static const char *keyword_list[] = {"rate", "channels", "remove_after_read", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii|O:UserDataAudio", (char **)keyword_list, &param0, &param1, &param2)) {
        UserDataAudio *return_value = new UserDataAudio((int)param0, (int)param1, (PyObject_IsTrue(param2) != 0));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UserDataAudio, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UserDataAudio() takes 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UserDataAudio(const UserDataAudio param0)\n"
      "UserDataAudio(int rate, int channels, bool remove_after_read)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_UserDataAudio(PyObject *args, CPT(UserDataAudio) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_UserDataAudio)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-UserDataAudio::UserDataAudio(int rate, int channels, bool remove_after_read = true)
      int param0;
      int param1;
      PyObject *param2 = Py_True;
      if (PyArg_ParseTuple(args, "ii|O:UserDataAudio", &param0, &param1, &param2)) {
        UserDataAudio *return_value = new UserDataAudio((int)param0, (int)param1, (PyObject_IsTrue(param2) != 0));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_UserDataAudio(PyObject *args, PT(UserDataAudio) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_UserDataAudio)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-UserDataAudio::UserDataAudio(int rate, int channels, bool remove_after_read = true)
      int param0;
      int param1;
      PyObject *param2 = Py_True;
      if (PyArg_ParseTuple(args, "ii|O:UserDataAudio", &param0, &param1, &param2)) {
        UserDataAudio *return_value = new UserDataAudio((int)param0, (int)param1, (PyObject_IsTrue(param2) != 0));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_UserDataAudio(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_UserDataAudio) {
    printf("UserDataAudio ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  UserDataAudio *local_this = (UserDataAudio *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_UserDataAudio) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieAudio) {
    return (MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_UserDataAudio(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_UserDataAudio) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieAudio) {
    MovieAudio* other_this = (MovieAudio*)from_this;
    return (UserDataAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (UserDataAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (UserDataAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (UserDataAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (UserDataAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (UserDataAudio*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class UserDataAudioCursor
 */
/**
 * Python function wrapper for:
 * static TypeHandle UserDataAudioCursor::get_class_type(void)
 */
static PyObject *Dtool_UserDataAudioCursor_get_class_type_105(PyObject *, PyObject *) {
  // 1-static TypeHandle UserDataAudioCursor::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((UserDataAudioCursor::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UserDataAudioCursor_get_class_type_105_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UserDataAudioCursor_get_class_type_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * UserDataAudioCursor::UserDataAudioCursor(UserDataAudio *src)
 * inline UserDataAudioCursor::UserDataAudioCursor(UserDataAudioCursor const &) = default
 */
static int Dtool_Init_UserDataAudioCursor(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "UserDataAudioCursor() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 UserDataAudioCursor::UserDataAudioCursor(UserDataAudio *src)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "src")) {
      UserDataAudio *param0_this = (UserDataAudio *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_UserDataAudio, 0, "UserDataAudioCursor.UserDataAudioCursor", false, false);
      if (param0_this != nullptr) {
        UserDataAudioCursor *return_value = new UserDataAudioCursor(param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UserDataAudioCursor, true, false);
      }
    }
  }

  {
    // -2 inline UserDataAudioCursor::UserDataAudioCursor(UserDataAudioCursor const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      UserDataAudioCursor const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_UserDataAudioCursor);
      if (param0_this != nullptr) {
        UserDataAudioCursor *return_value = new UserDataAudioCursor(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UserDataAudioCursor, true, false);
      }
    }
  }

  {
    // -2 UserDataAudioCursor::UserDataAudioCursor(UserDataAudio *src)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "src")) {
      PT(UserDataAudio) param0_this;
      if (Dtool_Coerce_UserDataAudio(param0, param0_this)) {
        UserDataAudioCursor *return_value = new UserDataAudioCursor(std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UserDataAudioCursor, true, false);
      }
    }
  }

  {
    // -2 inline UserDataAudioCursor::UserDataAudioCursor(UserDataAudioCursor const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(UserDataAudioCursor) param0_this;
      if (Dtool_ConstCoerce_UserDataAudioCursor(param0, param0_this)) {
        UserDataAudioCursor *return_value = new UserDataAudioCursor(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UserDataAudioCursor, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UserDataAudioCursor(UserDataAudio src)\n"
      "UserDataAudioCursor(const UserDataAudioCursor param0)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_UserDataAudioCursor(PyObject *args, CPT(UserDataAudioCursor) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_UserDataAudioCursor)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-UserDataAudioCursor::UserDataAudioCursor(UserDataAudio *src)
    UserDataAudio *arg_this = (UserDataAudio *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_UserDataAudio, 0, "UserDataAudioCursor.UserDataAudioCursor", false, false);
    if (arg_this != nullptr) {
      UserDataAudioCursor *return_value = new UserDataAudioCursor(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_UserDataAudioCursor(PyObject *args, PT(UserDataAudioCursor) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_UserDataAudioCursor)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-UserDataAudioCursor::UserDataAudioCursor(UserDataAudio *src)
    UserDataAudio *arg_this = (UserDataAudio *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_UserDataAudio, 0, "UserDataAudioCursor.UserDataAudioCursor", false, false);
    if (arg_this != nullptr) {
      UserDataAudioCursor *return_value = new UserDataAudioCursor(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_UserDataAudioCursor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_UserDataAudioCursor) {
    printf("UserDataAudioCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  UserDataAudioCursor *local_this = (UserDataAudioCursor *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_UserDataAudioCursor) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieAudioCursor) {
    return (MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_UserDataAudioCursor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_UserDataAudioCursor) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieAudioCursor) {
    MovieAudioCursor* other_this = (MovieAudioCursor*)from_this;
    return (UserDataAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (UserDataAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (UserDataAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (UserDataAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (UserDataAudioCursor*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VorbisAudio
 */
/**
 * Python function wrapper for:
 * static PointerTo< MovieAudio > VorbisAudio::make(Filename const &name)
 */
static PyObject *Dtool_VorbisAudio_make_108(PyObject *, PyObject *arg) {
  // 1-static PointerTo< MovieAudio > VorbisAudio::make(Filename const &name)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "VorbisAudio.make", "Filename");
  }
  PointerTo< MovieAudio > return_value = (VorbisAudio::make)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  MovieAudio *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MovieAudio, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const Filename name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VorbisAudio_make_108_comment =
  "C++ Interface:\n"
  "make(const Filename name)\n"
  "\n"
  "/**\n"
  " * Obtains a MovieAudio that references a file.\n"
  " */";
#else
static const char *Dtool_VorbisAudio_make_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VorbisAudio::get_class_type(void)
 */
static PyObject *Dtool_VorbisAudio_get_class_type_109(PyObject *, PyObject *) {
  // 1-static TypeHandle VorbisAudio::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VorbisAudio::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VorbisAudio_get_class_type_109_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VorbisAudio_get_class_type_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * VorbisAudio::VorbisAudio(Filename const &name)
 * inline VorbisAudio::VorbisAudio(VorbisAudio const &) = default
 */
static int Dtool_Init_VorbisAudio(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VorbisAudio() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline VorbisAudio::VorbisAudio(VorbisAudio const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      VorbisAudio const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_VorbisAudio);
      if (param0_this != nullptr) {
        VorbisAudio *return_value = new VorbisAudio(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VorbisAudio, true, false);
      }
    }
  }

  {
    // -2 VorbisAudio::VorbisAudio(Filename const &name)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "name")) {
      Filename const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
      if (param0_this != nullptr) {
        VorbisAudio *return_value = new VorbisAudio(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VorbisAudio, true, false);
      }
    }
  }

  {
    // -2 inline VorbisAudio::VorbisAudio(VorbisAudio const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(VorbisAudio) param0_this;
      if (Dtool_ConstCoerce_VorbisAudio(param0, param0_this)) {
        VorbisAudio *return_value = new VorbisAudio(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VorbisAudio, true, false);
      }
    }
  }

  {
    // -2 VorbisAudio::VorbisAudio(Filename const &name)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "name")) {
      Filename param0_local;
      Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
      if ((param0_this != nullptr)) {
        VorbisAudio *return_value = new VorbisAudio(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VorbisAudio, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VorbisAudio(const VorbisAudio param0)\n"
      "VorbisAudio(const Filename name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_VorbisAudio(PyObject *args, CPT(VorbisAudio) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_VorbisAudio)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 VorbisAudio::VorbisAudio(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        VorbisAudio *return_value = new VorbisAudio(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

    {
      // -2 static PointerTo< MovieAudio > VorbisAudio::make(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        PointerTo< MovieAudio > return_value = (VorbisAudio::make)(*arg_this);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move(DCAST(VorbisAudio, return_value.p()));
          return true;
        }
      }
    }

  }
  return false;
}

bool Dtool_Coerce_VorbisAudio(PyObject *args, PT(VorbisAudio) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_VorbisAudio)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 VorbisAudio::VorbisAudio(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        VorbisAudio *return_value = new VorbisAudio(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

    {
      // -2 static PointerTo< MovieAudio > VorbisAudio::make(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        PointerTo< MovieAudio > return_value = (VorbisAudio::make)(*arg_this);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move(DCAST(VorbisAudio, return_value.p()));
          return true;
        }
      }
    }

  }
  return false;
}

static void *Dtool_UpcastInterface_VorbisAudio(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VorbisAudio) {
    printf("VorbisAudio ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VorbisAudio *local_this = (VorbisAudio *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VorbisAudio) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieAudio) {
    return (MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VorbisAudio(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VorbisAudio) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieAudio) {
    MovieAudio* other_this = (MovieAudio*)from_this;
    return (VorbisAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (VorbisAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VorbisAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VorbisAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (VorbisAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (VorbisAudio*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VorbisAudioCursor
 */
/**
 * Python function wrapper for:
 * static TypeHandle VorbisAudioCursor::get_class_type(void)
 */
static PyObject *Dtool_VorbisAudioCursor_get_class_type_112(PyObject *, PyObject *) {
  // 1-static TypeHandle VorbisAudioCursor::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VorbisAudioCursor::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VorbisAudioCursor_get_class_type_112_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VorbisAudioCursor_get_class_type_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit VorbisAudioCursor::VorbisAudioCursor(VorbisAudio *src, std::istream *stream)
 * inline VorbisAudioCursor::VorbisAudioCursor(VorbisAudioCursor const &) = default
 */
static int Dtool_Init_VorbisAudioCursor(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline VorbisAudioCursor::VorbisAudioCursor(VorbisAudioCursor const &) = default
      VorbisAudioCursor const *arg_this = (VorbisAudioCursor *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VorbisAudioCursor, 0, "VorbisAudioCursor.VorbisAudioCursor", true, true);
      if (arg_this != nullptr) {
        VorbisAudioCursor *return_value = new VorbisAudioCursor(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VorbisAudioCursor, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-explicit VorbisAudioCursor::VorbisAudioCursor(VorbisAudio *src, std::istream *stream)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"src", "stream", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:VorbisAudioCursor", (char **)keyword_list, &param0, &param1)) {
        PT(VorbisAudio) param0_this;
        if (!Dtool_Coerce_VorbisAudio(param0, param0_this)) {
          Dtool_Raise_ArgTypeError(param0, 0, "VorbisAudioCursor.VorbisAudioCursor", "VorbisAudio");
          return -1;
        }
        std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "VorbisAudioCursor.VorbisAudioCursor", false, true);
        if (param1_this != nullptr) {
          VorbisAudioCursor *return_value = new VorbisAudioCursor(std::move(param0_this), param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VorbisAudioCursor, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "VorbisAudioCursor() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VorbisAudioCursor(const VorbisAudioCursor param0)\n"
      "VorbisAudioCursor(VorbisAudio src, istream stream)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_VorbisAudioCursor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VorbisAudioCursor) {
    printf("VorbisAudioCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VorbisAudioCursor *local_this = (VorbisAudioCursor *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VorbisAudioCursor) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieAudioCursor) {
    return (MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VorbisAudioCursor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VorbisAudioCursor) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieAudioCursor) {
    MovieAudioCursor* other_this = (MovieAudioCursor*)from_this;
    return (VorbisAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VorbisAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VorbisAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (VorbisAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (VorbisAudioCursor*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class WavAudio
 */
/**
 * Python function wrapper for:
 * static PointerTo< MovieAudio > WavAudio::make(Filename const &name)
 */
static PyObject *Dtool_WavAudio_make_115(PyObject *, PyObject *arg) {
  // 1-static PointerTo< MovieAudio > WavAudio::make(Filename const &name)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "WavAudio.make", "Filename");
  }
  PointerTo< MovieAudio > return_value = (WavAudio::make)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  MovieAudio *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_MovieAudio, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const Filename name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WavAudio_make_115_comment =
  "C++ Interface:\n"
  "make(const Filename name)\n"
  "\n"
  "/**\n"
  " * Obtains a MovieAudio that references a file.\n"
  " */";
#else
static const char *Dtool_WavAudio_make_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle WavAudio::get_class_type(void)
 */
static PyObject *Dtool_WavAudio_get_class_type_116(PyObject *, PyObject *) {
  // 1-static TypeHandle WavAudio::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((WavAudio::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WavAudio_get_class_type_116_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_WavAudio_get_class_type_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * WavAudio::WavAudio(Filename const &name)
 * inline WavAudio::WavAudio(WavAudio const &) = default
 */
static int Dtool_Init_WavAudio(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "WavAudio() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline WavAudio::WavAudio(WavAudio const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      WavAudio const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_WavAudio);
      if (param0_this != nullptr) {
        WavAudio *return_value = new WavAudio(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WavAudio, true, false);
      }
    }
  }

  {
    // -2 WavAudio::WavAudio(Filename const &name)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "name")) {
      Filename const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
      if (param0_this != nullptr) {
        WavAudio *return_value = new WavAudio(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WavAudio, true, false);
      }
    }
  }

  {
    // -2 inline WavAudio::WavAudio(WavAudio const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(WavAudio) param0_this;
      if (Dtool_ConstCoerce_WavAudio(param0, param0_this)) {
        WavAudio *return_value = new WavAudio(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WavAudio, true, false);
      }
    }
  }

  {
    // -2 WavAudio::WavAudio(Filename const &name)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "name")) {
      Filename param0_local;
      Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
      if ((param0_this != nullptr)) {
        WavAudio *return_value = new WavAudio(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WavAudio, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "WavAudio(const WavAudio param0)\n"
      "WavAudio(const Filename name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_WavAudio(PyObject *args, CPT(WavAudio) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_WavAudio)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 WavAudio::WavAudio(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        WavAudio *return_value = new WavAudio(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

    {
      // -2 static PointerTo< MovieAudio > WavAudio::make(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        PointerTo< MovieAudio > return_value = (WavAudio::make)(*arg_this);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move(DCAST(WavAudio, return_value.p()));
          return true;
        }
      }
    }

  }
  return false;
}

bool Dtool_Coerce_WavAudio(PyObject *args, PT(WavAudio) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_WavAudio)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 WavAudio::WavAudio(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        WavAudio *return_value = new WavAudio(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

    {
      // -2 static PointerTo< MovieAudio > WavAudio::make(Filename const &name)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        PointerTo< MovieAudio > return_value = (WavAudio::make)(*arg_this);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move(DCAST(WavAudio, return_value.p()));
          return true;
        }
      }
    }

  }
  return false;
}

static void *Dtool_UpcastInterface_WavAudio(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_WavAudio) {
    printf("WavAudio ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  WavAudio *local_this = (WavAudio *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_WavAudio) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieAudio) {
    return (MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieAudio *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_WavAudio(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_WavAudio) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieAudio) {
    MovieAudio* other_this = (MovieAudio*)from_this;
    return (WavAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (WavAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (WavAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (WavAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (WavAudio*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (WavAudio*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class WavAudioCursor
 */
/**
 * Python function wrapper for:
 * static TypeHandle WavAudioCursor::get_class_type(void)
 */
static PyObject *Dtool_WavAudioCursor_get_class_type_119(PyObject *, PyObject *) {
  // 1-static TypeHandle WavAudioCursor::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((WavAudioCursor::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WavAudioCursor_get_class_type_119_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_WavAudioCursor_get_class_type_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit WavAudioCursor::WavAudioCursor(WavAudio *src, std::istream *stream)
 * inline WavAudioCursor::WavAudioCursor(WavAudioCursor const &) = default
 */
static int Dtool_Init_WavAudioCursor(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline WavAudioCursor::WavAudioCursor(WavAudioCursor const &) = default
      WavAudioCursor const *arg_this = (WavAudioCursor *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_WavAudioCursor, 0, "WavAudioCursor.WavAudioCursor", true, true);
      if (arg_this != nullptr) {
        WavAudioCursor *return_value = new WavAudioCursor(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WavAudioCursor, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-explicit WavAudioCursor::WavAudioCursor(WavAudio *src, std::istream *stream)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"src", "stream", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:WavAudioCursor", (char **)keyword_list, &param0, &param1)) {
        PT(WavAudio) param0_this;
        if (!Dtool_Coerce_WavAudio(param0, param0_this)) {
          Dtool_Raise_ArgTypeError(param0, 0, "WavAudioCursor.WavAudioCursor", "WavAudio");
          return -1;
        }
        std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "WavAudioCursor.WavAudioCursor", false, true);
        if (param1_this != nullptr) {
          WavAudioCursor *return_value = new WavAudioCursor(std::move(param0_this), param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WavAudioCursor, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "WavAudioCursor() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "WavAudioCursor(const WavAudioCursor param0)\n"
      "WavAudioCursor(WavAudio src, istream stream)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_WavAudioCursor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_WavAudioCursor) {
    printf("WavAudioCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  WavAudioCursor *local_this = (WavAudioCursor *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_WavAudioCursor) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieAudioCursor) {
    return (MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieAudioCursor *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_WavAudioCursor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_WavAudioCursor) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieAudioCursor) {
    MovieAudioCursor* other_this = (MovieAudioCursor*)from_this;
    return (WavAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (WavAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (WavAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (WavAudioCursor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (WavAudioCursor*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for MovieAudio (MovieAudio)
 */
static PyMethodDef Dtool_Methods_MovieAudio[] = {
  {"open", &Dtool_MovieAudio_open_10, METH_NOARGS, (const char *)Dtool_MovieAudio_open_10_comment},
  {"get", &Dtool_MovieAudio_get_11, METH_O | METH_STATIC, (const char *)Dtool_MovieAudio_get_11_comment},
  {"get_filename", &Dtool_MovieAudio_get_filename_12, METH_NOARGS, (const char *)Dtool_MovieAudio_get_filename_12_comment},
  {"getFilename", &Dtool_MovieAudio_get_filename_12, METH_NOARGS, (const char *)Dtool_MovieAudio_get_filename_12_comment},
  {"get_class_type", &Dtool_MovieAudio_get_class_type_16, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieAudio_get_class_type_16_comment},
  {"getClassType", &Dtool_MovieAudio_get_class_type_16, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieAudio_get_class_type_16_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_3, METH_NOARGS, (const char *)Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_3_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_3, METH_NOARGS, (const char *)Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_3_comment},
  {"upcast_to_Namable", &Dtool_MovieAudio_upcast_to_Namable_6, METH_NOARGS, (const char *)Dtool_MovieAudio_upcast_to_Namable_6_comment},
  {"upcastToNamable", &Dtool_MovieAudio_upcast_to_Namable_6, METH_NOARGS, (const char *)Dtool_MovieAudio_upcast_to_Namable_6_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_MovieAudio[] = {
  {(char *)"filename", &Dtool_MovieAudio_filename_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_MovieAudio = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovieAudio = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MovieAudio = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MovieAudio = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MovieAudio = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MovieAudio = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MovieAudio",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MovieAudio,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MovieAudio,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MovieAudio,
    &Dtool_SequenceMethods_MovieAudio,
    &Dtool_MappingMethods_MovieAudio,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MovieAudio,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A MovieAudio is actually any source that provides a sequence of audio\n"
    " * samples.  That could include an AVI file, a microphone, or an internet TV\n"
    " * station.\n"
    " *\n"
    " * The difference between a MovieAudio and a MovieAudioCursor is like the\n"
    " * difference between a filename and a file handle.  The MovieAudio just\n"
    " * indicates a particular movie.  The MovieAudioCursor is what allows access.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MovieAudio,
    nullptr, // tp_members
    Dtool_Properties_MovieAudio,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MovieAudio,
    PyType_GenericAlloc,
    Dtool_new_MovieAudio,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovieAudio,
  Dtool_UpcastInterface_MovieAudio,
  Dtool_DowncastInterface_MovieAudio,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MovieAudio(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_MovieAudio._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_MovieAudio._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MovieAudio._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovieAudio) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovieAudio)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovieAudio);
  }
}

/**
 * Python method tables for FlacAudio (FlacAudio)
 */
static PyMethodDef Dtool_Methods_FlacAudio[] = {
  {"make", &Dtool_FlacAudio_make_19, METH_O | METH_STATIC, (const char *)Dtool_FlacAudio_make_19_comment},
  {"get_class_type", &Dtool_FlacAudio_get_class_type_20, METH_NOARGS | METH_STATIC, (const char *)Dtool_FlacAudio_get_class_type_20_comment},
  {"getClassType", &Dtool_FlacAudio_get_class_type_20, METH_NOARGS | METH_STATIC, (const char *)Dtool_FlacAudio_get_class_type_20_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_FlacAudio = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FlacAudio = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_FlacAudio = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_FlacAudio = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_FlacAudio = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_FlacAudio = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.FlacAudio",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FlacAudio,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_FlacAudio,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_FlacAudio,
    &Dtool_SequenceMethods_FlacAudio,
    &Dtool_MappingMethods_FlacAudio,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_FlacAudio,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Reads FLAC audio files.  Ogg-encapsulated FLAC files are not supported.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FlacAudio,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FlacAudio,
    PyType_GenericAlloc,
    Dtool_new_FlacAudio,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FlacAudio,
  Dtool_UpcastInterface_FlacAudio,
  Dtool_DowncastInterface_FlacAudio,
  (CoerceFunction)Dtool_ConstCoerce_FlacAudio,
  (CoerceFunction)Dtool_Coerce_FlacAudio,
};

static void Dtool_PyModuleClassInit_FlacAudio(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovieAudio(nullptr);
    Dtool_FlacAudio._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovieAudio);
    Dtool_FlacAudio._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_FlacAudio._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FlacAudio) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FlacAudio)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FlacAudio);
  }
}

/**
 * Python method tables for MovieAudioCursor (MovieAudioCursor)
 */
static PyMethodDef Dtool_Methods_MovieAudioCursor[] = {
  {"get_source", &Dtool_MovieAudioCursor_get_source_23, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_get_source_23_comment},
  {"getSource", &Dtool_MovieAudioCursor_get_source_23, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_get_source_23_comment},
  {"audio_rate", &Dtool_MovieAudioCursor_audio_rate_24, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_audio_rate_24_comment},
  {"audioRate", &Dtool_MovieAudioCursor_audio_rate_24, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_audio_rate_24_comment},
  {"audio_channels", &Dtool_MovieAudioCursor_audio_channels_25, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_audio_channels_25_comment},
  {"audioChannels", &Dtool_MovieAudioCursor_audio_channels_25, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_audio_channels_25_comment},
  {"length", &Dtool_MovieAudioCursor_length_26, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_length_26_comment},
  {"can_seek", &Dtool_MovieAudioCursor_can_seek_27, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_can_seek_27_comment},
  {"canSeek", &Dtool_MovieAudioCursor_can_seek_27, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_can_seek_27_comment},
  {"can_seek_fast", &Dtool_MovieAudioCursor_can_seek_fast_28, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_can_seek_fast_28_comment},
  {"canSeekFast", &Dtool_MovieAudioCursor_can_seek_fast_28, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_can_seek_fast_28_comment},
  {"tell", &Dtool_MovieAudioCursor_tell_29, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_tell_29_comment},
  {"skip_samples", &Dtool_MovieAudioCursor_skip_samples_30, METH_O, (const char *)Dtool_MovieAudioCursor_skip_samples_30_comment},
  {"skipSamples", &Dtool_MovieAudioCursor_skip_samples_30, METH_O, (const char *)Dtool_MovieAudioCursor_skip_samples_30_comment},
  {"aborted", &Dtool_MovieAudioCursor_aborted_31, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_aborted_31_comment},
  {"ready", &Dtool_MovieAudioCursor_ready_32, METH_NOARGS, (const char *)Dtool_MovieAudioCursor_ready_32_comment},
  {"seek", &Dtool_MovieAudioCursor_seek_33, METH_O, (const char *)Dtool_MovieAudioCursor_seek_33_comment},
  {"read_samples", (PyCFunction) &Dtool_MovieAudioCursor_read_samples_34, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MovieAudioCursor_read_samples_34_comment},
  {"readSamples", (PyCFunction) &Dtool_MovieAudioCursor_read_samples_34, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MovieAudioCursor_read_samples_34_comment},
  {"get_class_type", &Dtool_MovieAudioCursor_get_class_type_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieAudioCursor_get_class_type_35_comment},
  {"getClassType", &Dtool_MovieAudioCursor_get_class_type_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieAudioCursor_get_class_type_35_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MovieAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovieAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MovieAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MovieAudioCursor = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MovieAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MovieAudioCursor = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MovieAudioCursor",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MovieAudioCursor,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MovieAudioCursor,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MovieAudioCursor,
    &Dtool_SequenceMethods_MovieAudioCursor,
    &Dtool_MappingMethods_MovieAudioCursor,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MovieAudioCursor,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A MovieAudio is actually any source that provides a sequence of audio\n"
    " * samples.  That could include an AVI file, a microphone, or an internet TV\n"
    " * station.  A MovieAudioCursor is a handle that lets you read data\n"
    " * sequentially from a MovieAudio.\n"
    " *\n"
    " * Thread safety: each individual MovieAudioCursor must be owned and accessed\n"
    " * by a single thread.  It is OK for two different threads to open the same\n"
    " * file at the same time, as long as they use separate MovieAudioCursor\n"
    " * objects.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MovieAudioCursor,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MovieAudioCursor,
    PyType_GenericAlloc,
    Dtool_new_MovieAudioCursor,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovieAudioCursor,
  Dtool_UpcastInterface_MovieAudioCursor,
  Dtool_DowncastInterface_MovieAudioCursor,
  (CoerceFunction)Dtool_ConstCoerce_MovieAudioCursor,
  (CoerceFunction)Dtool_Coerce_MovieAudioCursor,
};

static void Dtool_PyModuleClassInit_MovieAudioCursor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_MovieAudioCursor._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_MovieAudioCursor._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MovieAudioCursor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovieAudioCursor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovieAudioCursor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovieAudioCursor);
  }
}

/**
 * Python method tables for FlacAudioCursor (FlacAudioCursor)
 */
static PyMethodDef Dtool_Methods_FlacAudioCursor[] = {
  {"get_class_type", &Dtool_FlacAudioCursor_get_class_type_38, METH_NOARGS | METH_STATIC, (const char *)Dtool_FlacAudioCursor_get_class_type_38_comment},
  {"getClassType", &Dtool_FlacAudioCursor_get_class_type_38, METH_NOARGS | METH_STATIC, (const char *)Dtool_FlacAudioCursor_get_class_type_38_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_FlacAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FlacAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_FlacAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_FlacAudioCursor = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_FlacAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_FlacAudioCursor = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.FlacAudioCursor",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FlacAudioCursor,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_FlacAudioCursor,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_FlacAudioCursor,
    &Dtool_SequenceMethods_FlacAudioCursor,
    &Dtool_MappingMethods_FlacAudioCursor,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_FlacAudioCursor,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Implements decoding of FLAC audio files.\n"
    " *\n"
    " * @see FlacAudio\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FlacAudioCursor,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FlacAudioCursor,
    PyType_GenericAlloc,
    Dtool_new_FlacAudioCursor,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FlacAudioCursor,
  Dtool_UpcastInterface_FlacAudioCursor,
  Dtool_DowncastInterface_FlacAudioCursor,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_FlacAudioCursor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovieAudioCursor(nullptr);
    Dtool_FlacAudioCursor._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovieAudioCursor);
    Dtool_FlacAudioCursor._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_FlacAudioCursor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FlacAudioCursor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FlacAudioCursor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FlacAudioCursor);
  }
}

/**
 * Python method tables for MovieVideo (MovieVideo)
 */
static PyMethodDef Dtool_Methods_MovieVideo[] = {
  {"open", &Dtool_MovieVideo_open_46, METH_NOARGS, (const char *)Dtool_MovieVideo_open_46_comment},
  {"get", &Dtool_MovieVideo_get_47, METH_O | METH_STATIC, (const char *)Dtool_MovieVideo_get_47_comment},
  {"get_filename", &Dtool_MovieVideo_get_filename_48, METH_NOARGS, (const char *)Dtool_MovieVideo_get_filename_48_comment},
  {"getFilename", &Dtool_MovieVideo_get_filename_48, METH_NOARGS, (const char *)Dtool_MovieVideo_get_filename_48_comment},
  {"get_subfile_info", &Dtool_MovieVideo_get_subfile_info_49, METH_NOARGS, (const char *)Dtool_MovieVideo_get_subfile_info_49_comment},
  {"getSubfileInfo", &Dtool_MovieVideo_get_subfile_info_49, METH_NOARGS, (const char *)Dtool_MovieVideo_get_subfile_info_49_comment},
  {"get_class_type", &Dtool_MovieVideo_get_class_type_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieVideo_get_class_type_54_comment},
  {"getClassType", &Dtool_MovieVideo_get_class_type_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieVideo_get_class_type_54_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_40, METH_NOARGS, (const char *)Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_40_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_40, METH_NOARGS, (const char *)Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_40_comment},
  {"upcast_to_Namable", &Dtool_MovieVideo_upcast_to_Namable_42, METH_NOARGS, (const char *)Dtool_MovieVideo_upcast_to_Namable_42_comment},
  {"upcastToNamable", &Dtool_MovieVideo_upcast_to_Namable_42, METH_NOARGS, (const char *)Dtool_MovieVideo_upcast_to_Namable_42_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_MovieVideo[] = {
  {(char *)"filename", &Dtool_MovieVideo_filename_Getter, nullptr, nullptr, nullptr},
  {(char *)"subfile_info", &Dtool_MovieVideo_subfile_info_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_MovieVideo = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovieVideo = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MovieVideo = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MovieVideo = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MovieVideo = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MovieVideo = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MovieVideo",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MovieVideo,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MovieVideo,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MovieVideo,
    &Dtool_SequenceMethods_MovieVideo,
    &Dtool_MappingMethods_MovieVideo,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MovieVideo,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A MovieVideo is actually any source that provides a sequence of video\n"
    " * frames.  That could include an AVI file, a digital camera, or an internet\n"
    " * TV station.\n"
    " *\n"
    " * The difference between a MovieVideo and a MovieVideoCursor is like the\n"
    " * difference between a filename and a file handle.  The MovieVideo just\n"
    " * indicates a particular movie.  The MovieVideoCursor is what allows access.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MovieVideo,
    nullptr, // tp_members
    Dtool_Properties_MovieVideo,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MovieVideo,
    PyType_GenericAlloc,
    Dtool_new_MovieVideo,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovieVideo,
  Dtool_UpcastInterface_MovieVideo,
  Dtool_DowncastInterface_MovieVideo,
  (CoerceFunction)Dtool_ConstCoerce_MovieVideo,
  (CoerceFunction)Dtool_Coerce_MovieVideo,
};

static void Dtool_PyModuleClassInit_MovieVideo(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_MovieVideo._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_MovieVideo._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MovieVideo._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovieVideo) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovieVideo)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovieVideo);
  }
}

/**
 * Python method tables for InkblotVideo (InkblotVideo)
 */
static PyMethodDef Dtool_Methods_InkblotVideo[] = {
  {"get_class_type", &Dtool_InkblotVideo_get_class_type_57, METH_NOARGS | METH_STATIC, (const char *)Dtool_InkblotVideo_get_class_type_57_comment},
  {"getClassType", &Dtool_InkblotVideo_get_class_type_57, METH_NOARGS | METH_STATIC, (const char *)Dtool_InkblotVideo_get_class_type_57_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_InkblotVideo = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_InkblotVideo = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_InkblotVideo = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_InkblotVideo = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_InkblotVideo = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_InkblotVideo = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.InkblotVideo",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InkblotVideo,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_InkblotVideo,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_InkblotVideo,
    &Dtool_SequenceMethods_InkblotVideo,
    &Dtool_MappingMethods_InkblotVideo,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_InkblotVideo,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A cellular automaton that generates an amusing pattern of swirling colors.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InkblotVideo,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InkblotVideo,
    PyType_GenericAlloc,
    Dtool_new_InkblotVideo,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InkblotVideo,
  Dtool_UpcastInterface_InkblotVideo,
  Dtool_DowncastInterface_InkblotVideo,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_InkblotVideo(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovieVideo(nullptr);
    Dtool_InkblotVideo._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovieVideo);
    Dtool_InkblotVideo._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_InkblotVideo._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InkblotVideo) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InkblotVideo)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InkblotVideo);
  }
}

/**
 * Python method tables for MovieVideoCursor_Buffer (Buffer)
 */
static PyMethodDef Dtool_Methods_MovieVideoCursor_Buffer[] = {
  {"compare_timestamp", &Dtool_MovieVideoCursor_Buffer_compare_timestamp_73, METH_O, (const char *)Dtool_MovieVideoCursor_Buffer_compare_timestamp_73_comment},
  {"compareTimestamp", &Dtool_MovieVideoCursor_Buffer_compare_timestamp_73, METH_O, (const char *)Dtool_MovieVideoCursor_Buffer_compare_timestamp_73_comment},
  {"get_timestamp", &Dtool_MovieVideoCursor_Buffer_get_timestamp_74, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_Buffer_get_timestamp_74_comment},
  {"getTimestamp", &Dtool_MovieVideoCursor_Buffer_get_timestamp_74, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_Buffer_get_timestamp_74_comment},
  {"get_class_type", &Dtool_MovieVideoCursor_Buffer_get_class_type_75, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieVideoCursor_Buffer_get_class_type_75_comment},
  {"getClassType", &Dtool_MovieVideoCursor_Buffer_get_class_type_75, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieVideoCursor_Buffer_get_class_type_75_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MovieVideoCursor_Buffer = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovieVideoCursor_Buffer = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MovieVideoCursor_Buffer = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MovieVideoCursor_Buffer = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MovieVideoCursor_Buffer = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MovieVideoCursor_Buffer = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Buffer",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MovieVideoCursor_Buffer,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MovieVideoCursor_Buffer,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MovieVideoCursor_Buffer,
    &Dtool_SequenceMethods_MovieVideoCursor_Buffer,
    &Dtool_MappingMethods_MovieVideoCursor_Buffer,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MovieVideoCursor_Buffer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MovieVideoCursor_Buffer,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MovieVideoCursor_Buffer,
    PyType_GenericAlloc,
    Dtool_new_MovieVideoCursor_Buffer,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovieVideoCursor_Buffer,
  Dtool_UpcastInterface_MovieVideoCursor_Buffer,
  Dtool_DowncastInterface_MovieVideoCursor_Buffer,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MovieVideoCursor_Buffer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_MovieVideoCursor_Buffer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_MovieVideoCursor_Buffer._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MovieVideoCursor_Buffer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovieVideoCursor_Buffer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovieVideoCursor_Buffer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovieVideoCursor_Buffer);
  }
}

/**
 * Python method tables for MovieVideoCursor (MovieVideoCursor)
 */
static PyMethodDef Dtool_Methods_MovieVideoCursor[] = {
  {"get_source", &Dtool_MovieVideoCursor_get_source_59, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_get_source_59_comment},
  {"getSource", &Dtool_MovieVideoCursor_get_source_59, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_get_source_59_comment},
  {"size_x", &Dtool_MovieVideoCursor_size_x_60, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_size_x_60_comment},
  {"sizeX", &Dtool_MovieVideoCursor_size_x_60, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_size_x_60_comment},
  {"size_y", &Dtool_MovieVideoCursor_size_y_61, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_size_y_61_comment},
  {"sizeY", &Dtool_MovieVideoCursor_size_y_61, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_size_y_61_comment},
  {"get_num_components", &Dtool_MovieVideoCursor_get_num_components_62, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_get_num_components_62_comment},
  {"getNumComponents", &Dtool_MovieVideoCursor_get_num_components_62, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_get_num_components_62_comment},
  {"length", &Dtool_MovieVideoCursor_length_63, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_length_63_comment},
  {"can_seek", &Dtool_MovieVideoCursor_can_seek_64, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_can_seek_64_comment},
  {"canSeek", &Dtool_MovieVideoCursor_can_seek_64, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_can_seek_64_comment},
  {"can_seek_fast", &Dtool_MovieVideoCursor_can_seek_fast_65, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_can_seek_fast_65_comment},
  {"canSeekFast", &Dtool_MovieVideoCursor_can_seek_fast_65, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_can_seek_fast_65_comment},
  {"aborted", &Dtool_MovieVideoCursor_aborted_66, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_aborted_66_comment},
  {"ready", &Dtool_MovieVideoCursor_ready_67, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_ready_67_comment},
  {"streaming", &Dtool_MovieVideoCursor_streaming_68, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_streaming_68_comment},
  {"setup_texture", &Dtool_MovieVideoCursor_setup_texture_69, METH_O, (const char *)Dtool_MovieVideoCursor_setup_texture_69_comment},
  {"setupTexture", &Dtool_MovieVideoCursor_setup_texture_69, METH_O, (const char *)Dtool_MovieVideoCursor_setup_texture_69_comment},
  {"set_time", (PyCFunction) &Dtool_MovieVideoCursor_set_time_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MovieVideoCursor_set_time_70_comment},
  {"setTime", (PyCFunction) &Dtool_MovieVideoCursor_set_time_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MovieVideoCursor_set_time_70_comment},
  {"fetch_buffer", &Dtool_MovieVideoCursor_fetch_buffer_77, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_fetch_buffer_77_comment},
  {"fetchBuffer", &Dtool_MovieVideoCursor_fetch_buffer_77, METH_NOARGS, (const char *)Dtool_MovieVideoCursor_fetch_buffer_77_comment},
  {"apply_to_texture", (PyCFunction) &Dtool_MovieVideoCursor_apply_to_texture_78, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MovieVideoCursor_apply_to_texture_78_comment},
  {"applyToTexture", (PyCFunction) &Dtool_MovieVideoCursor_apply_to_texture_78, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MovieVideoCursor_apply_to_texture_78_comment},
  {"apply_to_texture_rgb", (PyCFunction) &Dtool_MovieVideoCursor_apply_to_texture_rgb_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MovieVideoCursor_apply_to_texture_rgb_79_comment},
  {"applyToTextureRgb", (PyCFunction) &Dtool_MovieVideoCursor_apply_to_texture_rgb_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MovieVideoCursor_apply_to_texture_rgb_79_comment},
  {"apply_to_texture_alpha", (PyCFunction) &Dtool_MovieVideoCursor_apply_to_texture_alpha_80, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MovieVideoCursor_apply_to_texture_alpha_80_comment},
  {"applyToTextureAlpha", (PyCFunction) &Dtool_MovieVideoCursor_apply_to_texture_alpha_80, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MovieVideoCursor_apply_to_texture_alpha_80_comment},
  {"get_class_type", &Dtool_MovieVideoCursor_get_class_type_81, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieVideoCursor_get_class_type_81_comment},
  {"getClassType", &Dtool_MovieVideoCursor_get_class_type_81, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieVideoCursor_get_class_type_81_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MovieVideoCursor = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovieVideoCursor = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MovieVideoCursor = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MovieVideoCursor = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MovieVideoCursor = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MovieVideoCursor = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MovieVideoCursor",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MovieVideoCursor,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MovieVideoCursor,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MovieVideoCursor,
    &Dtool_SequenceMethods_MovieVideoCursor,
    &Dtool_MappingMethods_MovieVideoCursor,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MovieVideoCursor,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A MovieVideo is actually any source that provides a sequence of video\n"
    " * frames.  That could include an AVI file, a digital camera, or an internet\n"
    " * TV station.  A MovieVideoCursor is a handle that lets you read data\n"
    " * sequentially from a MovieVideo.\n"
    " *\n"
    " * Thread safety: each individual MovieVideoCursor must be owned and accessed\n"
    " * by a single thread.  It is OK for two different threads to open the same\n"
    " * file at the same time, as long as they use separate MovieVideoCursor\n"
    " * objects.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MovieVideoCursor,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MovieVideoCursor,
    PyType_GenericAlloc,
    Dtool_new_MovieVideoCursor,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovieVideoCursor,
  Dtool_UpcastInterface_MovieVideoCursor,
  Dtool_DowncastInterface_MovieVideoCursor,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MovieVideoCursor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_MovieVideoCursor._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_MovieVideoCursor._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MovieVideoCursor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Nested Object   MovieVideoCursor_Buffer;
    Dtool_PyModuleClassInit_MovieVideoCursor_Buffer(nullptr);
    PyDict_SetItemString(dict, "Buffer", (PyObject *)&Dtool_MovieVideoCursor_Buffer);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovieVideoCursor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovieVideoCursor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovieVideoCursor);
  }
}

/**
 * Python method tables for InkblotVideoCursor (InkblotVideoCursor)
 */
static PyMethodDef Dtool_Methods_InkblotVideoCursor[] = {
  {"get_class_type", &Dtool_InkblotVideoCursor_get_class_type_85, METH_NOARGS | METH_STATIC, (const char *)Dtool_InkblotVideoCursor_get_class_type_85_comment},
  {"getClassType", &Dtool_InkblotVideoCursor_get_class_type_85, METH_NOARGS | METH_STATIC, (const char *)Dtool_InkblotVideoCursor_get_class_type_85_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_InkblotVideoCursor = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_InkblotVideoCursor = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_InkblotVideoCursor = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_InkblotVideoCursor = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_InkblotVideoCursor = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_InkblotVideoCursor = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.InkblotVideoCursor",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InkblotVideoCursor,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_InkblotVideoCursor,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_InkblotVideoCursor,
    &Dtool_SequenceMethods_InkblotVideoCursor,
    &Dtool_MappingMethods_InkblotVideoCursor,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_InkblotVideoCursor,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A cellular automaton that generates an amusing pattern of swirling colors.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InkblotVideoCursor,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InkblotVideoCursor,
    PyType_GenericAlloc,
    Dtool_new_InkblotVideoCursor,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InkblotVideoCursor,
  Dtool_UpcastInterface_InkblotVideoCursor,
  Dtool_DowncastInterface_InkblotVideoCursor,
  (CoerceFunction)Dtool_ConstCoerce_InkblotVideoCursor,
  (CoerceFunction)Dtool_Coerce_InkblotVideoCursor,
};

static void Dtool_PyModuleClassInit_InkblotVideoCursor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovieVideoCursor(nullptr);
    Dtool_InkblotVideoCursor._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovieVideoCursor);
    Dtool_InkblotVideoCursor._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_InkblotVideoCursor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InkblotVideoCursor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InkblotVideoCursor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InkblotVideoCursor);
  }
}

/**
 * Python method tables for MicrophoneAudio (MicrophoneAudio)
 */
static PyMethodDef Dtool_Methods_MicrophoneAudio[] = {
  {"get_num_options", &Dtool_MicrophoneAudio_get_num_options_87, METH_NOARGS | METH_STATIC, (const char *)Dtool_MicrophoneAudio_get_num_options_87_comment},
  {"getNumOptions", &Dtool_MicrophoneAudio_get_num_options_87, METH_NOARGS | METH_STATIC, (const char *)Dtool_MicrophoneAudio_get_num_options_87_comment},
  {"get_option", &Dtool_MicrophoneAudio_get_option_88, METH_O | METH_STATIC, (const char *)Dtool_MicrophoneAudio_get_option_88_comment},
  {"getOption", &Dtool_MicrophoneAudio_get_option_88, METH_O | METH_STATIC, (const char *)Dtool_MicrophoneAudio_get_option_88_comment},
  {"get_channels", &Dtool_MicrophoneAudio_get_channels_90, METH_NOARGS, (const char *)Dtool_MicrophoneAudio_get_channels_90_comment},
  {"getChannels", &Dtool_MicrophoneAudio_get_channels_90, METH_NOARGS, (const char *)Dtool_MicrophoneAudio_get_channels_90_comment},
  {"get_rate", &Dtool_MicrophoneAudio_get_rate_91, METH_NOARGS, (const char *)Dtool_MicrophoneAudio_get_rate_91_comment},
  {"getRate", &Dtool_MicrophoneAudio_get_rate_91, METH_NOARGS, (const char *)Dtool_MicrophoneAudio_get_rate_91_comment},
  {"get_class_type", &Dtool_MicrophoneAudio_get_class_type_97, METH_NOARGS | METH_STATIC, (const char *)Dtool_MicrophoneAudio_get_class_type_97_comment},
  {"getClassType", &Dtool_MicrophoneAudio_get_class_type_97, METH_NOARGS | METH_STATIC, (const char *)Dtool_MicrophoneAudio_get_class_type_97_comment},
  {"get_options", (PyCFunction) &MakeSeq_MicrophoneAudio_get_options, METH_NOARGS | METH_STATIC, nullptr},
  { "getOptions", (PyCFunction) &MakeSeq_MicrophoneAudio_get_options, METH_NOARGS | METH_STATIC, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_MicrophoneAudio[] = {
  {(char *)"channels", &Dtool_MicrophoneAudio_channels_Getter, nullptr, nullptr, nullptr},
  {(char *)"rate", &Dtool_MicrophoneAudio_rate_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_MicrophoneAudio = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MicrophoneAudio = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MicrophoneAudio = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MicrophoneAudio = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MicrophoneAudio = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MicrophoneAudio = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MicrophoneAudio",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MicrophoneAudio,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MicrophoneAudio,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MicrophoneAudio,
    &Dtool_SequenceMethods_MicrophoneAudio,
    &Dtool_MappingMethods_MicrophoneAudio,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MicrophoneAudio,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Class MicrophoneAudio provides the means to read raw audio samples from a\n"
    " * microphone.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MicrophoneAudio,
    nullptr, // tp_members
    Dtool_Properties_MicrophoneAudio,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MicrophoneAudio,
    PyType_GenericAlloc,
    Dtool_new_MicrophoneAudio,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MicrophoneAudio,
  Dtool_UpcastInterface_MicrophoneAudio,
  Dtool_DowncastInterface_MicrophoneAudio,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MicrophoneAudio(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovieAudio(nullptr);
    Dtool_MicrophoneAudio._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovieAudio);
    Dtool_MicrophoneAudio._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MicrophoneAudio._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_options = {(char *)"options", &Dtool_MicrophoneAudio_options_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "options", Dtool_NewStaticProperty(&Dtool_MicrophoneAudio._PyType, &def_options));
    if (PyType_Ready((PyTypeObject *)&Dtool_MicrophoneAudio) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MicrophoneAudio)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MicrophoneAudio);
  }
}

/**
 * Python method tables for UserDataAudio (UserDataAudio)
 */
static PyMethodDef Dtool_Methods_UserDataAudio[] = {
  {"append", (PyCFunction) &Dtool_UserDataAudio_append_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_UserDataAudio_append_100_comment},
  {"done", &Dtool_UserDataAudio_done_101, METH_NOARGS, (const char *)Dtool_UserDataAudio_done_101_comment},
  {"get_class_type", &Dtool_UserDataAudio_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_UserDataAudio_get_class_type_102_comment},
  {"getClassType", &Dtool_UserDataAudio_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_UserDataAudio_get_class_type_102_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_UserDataAudio = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UserDataAudio = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_UserDataAudio = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_UserDataAudio = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_UserDataAudio = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_UserDataAudio = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.UserDataAudio",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_UserDataAudio,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_UserDataAudio,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_UserDataAudio,
    &Dtool_SequenceMethods_UserDataAudio,
    &Dtool_MappingMethods_UserDataAudio,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_UserDataAudio,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A UserDataAudio is a way for the user to manually supply raw audio samples.\n"
    " * remove_after_read means the data will be removed if read once.  Else data\n"
    " * will be stored (enable looping and seeking). Expects data as 16 bit signed\n"
    " * (word); Example for stereo: 1.word = 1.channel,2.word = 2.channel, 3.word =\n"
    " * 1.channel,4.word = 2.channel, etc.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_UserDataAudio,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_UserDataAudio,
    PyType_GenericAlloc,
    Dtool_new_UserDataAudio,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UserDataAudio,
  Dtool_UpcastInterface_UserDataAudio,
  Dtool_DowncastInterface_UserDataAudio,
  (CoerceFunction)Dtool_ConstCoerce_UserDataAudio,
  (CoerceFunction)Dtool_Coerce_UserDataAudio,
};

static void Dtool_PyModuleClassInit_UserDataAudio(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovieAudio(nullptr);
    Dtool_UserDataAudio._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovieAudio);
    Dtool_UserDataAudio._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_UserDataAudio._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UserDataAudio) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UserDataAudio)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UserDataAudio);
  }
}

/**
 * Python method tables for UserDataAudioCursor (UserDataAudioCursor)
 */
static PyMethodDef Dtool_Methods_UserDataAudioCursor[] = {
  {"get_class_type", &Dtool_UserDataAudioCursor_get_class_type_105, METH_NOARGS | METH_STATIC, (const char *)Dtool_UserDataAudioCursor_get_class_type_105_comment},
  {"getClassType", &Dtool_UserDataAudioCursor_get_class_type_105, METH_NOARGS | METH_STATIC, (const char *)Dtool_UserDataAudioCursor_get_class_type_105_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_UserDataAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UserDataAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_UserDataAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_UserDataAudioCursor = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_UserDataAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_UserDataAudioCursor = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.UserDataAudioCursor",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_UserDataAudioCursor,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_UserDataAudioCursor,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_UserDataAudioCursor,
    &Dtool_SequenceMethods_UserDataAudioCursor,
    &Dtool_MappingMethods_UserDataAudioCursor,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_UserDataAudioCursor,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A UserDataAudioCursor is a means to manually supply a sequence of raw audio\n"
    " * samples.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_UserDataAudioCursor,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_UserDataAudioCursor,
    PyType_GenericAlloc,
    Dtool_new_UserDataAudioCursor,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UserDataAudioCursor,
  Dtool_UpcastInterface_UserDataAudioCursor,
  Dtool_DowncastInterface_UserDataAudioCursor,
  (CoerceFunction)Dtool_ConstCoerce_UserDataAudioCursor,
  (CoerceFunction)Dtool_Coerce_UserDataAudioCursor,
};

static void Dtool_PyModuleClassInit_UserDataAudioCursor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovieAudioCursor(nullptr);
    Dtool_UserDataAudioCursor._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovieAudioCursor);
    Dtool_UserDataAudioCursor._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_UserDataAudioCursor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UserDataAudioCursor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UserDataAudioCursor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UserDataAudioCursor);
  }
}

/**
 * Python method tables for VorbisAudio (VorbisAudio)
 */
static PyMethodDef Dtool_Methods_VorbisAudio[] = {
  {"make", &Dtool_VorbisAudio_make_108, METH_O | METH_STATIC, (const char *)Dtool_VorbisAudio_make_108_comment},
  {"get_class_type", &Dtool_VorbisAudio_get_class_type_109, METH_NOARGS | METH_STATIC, (const char *)Dtool_VorbisAudio_get_class_type_109_comment},
  {"getClassType", &Dtool_VorbisAudio_get_class_type_109, METH_NOARGS | METH_STATIC, (const char *)Dtool_VorbisAudio_get_class_type_109_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VorbisAudio = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VorbisAudio = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VorbisAudio = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VorbisAudio = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VorbisAudio = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VorbisAudio = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VorbisAudio",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VorbisAudio,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VorbisAudio,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VorbisAudio,
    &Dtool_SequenceMethods_VorbisAudio,
    &Dtool_MappingMethods_VorbisAudio,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VorbisAudio,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Interfaces with the libvorbisfile library to implement decoding of Ogg\n"
    " * Vorbis audio files.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VorbisAudio,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VorbisAudio,
    PyType_GenericAlloc,
    Dtool_new_VorbisAudio,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VorbisAudio,
  Dtool_UpcastInterface_VorbisAudio,
  Dtool_DowncastInterface_VorbisAudio,
  (CoerceFunction)Dtool_ConstCoerce_VorbisAudio,
  (CoerceFunction)Dtool_Coerce_VorbisAudio,
};

static void Dtool_PyModuleClassInit_VorbisAudio(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovieAudio(nullptr);
    Dtool_VorbisAudio._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovieAudio);
    Dtool_VorbisAudio._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VorbisAudio._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VorbisAudio) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VorbisAudio)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VorbisAudio);
  }
}

/**
 * Python method tables for VorbisAudioCursor (VorbisAudioCursor)
 */
static PyMethodDef Dtool_Methods_VorbisAudioCursor[] = {
  {"get_class_type", &Dtool_VorbisAudioCursor_get_class_type_112, METH_NOARGS | METH_STATIC, (const char *)Dtool_VorbisAudioCursor_get_class_type_112_comment},
  {"getClassType", &Dtool_VorbisAudioCursor_get_class_type_112, METH_NOARGS | METH_STATIC, (const char *)Dtool_VorbisAudioCursor_get_class_type_112_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VorbisAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VorbisAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VorbisAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VorbisAudioCursor = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VorbisAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VorbisAudioCursor = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VorbisAudioCursor",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VorbisAudioCursor,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VorbisAudioCursor,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VorbisAudioCursor,
    &Dtool_SequenceMethods_VorbisAudioCursor,
    &Dtool_MappingMethods_VorbisAudioCursor,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VorbisAudioCursor,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Interfaces with the libvorbisfile library to implement decoding of Ogg\n"
    " * Vorbis audio files.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VorbisAudioCursor,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VorbisAudioCursor,
    PyType_GenericAlloc,
    Dtool_new_VorbisAudioCursor,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VorbisAudioCursor,
  Dtool_UpcastInterface_VorbisAudioCursor,
  Dtool_DowncastInterface_VorbisAudioCursor,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VorbisAudioCursor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovieAudioCursor(nullptr);
    Dtool_VorbisAudioCursor._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovieAudioCursor);
    Dtool_VorbisAudioCursor._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VorbisAudioCursor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VorbisAudioCursor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VorbisAudioCursor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VorbisAudioCursor);
  }
}

/**
 * Python method tables for WavAudio (WavAudio)
 */
static PyMethodDef Dtool_Methods_WavAudio[] = {
  {"make", &Dtool_WavAudio_make_115, METH_O | METH_STATIC, (const char *)Dtool_WavAudio_make_115_comment},
  {"get_class_type", &Dtool_WavAudio_get_class_type_116, METH_NOARGS | METH_STATIC, (const char *)Dtool_WavAudio_get_class_type_116_comment},
  {"getClassType", &Dtool_WavAudio_get_class_type_116, METH_NOARGS | METH_STATIC, (const char *)Dtool_WavAudio_get_class_type_116_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_WavAudio = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WavAudio = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_WavAudio = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_WavAudio = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_WavAudio = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_WavAudio = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.WavAudio",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_WavAudio,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_WavAudio,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_WavAudio,
    &Dtool_SequenceMethods_WavAudio,
    &Dtool_MappingMethods_WavAudio,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_WavAudio,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A native PCM .wav loader.  Supported formats are linear PCM, IEEE float,\n"
    " * A-law and mu-law.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_WavAudio,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_WavAudio,
    PyType_GenericAlloc,
    Dtool_new_WavAudio,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WavAudio,
  Dtool_UpcastInterface_WavAudio,
  Dtool_DowncastInterface_WavAudio,
  (CoerceFunction)Dtool_ConstCoerce_WavAudio,
  (CoerceFunction)Dtool_Coerce_WavAudio,
};

static void Dtool_PyModuleClassInit_WavAudio(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovieAudio(nullptr);
    Dtool_WavAudio._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovieAudio);
    Dtool_WavAudio._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_WavAudio._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WavAudio) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WavAudio)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WavAudio);
  }
}

/**
 * Python method tables for WavAudioCursor (WavAudioCursor)
 */
static PyMethodDef Dtool_Methods_WavAudioCursor[] = {
  {"get_class_type", &Dtool_WavAudioCursor_get_class_type_119, METH_NOARGS | METH_STATIC, (const char *)Dtool_WavAudioCursor_get_class_type_119_comment},
  {"getClassType", &Dtool_WavAudioCursor_get_class_type_119, METH_NOARGS | METH_STATIC, (const char *)Dtool_WavAudioCursor_get_class_type_119_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_WavAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WavAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_WavAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_WavAudioCursor = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_WavAudioCursor = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_WavAudioCursor = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.WavAudioCursor",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_WavAudioCursor,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_WavAudioCursor,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_WavAudioCursor,
    &Dtool_SequenceMethods_WavAudioCursor,
    &Dtool_MappingMethods_WavAudioCursor,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_WavAudioCursor,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Used for reading PCM .wav files.  Supported formats are linear PCM, IEEE\n"
    " * float, A-law and mu-law.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_WavAudioCursor,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_WavAudioCursor,
    PyType_GenericAlloc,
    Dtool_new_WavAudioCursor,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WavAudioCursor,
  Dtool_UpcastInterface_WavAudioCursor,
  Dtool_DowncastInterface_WavAudioCursor,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_WavAudioCursor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovieAudioCursor(nullptr);
    Dtool_WavAudioCursor._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovieAudioCursor);
    Dtool_WavAudioCursor._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_WavAudioCursor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WavAudioCursor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WavAudioCursor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WavAudioCursor);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3movies_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    MovieAudio::init_type();
    TypeHandle handle = MovieAudio::get_class_type();
    Dtool_MovieAudio._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MovieAudio);
  }
  {
    FlacAudio::init_type();
    TypeHandle handle = FlacAudio::get_class_type();
    Dtool_FlacAudio._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_FlacAudio);
  }
  {
    MovieAudioCursor::init_type();
    TypeHandle handle = MovieAudioCursor::get_class_type();
    Dtool_MovieAudioCursor._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MovieAudioCursor);
  }
  {
    FlacAudioCursor::init_type();
    TypeHandle handle = FlacAudioCursor::get_class_type();
    Dtool_FlacAudioCursor._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_FlacAudioCursor);
  }
  {
    MovieVideo::init_type();
    TypeHandle handle = MovieVideo::get_class_type();
    Dtool_MovieVideo._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MovieVideo);
  }
  {
    InkblotVideo::init_type();
    TypeHandle handle = InkblotVideo::get_class_type();
    Dtool_InkblotVideo._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_InkblotVideo);
  }
  {
    MovieVideoCursor::init_type();
    TypeHandle handle = MovieVideoCursor::get_class_type();
    Dtool_MovieVideoCursor._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MovieVideoCursor);
  }
  {
    MovieVideoCursor::Buffer::init_type();
    TypeHandle handle = MovieVideoCursor::Buffer::get_class_type();
    Dtool_MovieVideoCursor_Buffer._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MovieVideoCursor_Buffer);
  }
  {
    InkblotVideoCursor::init_type();
    TypeHandle handle = InkblotVideoCursor::get_class_type();
    Dtool_InkblotVideoCursor._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_InkblotVideoCursor);
  }
  {
    MicrophoneAudio::init_type();
    TypeHandle handle = MicrophoneAudio::get_class_type();
    Dtool_MicrophoneAudio._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MicrophoneAudio);
  }
  {
    UserDataAudio::init_type();
    TypeHandle handle = UserDataAudio::get_class_type();
    Dtool_UserDataAudio._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_UserDataAudio);
  }
  {
    UserDataAudioCursor::init_type();
    TypeHandle handle = UserDataAudioCursor::get_class_type();
    Dtool_UserDataAudioCursor._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_UserDataAudioCursor);
  }
  {
    VorbisAudio::init_type();
    TypeHandle handle = VorbisAudio::get_class_type();
    Dtool_VorbisAudio._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VorbisAudio);
  }
  {
    VorbisAudioCursor::init_type();
    TypeHandle handle = VorbisAudioCursor::get_class_type();
    Dtool_VorbisAudioCursor._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VorbisAudioCursor);
  }
  {
    WavAudio::init_type();
    TypeHandle handle = WavAudio::get_class_type();
    Dtool_WavAudio._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_WavAudio);
  }
  {
    WavAudioCursor::init_type();
    TypeHandle handle = WavAudioCursor::get_class_type();
    Dtool_WavAudioCursor._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_WavAudioCursor);
  }
}

void Dtool_libp3movies_BuildInstants(PyObject *module) {
  (void) module;
  // MovieAudio
  Dtool_PyModuleClassInit_MovieAudio(module);
  PyModule_AddObject(module, "MovieAudio", (PyObject *)&Dtool_MovieAudio);
  // FlacAudio
  Dtool_PyModuleClassInit_FlacAudio(module);
  PyModule_AddObject(module, "FlacAudio", (PyObject *)&Dtool_FlacAudio);
  // MovieAudioCursor
  Dtool_PyModuleClassInit_MovieAudioCursor(module);
  PyModule_AddObject(module, "MovieAudioCursor", (PyObject *)&Dtool_MovieAudioCursor);
  // FlacAudioCursor
  Dtool_PyModuleClassInit_FlacAudioCursor(module);
  PyModule_AddObject(module, "FlacAudioCursor", (PyObject *)&Dtool_FlacAudioCursor);
  // MovieVideo
  Dtool_PyModuleClassInit_MovieVideo(module);
  PyModule_AddObject(module, "MovieVideo", (PyObject *)&Dtool_MovieVideo);
  // InkblotVideo
  Dtool_PyModuleClassInit_InkblotVideo(module);
  PyModule_AddObject(module, "InkblotVideo", (PyObject *)&Dtool_InkblotVideo);
  // MovieVideoCursor
  Dtool_PyModuleClassInit_MovieVideoCursor(module);
  PyModule_AddObject(module, "MovieVideoCursor", (PyObject *)&Dtool_MovieVideoCursor);
  // InkblotVideoCursor
  Dtool_PyModuleClassInit_InkblotVideoCursor(module);
  PyModule_AddObject(module, "InkblotVideoCursor", (PyObject *)&Dtool_InkblotVideoCursor);
  // MicrophoneAudio
  Dtool_PyModuleClassInit_MicrophoneAudio(module);
  PyModule_AddObject(module, "MicrophoneAudio", (PyObject *)&Dtool_MicrophoneAudio);
  // UserDataAudio
  Dtool_PyModuleClassInit_UserDataAudio(module);
  PyModule_AddObject(module, "UserDataAudio", (PyObject *)&Dtool_UserDataAudio);
  // UserDataAudioCursor
  Dtool_PyModuleClassInit_UserDataAudioCursor(module);
  PyModule_AddObject(module, "UserDataAudioCursor", (PyObject *)&Dtool_UserDataAudioCursor);
  // VorbisAudio
  Dtool_PyModuleClassInit_VorbisAudio(module);
  PyModule_AddObject(module, "VorbisAudio", (PyObject *)&Dtool_VorbisAudio);
  // VorbisAudioCursor
  Dtool_PyModuleClassInit_VorbisAudioCursor(module);
  PyModule_AddObject(module, "VorbisAudioCursor", (PyObject *)&Dtool_VorbisAudioCursor);
  // WavAudio
  Dtool_PyModuleClassInit_WavAudio(module);
  PyModule_AddObject(module, "WavAudio", (PyObject *)&Dtool_WavAudio);
  // WavAudioCursor
  Dtool_PyModuleClassInit_WavAudioCursor(module);
  PyModule_AddObject(module, "WavAudioCursor", (PyObject *)&Dtool_WavAudioCursor);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3movies_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3movies_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613702,  /* file_identifier */
  "libp3movies",  /* library_name */
  "Aas2",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3movies.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  284  /* next_index */
};

Configure(_in_configure_libp3movies);
ConfigureFn(_in_configure_libp3movies) {
  interrogate_request_module(&_in_module_def);
}

