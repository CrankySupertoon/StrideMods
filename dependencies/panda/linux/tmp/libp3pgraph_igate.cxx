/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/pgraph -Ipanda/src/pgraph -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3pgraph_igate.cxx -od built/pandac/input/libp3pgraph.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/pgraph -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3pgraph accumulatedAttribs.h alphaTestAttrib.h antialiasAttrib.h attribNodeRegistry.h audioVolumeAttrib.h auxBitplaneAttrib.h auxSceneData.h bamFile.h billboardEffect.h cacheStats.h camera.h clipPlaneAttrib.h colorAttrib.h colorBlendAttrib.h colorScaleAttrib.h colorWriteAttrib.h compassEffect.h config_pgraph.h cullBin.h cullBinAttrib.h cullBinEnums.h cullBinManager.h cullFaceAttrib.h cullHandler.h cullPlanes.h cullResult.h cullTraverser.h cullTraverserData.h cullableObject.h decalEffect.h depthOffsetAttrib.h depthTestAttrib.h depthWriteAttrib.h findApproxLevelEntry.h findApproxPath.h fog.h fogAttrib.h geomDrawCallbackData.h geomNode.h geomTransformer.h internalNameCollection.h lensNode.h light.h lightAttrib.h lightRampAttrib.h loader.h loaderFileType.h loaderFileTypeBam.h loaderFileTypeRegistry.h loaderFileTypeRegistry_ext.h logicOpAttrib.h materialAttrib.h materialCollection.h modelFlattenRequest.h modelLoadRequest.h modelNode.h modelPool.h modelRoot.h modelSaveRequest.h nodePath.cxx nodePath.h nodePathCollection.h nodePathCollection_ext.h nodePathComponent.h nodePath_ext.h occluderEffect.h occluderNode.h p3pgraph_composite1.cxx p3pgraph_composite2.cxx p3pgraph_composite3.cxx p3pgraph_composite4.cxx p3pgraph_ext_composite.cxx pandaNode.h pandaNodeChain.h pandaNode_ext.h paramNodePath.h planeNode.h polylightEffect.h polylightNode.h portalClipper.h portalNode.h pythonLoaderFileType.h renderAttrib.h renderAttribRegistry.h renderEffect.h renderEffects.h renderModeAttrib.h renderState.h renderState_ext.h rescaleNormalAttrib.h sceneGraphReducer.h sceneSetup.h scissorAttrib.h scissorEffect.h shadeModelAttrib.h shaderAttrib.h shaderAttrib_ext.h shaderInput.h shaderInput_ext.h shaderPool.h showBoundsEffect.h stateMunger.h stencilAttrib.h texGenAttrib.h texMatrixAttrib.h texProjectorEffect.h textureAttrib.h textureStageCollection.h transformState.h transformState_ext.h transparencyAttrib.h weakNodePath.h workingNodePath.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "accumulatedAttribs.h"
#include "alphaTestAttrib.h"
#include "antialiasAttrib.h"
#include "asyncTask.h"
#include "asyncTaskManager.h"
#include "attribNodeRegistry.h"
#include "audioVolumeAttrib.h"
#include "auxBitplaneAttrib.h"
#include "auxSceneData.h"
#include "bam.h"
#include "bamEnums.h"
#include "bamFile.h"
#include "bamWriter.h"
#include "billboardEffect.h"
#include "boundingSphere.h"
#include "cacheStats.h"
#include "camera.h"
#include "clipPlaneAttrib.h"
#include "clockObject.h"
#include "colorAttrib.h"
#include "colorBlendAttrib.h"
#include "colorScaleAttrib.h"
#include "colorWriteAttrib.h"
#include "compassEffect.h"
#include "config_gobj.h"
#include "config_pgraph.h"
#include "cullBin.h"
#include "cullBinAttrib.h"
#include "cullBinEnums.h"
#include "cullBinManager.h"
#include "cullFaceAttrib.h"
#include "cullHandler.h"
#include "cullPlanes.h"
#include "cullResult.h"
#include "cullTraverser.h"
#include "cullTraverserData.h"
#include "cullableObject.h"
#include "cycleData.h"
#include "cycleDataLockedReader.h"
#include "cycleDataReader.h"
#include "cycleDataWriter.h"
#include "dSearchPath.h"
#include "datagramBuffer.h"
#include "datagramInputFile.h"
#include "datagramOutputFile.h"
#include "dcast.h"
#include "decalEffect.h"
#include "depthOffsetAttrib.h"
#include "depthTestAttrib.h"
#include "depthWriteAttrib.h"
#include "drawMask.h"
#include "dtoolbase.h"
#include "epvector.h"
#include "extension.h"
#include "filename.h"
#include "findApproxLevelEntry.h"
#include "findApproxPath.h"
#include "fog.h"
#include "fogAttrib.h"
#include "geom.h"
#include "geomDrawCallbackData.h"
#include "geomMunger.h"
#include "geomNode.h"
#include "geomTransformer.h"
#include "geomVertexData.h"
#include "globPattern.h"
#include "graphicsStateGuardianBase.h"
#include "internalNameCollection.h"
#include "lensNode.h"
#include "light.h"
#include "lightAttrib.h"
#include "lightMutex.h"
#include "lightRampAttrib.h"
#include "loader.h"
#include "loaderFileType.h"
#include "loaderFileTypeBam.h"
#include "loaderFileTypeRegistry.h"
#include "loaderFileTypeRegistry_ext.h"
#include "loaderOptions.h"
#include "logicOpAttrib.h"
#include "look_at.h"
#include "luse.h"
#include "material.h"
#include "materialAttrib.h"
#include "materialCollection.h"
#include "materialPool.h"
#include "modelFlattenRequest.h"
#include "modelLoadRequest.h"
#include "modelNode.h"
#include "modelPool.h"
#include "modelRoot.h"
#include "modelSaveRequest.h"
#include "namable.h"
#include "nodePath.h"
#include "nodePathCollection.h"
#include "nodePathCollection_ext.h"
#include "nodePathComponent.h"
#include "nodePath_ext.h"
#include "occluderEffect.h"
#include "occluderNode.h"
#include "ordered_vector.h"
#include "pStatCollector.h"
#include "pStatTimer.h"
#include "pandaNode.h"
#include "pandaNodeChain.h"
#include "pandaNode_ext.h"
#include "pandabase.h"
#include "paramNodePath.h"
#include "perspectiveLens.h"
#include "pipelineCycler.h"
#include "planeNode.h"
#include "plist.h"
#include "pmap.h"
#include "pnotify.h"
#include "pointerTo.h"
#include "polylightEffect.h"
#include "polylightNode.h"
#include "portalClipper.h"
#include "portalNode.h"
#include "preparedGraphicsObjects.h"
#include "pset.h"
#include "pvector.h"
#include "py_panda.h"
#include "pythonLoaderFileType.h"
#include "referenceCount.h"
#include "renderAttrib.h"
#include "renderAttribRegistry.h"
#include "renderEffect.h"
#include "renderEffects.h"
#include "renderModeAttrib.h"
#include "renderState.h"
#include "renderState_ext.h"
#include "rescaleNormalAttrib.h"
#include "sceneGraphReducer.h"
#include "sceneSetup.h"
#include "scissorAttrib.h"
#include "scissorEffect.h"
#include "shadeModelAttrib.h"
#include "shader.h"
#include "shaderAttrib.h"
#include "shaderAttrib_ext.h"
#include "shaderInput.h"
#include "shaderInput_ext.h"
#include "shaderPool.h"
#include "showBoundsEffect.h"
#include "stateMunger.h"
#include "stencilAttrib.h"
#include "texGenAttrib.h"
#include "texMatrixAttrib.h"
#include "texProjectorEffect.h"
#include "textureAttrib.h"
#include "textureCollection.h"
#include "texturePool.h"
#include "textureStageCollection.h"
#include "transformState.h"
#include "transformState_ext.h"
#include "transparencyAttrib.h"
#include "typedObject.h"
#include "typedReferenceCount.h"
#include "updateSeq.h"
#include "vector_int.h"
#include "weakNodePath.h"
#include "workingNodePath.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class TransformState
 */
typedef TransformState TransformState_localtype;
Define_Module_ClassRef(panda3d.core, TransformState, TransformState_localtype, TransformState);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformState = &Dtool_TransformState;
static void Dtool_PyModuleClassInit_TransformState(PyObject *module);

/**
 * Forward declarations for top-level class RenderAttribRegistry
 */
typedef RenderAttribRegistry RenderAttribRegistry_localtype;
Define_Module_Class_Private(panda3d.core, RenderAttribRegistry, RenderAttribRegistry_localtype, RenderAttribRegistry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderAttribRegistry = &Dtool_RenderAttribRegistry;
static void Dtool_PyModuleClassInit_RenderAttribRegistry(PyObject *module);

/**
 * Forward declarations for top-level class RenderAttrib
 */
typedef RenderAttrib RenderAttrib_localtype;
Define_Module_ClassRef(panda3d.core, RenderAttrib, RenderAttrib_localtype, RenderAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderAttrib = &Dtool_RenderAttrib;
static void Dtool_PyModuleClassInit_RenderAttrib(PyObject *module);

/**
 * Forward declarations for top-level class RenderModeAttrib
 */
typedef RenderModeAttrib RenderModeAttrib_localtype;
Define_Module_ClassRef(panda3d.core, RenderModeAttrib, RenderModeAttrib_localtype, RenderModeAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderModeAttrib = &Dtool_RenderModeAttrib;
static void Dtool_PyModuleClassInit_RenderModeAttrib(PyObject *module);
bool Dtool_ConstCoerce_RenderModeAttrib(PyObject *args, CPT(RenderModeAttrib) &coerced);

/**
 * Forward declarations for top-level class TexMatrixAttrib
 */
typedef TexMatrixAttrib TexMatrixAttrib_localtype;
Define_Module_ClassRef(panda3d.core, TexMatrixAttrib, TexMatrixAttrib_localtype, TexMatrixAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TexMatrixAttrib = &Dtool_TexMatrixAttrib;
static void Dtool_PyModuleClassInit_TexMatrixAttrib(PyObject *module);
bool Dtool_ConstCoerce_TexMatrixAttrib(PyObject *args, CPT(TexMatrixAttrib) &coerced);

/**
 * Forward declarations for top-level class RenderState
 */
typedef RenderState RenderState_localtype;
Define_Module_ClassRef(panda3d.core, RenderState, RenderState_localtype, RenderState);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderState = &Dtool_RenderState;
static void Dtool_PyModuleClassInit_RenderState(PyObject *module);
bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced);

/**
 * Forward declarations for top-level class AlphaTestAttrib
 */
typedef AlphaTestAttrib AlphaTestAttrib_localtype;
Define_Module_ClassRef(panda3d.core, AlphaTestAttrib, AlphaTestAttrib_localtype, AlphaTestAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AlphaTestAttrib = &Dtool_AlphaTestAttrib;
static void Dtool_PyModuleClassInit_AlphaTestAttrib(PyObject *module);
bool Dtool_ConstCoerce_AlphaTestAttrib(PyObject *args, CPT(AlphaTestAttrib) &coerced);

/**
 * Forward declarations for top-level class AntialiasAttrib
 */
typedef AntialiasAttrib AntialiasAttrib_localtype;
Define_Module_ClassRef(panda3d.core, AntialiasAttrib, AntialiasAttrib_localtype, AntialiasAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AntialiasAttrib = &Dtool_AntialiasAttrib;
static void Dtool_PyModuleClassInit_AntialiasAttrib(PyObject *module);
bool Dtool_ConstCoerce_AntialiasAttrib(PyObject *args, CPT(AntialiasAttrib) &coerced);

/**
 * Forward declarations for top-level class RenderEffect
 */
typedef RenderEffect RenderEffect_localtype;
Define_Module_ClassRef(panda3d.core, RenderEffect, RenderEffect_localtype, RenderEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderEffect = &Dtool_RenderEffect;
static void Dtool_PyModuleClassInit_RenderEffect(PyObject *module);

/**
 * Forward declarations for top-level class RenderEffects
 */
typedef RenderEffects RenderEffects_localtype;
Define_Module_ClassRef(panda3d.core, RenderEffects, RenderEffects_localtype, RenderEffects);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderEffects = &Dtool_RenderEffects;
static void Dtool_PyModuleClassInit_RenderEffects(PyObject *module);
bool Dtool_ConstCoerce_RenderEffects(PyObject *args, CPT(RenderEffects) &coerced);

/**
 * Forward declarations for top-level class PandaNode
 */
typedef PandaNode PandaNode_localtype;
Define_Module_ClassRef(panda3d.core, PandaNode, PandaNode_localtype, PandaNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
static void Dtool_PyModuleClassInit_PandaNode(PyObject *module);

/**
 * Forward declarations for top-level class PandaNode_Children
 */
typedef PandaNode::Children PandaNode_Children_localtype;
Define_Module_Class(panda3d.core, PandaNode_Children, PandaNode_Children_localtype, Children);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode_Children = &Dtool_PandaNode_Children;
static void Dtool_PyModuleClassInit_PandaNode_Children(PyObject *module);

/**
 * Forward declarations for top-level class PandaNode_Stashed
 */
typedef PandaNode::Stashed PandaNode_Stashed_localtype;
Define_Module_Class(panda3d.core, PandaNode_Stashed, PandaNode_Stashed_localtype, Stashed);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode_Stashed = &Dtool_PandaNode_Stashed;
static void Dtool_PyModuleClassInit_PandaNode_Stashed(PyObject *module);

/**
 * Forward declarations for top-level class PandaNode_Parents
 */
typedef PandaNode::Parents PandaNode_Parents_localtype;
Define_Module_Class(panda3d.core, PandaNode_Parents, PandaNode_Parents_localtype, Parents);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode_Parents = &Dtool_PandaNode_Parents;
static void Dtool_PyModuleClassInit_PandaNode_Parents(PyObject *module);

/**
 * Forward declarations for top-level class TransparencyAttrib
 */
typedef TransparencyAttrib TransparencyAttrib_localtype;
Define_Module_ClassRef(panda3d.core, TransparencyAttrib, TransparencyAttrib_localtype, TransparencyAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransparencyAttrib = &Dtool_TransparencyAttrib;
static void Dtool_PyModuleClassInit_TransparencyAttrib(PyObject *module);
bool Dtool_ConstCoerce_TransparencyAttrib(PyObject *args, CPT(TransparencyAttrib) &coerced);

/**
 * Forward declarations for top-level class LogicOpAttrib
 */
typedef LogicOpAttrib LogicOpAttrib_localtype;
Define_Module_ClassRef(panda3d.core, LogicOpAttrib, LogicOpAttrib_localtype, LogicOpAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LogicOpAttrib = &Dtool_LogicOpAttrib;
static void Dtool_PyModuleClassInit_LogicOpAttrib(PyObject *module);
bool Dtool_ConstCoerce_LogicOpAttrib(PyObject *args, CPT(LogicOpAttrib) &coerced);

/**
 * Forward declarations for top-level class ShaderInput
 */
typedef ShaderInput ShaderInput_localtype;
Define_Module_Class(panda3d.core, ShaderInput, ShaderInput_localtype, ShaderInput);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderInput = &Dtool_ShaderInput;
static void Dtool_PyModuleClassInit_ShaderInput(PyObject *module);

/**
 * Forward declarations for top-level class InternalNameCollection
 */
typedef InternalNameCollection InternalNameCollection_localtype;
Define_Module_Class(panda3d.core, InternalNameCollection, InternalNameCollection_localtype, InternalNameCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InternalNameCollection = &Dtool_InternalNameCollection;
static void Dtool_PyModuleClassInit_InternalNameCollection(PyObject *module);

/**
 * Forward declarations for top-level class MaterialCollection
 */
typedef MaterialCollection MaterialCollection_localtype;
Define_Module_Class(panda3d.core, MaterialCollection, MaterialCollection_localtype, MaterialCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MaterialCollection = &Dtool_MaterialCollection;
static void Dtool_PyModuleClassInit_MaterialCollection(PyObject *module);

/**
 * Forward declarations for top-level class TextureStageCollection
 */
typedef TextureStageCollection TextureStageCollection_localtype;
Define_Module_Class(panda3d.core, TextureStageCollection, TextureStageCollection_localtype, TextureStageCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStageCollection = &Dtool_TextureStageCollection;
static void Dtool_PyModuleClassInit_TextureStageCollection(PyObject *module);

/**
 * Forward declarations for top-level class NodePath
 */
typedef NodePath NodePath_localtype;
Define_Module_Class(panda3d.core, NodePath, NodePath_localtype, NodePath);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
static void Dtool_PyModuleClassInit_NodePath(PyObject *module);

/**
 * Forward declarations for top-level class NodePathCollection
 */
typedef NodePathCollection NodePathCollection_localtype;
Define_Module_Class(panda3d.core, NodePathCollection, NodePathCollection_localtype, NodePathCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePathCollection = &Dtool_NodePathCollection;
static void Dtool_PyModuleClassInit_NodePathCollection(PyObject *module);
NodePathCollection *Dtool_Coerce_NodePathCollection(PyObject *args, NodePathCollection &coerced);

/**
 * Forward declarations for top-level class AttribNodeRegistry
 */
typedef AttribNodeRegistry AttribNodeRegistry_localtype;
Define_Module_Class(panda3d.core, AttribNodeRegistry, AttribNodeRegistry_localtype, AttribNodeRegistry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AttribNodeRegistry = &Dtool_AttribNodeRegistry;
static void Dtool_PyModuleClassInit_AttribNodeRegistry(PyObject *module);

/**
 * Forward declarations for top-level class AudioVolumeAttrib
 */
typedef AudioVolumeAttrib AudioVolumeAttrib_localtype;
Define_Module_ClassRef(panda3d.core, AudioVolumeAttrib, AudioVolumeAttrib_localtype, AudioVolumeAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioVolumeAttrib = &Dtool_AudioVolumeAttrib;
static void Dtool_PyModuleClassInit_AudioVolumeAttrib(PyObject *module);
bool Dtool_ConstCoerce_AudioVolumeAttrib(PyObject *args, CPT(AudioVolumeAttrib) &coerced);

/**
 * Forward declarations for top-level class AuxBitplaneAttrib
 */
typedef AuxBitplaneAttrib AuxBitplaneAttrib_localtype;
Define_Module_ClassRef(panda3d.core, AuxBitplaneAttrib, AuxBitplaneAttrib_localtype, AuxBitplaneAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AuxBitplaneAttrib = &Dtool_AuxBitplaneAttrib;
static void Dtool_PyModuleClassInit_AuxBitplaneAttrib(PyObject *module);
bool Dtool_ConstCoerce_AuxBitplaneAttrib(PyObject *args, CPT(AuxBitplaneAttrib) &coerced);

/**
 * Forward declarations for top-level class AuxSceneData
 */
typedef AuxSceneData AuxSceneData_localtype;
Define_Module_ClassRef(panda3d.core, AuxSceneData, AuxSceneData_localtype, AuxSceneData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AuxSceneData = &Dtool_AuxSceneData;
static void Dtool_PyModuleClassInit_AuxSceneData(PyObject *module);

/**
 * Forward declarations for top-level class BamFile
 */
typedef BamFile BamFile_localtype;
Define_Module_Class(panda3d.core, BamFile, BamFile_localtype, BamFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamFile = &Dtool_BamFile;
static void Dtool_PyModuleClassInit_BamFile(PyObject *module);

/**
 * Forward declarations for top-level class BillboardEffect
 */
typedef BillboardEffect BillboardEffect_localtype;
Define_Module_ClassRef(panda3d.core, BillboardEffect, BillboardEffect_localtype, BillboardEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BillboardEffect = &Dtool_BillboardEffect;
static void Dtool_PyModuleClassInit_BillboardEffect(PyObject *module);
bool Dtool_ConstCoerce_BillboardEffect(PyObject *args, CPT(BillboardEffect) &coerced);

/**
 * Forward declarations for top-level class LensNode
 */
typedef LensNode LensNode_localtype;
Define_Module_ClassRef(panda3d.core, LensNode, LensNode_localtype, LensNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LensNode = &Dtool_LensNode;
static void Dtool_PyModuleClassInit_LensNode(PyObject *module);

/**
 * Forward declarations for top-level class WeakNodePath
 */
typedef WeakNodePath WeakNodePath_localtype;
Define_Module_Class(panda3d.core, WeakNodePath, WeakNodePath_localtype, WeakNodePath);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WeakNodePath = &Dtool_WeakNodePath;
static void Dtool_PyModuleClassInit_WeakNodePath(PyObject *module);

/**
 * Forward declarations for top-level class Camera
 */
typedef Camera Camera_localtype;
Define_Module_ClassRef(panda3d.core, Camera, Camera_localtype, Camera);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Camera = &Dtool_Camera;
static void Dtool_PyModuleClassInit_Camera(PyObject *module);

/**
 * Forward declarations for top-level class PlaneNode
 */
typedef PlaneNode PlaneNode_localtype;
Define_Module_ClassRef(panda3d.core, PlaneNode, PlaneNode_localtype, PlaneNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PlaneNode = &Dtool_PlaneNode;
static void Dtool_PyModuleClassInit_PlaneNode(PyObject *module);

/**
 * Forward declarations for top-level class ClipPlaneAttrib
 */
typedef ClipPlaneAttrib ClipPlaneAttrib_localtype;
Define_Module_ClassRef(panda3d.core, ClipPlaneAttrib, ClipPlaneAttrib_localtype, ClipPlaneAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ClipPlaneAttrib = &Dtool_ClipPlaneAttrib;
static void Dtool_PyModuleClassInit_ClipPlaneAttrib(PyObject *module);
bool Dtool_ConstCoerce_ClipPlaneAttrib(PyObject *args, CPT(ClipPlaneAttrib) &coerced);

/**
 * Forward declarations for top-level class ColorAttrib
 */
typedef ColorAttrib ColorAttrib_localtype;
Define_Module_ClassRef(panda3d.core, ColorAttrib, ColorAttrib_localtype, ColorAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ColorAttrib = &Dtool_ColorAttrib;
static void Dtool_PyModuleClassInit_ColorAttrib(PyObject *module);

/**
 * Forward declarations for top-level class ColorBlendAttrib
 */
typedef ColorBlendAttrib ColorBlendAttrib_localtype;
Define_Module_ClassRef(panda3d.core, ColorBlendAttrib, ColorBlendAttrib_localtype, ColorBlendAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ColorBlendAttrib = &Dtool_ColorBlendAttrib;
static void Dtool_PyModuleClassInit_ColorBlendAttrib(PyObject *module);
bool Dtool_ConstCoerce_ColorBlendAttrib(PyObject *args, CPT(ColorBlendAttrib) &coerced);

/**
 * Forward declarations for top-level class ColorScaleAttrib
 */
typedef ColorScaleAttrib ColorScaleAttrib_localtype;
Define_Module_ClassRef(panda3d.core, ColorScaleAttrib, ColorScaleAttrib_localtype, ColorScaleAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ColorScaleAttrib = &Dtool_ColorScaleAttrib;
static void Dtool_PyModuleClassInit_ColorScaleAttrib(PyObject *module);
bool Dtool_ConstCoerce_ColorScaleAttrib(PyObject *args, CPT(ColorScaleAttrib) &coerced);

/**
 * Forward declarations for top-level class ColorWriteAttrib
 */
typedef ColorWriteAttrib ColorWriteAttrib_localtype;
Define_Module_ClassRef(panda3d.core, ColorWriteAttrib, ColorWriteAttrib_localtype, ColorWriteAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ColorWriteAttrib = &Dtool_ColorWriteAttrib;
static void Dtool_PyModuleClassInit_ColorWriteAttrib(PyObject *module);
bool Dtool_ConstCoerce_ColorWriteAttrib(PyObject *args, CPT(ColorWriteAttrib) &coerced);

/**
 * Forward declarations for top-level class CompassEffect
 */
typedef CompassEffect CompassEffect_localtype;
Define_Module_ClassRef(panda3d.core, CompassEffect, CompassEffect_localtype, CompassEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CompassEffect = &Dtool_CompassEffect;
static void Dtool_PyModuleClassInit_CompassEffect(PyObject *module);
bool Dtool_ConstCoerce_CompassEffect(PyObject *args, CPT(CompassEffect) &coerced);

/**
 * Forward declarations for top-level class CullBinEnums
 */
typedef CullBinEnums CullBinEnums_localtype;
Define_Module_Class(panda3d.core, CullBinEnums, CullBinEnums_localtype, CullBinEnums);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullBinEnums = &Dtool_CullBinEnums;
static void Dtool_PyModuleClassInit_CullBinEnums(PyObject *module);

/**
 * Forward declarations for top-level class GeomNode
 */
typedef GeomNode GeomNode_localtype;
Define_Module_ClassRef(panda3d.core, GeomNode, GeomNode_localtype, GeomNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomNode = &Dtool_GeomNode;
static void Dtool_PyModuleClassInit_GeomNode(PyObject *module);

/**
 * Forward declarations for top-level class CullBinAttrib
 */
typedef CullBinAttrib CullBinAttrib_localtype;
Define_Module_ClassRef(panda3d.core, CullBinAttrib, CullBinAttrib_localtype, CullBinAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullBinAttrib = &Dtool_CullBinAttrib;
static void Dtool_PyModuleClassInit_CullBinAttrib(PyObject *module);
bool Dtool_ConstCoerce_CullBinAttrib(PyObject *args, CPT(CullBinAttrib) &coerced);

/**
 * Forward declarations for top-level class CullBinManager
 */
typedef CullBinManager CullBinManager_localtype;
Define_Module_Class_Private(panda3d.core, CullBinManager, CullBinManager_localtype, CullBinManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullBinManager = &Dtool_CullBinManager;
static void Dtool_PyModuleClassInit_CullBinManager(PyObject *module);

/**
 * Forward declarations for top-level class CullFaceAttrib
 */
typedef CullFaceAttrib CullFaceAttrib_localtype;
Define_Module_ClassRef(panda3d.core, CullFaceAttrib, CullFaceAttrib_localtype, CullFaceAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullFaceAttrib = &Dtool_CullFaceAttrib;
static void Dtool_PyModuleClassInit_CullFaceAttrib(PyObject *module);
bool Dtool_ConstCoerce_CullFaceAttrib(PyObject *args, CPT(CullFaceAttrib) &coerced);

/**
 * Forward declarations for top-level class WorkingNodePath
 */
typedef WorkingNodePath WorkingNodePath_localtype;
Define_Module_Class(panda3d.core, WorkingNodePath, WorkingNodePath_localtype, WorkingNodePath);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WorkingNodePath = &Dtool_WorkingNodePath;
static void Dtool_PyModuleClassInit_WorkingNodePath(PyObject *module);

/**
 * Forward declarations for top-level class CullTraverserData
 */
typedef CullTraverserData CullTraverserData_localtype;
Define_Module_Class(panda3d.core, CullTraverserData, CullTraverserData_localtype, CullTraverserData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullTraverserData = &Dtool_CullTraverserData;
static void Dtool_PyModuleClassInit_CullTraverserData(PyObject *module);

/**
 * Forward declarations for top-level class SceneSetup
 */
typedef SceneSetup SceneSetup_localtype;
Define_Module_ClassRef(panda3d.core, SceneSetup, SceneSetup_localtype, SceneSetup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SceneSetup = &Dtool_SceneSetup;
static void Dtool_PyModuleClassInit_SceneSetup(PyObject *module);

/**
 * Forward declarations for top-level class Fog
 */
typedef Fog Fog_localtype;
Define_Module_ClassRef(panda3d.core, Fog, Fog_localtype, Fog);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Fog = &Dtool_Fog;
static void Dtool_PyModuleClassInit_Fog(PyObject *module);

/**
 * Forward declarations for top-level class FogAttrib
 */
typedef FogAttrib FogAttrib_localtype;
Define_Module_ClassRef(panda3d.core, FogAttrib, FogAttrib_localtype, FogAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FogAttrib = &Dtool_FogAttrib;
static void Dtool_PyModuleClassInit_FogAttrib(PyObject *module);
bool Dtool_ConstCoerce_FogAttrib(PyObject *args, CPT(FogAttrib) &coerced);

/**
 * Forward declarations for top-level class CullTraverser
 */
typedef CullTraverser CullTraverser_localtype;
Define_Module_ClassRef(panda3d.core, CullTraverser, CullTraverser_localtype, CullTraverser);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullTraverser = &Dtool_CullTraverser;
static void Dtool_PyModuleClassInit_CullTraverser(PyObject *module);

/**
 * Forward declarations for top-level class GeomDrawCallbackData
 */
typedef GeomDrawCallbackData GeomDrawCallbackData_localtype;
Define_Module_Class(panda3d.core, GeomDrawCallbackData, GeomDrawCallbackData_localtype, GeomDrawCallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomDrawCallbackData = &Dtool_GeomDrawCallbackData;
static void Dtool_PyModuleClassInit_GeomDrawCallbackData(PyObject *module);

/**
 * Forward declarations for top-level class RescaleNormalAttrib
 */
typedef RescaleNormalAttrib RescaleNormalAttrib_localtype;
Define_Module_ClassRef(panda3d.core, RescaleNormalAttrib, RescaleNormalAttrib_localtype, RescaleNormalAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RescaleNormalAttrib = &Dtool_RescaleNormalAttrib;
static void Dtool_PyModuleClassInit_RescaleNormalAttrib(PyObject *module);
bool Dtool_ConstCoerce_RescaleNormalAttrib(PyObject *args, CPT(RescaleNormalAttrib) &coerced);

/**
 * Forward declarations for top-level class CullResult
 */
typedef CullResult CullResult_localtype;
Define_Module_ClassRef(panda3d.core, CullResult, CullResult_localtype, CullResult);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullResult = &Dtool_CullResult;
static void Dtool_PyModuleClassInit_CullResult(PyObject *module);

/**
 * Forward declarations for top-level class DecalEffect
 */
typedef DecalEffect DecalEffect_localtype;
Define_Module_ClassRef(panda3d.core, DecalEffect, DecalEffect_localtype, DecalEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DecalEffect = &Dtool_DecalEffect;
static void Dtool_PyModuleClassInit_DecalEffect(PyObject *module);

/**
 * Forward declarations for top-level class DepthOffsetAttrib
 */
typedef DepthOffsetAttrib DepthOffsetAttrib_localtype;
Define_Module_ClassRef(panda3d.core, DepthOffsetAttrib, DepthOffsetAttrib_localtype, DepthOffsetAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DepthOffsetAttrib = &Dtool_DepthOffsetAttrib;
static void Dtool_PyModuleClassInit_DepthOffsetAttrib(PyObject *module);
bool Dtool_ConstCoerce_DepthOffsetAttrib(PyObject *args, CPT(DepthOffsetAttrib) &coerced);

/**
 * Forward declarations for top-level class DepthTestAttrib
 */
typedef DepthTestAttrib DepthTestAttrib_localtype;
Define_Module_ClassRef(panda3d.core, DepthTestAttrib, DepthTestAttrib_localtype, DepthTestAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DepthTestAttrib = &Dtool_DepthTestAttrib;
static void Dtool_PyModuleClassInit_DepthTestAttrib(PyObject *module);
bool Dtool_ConstCoerce_DepthTestAttrib(PyObject *args, CPT(DepthTestAttrib) &coerced);

/**
 * Forward declarations for top-level class DepthWriteAttrib
 */
typedef DepthWriteAttrib DepthWriteAttrib_localtype;
Define_Module_ClassRef(panda3d.core, DepthWriteAttrib, DepthWriteAttrib_localtype, DepthWriteAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DepthWriteAttrib = &Dtool_DepthWriteAttrib;
static void Dtool_PyModuleClassInit_DepthWriteAttrib(PyObject *module);
bool Dtool_ConstCoerce_DepthWriteAttrib(PyObject *args, CPT(DepthWriteAttrib) &coerced);

/**
 * Forward declarations for top-level class Light
 */
typedef Light Light_localtype;
Define_Module_Class(panda3d.core, Light, Light_localtype, Light);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Light = &Dtool_Light;
static void Dtool_PyModuleClassInit_Light(PyObject *module);

/**
 * Forward declarations for top-level class LightAttrib
 */
typedef LightAttrib LightAttrib_localtype;
Define_Module_ClassRef(panda3d.core, LightAttrib, LightAttrib_localtype, LightAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightAttrib = &Dtool_LightAttrib;
static void Dtool_PyModuleClassInit_LightAttrib(PyObject *module);
bool Dtool_ConstCoerce_LightAttrib(PyObject *args, CPT(LightAttrib) &coerced);

/**
 * Forward declarations for top-level class LightRampAttrib
 */
typedef LightRampAttrib LightRampAttrib_localtype;
Define_Module_ClassRef(panda3d.core, LightRampAttrib, LightRampAttrib_localtype, LightRampAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightRampAttrib = &Dtool_LightRampAttrib;
static void Dtool_PyModuleClassInit_LightRampAttrib(PyObject *module);

/**
 * Forward declarations for top-level class Loader
 */
typedef Loader Loader_localtype;
Define_Module_ClassRef(panda3d.core, Loader, Loader_localtype, Loader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Loader = &Dtool_Loader;
static void Dtool_PyModuleClassInit_Loader(PyObject *module);

/**
 * Forward declarations for top-level class Loader_Results
 */
typedef Loader::Results Loader_Results_localtype;
Define_Module_Class(panda3d.core, Loader_Results, Loader_Results_localtype, Results);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Loader_Results = &Dtool_Loader_Results;
static void Dtool_PyModuleClassInit_Loader_Results(PyObject *module);

/**
 * Forward declarations for top-level class LoaderFileType
 */
typedef LoaderFileType LoaderFileType_localtype;
Define_Module_Class(panda3d.core, LoaderFileType, LoaderFileType_localtype, LoaderFileType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LoaderFileType = &Dtool_LoaderFileType;
static void Dtool_PyModuleClassInit_LoaderFileType(PyObject *module);

/**
 * Forward declarations for top-level class LoaderFileTypeRegistry
 */
typedef LoaderFileTypeRegistry LoaderFileTypeRegistry_localtype;
Define_Module_Class(panda3d.core, LoaderFileTypeRegistry, LoaderFileTypeRegistry_localtype, LoaderFileTypeRegistry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LoaderFileTypeRegistry = &Dtool_LoaderFileTypeRegistry;
static void Dtool_PyModuleClassInit_LoaderFileTypeRegistry(PyObject *module);

/**
 * Forward declarations for top-level class MaterialAttrib
 */
typedef MaterialAttrib MaterialAttrib_localtype;
Define_Module_ClassRef(panda3d.core, MaterialAttrib, MaterialAttrib_localtype, MaterialAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MaterialAttrib = &Dtool_MaterialAttrib;
static void Dtool_PyModuleClassInit_MaterialAttrib(PyObject *module);
bool Dtool_ConstCoerce_MaterialAttrib(PyObject *args, CPT(MaterialAttrib) &coerced);

/**
 * Forward declarations for top-level class ModelFlattenRequest
 */
typedef ModelFlattenRequest ModelFlattenRequest_localtype;
Define_Module_ClassRef(panda3d.core, ModelFlattenRequest, ModelFlattenRequest_localtype, ModelFlattenRequest);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelFlattenRequest = &Dtool_ModelFlattenRequest;
static void Dtool_PyModuleClassInit_ModelFlattenRequest(PyObject *module);

/**
 * Forward declarations for top-level class ModelLoadRequest
 */
typedef ModelLoadRequest ModelLoadRequest_localtype;
Define_Module_ClassRef(panda3d.core, ModelLoadRequest, ModelLoadRequest_localtype, ModelLoadRequest);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelLoadRequest = &Dtool_ModelLoadRequest;
static void Dtool_PyModuleClassInit_ModelLoadRequest(PyObject *module);

/**
 * Forward declarations for top-level class ModelNode
 */
typedef ModelNode ModelNode_localtype;
Define_Module_ClassRef(panda3d.core, ModelNode, ModelNode_localtype, ModelNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelNode = &Dtool_ModelNode;
static void Dtool_PyModuleClassInit_ModelNode(PyObject *module);

/**
 * Forward declarations for top-level class ModelRoot
 */
typedef ModelRoot ModelRoot_localtype;
Define_Module_ClassRef(panda3d.core, ModelRoot, ModelRoot_localtype, ModelRoot);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelRoot = &Dtool_ModelRoot;
static void Dtool_PyModuleClassInit_ModelRoot(PyObject *module);

/**
 * Forward declarations for top-level class ModelRoot_ModelReference
 */
typedef ModelRoot::ModelReference ModelRoot_ModelReference_localtype;
Define_Module_ClassRef(panda3d.core, ModelRoot_ModelReference, ModelRoot_ModelReference_localtype, ModelReference);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelRoot_ModelReference = &Dtool_ModelRoot_ModelReference;
static void Dtool_PyModuleClassInit_ModelRoot_ModelReference(PyObject *module);

/**
 * Forward declarations for top-level class ModelPool
 */
typedef ModelPool ModelPool_localtype;
Define_Module_Class(panda3d.core, ModelPool, ModelPool_localtype, ModelPool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelPool = &Dtool_ModelPool;
static void Dtool_PyModuleClassInit_ModelPool(PyObject *module);

/**
 * Forward declarations for top-level class ModelSaveRequest
 */
typedef ModelSaveRequest ModelSaveRequest_localtype;
Define_Module_ClassRef(panda3d.core, ModelSaveRequest, ModelSaveRequest_localtype, ModelSaveRequest);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelSaveRequest = &Dtool_ModelSaveRequest;
static void Dtool_PyModuleClassInit_ModelSaveRequest(PyObject *module);

/**
 * Forward declarations for top-level class TextureAttrib
 */
typedef TextureAttrib TextureAttrib_localtype;
Define_Module_ClassRef(panda3d.core, TextureAttrib, TextureAttrib_localtype, TextureAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureAttrib = &Dtool_TextureAttrib;
static void Dtool_PyModuleClassInit_TextureAttrib(PyObject *module);
bool Dtool_ConstCoerce_TextureAttrib(PyObject *args, CPT(TextureAttrib) &coerced);

/**
 * Forward declarations for top-level class TexGenAttrib
 */
typedef TexGenAttrib TexGenAttrib_localtype;
Define_Module_ClassRef(panda3d.core, TexGenAttrib, TexGenAttrib_localtype, TexGenAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TexGenAttrib = &Dtool_TexGenAttrib;
static void Dtool_PyModuleClassInit_TexGenAttrib(PyObject *module);
bool Dtool_ConstCoerce_TexGenAttrib(PyObject *args, CPT(TexGenAttrib) &coerced);

/**
 * Forward declarations for top-level class OccluderNode
 */
typedef OccluderNode OccluderNode_localtype;
Define_Module_ClassRef(panda3d.core, OccluderNode, OccluderNode_localtype, OccluderNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OccluderNode = &Dtool_OccluderNode;
static void Dtool_PyModuleClassInit_OccluderNode(PyObject *module);

/**
 * Forward declarations for top-level class OccluderEffect
 */
typedef OccluderEffect OccluderEffect_localtype;
Define_Module_ClassRef(panda3d.core, OccluderEffect, OccluderEffect_localtype, OccluderEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OccluderEffect = &Dtool_OccluderEffect;
static void Dtool_PyModuleClassInit_OccluderEffect(PyObject *module);

/**
 * Forward declarations for top-level class PolylightNode
 */
typedef PolylightNode PolylightNode_localtype;
Define_Module_ClassRef(panda3d.core, PolylightNode, PolylightNode_localtype, PolylightNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PolylightNode = &Dtool_PolylightNode;
static void Dtool_PyModuleClassInit_PolylightNode(PyObject *module);

/**
 * Forward declarations for top-level class PolylightEffect
 */
typedef PolylightEffect PolylightEffect_localtype;
Define_Module_ClassRef(panda3d.core, PolylightEffect, PolylightEffect_localtype, PolylightEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PolylightEffect = &Dtool_PolylightEffect;
static void Dtool_PyModuleClassInit_PolylightEffect(PyObject *module);
bool Dtool_ConstCoerce_PolylightEffect(PyObject *args, CPT(PolylightEffect) &coerced);

/**
 * Forward declarations for top-level class ShaderAttrib
 */
typedef ShaderAttrib ShaderAttrib_localtype;
Define_Module_ClassRef(panda3d.core, ShaderAttrib, ShaderAttrib_localtype, ShaderAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderAttrib = &Dtool_ShaderAttrib;
static void Dtool_PyModuleClassInit_ShaderAttrib(PyObject *module);
bool Dtool_ConstCoerce_ShaderAttrib(PyObject *args, CPT(ShaderAttrib) &coerced);

/**
 * Forward declarations for top-level class ShowBoundsEffect
 */
typedef ShowBoundsEffect ShowBoundsEffect_localtype;
Define_Module_ClassRef(panda3d.core, ShowBoundsEffect, ShowBoundsEffect_localtype, ShowBoundsEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShowBoundsEffect = &Dtool_ShowBoundsEffect;
static void Dtool_PyModuleClassInit_ShowBoundsEffect(PyObject *module);
bool Dtool_ConstCoerce_ShowBoundsEffect(PyObject *args, CPT(ShowBoundsEffect) &coerced);

/**
 * Forward declarations for top-level class TexProjectorEffect
 */
typedef TexProjectorEffect TexProjectorEffect_localtype;
Define_Module_ClassRef(panda3d.core, TexProjectorEffect, TexProjectorEffect_localtype, TexProjectorEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TexProjectorEffect = &Dtool_TexProjectorEffect;
static void Dtool_PyModuleClassInit_TexProjectorEffect(PyObject *module);

/**
 * Forward declarations for top-level class ScissorEffect
 */
typedef ScissorEffect ScissorEffect_localtype;
Define_Module_ClassRef(panda3d.core, ScissorEffect, ScissorEffect_localtype, ScissorEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ScissorEffect = &Dtool_ScissorEffect;
static void Dtool_PyModuleClassInit_ScissorEffect(PyObject *module);

/**
 * Forward declarations for top-level class SceneGraphReducer
 */
typedef SceneGraphReducer SceneGraphReducer_localtype;
Define_Module_Class(panda3d.core, SceneGraphReducer, SceneGraphReducer_localtype, SceneGraphReducer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SceneGraphReducer = &Dtool_SceneGraphReducer;
static void Dtool_PyModuleClassInit_SceneGraphReducer(PyObject *module);

/**
 * Forward declarations for top-level class ParamNodePath
 */
typedef ParamNodePath ParamNodePath_localtype;
Define_Module_ClassRef(panda3d.core, ParamNodePath, ParamNodePath_localtype, ParamNodePath);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamNodePath = &Dtool_ParamNodePath;
static void Dtool_PyModuleClassInit_ParamNodePath(PyObject *module);
bool Dtool_ConstCoerce_ParamNodePath(PyObject *args, CPT(ParamNodePath) &coerced);
bool Dtool_Coerce_ParamNodePath(PyObject *args, PT(ParamNodePath) &coerced);

/**
 * Forward declarations for top-level class PortalNode
 */
typedef PortalNode PortalNode_localtype;
Define_Module_ClassRef(panda3d.core, PortalNode, PortalNode_localtype, PortalNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PortalNode = &Dtool_PortalNode;
static void Dtool_PyModuleClassInit_PortalNode(PyObject *module);

/**
 * Forward declarations for top-level class ScissorAttrib
 */
typedef ScissorAttrib ScissorAttrib_localtype;
Define_Module_ClassRef(panda3d.core, ScissorAttrib, ScissorAttrib_localtype, ScissorAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ScissorAttrib = &Dtool_ScissorAttrib;
static void Dtool_PyModuleClassInit_ScissorAttrib(PyObject *module);
bool Dtool_ConstCoerce_ScissorAttrib(PyObject *args, CPT(ScissorAttrib) &coerced);

/**
 * Forward declarations for top-level class ShadeModelAttrib
 */
typedef ShadeModelAttrib ShadeModelAttrib_localtype;
Define_Module_ClassRef(panda3d.core, ShadeModelAttrib, ShadeModelAttrib_localtype, ShadeModelAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShadeModelAttrib = &Dtool_ShadeModelAttrib;
static void Dtool_PyModuleClassInit_ShadeModelAttrib(PyObject *module);
bool Dtool_ConstCoerce_ShadeModelAttrib(PyObject *args, CPT(ShadeModelAttrib) &coerced);

/**
 * Forward declarations for top-level class StencilAttrib
 */
typedef StencilAttrib StencilAttrib_localtype;
Define_Module_ClassRef(panda3d.core, StencilAttrib, StencilAttrib_localtype, StencilAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StencilAttrib = &Dtool_StencilAttrib;
static void Dtool_PyModuleClassInit_StencilAttrib(PyObject *module);
bool Dtool_ConstCoerce_StencilAttrib(PyObject *args, CPT(StencilAttrib) &coerced);

/**
 * Forward declarations for top-level class ShaderPool
 */
typedef ShaderPool ShaderPool_localtype;
Define_Module_Class(panda3d.core, ShaderPool, ShaderPool_localtype, ShaderPool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderPool = &Dtool_ShaderPool;
static void Dtool_PyModuleClassInit_ShaderPool(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"TransformState", &Dtool_TransformState},
  {"RenderAttribRegistry", &Dtool_RenderAttribRegistry},
  {"RenderAttrib", &Dtool_RenderAttrib},
  {"RenderModeAttrib", &Dtool_RenderModeAttrib},
  {"TexMatrixAttrib", &Dtool_TexMatrixAttrib},
  {"RenderState", &Dtool_RenderState},
  {"AlphaTestAttrib", &Dtool_AlphaTestAttrib},
  {"AntialiasAttrib", &Dtool_AntialiasAttrib},
  {"RenderEffect", &Dtool_RenderEffect},
  {"RenderEffects", &Dtool_RenderEffects},
  {"PandaNode", &Dtool_PandaNode},
  {"PandaNode::Children", &Dtool_PandaNode_Children},
  {"PandaNode::Stashed", &Dtool_PandaNode_Stashed},
  {"PandaNode::Parents", &Dtool_PandaNode_Parents},
  {"TransparencyAttrib", &Dtool_TransparencyAttrib},
  {"LogicOpAttrib", &Dtool_LogicOpAttrib},
  {"ShaderInput", &Dtool_ShaderInput},
  {"InternalNameCollection", &Dtool_InternalNameCollection},
  {"MaterialCollection", &Dtool_MaterialCollection},
  {"TextureStageCollection", &Dtool_TextureStageCollection},
  {"NodePath", &Dtool_NodePath},
  {"NodePathCollection", &Dtool_NodePathCollection},
  {"AttribNodeRegistry", &Dtool_AttribNodeRegistry},
  {"AudioVolumeAttrib", &Dtool_AudioVolumeAttrib},
  {"AuxBitplaneAttrib", &Dtool_AuxBitplaneAttrib},
  {"AuxSceneData", &Dtool_AuxSceneData},
  {"BamFile", &Dtool_BamFile},
  {"BillboardEffect", &Dtool_BillboardEffect},
  {"LensNode", &Dtool_LensNode},
  {"WeakNodePath", &Dtool_WeakNodePath},
  {"Camera", &Dtool_Camera},
  {"PlaneNode", &Dtool_PlaneNode},
  {"ClipPlaneAttrib", &Dtool_ClipPlaneAttrib},
  {"ColorAttrib", &Dtool_ColorAttrib},
  {"ColorBlendAttrib", &Dtool_ColorBlendAttrib},
  {"ColorScaleAttrib", &Dtool_ColorScaleAttrib},
  {"ColorWriteAttrib", &Dtool_ColorWriteAttrib},
  {"CompassEffect", &Dtool_CompassEffect},
  {"CullBinEnums", &Dtool_CullBinEnums},
  {"GeomNode", &Dtool_GeomNode},
  {"CullBinAttrib", &Dtool_CullBinAttrib},
  {"CullBinManager", &Dtool_CullBinManager},
  {"CullFaceAttrib", &Dtool_CullFaceAttrib},
  {"WorkingNodePath", &Dtool_WorkingNodePath},
  {"CullTraverserData", &Dtool_CullTraverserData},
  {"SceneSetup", &Dtool_SceneSetup},
  {"Fog", &Dtool_Fog},
  {"FogAttrib", &Dtool_FogAttrib},
  {"CullTraverser", &Dtool_CullTraverser},
  {"GeomDrawCallbackData", &Dtool_GeomDrawCallbackData},
  {"RescaleNormalAttrib", &Dtool_RescaleNormalAttrib},
  {"CullResult", &Dtool_CullResult},
  {"DecalEffect", &Dtool_DecalEffect},
  {"DepthOffsetAttrib", &Dtool_DepthOffsetAttrib},
  {"DepthTestAttrib", &Dtool_DepthTestAttrib},
  {"DepthWriteAttrib", &Dtool_DepthWriteAttrib},
  {"Light", &Dtool_Light},
  {"LightAttrib", &Dtool_LightAttrib},
  {"LightRampAttrib", &Dtool_LightRampAttrib},
  {"Loader", &Dtool_Loader},
  {"Loader::Results", &Dtool_Loader_Results},
  {"LoaderFileType", &Dtool_LoaderFileType},
  {"LoaderFileTypeRegistry", &Dtool_LoaderFileTypeRegistry},
  {"MaterialAttrib", &Dtool_MaterialAttrib},
  {"ModelFlattenRequest", &Dtool_ModelFlattenRequest},
  {"ModelLoadRequest", &Dtool_ModelLoadRequest},
  {"ModelNode", &Dtool_ModelNode},
  {"ModelRoot", &Dtool_ModelRoot},
  {"ModelRoot::ModelReference", &Dtool_ModelRoot_ModelReference},
  {"ModelPool", &Dtool_ModelPool},
  {"ModelSaveRequest", &Dtool_ModelSaveRequest},
  {"TextureAttrib", &Dtool_TextureAttrib},
  {"TexGenAttrib", &Dtool_TexGenAttrib},
  {"OccluderNode", &Dtool_OccluderNode},
  {"OccluderEffect", &Dtool_OccluderEffect},
  {"PolylightNode", &Dtool_PolylightNode},
  {"PolylightEffect", &Dtool_PolylightEffect},
  {"ShaderAttrib", &Dtool_ShaderAttrib},
  {"ShowBoundsEffect", &Dtool_ShowBoundsEffect},
  {"TexProjectorEffect", &Dtool_TexProjectorEffect},
  {"ScissorEffect", &Dtool_ScissorEffect},
  {"SceneGraphReducer", &Dtool_SceneGraphReducer},
  {"ParamNodePath", &Dtool_ParamNodePath},
  {"PortalNode", &Dtool_PortalNode},
  {"ScissorAttrib", &Dtool_ScissorAttrib},
  {"ShadeModelAttrib", &Dtool_ShadeModelAttrib},
  {"StencilAttrib", &Dtool_StencilAttrib},
  {"ShaderPool", &Dtool_ShaderPool},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"std::istream", nullptr},
#define Dtool_Ptr_std_istream (imports[1].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[2].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[3].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[4].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[5].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[6].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[7].type)
  {"Thread", nullptr},
#define Dtool_Ptr_Thread (imports[8].type)
  {"UpdateSeq", nullptr},
#define Dtool_Ptr_UpdateSeq (imports[9].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[10].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[11].type)
  {"CachedTypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_CachedTypedWritableReferenceCount (imports[12].type)
  {"NodeCachedReferenceCount", nullptr},
#define Dtool_Ptr_NodeCachedReferenceCount (imports[13].type)
  {"LVecBase2f", nullptr},
#define Dtool_Ptr_LVecBase2f (imports[14].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[15].type)
  {"LVector3f", nullptr},
#define Dtool_Ptr_LVector3f (imports[16].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[17].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[18].type)
  {"LMatrix3f", nullptr},
#define Dtool_Ptr_LMatrix3f (imports[19].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[20].type)
  {"LQuaternionf", nullptr},
#define Dtool_Ptr_LQuaternionf (imports[21].type)
  {"BitMask< uint32_t, 32 >", nullptr},
#define Dtool_Ptr_BitMask_uint32_t_32 (imports[22].type)
  {"BamEnums", nullptr},
#define Dtool_Ptr_BamEnums (imports[23].type)
  {"InternalName", nullptr},
#define Dtool_Ptr_InternalName (imports[24].type)
  {"LoaderOptions", nullptr},
#define Dtool_Ptr_LoaderOptions (imports[25].type)
  {"BamReader", nullptr},
#define Dtool_Ptr_BamReader (imports[26].type)
  {"GraphicsStateGuardianBase", nullptr},
#define Dtool_Ptr_GraphicsStateGuardianBase (imports[27].type)
  {"DisplayRegion", nullptr},
#define Dtool_Ptr_DisplayRegion (imports[28].type)
  {"TextureStage", nullptr},
#define Dtool_Ptr_TextureStage (imports[29].type)
  {"BoundingVolume", nullptr},
#define Dtool_Ptr_BoundingVolume (imports[30].type)
  {"Geom", nullptr},
#define Dtool_Ptr_Geom (imports[31].type)
  {"BamWriter", nullptr},
#define Dtool_Ptr_BamWriter (imports[32].type)
  {"ParamValueBase", nullptr},
#define Dtool_Ptr_ParamValueBase (imports[33].type)
  {"SamplerState", nullptr},
#define Dtool_Ptr_SamplerState (imports[34].type)
  {"AsyncFuture", nullptr},
#define Dtool_Ptr_AsyncFuture (imports[35].type)
  {"Shader", nullptr},
#define Dtool_Ptr_Shader (imports[36].type)
  {"GeometricBoundingVolume", nullptr},
#define Dtool_Ptr_GeometricBoundingVolume (imports[37].type)
  {"LPlanef", nullptr},
#define Dtool_Ptr_LPlanef (imports[38].type)
  {"Texture", nullptr},
#define Dtool_Ptr_Texture (imports[39].type)
  {"ShaderBuffer", nullptr},
#define Dtool_Ptr_ShaderBuffer (imports[40].type)
  {"Material", nullptr},
#define Dtool_Ptr_Material (imports[41].type)
  {"TextureCollection", nullptr},
#define Dtool_Ptr_TextureCollection (imports[42].type)
  {"Lens", nullptr},
#define Dtool_Ptr_Lens (imports[43].type)
  {"CallbackData", nullptr},
#define Dtool_Ptr_CallbackData (imports[44].type)
  {"AsyncTask", nullptr},
#define Dtool_Ptr_AsyncTask (imports[45].type)
  {"AsyncTaskManager", nullptr},
#define Dtool_Ptr_AsyncTaskManager (imports[46].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// std::istream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_istream = &Dtool_std_istream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// Thread
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Thread;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Thread = &Dtool_Thread;
#endif
// UpdateSeq
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_UpdateSeq;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UpdateSeq = &Dtool_UpdateSeq;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// CachedTypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CachedTypedWritableReferenceCount = &Dtool_CachedTypedWritableReferenceCount;
#endif
// NodeCachedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodeCachedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodeCachedReferenceCount = &Dtool_NodeCachedReferenceCount;
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LMatrix3f
#ifndef LINK_ALL_STATIC
inline static LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced) {
  nassertr(Dtool_Ptr_LMatrix3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix3f *(*)(PyObject *, LMatrix3f &))Dtool_Ptr_LMatrix3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f = &Dtool_LMatrix3f;
extern LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LQuaternionf
#ifndef LINK_ALL_STATIC
inline static LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced) {
  nassertr(Dtool_Ptr_LQuaternionf != nullptr, nullptr);
  nassertr(Dtool_Ptr_LQuaternionf->_Dtool_Coerce != nullptr, nullptr);
  return ((LQuaternionf *(*)(PyObject *, LQuaternionf &))Dtool_Ptr_LQuaternionf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaternionf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaternionf = &Dtool_LQuaternionf;
extern LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced);
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != nullptr, nullptr);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != nullptr, nullptr);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif
// BamEnums
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BamEnums;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamEnums = &Dtool_BamEnums;
#endif
// InternalName
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_InternalName(PyObject *args, CPT(InternalName) &coerced) {
  nassertr(Dtool_Ptr_InternalName != nullptr, false);
  nassertr(Dtool_Ptr_InternalName->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(InternalName) &))Dtool_Ptr_InternalName->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_InternalName(PyObject *args, PT(InternalName) &coerced) {
  nassertr(Dtool_Ptr_InternalName != nullptr, false);
  nassertr(Dtool_Ptr_InternalName->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(InternalName) &))Dtool_Ptr_InternalName->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_InternalName;
static struct Dtool_PyTypedObject *const Dtool_Ptr_InternalName = &Dtool_InternalName;
extern bool Dtool_ConstCoerce_InternalName(PyObject *args, CPT(InternalName) &coerced);
extern bool Dtool_Coerce_InternalName(PyObject *args, PT(InternalName) &coerced);
#endif
// LoaderOptions
#ifndef LINK_ALL_STATIC
inline static LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced) {
  nassertr(Dtool_Ptr_LoaderOptions != nullptr, nullptr);
  nassertr(Dtool_Ptr_LoaderOptions->_Dtool_Coerce != nullptr, nullptr);
  return ((LoaderOptions *(*)(PyObject *, LoaderOptions &))Dtool_Ptr_LoaderOptions->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LoaderOptions;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LoaderOptions = &Dtool_LoaderOptions;
extern LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced);
#endif
// BamReader
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BamReader;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamReader = &Dtool_BamReader;
#endif
// GraphicsStateGuardianBase
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsStateGuardianBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardianBase = &Dtool_GraphicsStateGuardianBase;
#endif
// DisplayRegion
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DisplayRegion;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayRegion = &Dtool_DisplayRegion;
#endif
// TextureStage
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TextureStage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStage = &Dtool_TextureStage;
#endif
// BoundingVolume
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BoundingVolume;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingVolume = &Dtool_BoundingVolume;
#endif
// Geom
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Geom;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Geom = &Dtool_Geom;
#endif
// BamWriter
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BamWriter;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamWriter = &Dtool_BamWriter;
#endif
// ParamValueBase
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ParamValueBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValueBase = &Dtool_ParamValueBase;
#endif
// SamplerState
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_SamplerState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_SamplerState = &Dtool_SamplerState;
#endif
// AsyncFuture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AsyncFuture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncFuture = &Dtool_AsyncFuture;
#endif
// Shader
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_Shader(PyObject *args, CPT(Shader) &coerced) {
  nassertr(Dtool_Ptr_Shader != nullptr, false);
  nassertr(Dtool_Ptr_Shader->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(Shader) &))Dtool_Ptr_Shader->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_Shader(PyObject *args, PT(Shader) &coerced) {
  nassertr(Dtool_Ptr_Shader != nullptr, false);
  nassertr(Dtool_Ptr_Shader->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(Shader) &))Dtool_Ptr_Shader->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Shader;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Shader = &Dtool_Shader;
extern bool Dtool_ConstCoerce_Shader(PyObject *args, CPT(Shader) &coerced);
extern bool Dtool_Coerce_Shader(PyObject *args, PT(Shader) &coerced);
#endif
// GeometricBoundingVolume
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GeometricBoundingVolume;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeometricBoundingVolume = &Dtool_GeometricBoundingVolume;
#endif
// LPlanef
#ifndef LINK_ALL_STATIC
inline static LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced) {
  nassertr(Dtool_Ptr_LPlanef != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPlanef->_Dtool_Coerce != nullptr, nullptr);
  return ((LPlanef *(*)(PyObject *, LPlanef &))Dtool_Ptr_LPlanef->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPlanef;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPlanef = &Dtool_LPlanef;
extern LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced);
#endif
// Texture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// ShaderBuffer
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ShaderBuffer;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderBuffer = &Dtool_ShaderBuffer;
#endif
// Material
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Material;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Material = &Dtool_Material;
#endif
// TextureCollection
#ifndef LINK_ALL_STATIC
inline static TextureCollection *Dtool_Coerce_TextureCollection(PyObject *args, TextureCollection &coerced) {
  nassertr(Dtool_Ptr_TextureCollection != nullptr, nullptr);
  nassertr(Dtool_Ptr_TextureCollection->_Dtool_Coerce != nullptr, nullptr);
  return ((TextureCollection *(*)(PyObject *, TextureCollection &))Dtool_Ptr_TextureCollection->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TextureCollection;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureCollection = &Dtool_TextureCollection;
extern TextureCollection *Dtool_Coerce_TextureCollection(PyObject *args, TextureCollection &coerced);
#endif
// Lens
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Lens;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Lens = &Dtool_Lens;
#endif
// CallbackData
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CallbackData;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackData = &Dtool_CallbackData;
#endif
// AsyncTask
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AsyncTask;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTask = &Dtool_AsyncTask;
#endif
// AsyncTaskManager
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AsyncTaskManager;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskManager = &Dtool_AsyncTaskManager;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * NodePath py_decode_NodePath_from_bam_stream(vector_uchar data)
 */
static PyObject *Dtool_py_decode_NodePath_from_bam_stream_2011(PyObject *, PyObject *arg) {
  // 1-NodePath py_decode_NodePath_from_bam_stream(vector_uchar data)
  unsigned char *param0_str = nullptr;
  Py_ssize_t param0_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param0_str, &param0_len) >= 0) {
    NodePath *return_value = new NodePath((::py_decode_NodePath_from_bam_stream)(vector_uchar(param0_str, param0_str + param0_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "py_decode_NodePath_from_bam_stream(bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_py_decode_NodePath_from_bam_stream_2011_comment =
  "C++ Interface:\n"
  "py_decode_NodePath_from_bam_stream(bytes data)\n";
#else
static const char *Dtool_py_decode_NodePath_from_bam_stream_2011_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath py_decode_NodePath_from_bam_stream_persist(PyObject *unpickler, vector_uchar data)
 */
static PyObject *Dtool_py_decode_NodePath_from_bam_stream_persist_2012(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-NodePath py_decode_NodePath_from_bam_stream_persist(PyObject *unpickler, vector_uchar data)
  PyObject *param0;
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"unpickler", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O" FMTCHAR_BYTES "#:py_decode_NodePath_from_bam_stream_persist", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    NodePath *return_value = new NodePath((::py_decode_NodePath_from_bam_stream_persist)(param0, vector_uchar(param1_str, param1_str + param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "py_decode_NodePath_from_bam_stream_persist(object unpickler, bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_py_decode_NodePath_from_bam_stream_persist_2012_comment =
  "C++ Interface:\n"
  "py_decode_NodePath_from_bam_stream_persist(object unpickler, bytes data)\n";
#else
static const char *Dtool_py_decode_NodePath_from_bam_stream_persist_2012_comment = nullptr;
#endif

/**
 * Python wrappers for functions of class TransformState
 */
/**
 * Python function wrapper for:
 * inline int TransformState::compare_to(TransformState const &other) const
 * int TransformState::compare_to(TransformState const &other, bool uniquify_matrix) const
 */
static PyObject *Dtool_TransformState_compare_to_4(PyObject *self, PyObject *args) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int TransformState::compare_to(TransformState const &other) const
      TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "TransformState.compare_to", true, true);
      if (arg_this != nullptr) {
        int return_value = ((*(const TransformState*)local_this).compare_to)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-int TransformState::compare_to(TransformState const &other, bool uniquify_matrix) const
      PyObject *param1;
      PyObject *param2;
      if (PyArg_UnpackTuple(args, "compare_to", 2, 2, &param1, &param2)) {
        TransformState const *param1_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TransformState, 1, "TransformState.compare_to", true, true);
        if (param1_this != nullptr) {
          int return_value = ((*(const TransformState*)local_this).compare_to)(*param1_this, (PyObject_IsTrue(param2) != 0));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compare_to() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(TransformState self, const TransformState other)\n"
      "compare_to(TransformState self, const TransformState other, bool uniquify_matrix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_compare_to_4_comment =
  "C++ Interface:\n"
  "compare_to(TransformState self, const TransformState other)\n"
  "compare_to(TransformState self, const TransformState other, bool uniquify_matrix)\n"
  "\n"
  "/**\n"
  " * Provides an arbitrary ordering among all unique TransformStates, so we can\n"
  " * store the essentially different ones in a big set and throw away the rest.\n"
  " *\n"
  " * Note that if this returns 0, it doesn't necessarily imply that operator ==\n"
  " * returns true; it uses a very slightly different comparison threshold.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Provides an arbitrary ordering among all unique TransformStates, so we can\n"
  " * store the essentially different ones in a big set and throw away the rest.\n"
  " *\n"
  " * Note that if this returns 0, it doesn't necessarily imply that operator ==\n"
  " * returns true; it uses a very slightly different comparison threshold.\n"
  " *\n"
  " * If uniquify_matrix is true, then matrix-defined TransformStates are also\n"
  " * uniqified.  If uniquify_matrix is false, then only component-defined\n"
  " * TransformStates are uniquified, which is less expensive.\n"
  " */";
#else
static const char *Dtool_TransformState_compare_to_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TransformState::get_hash(void) const
 */
static PyObject *Dtool_TransformState_get_hash_6(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline std::size_t TransformState::get_hash(void) const
  std::size_t return_value = ((*(const TransformState*)local_this).get_hash)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_hash_6_comment =
  "C++ Interface:\n"
  "get_hash(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash value for phash_map.\n"
  " */";
#else
static const char *Dtool_TransformState_get_hash_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< TransformState > TransformState::make_identity(void)
 */
static PyObject *Dtool_TransformState_make_identity_7(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< TransformState > TransformState::make_identity(void)
  ConstPointerTo< TransformState > return_value = (TransformState::make_identity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_identity_7_comment =
  "C++ Interface:\n"
  "make_identity()\n"
  "\n"
  "/**\n"
  " * Constructs an identity transform.\n"
  " */";
#else
static const char *Dtool_TransformState_make_identity_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< TransformState > TransformState::make_invalid(void)
 */
static PyObject *Dtool_TransformState_make_invalid_8(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< TransformState > TransformState::make_invalid(void)
  ConstPointerTo< TransformState > return_value = (TransformState::make_invalid)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_invalid_8_comment =
  "C++ Interface:\n"
  "make_invalid()\n"
  "\n"
  "/**\n"
  " * Constructs an invalid transform; for instance, the result of inverting a\n"
  " * singular matrix.\n"
  " */";
#else
static const char *Dtool_TransformState_make_invalid_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_pos(LVecBase3 const &pos)
 */
static PyObject *Dtool_TransformState_make_pos_9(PyObject *, PyObject *arg) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_pos(LVecBase3 const &pos)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "TransformState.make_pos", "LVecBase3f");
  }
  ConstPointerTo< TransformState > return_value = (TransformState::make_pos)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pos(const LVecBase3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_pos_9_comment =
  "C++ Interface:\n"
  "make_pos(const LVecBase3f pos)\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_pos_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_hpr(LVecBase3 const &hpr)
 */
static PyObject *Dtool_TransformState_make_hpr_10(PyObject *, PyObject *arg) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_hpr(LVecBase3 const &hpr)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "TransformState.make_hpr", "LVecBase3f");
  }
  ConstPointerTo< TransformState > return_value = (TransformState::make_hpr)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_hpr(const LVecBase3f hpr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_hpr_10_comment =
  "C++ Interface:\n"
  "make_hpr(const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_hpr_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_quat(LQuaternion const &quat)
 */
static PyObject *Dtool_TransformState_make_quat_11(PyObject *, PyObject *arg) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_quat(LQuaternion const &quat)
  LQuaternionf arg_local;
  LQuaternion const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "TransformState.make_quat", "LQuaternionf");
  }
  ConstPointerTo< TransformState > return_value = (TransformState::make_quat)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_quat(const LQuaternionf quat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_quat_11_comment =
  "C++ Interface:\n"
  "make_quat(const LQuaternionf quat)\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_quat_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_pos_hpr(LVecBase3 const &pos, LVecBase3 const &hpr)
 */
static PyObject *Dtool_TransformState_make_pos_hpr_12(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_pos_hpr(LVecBase3 const &pos, LVecBase3 const &hpr)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"pos", "hpr", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_pos_hpr", (char **)keyword_list, &param0, &param1)) {
    LVecBase3f param0_local;
    LVecBase3 const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "TransformState.make_pos_hpr", "LVecBase3f");
    }
    LVecBase3f param1_local;
    LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TransformState.make_pos_hpr", "LVecBase3f");
    }
    ConstPointerTo< TransformState > return_value = (TransformState::make_pos_hpr)(*param0_this, *param1_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pos_hpr(const LVecBase3f pos, const LVecBase3f hpr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_pos_hpr_12_comment =
  "C++ Interface:\n"
  "make_pos_hpr(const LVecBase3f pos, const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_pos_hpr_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_scale(LVecBase3 const &scale)
 * static inline ConstPointerTo< TransformState > TransformState::make_scale(PN_stdfloat scale)
 */
static PyObject *Dtool_TransformState_make_scale_13(PyObject *, PyObject *arg) {
  {
    // -2 static inline ConstPointerTo< TransformState > TransformState::make_scale(LVecBase3 const &scale)
    LVecBase3 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
    if (arg_this != nullptr) {
      ConstPointerTo< TransformState > return_value = (TransformState::make_scale)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      TransformState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
    }
  }

  {
    // -2 static inline ConstPointerTo< TransformState > TransformState::make_scale(PN_stdfloat scale)
    if (PyNumber_Check(arg)) {
      ConstPointerTo< TransformState > return_value = (TransformState::make_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      TransformState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
    }
  }

  {
    // -2 static inline ConstPointerTo< TransformState > TransformState::make_scale(LVecBase3 const &scale)
    LVecBase3f arg_local;
    LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ConstPointerTo< TransformState > return_value = (TransformState::make_scale)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      TransformState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
    }
  }

  // No coercion possible: static inline ConstPointerTo< TransformState > TransformState::make_scale(PN_stdfloat scale)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_scale(const LVecBase3f scale)\n"
      "make_scale(float scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_scale_13_comment =
  "C++ Interface:\n"
  "make_scale(const LVecBase3f scale)\n"
  "make_scale(float scale)\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified components.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_scale_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_shear(LVecBase3 const &shear)
 */
static PyObject *Dtool_TransformState_make_shear_14(PyObject *, PyObject *arg) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_shear(LVecBase3 const &shear)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "TransformState.make_shear", "LVecBase3f");
  }
  ConstPointerTo< TransformState > return_value = (TransformState::make_shear)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_shear(const LVecBase3f shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_shear_14_comment =
  "C++ Interface:\n"
  "make_shear(const LVecBase3f shear)\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_shear_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_pos_hpr_scale(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
 */
static PyObject *Dtool_TransformState_make_pos_hpr_scale_15(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_pos_hpr_scale(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"pos", "hpr", "scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:make_pos_hpr_scale", (char **)keyword_list, &param0, &param1, &param2)) {
    LVecBase3f param0_local;
    LVecBase3 const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "TransformState.make_pos_hpr_scale", "LVecBase3f");
    }
    LVecBase3f param1_local;
    LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TransformState.make_pos_hpr_scale", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TransformState.make_pos_hpr_scale", "LVecBase3f");
    }
    ConstPointerTo< TransformState > return_value = (TransformState::make_pos_hpr_scale)(*param0_this, *param1_this, *param2_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pos_hpr_scale(const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_pos_hpr_scale_15_comment =
  "C++ Interface:\n"
  "make_pos_hpr_scale(const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_pos_hpr_scale_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_pos_quat_scale(LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale)
 */
static PyObject *Dtool_TransformState_make_pos_quat_scale_16(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_pos_quat_scale(LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"pos", "quat", "scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:make_pos_quat_scale", (char **)keyword_list, &param0, &param1, &param2)) {
    LVecBase3f param0_local;
    LVecBase3 const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "TransformState.make_pos_quat_scale", "LVecBase3f");
    }
    LQuaternionf param1_local;
    LQuaternion const *param1_this = Dtool_Coerce_LQuaternionf(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TransformState.make_pos_quat_scale", "LQuaternionf");
    }
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TransformState.make_pos_quat_scale", "LVecBase3f");
    }
    ConstPointerTo< TransformState > return_value = (TransformState::make_pos_quat_scale)(*param0_this, *param1_this, *param2_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pos_quat_scale(const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_pos_quat_scale_16_comment =
  "C++ Interface:\n"
  "make_pos_quat_scale(const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale)\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_pos_quat_scale_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< TransformState > TransformState::make_pos_hpr_scale_shear(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale, LVecBase3 const &shear)
 */
static PyObject *Dtool_TransformState_make_pos_hpr_scale_shear_17(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< TransformState > TransformState::make_pos_hpr_scale_shear(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale, LVecBase3 const &shear)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"pos", "hpr", "scale", "shear", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:make_pos_hpr_scale_shear", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVecBase3f param0_local;
    LVecBase3 const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "TransformState.make_pos_hpr_scale_shear", "LVecBase3f");
    }
    LVecBase3f param1_local;
    LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TransformState.make_pos_hpr_scale_shear", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TransformState.make_pos_hpr_scale_shear", "LVecBase3f");
    }
    LVecBase3f param3_local;
    LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "TransformState.make_pos_hpr_scale_shear", "LVecBase3f");
    }
    ConstPointerTo< TransformState > return_value = (TransformState::make_pos_hpr_scale_shear)(*param0_this, *param1_this, *param2_this, *param3_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pos_hpr_scale_shear(const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale, const LVecBase3f shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_pos_hpr_scale_shear_17_comment =
  "C++ Interface:\n"
  "make_pos_hpr_scale_shear(const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale, const LVecBase3f shear)\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_pos_hpr_scale_shear_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< TransformState > TransformState::make_pos_quat_scale_shear(LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale, LVecBase3 const &shear)
 */
static PyObject *Dtool_TransformState_make_pos_quat_scale_shear_18(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< TransformState > TransformState::make_pos_quat_scale_shear(LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale, LVecBase3 const &shear)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"pos", "quat", "scale", "shear", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:make_pos_quat_scale_shear", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVecBase3f param0_local;
    LVecBase3 const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "TransformState.make_pos_quat_scale_shear", "LVecBase3f");
    }
    LQuaternionf param1_local;
    LQuaternion const *param1_this = Dtool_Coerce_LQuaternionf(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TransformState.make_pos_quat_scale_shear", "LQuaternionf");
    }
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TransformState.make_pos_quat_scale_shear", "LVecBase3f");
    }
    LVecBase3f param3_local;
    LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "TransformState.make_pos_quat_scale_shear", "LVecBase3f");
    }
    ConstPointerTo< TransformState > return_value = (TransformState::make_pos_quat_scale_shear)(*param0_this, *param1_this, *param2_this, *param3_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pos_quat_scale_shear(const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale, const LVecBase3f shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_pos_quat_scale_shear_18_comment =
  "C++ Interface:\n"
  "make_pos_quat_scale_shear(const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale, const LVecBase3f shear)\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_pos_quat_scale_shear_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< TransformState > TransformState::make_mat(LMatrix4 const &mat)
 */
static PyObject *Dtool_TransformState_make_mat_19(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< TransformState > TransformState::make_mat(LMatrix4 const &mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "TransformState.make_mat", "LMatrix4f");
  }
  ConstPointerTo< TransformState > return_value = (TransformState::make_mat)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_mat(const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_mat_19_comment =
  "C++ Interface:\n"
  "make_mat(const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Makes a new TransformState with the specified transformation matrix.\n"
  " */";
#else
static const char *Dtool_TransformState_make_mat_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_pos2d(LVecBase2 const &pos)
 */
static PyObject *Dtool_TransformState_make_pos2d_20(PyObject *, PyObject *arg) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_pos2d(LVecBase2 const &pos)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "TransformState.make_pos2d", "LVecBase2f");
  }
  ConstPointerTo< TransformState > return_value = (TransformState::make_pos2d)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pos2d(const LVecBase2f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_pos2d_20_comment =
  "C++ Interface:\n"
  "make_pos2d(const LVecBase2f pos)\n"
  "\n"
  "/**\n"
  " * Makes a new 2-d TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_pos2d_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_rotate2d(PN_stdfloat rotate)
 */
static PyObject *Dtool_TransformState_make_rotate2d_21(PyObject *, PyObject *arg) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_rotate2d(PN_stdfloat rotate)
  if (PyNumber_Check(arg)) {
    ConstPointerTo< TransformState > return_value = (TransformState::make_rotate2d)((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_rotate2d(float rotate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_rotate2d_21_comment =
  "C++ Interface:\n"
  "make_rotate2d(float rotate)\n"
  "\n"
  "/**\n"
  " * Makes a new 2-d TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_rotate2d_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_pos_rotate2d(LVecBase2 const &pos, PN_stdfloat rotate)
 */
static PyObject *Dtool_TransformState_make_pos_rotate2d_22(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_pos_rotate2d(LVecBase2 const &pos, PN_stdfloat rotate)
  PyObject *param0;
  float param1;
  static const char *keyword_list[] = {"pos", "rotate", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:make_pos_rotate2d", (char **)keyword_list, &param0, &param1)) {
    LVecBase2f param0_local;
    LVecBase2 const *param0_this = Dtool_Coerce_LVecBase2f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "TransformState.make_pos_rotate2d", "LVecBase2f");
    }
    ConstPointerTo< TransformState > return_value = (TransformState::make_pos_rotate2d)(*param0_this, (PN_stdfloat)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pos_rotate2d(const LVecBase2f pos, float rotate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_pos_rotate2d_22_comment =
  "C++ Interface:\n"
  "make_pos_rotate2d(const LVecBase2f pos, float rotate)\n"
  "\n"
  "/**\n"
  " * Makes a new 2-d TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_pos_rotate2d_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_scale2d(LVecBase2 const &scale)
 * static inline ConstPointerTo< TransformState > TransformState::make_scale2d(PN_stdfloat scale)
 */
static PyObject *Dtool_TransformState_make_scale2d_23(PyObject *, PyObject *arg) {
  {
    // -2 static inline ConstPointerTo< TransformState > TransformState::make_scale2d(LVecBase2 const &scale)
    LVecBase2 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2f);
    if (arg_this != nullptr) {
      ConstPointerTo< TransformState > return_value = (TransformState::make_scale2d)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      TransformState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
    }
  }

  {
    // -2 static inline ConstPointerTo< TransformState > TransformState::make_scale2d(PN_stdfloat scale)
    if (PyNumber_Check(arg)) {
      ConstPointerTo< TransformState > return_value = (TransformState::make_scale2d)((PN_stdfloat)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      TransformState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
    }
  }

  {
    // -2 static inline ConstPointerTo< TransformState > TransformState::make_scale2d(LVecBase2 const &scale)
    LVecBase2f arg_local;
    LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ConstPointerTo< TransformState > return_value = (TransformState::make_scale2d)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      TransformState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
    }
  }

  // No coercion possible: static inline ConstPointerTo< TransformState > TransformState::make_scale2d(PN_stdfloat scale)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_scale2d(const LVecBase2f scale)\n"
      "make_scale2d(float scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_scale2d_23_comment =
  "C++ Interface:\n"
  "make_scale2d(const LVecBase2f scale)\n"
  "make_scale2d(float scale)\n"
  "\n"
  "/**\n"
  " * Makes a new 2-d TransformState with the specified components.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Makes a new 2-d TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_scale2d_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_shear2d(PN_stdfloat shear)
 */
static PyObject *Dtool_TransformState_make_shear2d_24(PyObject *, PyObject *arg) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_shear2d(PN_stdfloat shear)
  if (PyNumber_Check(arg)) {
    ConstPointerTo< TransformState > return_value = (TransformState::make_shear2d)((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_shear2d(float shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_shear2d_24_comment =
  "C++ Interface:\n"
  "make_shear2d(float shear)\n"
  "\n"
  "/**\n"
  " * Makes a new 2-d TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_shear2d_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformState > TransformState::make_pos_rotate_scale2d(LVecBase2 const &pos, PN_stdfloat rotate, LVecBase2 const &scale)
 */
static PyObject *Dtool_TransformState_make_pos_rotate_scale2d_25(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline ConstPointerTo< TransformState > TransformState::make_pos_rotate_scale2d(LVecBase2 const &pos, PN_stdfloat rotate, LVecBase2 const &scale)
  PyObject *param0;
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"pos", "rotate", "scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OfO:make_pos_rotate_scale2d", (char **)keyword_list, &param0, &param1, &param2)) {
    LVecBase2f param0_local;
    LVecBase2 const *param0_this = Dtool_Coerce_LVecBase2f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "TransformState.make_pos_rotate_scale2d", "LVecBase2f");
    }
    LVecBase2f param2_local;
    LVecBase2 const *param2_this = Dtool_Coerce_LVecBase2f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TransformState.make_pos_rotate_scale2d", "LVecBase2f");
    }
    ConstPointerTo< TransformState > return_value = (TransformState::make_pos_rotate_scale2d)(*param0_this, (PN_stdfloat)param1, *param2_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pos_rotate_scale2d(const LVecBase2f pos, float rotate, const LVecBase2f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_pos_rotate_scale2d_25_comment =
  "C++ Interface:\n"
  "make_pos_rotate_scale2d(const LVecBase2f pos, float rotate, const LVecBase2f scale)\n"
  "\n"
  "/**\n"
  " * Makes a new 2-d TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_pos_rotate_scale2d_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< TransformState > TransformState::make_pos_rotate_scale_shear2d(LVecBase2 const &pos, PN_stdfloat rotate, LVecBase2 const &scale, PN_stdfloat shear)
 */
static PyObject *Dtool_TransformState_make_pos_rotate_scale_shear2d_26(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< TransformState > TransformState::make_pos_rotate_scale_shear2d(LVecBase2 const &pos, PN_stdfloat rotate, LVecBase2 const &scale, PN_stdfloat shear)
  PyObject *param0;
  float param1;
  PyObject *param2;
  float param3;
  static const char *keyword_list[] = {"pos", "rotate", "scale", "shear", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OfOf:make_pos_rotate_scale_shear2d", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVecBase2f param0_local;
    LVecBase2 const *param0_this = Dtool_Coerce_LVecBase2f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "TransformState.make_pos_rotate_scale_shear2d", "LVecBase2f");
    }
    LVecBase2f param2_local;
    LVecBase2 const *param2_this = Dtool_Coerce_LVecBase2f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TransformState.make_pos_rotate_scale_shear2d", "LVecBase2f");
    }
    ConstPointerTo< TransformState > return_value = (TransformState::make_pos_rotate_scale_shear2d)(*param0_this, (PN_stdfloat)param1, *param2_this, (PN_stdfloat)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pos_rotate_scale_shear2d(const LVecBase2f pos, float rotate, const LVecBase2f scale, float shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_pos_rotate_scale_shear2d_26_comment =
  "C++ Interface:\n"
  "make_pos_rotate_scale_shear2d(const LVecBase2f pos, float rotate, const LVecBase2f scale, float shear)\n"
  "\n"
  "/**\n"
  " * Makes a new two-dimensional TransformState with the specified components.\n"
  " */";
#else
static const char *Dtool_TransformState_make_pos_rotate_scale_shear2d_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< TransformState > TransformState::make_mat3(LMatrix3 const &mat)
 */
static PyObject *Dtool_TransformState_make_mat3_27(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< TransformState > TransformState::make_mat3(LMatrix3 const &mat)
  LMatrix3f arg_local;
  LMatrix3 const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "TransformState.make_mat3", "LMatrix3f");
  }
  ConstPointerTo< TransformState > return_value = (TransformState::make_mat3)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_mat3(const LMatrix3f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_make_mat3_27_comment =
  "C++ Interface:\n"
  "make_mat3(const LMatrix3f mat)\n"
  "\n"
  "/**\n"
  " * Makes a new two-dimensional TransformState with the specified 3x3\n"
  " * transformation matrix.\n"
  " */";
#else
static const char *Dtool_TransformState_make_mat3_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::is_identity(void) const
 */
static PyObject *Dtool_TransformState_is_identity_28(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::is_identity(void) const
  bool return_value = ((*(const TransformState*)local_this).is_identity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_is_identity_28_comment =
  "C++ Interface:\n"
  "is_identity(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform represents the identity matrix, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_TransformState_is_identity_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::is_invalid(void) const
 */
static PyObject *Dtool_TransformState_is_invalid_29(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::is_invalid(void) const
  bool return_value = ((*(const TransformState*)local_this).is_invalid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_is_invalid_29_comment =
  "C++ Interface:\n"
  "is_invalid(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform represents an invalid matrix, for instance\n"
  " * the result of inverting a singular matrix, or false if the transform is\n"
  " * valid.\n"
  " */";
#else
static const char *Dtool_TransformState_is_invalid_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::is_singular(void) const
 */
static PyObject *Dtool_TransformState_is_singular_30(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::is_singular(void) const
  bool return_value = ((*(const TransformState*)local_this).is_singular)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_is_singular_30_comment =
  "C++ Interface:\n"
  "is_singular(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform represents a singular transform (that is, it\n"
  " * has a zero scale, and it cannot be inverted), or false otherwise.\n"
  " */";
#else
static const char *Dtool_TransformState_is_singular_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::is_2d(void) const
 */
static PyObject *Dtool_TransformState_is_2d_31(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::is_2d(void) const
  bool return_value = ((*(const TransformState*)local_this).is_2d)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_is_2d_31_comment =
  "C++ Interface:\n"
  "is_2d(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform has been constructed entirely using the 2-d\n"
  " * transform operations, e.g.  make_pos2d(), and therefore operates strictly\n"
  " * in two-dimensional space on X and Y only.\n"
  " */";
#else
static const char *Dtool_TransformState_is_2d_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::has_components(void) const
 */
static PyObject *Dtool_TransformState_has_components_32(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::has_components(void) const
  bool return_value = ((*(const TransformState*)local_this).has_components)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_has_components_32_comment =
  "C++ Interface:\n"
  "has_components(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform can be described by separate pos, hpr, and\n"
  " * scale components.  Most transforms we use in everyday life can be so\n"
  " * described, but some kinds of transforms (for instance, those involving a\n"
  " * skew) cannot.\n"
  " *\n"
  " * This is not related to whether the transform was originally described\n"
  " * componentwise.  Even a transform that was constructed with a 4x4 may return\n"
  " * true here if the matrix is a simple affine matrix with no skew.\n"
  " *\n"
  " * If this returns true, you may safely call get_hpr() and get_scale() to\n"
  " * retrieve the components.  (You may always safely call get_pos() whether\n"
  " * this returns true or false.)\n"
  " */";
#else
static const char *Dtool_TransformState_has_components_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::components_given(void) const
 */
static PyObject *Dtool_TransformState_components_given_33(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::components_given(void) const
  bool return_value = ((*(const TransformState*)local_this).components_given)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_components_given_33_comment =
  "C++ Interface:\n"
  "components_given(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform was specified componentwise, or false if it\n"
  " * was specified with a general 4x4 matrix.  If this is true, the components\n"
  " * returned by get_pos() and get_scale() will be exactly those that were set;\n"
  " * otherwise, these functions will return computed values.  If this is true,\n"
  " * the rotation may have been set either with a hpr trio or with a quaternion;\n"
  " * hpr_given() or quat_given() can resolve the difference.\n"
  " */";
#else
static const char *Dtool_TransformState_components_given_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::hpr_given(void) const
 */
static PyObject *Dtool_TransformState_hpr_given_34(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::hpr_given(void) const
  bool return_value = ((*(const TransformState*)local_this).hpr_given)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_hpr_given_34_comment =
  "C++ Interface:\n"
  "hpr_given(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the rotation was specified via a trio of Euler angles,\n"
  " * false otherwise.  If this is true, get_hpr() will be exactly as set;\n"
  " * otherwise, it will return a computed value.\n"
  " */";
#else
static const char *Dtool_TransformState_hpr_given_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::quat_given(void) const
 */
static PyObject *Dtool_TransformState_quat_given_35(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::quat_given(void) const
  bool return_value = ((*(const TransformState*)local_this).quat_given)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_quat_given_35_comment =
  "C++ Interface:\n"
  "quat_given(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the rotation was specified via a quaternion, false\n"
  " * otherwise.  If this is true, get_quat() will be exactly as set; otherwise,\n"
  " * it will return a computed value.\n"
  " */";
#else
static const char *Dtool_TransformState_quat_given_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::has_pos(void) const
 */
static PyObject *Dtool_TransformState_has_pos_36(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::has_pos(void) const
  bool return_value = ((*(const TransformState*)local_this).has_pos)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_has_pos_36_comment =
  "C++ Interface:\n"
  "has_pos(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform's pos component can be extracted out\n"
  " * separately.  This is generally always true, unless the transform is invalid\n"
  " * (i.e.  is_invalid() returns true).\n"
  " */";
#else
static const char *Dtool_TransformState_has_pos_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::has_hpr(void) const
 */
static PyObject *Dtool_TransformState_has_hpr_37(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::has_hpr(void) const
  bool return_value = ((*(const TransformState*)local_this).has_hpr)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_has_hpr_37_comment =
  "C++ Interface:\n"
  "has_hpr(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform's rotation component can be extracted out\n"
  " * separately and described as a set of Euler angles.  This is generally true\n"
  " * only when has_components() is true.\n"
  " */";
#else
static const char *Dtool_TransformState_has_hpr_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::has_quat(void) const
 */
static PyObject *Dtool_TransformState_has_quat_38(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::has_quat(void) const
  bool return_value = ((*(const TransformState*)local_this).has_quat)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_has_quat_38_comment =
  "C++ Interface:\n"
  "has_quat(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform's rotation component can be extracted out\n"
  " * separately and described as a quaternion.  This is generally true only when\n"
  " * has_components() is true.\n"
  " */";
#else
static const char *Dtool_TransformState_has_quat_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::has_scale(void) const
 */
static PyObject *Dtool_TransformState_has_scale_39(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::has_scale(void) const
  bool return_value = ((*(const TransformState*)local_this).has_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_has_scale_39_comment =
  "C++ Interface:\n"
  "has_scale(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform's scale component can be extracted out\n"
  " * separately.  This is generally true only when has_components() is true.\n"
  " */";
#else
static const char *Dtool_TransformState_has_scale_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::has_identity_scale(void) const
 */
static PyObject *Dtool_TransformState_has_identity_scale_40(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::has_identity_scale(void) const
  bool return_value = ((*(const TransformState*)local_this).has_identity_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_has_identity_scale_40_comment =
  "C++ Interface:\n"
  "has_identity_scale(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the scale is uniform 1.0, or false if the scale has some\n"
  " * real value.\n"
  " */";
#else
static const char *Dtool_TransformState_has_identity_scale_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::has_uniform_scale(void) const
 */
static PyObject *Dtool_TransformState_has_uniform_scale_41(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::has_uniform_scale(void) const
  bool return_value = ((*(const TransformState*)local_this).has_uniform_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_has_uniform_scale_41_comment =
  "C++ Interface:\n"
  "has_uniform_scale(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the scale is uniform across all three axes (and therefore\n"
  " * can be expressed as a single number), or false if the transform has a\n"
  " * different scale in different dimensions.\n"
  " */";
#else
static const char *Dtool_TransformState_has_uniform_scale_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::has_shear(void) const
 */
static PyObject *Dtool_TransformState_has_shear_42(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::has_shear(void) const
  bool return_value = ((*(const TransformState*)local_this).has_shear)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_has_shear_42_comment =
  "C++ Interface:\n"
  "has_shear(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform's shear component can be extracted out\n"
  " * separately.  This is generally true only when has_components() is true.\n"
  " */";
#else
static const char *Dtool_TransformState_has_shear_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::has_nonzero_shear(void) const
 */
static PyObject *Dtool_TransformState_has_nonzero_shear_43(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::has_nonzero_shear(void) const
  bool return_value = ((*(const TransformState*)local_this).has_nonzero_shear)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_has_nonzero_shear_43_comment =
  "C++ Interface:\n"
  "has_nonzero_shear(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the shear component is non-zero, false if it is zero or if\n"
  " * the matrix cannot be decomposed.\n"
  " */";
#else
static const char *Dtool_TransformState_has_nonzero_shear_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::has_mat(void) const
 */
static PyObject *Dtool_TransformState_has_mat_44(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::has_mat(void) const
  bool return_value = ((*(const TransformState*)local_this).has_mat)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_has_mat_44_comment =
  "C++ Interface:\n"
  "has_mat(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform can be described as a matrix.  This is\n"
  " * generally always true, unless is_invalid() is true.\n"
  " */";
#else
static const char *Dtool_TransformState_has_mat_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &TransformState::get_pos(void) const
 */
static PyObject *Dtool_TransformState_get_pos_45(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &TransformState::get_pos(void) const
  LPoint3 const *return_value = &(((*(const TransformState*)local_this).get_pos)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_pos_45_comment =
  "C++ Interface:\n"
  "get_pos(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the pos component of the transform.  It is an error to call this if\n"
  " * has_pos() returned false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_pos_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &TransformState::get_hpr(void) const
 */
static PyObject *Dtool_TransformState_get_hpr_46(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline LVecBase3 const &TransformState::get_hpr(void) const
  LVecBase3 const *return_value = &(((*(const TransformState*)local_this).get_hpr)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_hpr_46_comment =
  "C++ Interface:\n"
  "get_hpr(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the rotation component of the transform as a trio of Euler angles.\n"
  " * It is an error to call this if has_components() returned false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_hpr_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LQuaternion const &TransformState::get_quat(void) const
 */
static PyObject *Dtool_TransformState_get_quat_47(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline LQuaternion const &TransformState::get_quat(void) const
  LQuaternion const *return_value = &(((*(const TransformState*)local_this).get_quat)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_quat_47_comment =
  "C++ Interface:\n"
  "get_quat(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the rotation component of the transform as a quaternion.  The\n"
  " * return value will be normalized if a normalized quaternion was given to the\n"
  " * constructor (or if the quaternion was computed implicitly); it will be non-\n"
  " * normalized if a non-normalized quaternion was given to the constructor.\n"
  " * See also get_norm_quat().\n"
  " *\n"
  " * It is an error to call this if has_components() returned false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_quat_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LQuaternion const &TransformState::get_norm_quat(void) const
 */
static PyObject *Dtool_TransformState_get_norm_quat_48(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline LQuaternion const &TransformState::get_norm_quat(void) const
  LQuaternion const *return_value = &(((*(const TransformState*)local_this).get_norm_quat)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_norm_quat_48_comment =
  "C++ Interface:\n"
  "get_norm_quat(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the rotation component of the transform as a quaternion.  Unlike\n"
  " * the result of get_quat(), the return value of this method is guaranteed to\n"
  " * be normalized.  It is an error to call this if has_components() returned\n"
  " * false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_norm_quat_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &TransformState::get_scale(void) const
 */
static PyObject *Dtool_TransformState_get_scale_49(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline LVecBase3 const &TransformState::get_scale(void) const
  LVecBase3 const *return_value = &(((*(const TransformState*)local_this).get_scale)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_scale_49_comment =
  "C++ Interface:\n"
  "get_scale(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the scale component of the transform.  It is an error to call this\n"
  " * if has_components() returned false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_scale_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TransformState::get_uniform_scale(void) const
 */
static PyObject *Dtool_TransformState_get_uniform_scale_50(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TransformState::get_uniform_scale(void) const
  PN_stdfloat return_value = ((*(const TransformState*)local_this).get_uniform_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_uniform_scale_50_comment =
  "C++ Interface:\n"
  "get_uniform_scale(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the scale component of the transform, as a single number.  It is an\n"
  " * error to call this if has_uniform_scale() returned false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_uniform_scale_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &TransformState::get_shear(void) const
 */
static PyObject *Dtool_TransformState_get_shear_51(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline LVecBase3 const &TransformState::get_shear(void) const
  LVecBase3 const *return_value = &(((*(const TransformState*)local_this).get_shear)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_shear_51_comment =
  "C++ Interface:\n"
  "get_shear(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the shear component of the transform.  It is an error to call this\n"
  " * if has_components() returned false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_shear_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &TransformState::get_mat(void) const
 */
static PyObject *Dtool_TransformState_get_mat_52(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &TransformState::get_mat(void) const
  LMatrix4 const *return_value = &(((*(const TransformState*)local_this).get_mat)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_mat_52_comment =
  "C++ Interface:\n"
  "get_mat(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the matrix that describes the transform.\n"
  " */";
#else
static const char *Dtool_TransformState_get_mat_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 TransformState::get_pos2d(void) const
 */
static PyObject *Dtool_TransformState_get_pos2d_53(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline LVecBase2 TransformState::get_pos2d(void) const
  LVecBase2 *return_value = new LVecBase2(((*(const TransformState*)local_this).get_pos2d)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_pos2d_53_comment =
  "C++ Interface:\n"
  "get_pos2d(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the pos component of the 2-d transform.  It is an error to call\n"
  " * this if has_pos() or is_2d() returned false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_pos2d_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TransformState::get_rotate2d(void) const
 */
static PyObject *Dtool_TransformState_get_rotate2d_54(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TransformState::get_rotate2d(void) const
  PN_stdfloat return_value = ((*(const TransformState*)local_this).get_rotate2d)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_rotate2d_54_comment =
  "C++ Interface:\n"
  "get_rotate2d(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the rotation component of the 2-d transform as an angle in degrees\n"
  " * clockwise about the origin.  It is an error to call this if\n"
  " * has_components() or is_2d() returned false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_rotate2d_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 TransformState::get_scale2d(void) const
 */
static PyObject *Dtool_TransformState_get_scale2d_55(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline LVecBase2 TransformState::get_scale2d(void) const
  LVecBase2 *return_value = new LVecBase2(((*(const TransformState*)local_this).get_scale2d)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_scale2d_55_comment =
  "C++ Interface:\n"
  "get_scale2d(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the scale component of the 2-d transform.  It is an error to call\n"
  " * this if has_components() or is_2d() returned false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_scale2d_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TransformState::get_shear2d(void) const
 */
static PyObject *Dtool_TransformState_get_shear2d_56(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TransformState::get_shear2d(void) const
  PN_stdfloat return_value = ((*(const TransformState*)local_this).get_shear2d)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_shear2d_56_comment =
  "C++ Interface:\n"
  "get_shear2d(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the shear component of the 2-d transform.  It is an error to call\n"
  " * this if has_components() or is_2d() returned false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_shear2d_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3 TransformState::get_mat3(void) const
 */
static PyObject *Dtool_TransformState_get_mat3_57(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline LMatrix3 TransformState::get_mat3(void) const
  LMatrix3 *return_value = new LMatrix3(((*(const TransformState*)local_this).get_mat3)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_mat3_57_comment =
  "C++ Interface:\n"
  "get_mat3(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the 3x3 matrix that describes the 2-d transform.  It is an error to\n"
  " * call this if is_2d() returned false.\n"
  " */";
#else
static const char *Dtool_TransformState_get_mat3_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TransformState::set_pos(LVecBase3 const &pos) const
 */
static PyObject *Dtool_TransformState_set_pos_77(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TransformState::set_pos(LVecBase3 const &pos) const
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TransformState.set_pos", "LVecBase3f");
  }
  ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).set_pos)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(TransformState self, const LVecBase3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_set_pos_77_comment =
  "C++ Interface:\n"
  "set_pos(TransformState self, const LVecBase3f pos)\n"
  "\n"
  "/**\n"
  " * Returns a new TransformState object that represents the original\n"
  " * TransformState with its pos component replaced with the indicated value.\n"
  " */";
#else
static const char *Dtool_TransformState_set_pos_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TransformState::set_hpr(LVecBase3 const &hpr) const
 */
static PyObject *Dtool_TransformState_set_hpr_78(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TransformState::set_hpr(LVecBase3 const &hpr) const
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TransformState.set_hpr", "LVecBase3f");
  }
  ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).set_hpr)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hpr(TransformState self, const LVecBase3f hpr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_set_hpr_78_comment =
  "C++ Interface:\n"
  "set_hpr(TransformState self, const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Returns a new TransformState object that represents the original\n"
  " * TransformState with its rotation component replaced with the indicated\n"
  " * value, if possible.\n"
  " */";
#else
static const char *Dtool_TransformState_set_hpr_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TransformState::set_quat(LQuaternion const &quat) const
 */
static PyObject *Dtool_TransformState_set_quat_79(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TransformState::set_quat(LQuaternion const &quat) const
  LQuaternionf arg_local;
  LQuaternion const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TransformState.set_quat", "LQuaternionf");
  }
  ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).set_quat)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quat(TransformState self, const LQuaternionf quat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_set_quat_79_comment =
  "C++ Interface:\n"
  "set_quat(TransformState self, const LQuaternionf quat)\n"
  "\n"
  "/**\n"
  " * Returns a new TransformState object that represents the original\n"
  " * TransformState with its rotation component replaced with the indicated\n"
  " * value, if possible.\n"
  " */";
#else
static const char *Dtool_TransformState_set_quat_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TransformState::set_scale(LVecBase3 const &scale) const
 */
static PyObject *Dtool_TransformState_set_scale_80(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TransformState::set_scale(LVecBase3 const &scale) const
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TransformState.set_scale", "LVecBase3f");
  }
  ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).set_scale)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale(TransformState self, const LVecBase3f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_set_scale_80_comment =
  "C++ Interface:\n"
  "set_scale(TransformState self, const LVecBase3f scale)\n"
  "\n"
  "/**\n"
  " * Returns a new TransformState object that represents the original\n"
  " * TransformState with its scale component replaced with the indicated value,\n"
  " * if possible.\n"
  " */";
#else
static const char *Dtool_TransformState_set_scale_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TransformState::set_shear(LVecBase3 const &shear) const
 */
static PyObject *Dtool_TransformState_set_shear_81(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TransformState::set_shear(LVecBase3 const &shear) const
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TransformState.set_shear", "LVecBase3f");
  }
  ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).set_shear)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shear(TransformState self, const LVecBase3f shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_set_shear_81_comment =
  "C++ Interface:\n"
  "set_shear(TransformState self, const LVecBase3f shear)\n"
  "\n"
  "/**\n"
  " * Returns a new TransformState object that represents the original\n"
  " * TransformState with its shear component replaced with the indicated value,\n"
  " * if possible.\n"
  " */";
#else
static const char *Dtool_TransformState_set_shear_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TransformState::set_pos2d(LVecBase2 const &pos) const
 */
static PyObject *Dtool_TransformState_set_pos2d_82(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TransformState::set_pos2d(LVecBase2 const &pos) const
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TransformState.set_pos2d", "LVecBase2f");
  }
  ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).set_pos2d)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos2d(TransformState self, const LVecBase2f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_set_pos2d_82_comment =
  "C++ Interface:\n"
  "set_pos2d(TransformState self, const LVecBase2f pos)\n"
  "\n"
  "/**\n"
  " * Returns a new TransformState object that represents the original 2-d\n"
  " * TransformState with its pos component replaced with the indicated value.\n"
  " */";
#else
static const char *Dtool_TransformState_set_pos2d_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TransformState::set_rotate2d(PN_stdfloat rotate) const
 */
static PyObject *Dtool_TransformState_set_rotate2d_83(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TransformState::set_rotate2d(PN_stdfloat rotate) const
  if (PyNumber_Check(arg)) {
    ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).set_rotate2d)((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotate2d(TransformState self, float rotate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_set_rotate2d_83_comment =
  "C++ Interface:\n"
  "set_rotate2d(TransformState self, float rotate)\n"
  "\n"
  "/**\n"
  " * Returns a new TransformState object that represents the original 2-d\n"
  " * TransformState with its rotation component replaced with the indicated\n"
  " * value, if possible.\n"
  " */";
#else
static const char *Dtool_TransformState_set_rotate2d_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TransformState::set_scale2d(LVecBase2 const &scale) const
 */
static PyObject *Dtool_TransformState_set_scale2d_84(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TransformState::set_scale2d(LVecBase2 const &scale) const
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TransformState.set_scale2d", "LVecBase2f");
  }
  ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).set_scale2d)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale2d(TransformState self, const LVecBase2f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_set_scale2d_84_comment =
  "C++ Interface:\n"
  "set_scale2d(TransformState self, const LVecBase2f scale)\n"
  "\n"
  "/**\n"
  " * Returns a new TransformState object that represents the original 2-d\n"
  " * TransformState with its scale component replaced with the indicated value,\n"
  " * if possible.\n"
  " */";
#else
static const char *Dtool_TransformState_set_scale2d_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TransformState::set_shear2d(PN_stdfloat shear) const
 */
static PyObject *Dtool_TransformState_set_shear2d_85(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TransformState::set_shear2d(PN_stdfloat shear) const
  if (PyNumber_Check(arg)) {
    ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).set_shear2d)((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shear2d(TransformState self, float shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_set_shear2d_85_comment =
  "C++ Interface:\n"
  "set_shear2d(TransformState self, float shear)\n"
  "\n"
  "/**\n"
  " * Returns a new TransformState object that represents the original 2-d\n"
  " * TransformState with its shear component replaced with the indicated value,\n"
  " * if possible.\n"
  " */";
#else
static const char *Dtool_TransformState_set_shear2d_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TransformState::compose(TransformState const *other) const
 */
static PyObject *Dtool_TransformState_compose_86(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TransformState::compose(TransformState const *other) const
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "TransformState.compose", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).compose)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compose(TransformState self, const TransformState other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_compose_86_comment =
  "C++ Interface:\n"
  "compose(TransformState self, const TransformState other)\n"
  "\n"
  "/**\n"
  " * Returns a new TransformState object that represents the composition of this\n"
  " * state with the other state.\n"
  " *\n"
  " * The result of this operation is cached, and will be retained as long as\n"
  " * both this TransformState object and the other TransformState object\n"
  " * continue to exist.  Should one of them destruct, the cached entry will be\n"
  " * removed, and its pointer will be allowed to destruct as well.\n"
  " */";
#else
static const char *Dtool_TransformState_compose_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TransformState::invert_compose(TransformState const *other) const
 */
static PyObject *Dtool_TransformState_invert_compose_87(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TransformState::invert_compose(TransformState const *other) const
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "TransformState.invert_compose", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).invert_compose)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_compose(TransformState self, const TransformState other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_invert_compose_87_comment =
  "C++ Interface:\n"
  "invert_compose(TransformState self, const TransformState other)\n"
  "\n"
  "/**\n"
  " * Returns a new TransformState object that represents the composition of this\n"
  " * state's inverse with the other state.\n"
  " *\n"
  " * This is similar to compose(), but is particularly useful for computing the\n"
  " * relative state of a node as viewed from some other node.\n"
  " */";
#else
static const char *Dtool_TransformState_invert_compose_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< TransformState > TransformState::get_inverse(void) const
 */
static PyObject *Dtool_TransformState_get_inverse_88(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< TransformState > TransformState::get_inverse(void) const
  ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).get_inverse)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_inverse_88_comment =
  "C++ Interface:\n"
  "get_inverse(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the inverse of this transform.  If you are going to immediately\n"
  " * compose this result with another TransformState, it is faster to do it in\n"
  " * one operation with invert_compose().\n"
  " */";
#else
static const char *Dtool_TransformState_get_inverse_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< TransformState > TransformState::get_unique(void) const
 */
static PyObject *Dtool_TransformState_get_unique_89(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< TransformState > TransformState::get_unique(void) const
  ConstPointerTo< TransformState > return_value = ((*(const TransformState*)local_this).get_unique)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_unique_89_comment =
  "C++ Interface:\n"
  "get_unique(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the unique TransformState in the cache that is\n"
  " * equivalent to this one.  This may be the same pointer as this object, or it\n"
  " * may be a different pointer; but it will be an equivalent object, and it\n"
  " * will be a shared pointer.  This may be called from time to time to improve\n"
  " * cache benefits.\n"
  " */";
#else
static const char *Dtool_TransformState_get_unique_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TransformState::get_geom_rendering(int geom_rendering) const
 */
static PyObject *Dtool_TransformState_get_geom_rendering_90(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline int TransformState::get_geom_rendering(int geom_rendering) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const TransformState*)local_this).get_geom_rendering)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geom_rendering(TransformState self, int geom_rendering)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_geom_rendering_90_comment =
  "C++ Interface:\n"
  "get_geom_rendering(TransformState self, int geom_rendering)\n"
  "\n"
  "/**\n"
  " * Returns the union of the Geom::GeomRendering bits that will be required\n"
  " * once this TransformState is applied to a geom which includes the indicated\n"
  " * geom_rendering bits.  The RenderState's get_geom_rendering() should already\n"
  " * have been applied.\n"
  " */";
#else
static const char *Dtool_TransformState_get_geom_rendering_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TransformState::cache_ref(void) const
 */
static PyObject *Dtool_TransformState_cache_ref_91(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline void TransformState::cache_ref(void) const
  ((*(const TransformState*)local_this).cache_ref)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TransformState_cache_ref_91_comment =
  "C++ Interface:\n"
  "cache_ref(TransformState self)\n"
  "\n"
  "/**\n"
  " * Overrides this method to update PStats appropriately.\n"
  " */";
#else
static const char *Dtool_TransformState_cache_ref_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::cache_unref(void) const
 */
static PyObject *Dtool_TransformState_cache_unref_92(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::cache_unref(void) const
  bool return_value = ((*(const TransformState*)local_this).cache_unref)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_cache_unref_92_comment =
  "C++ Interface:\n"
  "cache_unref(TransformState self)\n"
  "\n"
  "/**\n"
  " * Overrides this method to update PStats appropriately.\n"
  " */";
#else
static const char *Dtool_TransformState_cache_unref_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TransformState::node_ref(void) const
 */
static PyObject *Dtool_TransformState_node_ref_93(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline void TransformState::node_ref(void) const
  ((*(const TransformState*)local_this).node_ref)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TransformState_node_ref_93_comment =
  "C++ Interface:\n"
  "node_ref(TransformState self)\n"
  "\n"
  "/**\n"
  " * Overrides this method to update PStats appropriately.\n"
  " */";
#else
static const char *Dtool_TransformState_node_ref_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformState::node_unref(void) const
 */
static PyObject *Dtool_TransformState_node_unref_94(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline bool TransformState::node_unref(void) const
  bool return_value = ((*(const TransformState*)local_this).node_unref)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_node_unref_94_comment =
  "C++ Interface:\n"
  "node_unref(TransformState self)\n"
  "\n"
  "/**\n"
  " * Overrides this method to update PStats appropriately.\n"
  " */";
#else
static const char *Dtool_TransformState_node_unref_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TransformState::get_composition_cache_num_entries(void) const
 */
static PyObject *Dtool_TransformState_get_composition_cache_num_entries_95(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline std::size_t TransformState::get_composition_cache_num_entries(void) const
  std::size_t return_value = ((*(const TransformState*)local_this).get_composition_cache_num_entries)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_composition_cache_num_entries_95_comment =
  "C++ Interface:\n"
  "get_composition_cache_num_entries(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the number of entries in the composition cache for this\n"
  " * TransformState.  This is the number of other TransformStates whose\n"
  " * composition with this one has been cached.  This number is not useful for\n"
  " * any practical reason other than performance analysis.\n"
  " */";
#else
static const char *Dtool_TransformState_get_composition_cache_num_entries_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TransformState::get_invert_composition_cache_num_entries(void) const
 */
static PyObject *Dtool_TransformState_get_invert_composition_cache_num_entries_96(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline std::size_t TransformState::get_invert_composition_cache_num_entries(void) const
  std::size_t return_value = ((*(const TransformState*)local_this).get_invert_composition_cache_num_entries)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_invert_composition_cache_num_entries_96_comment =
  "C++ Interface:\n"
  "get_invert_composition_cache_num_entries(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the number of entries in the invert_composition cache for this\n"
  " * TransformState.  This is similar to the composition cache, but it records\n"
  " * cache entries for the invert_compose() operation.  See\n"
  " * get_composition_cache_num_entries().\n"
  " */";
#else
static const char *Dtool_TransformState_get_invert_composition_cache_num_entries_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TransformState::get_composition_cache_size(void) const
 */
static PyObject *Dtool_TransformState_get_composition_cache_size_97(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline std::size_t TransformState::get_composition_cache_size(void) const
  std::size_t return_value = ((*(const TransformState*)local_this).get_composition_cache_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_composition_cache_size_97_comment =
  "C++ Interface:\n"
  "get_composition_cache_size(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the number of slots in the composition cache for this\n"
  " * TransformState.  You may use this as an upper bound when walking through\n"
  " * all of the composition cache results via get_composition_cache_source() or\n"
  " * result().\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_TransformState_get_composition_cache_size_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *TransformState::get_composition_cache_source(std::size_t n) const
 */
static PyObject *Dtool_TransformState_get_composition_cache_source_98(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline TransformState const *TransformState::get_composition_cache_source(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    TransformState const *return_value = ((*(const TransformState*)local_this).get_composition_cache_source)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_composition_cache_source(TransformState self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_composition_cache_source_98_comment =
  "C++ Interface:\n"
  "get_composition_cache_source(TransformState self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the source TransformState of the nth element in the composition\n"
  " * cache.  Returns NULL if there doesn't happen to be an entry in the nth\n"
  " * element.  See get_composition_cache_result().\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_TransformState_get_composition_cache_source_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *TransformState::get_composition_cache_result(std::size_t n) const
 */
static PyObject *Dtool_TransformState_get_composition_cache_result_99(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline TransformState const *TransformState::get_composition_cache_result(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    TransformState const *return_value = ((*(const TransformState*)local_this).get_composition_cache_result)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_composition_cache_result(TransformState self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_composition_cache_result_99_comment =
  "C++ Interface:\n"
  "get_composition_cache_result(TransformState self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the result TransformState of the nth element in the composition\n"
  " * cache.  Returns NULL if there doesn't happen to be an entry in the nth\n"
  " * element.\n"
  " *\n"
  " * In general, a->compose(a->get_composition_cache_source(n)) ==\n"
  " * a->get_composition_cache_result(n).\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_TransformState_get_composition_cache_result_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TransformState::get_invert_composition_cache_size(void) const
 */
static PyObject *Dtool_TransformState_get_invert_composition_cache_size_100(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline std::size_t TransformState::get_invert_composition_cache_size(void) const
  std::size_t return_value = ((*(const TransformState*)local_this).get_invert_composition_cache_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_invert_composition_cache_size_100_comment =
  "C++ Interface:\n"
  "get_invert_composition_cache_size(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns the number of slots in the composition cache for this\n"
  " * TransformState.  You may use this as an upper bound when walking through\n"
  " * all of the composition cache results via\n"
  " * get_invert_composition_cache_source() or result().\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_TransformState_get_invert_composition_cache_size_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *TransformState::get_invert_composition_cache_source(std::size_t n) const
 */
static PyObject *Dtool_TransformState_get_invert_composition_cache_source_101(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline TransformState const *TransformState::get_invert_composition_cache_source(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    TransformState const *return_value = ((*(const TransformState*)local_this).get_invert_composition_cache_source)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_invert_composition_cache_source(TransformState self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_invert_composition_cache_source_101_comment =
  "C++ Interface:\n"
  "get_invert_composition_cache_source(TransformState self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the source TransformState of the nth element in the invert\n"
  " * composition cache.  Returns NULL if there doesn't happen to be an entry in\n"
  " * the nth element.  See get_invert_composition_cache_result().\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_TransformState_get_invert_composition_cache_source_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *TransformState::get_invert_composition_cache_result(std::size_t n) const
 */
static PyObject *Dtool_TransformState_get_invert_composition_cache_result_102(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-inline TransformState const *TransformState::get_invert_composition_cache_result(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    TransformState const *return_value = ((*(const TransformState*)local_this).get_invert_composition_cache_result)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_invert_composition_cache_result(TransformState self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_invert_composition_cache_result_102_comment =
  "C++ Interface:\n"
  "get_invert_composition_cache_result(TransformState self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the result TransformState of the nth element in the invert\n"
  " * composition cache.  Returns NULL if there doesn't happen to be an entry in\n"
  " * the nth element.\n"
  " *\n"
  " * In general, a->invert_compose(a->get_invert_composition_cache_source(n)) ==\n"
  " * a->get_invert_composition_cache_result(n).\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_TransformState_get_invert_composition_cache_result_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TransformState::validate_composition_cache(void) const
 */
static PyObject *Dtool_TransformState_validate_composition_cache_103(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-bool TransformState::validate_composition_cache(void) const
  bool return_value = ((*(const TransformState*)local_this).validate_composition_cache)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_validate_composition_cache_103_comment =
  "C++ Interface:\n"
  "validate_composition_cache(TransformState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the composition cache and invert composition cache for this\n"
  " * particular TransformState are self-consistent and valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_TransformState_validate_composition_cache_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *TransformState::get_composition_cache(void) const
 */
static PyObject *Dtool_TransformState_get_composition_cache_104(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-PyObject *TransformState::get_composition_cache(void) const
  PyObject *return_value = invoke_extension((const TransformState*)local_this).get_composition_cache();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_composition_cache_104_comment =
  "C++ Interface:\n"
  "get_composition_cache(TransformState self)\n";
#else
static const char *Dtool_TransformState_get_composition_cache_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *TransformState::get_invert_composition_cache(void) const
 */
static PyObject *Dtool_TransformState_get_invert_composition_cache_105(PyObject *self, PyObject *) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-PyObject *TransformState::get_invert_composition_cache(void) const
  PyObject *return_value = invoke_extension((const TransformState*)local_this).get_invert_composition_cache();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_invert_composition_cache_105_comment =
  "C++ Interface:\n"
  "get_invert_composition_cache(TransformState self)\n";
#else
static const char *Dtool_TransformState_get_invert_composition_cache_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformState::output(std::ostream &out) const
 */
static PyObject *Dtool_TransformState_output_106(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-void TransformState::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "TransformState.output", false, true);
  if (arg_this != nullptr) {
    ((*(const TransformState*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(TransformState self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_output_106_comment =
  "C++ Interface:\n"
  "output(TransformState self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TransformState_output_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformState::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_TransformState_write_107(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-void TransformState::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "TransformState.write", false, true);
    if (param1_this != nullptr) {
      ((*(const TransformState*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TransformState self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_write_107_comment =
  "C++ Interface:\n"
  "write(TransformState self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TransformState_write_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformState::write_composition_cache(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_TransformState_write_composition_cache_108(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformState)) {
    return nullptr;
  }
  // 1-void TransformState::write_composition_cache(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_composition_cache", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "TransformState.write_composition_cache", false, true);
    if (param1_this != nullptr) {
      ((*(const TransformState*)local_this).write_composition_cache)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_composition_cache(TransformState self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_write_composition_cache_108_comment =
  "C++ Interface:\n"
  "write_composition_cache(TransformState self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a brief description of the composition cache and invert composition\n"
  " * cache to the indicated ostream.  This is not useful except for performance\n"
  " * analysis, to examine the cache structure.\n"
  " */";
#else
static const char *Dtool_TransformState_write_composition_cache_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int TransformState::get_num_states(void)
 */
static PyObject *Dtool_TransformState_get_num_states_109(PyObject *, PyObject *) {
  // 1-static int TransformState::get_num_states(void)
  int return_value = (TransformState::get_num_states)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_num_states_109_comment =
  "C++ Interface:\n"
  "get_num_states()\n"
  "\n"
  "/**\n"
  " * Returns the total number of unique TransformState objects allocated in the\n"
  " * world.  This will go up and down during normal operations.\n"
  " */";
#else
static const char *Dtool_TransformState_get_num_states_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int TransformState::get_num_unused_states(void)
 */
static PyObject *Dtool_TransformState_get_num_unused_states_110(PyObject *, PyObject *) {
  // 1-static int TransformState::get_num_unused_states(void)
  int return_value = (TransformState::get_num_unused_states)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_num_unused_states_110_comment =
  "C++ Interface:\n"
  "get_num_unused_states()\n"
  "\n"
  "/**\n"
  " * Returns the total number of TransformState objects that have been allocated\n"
  " * but have no references outside of the internal TransformState cache.\n"
  " *\n"
  " * A nonzero return value is not necessarily indicative of leaked references;\n"
  " * it is normal for two TransformState objects, both of which have references\n"
  " * held outside the cache, to have the result of their composition stored\n"
  " * within the cache.  This result will be retained within the cache until one\n"
  " * of the base TransformStates is released.\n"
  " *\n"
  " * Use list_cycles() to get an idea of the number of actual \"leaked\"\n"
  " * TransformState objects.\n"
  " */";
#else
static const char *Dtool_TransformState_get_num_unused_states_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int TransformState::clear_cache(void)
 */
static PyObject *Dtool_TransformState_clear_cache_111(PyObject *, PyObject *) {
  // 1-static int TransformState::clear_cache(void)
  int return_value = (TransformState::clear_cache)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_clear_cache_111_comment =
  "C++ Interface:\n"
  "clear_cache()\n"
  "\n"
  "/**\n"
  " * Empties the cache of composed TransformStates.  This makes every\n"
  " * TransformState forget what results when it is composed with other\n"
  " * TransformStates.\n"
  " *\n"
  " * This will eliminate any TransformState objects that have been allocated but\n"
  " * have no references outside of the internal TransformState map.  It will not\n"
  " * eliminate TransformState objects that are still in use.\n"
  " *\n"
  " * Nowadays, this method should not be necessary, as reference-count cycles in\n"
  " * the composition cache should be automatically detected and broken.\n"
  " *\n"
  " * The return value is the number of TransformStates freed by this operation.\n"
  " */";
#else
static const char *Dtool_TransformState_clear_cache_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int TransformState::garbage_collect(void)
 */
static PyObject *Dtool_TransformState_garbage_collect_112(PyObject *, PyObject *) {
  // 1-static int TransformState::garbage_collect(void)
  int return_value = (TransformState::garbage_collect)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_garbage_collect_112_comment =
  "C++ Interface:\n"
  "garbage_collect()\n"
  "\n"
  "/**\n"
  " * Performs a garbage-collection cycle.  This must be called periodically if\n"
  " * garbage-collect-states is true to ensure that TransformStates get cleaned\n"
  " * up appropriately.  It does no harm to call it even if this variable is not\n"
  " * true, but there is probably no advantage in that case.\n"
  " */";
#else
static const char *Dtool_TransformState_garbage_collect_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void TransformState::list_cycles(std::ostream &out)
 */
static PyObject *Dtool_TransformState_list_cycles_113(PyObject *, PyObject *arg) {
  // 1-static void TransformState::list_cycles(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "TransformState.list_cycles", false, true);
  if (arg_this != nullptr) {
    (TransformState::list_cycles)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_cycles(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_list_cycles_113_comment =
  "C++ Interface:\n"
  "list_cycles(ostream out)\n"
  "\n"
  "/**\n"
  " * Detects all of the reference-count cycles in the cache and reports them to\n"
  " * standard output.\n"
  " *\n"
  " * These cycles may be inadvertently created when state compositions cycle\n"
  " * back to a starting point.  Nowadays, these cycles should be automatically\n"
  " * detected and broken, so this method should never list any cycles unless\n"
  " * there is a bug in that detection logic.\n"
  " *\n"
  " * The cycles listed here are not leaks in the strictest sense of the word,\n"
  " * since they can be reclaimed by a call to clear_cache(); but they will not\n"
  " * be reclaimed automatically.\n"
  " */";
#else
static const char *Dtool_TransformState_list_cycles_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void TransformState::list_states(std::ostream &out)
 */
static PyObject *Dtool_TransformState_list_states_114(PyObject *, PyObject *arg) {
  // 1-static void TransformState::list_states(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "TransformState.list_states", false, true);
  if (arg_this != nullptr) {
    (TransformState::list_states)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_states(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformState_list_states_114_comment =
  "C++ Interface:\n"
  "list_states(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists all of the TransformStates in the cache to the output stream, one per\n"
  " * line.  This can be quite a lot of output if the cache is large, so be\n"
  " * prepared.\n"
  " */";
#else
static const char *Dtool_TransformState_list_states_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool TransformState::validate_states(void)
 */
static PyObject *Dtool_TransformState_validate_states_115(PyObject *, PyObject *) {
  // 1-static bool TransformState::validate_states(void)
  bool return_value = (TransformState::validate_states)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_validate_states_115_comment =
  "C++ Interface:\n"
  "validate_states()\n"
  "\n"
  "/**\n"
  " * Ensures that the cache is still stored in sorted order, and that none of\n"
  " * the cache elements have been inadvertently deleted.  Returns true if so,\n"
  " * false if there is a problem (which implies someone has modified one of the\n"
  " * supposedly-const TransformState objects).\n"
  " */";
#else
static const char *Dtool_TransformState_validate_states_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PyObject *TransformState::get_states(void)
 */
static PyObject *Dtool_TransformState_get_states_116(PyObject *, PyObject *) {
  // 1-static PyObject *TransformState::get_states(void)
  PyObject *return_value = Extension<TransformState>::get_states();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_states_116_comment =
  "C++ Interface:\n"
  "get_states()\n";
#else
static const char *Dtool_TransformState_get_states_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PyObject *TransformState::get_unused_states(void)
 */
static PyObject *Dtool_TransformState_get_unused_states_117(PyObject *, PyObject *) {
  // 1-static PyObject *TransformState::get_unused_states(void)
  PyObject *return_value = Extension<TransformState>::get_unused_states();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_unused_states_117_comment =
  "C++ Interface:\n"
  "get_unused_states()\n";
#else
static const char *Dtool_TransformState_get_unused_states_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TransformState::get_class_type(void)
 */
static PyObject *Dtool_TransformState_get_class_type_118(PyObject *, PyObject *) {
  // 1-static TypeHandle TransformState::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TransformState::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TransformState_get_class_type_118_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TransformState_get_class_type_118_comment = nullptr;
#endif

static PyObject *Dtool_TransformState_pos_Getter(PyObject *self, void *) {
  const TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &TransformState::get_pos(void) const
  LPoint3 const *return_value = &(((*(const TransformState*)local_this).get_pos)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static PyObject *Dtool_TransformState_hpr_Getter(PyObject *self, void *) {
  const TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase3 const &TransformState::get_hpr(void) const
  LVecBase3 const *return_value = &(((*(const TransformState*)local_this).get_hpr)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static PyObject *Dtool_TransformState_quat_Getter(PyObject *self, void *) {
  const TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LQuaternion const &TransformState::get_quat(void) const
  LQuaternion const *return_value = &(((*(const TransformState*)local_this).get_quat)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, false, true);
}

static PyObject *Dtool_TransformState_norm_quat_Getter(PyObject *self, void *) {
  const TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LQuaternion const &TransformState::get_norm_quat(void) const
  LQuaternion const *return_value = &(((*(const TransformState*)local_this).get_norm_quat)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, false, true);
}

static PyObject *Dtool_TransformState_scale_Getter(PyObject *self, void *) {
  const TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase3 const &TransformState::get_scale(void) const
  LVecBase3 const *return_value = &(((*(const TransformState*)local_this).get_scale)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static PyObject *Dtool_TransformState_shear_Getter(PyObject *self, void *) {
  const TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase3 const &TransformState::get_shear(void) const
  LVecBase3 const *return_value = &(((*(const TransformState*)local_this).get_shear)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static PyObject *Dtool_TransformState_mat_Getter(PyObject *self, void *) {
  const TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LMatrix4 const &TransformState::get_mat(void) const
  LMatrix4 const *return_value = &(((*(const TransformState*)local_this).get_mat)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

static int Dtool_Init_TransformState(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TransformState(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TransformState) {
    printf("TransformState ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TransformState *local_this = (TransformState *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TransformState) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(NodeCachedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_NodeCachedReferenceCount) {
    return (NodeCachedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(NodeCachedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(NodeCachedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(NodeCachedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(NodeCachedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TransformState(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TransformState) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (TransformState*)other_this;
  }
  if (from_type == Dtool_Ptr_NodeCachedReferenceCount) {
    NodeCachedReferenceCount* other_this = (NodeCachedReferenceCount*)from_this;
    return (TransformState*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TransformState*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TransformState*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TransformState*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TransformState*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RenderAttribRegistry
 */
/**
 * Python function wrapper for:
 * inline int RenderAttribRegistry::get_slot(TypeHandle type_handle) const
 */
static PyObject *Dtool_RenderAttribRegistry_get_slot_120(PyObject *self, PyObject *arg) {
  RenderAttribRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttribRegistry)) {
    return nullptr;
  }
  // 1-inline int RenderAttribRegistry::get_slot(TypeHandle type_handle) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RenderAttribRegistry.get_slot", "TypeHandle");
  }
  int return_value = ((*(const RenderAttribRegistry*)local_this).get_slot)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_slot(RenderAttribRegistry self, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttribRegistry_get_slot_120_comment =
  "C++ Interface:\n"
  "get_slot(RenderAttribRegistry self, TypeHandle type_handle)\n"
  "\n"
  "/**\n"
  " * Returns the slot number assigned to the indicated TypeHandle, or 0 if no\n"
  " * slot number has been assigned.\n"
  " */";
#else
static const char *Dtool_RenderAttribRegistry_get_slot_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr int RenderAttribRegistry::get_max_slots(void)
 */
static PyObject *Dtool_RenderAttribRegistry_get_max_slots_121(PyObject *, PyObject *) {
  // 1-static constexpr int RenderAttribRegistry::get_max_slots(void)
  int return_value = (RenderAttribRegistry::get_max_slots)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderAttribRegistry_get_max_slots_121_comment =
  "C++ Interface:\n"
  "get_max_slots()\n";
#else
static const char *Dtool_RenderAttribRegistry_get_max_slots_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RenderAttribRegistry::get_num_slots(void) const
 */
static PyObject *Dtool_RenderAttribRegistry_get_num_slots_122(PyObject *self, PyObject *) {
  RenderAttribRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttribRegistry)) {
    return nullptr;
  }
  // 1-inline int RenderAttribRegistry::get_num_slots(void) const
  int return_value = ((*(const RenderAttribRegistry*)local_this).get_num_slots)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderAttribRegistry_get_num_slots_122_comment =
  "C++ Interface:\n"
  "get_num_slots(RenderAttribRegistry self)\n"
  "\n"
  "/**\n"
  " * Returns the number of RenderAttrib slots that have been allocated.  This is\n"
  " * one more than the highest slot number in use.\n"
  " */";
#else
static const char *Dtool_RenderAttribRegistry_get_num_slots_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TypeHandle RenderAttribRegistry::get_slot_type(int slot) const
 */
static PyObject *Dtool_RenderAttribRegistry_get_slot_type_123(PyObject *self, PyObject *arg) {
  RenderAttribRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttribRegistry)) {
    return nullptr;
  }
  // 1-inline TypeHandle RenderAttribRegistry::get_slot_type(int slot) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle(((*(const RenderAttribRegistry*)local_this).get_slot_type)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_slot_type(RenderAttribRegistry self, int slot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttribRegistry_get_slot_type_123_comment =
  "C++ Interface:\n"
  "get_slot_type(RenderAttribRegistry self, int slot)\n"
  "\n"
  "/**\n"
  " * Returns the TypeHandle associated with slot n.\n"
  " */";
#else
static const char *Dtool_RenderAttribRegistry_get_slot_type_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RenderAttribRegistry::get_slot_sort(int slot) const
 */
static PyObject *Dtool_RenderAttribRegistry_get_slot_sort_124(PyObject *self, PyObject *arg) {
  RenderAttribRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttribRegistry)) {
    return nullptr;
  }
  // 1-inline int RenderAttribRegistry::get_slot_sort(int slot) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const RenderAttribRegistry*)local_this).get_slot_sort)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_slot_sort(RenderAttribRegistry self, int slot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttribRegistry_get_slot_sort_124_comment =
  "C++ Interface:\n"
  "get_slot_sort(RenderAttribRegistry self, int slot)\n"
  "\n"
  "/**\n"
  " * Returns the sort number associated with slot n.\n"
  " */";
#else
static const char *Dtool_RenderAttribRegistry_get_slot_sort_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RenderAttribRegistry::set_slot_sort(int slot, int sort)
 */
static PyObject *Dtool_RenderAttribRegistry_set_slot_sort_125(PyObject *self, PyObject *args, PyObject *kwds) {
  RenderAttribRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RenderAttribRegistry, (void **)&local_this, "RenderAttribRegistry.set_slot_sort")) {
    return nullptr;
  }
  // 1-void RenderAttribRegistry::set_slot_sort(int slot, int sort)
  int param1;
  int param2;
  static const char *keyword_list[] = {"slot", "sort", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_slot_sort", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_slot_sort)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slot_sort(const RenderAttribRegistry self, int slot, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttribRegistry_set_slot_sort_125_comment =
  "C++ Interface:\n"
  "set_slot_sort(const RenderAttribRegistry self, int slot, int sort)\n"
  "\n"
  "/**\n"
  " * Changes the sort number associated with slot n.\n"
  " */";
#else
static const char *Dtool_RenderAttribRegistry_set_slot_sort_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderAttrib const *RenderAttribRegistry::get_slot_default(int slot) const
 */
static PyObject *Dtool_RenderAttribRegistry_get_slot_default_126(PyObject *self, PyObject *arg) {
  RenderAttribRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttribRegistry)) {
    return nullptr;
  }
  // 1-inline RenderAttrib const *RenderAttribRegistry::get_slot_default(int slot) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    RenderAttrib const *return_value = ((*(const RenderAttribRegistry*)local_this).get_slot_default)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderAttrib, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_slot_default(RenderAttribRegistry self, int slot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttribRegistry_get_slot_default_126_comment =
  "C++ Interface:\n"
  "get_slot_default(RenderAttribRegistry self, int slot)\n"
  "\n"
  "/**\n"
  " * Returns the default RenderAttrib object associated with slot n.  This is\n"
  " * the attrib that should be applied in the absence of any other attrib of\n"
  " * this type.\n"
  " */";
#else
static const char *Dtool_RenderAttribRegistry_get_slot_default_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RenderAttribRegistry::get_num_sorted_slots(void) const
 */
static PyObject *Dtool_RenderAttribRegistry_get_num_sorted_slots_127(PyObject *self, PyObject *) {
  RenderAttribRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttribRegistry)) {
    return nullptr;
  }
  // 1-inline int RenderAttribRegistry::get_num_sorted_slots(void) const
  int return_value = ((*(const RenderAttribRegistry*)local_this).get_num_sorted_slots)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderAttribRegistry_get_num_sorted_slots_127_comment =
  "C++ Interface:\n"
  "get_num_sorted_slots(RenderAttribRegistry self)\n"
  "\n"
  "/**\n"
  " * Returns the number of entries in the sorted_slots list.\n"
  " */";
#else
static const char *Dtool_RenderAttribRegistry_get_num_sorted_slots_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RenderAttribRegistry::get_sorted_slot(int n) const
 */
static PyObject *Dtool_RenderAttribRegistry_get_sorted_slot_128(PyObject *self, PyObject *arg) {
  RenderAttribRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttribRegistry)) {
    return nullptr;
  }
  // 1-inline int RenderAttribRegistry::get_sorted_slot(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const RenderAttribRegistry*)local_this).get_sorted_slot)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sorted_slot(RenderAttribRegistry self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttribRegistry_get_sorted_slot_128_comment =
  "C++ Interface:\n"
  "get_sorted_slot(RenderAttribRegistry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth slot in sorted order.  By traversing this list, you will\n"
  " * retrieve all the slot numbers in order according to their registered sort\n"
  " * value.\n"
  " */";
#else
static const char *Dtool_RenderAttribRegistry_get_sorted_slot_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline RenderAttribRegistry *RenderAttribRegistry::get_global_ptr(void)
 */
static PyObject *Dtool_RenderAttribRegistry_get_global_ptr_129(PyObject *, PyObject *) {
  // 1-static inline RenderAttribRegistry *RenderAttribRegistry::get_global_ptr(void)
  RenderAttribRegistry *return_value = (RenderAttribRegistry::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_RenderAttribRegistry, false, false);
}

#ifndef NDEBUG
static const char *Dtool_RenderAttribRegistry_get_global_ptr_129_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_RenderAttribRegistry_get_global_ptr_129_comment = nullptr;
#endif

static int Dtool_Init_RenderAttribRegistry(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_RenderAttribRegistry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RenderAttribRegistry) {
    printf("RenderAttribRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RenderAttribRegistry *local_this = (RenderAttribRegistry *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RenderAttribRegistry) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RenderAttribRegistry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RenderAttribRegistry) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RenderAttrib
 */
/**
 * Python function wrapper for:
 * inline ConstPointerTo< RenderAttrib > RenderAttrib::compose(RenderAttrib const *other) const
 */
static PyObject *Dtool_RenderAttrib_compose_132(PyObject *self, PyObject *arg) {
  RenderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttrib)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< RenderAttrib > RenderAttrib::compose(RenderAttrib const *other) const
  RenderAttrib const *arg_this = (RenderAttrib *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderAttrib, 1, "RenderAttrib.compose", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const RenderAttrib*)local_this).compose)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compose(RenderAttrib self, const RenderAttrib other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_compose_132_comment =
  "C++ Interface:\n"
  "compose(RenderAttrib self, const RenderAttrib other)\n"
  "\n"
  "/**\n"
  " * Returns a new RenderAttrib object that represents the composition of this\n"
  " * attrib with the other attrib.  In most cases, this is the same as the other\n"
  " * attrib; a compose b produces b.  Some kinds of attributes, like a\n"
  " * TextureTransform, for instance, might produce a new result: a compose b\n"
  " * produces c.\n"
  " */";
#else
static const char *Dtool_RenderAttrib_compose_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< RenderAttrib > RenderAttrib::invert_compose(RenderAttrib const *other) const
 */
static PyObject *Dtool_RenderAttrib_invert_compose_133(PyObject *self, PyObject *arg) {
  RenderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttrib)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< RenderAttrib > RenderAttrib::invert_compose(RenderAttrib const *other) const
  RenderAttrib const *arg_this = (RenderAttrib *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderAttrib, 1, "RenderAttrib.invert_compose", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const RenderAttrib*)local_this).invert_compose)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_compose(RenderAttrib self, const RenderAttrib other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_invert_compose_133_comment =
  "C++ Interface:\n"
  "invert_compose(RenderAttrib self, const RenderAttrib other)\n"
  "\n"
  "/**\n"
  " * Returns a new RenderAttrib object that represents the composition of the\n"
  " * inverse of this attrib with the other attrib.  In most cases, this is the\n"
  " * same as the other attrib; !a compose b produces b.  Some kinds of\n"
  " * attributes, like a TextureTransform, for instance, might produce a new\n"
  " * result: !a compose b produces c.\n"
  " *\n"
  " * This is similar to compose() except that the source attrib is inverted\n"
  " * first.  This is used to compute the relative attribute for one node as\n"
  " * viewed from some other node, which is especially useful for transform-type\n"
  " * attributes.\n"
  " */";
#else
static const char *Dtool_RenderAttrib_invert_compose_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool RenderAttrib::lower_attrib_can_override(void) const
 */
static PyObject *Dtool_RenderAttrib_lower_attrib_can_override_134(PyObject *self, PyObject *) {
  RenderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttrib)) {
    return nullptr;
  }
  // 1-virtual bool RenderAttrib::lower_attrib_can_override(void) const
  bool return_value = ((*(const RenderAttrib*)local_this).lower_attrib_can_override)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_lower_attrib_can_override_134_comment =
  "C++ Interface:\n"
  "lower_attrib_can_override(RenderAttrib self)\n"
  "\n"
  "/**\n"
  " * Intended to be overridden by derived RenderAttrib types to specify how two\n"
  " * consecutive RenderAttrib objects of the same type interact.\n"
  " *\n"
  " * This should return false if a RenderAttrib on a higher node will compose\n"
  " * into a RenderAttrib on a lower node that has a higher override value, or\n"
  " * true if the lower RenderAttrib will completely replace the state.\n"
  " *\n"
  " * The default behavior is false: normally, a RenderAttrib in the graph cannot\n"
  " * completely override a RenderAttrib above it, regardless of its override\n"
  " * value--instead, the two attribs are composed.  But for some kinds of\n"
  " * RenderAttribs, it is useful to allow this kind of override.\n"
  " *\n"
  " * This method only handles the one special case of a lower RenderAttrib with\n"
  " * a higher override value.  If the higher RenderAttrib has a higher override\n"
  " * value, it always completely overrides.  And if both RenderAttribs have the\n"
  " * same override value, they are always composed.\n"
  " */";
#else
static const char *Dtool_RenderAttrib_lower_attrib_can_override_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RenderAttrib::compare_to(RenderAttrib const &other) const
 */
static PyObject *Dtool_RenderAttrib_compare_to_135(PyObject *self, PyObject *arg) {
  RenderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttrib)) {
    return nullptr;
  }
  // 1-inline int RenderAttrib::compare_to(RenderAttrib const &other) const
  RenderAttrib const *arg_this = (RenderAttrib *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderAttrib, 1, "RenderAttrib.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const RenderAttrib*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(RenderAttrib self, const RenderAttrib other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_compare_to_135_comment =
  "C++ Interface:\n"
  "compare_to(RenderAttrib self, const RenderAttrib other)\n"
  "\n"
  "/**\n"
  " * Provides an arbitrary ordering among all unique RenderAttribs, so we can\n"
  " * store the essentially different ones in a big set and throw away the rest.\n"
  " *\n"
  " * This method is not needed outside of the RenderAttrib class because all\n"
  " * equivalent RenderAttrib objects are guaranteed to share the same pointer;\n"
  " * thus, a pointer comparison is always sufficient.\n"
  " */";
#else
static const char *Dtool_RenderAttrib_compare_to_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t RenderAttrib::get_hash(void) const
 */
static PyObject *Dtool_RenderAttrib_get_hash_136(PyObject *self, PyObject *) {
  RenderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttrib)) {
    return nullptr;
  }
  // 1-inline std::size_t RenderAttrib::get_hash(void) const
  std::size_t return_value = ((*(const RenderAttrib*)local_this).get_hash)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_get_hash_136_comment =
  "C++ Interface:\n"
  "get_hash(RenderAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash value for phash_map.\n"
  " */";
#else
static const char *Dtool_RenderAttrib_get_hash_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< RenderAttrib > RenderAttrib::get_unique(void) const
 */
static PyObject *Dtool_RenderAttrib_get_unique_137(PyObject *self, PyObject *) {
  RenderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttrib)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< RenderAttrib > RenderAttrib::get_unique(void) const
  ConstPointerTo< RenderAttrib > return_value = ((*(const RenderAttrib*)local_this).get_unique)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_get_unique_137_comment =
  "C++ Interface:\n"
  "get_unique(RenderAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the unique RenderAttrib in the cache that is\n"
  " * equivalent to this one.  This may be the same pointer as this object, or it\n"
  " * may be a different pointer; but it will be an equivalent object, and it\n"
  " * will be a shared pointer.  This may be called from time to time to improve\n"
  " * cache benefits.\n"
  " */";
#else
static const char *Dtool_RenderAttrib_get_unique_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void RenderAttrib::output(std::ostream &out) const
 */
static PyObject *Dtool_RenderAttrib_output_138(PyObject *self, PyObject *arg) {
  RenderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttrib)) {
    return nullptr;
  }
  // 1-virtual void RenderAttrib::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "RenderAttrib.output", false, true);
  if (arg_this != nullptr) {
    ((*(const RenderAttrib*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(RenderAttrib self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_output_138_comment =
  "C++ Interface:\n"
  "output(RenderAttrib self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_RenderAttrib_output_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void RenderAttrib::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_RenderAttrib_write_139(PyObject *self, PyObject *args, PyObject *kwds) {
  RenderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttrib)) {
    return nullptr;
  }
  // 1-virtual void RenderAttrib::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "RenderAttrib.write", false, true);
    if (param1_this != nullptr) {
      ((*(const RenderAttrib*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(RenderAttrib self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_write_139_comment =
  "C++ Interface:\n"
  "write(RenderAttrib self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_RenderAttrib_write_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int RenderAttrib::get_num_attribs(void)
 */
static PyObject *Dtool_RenderAttrib_get_num_attribs_140(PyObject *, PyObject *) {
  // 1-static int RenderAttrib::get_num_attribs(void)
  int return_value = (RenderAttrib::get_num_attribs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_get_num_attribs_140_comment =
  "C++ Interface:\n"
  "get_num_attribs()\n"
  "\n"
  "/**\n"
  " * Returns the total number of unique RenderAttrib objects allocated in the\n"
  " * world.  This will go up and down during normal operations.\n"
  " */";
#else
static const char *Dtool_RenderAttrib_get_num_attribs_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void RenderAttrib::list_attribs(std::ostream &out)
 */
static PyObject *Dtool_RenderAttrib_list_attribs_141(PyObject *, PyObject *arg) {
  // 1-static void RenderAttrib::list_attribs(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "RenderAttrib.list_attribs", false, true);
  if (arg_this != nullptr) {
    (RenderAttrib::list_attribs)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_attribs(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_list_attribs_141_comment =
  "C++ Interface:\n"
  "list_attribs(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists all of the RenderAttribs in the cache to the output stream, one per\n"
  " * line.  This can be quite a lot of output if the cache is large, so be\n"
  " * prepared.\n"
  " */";
#else
static const char *Dtool_RenderAttrib_list_attribs_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int RenderAttrib::garbage_collect(void)
 */
static PyObject *Dtool_RenderAttrib_garbage_collect_142(PyObject *, PyObject *) {
  // 1-static int RenderAttrib::garbage_collect(void)
  int return_value = (RenderAttrib::garbage_collect)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_garbage_collect_142_comment =
  "C++ Interface:\n"
  "garbage_collect()\n"
  "\n"
  "/**\n"
  " * Performs a garbage-collection cycle.  This is called automatically from\n"
  " * RenderState::garbage_collect(); see that method for more information.\n"
  " */";
#else
static const char *Dtool_RenderAttrib_garbage_collect_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool RenderAttrib::validate_attribs(void)
 */
static PyObject *Dtool_RenderAttrib_validate_attribs_143(PyObject *, PyObject *) {
  // 1-static bool RenderAttrib::validate_attribs(void)
  bool return_value = (RenderAttrib::validate_attribs)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_validate_attribs_143_comment =
  "C++ Interface:\n"
  "validate_attribs()\n"
  "\n"
  "/**\n"
  " * Ensures that the cache is still stored in sorted order.  Returns true if\n"
  " * so, false if there is a problem (which implies someone has modified one of\n"
  " * the supposedly-const RenderAttrib objects).\n"
  " */";
#else
static const char *Dtool_RenderAttrib_validate_attribs_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int RenderAttrib::get_slot(void) const = 0
 */
static PyObject *Dtool_RenderAttrib_get_slot_144(PyObject *self, PyObject *) {
  RenderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderAttrib)) {
    return nullptr;
  }
  // 1-virtual int RenderAttrib::get_slot(void) const = 0
  int return_value = ((*(const RenderAttrib*)local_this).get_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_get_slot_144_comment =
  "C++ Interface:\n"
  "get_slot(RenderAttrib self)\n";
#else
static const char *Dtool_RenderAttrib_get_slot_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RenderAttrib::get_class_type(void)
 */
static PyObject *Dtool_RenderAttrib_get_class_type_149(PyObject *, PyObject *) {
  // 1-static TypeHandle RenderAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RenderAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RenderAttrib_get_class_type_149_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RenderAttrib_get_class_type_149_comment = nullptr;
#endif

static PyObject *Dtool_RenderAttrib_slot_Getter(PyObject *self, void *) {
  const RenderAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual int RenderAttrib::get_slot(void) const = 0
  int return_value = ((*(const RenderAttrib*)local_this).get_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_RenderAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_RenderAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RenderAttrib) {
    printf("RenderAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RenderAttrib *local_this = (RenderAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RenderAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RenderAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RenderAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RenderAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RenderAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RenderAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RenderModeAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > RenderModeAttrib::make(RenderModeAttrib::Mode mode, PN_stdfloat thickness = 1.0, bool perspective = false, LColor const &wireframe_color = LColor::zero())
 */
static PyObject *Dtool_RenderModeAttrib_make_152(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > RenderModeAttrib::make(RenderModeAttrib::Mode mode, PN_stdfloat thickness = 1.0, bool perspective = false, LColor const &wireframe_color = LColor::zero())
  int param0;
  float param1 = 1.0;
  PyObject *param2 = Py_False;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"mode", "thickness", "perspective", "wireframe_color", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|fOO:make", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVecBase4f param3_local;
    LColor const *param3_this;
    if (param3 != nullptr) {
      param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
    } else {
      param3_local = LVecBase4f::zero();
      param3_this = &param3_local;
    }
    if (param3 != nullptr && !(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "RenderModeAttrib.make", "LVecBase4f");
    }
    ConstPointerTo< RenderAttrib > return_value = (RenderModeAttrib::make)((RenderModeAttrib::Mode)param0, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0), *param3_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int mode, float thickness, bool perspective, const LVecBase4f wireframe_color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderModeAttrib_make_152_comment =
  "C++ Interface:\n"
  "make(int mode, float thickness, bool perspective, const LVecBase4f wireframe_color)\n"
  "\n"
  "/**\n"
  " * Constructs a new RenderModeAttrib object that specifies whether to draw\n"
  " * polygons in the normal, filled mode, or wireframe mode, or in some other\n"
  " * yet-to-be-defined mode.\n"
  " *\n"
  " * The thickness parameter specifies the thickness to be used for wireframe\n"
  " * lines, as well as for ordinary linestrip lines; it also specifies the\n"
  " * diameter of points.  (Thick lines are presently only supported in OpenGL;\n"
  " * but thick points are supported on either platform.)\n"
  " *\n"
  " * If perspective is true, the point thickness represented is actually a width\n"
  " * in 3-d units, and the points should scale according to perspective.  When\n"
  " * it is false, the point thickness is actually a width in pixels, and points\n"
  " * are a uniform screen size regardless of distance from the camera.\n"
  " *\n"
  " * In M_filled_wireframe mode, you should also specify the wireframe_color,\n"
  " * indicating the flat color to assign to the overlayed wireframe.\n"
  " */";
#else
static const char *Dtool_RenderModeAttrib_make_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > RenderModeAttrib::make_default(void)
 */
static PyObject *Dtool_RenderModeAttrib_make_default_153(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > RenderModeAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (RenderModeAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_RenderModeAttrib_make_default_153_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_RenderModeAttrib_make_default_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderModeAttrib::Mode RenderModeAttrib::get_mode(void) const
 */
static PyObject *Dtool_RenderModeAttrib_get_mode_154(PyObject *self, PyObject *) {
  RenderModeAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderModeAttrib)) {
    return nullptr;
  }
  // 1-inline RenderModeAttrib::Mode RenderModeAttrib::get_mode(void) const
  RenderModeAttrib::Mode return_value = ((*(const RenderModeAttrib*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderModeAttrib_get_mode_154_comment =
  "C++ Interface:\n"
  "get_mode(RenderModeAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the render mode.\n"
  " */";
#else
static const char *Dtool_RenderModeAttrib_get_mode_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat RenderModeAttrib::get_thickness(void) const
 */
static PyObject *Dtool_RenderModeAttrib_get_thickness_155(PyObject *self, PyObject *) {
  RenderModeAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderModeAttrib)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat RenderModeAttrib::get_thickness(void) const
  PN_stdfloat return_value = ((*(const RenderModeAttrib*)local_this).get_thickness)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderModeAttrib_get_thickness_155_comment =
  "C++ Interface:\n"
  "get_thickness(RenderModeAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the line width or point thickness.  This is only relevant when\n"
  " * rendering points or lines, such as when the mode is M_wireframe or M_point\n"
  " * (or when rendering actual points or lines primitives in M_polygon mode).\n"
  " */";
#else
static const char *Dtool_RenderModeAttrib_get_thickness_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RenderModeAttrib::get_perspective(void) const
 */
static PyObject *Dtool_RenderModeAttrib_get_perspective_156(PyObject *self, PyObject *) {
  RenderModeAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderModeAttrib)) {
    return nullptr;
  }
  // 1-inline bool RenderModeAttrib::get_perspective(void) const
  bool return_value = ((*(const RenderModeAttrib*)local_this).get_perspective)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderModeAttrib_get_perspective_156_comment =
  "C++ Interface:\n"
  "get_perspective(RenderModeAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the perspective flag.  When this is true, the point thickness\n"
  " * represented by get_thickness() is actually a width in 3-d units, and the\n"
  " * points should scale according to perspective.  When it is false, the\n"
  " * default, the point thickness is actually a width in pixels, and points are\n"
  " * a uniform size regardless of distance from the camera.\n"
  " */";
#else
static const char *Dtool_RenderModeAttrib_get_perspective_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &RenderModeAttrib::get_wireframe_color(void) const
 */
static PyObject *Dtool_RenderModeAttrib_get_wireframe_color_157(PyObject *self, PyObject *) {
  RenderModeAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderModeAttrib)) {
    return nullptr;
  }
  // 1-inline LColor const &RenderModeAttrib::get_wireframe_color(void) const
  LColor const *return_value = &(((*(const RenderModeAttrib*)local_this).get_wireframe_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RenderModeAttrib_get_wireframe_color_157_comment =
  "C++ Interface:\n"
  "get_wireframe_color(RenderModeAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the color that is used in M_filled_wireframe mode to distinguish\n"
  " * the wireframe from the rest of the geometry.\n"
  " */";
#else
static const char *Dtool_RenderModeAttrib_get_wireframe_color_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RenderModeAttrib::get_geom_rendering(int geom_rendering) const
 */
static PyObject *Dtool_RenderModeAttrib_get_geom_rendering_158(PyObject *self, PyObject *arg) {
  RenderModeAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderModeAttrib)) {
    return nullptr;
  }
  // 1-inline int RenderModeAttrib::get_geom_rendering(int geom_rendering) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const RenderModeAttrib*)local_this).get_geom_rendering)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geom_rendering(RenderModeAttrib self, int geom_rendering)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderModeAttrib_get_geom_rendering_158_comment =
  "C++ Interface:\n"
  "get_geom_rendering(RenderModeAttrib self, int geom_rendering)\n"
  "\n"
  "/**\n"
  " * Returns the union of the Geom::GeomRendering bits that will be required\n"
  " * once this RenderModeAttrib is applied to a geom which includes the\n"
  " * indicated geom_rendering bits.\n"
  " */";
#else
static const char *Dtool_RenderModeAttrib_get_geom_rendering_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int RenderModeAttrib::get_class_slot(void)
 */
static PyObject *Dtool_RenderModeAttrib_get_class_slot_170(PyObject *, PyObject *) {
  // 1-static int RenderModeAttrib::get_class_slot(void)
  int return_value = (RenderModeAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderModeAttrib_get_class_slot_170_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_RenderModeAttrib_get_class_slot_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RenderModeAttrib::get_class_type(void)
 */
static PyObject *Dtool_RenderModeAttrib_get_class_type_172(PyObject *, PyObject *) {
  // 1-static TypeHandle RenderModeAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RenderModeAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RenderModeAttrib_get_class_type_172_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RenderModeAttrib_get_class_type_172_comment = nullptr;
#endif

static PyObject *Dtool_RenderModeAttrib_mode_Getter(PyObject *self, void *) {
  const RenderModeAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderModeAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline RenderModeAttrib::Mode RenderModeAttrib::get_mode(void) const
  RenderModeAttrib::Mode return_value = ((*(const RenderModeAttrib*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_RenderModeAttrib_thickness_Getter(PyObject *self, void *) {
  const RenderModeAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderModeAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat RenderModeAttrib::get_thickness(void) const
  PN_stdfloat return_value = ((*(const RenderModeAttrib*)local_this).get_thickness)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_RenderModeAttrib_perspective_Getter(PyObject *self, void *) {
  const RenderModeAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderModeAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool RenderModeAttrib::get_perspective(void) const
  bool return_value = ((*(const RenderModeAttrib*)local_this).get_perspective)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_RenderModeAttrib_wireframe_color_Getter(PyObject *self, void *) {
  const RenderModeAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderModeAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor const &RenderModeAttrib::get_wireframe_color(void) const
  LColor const *return_value = &(((*(const RenderModeAttrib*)local_this).get_wireframe_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static PyObject *Dtool_RenderModeAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int RenderModeAttrib::get_class_slot(void)
  int return_value = (RenderModeAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_RenderModeAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_RenderModeAttrib(PyObject *args, CPT(RenderModeAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_RenderModeAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > RenderModeAttrib::make(RenderModeAttrib::Mode mode, PN_stdfloat thickness, bool perspective, LColor const &wireframe_color)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (RenderModeAttrib::make)((RenderModeAttrib::Mode)arg_val);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((RenderModeAttrib const *) return_value.p());
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      // 1-static ConstPointerTo< RenderAttrib > RenderModeAttrib::make(RenderModeAttrib::Mode mode, PN_stdfloat thickness, bool perspective = false, LColor const &wireframe_color = LColor::zero())
      int param0;
      float param1;
      PyObject *param2 = Py_False;
      PyObject *param3 = nullptr;
      if (PyArg_ParseTuple(args, "if|OO:make", &param0, &param1, &param2, &param3)) {
        LColor const *param3_this;
        const LVecBase4f &param3_ref = LVecBase4f::zero();
        if (param3 == nullptr) {
          param3_this = &param3_ref;
        } else {
          param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase4f);
        }
        if ((param3 == nullptr || param3_this != nullptr)) {
          ConstPointerTo< RenderAttrib > return_value = (RenderModeAttrib::make)((RenderModeAttrib::Mode)param0, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0), *param3_this);
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move((RenderModeAttrib const *) return_value.p());
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_RenderModeAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RenderModeAttrib) {
    printf("RenderModeAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RenderModeAttrib *local_this = (RenderModeAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RenderModeAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RenderModeAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RenderModeAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RenderModeAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (RenderModeAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RenderModeAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RenderModeAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RenderModeAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TexMatrixAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > TexMatrixAttrib::make(void)
 * static ConstPointerTo< RenderAttrib > TexMatrixAttrib::make(LMatrix4 const &mat)
 * static ConstPointerTo< RenderAttrib > TexMatrixAttrib::make(TextureStage *stage, TransformState const *transform)
 */
static PyObject *Dtool_TexMatrixAttrib_make_175(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-static ConstPointerTo< RenderAttrib > TexMatrixAttrib::make(void)
      ConstPointerTo< RenderAttrib > return_value = (TexMatrixAttrib::make)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "mat")) {
        // 1-static ConstPointerTo< RenderAttrib > TexMatrixAttrib::make(LMatrix4 const &mat)
        LMatrix4f arg_local;
        LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 0, "TexMatrixAttrib.make", "LMatrix4f");
        }
        ConstPointerTo< RenderAttrib > return_value = (TexMatrixAttrib::make)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderAttrib const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 2:
    {
      // 1-static ConstPointerTo< RenderAttrib > TexMatrixAttrib::make(TextureStage *stage, TransformState const *transform)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"stage", "transform", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make", (char **)keyword_list, &param0, &param1)) {
        TextureStage *param0_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TextureStage, 0, "TexMatrixAttrib.make", false, true);
        TransformState const *param1_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TransformState, 1, "TexMatrixAttrib.make", true, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (TexMatrixAttrib::make)(param0_this, param1_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 0, 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make()\n"
      "make(const LMatrix4f mat)\n"
      "make(TextureStage stage, const TransformState transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_make_175_comment =
  "C++ Interface:\n"
  "make()\n"
  "make(const LMatrix4f mat)\n"
  "make(TextureStage stage, const TransformState transform)\n"
  "\n"
  "/**\n"
  " * Constructs a TexMatrixAttrib that applies no stages at all.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a TexMatrixAttrib that applies the indicated matrix to the\n"
  " * default texture stage.  This interface is deprecated.\n"
  " *\n"
  " * @deprecated Use the constructor that takes a TextureStage instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a TexMatrixAttrib that applies the indicated transform to the\n"
  " * named texture stage.\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_make_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > TexMatrixAttrib::make_default(void)
 */
static PyObject *Dtool_TexMatrixAttrib_make_default_176(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > TexMatrixAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (TexMatrixAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_make_default_176_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_make_default_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > TexMatrixAttrib::add_stage(TextureStage *stage, TransformState const *transform, int override = 0) const
 */
static PyObject *Dtool_TexMatrixAttrib_add_stage_177(PyObject *self, PyObject *args, PyObject *kwds) {
  TexMatrixAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexMatrixAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > TexMatrixAttrib::add_stage(TextureStage *stage, TransformState const *transform, int override = 0) const
  PyObject *param1;
  PyObject *param2;
  int param3 = 0;
  static const char *keyword_list[] = {"stage", "transform", "override", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:add_stage", (char **)keyword_list, &param1, &param2, &param3)) {
    TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "TexMatrixAttrib.add_stage", false, true);
    TransformState const *param2_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TransformState, 2, "TexMatrixAttrib.add_stage", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = ((*(const TexMatrixAttrib*)local_this).add_stage)(param1_this, param2_this, (int)param3);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_stage(TexMatrixAttrib self, TextureStage stage, const TransformState transform, int override)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_add_stage_177_comment =
  "C++ Interface:\n"
  "add_stage(TexMatrixAttrib self, TextureStage stage, const TransformState transform, int override)\n"
  "\n"
  "/**\n"
  " * Returns a new TexMatrixAttrib just like this one, with the indicated\n"
  " * transform for the given stage.  If this stage already exists, its transform\n"
  " * is replaced.\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_add_stage_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > TexMatrixAttrib::remove_stage(TextureStage *stage) const
 */
static PyObject *Dtool_TexMatrixAttrib_remove_stage_178(PyObject *self, PyObject *arg) {
  TexMatrixAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexMatrixAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > TexMatrixAttrib::remove_stage(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexMatrixAttrib.remove_stage", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const TexMatrixAttrib*)local_this).remove_stage)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_stage(TexMatrixAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_remove_stage_178_comment =
  "C++ Interface:\n"
  "remove_stage(TexMatrixAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns a new TexMatrixAttrib just like this one, with the indicated stage\n"
  " * removed.\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_remove_stage_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TexMatrixAttrib::is_empty(void) const
 */
static PyObject *Dtool_TexMatrixAttrib_is_empty_179(PyObject *self, PyObject *) {
  TexMatrixAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexMatrixAttrib)) {
    return nullptr;
  }
  // 1-bool TexMatrixAttrib::is_empty(void) const
  bool return_value = ((*(const TexMatrixAttrib*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_is_empty_179_comment =
  "C++ Interface:\n"
  "is_empty(TexMatrixAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if no stages are defined in the TexMatrixAttrib, false if at\n"
  " * least one is.\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_is_empty_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TexMatrixAttrib::has_stage(TextureStage *stage) const
 */
static PyObject *Dtool_TexMatrixAttrib_has_stage_180(PyObject *self, PyObject *arg) {
  TexMatrixAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexMatrixAttrib)) {
    return nullptr;
  }
  // 1-bool TexMatrixAttrib::has_stage(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexMatrixAttrib.has_stage", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const TexMatrixAttrib*)local_this).has_stage)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_stage(TexMatrixAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_has_stage_180_comment =
  "C++ Interface:\n"
  "has_stage(TexMatrixAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a transform associated with the indicated stage,\n"
  " * or false otherwise (in which case get_transform(stage) will return the\n"
  " * identity transform).\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_has_stage_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TexMatrixAttrib::get_num_stages(void) const
 */
static PyObject *Dtool_TexMatrixAttrib_get_num_stages_181(PyObject *self, PyObject *) {
  TexMatrixAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexMatrixAttrib)) {
    return nullptr;
  }
  // 1-int TexMatrixAttrib::get_num_stages(void) const
  int return_value = ((*(const TexMatrixAttrib*)local_this).get_num_stages)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_get_num_stages_181_comment =
  "C++ Interface:\n"
  "get_num_stages(TexMatrixAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of stages that are represented by this attrib.\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_get_num_stages_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextureStage *TexMatrixAttrib::get_stage(int n) const
 */
static PyObject *Dtool_TexMatrixAttrib_get_stage_182(PyObject *self, PyObject *arg) {
  TexMatrixAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexMatrixAttrib)) {
    return nullptr;
  }
  // 1-TextureStage *TexMatrixAttrib::get_stage(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TextureStage *return_value = ((*(const TexMatrixAttrib*)local_this).get_stage)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_stage(TexMatrixAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_get_stage_182_comment =
  "C++ Interface:\n"
  "get_stage(TexMatrixAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth stage that is represented by this attrib.  The\n"
  " * TextureStages are in no particular order.\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_get_stage_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LMatrix4 const &TexMatrixAttrib::get_mat(void) const
 * LMatrix4 const &TexMatrixAttrib::get_mat(TextureStage *stage) const
 */
static PyObject *Dtool_TexMatrixAttrib_get_mat_184(PyObject *self, PyObject *args) {
  TexMatrixAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexMatrixAttrib)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-LMatrix4 const &TexMatrixAttrib::get_mat(void) const
      LMatrix4 const *return_value = &(((*(const TexMatrixAttrib*)local_this).get_mat)());
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-LMatrix4 const &TexMatrixAttrib::get_mat(TextureStage *stage) const
      TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexMatrixAttrib.get_mat", false, true);
      if (arg_this != nullptr) {
        LMatrix4 const *return_value = &(((*(const TexMatrixAttrib*)local_this).get_mat)(arg_this));
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_mat() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mat(TexMatrixAttrib self)\n"
      "get_mat(TexMatrixAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_get_mat_184_comment =
  "C++ Interface:\n"
  "get_mat(TexMatrixAttrib self)\n"
  "get_mat(TexMatrixAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the transformation matrix associated with the default texture\n"
  " * stage.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the transformation matrix associated with the indicated texture\n"
  " * stage, or identity matrix if nothing is associated with the indicated\n"
  " * stage.\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_get_mat_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > TexMatrixAttrib::get_transform(TextureStage *stage) const
 */
static PyObject *Dtool_TexMatrixAttrib_get_transform_185(PyObject *self, PyObject *arg) {
  TexMatrixAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexMatrixAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > TexMatrixAttrib::get_transform(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexMatrixAttrib.get_transform", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< TransformState > return_value = ((*(const TexMatrixAttrib*)local_this).get_transform)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_transform(TexMatrixAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_get_transform_185_comment =
  "C++ Interface:\n"
  "get_transform(TexMatrixAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the transformation associated with the indicated texture stage, or\n"
  " * identity matrix if nothing is associated with the indicated stage.\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_get_transform_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TexMatrixAttrib::get_override(TextureStage *stage) const
 */
static PyObject *Dtool_TexMatrixAttrib_get_override_186(PyObject *self, PyObject *arg) {
  TexMatrixAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexMatrixAttrib)) {
    return nullptr;
  }
  // 1-inline int TexMatrixAttrib::get_override(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexMatrixAttrib.get_override", false, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const TexMatrixAttrib*)local_this).get_override)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_override(TexMatrixAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_get_override_186_comment =
  "C++ Interface:\n"
  "get_override(TexMatrixAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the override value associated with the indicated stage.\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_get_override_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TexMatrixAttrib::get_geom_rendering(int geom_rendering) const
 */
static PyObject *Dtool_TexMatrixAttrib_get_geom_rendering_187(PyObject *self, PyObject *arg) {
  TexMatrixAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexMatrixAttrib)) {
    return nullptr;
  }
  // 1-inline int TexMatrixAttrib::get_geom_rendering(int geom_rendering) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const TexMatrixAttrib*)local_this).get_geom_rendering)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geom_rendering(TexMatrixAttrib self, int geom_rendering)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_get_geom_rendering_187_comment =
  "C++ Interface:\n"
  "get_geom_rendering(TexMatrixAttrib self, int geom_rendering)\n"
  "\n"
  "/**\n"
  " * Returns the union of the Geom::GeomRendering bits that will be required\n"
  " * once this TexMatrixAttrib is applied to a geom which includes the indicated\n"
  " * geom_rendering bits.\n"
  " */";
#else
static const char *Dtool_TexMatrixAttrib_get_geom_rendering_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int TexMatrixAttrib::get_class_slot(void)
 */
static PyObject *Dtool_TexMatrixAttrib_get_class_slot_188(PyObject *, PyObject *) {
  // 1-static int TexMatrixAttrib::get_class_slot(void)
  int return_value = (TexMatrixAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_get_class_slot_188_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_TexMatrixAttrib_get_class_slot_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TexMatrixAttrib::get_class_type(void)
 */
static PyObject *Dtool_TexMatrixAttrib_get_class_type_190(PyObject *, PyObject *) {
  // 1-static TypeHandle TexMatrixAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TexMatrixAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TexMatrixAttrib_get_class_type_190_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TexMatrixAttrib_get_class_type_190_comment = nullptr;
#endif

static PyObject *Dtool_TexMatrixAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int TexMatrixAttrib::get_class_slot(void)
  int return_value = (TexMatrixAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_TexMatrixAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_TexMatrixAttrib(PyObject *args, CPT(TexMatrixAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_TexMatrixAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > TexMatrixAttrib::make(LMatrix4 const &mat)
    LMatrix4 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix4f);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = (TexMatrixAttrib::make)(*arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((TexMatrixAttrib const *) return_value.p());
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-static ConstPointerTo< RenderAttrib > TexMatrixAttrib::make(TextureStage *stage, TransformState const *transform)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "make", 2, 2, &param0, &param1)) {
        TextureStage *param0_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TextureStage, 0, "TexMatrixAttrib.make", false, false);
        TransformState const *param1_this = nullptr;
        DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_TransformState);
        if (param0_this != nullptr && param1_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (TexMatrixAttrib::make)(param0_this, param1_this);
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move((TexMatrixAttrib const *) return_value.p());
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TexMatrixAttrib_get_stages(PyObject *self, PyObject *) {
  TexMatrixAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TexMatrixAttrib, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_stages)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TexMatrixAttrib_get_stage_182(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_TexMatrixAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TexMatrixAttrib) {
    printf("TexMatrixAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TexMatrixAttrib *local_this = (TexMatrixAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TexMatrixAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TexMatrixAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TexMatrixAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TexMatrixAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (TexMatrixAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TexMatrixAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TexMatrixAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TexMatrixAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RenderState
 */
/**
 * Python function wrapper for:
 * int RenderState::compare_to(RenderState const &other) const
 */
static PyObject *Dtool_RenderState_compare_to_192(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-int RenderState::compare_to(RenderState const &other) const
  CPT(RenderState) arg_this;
  if (!Dtool_ConstCoerce_RenderState(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RenderState.compare_to", "RenderState");
  }
  int return_value = ((*(const RenderState*)local_this).compare_to)(*std::move(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(RenderState self, const RenderState other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_compare_to_192_comment =
  "C++ Interface:\n"
  "compare_to(RenderState self, const RenderState other)\n"
  "\n"
  "/**\n"
  " * Provides an arbitrary ordering among all unique RenderStates, so we can\n"
  " * store the essentially different ones in a big set and throw away the rest.\n"
  " *\n"
  " * This method is not needed outside of the RenderState class because all\n"
  " * equivalent RenderState objects are guaranteed to share the same pointer;\n"
  " * thus, a pointer comparison is always sufficient.\n"
  " */";
#else
static const char *Dtool_RenderState_compare_to_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int RenderState::compare_sort(RenderState const &other) const
 */
static PyObject *Dtool_RenderState_compare_sort_193(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-int RenderState::compare_sort(RenderState const &other) const
  CPT(RenderState) arg_this;
  if (!Dtool_ConstCoerce_RenderState(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RenderState.compare_sort", "RenderState");
  }
  int return_value = ((*(const RenderState*)local_this).compare_sort)(*std::move(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_sort(RenderState self, const RenderState other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_compare_sort_193_comment =
  "C++ Interface:\n"
  "compare_sort(RenderState self, const RenderState other)\n"
  "\n"
  "/**\n"
  " * Returns -1, 0, or 1 according to the relative sorting of these two\n"
  " * RenderStates, with regards to rendering performance, so that \"heavier\"\n"
  " * RenderAttribs (as defined by RenderAttribRegistry::get_slot_sort()) are\n"
  " * more likely to be grouped together.  This is not related to the sorting\n"
  " * order defined by compare_to.\n"
  " */";
#else
static const char *Dtool_RenderState_compare_sort_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int RenderState::compare_mask(RenderState const &other, RenderState::SlotMask compare_mask) const
 */
static PyObject *Dtool_RenderState_compare_mask_194(PyObject *self, PyObject *args, PyObject *kwds) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-int RenderState::compare_mask(RenderState const &other, RenderState::SlotMask compare_mask) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"other", "compare_mask", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:compare_mask", (char **)keyword_list, &param1, &param2)) {
    CPT(RenderState) param1_this;
    if (!Dtool_ConstCoerce_RenderState(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "RenderState.compare_mask", "RenderState");
    }
    BitMask< uint32_t, 32 > param2_local;
    RenderState::SlotMask *param2_this = Dtool_Coerce_BitMask_uint32_t_32(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "RenderState.compare_mask", "BitMask");
    }
    int return_value = ((*(const RenderState*)local_this).compare_mask)(*std::move(param1_this), *param2_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_mask(RenderState self, const RenderState other, BitMask compare_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_compare_mask_194_comment =
  "C++ Interface:\n"
  "compare_mask(RenderState self, const RenderState other, BitMask compare_mask)\n"
  "\n"
  "/**\n"
  " * This version of compare_to takes a slot mask that indicates which\n"
  " * attributes to include in the comparison.  Unlike compare_to, this method\n"
  " * compares the attributes by pointer.\n"
  " */";
#else
static const char *Dtool_RenderState_compare_mask_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t RenderState::get_hash(void) const
 */
static PyObject *Dtool_RenderState_get_hash_195(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline std::size_t RenderState::get_hash(void) const
  std::size_t return_value = ((*(const RenderState*)local_this).get_hash)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_hash_195_comment =
  "C++ Interface:\n"
  "get_hash(RenderState self)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash value for phash_map.\n"
  " */";
#else
static const char *Dtool_RenderState_get_hash_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RenderState::is_empty(void) const
 */
static PyObject *Dtool_RenderState_is_empty_196(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline bool RenderState::is_empty(void) const
  bool return_value = ((*(const RenderState*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_is_empty_196_comment =
  "C++ Interface:\n"
  "is_empty(RenderState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the state is empty, false otherwise.\n"
  " */";
#else
static const char *Dtool_RenderState_is_empty_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RenderState::has_cull_callback(void) const
 */
static PyObject *Dtool_RenderState_has_cull_callback_197(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline bool RenderState::has_cull_callback(void) const
  bool return_value = ((*(const RenderState*)local_this).has_cull_callback)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_has_cull_callback_197_comment =
  "C++ Interface:\n"
  "has_cull_callback(RenderState self)\n"
  "\n"
  "/**\n"
  " * Returns true if any of the RenderAttribs in this state request a\n"
  " * cull_callback(), false if none of them do.\n"
  " */";
#else
static const char *Dtool_RenderState_has_cull_callback_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool RenderState::cull_callback(CullTraverser *trav, CullTraverserData const &data) const
 */
static PyObject *Dtool_RenderState_cull_callback_198(PyObject *self, PyObject *args, PyObject *kwds) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-bool RenderState::cull_callback(CullTraverser *trav, CullTraverserData const &data) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"trav", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:cull_callback", (char **)keyword_list, &param1, &param2)) {
    CullTraverser *param1_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_CullTraverser, 1, "RenderState.cull_callback", false, true);
    CullTraverserData const *param2_this = (CullTraverserData *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_CullTraverserData, 2, "RenderState.cull_callback", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      bool return_value = ((*(const RenderState*)local_this).cull_callback)(param1_this, *param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cull_callback(RenderState self, CullTraverser trav, const CullTraverserData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_cull_callback_198_comment =
  "C++ Interface:\n"
  "cull_callback(RenderState self, CullTraverser trav, const CullTraverserData data)\n"
  "\n"
  "/**\n"
  " * Calls cull_callback() on each attrib.  If any attrib returns false,\n"
  " * interrupts the list and returns false immediately; otherwise, completes the\n"
  " * list and returns true.\n"
  " */";
#else
static const char *Dtool_RenderState_cull_callback_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< RenderState > RenderState::make_empty(void)
 */
static PyObject *Dtool_RenderState_make_empty_199(PyObject *, PyObject *) {
  // 1-static inline ConstPointerTo< RenderState > RenderState::make_empty(void)
  ConstPointerTo< RenderState > return_value = (RenderState::make_empty)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_RenderState_make_empty_199_comment =
  "C++ Interface:\n"
  "make_empty()\n"
  "\n"
  "/**\n"
  " * Returns a RenderState with no attributes set.\n"
  " */";
#else
static const char *Dtool_RenderState_make_empty_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, RenderAttrib const *attrib5, int override = 0)
 * static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, int override = 0)
 * static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, int override = 0)
 * static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, int override = 0)
 * static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib, int override = 0)
 */
static PyObject *Dtool_RenderState_make_200(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "attrib")) {
        // 1-static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib, int override)
        RenderAttrib const *arg_this = (RenderAttrib *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderAttrib, 0, "RenderState.make", true, true);
        if (arg_this != nullptr) {
          ConstPointerTo< RenderState > return_value = (RenderState::make)(arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderState const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 2:
    {
      {
        // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, int override)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"attrib1", "attrib2", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make", (char **)keyword_list, &param0, &param1)) {
          RenderAttrib const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
          if (param0_this != nullptr && param1_this != nullptr) {
            ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderState const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib, int override)
        PyObject *param0;
        int param1;
        static const char *keyword_list[] = {"attrib", "override", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:make", (char **)keyword_list, &param0, &param1)) {
          RenderAttrib const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
          if (param0_this != nullptr) {
            ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, (int)param1);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderState const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, int override)
      // No coercion possible: static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib, int override)
    }
    break;
  case 3:
    {
      {
        // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, int override)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"attrib1", "attrib2", "attrib3", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:make", (char **)keyword_list, &param0, &param1, &param2)) {
          RenderAttrib const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderAttrib);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, param2_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderState const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, int override)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"attrib1", "attrib2", "override", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:make", (char **)keyword_list, &param0, &param1, &param2)) {
          RenderAttrib const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
          if (param0_this != nullptr && param1_this != nullptr) {
            ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, (int)param2);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderState const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, int override)
      // No coercion possible: static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, int override)
    }
    break;
  case 4:
    {
      {
        // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, int override)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"attrib1", "attrib2", "attrib3", "attrib4", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:make", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          RenderAttrib const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_RenderAttrib);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, param2_this, param3_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderState const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, int override)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"attrib1", "attrib2", "attrib3", "override", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:make", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          RenderAttrib const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderAttrib);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, param2_this, (int)param3);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderState const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, int override)
      // No coercion possible: static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, int override)
    }
    break;
  case 5:
  case 6:
    {
      {
        // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, RenderAttrib const *attrib5, int override = 0)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5 = 0;
        static const char *keyword_list[] = {"attrib1", "attrib2", "attrib3", "attrib4", "attrib5", "override", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO|i:make", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          RenderAttrib const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_RenderAttrib);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr && param4_this != nullptr) {
            ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, param2_this, param3_this, param4_this, (int)param5);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderState const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, int override = 0)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"attrib1", "attrib2", "attrib3", "attrib4", "override", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:make", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          RenderAttrib const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderAttrib);
          RenderAttrib const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_RenderAttrib);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, param2_this, param3_this, (int)param4);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderState const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, RenderAttrib const *attrib5, int override = 0)
      // No coercion possible: static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, int override = 0)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 1, 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const RenderAttrib attrib)\n"
      "make(const RenderAttrib attrib1, const RenderAttrib attrib2)\n"
      "make(const RenderAttrib attrib, int override)\n"
      "make(const RenderAttrib attrib1, const RenderAttrib attrib2, const RenderAttrib attrib3)\n"
      "make(const RenderAttrib attrib1, const RenderAttrib attrib2, int override)\n"
      "make(const RenderAttrib attrib1, const RenderAttrib attrib2, const RenderAttrib attrib3, const RenderAttrib attrib4)\n"
      "make(const RenderAttrib attrib1, const RenderAttrib attrib2, const RenderAttrib attrib3, int override)\n"
      "make(const RenderAttrib attrib1, const RenderAttrib attrib2, const RenderAttrib attrib3, const RenderAttrib attrib4, const RenderAttrib attrib5, int override)\n"
      "make(const RenderAttrib attrib1, const RenderAttrib attrib2, const RenderAttrib attrib3, const RenderAttrib attrib4, int override)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_make_200_comment =
  "C++ Interface:\n"
  "make(const RenderAttrib attrib)\n"
  "make(const RenderAttrib attrib1, const RenderAttrib attrib2)\n"
  "make(const RenderAttrib attrib, int override)\n"
  "make(const RenderAttrib attrib1, const RenderAttrib attrib2, const RenderAttrib attrib3)\n"
  "make(const RenderAttrib attrib1, const RenderAttrib attrib2, int override)\n"
  "make(const RenderAttrib attrib1, const RenderAttrib attrib2, const RenderAttrib attrib3, const RenderAttrib attrib4)\n"
  "make(const RenderAttrib attrib1, const RenderAttrib attrib2, const RenderAttrib attrib3, int override)\n"
  "make(const RenderAttrib attrib1, const RenderAttrib attrib2, const RenderAttrib attrib3, const RenderAttrib attrib4, const RenderAttrib attrib5, int override)\n"
  "make(const RenderAttrib attrib1, const RenderAttrib attrib2, const RenderAttrib attrib3, const RenderAttrib attrib4, int override)\n"
  "\n"
  "/**\n"
  " * Returns a RenderState with one attribute set.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a RenderState with two attributes set.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a RenderState with three attributes set.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a RenderState with four attributes set.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a RenderState with five attributes set.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a RenderState with n attributes set.\n"
  " */";
#else
static const char *Dtool_RenderState_make_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderState > RenderState::compose(RenderState const *other) const
 */
static PyObject *Dtool_RenderState_compose_201(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderState > RenderState::compose(RenderState const *other) const
  CPT(RenderState) arg_this;
  if (!Dtool_ConstCoerce_RenderState(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RenderState.compose", "RenderState");
  }
  ConstPointerTo< RenderState > return_value = ((*(const RenderState*)local_this).compose)(std::move(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compose(RenderState self, const RenderState other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_compose_201_comment =
  "C++ Interface:\n"
  "compose(RenderState self, const RenderState other)\n"
  "\n"
  "/**\n"
  " * Returns a new RenderState object that represents the composition of this\n"
  " * state with the other state.\n"
  " *\n"
  " * The result of this operation is cached, and will be retained as long as\n"
  " * both this RenderState object and the other RenderState object continue to\n"
  " * exist.  Should one of them destruct, the cached entry will be removed, and\n"
  " * its pointer will be allowed to destruct as well.\n"
  " */";
#else
static const char *Dtool_RenderState_compose_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderState > RenderState::invert_compose(RenderState const *other) const
 */
static PyObject *Dtool_RenderState_invert_compose_202(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderState > RenderState::invert_compose(RenderState const *other) const
  CPT(RenderState) arg_this;
  if (!Dtool_ConstCoerce_RenderState(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RenderState.invert_compose", "RenderState");
  }
  ConstPointerTo< RenderState > return_value = ((*(const RenderState*)local_this).invert_compose)(std::move(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_compose(RenderState self, const RenderState other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_invert_compose_202_comment =
  "C++ Interface:\n"
  "invert_compose(RenderState self, const RenderState other)\n"
  "\n"
  "/**\n"
  " * Returns a new RenderState object that represents the composition of this\n"
  " * state's inverse with the other state.\n"
  " *\n"
  " * This is similar to compose(), but is particularly useful for computing the\n"
  " * relative state of a node as viewed from some other node.\n"
  " */";
#else
static const char *Dtool_RenderState_invert_compose_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderState > RenderState::add_attrib(RenderAttrib const *attrib, int override = 0) const
 */
static PyObject *Dtool_RenderState_add_attrib_203(PyObject *self, PyObject *args, PyObject *kwds) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderState > RenderState::add_attrib(RenderAttrib const *attrib, int override = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"attrib", "override", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:add_attrib", (char **)keyword_list, &param1, &param2)) {
    RenderAttrib const *param1_this = (RenderAttrib *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_RenderAttrib, 1, "RenderState.add_attrib", true, true);
    if (param1_this != nullptr) {
      ConstPointerTo< RenderState > return_value = ((*(const RenderState*)local_this).add_attrib)(param1_this, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_attrib(RenderState self, const RenderAttrib attrib, int override)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_add_attrib_203_comment =
  "C++ Interface:\n"
  "add_attrib(RenderState self, const RenderAttrib attrib, int override)\n"
  "\n"
  "/**\n"
  " * Returns a new RenderState object that represents the same as the source\n"
  " * state, with the new RenderAttrib added.  If there is already a RenderAttrib\n"
  " * with the same type, it is replaced (unless the override is lower).\n"
  " */";
#else
static const char *Dtool_RenderState_add_attrib_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderState > RenderState::set_attrib(RenderAttrib const *attrib) const
 * ConstPointerTo< RenderState > RenderState::set_attrib(RenderAttrib const *attrib, int override) const
 */
static PyObject *Dtool_RenderState_set_attrib_204(PyObject *self, PyObject *args, PyObject *kwds) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "attrib")) {
        // 1-ConstPointerTo< RenderState > RenderState::set_attrib(RenderAttrib const *attrib) const
        RenderAttrib const *arg_this = (RenderAttrib *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderAttrib, 1, "RenderState.set_attrib", true, true);
        if (arg_this != nullptr) {
          ConstPointerTo< RenderState > return_value = ((*(const RenderState*)local_this).set_attrib)(arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderState const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 2:
    {
      // 1-ConstPointerTo< RenderState > RenderState::set_attrib(RenderAttrib const *attrib, int override) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"attrib", "override", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_attrib", (char **)keyword_list, &param1, &param2)) {
        RenderAttrib const *param1_this = (RenderAttrib *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_RenderAttrib, 1, "RenderState.set_attrib", true, true);
        if (param1_this != nullptr) {
          ConstPointerTo< RenderState > return_value = ((*(const RenderState*)local_this).set_attrib)(param1_this, (int)param2);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderState const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_attrib() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_attrib(RenderState self, const RenderAttrib attrib)\n"
      "set_attrib(RenderState self, const RenderAttrib attrib, int override)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_set_attrib_204_comment =
  "C++ Interface:\n"
  "set_attrib(RenderState self, const RenderAttrib attrib)\n"
  "set_attrib(RenderState self, const RenderAttrib attrib, int override)\n"
  "\n"
  "/**\n"
  " * Returns a new RenderState object that represents the same as the source\n"
  " * state, with the new RenderAttrib added.  If there is already a RenderAttrib\n"
  " * with the same type, it is replaced unconditionally.  The override is not\n"
  " * changed.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a new RenderState object that represents the same as the source\n"
  " * state, with the new RenderAttrib added.  If there is already a RenderAttrib\n"
  " * with the same type, it is replaced unconditionally.  The override is also\n"
  " * replaced unconditionally.\n"
  " */";
#else
static const char *Dtool_RenderState_set_attrib_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< RenderState > RenderState::remove_attrib(TypeHandle type) const
 * ConstPointerTo< RenderState > RenderState::remove_attrib(int slot) const
 */
static PyObject *Dtool_RenderState_remove_attrib_205(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  {
    // -2 inline ConstPointerTo< RenderState > RenderState::remove_attrib(TypeHandle type) const
    TypeHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderState > return_value = ((*(const RenderState*)local_this).remove_attrib)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 ConstPointerTo< RenderState > RenderState::remove_attrib(int slot) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      ConstPointerTo< RenderState > return_value = ((*(const RenderState*)local_this).remove_attrib)((int)arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline ConstPointerTo< RenderState > RenderState::remove_attrib(TypeHandle type) const
    TypeHandle arg_local;
    TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      ConstPointerTo< RenderState > return_value = ((*(const RenderState*)local_this).remove_attrib)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }

  // No coercion possible: ConstPointerTo< RenderState > RenderState::remove_attrib(int slot) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_attrib(RenderState self, TypeHandle type)\n"
      "remove_attrib(RenderState self, int slot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_remove_attrib_205_comment =
  "C++ Interface:\n"
  "remove_attrib(RenderState self, TypeHandle type)\n"
  "remove_attrib(RenderState self, int slot)\n"
  "\n"
  "/**\n"
  " * Returns a new RenderState object that represents the same as the source\n"
  " * state, with the indicated RenderAttrib removed.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a new RenderState object that represents the same as the source\n"
  " * state, with the indicated RenderAttrib removed.\n"
  " */";
#else
static const char *Dtool_RenderState_remove_attrib_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderState > RenderState::adjust_all_priorities(int adjustment) const
 */
static PyObject *Dtool_RenderState_adjust_all_priorities_206(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderState > RenderState::adjust_all_priorities(int adjustment) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< RenderState > return_value = ((*(const RenderState*)local_this).adjust_all_priorities)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_all_priorities(RenderState self, int adjustment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_adjust_all_priorities_206_comment =
  "C++ Interface:\n"
  "adjust_all_priorities(RenderState self, int adjustment)\n"
  "\n"
  "/**\n"
  " * Returns a new RenderState object that represents the same as the source\n"
  " * state, with all attributes' override values incremented (or decremented, if\n"
  " * negative) by the indicated amount.  If the override would drop below zero,\n"
  " * it is set to zero.\n"
  " */";
#else
static const char *Dtool_RenderState_adjust_all_priorities_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RenderState::has_attrib(TypeHandle type) const
 * inline bool RenderState::has_attrib(int slot) const
 */
static PyObject *Dtool_RenderState_has_attrib_207(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  {
    // -2 inline bool RenderState::has_attrib(TypeHandle type) const
    TypeHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
    if (arg_this != nullptr) {
      bool return_value = ((*(const RenderState*)local_this).has_attrib)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool RenderState::has_attrib(int slot) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      bool return_value = ((*(const RenderState*)local_this).has_attrib)((int)arg_val);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool RenderState::has_attrib(TypeHandle type) const
    TypeHandle arg_local;
    TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*(const RenderState*)local_this).has_attrib)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: inline bool RenderState::has_attrib(int slot) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_attrib(RenderState self, TypeHandle type)\n"
      "has_attrib(RenderState self, int slot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_has_attrib_207_comment =
  "C++ Interface:\n"
  "has_attrib(RenderState self, TypeHandle type)\n"
  "has_attrib(RenderState self, int slot)\n"
  "\n"
  "/**\n"
  " * Returns true if an attrib of the indicated type is present, false\n"
  " * otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if an attrib of the indicated type is present, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_RenderState_has_attrib_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderAttrib const *RenderState::get_attrib(TypeHandle type) const
 * inline RenderAttrib const *RenderState::get_attrib(int slot) const
 */
static PyObject *Dtool_RenderState_get_attrib_208(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  {
    // -2 inline RenderAttrib const *RenderState::get_attrib(TypeHandle type) const
    TypeHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
    if (arg_this != nullptr) {
      RenderAttrib const *return_value = ((*(const RenderState*)local_this).get_attrib)(*arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderAttrib, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline RenderAttrib const *RenderState::get_attrib(int slot) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      RenderAttrib const *return_value = ((*(const RenderState*)local_this).get_attrib)((int)arg_val);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderAttrib, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline RenderAttrib const *RenderState::get_attrib(TypeHandle type) const
    TypeHandle arg_local;
    TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      RenderAttrib const *return_value = ((*(const RenderState*)local_this).get_attrib)(*arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderAttrib, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  // No coercion possible: inline RenderAttrib const *RenderState::get_attrib(int slot) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_attrib(RenderState self, TypeHandle type)\n"
      "get_attrib(RenderState self, int slot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_attrib_208_comment =
  "C++ Interface:\n"
  "get_attrib(RenderState self, TypeHandle type)\n"
  "get_attrib(RenderState self, int slot)\n"
  "\n"
  "/**\n"
  " * Looks for a RenderAttrib of the indicated type in the state, and returns it\n"
  " * if it is found, or NULL if it is not.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the RenderAttrib with the indicated slot index, or NULL if there is\n"
  " * no such RenderAttrib in the state.\n"
  " */";
#else
static const char *Dtool_RenderState_get_attrib_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderAttrib const *RenderState::get_attrib_def(int slot) const
 */
static PyObject *Dtool_RenderState_get_attrib_def_209(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline RenderAttrib const *RenderState::get_attrib_def(int slot) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    RenderAttrib const *return_value = ((*(const RenderState*)local_this).get_attrib_def)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderAttrib, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_attrib_def(RenderState self, int slot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_attrib_def_209_comment =
  "C++ Interface:\n"
  "get_attrib_def(RenderState self, int slot)\n"
  "\n"
  "/**\n"
  " * Returns the RenderAttrib with the indicated slot index, or the default\n"
  " * attrib for that slot if there is no such RenderAttrib in the state.\n"
  " */";
#else
static const char *Dtool_RenderState_get_attrib_def_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RenderState::get_override(TypeHandle type) const
 * inline int RenderState::get_override(int slot) const
 */
static PyObject *Dtool_RenderState_get_override_210(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  {
    // -2 inline int RenderState::get_override(TypeHandle type) const
    TypeHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
    if (arg_this != nullptr) {
      int return_value = ((*(const RenderState*)local_this).get_override)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline int RenderState::get_override(int slot) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      int return_value = ((*(const RenderState*)local_this).get_override)((int)arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline int RenderState::get_override(TypeHandle type) const
    TypeHandle arg_local;
    TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      int return_value = ((*(const RenderState*)local_this).get_override)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline int RenderState::get_override(int slot) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_override(RenderState self, TypeHandle type)\n"
      "get_override(RenderState self, int slot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_override_210_comment =
  "C++ Interface:\n"
  "get_override(RenderState self, TypeHandle type)\n"
  "get_override(RenderState self, int slot)\n"
  "\n"
  "/**\n"
  " * Looks for a RenderAttrib of the indicated type in the state, and returns\n"
  " * its override value if it is found, or 0 if it is not.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Looks for a RenderAttrib of the indicated type in the state, and returns\n"
  " * its override value if it is found, or 0 if it is not.\n"
  " */";
#else
static const char *Dtool_RenderState_get_override_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< RenderState > RenderState::get_unique(void) const
 */
static PyObject *Dtool_RenderState_get_unique_214(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< RenderState > RenderState::get_unique(void) const
  ConstPointerTo< RenderState > return_value = ((*(const RenderState*)local_this).get_unique)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_unique_214_comment =
  "C++ Interface:\n"
  "get_unique(RenderState self)\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the unique RenderState in the cache that is\n"
  " * equivalent to this one.  This may be the same pointer as this object, or it\n"
  " * may be a different pointer; but it will be an equivalent object, and it\n"
  " * will be a shared pointer.  This may be called from time to time to improve\n"
  " * cache benefits.\n"
  " */";
#else
static const char *Dtool_RenderState_get_unique_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RenderState::cache_ref(void) const
 */
static PyObject *Dtool_RenderState_cache_ref_215(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline void RenderState::cache_ref(void) const
  ((*(const RenderState*)local_this).cache_ref)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RenderState_cache_ref_215_comment =
  "C++ Interface:\n"
  "cache_ref(RenderState self)\n"
  "\n"
  "/**\n"
  " * Overrides this method to update PStats appropriately.\n"
  " */";
#else
static const char *Dtool_RenderState_cache_ref_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RenderState::cache_unref(void) const
 */
static PyObject *Dtool_RenderState_cache_unref_216(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline bool RenderState::cache_unref(void) const
  bool return_value = ((*(const RenderState*)local_this).cache_unref)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_cache_unref_216_comment =
  "C++ Interface:\n"
  "cache_unref(RenderState self)\n"
  "\n"
  "/**\n"
  " * Overrides this method to update PStats appropriately.\n"
  " */";
#else
static const char *Dtool_RenderState_cache_unref_216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RenderState::node_ref(void) const
 */
static PyObject *Dtool_RenderState_node_ref_217(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline void RenderState::node_ref(void) const
  ((*(const RenderState*)local_this).node_ref)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RenderState_node_ref_217_comment =
  "C++ Interface:\n"
  "node_ref(RenderState self)\n"
  "\n"
  "/**\n"
  " * Overrides this method to update PStats appropriately.\n"
  " */";
#else
static const char *Dtool_RenderState_node_ref_217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RenderState::node_unref(void) const
 */
static PyObject *Dtool_RenderState_node_unref_218(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline bool RenderState::node_unref(void) const
  bool return_value = ((*(const RenderState*)local_this).node_unref)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_node_unref_218_comment =
  "C++ Interface:\n"
  "node_unref(RenderState self)\n"
  "\n"
  "/**\n"
  " * Overrides this method to update PStats appropriately.\n"
  " */";
#else
static const char *Dtool_RenderState_node_unref_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t RenderState::get_composition_cache_num_entries(void) const
 */
static PyObject *Dtool_RenderState_get_composition_cache_num_entries_219(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline std::size_t RenderState::get_composition_cache_num_entries(void) const
  std::size_t return_value = ((*(const RenderState*)local_this).get_composition_cache_num_entries)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_composition_cache_num_entries_219_comment =
  "C++ Interface:\n"
  "get_composition_cache_num_entries(RenderState self)\n"
  "\n"
  "/**\n"
  " * Returns the number of entries in the composition cache for this\n"
  " * RenderState.  This is the number of other RenderStates whose composition\n"
  " * with this one has been cached.  This number is not useful for any practical\n"
  " * reason other than performance analysis.\n"
  " */";
#else
static const char *Dtool_RenderState_get_composition_cache_num_entries_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t RenderState::get_invert_composition_cache_num_entries(void) const
 */
static PyObject *Dtool_RenderState_get_invert_composition_cache_num_entries_220(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline std::size_t RenderState::get_invert_composition_cache_num_entries(void) const
  std::size_t return_value = ((*(const RenderState*)local_this).get_invert_composition_cache_num_entries)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_invert_composition_cache_num_entries_220_comment =
  "C++ Interface:\n"
  "get_invert_composition_cache_num_entries(RenderState self)\n"
  "\n"
  "/**\n"
  " * Returns the number of entries in the invert_composition cache for this\n"
  " * RenderState.  This is similar to the composition cache, but it records\n"
  " * cache entries for the invert_compose() operation.  See\n"
  " * get_composition_cache_num_entries().\n"
  " */";
#else
static const char *Dtool_RenderState_get_invert_composition_cache_num_entries_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t RenderState::get_composition_cache_size(void) const
 */
static PyObject *Dtool_RenderState_get_composition_cache_size_221(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline std::size_t RenderState::get_composition_cache_size(void) const
  std::size_t return_value = ((*(const RenderState*)local_this).get_composition_cache_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_composition_cache_size_221_comment =
  "C++ Interface:\n"
  "get_composition_cache_size(RenderState self)\n"
  "\n"
  "/**\n"
  " * Returns the number of slots in the composition cache for this RenderState.\n"
  " * You may use this as an upper bound when walking through all of the\n"
  " * composition cache results via get_composition_cache_source() or result().\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_RenderState_get_composition_cache_size_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderState const *RenderState::get_composition_cache_source(std::size_t n) const
 */
static PyObject *Dtool_RenderState_get_composition_cache_source_222(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline RenderState const *RenderState::get_composition_cache_source(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    RenderState const *return_value = ((*(const RenderState*)local_this).get_composition_cache_source)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_composition_cache_source(RenderState self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_composition_cache_source_222_comment =
  "C++ Interface:\n"
  "get_composition_cache_source(RenderState self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the source RenderState of the nth element in the composition cache.\n"
  " * Returns NULL if there doesn't happen to be an entry in the nth element.\n"
  " * See get_composition_cache_result().\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_RenderState_get_composition_cache_source_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderState const *RenderState::get_composition_cache_result(std::size_t n) const
 */
static PyObject *Dtool_RenderState_get_composition_cache_result_223(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline RenderState const *RenderState::get_composition_cache_result(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    RenderState const *return_value = ((*(const RenderState*)local_this).get_composition_cache_result)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_composition_cache_result(RenderState self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_composition_cache_result_223_comment =
  "C++ Interface:\n"
  "get_composition_cache_result(RenderState self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the result RenderState of the nth element in the composition cache.\n"
  " * Returns NULL if there doesn't happen to be an entry in the nth element.\n"
  " *\n"
  " * In general, a->compose(a->get_composition_cache_source(n)) ==\n"
  " * a->get_composition_cache_result(n).\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_RenderState_get_composition_cache_result_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t RenderState::get_invert_composition_cache_size(void) const
 */
static PyObject *Dtool_RenderState_get_invert_composition_cache_size_224(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline std::size_t RenderState::get_invert_composition_cache_size(void) const
  std::size_t return_value = ((*(const RenderState*)local_this).get_invert_composition_cache_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_invert_composition_cache_size_224_comment =
  "C++ Interface:\n"
  "get_invert_composition_cache_size(RenderState self)\n"
  "\n"
  "/**\n"
  " * Returns the number of slots in the composition cache for this RenderState.\n"
  " * You may use this as an upper bound when walking through all of the\n"
  " * composition cache results via get_invert_composition_cache_source() or\n"
  " * result().\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_RenderState_get_invert_composition_cache_size_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderState const *RenderState::get_invert_composition_cache_source(std::size_t n) const
 */
static PyObject *Dtool_RenderState_get_invert_composition_cache_source_225(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline RenderState const *RenderState::get_invert_composition_cache_source(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    RenderState const *return_value = ((*(const RenderState*)local_this).get_invert_composition_cache_source)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_invert_composition_cache_source(RenderState self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_invert_composition_cache_source_225_comment =
  "C++ Interface:\n"
  "get_invert_composition_cache_source(RenderState self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the source RenderState of the nth element in the invert composition\n"
  " * cache.  Returns NULL if there doesn't happen to be an entry in the nth\n"
  " * element.  See get_invert_composition_cache_result().\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_RenderState_get_invert_composition_cache_source_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderState const *RenderState::get_invert_composition_cache_result(std::size_t n) const
 */
static PyObject *Dtool_RenderState_get_invert_composition_cache_result_226(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline RenderState const *RenderState::get_invert_composition_cache_result(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    RenderState const *return_value = ((*(const RenderState*)local_this).get_invert_composition_cache_result)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_invert_composition_cache_result(RenderState self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_invert_composition_cache_result_226_comment =
  "C++ Interface:\n"
  "get_invert_composition_cache_result(RenderState self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the result RenderState of the nth element in the invert composition\n"
  " * cache.  Returns NULL if there doesn't happen to be an entry in the nth\n"
  " * element.\n"
  " *\n"
  " * In general, a->invert_compose(a->get_invert_composition_cache_source(n)) ==\n"
  " * a->get_invert_composition_cache_result(n).\n"
  " *\n"
  " * This has no practical value other than for examining the cache for\n"
  " * performance analysis.\n"
  " */";
#else
static const char *Dtool_RenderState_get_invert_composition_cache_result_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *RenderState::get_composition_cache(void) const
 */
static PyObject *Dtool_RenderState_get_composition_cache_227(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-PyObject *RenderState::get_composition_cache(void) const
  PyObject *return_value = invoke_extension((const RenderState*)local_this).get_composition_cache();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_composition_cache_227_comment =
  "C++ Interface:\n"
  "get_composition_cache(RenderState self)\n";
#else
static const char *Dtool_RenderState_get_composition_cache_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *RenderState::get_invert_composition_cache(void) const
 */
static PyObject *Dtool_RenderState_get_invert_composition_cache_228(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-PyObject *RenderState::get_invert_composition_cache(void) const
  PyObject *return_value = invoke_extension((const RenderState*)local_this).get_invert_composition_cache();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_invert_composition_cache_228_comment =
  "C++ Interface:\n"
  "get_invert_composition_cache(RenderState self)\n";
#else
static const char *Dtool_RenderState_get_invert_composition_cache_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RenderState::output(std::ostream &out) const
 */
static PyObject *Dtool_RenderState_output_229(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-void RenderState::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "RenderState.output", false, true);
  if (arg_this != nullptr) {
    ((*(const RenderState*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(RenderState self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_output_229_comment =
  "C++ Interface:\n"
  "output(RenderState self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_RenderState_output_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RenderState::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_RenderState_write_230(PyObject *self, PyObject *args, PyObject *kwds) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-void RenderState::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "RenderState.write", false, true);
    if (param1_this != nullptr) {
      ((*(const RenderState*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(RenderState self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_write_230_comment =
  "C++ Interface:\n"
  "write(RenderState self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_RenderState_write_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int RenderState::get_max_priority(void)
 */
static PyObject *Dtool_RenderState_get_max_priority_231(PyObject *, PyObject *) {
  // 1-static int RenderState::get_max_priority(void)
  int return_value = (RenderState::get_max_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_max_priority_231_comment =
  "C++ Interface:\n"
  "get_max_priority()\n"
  "\n"
  "/**\n"
  " * Returns the maximum priority number (sometimes called override) that may be\n"
  " * set on any node.  This may or may not be enforced, but the scene graph code\n"
  " * assumes that no priority numbers will be larger than this, and some effects\n"
  " * may not work properly if you use a larger number.\n"
  " */";
#else
static const char *Dtool_RenderState_get_max_priority_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int RenderState::get_num_states(void)
 */
static PyObject *Dtool_RenderState_get_num_states_232(PyObject *, PyObject *) {
  // 1-static int RenderState::get_num_states(void)
  int return_value = (RenderState::get_num_states)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_num_states_232_comment =
  "C++ Interface:\n"
  "get_num_states()\n"
  "\n"
  "/**\n"
  " * Returns the total number of unique RenderState objects allocated in the\n"
  " * world.  This will go up and down during normal operations.\n"
  " */";
#else
static const char *Dtool_RenderState_get_num_states_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int RenderState::get_num_unused_states(void)
 */
static PyObject *Dtool_RenderState_get_num_unused_states_233(PyObject *, PyObject *) {
  // 1-static int RenderState::get_num_unused_states(void)
  int return_value = (RenderState::get_num_unused_states)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_num_unused_states_233_comment =
  "C++ Interface:\n"
  "get_num_unused_states()\n"
  "\n"
  "/**\n"
  " * Returns the total number of RenderState objects that have been allocated\n"
  " * but have no references outside of the internal RenderState cache.\n"
  " *\n"
  " * A nonzero return value is not necessarily indicative of leaked references;\n"
  " * it is normal for two RenderState objects, both of which have references\n"
  " * held outside the cache, to have to result of their composition stored\n"
  " * within the cache.  This result will be retained within the cache until one\n"
  " * of the base RenderStates is released.\n"
  " *\n"
  " * Use list_cycles() to get an idea of the number of actual \"leaked\"\n"
  " * RenderState objects.\n"
  " */";
#else
static const char *Dtool_RenderState_get_num_unused_states_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int RenderState::clear_cache(void)
 */
static PyObject *Dtool_RenderState_clear_cache_234(PyObject *, PyObject *) {
  // 1-static int RenderState::clear_cache(void)
  int return_value = (RenderState::clear_cache)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_clear_cache_234_comment =
  "C++ Interface:\n"
  "clear_cache()\n"
  "\n"
  "/**\n"
  " * Empties the cache of composed RenderStates.  This makes every RenderState\n"
  " * forget what results when it is composed with other RenderStates.\n"
  " *\n"
  " * This will eliminate any RenderState objects that have been allocated but\n"
  " * have no references outside of the internal RenderState map.  It will not\n"
  " * eliminate RenderState objects that are still in use.\n"
  " *\n"
  " * Nowadays, this method should not be necessary, as reference-count cycles in\n"
  " * the composition cache should be automatically detected and broken.\n"
  " *\n"
  " * The return value is the number of RenderStates freed by this operation.\n"
  " */";
#else
static const char *Dtool_RenderState_clear_cache_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void RenderState::clear_munger_cache(void)
 */
static PyObject *Dtool_RenderState_clear_munger_cache_235(PyObject *, PyObject *) {
  // 1-static void RenderState::clear_munger_cache(void)
  (RenderState::clear_munger_cache)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RenderState_clear_munger_cache_235_comment =
  "C++ Interface:\n"
  "clear_munger_cache()\n"
  "\n"
  "/**\n"
  " * Completely empties the cache of state + gsg -> munger, for all states and\n"
  " * all gsg's.  Normally there is no need to empty this cache.\n"
  " */";
#else
static const char *Dtool_RenderState_clear_munger_cache_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int RenderState::garbage_collect(void)
 */
static PyObject *Dtool_RenderState_garbage_collect_236(PyObject *, PyObject *) {
  // 1-static int RenderState::garbage_collect(void)
  int return_value = (RenderState::garbage_collect)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_garbage_collect_236_comment =
  "C++ Interface:\n"
  "garbage_collect()\n"
  "\n"
  "/**\n"
  " * Performs a garbage-collection cycle.  This must be called periodically if\n"
  " * garbage-collect-states is true to ensure that RenderStates get cleaned up\n"
  " * appropriately.  It does no harm to call it even if this variable is not\n"
  " * true, but there is probably no advantage in that case.\n"
  " *\n"
  " * This automatically calls RenderAttrib::garbage_collect() as well.\n"
  " */";
#else
static const char *Dtool_RenderState_garbage_collect_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void RenderState::list_cycles(std::ostream &out)
 */
static PyObject *Dtool_RenderState_list_cycles_237(PyObject *, PyObject *arg) {
  // 1-static void RenderState::list_cycles(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "RenderState.list_cycles", false, true);
  if (arg_this != nullptr) {
    (RenderState::list_cycles)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_cycles(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_list_cycles_237_comment =
  "C++ Interface:\n"
  "list_cycles(ostream out)\n"
  "\n"
  "/**\n"
  " * Detects all of the reference-count cycles in the cache and reports them to\n"
  " * standard output.\n"
  " *\n"
  " * These cycles may be inadvertently created when state compositions cycle\n"
  " * back to a starting point.  Nowadays, these cycles should be automatically\n"
  " * detected and broken, so this method should never list any cycles unless\n"
  " * there is a bug in that detection logic.\n"
  " *\n"
  " * The cycles listed here are not leaks in the strictest sense of the word,\n"
  " * since they can be reclaimed by a call to clear_cache(); but they will not\n"
  " * be reclaimed automatically.\n"
  " */";
#else
static const char *Dtool_RenderState_list_cycles_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void RenderState::list_states(std::ostream &out)
 */
static PyObject *Dtool_RenderState_list_states_238(PyObject *, PyObject *arg) {
  // 1-static void RenderState::list_states(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "RenderState.list_states", false, true);
  if (arg_this != nullptr) {
    (RenderState::list_states)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_states(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_list_states_238_comment =
  "C++ Interface:\n"
  "list_states(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists all of the RenderStates in the cache to the output stream, one per\n"
  " * line.  This can be quite a lot of output if the cache is large, so be\n"
  " * prepared.\n"
  " */";
#else
static const char *Dtool_RenderState_list_states_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool RenderState::validate_states(void)
 */
static PyObject *Dtool_RenderState_validate_states_239(PyObject *, PyObject *) {
  // 1-static bool RenderState::validate_states(void)
  bool return_value = (RenderState::validate_states)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_validate_states_239_comment =
  "C++ Interface:\n"
  "validate_states()\n"
  "\n"
  "/**\n"
  " * Ensures that the cache is still stored in sorted order, and that none of\n"
  " * the cache elements have been inadvertently deleted.  Returns true if so,\n"
  " * false if there is a problem (which implies someone has modified one of the\n"
  " * supposedly-const RenderState objects).\n"
  " */";
#else
static const char *Dtool_RenderState_validate_states_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PyObject *RenderState::get_states(void)
 */
static PyObject *Dtool_RenderState_get_states_240(PyObject *, PyObject *) {
  // 1-static PyObject *RenderState::get_states(void)
  PyObject *return_value = Extension<RenderState>::get_states();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_states_240_comment =
  "C++ Interface:\n"
  "get_states()\n";
#else
static const char *Dtool_RenderState_get_states_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RenderState::get_draw_order(void) const
 */
static PyObject *Dtool_RenderState_get_draw_order_241(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline int RenderState::get_draw_order(void) const
  int return_value = ((*(const RenderState*)local_this).get_draw_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_draw_order_241_comment =
  "C++ Interface:\n"
  "get_draw_order(RenderState self)\n"
  "\n"
  "// These methods are intended for use by low-level code, but they're also\n"
  "// handy enough to expose to high-level users.\n"
  "\n"
  "/**\n"
  " * Returns the draw order indicated by the CullBinAttrib, if any, associated\n"
  " * by this state (or 0 if there is no CullBinAttrib).  See get_bin_index().\n"
  " */";
#else
static const char *Dtool_RenderState_get_draw_order_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RenderState::get_bin_index(void) const
 */
static PyObject *Dtool_RenderState_get_bin_index_242(PyObject *self, PyObject *) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-inline int RenderState::get_bin_index(void) const
  int return_value = ((*(const RenderState*)local_this).get_bin_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_bin_index_242_comment =
  "C++ Interface:\n"
  "get_bin_index(RenderState self)\n"
  "\n"
  "/**\n"
  " * Returns the bin index indicated by the CullBinAttrib, if any, associated by\n"
  " * this state (or the default bin index if there is no CullBinAttrib).  This\n"
  " * function is provided as an optimization for determining this at render\n"
  " * time.\n"
  " */";
#else
static const char *Dtool_RenderState_get_bin_index_242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int RenderState::get_geom_rendering(int geom_rendering) const
 */
static PyObject *Dtool_RenderState_get_geom_rendering_243(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderState)) {
    return nullptr;
  }
  // 1-int RenderState::get_geom_rendering(int geom_rendering) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const RenderState*)local_this).get_geom_rendering)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geom_rendering(RenderState self, int geom_rendering)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_geom_rendering_243_comment =
  "C++ Interface:\n"
  "get_geom_rendering(RenderState self, int geom_rendering)\n"
  "\n"
  "/**\n"
  " * Returns the union of the Geom::GeomRendering bits that will be required\n"
  " * once this RenderState is applied to a geom which includes the indicated\n"
  " * geom_rendering bits.\n"
  " */";
#else
static const char *Dtool_RenderState_get_geom_rendering_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RenderState::get_class_type(void)
 */
static PyObject *Dtool_RenderState_get_class_type_244(PyObject *, PyObject *) {
  // 1-static TypeHandle RenderState::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RenderState::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RenderState_get_class_type_244_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RenderState_get_class_type_244_comment = nullptr;
#endif

/**
 * mapping getitem for property RenderState::attribs
 */
static PyObject *Dtool_RenderState_attribs_Mapping_Getitem(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderState, (void **)&local_this)) {
    return nullptr;
  }
  {
    {
      // -2 inline bool RenderState::has_attrib(TypeHandle type) const
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        bool return_value = ((*(const RenderState*)local_this).has_attrib)(*arg_this);
        if (!return_value) {
          PyErr_SetObject(PyExc_KeyError, arg);
          return nullptr;
        }
      }
    }

    {
      // -2 inline bool RenderState::has_attrib(int slot) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return nullptr;
        }
#endif
        bool return_value = ((*(const RenderState*)local_this).has_attrib)((int)arg_val);
        if (!return_value) {
          PyErr_SetObject(PyExc_KeyError, arg);
          return nullptr;
        }
      }
    }

    {
      // -2 inline bool RenderState::has_attrib(TypeHandle type) const
      TypeHandle arg_local;
      TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const RenderState*)local_this).has_attrib)(*arg_this);
        if (!return_value) {
          PyErr_SetObject(PyExc_KeyError, arg);
          return nullptr;
        }
      }
    }

    // No coercion possible: inline bool RenderState::has_attrib(int slot) const
  }
  {
    // -2 inline RenderAttrib const *RenderState::get_attrib(TypeHandle type) const
    TypeHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
    if (arg_this != nullptr) {
      RenderAttrib const *return_value = ((*(const RenderState*)local_this).get_attrib)(*arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return Dtool_Raise_AssertionError();
      }
#endif
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderAttrib, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline RenderAttrib const *RenderState::get_attrib(int slot) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      RenderAttrib const *return_value = ((*(const RenderState*)local_this).get_attrib)((int)arg_val);
      if (return_value != nullptr) {
        return_value->ref();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return Dtool_Raise_AssertionError();
      }
#endif
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderAttrib, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline RenderAttrib const *RenderState::get_attrib(TypeHandle type) const
    TypeHandle arg_local;
    TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      RenderAttrib const *return_value = ((*(const RenderState*)local_this).get_attrib)(*arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return Dtool_Raise_AssertionError();
      }
#endif
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderAttrib, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  // No coercion possible: inline RenderAttrib const *RenderState::get_attrib(int slot) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_attrib(RenderState self, TypeHandle type)\n"
      "get_attrib(RenderState self, int slot)\n");
  }
  return nullptr;
}

static PyObject *Dtool_RenderState_attribs_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MappingWrapper *wrap = Dtool_NewMappingWrapper(self, "RenderState.attribs");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_RenderState_attribs_Mapping_Getitem;
  }
  return (PyObject *)wrap;
}

static int Dtool_Init_RenderState(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_RenderState)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib, int override)
    RenderAttrib const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_RenderAttrib);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderState > return_value = (RenderState::make)(arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((RenderState const *) return_value.p());
        return true;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        {
          // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, int override)
          PyObject *param0;
          PyObject *param1;
          if (PyArg_UnpackTuple(args, "make", 2, 2, &param0, &param1)) {
            RenderAttrib const *param0_this = nullptr;
            DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param1_this = nullptr;
            DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
            if (param0_this != nullptr && param1_this != nullptr) {
              ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this);
              if (_PyErr_OCCURRED()) {
                return false;
              } else {
                coerced = std::move((RenderState const *) return_value.p());
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib, int override)
          PyObject *param0;
          int param1;
          if (PyArg_ParseTuple(args, "Oi:make", &param0, &param1)) {
            RenderAttrib const *param0_this = nullptr;
            DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
            if (param0_this != nullptr) {
              ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, (int)param1);
              if (_PyErr_OCCURRED()) {
                return false;
              } else {
                coerced = std::move((RenderState const *) return_value.p());
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        break;
      }
      case 3: {
        {
          // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, int override)
          PyObject *param0;
          PyObject *param1;
          PyObject *param2;
          if (PyArg_UnpackTuple(args, "make", 3, 3, &param0, &param1, &param2)) {
            RenderAttrib const *param0_this = nullptr;
            DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param1_this = nullptr;
            DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param2_this = nullptr;
            DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderAttrib);
            if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
              ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, param2_this);
              if (_PyErr_OCCURRED()) {
                return false;
              } else {
                coerced = std::move((RenderState const *) return_value.p());
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, int override)
          PyObject *param0;
          PyObject *param1;
          int param2;
          if (PyArg_ParseTuple(args, "OOi:make", &param0, &param1, &param2)) {
            RenderAttrib const *param0_this = nullptr;
            DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param1_this = nullptr;
            DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
            if (param0_this != nullptr && param1_this != nullptr) {
              ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, (int)param2);
              if (_PyErr_OCCURRED()) {
                return false;
              } else {
                coerced = std::move((RenderState const *) return_value.p());
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        break;
      }
      case 4: {
        {
          // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, int override)
          PyObject *param0;
          PyObject *param1;
          PyObject *param2;
          PyObject *param3;
          if (PyArg_UnpackTuple(args, "make", 4, 4, &param0, &param1, &param2, &param3)) {
            RenderAttrib const *param0_this = nullptr;
            DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param1_this = nullptr;
            DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param2_this = nullptr;
            DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param3_this = nullptr;
            DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_RenderAttrib);
            if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
              ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, param2_this, param3_this);
              if (_PyErr_OCCURRED()) {
                return false;
              } else {
                coerced = std::move((RenderState const *) return_value.p());
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, int override)
          PyObject *param0;
          PyObject *param1;
          PyObject *param2;
          int param3;
          if (PyArg_ParseTuple(args, "OOOi:make", &param0, &param1, &param2, &param3)) {
            RenderAttrib const *param0_this = nullptr;
            DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param1_this = nullptr;
            DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param2_this = nullptr;
            DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderAttrib);
            if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
              ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, param2_this, (int)param3);
              if (_PyErr_OCCURRED()) {
                return false;
              } else {
                coerced = std::move((RenderState const *) return_value.p());
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        break;
      }
      case 5:
      case 6: {
        {
          // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, RenderAttrib const *attrib5, int override = 0)
          PyObject *param0;
          PyObject *param1;
          PyObject *param2;
          PyObject *param3;
          PyObject *param4;
          int param5 = 0;
          if (PyArg_ParseTuple(args, "OOOOO|i:make", &param0, &param1, &param2, &param3, &param4, &param5)) {
            RenderAttrib const *param0_this = nullptr;
            DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param1_this = nullptr;
            DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param2_this = nullptr;
            DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param3_this = nullptr;
            DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param4_this = nullptr;
            DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_RenderAttrib);
            if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr && param4_this != nullptr) {
              ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, param2_this, param3_this, param4_this, (int)param5);
              if (_PyErr_OCCURRED()) {
                return false;
              } else {
                coerced = std::move((RenderState const *) return_value.p());
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 static ConstPointerTo< RenderState > RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, int override = 0)
          PyObject *param0;
          PyObject *param1;
          PyObject *param2;
          PyObject *param3;
          int param4;
          if (PyArg_ParseTuple(args, "OOOOi:make", &param0, &param1, &param2, &param3, &param4)) {
            RenderAttrib const *param0_this = nullptr;
            DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param1_this = nullptr;
            DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param2_this = nullptr;
            DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderAttrib);
            RenderAttrib const *param3_this = nullptr;
            DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_RenderAttrib);
            if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
              ConstPointerTo< RenderState > return_value = (RenderState::make)(param0_this, param1_this, param2_this, param3_this, (int)param4);
              if (_PyErr_OCCURRED()) {
                return false;
              } else {
                coerced = std::move((RenderState const *) return_value.p());
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_RenderState(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RenderState) {
    printf("RenderState ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RenderState *local_this = (RenderState *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RenderState) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(NodeCachedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_NodeCachedReferenceCount) {
    return (NodeCachedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(NodeCachedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(NodeCachedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(NodeCachedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(NodeCachedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RenderState(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RenderState) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (RenderState*)other_this;
  }
  if (from_type == Dtool_Ptr_NodeCachedReferenceCount) {
    NodeCachedReferenceCount* other_this = (NodeCachedReferenceCount*)from_this;
    return (RenderState*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RenderState*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RenderState*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RenderState*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RenderState*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AlphaTestAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > AlphaTestAttrib::make(RenderAttrib::PandaCompareFunc mode, PN_stdfloat reference_alpha)
 */
static PyObject *Dtool_AlphaTestAttrib_make_246(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > AlphaTestAttrib::make(RenderAttrib::PandaCompareFunc mode, PN_stdfloat reference_alpha)
  int param0;
  float param1;
  static const char *keyword_list[] = {"mode", "reference_alpha", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:make", (char **)keyword_list, &param0, &param1)) {
    ConstPointerTo< RenderAttrib > return_value = (AlphaTestAttrib::make)((RenderAttrib::PandaCompareFunc)param0, (PN_stdfloat)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int mode, float reference_alpha)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AlphaTestAttrib_make_246_comment =
  "C++ Interface:\n"
  "make(int mode, float reference_alpha)\n"
  "\n"
  "/**\n"
  " * Constructs a new AlphaTestAttrib object.\n"
  " */";
#else
static const char *Dtool_AlphaTestAttrib_make_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > AlphaTestAttrib::make_default(void)
 */
static PyObject *Dtool_AlphaTestAttrib_make_default_247(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > AlphaTestAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (AlphaTestAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AlphaTestAttrib_make_default_247_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_AlphaTestAttrib_make_default_247_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat AlphaTestAttrib::get_reference_alpha(void) const
 */
static PyObject *Dtool_AlphaTestAttrib_get_reference_alpha_248(PyObject *self, PyObject *) {
  AlphaTestAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AlphaTestAttrib)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat AlphaTestAttrib::get_reference_alpha(void) const
  PN_stdfloat return_value = ((*(const AlphaTestAttrib*)local_this).get_reference_alpha)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AlphaTestAttrib_get_reference_alpha_248_comment =
  "C++ Interface:\n"
  "get_reference_alpha(AlphaTestAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the alpha reference value.\n"
  " */";
#else
static const char *Dtool_AlphaTestAttrib_get_reference_alpha_248_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderAttrib::PandaCompareFunc AlphaTestAttrib::get_mode(void) const
 */
static PyObject *Dtool_AlphaTestAttrib_get_mode_249(PyObject *self, PyObject *) {
  AlphaTestAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AlphaTestAttrib)) {
    return nullptr;
  }
  // 1-inline RenderAttrib::PandaCompareFunc AlphaTestAttrib::get_mode(void) const
  RenderAttrib::PandaCompareFunc return_value = ((*(const AlphaTestAttrib*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AlphaTestAttrib_get_mode_249_comment =
  "C++ Interface:\n"
  "get_mode(AlphaTestAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the alpha write mode.\n"
  " */";
#else
static const char *Dtool_AlphaTestAttrib_get_mode_249_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int AlphaTestAttrib::get_class_slot(void)
 */
static PyObject *Dtool_AlphaTestAttrib_get_class_slot_252(PyObject *, PyObject *) {
  // 1-static int AlphaTestAttrib::get_class_slot(void)
  int return_value = (AlphaTestAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AlphaTestAttrib_get_class_slot_252_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_AlphaTestAttrib_get_class_slot_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AlphaTestAttrib::get_class_type(void)
 */
static PyObject *Dtool_AlphaTestAttrib_get_class_type_254(PyObject *, PyObject *) {
  // 1-static TypeHandle AlphaTestAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AlphaTestAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AlphaTestAttrib_get_class_type_254_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AlphaTestAttrib_get_class_type_254_comment = nullptr;
#endif

static PyObject *Dtool_AlphaTestAttrib_reference_alpha_Getter(PyObject *self, void *) {
  const AlphaTestAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AlphaTestAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat AlphaTestAttrib::get_reference_alpha(void) const
  PN_stdfloat return_value = ((*(const AlphaTestAttrib*)local_this).get_reference_alpha)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AlphaTestAttrib_mode_Getter(PyObject *self, void *) {
  const AlphaTestAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AlphaTestAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline RenderAttrib::PandaCompareFunc AlphaTestAttrib::get_mode(void) const
  RenderAttrib::PandaCompareFunc return_value = ((*(const AlphaTestAttrib*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AlphaTestAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int AlphaTestAttrib::get_class_slot(void)
  int return_value = (AlphaTestAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_AlphaTestAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_AlphaTestAttrib(PyObject *args, CPT(AlphaTestAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_AlphaTestAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-static ConstPointerTo< RenderAttrib > AlphaTestAttrib::make(RenderAttrib::PandaCompareFunc mode, PN_stdfloat reference_alpha)
      int param0;
      float param1;
      if (PyArg_ParseTuple(args, "if:make", &param0, &param1)) {
        ConstPointerTo< RenderAttrib > return_value = (AlphaTestAttrib::make)((RenderAttrib::PandaCompareFunc)param0, (PN_stdfloat)param1);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move((AlphaTestAttrib const *) return_value.p());
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_AlphaTestAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AlphaTestAttrib) {
    printf("AlphaTestAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AlphaTestAttrib *local_this = (AlphaTestAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AlphaTestAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AlphaTestAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AlphaTestAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AlphaTestAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (AlphaTestAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AlphaTestAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AlphaTestAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AlphaTestAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AntialiasAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > AntialiasAttrib::make(unsigned short int mode)
 */
static PyObject *Dtool_AntialiasAttrib_make_258(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > AntialiasAttrib::make(unsigned short int mode)
  if (PyLongOrInt_Check(arg)) {
    long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param0 < 0 || param0 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param0);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (AntialiasAttrib::make)((unsigned short int)param0);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AntialiasAttrib_make_258_comment =
  "C++ Interface:\n"
  "make(int mode)\n"
  "\n"
  "/**\n"
  " * Constructs a new AntialiasAttrib object.\n"
  " *\n"
  " * The mode should be either M_none, M_auto, or a union of any or all of\n"
  " * M_point, M_line, M_polygon, and M_multisample.  Also, in addition to the\n"
  " * above choices, it may include either of M_better of M_faster to specify a\n"
  " * performance/quality tradeoff hint.\n"
  " *\n"
  " * If M_none is specified, no antialiasing is performed.\n"
  " *\n"
  " * If M_multisample is specified, it means to use the special framebuffer\n"
  " * multisample bits for antialiasing, if it is available.  If so, the M_point,\n"
  " * M_line, and M_polygon modes are ignored.  This advanced antialiasing mode\n"
  " * is only available on certain graphics hardware.  If it is not available,\n"
  " * the M_multisample bit is ignored (and the other modes may be used instead,\n"
  " * if specified).\n"
  " *\n"
  " * M_point, M_line, and/or M_polygon specify per-primitive smoothing.  When\n"
  " * enabled, M_point and M_line may force transparency on.  M_polygon requires\n"
  " * a frame buffer that includes an alpha channel, and it works best if the\n"
  " * primitives are sorted front-to-back.\n"
  " *\n"
  " * If M_auto is specified, M_multisample is selected if it is available,\n"
  " * otherwise M_polygon is selected, unless drawing lines or points, in which\n"
  " * case M_line or M_point is selected (these two generally produce better\n"
  " * results than M_multisample)\n"
  " */";
#else
static const char *Dtool_AntialiasAttrib_make_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > AntialiasAttrib::make_default(void)
 */
static PyObject *Dtool_AntialiasAttrib_make_default_259(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > AntialiasAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (AntialiasAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AntialiasAttrib_make_default_259_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_AntialiasAttrib_make_default_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned short int AntialiasAttrib::get_mode(void) const
 */
static PyObject *Dtool_AntialiasAttrib_get_mode_260(PyObject *self, PyObject *) {
  AntialiasAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AntialiasAttrib)) {
    return nullptr;
  }
  // 1-inline unsigned short int AntialiasAttrib::get_mode(void) const
  unsigned short int return_value = ((*(const AntialiasAttrib*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AntialiasAttrib_get_mode_260_comment =
  "C++ Interface:\n"
  "get_mode(AntialiasAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the specified antialias mode.\n"
  " */";
#else
static const char *Dtool_AntialiasAttrib_get_mode_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned short int AntialiasAttrib::get_mode_type(void) const
 */
static PyObject *Dtool_AntialiasAttrib_get_mode_type_261(PyObject *self, PyObject *) {
  AntialiasAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AntialiasAttrib)) {
    return nullptr;
  }
  // 1-inline unsigned short int AntialiasAttrib::get_mode_type(void) const
  unsigned short int return_value = ((*(const AntialiasAttrib*)local_this).get_mode_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AntialiasAttrib_get_mode_type_261_comment =
  "C++ Interface:\n"
  "get_mode_type(AntialiasAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the specified antialias mode, with the quality bits masked out.\n"
  " * This therefore indicates only the requested type of antialiasing: M_none,\n"
  " * M_auto, or some specific combination.\n"
  " */";
#else
static const char *Dtool_AntialiasAttrib_get_mode_type_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned short int AntialiasAttrib::get_mode_quality(void) const
 */
static PyObject *Dtool_AntialiasAttrib_get_mode_quality_262(PyObject *self, PyObject *) {
  AntialiasAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AntialiasAttrib)) {
    return nullptr;
  }
  // 1-inline unsigned short int AntialiasAttrib::get_mode_quality(void) const
  unsigned short int return_value = ((*(const AntialiasAttrib*)local_this).get_mode_quality)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AntialiasAttrib_get_mode_quality_262_comment =
  "C++ Interface:\n"
  "get_mode_quality(AntialiasAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the specified antialias mode, with the type bits masked out.  This\n"
  " * therefore indicates only the requested quality settings: one of M_faster,\n"
  " * M_better, M_dont_care, or zero (unspecified).\n"
  " */";
#else
static const char *Dtool_AntialiasAttrib_get_mode_quality_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int AntialiasAttrib::get_class_slot(void)
 */
static PyObject *Dtool_AntialiasAttrib_get_class_slot_267(PyObject *, PyObject *) {
  // 1-static int AntialiasAttrib::get_class_slot(void)
  int return_value = (AntialiasAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AntialiasAttrib_get_class_slot_267_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_AntialiasAttrib_get_class_slot_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AntialiasAttrib::get_class_type(void)
 */
static PyObject *Dtool_AntialiasAttrib_get_class_type_269(PyObject *, PyObject *) {
  // 1-static TypeHandle AntialiasAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AntialiasAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AntialiasAttrib_get_class_type_269_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AntialiasAttrib_get_class_type_269_comment = nullptr;
#endif

static PyObject *Dtool_AntialiasAttrib_mode_Getter(PyObject *self, void *) {
  const AntialiasAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AntialiasAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline unsigned short int AntialiasAttrib::get_mode(void) const
  unsigned short int return_value = ((*(const AntialiasAttrib*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AntialiasAttrib_mode_type_Getter(PyObject *self, void *) {
  const AntialiasAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AntialiasAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline unsigned short int AntialiasAttrib::get_mode_type(void) const
  unsigned short int return_value = ((*(const AntialiasAttrib*)local_this).get_mode_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AntialiasAttrib_mode_quality_Getter(PyObject *self, void *) {
  const AntialiasAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AntialiasAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline unsigned short int AntialiasAttrib::get_mode_quality(void) const
  unsigned short int return_value = ((*(const AntialiasAttrib*)local_this).get_mode_quality)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AntialiasAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int AntialiasAttrib::get_class_slot(void)
  int return_value = (AntialiasAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_AntialiasAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_AntialiasAttrib(PyObject *args, CPT(AntialiasAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_AntialiasAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > AntialiasAttrib::make(unsigned short int mode)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > USHRT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for unsigned short integer",
                     param0);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (AntialiasAttrib::make)((unsigned short int)param0);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((AntialiasAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_AntialiasAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AntialiasAttrib) {
    printf("AntialiasAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AntialiasAttrib *local_this = (AntialiasAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AntialiasAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AntialiasAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AntialiasAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AntialiasAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (AntialiasAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AntialiasAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AntialiasAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AntialiasAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RenderEffect
 */
/**
 * Python function wrapper for:
 * inline int RenderEffect::compare_to(RenderEffect const &other) const
 */
static PyObject *Dtool_RenderEffect_compare_to_272(PyObject *self, PyObject *arg) {
  RenderEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffect)) {
    return nullptr;
  }
  // 1-inline int RenderEffect::compare_to(RenderEffect const &other) const
  RenderEffect const *arg_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderEffect, 1, "RenderEffect.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const RenderEffect*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(RenderEffect self, const RenderEffect other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffect_compare_to_272_comment =
  "C++ Interface:\n"
  "compare_to(RenderEffect self, const RenderEffect other)\n"
  "\n"
  "/**\n"
  " * Provides an arbitrary ordering among all unique RenderEffects, so we can\n"
  " * store the essentially different ones in a big set and throw away the rest.\n"
  " *\n"
  " * This method is not needed outside of the RenderEffect class because all\n"
  " * equivalent RenderEffect objects are guaranteed to share the same pointer;\n"
  " * thus, a pointer comparison is always sufficient.\n"
  " */";
#else
static const char *Dtool_RenderEffect_compare_to_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void RenderEffect::output(std::ostream &out) const
 */
static PyObject *Dtool_RenderEffect_output_273(PyObject *self, PyObject *arg) {
  RenderEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffect)) {
    return nullptr;
  }
  // 1-virtual void RenderEffect::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "RenderEffect.output", false, true);
  if (arg_this != nullptr) {
    ((*(const RenderEffect*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(RenderEffect self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffect_output_273_comment =
  "C++ Interface:\n"
  "output(RenderEffect self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_RenderEffect_output_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void RenderEffect::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_RenderEffect_write_274(PyObject *self, PyObject *args, PyObject *kwds) {
  RenderEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffect)) {
    return nullptr;
  }
  // 1-virtual void RenderEffect::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "RenderEffect.write", false, true);
    if (param1_this != nullptr) {
      ((*(const RenderEffect*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(RenderEffect self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffect_write_274_comment =
  "C++ Interface:\n"
  "write(RenderEffect self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_RenderEffect_write_274_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int RenderEffect::get_num_effects(void)
 */
static PyObject *Dtool_RenderEffect_get_num_effects_275(PyObject *, PyObject *) {
  // 1-static int RenderEffect::get_num_effects(void)
  int return_value = (RenderEffect::get_num_effects)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderEffect_get_num_effects_275_comment =
  "C++ Interface:\n"
  "get_num_effects()\n"
  "\n"
  "/**\n"
  " * Returns the total number of unique RenderEffect objects allocated in the\n"
  " * world.  This will go up and down during normal operations.\n"
  " */";
#else
static const char *Dtool_RenderEffect_get_num_effects_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void RenderEffect::list_effects(std::ostream &out)
 */
static PyObject *Dtool_RenderEffect_list_effects_276(PyObject *, PyObject *arg) {
  // 1-static void RenderEffect::list_effects(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "RenderEffect.list_effects", false, true);
  if (arg_this != nullptr) {
    (RenderEffect::list_effects)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_effects(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffect_list_effects_276_comment =
  "C++ Interface:\n"
  "list_effects(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists all of the RenderEffects in the cache to the output stream, one per\n"
  " * line.  This can be quite a lot of output if the cache is large, so be\n"
  " * prepared.\n"
  " */";
#else
static const char *Dtool_RenderEffect_list_effects_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool RenderEffect::validate_effects(void)
 */
static PyObject *Dtool_RenderEffect_validate_effects_277(PyObject *, PyObject *) {
  // 1-static bool RenderEffect::validate_effects(void)
  bool return_value = (RenderEffect::validate_effects)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderEffect_validate_effects_277_comment =
  "C++ Interface:\n"
  "validate_effects()\n"
  "\n"
  "/**\n"
  " * Ensures that the cache is still stored in sorted order.  Returns true if\n"
  " * so, false if there is a problem (which implies someone has modified one of\n"
  " * the supposedly-const RenderEffect objects).\n"
  " */";
#else
static const char *Dtool_RenderEffect_validate_effects_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RenderEffect::get_class_type(void)
 */
static PyObject *Dtool_RenderEffect_get_class_type_278(PyObject *, PyObject *) {
  // 1-static TypeHandle RenderEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RenderEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RenderEffect_get_class_type_278_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RenderEffect_get_class_type_278_comment = nullptr;
#endif

static int Dtool_Init_RenderEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_RenderEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RenderEffect) {
    printf("RenderEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RenderEffect *local_this = (RenderEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RenderEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RenderEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RenderEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RenderEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RenderEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RenderEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RenderEffects
 */
/**
 * Python function wrapper for:
 * inline bool RenderEffects::is_empty(void) const
 */
static PyObject *Dtool_RenderEffects_is_empty_281(PyObject *self, PyObject *) {
  RenderEffects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffects)) {
    return nullptr;
  }
  // 1-inline bool RenderEffects::is_empty(void) const
  bool return_value = ((*(const RenderEffects*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_is_empty_281_comment =
  "C++ Interface:\n"
  "is_empty(RenderEffects self)\n"
  "\n"
  "/**\n"
  " * Returns true if the state is empty, false otherwise.\n"
  " */";
#else
static const char *Dtool_RenderEffects_is_empty_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t RenderEffects::get_num_effects(void) const
 */
static PyObject *Dtool_RenderEffects_get_num_effects_282(PyObject *self, PyObject *) {
  RenderEffects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffects)) {
    return nullptr;
  }
  // 1-inline std::size_t RenderEffects::get_num_effects(void) const
  std::size_t return_value = ((*(const RenderEffects*)local_this).get_num_effects)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_get_num_effects_282_comment =
  "C++ Interface:\n"
  "get_num_effects(RenderEffects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of separate effects indicated in the state.\n"
  " * @deprecated in Python, use len(effects) instead, or effects.size() in C++.\n"
  " */";
#else
static const char *Dtool_RenderEffects_get_num_effects_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * RenderEffect const *RenderEffects::get_effect(TypeHandle type) const
 * inline RenderEffect const *RenderEffects::get_effect(std::size_t n) const
 */
static PyObject *Dtool_RenderEffects_get_effect_283(PyObject *self, PyObject *arg) {
  RenderEffects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffects)) {
    return nullptr;
  }
  {
    // -2 RenderEffect const *RenderEffects::get_effect(TypeHandle type) const
    TypeHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
    if (arg_this != nullptr) {
      RenderEffect const *return_value = ((*(const RenderEffects*)local_this).get_effect)(*arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderEffect, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline RenderEffect const *RenderEffects::get_effect(std::size_t n) const
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      RenderEffect const *return_value = ((*(const RenderEffects*)local_this).get_effect)(arg_val);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderEffect, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 RenderEffect const *RenderEffects::get_effect(TypeHandle type) const
    TypeHandle arg_local;
    TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      RenderEffect const *return_value = ((*(const RenderEffects*)local_this).get_effect)(*arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderEffect, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  // No coercion possible: inline RenderEffect const *RenderEffects::get_effect(std::size_t n) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_effect(RenderEffects self, TypeHandle type)\n"
      "get_effect(RenderEffects self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_get_effect_283_comment =
  "C++ Interface:\n"
  "get_effect(RenderEffects self, TypeHandle type)\n"
  "get_effect(RenderEffects self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth effect in the state.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Looks for a RenderEffect of the indicated type in the state, and returns it\n"
  " * if it is found, or NULL if it is not.\n"
  " */";
#else
static const char *Dtool_RenderEffects_get_effect_283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderEffect const *RenderEffects::operator [](TypeHandle type) const
 * inline RenderEffect const *RenderEffects::operator [](std::size_t n) const
 */
static PyObject *Dtool_RenderEffects_operator_285(PyObject *self, PyObject *arg) {
  RenderEffects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffects)) {
    return nullptr;
  }
  {
    // -2 inline RenderEffect const *RenderEffects::operator [](TypeHandle type) const
    TypeHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
    if (arg_this != nullptr) {
      RenderEffect const *return_value = ((*(const RenderEffects*)local_this).operator [])(*arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderEffect, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline RenderEffect const *RenderEffects::operator [](std::size_t n) const
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      RenderEffect const *return_value = ((*(const RenderEffects*)local_this).operator [])(arg_val);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderEffect, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline RenderEffect const *RenderEffects::operator [](TypeHandle type) const
    TypeHandle arg_local;
    TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      RenderEffect const *return_value = ((*(const RenderEffects*)local_this).operator [])(*arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderEffect, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  // No coercion possible: inline RenderEffect const *RenderEffects::operator [](std::size_t n) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(RenderEffects self, TypeHandle type)\n"
      "__getitem__(RenderEffects self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_operator_285_comment =
  "C++ Interface:\n"
  "__getitem__(RenderEffects self, TypeHandle type)\n"
  "__getitem__(RenderEffects self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth effect in the state.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the effect in the state with the given type.\n"
  " */";
#else
static const char *Dtool_RenderEffects_operator_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int RenderEffects::find_effect(TypeHandle type) const
 */
static PyObject *Dtool_RenderEffects_find_effect_286(PyObject *self, PyObject *arg) {
  RenderEffects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffects)) {
    return nullptr;
  }
  // 1-int RenderEffects::find_effect(TypeHandle type) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RenderEffects.find_effect", "TypeHandle");
  }
  int return_value = ((*(const RenderEffects*)local_this).find_effect)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_effect(RenderEffects self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_find_effect_286_comment =
  "C++ Interface:\n"
  "find_effect(RenderEffects self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Searches for an effect with the indicated type in the state, and returns\n"
  " * its index if it is found, or -1 if it is not.\n"
  " */";
#else
static const char *Dtool_RenderEffects_find_effect_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffects > RenderEffects::make_empty(void)
 */
static PyObject *Dtool_RenderEffects_make_empty_287(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderEffects > RenderEffects::make_empty(void)
  ConstPointerTo< RenderEffects > return_value = (RenderEffects::make_empty)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffects const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffects, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_make_empty_287_comment =
  "C++ Interface:\n"
  "make_empty()\n"
  "\n"
  "/**\n"
  " * Returns a RenderEffects with no effects set.\n"
  " */";
#else
static const char *Dtool_RenderEffects_make_empty_287_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect)
 * static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2)
 * static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2, RenderEffect const *effect3)
 * static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2, RenderEffect const *effect3, RenderEffect const *effect4)
 */
static PyObject *Dtool_RenderEffects_make_288(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "effect")) {
        // 1-static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect)
        RenderEffect const *arg_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderEffect, 0, "RenderEffects.make", true, true);
        if (arg_this != nullptr) {
          ConstPointerTo< RenderEffects > return_value = (RenderEffects::make)(arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderEffects const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffects, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 2:
    {
      // 1-static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"effect1", "effect2", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make", (char **)keyword_list, &param0, &param1)) {
        RenderEffect const *param0_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_RenderEffect, 0, "RenderEffects.make", true, true);
        RenderEffect const *param1_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_RenderEffect, 1, "RenderEffects.make", true, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          ConstPointerTo< RenderEffects > return_value = (RenderEffects::make)(param0_this, param1_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderEffects const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffects, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 3:
    {
      // 1-static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2, RenderEffect const *effect3)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"effect1", "effect2", "effect3", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:make", (char **)keyword_list, &param0, &param1, &param2)) {
        RenderEffect const *param0_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_RenderEffect, 0, "RenderEffects.make", true, true);
        RenderEffect const *param1_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_RenderEffect, 1, "RenderEffects.make", true, true);
        RenderEffect const *param2_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_RenderEffect, 2, "RenderEffects.make", true, true);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
          ConstPointerTo< RenderEffects > return_value = (RenderEffects::make)(param0_this, param1_this, param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderEffects const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffects, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 4:
    {
      // 1-static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2, RenderEffect const *effect3, RenderEffect const *effect4)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"effect1", "effect2", "effect3", "effect4", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:make", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        RenderEffect const *param0_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_RenderEffect, 0, "RenderEffects.make", true, true);
        RenderEffect const *param1_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_RenderEffect, 1, "RenderEffects.make", true, true);
        RenderEffect const *param2_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_RenderEffect, 2, "RenderEffects.make", true, true);
        RenderEffect const *param3_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_RenderEffect, 3, "RenderEffects.make", true, true);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
          ConstPointerTo< RenderEffects > return_value = (RenderEffects::make)(param0_this, param1_this, param2_this, param3_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderEffects const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffects, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 1, 2, 3 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const RenderEffect effect)\n"
      "make(const RenderEffect effect1, const RenderEffect effect2)\n"
      "make(const RenderEffect effect1, const RenderEffect effect2, const RenderEffect effect3)\n"
      "make(const RenderEffect effect1, const RenderEffect effect2, const RenderEffect effect3, const RenderEffect effect4)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_make_288_comment =
  "C++ Interface:\n"
  "make(const RenderEffect effect)\n"
  "make(const RenderEffect effect1, const RenderEffect effect2)\n"
  "make(const RenderEffect effect1, const RenderEffect effect2, const RenderEffect effect3)\n"
  "make(const RenderEffect effect1, const RenderEffect effect2, const RenderEffect effect3, const RenderEffect effect4)\n"
  "\n"
  "/**\n"
  " * Returns a RenderEffects with one effect set.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a RenderEffects with two effects set.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a RenderEffects with three effects set.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a RenderEffects with four effects set.\n"
  " */";
#else
static const char *Dtool_RenderEffects_make_288_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffects > RenderEffects::add_effect(RenderEffect const *effect) const
 */
static PyObject *Dtool_RenderEffects_add_effect_289(PyObject *self, PyObject *arg) {
  RenderEffects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffects)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffects > RenderEffects::add_effect(RenderEffect const *effect) const
  RenderEffect const *arg_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderEffect, 1, "RenderEffects.add_effect", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderEffects > return_value = ((*(const RenderEffects*)local_this).add_effect)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderEffects const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffects, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_effect(RenderEffects self, const RenderEffect effect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_add_effect_289_comment =
  "C++ Interface:\n"
  "add_effect(RenderEffects self, const RenderEffect effect)\n"
  "\n"
  "/**\n"
  " * Returns a new RenderEffects object that represents the same as the source\n"
  " * state, with the new RenderEffect added.  If there is already a RenderEffect\n"
  " * with the same type, it is replaced.\n"
  " */";
#else
static const char *Dtool_RenderEffects_add_effect_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffects > RenderEffects::remove_effect(TypeHandle type) const
 */
static PyObject *Dtool_RenderEffects_remove_effect_290(PyObject *self, PyObject *arg) {
  RenderEffects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffects)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffects > RenderEffects::remove_effect(TypeHandle type) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RenderEffects.remove_effect", "TypeHandle");
  }
  ConstPointerTo< RenderEffects > return_value = ((*(const RenderEffects*)local_this).remove_effect)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffects const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffects, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_effect(RenderEffects self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_remove_effect_290_comment =
  "C++ Interface:\n"
  "remove_effect(RenderEffects self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Returns a new RenderEffects object that represents the same as the source\n"
  " * state, with the indicated RenderEffect removed.\n"
  " */";
#else
static const char *Dtool_RenderEffects_remove_effect_290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RenderEffects::output(std::ostream &out) const
 */
static PyObject *Dtool_RenderEffects_output_291(PyObject *self, PyObject *arg) {
  RenderEffects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffects)) {
    return nullptr;
  }
  // 1-void RenderEffects::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "RenderEffects.output", false, true);
  if (arg_this != nullptr) {
    ((*(const RenderEffects*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(RenderEffects self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_output_291_comment =
  "C++ Interface:\n"
  "output(RenderEffects self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_RenderEffects_output_291_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RenderEffects::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_RenderEffects_write_292(PyObject *self, PyObject *args, PyObject *kwds) {
  RenderEffects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RenderEffects)) {
    return nullptr;
  }
  // 1-void RenderEffects::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "RenderEffects.write", false, true);
    if (param1_this != nullptr) {
      ((*(const RenderEffects*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(RenderEffects self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_write_292_comment =
  "C++ Interface:\n"
  "write(RenderEffects self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_RenderEffects_write_292_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int RenderEffects::get_num_states(void)
 */
static PyObject *Dtool_RenderEffects_get_num_states_293(PyObject *, PyObject *) {
  // 1-static int RenderEffects::get_num_states(void)
  int return_value = (RenderEffects::get_num_states)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_get_num_states_293_comment =
  "C++ Interface:\n"
  "get_num_states()\n"
  "\n"
  "/**\n"
  " * Returns the total number of unique RenderEffects objects allocated in the\n"
  " * world.  This will go up and down during normal operations.\n"
  " */";
#else
static const char *Dtool_RenderEffects_get_num_states_293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void RenderEffects::list_states(std::ostream &out)
 */
static PyObject *Dtool_RenderEffects_list_states_294(PyObject *, PyObject *arg) {
  // 1-static void RenderEffects::list_states(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "RenderEffects.list_states", false, true);
  if (arg_this != nullptr) {
    (RenderEffects::list_states)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_states(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_list_states_294_comment =
  "C++ Interface:\n"
  "list_states(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists all of the RenderEffects in the cache to the output stream, one per\n"
  " * line.  This can be quite a lot of output if the cache is large, so be\n"
  " * prepared.\n"
  " */";
#else
static const char *Dtool_RenderEffects_list_states_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool RenderEffects::validate_states(void)
 */
static PyObject *Dtool_RenderEffects_validate_states_295(PyObject *, PyObject *) {
  // 1-static bool RenderEffects::validate_states(void)
  bool return_value = (RenderEffects::validate_states)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_validate_states_295_comment =
  "C++ Interface:\n"
  "validate_states()\n"
  "\n"
  "/**\n"
  " * Ensures that the cache is still stored in sorted order.  Returns true if\n"
  " * so, false if there is a problem (which implies someone has modified one of\n"
  " * the supposedly-const RenderEffects objects).\n"
  " */";
#else
static const char *Dtool_RenderEffects_validate_states_295_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RenderEffects::get_class_type(void)
 */
static PyObject *Dtool_RenderEffects_get_class_type_296(PyObject *, PyObject *) {
  // 1-static TypeHandle RenderEffects::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RenderEffects::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RenderEffects_get_class_type_296_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RenderEffects_get_class_type_296_comment = nullptr;
#endif

static int Dtool_Init_RenderEffects(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_RenderEffects(PyObject *args, CPT(RenderEffects) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_RenderEffects)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect)
    RenderEffect const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_RenderEffect);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderEffects > return_value = (RenderEffects::make)(arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((RenderEffects const *) return_value.p());
        return true;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "make", 2, 2, &param0, &param1)) {
          RenderEffect const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderEffect);
          RenderEffect const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderEffect);
          if (param0_this != nullptr && param1_this != nullptr) {
            ConstPointerTo< RenderEffects > return_value = (RenderEffects::make)(param0_this, param1_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((RenderEffects const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2, RenderEffect const *effect3)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_UnpackTuple(args, "make", 3, 3, &param0, &param1, &param2)) {
          RenderEffect const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderEffect);
          RenderEffect const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderEffect);
          RenderEffect const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderEffect);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            ConstPointerTo< RenderEffects > return_value = (RenderEffects::make)(param0_this, param1_this, param2_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((RenderEffects const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-static ConstPointerTo< RenderEffects > RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2, RenderEffect const *effect3, RenderEffect const *effect4)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        if (PyArg_UnpackTuple(args, "make", 4, 4, &param0, &param1, &param2, &param3)) {
          RenderEffect const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_RenderEffect);
          RenderEffect const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderEffect);
          RenderEffect const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderEffect);
          RenderEffect const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_RenderEffect);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ConstPointerTo< RenderEffects > return_value = (RenderEffects::make)(param0_this, param1_this, param2_this, param3_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((RenderEffects const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_RenderEffects(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RenderEffects) {
    printf("RenderEffects ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RenderEffects *local_this = (RenderEffects *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RenderEffects) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RenderEffects(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RenderEffects) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RenderEffects*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RenderEffects*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RenderEffects*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RenderEffects*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PandaNode
 */
/**
 * Python function wrapper for:
 * virtual PandaNode *PandaNode::combine_with(PandaNode *other)
 */
static PyObject *Dtool_PandaNode_combine_with_308(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.combine_with")) {
    return nullptr;
  }
  // 1-virtual PandaNode *PandaNode::combine_with(PandaNode *other)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "PandaNode.combine_with", false, true);
  if (arg_this != nullptr) {
    PandaNode *return_value = ((*local_this).combine_with)(arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "combine_with(const PandaNode self, PandaNode other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_combine_with_308_comment =
  "C++ Interface:\n"
  "combine_with(const PandaNode self, PandaNode other)\n"
  "\n"
  "// published so that characters can be combined.\n"
  "\n"
  "/**\n"
  " * Collapses this PandaNode with the other PandaNode, if possible, and returns\n"
  " * a pointer to the combined PandaNode, or NULL if the two PandaNodes cannot\n"
  " * safely be combined.\n"
  " *\n"
  " * The return value may be this, other, or a new PandaNode altogether.\n"
  " *\n"
  " * This function is called from GraphReducer::flatten(), and need not deal\n"
  " * with children; its job is just to decide whether to collapse the two\n"
  " * PandaNodes and what the collapsed PandaNode should look like.\n"
  " */";
#else
static const char *Dtool_PandaNode_combine_with_308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PandaNode *PandaNode::make_copy(void) const
 */
static PyObject *Dtool_PandaNode_make_copy_309(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-virtual PandaNode *PandaNode::make_copy(void) const
  PandaNode *return_value = ((*(const PandaNode*)local_this).make_copy)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_make_copy_309_comment =
  "C++ Interface:\n"
  "make_copy(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns a newly-allocated PandaNode that is a shallow copy of this one.  It\n"
  " * will be a different pointer, but its internal data may or may not be shared\n"
  " * with that of the original PandaNode.  No children will be copied.\n"
  " */";
#else
static const char *Dtool_PandaNode_make_copy_309_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > PandaNode::copy_subgraph(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_copy_subgraph_310(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-PointerTo< PandaNode > PandaNode::copy_subgraph(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.copy_subgraph", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      PointerTo< PandaNode > return_value = ((*(const PandaNode*)local_this).copy_subgraph)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      PandaNode *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_subgraph(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_copy_subgraph_310_comment =
  "C++ Interface:\n"
  "copy_subgraph(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Allocates and returns a complete copy of this PandaNode and the entire\n"
  " * scene graph rooted at this PandaNode.  Some data may still be shared from\n"
  " * the original (e.g.  vertex index tables), but nothing that will impede\n"
  " * normal use of the PandaNode.\n"
  " */";
#else
static const char *Dtool_PandaNode_copy_subgraph_310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > PandaNode::__copy__(void) const
 */
static PyObject *Dtool_PandaNode_copy_311(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-PointerTo< PandaNode > PandaNode::__copy__(void) const
  PointerTo< PandaNode > return_value = invoke_extension((const PandaNode*)local_this).__copy__();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  PandaNode *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_copy_311_comment =
  "C++ Interface:\n"
  "__copy__(PandaNode self)\n";
#else
static const char *Dtool_PandaNode_copy_311_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PandaNode::__deepcopy__(PyObject *self, PyObject *memo) const
 */
static PyObject *Dtool_PandaNode_deepcopy_312(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-PyObject *PandaNode::__deepcopy__(PyObject *self, PyObject *memo) const
  PyObject *return_value = invoke_extension((const PandaNode*)local_this).__deepcopy__(self, arg);
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__deepcopy__(PandaNode self, object memo)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_deepcopy_312_comment =
  "C++ Interface:\n"
  "__deepcopy__(PandaNode self, object memo)\n";
#else
static const char *Dtool_PandaNode_deepcopy_312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PandaNode::get_num_parents(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_num_parents_313(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline int PandaNode::get_num_parents(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_num_parents", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*(const PandaNode*)local_this).get_num_parents)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_parents(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_num_parents_313_comment =
  "C++ Interface:\n"
  "get_num_parents(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the number of parent nodes this node has.  If this number is\n"
  " * greater than 1, the node has been multiply instanced.  The order of the\n"
  " * parent nodes is not meaningful and is not related to the order in which the\n"
  " * node was instanced to them.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_num_parents_313_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *PandaNode::get_parent(int n, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_parent_314(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline PandaNode *PandaNode::get_parent(int n, Thread *current_thread = Thread::get_current_thread()) const
  int param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"n", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:get_parent", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.get_parent", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      PandaNode *return_value = ((*(const PandaNode*)local_this).get_parent)((int)param1, param2_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent(PandaNode self, int n, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_parent_314_comment =
  "C++ Interface:\n"
  "get_parent(PandaNode self, int n, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the nth parent node of this node.  See get_num_parents().  Also see\n"
  " * get_parents(), if your intention is to iterate through the complete list of\n"
  " * parents; get_parents() is preferable in this case.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_parent_314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PandaNode::find_parent(PandaNode *node, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_find_parent_315(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline int PandaNode::find_parent(PandaNode *node, Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"node", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:find_parent", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "PandaNode.find_parent", false, true);
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.find_parent", false, true);
    }
    if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
      int return_value = ((*(const PandaNode*)local_this).find_parent)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_parent(PandaNode self, PandaNode node, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_find_parent_315_comment =
  "C++ Interface:\n"
  "find_parent(PandaNode self, PandaNode node, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the index of the indicated parent node, if it is a parent, or -1 if\n"
  " * it is not.\n"
  " */";
#else
static const char *Dtool_PandaNode_find_parent_315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PandaNode::get_num_children(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_num_children_317(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline int PandaNode::get_num_children(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_num_children", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*(const PandaNode*)local_this).get_num_children)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_children(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_num_children_317_comment =
  "C++ Interface:\n"
  "get_num_children(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the number of child nodes this node has.  The order of the child\n"
  " * nodes *is* meaningful and is based on the sort number that was passed to\n"
  " * add_child(), and also on the order in which the nodes were added.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_num_children_317_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *PandaNode::get_child(int n, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_child_318(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline PandaNode *PandaNode::get_child(int n, Thread *current_thread = Thread::get_current_thread()) const
  int param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"n", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:get_child", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.get_child", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      PandaNode *return_value = ((*(const PandaNode*)local_this).get_child)((int)param1, param2_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(PandaNode self, int n, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_child_318_comment =
  "C++ Interface:\n"
  "get_child(PandaNode self, int n, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the nth child node of this node.  See get_num_children().  Also see\n"
  " * get_children(), if your intention is to iterate through the complete list\n"
  " * of children; get_children() is preferable in this case.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_child_318_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PandaNode::get_child_sort(int n, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_child_sort_319(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline int PandaNode::get_child_sort(int n, Thread *current_thread = Thread::get_current_thread()) const
  int param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"n", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:get_child_sort", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.get_child_sort", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      int return_value = ((*(const PandaNode*)local_this).get_child_sort)((int)param1, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child_sort(PandaNode self, int n, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_child_sort_319_comment =
  "C++ Interface:\n"
  "get_child_sort(PandaNode self, int n, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the sort index of the nth child node of this node (that is, the\n"
  " * number that was passed to add_child()).  See get_num_children().\n"
  " */";
#else
static const char *Dtool_PandaNode_get_child_sort_319_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PandaNode::find_child(PandaNode *node, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_find_child_320(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline int PandaNode::find_child(PandaNode *node, Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"node", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:find_child", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "PandaNode.find_child", false, true);
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.find_child", false, true);
    }
    if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
      int return_value = ((*(const PandaNode*)local_this).find_child)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_child(PandaNode self, PandaNode node, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_find_child_320_comment =
  "C++ Interface:\n"
  "find_child(PandaNode self, PandaNode node, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the index of the indicated child node, if it is a child, or -1 if\n"
  " * it is not.\n"
  " */";
#else
static const char *Dtool_PandaNode_find_child_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PandaNode::count_num_descendants(void) const
 */
static PyObject *Dtool_PandaNode_count_num_descendants_322(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-int PandaNode::count_num_descendants(void) const
  int return_value = ((*(const PandaNode*)local_this).count_num_descendants)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_count_num_descendants_322_comment =
  "C++ Interface:\n"
  "count_num_descendants(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of nodes at and below this level.\n"
  " */";
#else
static const char *Dtool_PandaNode_count_num_descendants_322_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::add_child(PandaNode *child_node, int sort = 0, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_add_child_323(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.add_child")) {
    return nullptr;
  }
  // 1-void PandaNode::add_child(PandaNode *child_node, int sort = 0, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  int param2 = 0;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"child_node", "sort", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|iO:add_child", (char **)keyword_list, &param1, &param2, &param3)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "PandaNode.add_child", false, true);
    Thread *param3_this;
    if (param3 == nullptr) {
      param3_this = Thread::get_current_thread();
    } else {
      param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "PandaNode.add_child", false, true);
    }
    if (param1_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
      ((*local_this).add_child)(param1_this, (int)param2, param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_child(const PandaNode self, PandaNode child_node, int sort, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_add_child_323_comment =
  "C++ Interface:\n"
  "add_child(const PandaNode self, PandaNode child_node, int sort, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Adds a new child to the node.  The child is added in the relative position\n"
  " * indicated by sort; if all children have the same sort index, the child is\n"
  " * added at the end.\n"
  " *\n"
  " * If the same child is added to a node more than once, the previous instance\n"
  " * is first removed.\n"
  " */";
#else
static const char *Dtool_PandaNode_add_child_323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PandaNode::remove_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
 * void PandaNode::remove_child(int child_index, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_remove_child_324(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.remove_child")) {
    return nullptr;
  }
  {
    // -2 bool PandaNode::remove_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"child_node", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:remove_child", (char **)keyword_list, &param1, &param2)) {
      PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "PandaNode.remove_child", false, false);
      Thread *param2_this;
      if (param2 == nullptr) {
        param2_this = Thread::get_current_thread();
      } else {
        param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.remove_child", false, false);
      }
      if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
        bool return_value = ((*local_this).remove_child)(param1_this, param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void PandaNode::remove_child(int child_index, Thread *current_thread = Thread::get_current_thread())
    int param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"child_index", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:remove_child", (char **)keyword_list, &param1, &param2)) {
      Thread *param2_this;
      if (param2 == nullptr) {
        param2_this = Thread::get_current_thread();
      } else {
        param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.remove_child", false, false);
      }
      if ((param2 == nullptr || param2_this != nullptr)) {
        ((*local_this).remove_child)((int)param1, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool PandaNode::remove_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
  // No coercion possible: void PandaNode::remove_child(int child_index, Thread *current_thread = Thread::get_current_thread())
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_child(const PandaNode self, PandaNode child_node, Thread current_thread)\n"
      "remove_child(const PandaNode self, int child_index, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_remove_child_324_comment =
  "C++ Interface:\n"
  "remove_child(const PandaNode self, PandaNode child_node, Thread current_thread)\n"
  "remove_child(const PandaNode self, int child_index, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Removes the nth child from the node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the indicated child from the node.  Returns true if the child was\n"
  " * removed, false if it was not already a child of the node.  This will also\n"
  " * successfully remove the child if it had been stashed.\n"
  " */";
#else
static const char *Dtool_PandaNode_remove_child_324_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PandaNode::replace_child(PandaNode *orig_child, PandaNode *new_child, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_replace_child_325(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.replace_child")) {
    return nullptr;
  }
  // 1-bool PandaNode::replace_child(PandaNode *orig_child, PandaNode *new_child, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  PyObject *param2;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"orig_child", "new_child", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:replace_child", (char **)keyword_list, &param1, &param2, &param3)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "PandaNode.replace_child", false, true);
    PandaNode *param2_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PandaNode, 2, "PandaNode.replace_child", false, true);
    Thread *param3_this;
    if (param3 == nullptr) {
      param3_this = Thread::get_current_thread();
    } else {
      param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "PandaNode.replace_child", false, true);
    }
    if (param1_this != nullptr && param2_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
      bool return_value = ((*local_this).replace_child)(param1_this, param2_this, param3_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "replace_child(const PandaNode self, PandaNode orig_child, PandaNode new_child, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_replace_child_325_comment =
  "C++ Interface:\n"
  "replace_child(const PandaNode self, PandaNode orig_child, PandaNode new_child, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Searches for the orig_child node in the node's list of children, and\n"
  " * replaces it with the new_child instead.  Returns true if the replacement is\n"
  " * made, or false if the node is not a child or if there is some other\n"
  " * problem.\n"
  " */";
#else
static const char *Dtool_PandaNode_replace_child_325_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PandaNode::stash_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
 * void PandaNode::stash_child(int child_index, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_stash_child_326(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.stash_child")) {
    return nullptr;
  }
  {
    // -2 inline bool PandaNode::stash_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"child_node", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:stash_child", (char **)keyword_list, &param1, &param2)) {
      PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "PandaNode.stash_child", false, false);
      Thread *param2_this;
      if (param2 == nullptr) {
        param2_this = Thread::get_current_thread();
      } else {
        param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.stash_child", false, false);
      }
      if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
        bool return_value = ((*local_this).stash_child)(param1_this, param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void PandaNode::stash_child(int child_index, Thread *current_thread = Thread::get_current_thread())
    int param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"child_index", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:stash_child", (char **)keyword_list, &param1, &param2)) {
      Thread *param2_this;
      if (param2 == nullptr) {
        param2_this = Thread::get_current_thread();
      } else {
        param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.stash_child", false, false);
      }
      if ((param2 == nullptr || param2_this != nullptr)) {
        ((*local_this).stash_child)((int)param1, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline bool PandaNode::stash_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
  // No coercion possible: void PandaNode::stash_child(int child_index, Thread *current_thread = Thread::get_current_thread())
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "stash_child(const PandaNode self, PandaNode child_node, Thread current_thread)\n"
      "stash_child(const PandaNode self, int child_index, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_stash_child_326_comment =
  "C++ Interface:\n"
  "stash_child(const PandaNode self, PandaNode child_node, Thread current_thread)\n"
  "stash_child(const PandaNode self, int child_index, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Stashes the indicated child node.  This removes the child from the list of\n"
  " * active children and puts it on a special list of stashed children.  This\n"
  " * child node no longer contributes to the bounding volume of the PandaNode,\n"
  " * and is not visited in normal traversals.  It is invisible and uncollidable.\n"
  " * The child may later be restored by calling unstash_child().\n"
  " *\n"
  " * This function returns true if the child node was successfully stashed, or\n"
  " * false if it was not a child of the node in the first place (e.g.  it was\n"
  " * previously stashed).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stashes the indicated child node.  This removes the child from the list of\n"
  " * active children and puts it on a special list of stashed children.  This\n"
  " * child node no longer contributes to the bounding volume of the PandaNode,\n"
  " * and is not visited in normal traversals.  It is invisible and uncollidable.\n"
  " * The child may later be restored by calling unstash_child().\n"
  " *\n"
  " * This can only be called from the top pipeline stage (i.e.  from App).\n"
  " */";
#else
static const char *Dtool_PandaNode_stash_child_326_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PandaNode::unstash_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
 * void PandaNode::unstash_child(int stashed_index, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_unstash_child_327(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.unstash_child")) {
    return nullptr;
  }
  {
    // -2 inline bool PandaNode::unstash_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"child_node", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:unstash_child", (char **)keyword_list, &param1, &param2)) {
      PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "PandaNode.unstash_child", false, false);
      Thread *param2_this;
      if (param2 == nullptr) {
        param2_this = Thread::get_current_thread();
      } else {
        param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.unstash_child", false, false);
      }
      if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
        bool return_value = ((*local_this).unstash_child)(param1_this, param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void PandaNode::unstash_child(int stashed_index, Thread *current_thread = Thread::get_current_thread())
    int param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"stashed_index", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:unstash_child", (char **)keyword_list, &param1, &param2)) {
      Thread *param2_this;
      if (param2 == nullptr) {
        param2_this = Thread::get_current_thread();
      } else {
        param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.unstash_child", false, false);
      }
      if ((param2 == nullptr || param2_this != nullptr)) {
        ((*local_this).unstash_child)((int)param1, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline bool PandaNode::unstash_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
  // No coercion possible: void PandaNode::unstash_child(int stashed_index, Thread *current_thread = Thread::get_current_thread())
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unstash_child(const PandaNode self, PandaNode child_node, Thread current_thread)\n"
      "unstash_child(const PandaNode self, int stashed_index, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_unstash_child_327_comment =
  "C++ Interface:\n"
  "unstash_child(const PandaNode self, PandaNode child_node, Thread current_thread)\n"
  "unstash_child(const PandaNode self, int stashed_index, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the indicated stashed node to normal child status.  This removes\n"
  " * the child from the list of stashed children and puts it on the normal list\n"
  " * of active children.  This child node once again contributes to the bounding\n"
  " * volume of the PandaNode, and will be visited in normal traversals.  It is\n"
  " * visible and collidable.\n"
  " *\n"
  " * This function returns true if the child node was successfully stashed, or\n"
  " * false if it was not a child of the node in the first place (e.g.  it was\n"
  " * previously stashed).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the indicated stashed node to normal child status.  This removes\n"
  " * the child from the list of stashed children and puts it on the normal list\n"
  " * of active children.  This child node once again contributes to the bounding\n"
  " * volume of the PandaNode, and will be visited in normal traversals.  It is\n"
  " * visible and collidable.\n"
  " *\n"
  " * This can only be called from the top pipeline stage (i.e.  from App).\n"
  " */";
#else
static const char *Dtool_PandaNode_unstash_child_327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PandaNode::get_num_stashed(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_num_stashed_328(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline int PandaNode::get_num_stashed(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_num_stashed", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*(const PandaNode*)local_this).get_num_stashed)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_stashed(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_num_stashed_328_comment =
  "C++ Interface:\n"
  "get_num_stashed(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the number of stashed nodes this node has.  These are former\n"
  " * children of the node that have been moved to the special stashed list via\n"
  " * stash_child().\n"
  " */";
#else
static const char *Dtool_PandaNode_get_num_stashed_328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode::Stashed PandaNode::get_stashed(Thread *current_thread = Thread::get_current_thread()) const
 * inline PandaNode *PandaNode::get_stashed(int n, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_stashed_329(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PandaNode::Stashed PandaNode::get_stashed(Thread *current_thread) const
      PandaNode::Stashed *return_value = new PandaNode::Stashed(((*(const PandaNode*)local_this).get_stashed)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PandaNode_Stashed, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 inline PandaNode *PandaNode::get_stashed(int n, Thread *current_thread = Thread::get_current_thread()) const
        int param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"n", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:get_stashed", (char **)keyword_list, &param1, &param2)) {
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.get_stashed", false, false);
          }
          if ((param2 == nullptr || param2_this != nullptr)) {
            PandaNode *return_value = ((*(const PandaNode*)local_this).get_stashed)((int)param1, param2_this);
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (Dtool_CheckErrorOccurred()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return nullptr;
            }
            if (return_value == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PandaNode::Stashed PandaNode::get_stashed(Thread *current_thread = Thread::get_current_thread()) const
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "current_thread")) {
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_stashed", false, false);
          if (param1_this != nullptr) {
            PandaNode::Stashed *return_value = new PandaNode::Stashed(((*(const PandaNode*)local_this).get_stashed)(param1_this));
            if (return_value == nullptr) {
              return PyErr_NoMemory();
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PandaNode_Stashed, true, false);
          }
        }
      }

      // No coercion possible: inline PandaNode *PandaNode::get_stashed(int n, Thread *current_thread = Thread::get_current_thread()) const
      // No coercion possible: inline PandaNode::Stashed PandaNode::get_stashed(Thread *current_thread = Thread::get_current_thread()) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_stashed() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_stashed(PandaNode self)\n"
      "get_stashed(PandaNode self, int n, Thread current_thread)\n"
      "get_stashed(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_stashed_329_comment =
  "C++ Interface:\n"
  "get_stashed(PandaNode self)\n"
  "get_stashed(PandaNode self, int n, Thread current_thread)\n"
  "get_stashed(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the nth stashed child of this node.  See get_num_stashed().  Also\n"
  " * see get_stashed(), if your intention is to iterate through the complete\n"
  " * list of stashed children; get_stashed() is preferable in this case.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns an object that can be used to walk through the list of children of\n"
  " * the node.  When you intend to visit multiple children, using this is\n"
  " * slightly faster than calling get_stashed() directly on the PandaNode, since\n"
  " * this object avoids reopening the PipelineCycler each time.\n"
  " *\n"
  " * This object also protects you from self-modifying loops (e.g.  adding or\n"
  " * removing children during traversal), since a virtual copy of the children\n"
  " * is made ahead of time.  The virtual copy is fast--it is a form of copy-on-\n"
  " * write, so the list is not actually copied unless it is modified during the\n"
  " * traversal.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_stashed_329_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PandaNode::get_stashed_sort(int n, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_stashed_sort_330(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline int PandaNode::get_stashed_sort(int n, Thread *current_thread = Thread::get_current_thread()) const
  int param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"n", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:get_stashed_sort", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.get_stashed_sort", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      int return_value = ((*(const PandaNode*)local_this).get_stashed_sort)((int)param1, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_stashed_sort(PandaNode self, int n, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_stashed_sort_330_comment =
  "C++ Interface:\n"
  "get_stashed_sort(PandaNode self, int n, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the sort index of the nth stashed node of this node (that is, the\n"
  " * number that was passed to add_child()).  See get_num_stashed().\n"
  " */";
#else
static const char *Dtool_PandaNode_get_stashed_sort_330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PandaNode::find_stashed(PandaNode *node, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_find_stashed_331(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline int PandaNode::find_stashed(PandaNode *node, Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"node", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:find_stashed", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "PandaNode.find_stashed", false, true);
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.find_stashed", false, true);
    }
    if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
      int return_value = ((*(const PandaNode*)local_this).find_stashed)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_stashed(PandaNode self, PandaNode node, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_find_stashed_331_comment =
  "C++ Interface:\n"
  "find_stashed(PandaNode self, PandaNode node, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the index of the indicated stashed node, if it is a stashed child,\n"
  " * or -1 if it is not.\n"
  " */";
#else
static const char *Dtool_PandaNode_find_stashed_331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::add_stashed(PandaNode *child_node, int sort = 0, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_add_stashed_333(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.add_stashed")) {
    return nullptr;
  }
  // 1-void PandaNode::add_stashed(PandaNode *child_node, int sort = 0, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  int param2 = 0;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"child_node", "sort", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|iO:add_stashed", (char **)keyword_list, &param1, &param2, &param3)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "PandaNode.add_stashed", false, true);
    Thread *param3_this;
    if (param3 == nullptr) {
      param3_this = Thread::get_current_thread();
    } else {
      param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "PandaNode.add_stashed", false, true);
    }
    if (param1_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
      ((*local_this).add_stashed)(param1_this, (int)param2, param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_stashed(const PandaNode self, PandaNode child_node, int sort, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_add_stashed_333_comment =
  "C++ Interface:\n"
  "add_stashed(const PandaNode self, PandaNode child_node, int sort, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Adds a new child to the node, directly as a stashed child.  The child is\n"
  " * not added in the normal sense, but will be revealed if unstash_child() is\n"
  " * called on it later.\n"
  " *\n"
  " * If the same child is added to a node more than once, the previous instance\n"
  " * is first removed.\n"
  " *\n"
  " * This can only be called from the top pipeline stage (i.e.  from App).\n"
  " */";
#else
static const char *Dtool_PandaNode_add_stashed_333_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::remove_stashed(int child_index, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_remove_stashed_334(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.remove_stashed")) {
    return nullptr;
  }
  // 1-void PandaNode::remove_stashed(int child_index, Thread *current_thread = Thread::get_current_thread())
  int param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"child_index", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:remove_stashed", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.remove_stashed", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).remove_stashed)((int)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_stashed(const PandaNode self, int child_index, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_remove_stashed_334_comment =
  "C++ Interface:\n"
  "remove_stashed(const PandaNode self, int child_index, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Removes the nth stashed child from the node.\n"
  " */";
#else
static const char *Dtool_PandaNode_remove_stashed_334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::remove_all_children(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_remove_all_children_335(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.remove_all_children")) {
    return nullptr;
  }
  // 1-void PandaNode::remove_all_children(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.remove_all_children", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).remove_all_children)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_all_children(const PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_remove_all_children_335_comment =
  "C++ Interface:\n"
  "remove_all_children(const PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Removes all the children from the node at once, including stashed children.\n"
  " *\n"
  " * This can only be called from the top pipeline stage (i.e.  from App).\n"
  " */";
#else
static const char *Dtool_PandaNode_remove_all_children_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::steal_children(PandaNode *other, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_steal_children_336(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.steal_children")) {
    return nullptr;
  }
  // 1-void PandaNode::steal_children(PandaNode *other, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"other", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:steal_children", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "PandaNode.steal_children", false, true);
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.steal_children", false, true);
    }
    if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).steal_children)(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "steal_children(const PandaNode self, PandaNode other, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_steal_children_336_comment =
  "C++ Interface:\n"
  "steal_children(const PandaNode self, PandaNode other, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Moves all the children from the other node onto this node.\n"
  " *\n"
  " * Any NodePaths to child nodes of the other node are truncated, rather than\n"
  " * moved to the new parent.\n"
  " */";
#else
static const char *Dtool_PandaNode_steal_children_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::copy_children(PandaNode *other, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_copy_children_337(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.copy_children")) {
    return nullptr;
  }
  // 1-void PandaNode::copy_children(PandaNode *other, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"other", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:copy_children", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "PandaNode.copy_children", false, true);
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.copy_children", false, true);
    }
    if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).copy_children)(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_children(const PandaNode self, PandaNode other, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_copy_children_337_comment =
  "C++ Interface:\n"
  "copy_children(const PandaNode self, PandaNode other, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Makes another instance of all the children of the other node, copying them\n"
  " * to this node.\n"
  " */";
#else
static const char *Dtool_PandaNode_copy_children_337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_attrib(RenderAttrib const *attrib, int override = 0)
 */
static PyObject *Dtool_PandaNode_set_attrib_338(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_attrib")) {
    return nullptr;
  }
  // 1-void PandaNode::set_attrib(RenderAttrib const *attrib, int override = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"attrib", "override", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_attrib", (char **)keyword_list, &param1, &param2)) {
    RenderAttrib const *param1_this = (RenderAttrib *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_RenderAttrib, 1, "PandaNode.set_attrib", true, true);
    if (param1_this != nullptr) {
      ((*local_this).set_attrib)(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_attrib(const PandaNode self, const RenderAttrib attrib, int override)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_attrib_338_comment =
  "C++ Interface:\n"
  "set_attrib(const PandaNode self, const RenderAttrib attrib, int override)\n"
  "\n"
  "/**\n"
  " * Adds the indicated render attribute to the scene graph on this node.  This\n"
  " * attribute will now apply to this node and everything below.  If there was\n"
  " * already an attribute of the same type, it is replaced.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_attrib_338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< RenderAttrib > PandaNode::get_attrib(TypeHandle type) const
 * inline ConstPointerTo< RenderAttrib > PandaNode::get_attrib(int slot) const
 */
static PyObject *Dtool_PandaNode_get_attrib_339(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  {
    // -2 inline ConstPointerTo< RenderAttrib > PandaNode::get_attrib(TypeHandle type) const
    TypeHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = ((*(const PandaNode*)local_this).get_attrib)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline ConstPointerTo< RenderAttrib > PandaNode::get_attrib(int slot) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = ((*(const PandaNode*)local_this).get_attrib)((int)arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline ConstPointerTo< RenderAttrib > PandaNode::get_attrib(TypeHandle type) const
    TypeHandle arg_local;
    TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      ConstPointerTo< RenderAttrib > return_value = ((*(const PandaNode*)local_this).get_attrib)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }

  // No coercion possible: inline ConstPointerTo< RenderAttrib > PandaNode::get_attrib(int slot) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_attrib(PandaNode self, TypeHandle type)\n"
      "get_attrib(PandaNode self, int slot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_attrib_339_comment =
  "C++ Interface:\n"
  "get_attrib(PandaNode self, TypeHandle type)\n"
  "get_attrib(PandaNode self, int slot)\n"
  "\n"
  "/**\n"
  " * Returns the render attribute of the indicated type, if it is defined on the\n"
  " * node, or NULL if it is not.  This checks only what is set on this\n"
  " * particular node level, and has nothing to do with what render attributes\n"
  " * may be inherited from parent nodes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the render attribute of the indicated type, if it is defined on the\n"
  " * node, or NULL if it is not.  This checks only what is set on this\n"
  " * particular node level, and has nothing to do with what render attributes\n"
  " * may be inherited from parent nodes.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_attrib_339_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PandaNode::has_attrib(TypeHandle type) const
 * inline bool PandaNode::has_attrib(int slot) const
 */
static PyObject *Dtool_PandaNode_has_attrib_340(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  {
    // -2 inline bool PandaNode::has_attrib(TypeHandle type) const
    TypeHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
    if (arg_this != nullptr) {
      bool return_value = ((*(const PandaNode*)local_this).has_attrib)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool PandaNode::has_attrib(int slot) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      bool return_value = ((*(const PandaNode*)local_this).has_attrib)((int)arg_val);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool PandaNode::has_attrib(TypeHandle type) const
    TypeHandle arg_local;
    TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*(const PandaNode*)local_this).has_attrib)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: inline bool PandaNode::has_attrib(int slot) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_attrib(PandaNode self, TypeHandle type)\n"
      "has_attrib(PandaNode self, int slot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_has_attrib_340_comment =
  "C++ Interface:\n"
  "has_attrib(PandaNode self, TypeHandle type)\n"
  "has_attrib(PandaNode self, int slot)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a render attribute of the indicated type defined\n"
  " * on this node, or false if there is not.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if there is a render attribute of the indicated type defined\n"
  " * on this node, or false if there is not.\n"
  " */";
#else
static const char *Dtool_PandaNode_has_attrib_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PandaNode::clear_attrib(TypeHandle type)
 * void PandaNode::clear_attrib(int slot)
 */
static PyObject *Dtool_PandaNode_clear_attrib_341(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.clear_attrib")) {
    return nullptr;
  }
  {
    // -2 inline void PandaNode::clear_attrib(TypeHandle type)
    TypeHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
    if (arg_this != nullptr) {
      ((*local_this).clear_attrib)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PandaNode::clear_attrib(int slot)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      ((*local_this).clear_attrib)((int)arg_val);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PandaNode::clear_attrib(TypeHandle type)
    TypeHandle arg_local;
    TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).clear_attrib)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void PandaNode::clear_attrib(int slot)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_attrib(const PandaNode self, TypeHandle type)\n"
      "clear_attrib(const PandaNode self, int slot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_clear_attrib_341_comment =
  "C++ Interface:\n"
  "clear_attrib(const PandaNode self, TypeHandle type)\n"
  "clear_attrib(const PandaNode self, int slot)\n"
  "\n"
  "/**\n"
  " * Removes the render attribute of the given type from this node.  This node,\n"
  " * and the subgraph below, will now inherit the indicated render attribute\n"
  " * from the nodes above this one.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the render attribute of the given type from this node.  This node,\n"
  " * and the subgraph below, will now inherit the indicated render attribute\n"
  " * from the nodes above this one.\n"
  " */";
#else
static const char *Dtool_PandaNode_clear_attrib_341_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_effect(RenderEffect const *effect)
 */
static PyObject *Dtool_PandaNode_set_effect_342(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_effect")) {
    return nullptr;
  }
  // 1-void PandaNode::set_effect(RenderEffect const *effect)
  RenderEffect const *arg_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderEffect, 1, "PandaNode.set_effect", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_effect)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_effect(const PandaNode self, const RenderEffect effect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_effect_342_comment =
  "C++ Interface:\n"
  "set_effect(const PandaNode self, const RenderEffect effect)\n"
  "\n"
  "/**\n"
  " * Adds the indicated render effect to the scene graph on this node.  If there\n"
  " * was already an effect of the same type, it is replaced.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_effect_342_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< RenderEffect > PandaNode::get_effect(TypeHandle type) const
 */
static PyObject *Dtool_PandaNode_get_effect_343(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< RenderEffect > PandaNode::get_effect(TypeHandle type) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PandaNode.get_effect", "TypeHandle");
  }
  ConstPointerTo< RenderEffect > return_value = ((*(const PandaNode*)local_this).get_effect)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffect const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_effect(PandaNode self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_effect_343_comment =
  "C++ Interface:\n"
  "get_effect(PandaNode self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Returns the render effect of the indicated type, if it is defined on the\n"
  " * node, or NULL if it is not.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_effect_343_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PandaNode::has_effect(TypeHandle type) const
 */
static PyObject *Dtool_PandaNode_has_effect_344(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline bool PandaNode::has_effect(TypeHandle type) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PandaNode.has_effect", "TypeHandle");
  }
  bool return_value = ((*(const PandaNode*)local_this).has_effect)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_effect(PandaNode self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_has_effect_344_comment =
  "C++ Interface:\n"
  "has_effect(PandaNode self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a render effect of the indicated type defined on\n"
  " * this node, or false if there is not.\n"
  " */";
#else
static const char *Dtool_PandaNode_has_effect_344_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::clear_effect(TypeHandle type)
 */
static PyObject *Dtool_PandaNode_clear_effect_345(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.clear_effect")) {
    return nullptr;
  }
  // 1-void PandaNode::clear_effect(TypeHandle type)
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PandaNode.clear_effect", "TypeHandle");
  }
  ((*local_this).clear_effect)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_effect(const PandaNode self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_clear_effect_345_comment =
  "C++ Interface:\n"
  "clear_effect(const PandaNode self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Removes the render effect of the given type from this node.\n"
  " */";
#else
static const char *Dtool_PandaNode_clear_effect_345_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_state(RenderState const *state, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_set_state_346(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_state")) {
    return nullptr;
  }
  // 1-void PandaNode::set_state(RenderState const *state, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"state", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:set_state", (char **)keyword_list, &param1, &param2)) {
    CPT(RenderState) param1_this;
    if (!Dtool_ConstCoerce_RenderState(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PandaNode.set_state", "RenderState");
    }
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.set_state", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).set_state)(std::move(param1_this), param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_state(const PandaNode self, const RenderState state, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_state_346_comment =
  "C++ Interface:\n"
  "set_state(const PandaNode self, const RenderState state, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Sets the complete RenderState that will be applied to all nodes at this\n"
  " * level and below.  (The actual state that will be applied to lower nodes is\n"
  " * based on the composition of RenderStates from above this node as well).\n"
  " * This completely replaces whatever has been set on this node via repeated\n"
  " * calls to set_attrib().\n"
  " */";
#else
static const char *Dtool_PandaNode_set_state_346_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< RenderState > PandaNode::get_state(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_state_347(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< RenderState > PandaNode::get_state(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_state", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< RenderState > return_value = ((*(const PandaNode*)local_this).get_state)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_state(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_state_347_comment =
  "C++ Interface:\n"
  "get_state(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the complete RenderState that will be applied to all nodes at this\n"
  " * level and below, as set on this node.  This returns only the RenderState\n"
  " * set on this particular node, and has nothing to do with state that might be\n"
  " * inherited from above.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_state_347_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PandaNode::clear_state(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_clear_state_348(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.clear_state")) {
    return nullptr;
  }
  // 1-inline void PandaNode::clear_state(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.clear_state", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).clear_state)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_state(const PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_clear_state_348_comment =
  "C++ Interface:\n"
  "clear_state(const PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Resets this node to leave the render state alone.  Nodes at this level and\n"
  " * below will once again inherit their render state unchanged from the nodes\n"
  " * above this level.\n"
  " */";
#else
static const char *Dtool_PandaNode_clear_state_348_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_effects(RenderEffects const *effects, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_set_effects_351(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_effects")) {
    return nullptr;
  }
  // 1-void PandaNode::set_effects(RenderEffects const *effects, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"effects", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:set_effects", (char **)keyword_list, &param1, &param2)) {
    CPT(RenderEffects) param1_this;
    if (!Dtool_ConstCoerce_RenderEffects(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PandaNode.set_effects", "RenderEffects");
    }
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.set_effects", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).set_effects)(std::move(param1_this), param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_effects(const PandaNode self, const RenderEffects effects, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_effects_351_comment =
  "C++ Interface:\n"
  "set_effects(const PandaNode self, const RenderEffects effects, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Sets the complete RenderEffects that will be applied this node.  This\n"
  " * completely replaces whatever has been set on this node via repeated calls\n"
  " * to set_attrib().\n"
  " */";
#else
static const char *Dtool_PandaNode_set_effects_351_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< RenderEffects > PandaNode::get_effects(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_effects_352(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< RenderEffects > PandaNode::get_effects(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_effects", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< RenderEffects > return_value = ((*(const PandaNode*)local_this).get_effects)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderEffects const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffects, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_effects(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_effects_352_comment =
  "C++ Interface:\n"
  "get_effects(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the complete RenderEffects that will be applied to this node.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_effects_352_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PandaNode::clear_effects(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_clear_effects_353(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.clear_effects")) {
    return nullptr;
  }
  // 1-inline void PandaNode::clear_effects(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.clear_effects", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).clear_effects)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_effects(const PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_clear_effects_353_comment =
  "C++ Interface:\n"
  "clear_effects(const PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Resets this node to have no render effects.\n"
  " */";
#else
static const char *Dtool_PandaNode_clear_effects_353_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_set_transform_356(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_transform")) {
    return nullptr;
  }
  // 1-void PandaNode::set_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"transform", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:set_transform", (char **)keyword_list, &param1, &param2)) {
    TransformState const *param1_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TransformState, 1, "PandaNode.set_transform", true, true);
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.set_transform", false, true);
    }
    if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).set_transform)(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform(const PandaNode self, const TransformState transform, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_transform_356_comment =
  "C++ Interface:\n"
  "set_transform(const PandaNode self, const TransformState transform, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Sets the transform that will be applied to this node and below.  This\n"
  " * defines a new coordinate space at this point in the scene graph and below.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_transform_356_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< TransformState > PandaNode::get_transform(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_transform_357(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< TransformState > PandaNode::get_transform(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_transform", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< TransformState > return_value = ((*(const PandaNode*)local_this).get_transform)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      TransformState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_transform(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_transform_357_comment =
  "C++ Interface:\n"
  "get_transform(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the transform that has been set on this particular node.  This is\n"
  " * not the net transform from the root, but simply the transform on this\n"
  " * particular node.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_transform_357_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PandaNode::clear_transform(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_clear_transform_358(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.clear_transform")) {
    return nullptr;
  }
  // 1-inline void PandaNode::clear_transform(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.clear_transform", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).clear_transform)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_transform(const PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_clear_transform_358_comment =
  "C++ Interface:\n"
  "clear_transform(const PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Resets the transform on this node to the identity transform.\n"
  " */";
#else
static const char *Dtool_PandaNode_clear_transform_358_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_prev_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_set_prev_transform_361(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_prev_transform")) {
    return nullptr;
  }
  // 1-void PandaNode::set_prev_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"transform", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:set_prev_transform", (char **)keyword_list, &param1, &param2)) {
    TransformState const *param1_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TransformState, 1, "PandaNode.set_prev_transform", true, true);
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.set_prev_transform", false, true);
    }
    if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).set_prev_transform)(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_prev_transform(const PandaNode self, const TransformState transform, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_prev_transform_361_comment =
  "C++ Interface:\n"
  "set_prev_transform(const PandaNode self, const TransformState transform, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Sets the transform that represents this node's \"previous\" position, one\n"
  " * frame ago, for the purposes of detecting motion for accurate collision\n"
  " * calculations.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_prev_transform_361_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< TransformState > PandaNode::get_prev_transform(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_prev_transform_362(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< TransformState > PandaNode::get_prev_transform(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_prev_transform", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< TransformState > return_value = ((*(const PandaNode*)local_this).get_prev_transform)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      TransformState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_prev_transform(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_prev_transform_362_comment =
  "C++ Interface:\n"
  "get_prev_transform(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the transform that has been set as this node's \"previous\" position.\n"
  " * See set_prev_transform().\n"
  " */";
#else
static const char *Dtool_PandaNode_get_prev_transform_362_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::reset_prev_transform(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_reset_prev_transform_363(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.reset_prev_transform")) {
    return nullptr;
  }
  // 1-void PandaNode::reset_prev_transform(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.reset_prev_transform", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).reset_prev_transform)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_prev_transform(const PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_reset_prev_transform_363_comment =
  "C++ Interface:\n"
  "reset_prev_transform(const PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Resets the transform that represents this node's \"previous\" position to the\n"
  " * same as the current transform.  This is not the same thing as clearing it\n"
  " * to identity.\n"
  " */";
#else
static const char *Dtool_PandaNode_reset_prev_transform_363_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PandaNode::has_dirty_prev_transform(void) const
 */
static PyObject *Dtool_PandaNode_has_dirty_prev_transform_364(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline bool PandaNode::has_dirty_prev_transform(void) const
  bool return_value = ((*(const PandaNode*)local_this).has_dirty_prev_transform)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_has_dirty_prev_transform_364_comment =
  "C++ Interface:\n"
  "has_dirty_prev_transform(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if this node has the _dirty_prev_transform flag set, which\n"
  " * indicates its _prev_transform is different from its _transform value (in\n"
  " * pipeline stage 0).  In this case, the node will be visited by\n"
  " * reset_prev_transform().\n"
  " */";
#else
static const char *Dtool_PandaNode_has_dirty_prev_transform_364_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void PandaNode::reset_all_prev_transform(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_reset_all_prev_transform_365(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static void PandaNode::reset_all_prev_transform(Thread *current_thread = Thread::get_current_thread())
  PyObject *param0 = nullptr;
  if (Dtool_ExtractOptionalArg(&param0, args, kwds, "current_thread")) {
    Thread *param0_this;
    if (param0 == nullptr) {
      param0_this = Thread::get_current_thread();
    } else {
      param0_this = (Thread *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Thread, 0, "PandaNode.reset_all_prev_transform", false, true);
    }
    if ((param0 == nullptr || param0_this != nullptr)) {
      (PandaNode::reset_all_prev_transform)(param0_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_all_prev_transform(Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_reset_all_prev_transform_365_comment =
  "C++ Interface:\n"
  "reset_all_prev_transform(Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Visits all nodes in the world with the _dirty_prev_transform flag--that is,\n"
  " * all nodes whose _prev_transform is different from the _transform in\n"
  " * pipeline stage 0--and resets the _prev_transform to be the same as\n"
  " * _transform.\n"
  " */";
#else
static const char *Dtool_PandaNode_reset_all_prev_transform_365_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_tag(std::string const &key, std::string const &value, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_set_tag_367(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_tag")) {
    return nullptr;
  }
  // 1-void PandaNode::set_tag(std::string const &key, std::string const &value, Thread *current_thread = Thread::get_current_thread())
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"key", "value", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|O:set_tag", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
    Thread *param3_this;
    if (param3 == nullptr) {
      param3_this = Thread::get_current_thread();
    } else {
      param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "PandaNode.set_tag", false, true);
    }
    if ((param3 == nullptr || param3_this != nullptr)) {
      ((*local_this).set_tag)(std::string(param1_str, param1_len), std::string(param2_str, param2_len), param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tag(const PandaNode self, str key, str value, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_tag_367_comment =
  "C++ Interface:\n"
  "set_tag(const PandaNode self, str key, str value, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Associates a user-defined value with a user-defined key which is stored on\n"
  " * the node.  This value has no meaning to Panda; but it is stored\n"
  " * indefinitely on the node until it is requested again.\n"
  " *\n"
  " * Each unique key stores a different string value.  There is no effective\n"
  " * limit on the number of different keys that may be stored or on the length\n"
  " * of any one key's value.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_tag_367_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string PandaNode::get_tag(std::string const &key, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_tag_368(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline std::string PandaNode::get_tag(std::string const &key, Thread *current_thread = Thread::get_current_thread()) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"key", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:get_tag", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.get_tag", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      std::string return_value = ((*(const PandaNode*)local_this).get_tag)(std::string(param1_str, param1_len), param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tag(PandaNode self, str key, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_tag_368_comment =
  "C++ Interface:\n"
  "get_tag(PandaNode self, str key, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Retrieves the user-defined value that was previously set on this node for\n"
  " * the particular key, if any.  If no value has been previously set, returns\n"
  " * the empty string.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_tag_368_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PandaNode::has_tag(std::string const &key, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_has_tag_369(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline bool PandaNode::has_tag(std::string const &key, Thread *current_thread = Thread::get_current_thread()) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"key", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:has_tag", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.has_tag", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      bool return_value = ((*(const PandaNode*)local_this).has_tag)(std::string(param1_str, param1_len), param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_tag(PandaNode self, str key, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_has_tag_369_comment =
  "C++ Interface:\n"
  "has_tag(PandaNode self, str key, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns true if a value has been defined on this node for the particular\n"
  " * key (even if that value is the empty string), or false if no value has been\n"
  " * set.\n"
  " */";
#else
static const char *Dtool_PandaNode_has_tag_369_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::clear_tag(std::string const &key, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_clear_tag_370(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.clear_tag")) {
    return nullptr;
  }
  // 1-void PandaNode::clear_tag(std::string const &key, Thread *current_thread = Thread::get_current_thread())
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"key", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:clear_tag", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.clear_tag", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).clear_tag)(std::string(param1_str, param1_len), param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_tag(const PandaNode self, str key, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_clear_tag_370_comment =
  "C++ Interface:\n"
  "clear_tag(const PandaNode self, str key, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Removes the value defined for this key on this particular node.  After a\n"
  " * call to clear_tag(), has_tag() will return false for the indicated key.\n"
  " */";
#else
static const char *Dtool_PandaNode_clear_tag_370_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PandaNode::get_tag_keys(void) const
 */
static PyObject *Dtool_PandaNode_get_tag_keys_376(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-PyObject *PandaNode::get_tag_keys(void) const
  PyObject *return_value = invoke_extension((const PandaNode*)local_this).get_tag_keys();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_tag_keys_376_comment =
  "C++ Interface:\n"
  "get_tag_keys(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Fills the given vector up with the list of tags on this PandaNode.\n"
  " *\n"
  " * It is the user's responsibility to ensure that the keys vector is empty\n"
  " * before making this call; otherwise, the new keys will be appended to it.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_tag_keys_376_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PandaNode::get_python_tags(void)
 */
static PyObject *Dtool_PandaNode_get_python_tags_377(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.get_python_tags")) {
    return nullptr;
  }
  // 1-PyObject *PandaNode::get_python_tags(void)
  PyObject *return_value = invoke_extension(local_this).get_python_tags();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_python_tags_377_comment =
  "C++ Interface:\n"
  "get_python_tags(const PandaNode self)\n";
#else
static const char *Dtool_PandaNode_get_python_tags_377_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_python_tag(PyObject *key, PyObject *value)
 */
static PyObject *Dtool_PandaNode_set_python_tag_378(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_python_tag")) {
    return nullptr;
  }
  // 1-void PandaNode::set_python_tag(PyObject *key, PyObject *value)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"key", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_python_tag", (char **)keyword_list, &param1, &param2)) {
    invoke_extension(local_this).set_python_tag(param1, param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_python_tag(const PandaNode self, object key, object value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_python_tag_378_comment =
  "C++ Interface:\n"
  "set_python_tag(const PandaNode self, object key, object value)\n";
#else
static const char *Dtool_PandaNode_set_python_tag_378_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PandaNode::get_python_tag(PyObject *key) const
 */
static PyObject *Dtool_PandaNode_get_python_tag_379(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-PyObject *PandaNode::get_python_tag(PyObject *key) const
  PyObject *return_value = invoke_extension((const PandaNode*)local_this).get_python_tag(arg);
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_python_tag(PandaNode self, object key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_python_tag_379_comment =
  "C++ Interface:\n"
  "get_python_tag(PandaNode self, object key)\n";
#else
static const char *Dtool_PandaNode_get_python_tag_379_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PandaNode::has_python_tag(PyObject *key) const
 */
static PyObject *Dtool_PandaNode_has_python_tag_380(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-bool PandaNode::has_python_tag(PyObject *key) const
  bool return_value = invoke_extension((const PandaNode*)local_this).has_python_tag(arg);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_python_tag(PandaNode self, object key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_has_python_tag_380_comment =
  "C++ Interface:\n"
  "has_python_tag(PandaNode self, object key)\n";
#else
static const char *Dtool_PandaNode_has_python_tag_380_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::clear_python_tag(PyObject *key)
 */
static PyObject *Dtool_PandaNode_clear_python_tag_381(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.clear_python_tag")) {
    return nullptr;
  }
  // 1-void PandaNode::clear_python_tag(PyObject *key)
  invoke_extension(local_this).clear_python_tag(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_python_tag(const PandaNode self, object key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_clear_python_tag_381_comment =
  "C++ Interface:\n"
  "clear_python_tag(const PandaNode self, object key)\n";
#else
static const char *Dtool_PandaNode_clear_python_tag_381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PandaNode::get_python_tag_keys(void) const
 */
static PyObject *Dtool_PandaNode_get_python_tag_keys_382(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-PyObject *PandaNode::get_python_tag_keys(void) const
  PyObject *return_value = invoke_extension((const PandaNode*)local_this).get_python_tag_keys();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_python_tag_keys_382_comment =
  "C++ Interface:\n"
  "get_python_tag_keys(PandaNode self)\n";
#else
static const char *Dtool_PandaNode_get_python_tag_keys_382_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PandaNode::has_tags(void) const
 */
static PyObject *Dtool_PandaNode_has_tags_388(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline bool PandaNode::has_tags(void) const
  bool return_value = ((*(const PandaNode*)local_this).has_tags)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_has_tags_388_comment =
  "C++ Interface:\n"
  "has_tags(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the node has any tags (or any Python tags) at all, false if\n"
  " * it has none.\n"
  " */";
#else
static const char *Dtool_PandaNode_has_tags_388_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::copy_tags(PandaNode *other)
 */
static PyObject *Dtool_PandaNode_copy_tags_389(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.copy_tags")) {
    return nullptr;
  }
  // 1-void PandaNode::copy_tags(PandaNode *other)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "PandaNode.copy_tags", false, true);
  if (arg_this != nullptr) {
    ((*local_this).copy_tags)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_tags(const PandaNode self, PandaNode other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_copy_tags_389_comment =
  "C++ Interface:\n"
  "copy_tags(const PandaNode self, PandaNode other)\n"
  "\n"
  "/**\n"
  " * Copies all of the tags stored on the other node onto this node.  If a\n"
  " * particular tag exists on both nodes, the contents of this node's value is\n"
  " * replaced by that of the other.\n"
  " */";
#else
static const char *Dtool_PandaNode_copy_tags_389_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::list_tags(std::ostream &out, std::string const &separator = "\n") const
 */
static PyObject *Dtool_PandaNode_list_tags_390(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-void PandaNode::list_tags(std::ostream &out, std::string const &separator = "\n") const
  PyObject *param1;
  const char *param2_str = "\n";
  Py_ssize_t param2_len = 1;
  static const char *keyword_list[] = {"out", "separator", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:list_tags", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PandaNode.list_tags", false, true);
    if (param1_this != nullptr) {
      ((*(const PandaNode*)local_this).list_tags)(*param1_this, std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_tags(PandaNode self, ostream out, str separator)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_list_tags_390_comment =
  "C++ Interface:\n"
  "list_tags(PandaNode self, ostream out, str separator)\n"
  "\n"
  "/**\n"
  " * Writes a list of all the tag keys assigned to the node to the indicated\n"
  " * stream.  Writes one instance of the separator following each key (but does\n"
  " * not write a terminal separator).  The value associated with each key is not\n"
  " * written.\n"
  " *\n"
  " * This is mainly for the benefit of the realtime user, to see the list of all\n"
  " * of the associated tag keys.\n"
  " */";
#else
static const char *Dtool_PandaNode_list_tags_390_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PandaNode::compare_tags(PandaNode const *other) const
 */
static PyObject *Dtool_PandaNode_compare_tags_391(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-int PandaNode::compare_tags(PandaNode const *other) const
  PandaNode const *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "PandaNode.compare_tags", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const PandaNode*)local_this).compare_tags)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_tags(PandaNode self, const PandaNode other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_compare_tags_391_comment =
  "C++ Interface:\n"
  "compare_tags(PandaNode self, const PandaNode other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than 0, 0, or greater than 0, to indicate the\n"
  " * similarity of tags between this node and the other one.  If this returns 0,\n"
  " * the tags are identical.  If it returns other than 0, then the tags are\n"
  " * different; and the nodes may be sorted into a consistent (but arbitrary)\n"
  " * ordering based on this number.\n"
  " */";
#else
static const char *Dtool_PandaNode_compare_tags_391_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::copy_all_properties(PandaNode *other)
 */
static PyObject *Dtool_PandaNode_copy_all_properties_392(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.copy_all_properties")) {
    return nullptr;
  }
  // 1-void PandaNode::copy_all_properties(PandaNode *other)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "PandaNode.copy_all_properties", false, true);
  if (arg_this != nullptr) {
    ((*local_this).copy_all_properties)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_all_properties(const PandaNode self, PandaNode other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_copy_all_properties_392_comment =
  "C++ Interface:\n"
  "copy_all_properties(const PandaNode self, PandaNode other)\n"
  "\n"
  "/**\n"
  " * Copies the TransformState, RenderState, RenderEffects, tags, Python tags,\n"
  " * and the show/hide state from the other node onto this one.  Typically this\n"
  " * is used to prepare a node to replace another node in the scene graph (also\n"
  " * see replace_node()).\n"
  " */";
#else
static const char *Dtool_PandaNode_copy_all_properties_392_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::replace_node(PandaNode *other)
 */
static PyObject *Dtool_PandaNode_replace_node_393(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.replace_node")) {
    return nullptr;
  }
  // 1-void PandaNode::replace_node(PandaNode *other)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "PandaNode.replace_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).replace_node)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "replace_node(const PandaNode self, PandaNode other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_replace_node_393_comment =
  "C++ Interface:\n"
  "replace_node(const PandaNode self, PandaNode other)\n"
  "\n"
  "/**\n"
  " * Inserts this node into the scene graph in place of the other one, and\n"
  " * removes the other node.  All scene graph attributes (TransformState,\n"
  " * RenderState, etc.) are copied to this node.\n"
  " *\n"
  " * All children are moved to this node, and removed from the old node.  The\n"
  " * new node is left in the same place in the old node's parent's list of\n"
  " * children.\n"
  " *\n"
  " * Even NodePaths that reference the old node are updated in-place to\n"
  " * reference the new node instead.\n"
  " *\n"
  " * This method is intended to be used to replace a node of a given type in the\n"
  " * scene graph with a node of a different type.\n"
  " */";
#else
static const char *Dtool_PandaNode_replace_node_393_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_unexpected_change(unsigned int flags)
 */
static PyObject *Dtool_PandaNode_set_unexpected_change_395(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_unexpected_change")) {
    return nullptr;
  }
  // 1-void PandaNode::set_unexpected_change(unsigned int flags)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).set_unexpected_change)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_unexpected_change(const PandaNode self, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_unexpected_change_395_comment =
  "C++ Interface:\n"
  "set_unexpected_change(const PandaNode self, int flags)\n"
  "\n"
  "/**\n"
  " * Sets one or more of the PandaNode::UnexpectedChange bits on, indicating\n"
  " * that the corresponding property should not change again on this node.  Once\n"
  " * one of these bits has been set, if the property changes, an assertion\n"
  " * failure will be raised, which is designed to assist the developer in\n"
  " * identifying the troublesome code that modified the property unexpectedly.\n"
  " *\n"
  " * The input parameter is the union of bits that are to be set.  To clear\n"
  " * these bits later, use clear_unexpected_change().\n"
  " *\n"
  " * Since this is a developer debugging tool only, this function does nothing\n"
  " * in a production (NDEBUG) build.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_unexpected_change_395_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * unsigned int PandaNode::get_unexpected_change(unsigned int flags) const
 */
static PyObject *Dtool_PandaNode_get_unexpected_change_396(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-unsigned int PandaNode::get_unexpected_change(unsigned int flags) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    unsigned int return_value = ((*(const PandaNode*)local_this).get_unexpected_change)((unsigned int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_unexpected_change(PandaNode self, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_unexpected_change_396_comment =
  "C++ Interface:\n"
  "get_unexpected_change(PandaNode self, int flags)\n"
  "\n"
  "/**\n"
  " * Returns nonzero if any of the bits in the input parameter are set on this\n"
  " * node, or zero if none of them are set.  More specifically, this returns the\n"
  " * particular set of bits (masked by the input parameter) that have been set\n"
  " * on this node.  See set_unexpected_change().\n"
  " *\n"
  " * Since this is a developer debugging tool only, this function always returns\n"
  " * zero in a production (NDEBUG) build.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_unexpected_change_396_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::clear_unexpected_change(unsigned int flags)
 */
static PyObject *Dtool_PandaNode_clear_unexpected_change_397(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.clear_unexpected_change")) {
    return nullptr;
  }
  // 1-void PandaNode::clear_unexpected_change(unsigned int flags)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).clear_unexpected_change)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_unexpected_change(const PandaNode self, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_clear_unexpected_change_397_comment =
  "C++ Interface:\n"
  "clear_unexpected_change(const PandaNode self, int flags)\n"
  "\n"
  "/**\n"
  " * Sets one or more of the PandaNode::UnexpectedChange bits off, indicating\n"
  " * that the corresponding property may once again change on this node.  See\n"
  " * set_unexpected_change().\n"
  " *\n"
  " * The input parameter is the union of bits that are to be cleared.\n"
  " *\n"
  " * Since this is a developer debugging tool only, this function does nothing\n"
  " * in a production (NDEBUG) build.\n"
  " */";
#else
static const char *Dtool_PandaNode_clear_unexpected_change_397_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline DrawMask PandaNode::get_overall_bit(void)
 */
static PyObject *Dtool_PandaNode_get_overall_bit_398(PyObject *, PyObject *) {
  // 1-static inline DrawMask PandaNode::get_overall_bit(void)
  DrawMask *return_value = new DrawMask((PandaNode::get_overall_bit)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_overall_bit_398_comment =
  "C++ Interface:\n"
  "get_overall_bit()\n"
  "\n"
  "/**\n"
  " * Returns the special bit that, when specifically cleared in the node's\n"
  " * DrawMask, indicates that the node is hidden to all cameras, regardless of\n"
  " * the remaining DrawMask bits.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_overall_bit_398_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline DrawMask PandaNode::get_all_camera_mask(void)
 */
static PyObject *Dtool_PandaNode_get_all_camera_mask_399(PyObject *, PyObject *) {
  // 1-static inline DrawMask PandaNode::get_all_camera_mask(void)
  DrawMask *return_value = new DrawMask((PandaNode::get_all_camera_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_all_camera_mask_399_comment =
  "C++ Interface:\n"
  "get_all_camera_mask()\n"
  "\n"
  "/**\n"
  " * Returns a DrawMask that is appropriate for rendering to all cameras.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_all_camera_mask_399_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PandaNode::is_overall_hidden(void) const
 */
static PyObject *Dtool_PandaNode_is_overall_hidden_400(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline bool PandaNode::is_overall_hidden(void) const
  bool return_value = ((*(const PandaNode*)local_this).is_overall_hidden)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_is_overall_hidden_400_comment =
  "C++ Interface:\n"
  "is_overall_hidden(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the node has been hidden to all cameras by clearing its\n"
  " * overall bit.\n"
  " */";
#else
static const char *Dtool_PandaNode_is_overall_hidden_400_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PandaNode::set_overall_hidden(bool overall_hidden)
 */
static PyObject *Dtool_PandaNode_set_overall_hidden_401(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_overall_hidden")) {
    return nullptr;
  }
  // 1-inline void PandaNode::set_overall_hidden(bool overall_hidden)
  ((*local_this).set_overall_hidden)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_overall_hidden(const PandaNode self, bool overall_hidden)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_overall_hidden_401_comment =
  "C++ Interface:\n"
  "set_overall_hidden(const PandaNode self, bool overall_hidden)\n"
  "\n"
  "/**\n"
  " * Sets or clears the hidden flag.  When the hidden flag is true, the node and\n"
  " * all of its children are invisible to all cameras, regardless of the setting\n"
  " * of any draw masks.  Setting the hidden flag to false restores the previous\n"
  " * visibility as established by the draw masks.\n"
  " *\n"
  " * This actually works by twiddling the reserved _overall_bit in the node's\n"
  " * draw mask, which has special meaning.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_overall_hidden_401_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::adjust_draw_mask(DrawMask show_mask, DrawMask hide_mask, DrawMask clear_mask)
 */
static PyObject *Dtool_PandaNode_adjust_draw_mask_408(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.adjust_draw_mask")) {
    return nullptr;
  }
  // 1-void PandaNode::adjust_draw_mask(DrawMask show_mask, DrawMask hide_mask, DrawMask clear_mask)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"show_mask", "hide_mask", "clear_mask", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:adjust_draw_mask", (char **)keyword_list, &param1, &param2, &param3)) {
    BitMask< uint32_t, 32 > param1_local;
    DrawMask *param1_this = Dtool_Coerce_BitMask_uint32_t_32(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PandaNode.adjust_draw_mask", "BitMask");
    }
    BitMask< uint32_t, 32 > param2_local;
    DrawMask *param2_this = Dtool_Coerce_BitMask_uint32_t_32(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PandaNode.adjust_draw_mask", "BitMask");
    }
    BitMask< uint32_t, 32 > param3_local;
    DrawMask *param3_this = Dtool_Coerce_BitMask_uint32_t_32(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "PandaNode.adjust_draw_mask", "BitMask");
    }
    ((*local_this).adjust_draw_mask)(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_draw_mask(const PandaNode self, BitMask show_mask, BitMask hide_mask, BitMask clear_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_adjust_draw_mask_408_comment =
  "C++ Interface:\n"
  "adjust_draw_mask(const PandaNode self, BitMask show_mask, BitMask hide_mask, BitMask clear_mask)\n"
  "\n"
  "/**\n"
  " * Adjusts the hide/show bits of this particular node.\n"
  " *\n"
  " * These three parameters can be used to adjust the _draw_control_mask and\n"
  " * _draw_show_mask independently, which work together to provide per-camera\n"
  " * visibility for the node and its descendents.\n"
  " *\n"
  " * _draw_control_mask indicates the bits in _draw_show_mask that are\n"
  " * significant.  Each different bit corresponds to a different camera (and\n"
  " * these bits are assigned via Camera::set_camera_mask()).\n"
  " *\n"
  " * Where _draw_control_mask has a 1 bit, a 1 bit in _draw_show_mask indicates\n"
  " * the node is visible to that camera, and a 0 bit indicates the node is\n"
  " * hidden to that camera.  Where _draw_control_mask is 0, the node is hidden\n"
  " * only if a parent node is hidden.\n"
  " *\n"
  " * The meaning of the three parameters is as follows:\n"
  " *\n"
  " * * Wherever show_mask is 1, _draw_show_mask and _draw_control_mask will be\n"
  " * set 1.  Thus, show_mask indicates the set of cameras to which the node\n"
  " * should be shown.\n"
  " *\n"
  " * * Wherever hide_mask is 1, _draw_show_mask will be set 0 and\n"
  " * _draw_control_mask will be set 1.  Thus, hide_mask indicates the set of\n"
  " * cameras from which the node should be hidden.\n"
  " *\n"
  " * * Wherever clear_mask is 1, _draw_control_mask will be set 0.  Thus,\n"
  " * clear_mask indicates the set of cameras from which the hidden state should\n"
  " * be inherited from a parent.\n"
  " */";
#else
static const char *Dtool_PandaNode_adjust_draw_mask_408_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DrawMask PandaNode::get_draw_control_mask(void) const
 */
static PyObject *Dtool_PandaNode_get_draw_control_mask_409(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline DrawMask PandaNode::get_draw_control_mask(void) const
  DrawMask *return_value = new DrawMask(((*(const PandaNode*)local_this).get_draw_control_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_draw_control_mask_409_comment =
  "C++ Interface:\n"
  "get_draw_control_mask(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns the set of bits in draw_show_mask that are considered meaningful.\n"
  " * See adjust_draw_mask().\n"
  " */";
#else
static const char *Dtool_PandaNode_get_draw_control_mask_409_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DrawMask PandaNode::get_draw_show_mask(void) const
 */
static PyObject *Dtool_PandaNode_get_draw_show_mask_410(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline DrawMask PandaNode::get_draw_show_mask(void) const
  DrawMask *return_value = new DrawMask(((*(const PandaNode*)local_this).get_draw_show_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_draw_show_mask_410_comment =
  "C++ Interface:\n"
  "get_draw_show_mask(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns the hide/show bits of this particular node.  See\n"
  " * adjust_draw_mask().\n"
  " */";
#else
static const char *Dtool_PandaNode_get_draw_show_mask_410_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DrawMask PandaNode::get_net_draw_control_mask(void) const
 */
static PyObject *Dtool_PandaNode_get_net_draw_control_mask_413(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-DrawMask PandaNode::get_net_draw_control_mask(void) const
  DrawMask *return_value = new DrawMask(((*(const PandaNode*)local_this).get_net_draw_control_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_net_draw_control_mask_413_comment =
  "C++ Interface:\n"
  "get_net_draw_control_mask(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns the set of bits in get_net_draw_show_mask() that have been\n"
  " * explicitly set via adjust_draw_mask(), rather than implicitly inherited.\n"
  " *\n"
  " * A 1 bit in any position of this mask indicates that (a) this node has\n"
  " * renderable children, and (b) some child of this node has made an explicit\n"
  " * hide() or show_through() call for the corresponding bit.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_net_draw_control_mask_413_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DrawMask PandaNode::get_net_draw_show_mask(void) const
 */
static PyObject *Dtool_PandaNode_get_net_draw_show_mask_414(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-DrawMask PandaNode::get_net_draw_show_mask(void) const
  DrawMask *return_value = new DrawMask(((*(const PandaNode*)local_this).get_net_draw_show_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_net_draw_show_mask_414_comment =
  "C++ Interface:\n"
  "get_net_draw_show_mask(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns the union of all draw_show_mask values--of renderable nodes only--\n"
  " * at this level and below.  If any bit in this mask is 0, there is no reason\n"
  " * to traverse below this node for a camera with the corresponding\n"
  " * camera_mask.\n"
  " *\n"
  " * The bits in this mask that do not correspond to a 1 bit in the\n"
  " * net_draw_control_mask are meaningless (and will be set to 1).  For bits\n"
  " * that *do* correspond to a 1 bit in the net_draw_control_mask, a 1 bit\n"
  " * indicates that at least one child should be visible, while a 0 bit\n"
  " * indicates that all children are hidden.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_net_draw_show_mask_414_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_into_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_PandaNode_set_into_collide_mask_415(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_into_collide_mask")) {
    return nullptr;
  }
  // 1-void PandaNode::set_into_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PandaNode.set_into_collide_mask", "BitMask");
  }
  ((*local_this).set_into_collide_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_into_collide_mask(const PandaNode self, BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_into_collide_mask_415_comment =
  "C++ Interface:\n"
  "set_into_collide_mask(const PandaNode self, BitMask mask)\n"
  "\n"
  "/**\n"
  " * Sets the \"into\" CollideMask.\n"
  " *\n"
  " * This specifies the set of bits that must be shared with a CollisionNode's\n"
  " * \"from\" CollideMask in order for the CollisionNode to detect a collision\n"
  " * with this particular node.\n"
  " *\n"
  " * The actual CollideMask that will be set is masked by the return value from\n"
  " * get_legal_collide_mask(). Thus, the into_collide_mask cannot be set to\n"
  " * anything other than nonzero except for those types of nodes that can be\n"
  " * collided into, such as CollisionNodes and GeomNodes.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_into_collide_mask_415_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask PandaNode::get_into_collide_mask(void) const
 */
static PyObject *Dtool_PandaNode_get_into_collide_mask_416(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline CollideMask PandaNode::get_into_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const PandaNode*)local_this).get_into_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_into_collide_mask_416_comment =
  "C++ Interface:\n"
  "get_into_collide_mask(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"into\" collide mask for this node.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_into_collide_mask_416_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual CollideMask PandaNode::get_legal_collide_mask(void) const
 */
static PyObject *Dtool_PandaNode_get_legal_collide_mask_417(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-virtual CollideMask PandaNode::get_legal_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const PandaNode*)local_this).get_legal_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_legal_collide_mask_417_comment =
  "C++ Interface:\n"
  "get_legal_collide_mask(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns the subset of CollideMask bits that may be set for this particular\n"
  " * type of PandaNode.  For most nodes, this is 0; it doesn't make sense to set\n"
  " * a CollideMask for most kinds of nodes.\n"
  " *\n"
  " * For nodes that can be collided with, such as GeomNode and CollisionNode,\n"
  " * this returns all bits on.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_legal_collide_mask_417_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CollideMask PandaNode::get_net_collide_mask(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_net_collide_mask_421(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-CollideMask PandaNode::get_net_collide_mask(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_net_collide_mask", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      CollideMask *return_value = new CollideMask(((*(const PandaNode*)local_this).get_net_collide_mask)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_collide_mask(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_net_collide_mask_421_comment =
  "C++ Interface:\n"
  "get_net_collide_mask(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the union of all into_collide_mask() values set at CollisionNodes\n"
  " * at this level and below.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_net_collide_mask_421_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > PandaNode::get_off_clip_planes(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_off_clip_planes_422(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > PandaNode::get_off_clip_planes(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_off_clip_planes", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< RenderAttrib > return_value = ((*(const PandaNode*)local_this).get_off_clip_planes)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_off_clip_planes(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_off_clip_planes_422_comment =
  "C++ Interface:\n"
  "get_off_clip_planes(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a ClipPlaneAttrib which represents the union of all of the clip\n"
  " * planes that have been turned *off* at this level and below.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_off_clip_planes_422_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::prepare_scene(GraphicsStateGuardianBase *gsg, RenderState const *node_state)
 */
static PyObject *Dtool_PandaNode_prepare_scene_423(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.prepare_scene")) {
    return nullptr;
  }
  // 1-void PandaNode::prepare_scene(GraphicsStateGuardianBase *gsg, RenderState const *node_state)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"gsg", "node_state", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:prepare_scene", (char **)keyword_list, &param1, &param2)) {
    GraphicsStateGuardianBase *param1_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsStateGuardianBase, 1, "PandaNode.prepare_scene", false, true);
    CPT(RenderState) param2_this;
    if (!Dtool_ConstCoerce_RenderState(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PandaNode.prepare_scene", "RenderState");
    }
    if (param1_this != nullptr) {
      ((*local_this).prepare_scene)(param1_this, std::move(param2_this));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_scene(const PandaNode self, GraphicsStateGuardianBase gsg, const RenderState node_state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_prepare_scene_423_comment =
  "C++ Interface:\n"
  "prepare_scene(const PandaNode self, GraphicsStateGuardianBase gsg, const RenderState node_state)\n"
  "\n"
  "/**\n"
  " * Walks through the scene graph beginning at this node, and does whatever\n"
  " * initialization is required to render the scene properly with the indicated\n"
  " * GSG.  It is not strictly necessary to call this, since the GSG will\n"
  " * initialize itself when the scene is rendered, but this may take some of the\n"
  " * overhead away from that process.\n"
  " *\n"
  " * In particular, this will ensure that textures and vertex buffers within the\n"
  " * scene are loaded into graphics memory.\n"
  " */";
#else
static const char *Dtool_PandaNode_prepare_scene_423_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PandaNode::is_scene_root(void) const
 */
static PyObject *Dtool_PandaNode_is_scene_root_424(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-bool PandaNode::is_scene_root(void) const
  bool return_value = ((*(const PandaNode*)local_this).is_scene_root)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_is_scene_root_424_comment =
  "C++ Interface:\n"
  "is_scene_root(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular node is known to be the render root of some\n"
  " * active DisplayRegion associated with the global GraphicsEngine, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PandaNode_is_scene_root_424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PandaNode::is_under_scene_root(void) const
 */
static PyObject *Dtool_PandaNode_is_under_scene_root_425(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-bool PandaNode::is_under_scene_root(void) const
  bool return_value = ((*(const PandaNode*)local_this).is_under_scene_root)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_is_under_scene_root_425_comment =
  "C++ Interface:\n"
  "is_under_scene_root(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular node is in a live scene graph: that is, it\n"
  " * is a child or descendent of a node that is itself a scene root.  If this is\n"
  " * true, this node may potentially be traversed by the render traverser.\n"
  " * Stashed nodes don't count for this purpose, but hidden nodes do.\n"
  " */";
#else
static const char *Dtool_PandaNode_is_under_scene_root_425_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PandaNode::output(std::ostream &out) const
 */
static PyObject *Dtool_PandaNode_output_426(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-virtual void PandaNode::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PandaNode.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PandaNode*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PandaNode self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_output_426_comment =
  "C++ Interface:\n"
  "output(PandaNode self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PandaNode_output_426_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PandaNode::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_PandaNode_write_427(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-virtual void PandaNode::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PandaNode.write", false, true);
    if (param1_this != nullptr) {
      ((*(const PandaNode*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PandaNode self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_write_427_comment =
  "C++ Interface:\n"
  "write(PandaNode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PandaNode_write_427_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PandaNode::ls(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_PandaNode_ls_428(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline void PandaNode::ls(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:ls", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PandaNode.ls", false, true);
    if (param1_this != nullptr) {
      ((*(const PandaNode*)local_this).ls)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls(PandaNode self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_ls_428_comment =
  "C++ Interface:\n"
  "ls(PandaNode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Lists all the nodes at and below the current path hierarchically.\n"
  " */";
#else
static const char *Dtool_PandaNode_ls_428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_bounds_type(BoundingVolume::BoundsType bounds_type)
 */
static PyObject *Dtool_PandaNode_set_bounds_type_429(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_bounds_type")) {
    return nullptr;
  }
  // 1-void PandaNode::set_bounds_type(BoundingVolume::BoundsType bounds_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_bounds_type)((BoundingVolume::BoundsType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bounds_type(const PandaNode self, int bounds_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_bounds_type_429_comment =
  "C++ Interface:\n"
  "set_bounds_type(const PandaNode self, int bounds_type)\n"
  "\n"
  "// We define set_bounds() and get_bounds() functions so that set_bounds()\n"
  "// sets the user bounding volume, while get_bounds() returns the external\n"
  "// bounding volume.  Although it might seem strange and confusing to do\n"
  "// this, this is actually the natural way the user thinks about nodes and\n"
  "// bounding volumes.\n"
  "\n"
  "/**\n"
  " * Specifies the desired type of bounding volume that will be created for this\n"
  " * node.  This is normally BoundingVolume::BT_default, which means to set the\n"
  " * type according to the config variable \"bounds-type\".\n"
  " *\n"
  " * If this is BT_sphere or BT_box, a BoundingSphere or BoundingBox is\n"
  " * explicitly created.  If it is BT_best, the appropriate type to best enclose\n"
  " * the node's children is created.\n"
  " *\n"
  " * This affects the bounding volume returned by get_bounds(), which is not\n"
  " * exactly the same bounding volume modified by set_bounds(), because a new\n"
  " * bounding volume has to be created that includes this node and all of its\n"
  " * children.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_bounds_type_429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BoundingVolume::BoundsType PandaNode::get_bounds_type(void) const
 */
static PyObject *Dtool_PandaNode_get_bounds_type_430(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-BoundingVolume::BoundsType PandaNode::get_bounds_type(void) const
  BoundingVolume::BoundsType return_value = ((*(const PandaNode*)local_this).get_bounds_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_bounds_type_430_comment =
  "C++ Interface:\n"
  "get_bounds_type(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns the bounding volume type set with set_bounds_type().\n"
  " */";
#else
static const char *Dtool_PandaNode_get_bounds_type_430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_bounds(BoundingVolume const *volume)
 */
static PyObject *Dtool_PandaNode_set_bounds_434(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_bounds")) {
    return nullptr;
  }
  // 1-void PandaNode::set_bounds(BoundingVolume const *volume)
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "PandaNode.set_bounds", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_bounds)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bounds(const PandaNode self, const BoundingVolume volume)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_bounds_434_comment =
  "C++ Interface:\n"
  "set_bounds(const PandaNode self, const BoundingVolume volume)\n"
  "\n"
  "/**\n"
  " * Resets the bounding volume so that it is the indicated volume.  When it is\n"
  " * explicitly set, the bounding volume will no longer be automatically\n"
  " * computed according to the contents of the node itself, for nodes like\n"
  " * GeomNodes and TextNodes that contain substance (but the bounding volume\n"
  " * will still be automatically expanded to include its children).\n"
  " *\n"
  " * Call clear_bounds() if you would like to return the bounding volume to its\n"
  " * default behavior later.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_bounds_434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::set_bound(BoundingVolume const *volume)
 */
static PyObject *Dtool_PandaNode_set_bound_435(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_bound")) {
    return nullptr;
  }
  // 1-void PandaNode::set_bound(BoundingVolume const *volume)
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "PandaNode.set_bound", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_bound)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bound(const PandaNode self, const BoundingVolume volume)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_bound_435_comment =
  "C++ Interface:\n"
  "set_bound(const PandaNode self, const BoundingVolume volume)\n"
  "\n"
  "/**\n"
  " * Deprecated.  Use set_bounds() instead.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_bound_435_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PandaNode::clear_bounds(void)
 */
static PyObject *Dtool_PandaNode_clear_bounds_436(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.clear_bounds")) {
    return nullptr;
  }
  // 1-inline void PandaNode::clear_bounds(void)
  ((*local_this).clear_bounds)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_clear_bounds_436_comment =
  "C++ Interface:\n"
  "clear_bounds(const PandaNode self)\n"
  "\n"
  "/**\n"
  " * Reverses the effect of a previous call to set_bounds(), and allows the\n"
  " * node's bounding volume to be automatically computed once more based on the\n"
  " * contents of the node.\n"
  " */";
#else
static const char *Dtool_PandaNode_clear_bounds_436_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< BoundingVolume > PandaNode::get_bounds(Thread *current_thread = Thread::get_current_thread()) const
 * ConstPointerTo< BoundingVolume > PandaNode::get_bounds(UpdateSeq &seq, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_bounds_437(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ConstPointerTo< BoundingVolume > PandaNode::get_bounds(Thread *current_thread) const
      ConstPointerTo< BoundingVolume > return_value = ((*(const PandaNode*)local_this).get_bounds)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      BoundingVolume const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 ConstPointerTo< BoundingVolume > PandaNode::get_bounds(UpdateSeq &seq, Thread *current_thread = Thread::get_current_thread()) const
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"seq", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:get_bounds", (char **)keyword_list, &param1, &param2)) {
          UpdateSeq *param1_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_UpdateSeq, 1, "PandaNode.get_bounds", false, false);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "PandaNode.get_bounds", false, false);
          }
          if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            ConstPointerTo< BoundingVolume > return_value = ((*(const PandaNode*)local_this).get_bounds)(*param1_this, param2_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            BoundingVolume const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 ConstPointerTo< BoundingVolume > PandaNode::get_bounds(Thread *current_thread = Thread::get_current_thread()) const
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "current_thread")) {
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_bounds", false, false);
          if (param1_this != nullptr) {
            ConstPointerTo< BoundingVolume > return_value = ((*(const PandaNode*)local_this).get_bounds)(param1_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            BoundingVolume const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
      }

      // No coercion possible: ConstPointerTo< BoundingVolume > PandaNode::get_bounds(UpdateSeq &seq, Thread *current_thread = Thread::get_current_thread()) const
      // No coercion possible: ConstPointerTo< BoundingVolume > PandaNode::get_bounds(Thread *current_thread = Thread::get_current_thread()) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_bounds() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bounds(PandaNode self)\n"
      "get_bounds(PandaNode self, UpdateSeq seq, Thread current_thread)\n"
      "get_bounds(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_bounds_437_comment =
  "C++ Interface:\n"
  "get_bounds(PandaNode self)\n"
  "get_bounds(PandaNode self, UpdateSeq seq, Thread current_thread)\n"
  "get_bounds(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the external bounding volume of this node: a bounding volume that\n"
  " * contains the user bounding volume, the internal bounding volume, and all of\n"
  " * the children's bounding volumes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of get_bounds() return the external bounding volume, and also\n"
  " * fills in seq with the bounding volume's current sequence number.  When this\n"
  " * sequence number changes, it indicates that the bounding volume might have\n"
  " * changed, e.g.  because some nested child's bounding volume has changed.\n"
  " *\n"
  " * Although this might occasionally increment without changing the bounding\n"
  " * volume, the bounding volume will never change without incrementing this\n"
  " * counter, so as long as this counter remains unchanged you can be confident\n"
  " * the bounding volume is also unchanged.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_bounds_437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PandaNode::get_nested_vertices(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_nested_vertices_438(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-int PandaNode::get_nested_vertices(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_nested_vertices", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*(const PandaNode*)local_this).get_nested_vertices)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_nested_vertices(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_nested_vertices_438_comment =
  "C++ Interface:\n"
  "get_nested_vertices(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the total number of vertices that will be rendered by this node and\n"
  " * all of its descendents.\n"
  " *\n"
  " * This is not necessarily an accurate count of vertices that will actually be\n"
  " * rendered, since this will include all vertices of all LOD's, and it will\n"
  " * also include hidden nodes.  It may also omit or only approximate certain\n"
  " * kinds of dynamic geometry.  However, it will not include stashed nodes.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_nested_vertices_438_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< BoundingVolume > PandaNode::get_internal_bounds(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_internal_bounds_439(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< BoundingVolume > PandaNode::get_internal_bounds(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_internal_bounds", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< BoundingVolume > return_value = ((*(const PandaNode*)local_this).get_internal_bounds)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      BoundingVolume const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_internal_bounds(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_internal_bounds_439_comment =
  "C++ Interface:\n"
  "get_internal_bounds(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the node's internal bounding volume.  This is the bounding volume\n"
  " * around the node alone, without including children.  If the user has called\n"
  " * set_bounds(), it will be the specified bounding volume.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the node's internal bounding volume.  This is the bounding volume\n"
  " * around the node alone, without including children.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_internal_bounds_439_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PandaNode::get_internal_vertices(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_internal_vertices_440(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline int PandaNode::get_internal_vertices(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_internal_vertices", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*(const PandaNode*)local_this).get_internal_vertices)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_internal_vertices(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_internal_vertices_440_comment =
  "C++ Interface:\n"
  "get_internal_vertices(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the total number of vertices that will be rendered by this\n"
  " * particular node alone, not accounting for its children.\n"
  " *\n"
  " * This may not include all vertices for certain dynamic effects.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the total number of vertices that will be rendered by this\n"
  " * particular node alone, not accounting for its children.\n"
  " *\n"
  " * This may not include all vertices for certain dynamic effects.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_internal_vertices_440_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::mark_bounds_stale(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_mark_bounds_stale_445(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-void PandaNode::mark_bounds_stale(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.mark_bounds_stale", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const PandaNode*)local_this).mark_bounds_stale)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mark_bounds_stale(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_mark_bounds_stale_445_comment =
  "C++ Interface:\n"
  "mark_bounds_stale(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Indicates that the bounding volume, or something that influences the\n"
  " * bounding volume (or any of the other things stored in CData, like\n"
  " * net_collide_mask), may have changed for this node, and that it must be\n"
  " * recomputed.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Indicates that the bounding volume, or something that influences the\n"
  " * bounding volume (or any of the other things stored in CData, like\n"
  " * net_collide_mask), may have changed for this node, and that it must be\n"
  " * recomputed.\n"
  " *\n"
  " * With no parameters, this means to iterate through all stages including and\n"
  " * upstream of the current pipeline stage.\n"
  " *\n"
  " * This method is intended for internal use; usually it is not necessary for a\n"
  " * user to call this directly.  It will be called automatically by derived\n"
  " * classes when appropriate.\n"
  " */";
#else
static const char *Dtool_PandaNode_mark_bounds_stale_445_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaNode::mark_internal_bounds_stale(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_PandaNode_mark_internal_bounds_stale_446(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.mark_internal_bounds_stale")) {
    return nullptr;
  }
  // 1-void PandaNode::mark_internal_bounds_stale(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.mark_internal_bounds_stale", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).mark_internal_bounds_stale)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mark_internal_bounds_stale(const PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_mark_internal_bounds_stale_446_comment =
  "C++ Interface:\n"
  "mark_internal_bounds_stale(const PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Should be called by a derived class to mark the internal bounding volume\n"
  " * stale, so that recompute_internal_bounds() will be called when the bounding\n"
  " * volume is next requested.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Should be called by a derived class to mark the internal bounding volume\n"
  " * stale, so that compute_internal_bounds() will be called when the bounding\n"
  " * volume is next requested.\n"
  " *\n"
  " * With no parameters, this means to iterate through all stages including and\n"
  " * upstream of the current pipeline stage.\n"
  " *\n"
  " * It is normally not necessary to call this method directly; each node should\n"
  " * be responsible for calling it when its internals have changed.\n"
  " */";
#else
static const char *Dtool_PandaNode_mark_internal_bounds_stale_446_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PandaNode::is_bounds_stale(void) const
 */
static PyObject *Dtool_PandaNode_is_bounds_stale_447(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline bool PandaNode::is_bounds_stale(void) const
  bool return_value = ((*(const PandaNode*)local_this).is_bounds_stale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_is_bounds_stale_447_comment =
  "C++ Interface:\n"
  "is_bounds_stale(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the bounding volume of this node is stale and will be\n"
  " * implicitly recomputed at the next call to get_bounds(), or false if it is\n"
  " * fresh and need not be recomputed.\n"
  " */";
#else
static const char *Dtool_PandaNode_is_bounds_stale_447_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PandaNode::set_final(bool flag)
 */
static PyObject *Dtool_PandaNode_set_final_449(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.set_final")) {
    return nullptr;
  }
  // 1-inline void PandaNode::set_final(bool flag)
  ((*local_this).set_final)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_final(const PandaNode self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_set_final_449_comment =
  "C++ Interface:\n"
  "set_final(const PandaNode self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the \"final\" flag on this PandaNode.  If this is true, than no bounding\n"
  " * volume need be tested below it; a positive intersection with this node's\n"
  " * bounding volume is deemed to be a positive intersection with all geometry\n"
  " * inside.\n"
  " *\n"
  " * This is useful to quickly force a larger bounding volume around a node when\n"
  " * the GeomNodes themselves are inaccurate for some reason, without forcing a\n"
  " * recompute of every nested bounding volume.  It's also helpful when the\n"
  " * bounding volume is tricked by some special properties, like billboards,\n"
  " * that may move geometry out of its bounding volume otherwise.\n"
  " */";
#else
static const char *Dtool_PandaNode_set_final_449_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PandaNode::is_final(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_is_final_450(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline bool PandaNode::is_final(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.is_final", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      bool return_value = ((*(const PandaNode*)local_this).is_final)(param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_final(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_is_final_450_comment =
  "C++ Interface:\n"
  "is_final(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the current state of the \"final\" flag.  Initially, this flag is off\n"
  " * (false), but it may be changed by an explicit call to set_final().  See\n"
  " * set_final().\n"
  " */";
#else
static const char *Dtool_PandaNode_is_final_450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool PandaNode::is_geom_node(void) const
 */
static PyObject *Dtool_PandaNode_is_geom_node_452(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-virtual bool PandaNode::is_geom_node(void) const
  bool return_value = ((*(const PandaNode*)local_this).is_geom_node)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_is_geom_node_452_comment =
  "C++ Interface:\n"
  "is_geom_node(PandaNode self)\n"
  "\n"
  "/**\n"
  " * A simple downcast check.  Returns true if this kind of node happens to\n"
  " * inherit from GeomNode, false otherwise.\n"
  " *\n"
  " * This is provided as a a faster alternative to calling\n"
  " * is_of_type(GeomNode::get_class_type()), since this test is so important to\n"
  " * rendering.\n"
  " */";
#else
static const char *Dtool_PandaNode_is_geom_node_452_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool PandaNode::is_lod_node(void) const
 */
static PyObject *Dtool_PandaNode_is_lod_node_453(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-virtual bool PandaNode::is_lod_node(void) const
  bool return_value = ((*(const PandaNode*)local_this).is_lod_node)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_is_lod_node_453_comment =
  "C++ Interface:\n"
  "is_lod_node(PandaNode self)\n"
  "\n"
  "/**\n"
  " * A simple downcast check.  Returns true if this kind of node happens to\n"
  " * inherit from LODNode, false otherwise.\n"
  " *\n"
  " * This is provided as a a faster alternative to calling\n"
  " * is_of_type(LODNode::get_class_type()).\n"
  " */";
#else
static const char *Dtool_PandaNode_is_lod_node_453_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool PandaNode::is_collision_node(void) const
 */
static PyObject *Dtool_PandaNode_is_collision_node_454(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-virtual bool PandaNode::is_collision_node(void) const
  bool return_value = ((*(const PandaNode*)local_this).is_collision_node)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_is_collision_node_454_comment =
  "C++ Interface:\n"
  "is_collision_node(PandaNode self)\n"
  "\n"
  "/**\n"
  " * A simple downcast check.  Returns true if this kind of node happens to\n"
  " * inherit from CollisionNode, false otherwise.\n"
  " *\n"
  " * This is provided as a a faster alternative to calling\n"
  " * is_of_type(CollisionNode::get_class_type()).\n"
  " */";
#else
static const char *Dtool_PandaNode_is_collision_node_454_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual Light *PandaNode::as_light(void)
 */
static PyObject *Dtool_PandaNode_as_light_455(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.as_light")) {
    return nullptr;
  }
  // 1-virtual Light *PandaNode::as_light(void)
  Light *return_value = ((*local_this).as_light)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Light, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_as_light_455_comment =
  "C++ Interface:\n"
  "as_light(const PandaNode self)\n"
  "\n"
  "/**\n"
  " * Cross-casts the node to a Light pointer, if it is one of the four kinds of\n"
  " * Light nodes, or returns NULL if it is not.\n"
  " */";
#else
static const char *Dtool_PandaNode_as_light_455_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool PandaNode::is_ambient_light(void) const
 */
static PyObject *Dtool_PandaNode_is_ambient_light_456(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-virtual bool PandaNode::is_ambient_light(void) const
  bool return_value = ((*(const PandaNode*)local_this).is_ambient_light)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_is_ambient_light_456_comment =
  "C++ Interface:\n"
  "is_ambient_light(PandaNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is an AmbientLight, false if it is not a light, or it\n"
  " * is some other kind of light.\n"
  " */";
#else
static const char *Dtool_PandaNode_is_ambient_light_456_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PandaNode::get_fancy_bits(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_PandaNode_get_fancy_bits_458(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaNode)) {
    return nullptr;
  }
  // 1-inline int PandaNode::get_fancy_bits(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "PandaNode.get_fancy_bits", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*(const PandaNode*)local_this).get_fancy_bits)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_fancy_bits(PandaNode self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_fancy_bits_458_comment =
  "C++ Interface:\n"
  "get_fancy_bits(PandaNode self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the union of all of the enum FancyBits values corresponding to the\n"
  " * various \"fancy\" attributes that are set on the node.  If this returns 0,\n"
  " * the node has nothing interesting about it.  This is intended to speed\n"
  " * traversal by quickly skipping past nodes that don't particularly affect the\n"
  " * render state.\n"
  " */";
#else
static const char *Dtool_PandaNode_get_fancy_bits_458_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< PandaNode > PandaNode::decode_from_bam_stream(vector_uchar data, BamReader *reader = nullptr)
 */
static PyObject *Dtool_PandaNode_decode_from_bam_stream_459(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< PandaNode > PandaNode::decode_from_bam_stream(vector_uchar data, BamReader *reader = nullptr)
  unsigned char *param0_str = nullptr;
  Py_ssize_t param0_len;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"data", "reader", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "" FMTCHAR_BYTES "#|O:decode_from_bam_stream", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    BamReader *param1_this = nullptr;
    if (param1 != nullptr && param1 != Py_None) {
      param1_this = (BamReader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BamReader, 1, "PandaNode.decode_from_bam_stream", false, true);
    }
    if ((param1 == nullptr || param1 == Py_None || param1_this != nullptr)) {
      PointerTo< PandaNode > return_value = (PandaNode::decode_from_bam_stream)(vector_uchar(param0_str, param0_str + param0_len), param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      PandaNode *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decode_from_bam_stream(bytes data, BamReader reader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_decode_from_bam_stream_459_comment =
  "C++ Interface:\n"
  "decode_from_bam_stream(bytes data, BamReader reader)\n"
  "\n"
  "/**\n"
  " * Reads the bytes created by a previous call to encode_to_bam_stream(), and\n"
  " * extracts and returns the single object on those bytes.  Returns NULL on\n"
  " * error.\n"
  " *\n"
  " * This method is intended to replace decode_raw_from_bam_stream() when you\n"
  " * know the stream in question returns an object of type PandaNode, allowing\n"
  " * for easier reference count management.  Note that the caller is still\n"
  " * responsible for maintaining the reference count on the return value.\n"
  " */";
#else
static const char *Dtool_PandaNode_decode_from_bam_stream_459_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PandaNode::get_class_type(void)
 */
static PyObject *Dtool_PandaNode_get_class_type_477(PyObject *, PyObject *) {
  // 1-static TypeHandle PandaNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PandaNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_get_class_type_477_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PandaNode_get_class_type_477_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *PandaNode::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_PandaNode_upcast_to_TypedWritableReferenceCount_298(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.upcast_to_TypedWritableReferenceCount")) {
    return nullptr;
  }
  // 1-TypedWritableReferenceCount *PandaNode::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_upcast_to_TypedWritableReferenceCount_298_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const PandaNode self)\n"
  "\n"
  "upcast from PandaNode to TypedWritableReferenceCount";
#else
static const char *Dtool_PandaNode_upcast_to_TypedWritableReferenceCount_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *PandaNode::upcast_to_Namable(void)
 */
static PyObject *Dtool_PandaNode_upcast_to_Namable_301(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *PandaNode::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaNode_upcast_to_Namable_301_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const PandaNode self)\n"
  "\n"
  "upcast from PandaNode to Namable";
#else
static const char *Dtool_PandaNode_upcast_to_Namable_301_comment = nullptr;
#endif

static PyObject *Dtool_PandaNode_state_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConstPointerTo< RenderState > PandaNode::get_state(Thread *current_thread) const
  ConstPointerTo< RenderState > return_value = ((*(const PandaNode*)local_this).get_state)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  RenderState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

static int Dtool_PandaNode_state_Setter(PyObject *self, PyObject *arg, void *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.state")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete state attribute");
    return -1;
  }
  // 1-void PandaNode::set_state(RenderState const *state, Thread *current_thread)
  CPT(RenderState) arg_this;
  if (!Dtool_ConstCoerce_RenderState(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PandaNode.set_state", "RenderState");
    return -1;
  }
  ((*local_this).set_state)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_state(const PandaNode self, const RenderState state)\n");
  }
  return -1;
}

static PyObject *Dtool_PandaNode_effects_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConstPointerTo< RenderEffects > PandaNode::get_effects(Thread *current_thread) const
  ConstPointerTo< RenderEffects > return_value = ((*(const PandaNode*)local_this).get_effects)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  RenderEffects const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffects, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

static int Dtool_PandaNode_effects_Setter(PyObject *self, PyObject *arg, void *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.effects")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete effects attribute");
    return -1;
  }
  // 1-void PandaNode::set_effects(RenderEffects const *effects, Thread *current_thread)
  CPT(RenderEffects) arg_this;
  if (!Dtool_ConstCoerce_RenderEffects(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PandaNode.set_effects", "RenderEffects");
    return -1;
  }
  ((*local_this).set_effects)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_effects(const PandaNode self, const RenderEffects effects)\n");
  }
  return -1;
}

static PyObject *Dtool_PandaNode_transform_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConstPointerTo< TransformState > PandaNode::get_transform(Thread *current_thread) const
  ConstPointerTo< TransformState > return_value = ((*(const PandaNode*)local_this).get_transform)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
}

static int Dtool_PandaNode_transform_Setter(PyObject *self, PyObject *arg, void *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.transform")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete transform attribute");
    return -1;
  }
  // 1-void PandaNode::set_transform(TransformState const *transform, Thread *current_thread)
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "PandaNode.set_transform", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_transform)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_transform(const PandaNode self, const TransformState transform)\n");
  }
  return -1;
}

static PyObject *Dtool_PandaNode_prev_transform_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConstPointerTo< TransformState > PandaNode::get_prev_transform(Thread *current_thread) const
  ConstPointerTo< TransformState > return_value = ((*(const PandaNode*)local_this).get_prev_transform)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
}

/**
 * sequence length function for property PandaNode::tags
 */
static Py_ssize_t Dtool_PandaNode_tags_Len(PyObject *self) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_tags)();
}

/**
 * mapping getitem for property PandaNode::tags
 */
static PyObject *Dtool_PandaNode_tags_Mapping_Getitem(PyObject *self, PyObject *arg) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }
  {
    // 1-inline bool PandaNode::has_tag(std::string const &key, Thread *current_thread) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      bool return_value = ((*(const PandaNode*)local_this).has_tag)(std::string(param1_str, param1_len));
      if (!return_value) {
        PyErr_SetObject(PyExc_KeyError, arg);
        return nullptr;
      }
    }
  }
  // 1-inline std::string PandaNode::get_tag(std::string const &key, Thread *current_thread) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    std::string return_value = ((*(const PandaNode*)local_this).get_tag)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tag(PandaNode self, str key)\n");
  }
  return nullptr;
}

/**
 * mapping setitem for property PandaNode::tags
 */
static int Dtool_PandaNode_tags_Mapping_Setitem(PyObject *self, PyObject *key, PyObject *value) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.tags")) {
    return -1;
  }

  if (value == nullptr) {
    PyObject *arg = key;
    {
      // 1-inline bool PandaNode::has_tag(std::string const &key, Thread *current_thread) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        bool return_value = ((*(const PandaNode*)local_this).has_tag)(std::string(param1_str, param1_len));
        if (!return_value) {
          PyErr_SetObject(PyExc_KeyError, arg);
          return -1;
        }
      }
    }
    // 1-void PandaNode::clear_tag(std::string const &key, Thread *current_thread)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).clear_tag)(std::string(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
    return -1;
  }
  PyObject *args = PyTuple_New(2);
  PyTuple_SET_ITEM(args, 0, key);
  PyTuple_SET_ITEM(args, 1, value);
  Py_INCREF(key);
  Py_INCREF(value);
  // 1-void PandaNode::set_tag(std::string const &key, std::string const &value, Thread *current_thread)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  if (PyArg_ParseTuple(args, "s#s#:set_tag", &param1_str, &param1_len, &param2_str, &param2_len)) {
    ((*local_this).set_tag)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    Py_DECREF(args);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tag(const PandaNode self, str key, str value)\n");
  }
  Py_DECREF(args);
  return -1;
}

/**
 * mapping key-getter for property PandaNode::tags
 */
static PyObject *Dtool_PandaNode_tags_Mapping_Getkey(PyObject *self, Py_ssize_t index) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_tags)()) {
    PyErr_SetString(PyExc_IndexError, "PandaNode.tags[] index out of range");
    return nullptr;
  }
  // 1-inline std::string PandaNode::get_tag_key(std::size_t i) const
  std::string return_value = ((*(const PandaNode*)local_this).get_tag_key)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tag_key(PandaNode self, index)\n");
  }
}

static PyObject *Dtool_PandaNode_tags_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MappingWrapper *wrap = Dtool_NewMutableMappingWrapper(self, "PandaNode.tags");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_PandaNode_tags_Mapping_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_PandaNode_tags_Mapping_Setitem;
    }
    wrap->_keys._len_func = &Dtool_PandaNode_tags_Len;
    wrap->_keys._getitem_func = &Dtool_PandaNode_tags_Mapping_Getkey;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_PandaNode_python_tags_Getter(PyObject *self, void *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.python_tags")) {
    return nullptr;
  }

  // 1-PyObject *PandaNode::get_python_tags(void)
  PyObject *return_value = invoke_extension(local_this).get_python_tags();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaNode_overall_bit_Getter(PyObject *self, void *) {
  // 1-static inline DrawMask PandaNode::get_overall_bit(void)
  DrawMask *return_value = new DrawMask((PandaNode::get_overall_bit)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static PyObject *Dtool_PandaNode_all_camera_mask_Getter(PyObject *self, void *) {
  // 1-static inline DrawMask PandaNode::get_all_camera_mask(void)
  DrawMask *return_value = new DrawMask((PandaNode::get_all_camera_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static PyObject *Dtool_PandaNode_overall_hidden_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool PandaNode::is_overall_hidden(void) const
  bool return_value = ((*(const PandaNode*)local_this).is_overall_hidden)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PandaNode_overall_hidden_Setter(PyObject *self, PyObject *arg, void *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.overall_hidden")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete overall_hidden attribute");
    return -1;
  }
  // 1-inline void PandaNode::set_overall_hidden(bool overall_hidden)
  ((*local_this).set_overall_hidden)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_overall_hidden(const PandaNode self, bool overall_hidden)\n");
  }
  return -1;
}

static PyObject *Dtool_PandaNode_draw_control_mask_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline DrawMask PandaNode::get_draw_control_mask(void) const
  DrawMask *return_value = new DrawMask(((*(const PandaNode*)local_this).get_draw_control_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static PyObject *Dtool_PandaNode_draw_show_mask_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline DrawMask PandaNode::get_draw_show_mask(void) const
  DrawMask *return_value = new DrawMask(((*(const PandaNode*)local_this).get_draw_show_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static PyObject *Dtool_PandaNode_into_collide_mask_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CollideMask PandaNode::get_into_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const PandaNode*)local_this).get_into_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_PandaNode_into_collide_mask_Setter(PyObject *self, PyObject *arg, void *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.into_collide_mask")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete into_collide_mask attribute");
    return -1;
  }
  // 1-void PandaNode::set_into_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PandaNode.set_into_collide_mask", "BitMask");
    return -1;
  }
  ((*local_this).set_into_collide_mask)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_into_collide_mask(const PandaNode self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_PandaNode_legal_collide_mask_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual CollideMask PandaNode::get_legal_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const PandaNode*)local_this).get_legal_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static PyObject *Dtool_PandaNode_bounds_type_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-BoundingVolume::BoundsType PandaNode::get_bounds_type(void) const
  BoundingVolume::BoundsType return_value = ((*(const PandaNode*)local_this).get_bounds_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaNode_nested_vertices_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int PandaNode::get_nested_vertices(Thread *current_thread) const
  int return_value = ((*(const PandaNode*)local_this).get_nested_vertices)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaNode_internal_bounds_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConstPointerTo< BoundingVolume > PandaNode::get_internal_bounds(Thread *current_thread) const
  ConstPointerTo< BoundingVolume > return_value = ((*(const PandaNode*)local_this).get_internal_bounds)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  BoundingVolume const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_PandaNode_internal_vertices_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int PandaNode::get_internal_vertices(Thread *current_thread) const
  int return_value = ((*(const PandaNode*)local_this).get_internal_vertices)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaNode_bounds_stale_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool PandaNode::is_bounds_stale(void) const
  bool return_value = ((*(const PandaNode*)local_this).is_bounds_stale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaNode_final_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool PandaNode::is_final(Thread *current_thread) const
  bool return_value = ((*(const PandaNode*)local_this).is_final)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PandaNode_final_Setter(PyObject *self, PyObject *arg, void *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaNode, (void **)&local_this, "PandaNode.final")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete final attribute");
    return -1;
  }
  // 1-inline void PandaNode::set_final(bool flag)
  ((*local_this).set_final)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_final(const PandaNode self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_PandaNode_children_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PandaNode::Children PandaNode::get_children(Thread *current_thread) const
  PandaNode::Children *return_value = new PandaNode::Children(((*(const PandaNode*)local_this).get_children)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PandaNode_Children, true, false);
}

static PyObject *Dtool_PandaNode_stashed_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PandaNode::Stashed PandaNode::get_stashed(Thread *current_thread) const
  PandaNode::Stashed *return_value = new PandaNode::Stashed(((*(const PandaNode*)local_this).get_stashed)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PandaNode_Stashed, true, false);
}

static PyObject *Dtool_PandaNode_parents_Getter(PyObject *self, void *) {
  const PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PandaNode::Parents PandaNode::get_parents(Thread *current_thread) const
  PandaNode::Parents *return_value = new PandaNode::Parents(((*(const PandaNode*)local_this).get_parents)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PandaNode_Parents, true, false);
}

/**
 * Python function wrapper for:
 * explicit PandaNode::PandaNode(std::string const &name)
 */
static int Dtool_Init_PandaNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PandaNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit PandaNode::PandaNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      PandaNode *return_value = new PandaNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PandaNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PandaNode(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PandaNode_get_parents(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_parents)();
  PyTupleObject args;
  (void)PyObject_INIT_VAR((PyVarObject *)&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_PandaNode_get_parent_314(self, (PyObject *)&args, nullptr);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PandaNode_get_children(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_children)();
  PyTupleObject args;
  (void)PyObject_INIT_VAR((PyVarObject *)&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_PandaNode_get_child_318(self, (PyObject *)&args, nullptr);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PandaNode_get_stashed(PyObject *self, PyObject *) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_stashed)();
  PyTupleObject args;
  (void)PyObject_INIT_VAR((PyVarObject *)&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_PandaNode_get_stashed_329(self, (PyObject *)&args, nullptr);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PandaNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PandaNode) {
    printf("PandaNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PandaNode *local_this = (PandaNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PandaNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PandaNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PandaNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PandaNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PandaNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PandaNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PandaNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PandaNode::Children
 */
static int Dtool_Init_PandaNode_Children(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PandaNode_Children(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PandaNode_Children) {
    printf("PandaNode_Children ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PandaNode::Children *local_this = (PandaNode::Children *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PandaNode_Children) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PandaNode_Children(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PandaNode_Children) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PandaNode::Stashed
 */
static int Dtool_Init_PandaNode_Stashed(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PandaNode_Stashed(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PandaNode_Stashed) {
    printf("PandaNode_Stashed ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PandaNode::Stashed *local_this = (PandaNode::Stashed *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PandaNode_Stashed) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PandaNode_Stashed(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PandaNode_Stashed) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PandaNode::Parents
 */
static int Dtool_Init_PandaNode_Parents(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PandaNode_Parents(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PandaNode_Parents) {
    printf("PandaNode_Parents ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PandaNode::Parents *local_this = (PandaNode::Parents *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PandaNode_Parents) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PandaNode_Parents(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PandaNode_Parents) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TransparencyAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > TransparencyAttrib::make(TransparencyAttrib::Mode mode)
 */
static PyObject *Dtool_TransparencyAttrib_make_480(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > TransparencyAttrib::make(TransparencyAttrib::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (TransparencyAttrib::make)((TransparencyAttrib::Mode)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransparencyAttrib_make_480_comment =
  "C++ Interface:\n"
  "make(int mode)\n"
  "\n"
  "/**\n"
  " * Constructs a new TransparencyAttrib object.\n"
  " */";
#else
static const char *Dtool_TransparencyAttrib_make_480_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > TransparencyAttrib::make_default(void)
 */
static PyObject *Dtool_TransparencyAttrib_make_default_481(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > TransparencyAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (TransparencyAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TransparencyAttrib_make_default_481_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_TransparencyAttrib_make_default_481_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransparencyAttrib::Mode TransparencyAttrib::get_mode(void) const
 */
static PyObject *Dtool_TransparencyAttrib_get_mode_482(PyObject *self, PyObject *) {
  TransparencyAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransparencyAttrib)) {
    return nullptr;
  }
  // 1-inline TransparencyAttrib::Mode TransparencyAttrib::get_mode(void) const
  TransparencyAttrib::Mode return_value = ((*(const TransparencyAttrib*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransparencyAttrib_get_mode_482_comment =
  "C++ Interface:\n"
  "get_mode(TransparencyAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the transparency mode.\n"
  " */";
#else
static const char *Dtool_TransparencyAttrib_get_mode_482_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int TransparencyAttrib::get_class_slot(void)
 */
static PyObject *Dtool_TransparencyAttrib_get_class_slot_484(PyObject *, PyObject *) {
  // 1-static int TransparencyAttrib::get_class_slot(void)
  int return_value = (TransparencyAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransparencyAttrib_get_class_slot_484_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_TransparencyAttrib_get_class_slot_484_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TransparencyAttrib::get_class_type(void)
 */
static PyObject *Dtool_TransparencyAttrib_get_class_type_486(PyObject *, PyObject *) {
  // 1-static TypeHandle TransparencyAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TransparencyAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TransparencyAttrib_get_class_type_486_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TransparencyAttrib_get_class_type_486_comment = nullptr;
#endif

static PyObject *Dtool_TransparencyAttrib_mode_Getter(PyObject *self, void *) {
  const TransparencyAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransparencyAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline TransparencyAttrib::Mode TransparencyAttrib::get_mode(void) const
  TransparencyAttrib::Mode return_value = ((*(const TransparencyAttrib*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TransparencyAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int TransparencyAttrib::get_class_slot(void)
  int return_value = (TransparencyAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_TransparencyAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_TransparencyAttrib(PyObject *args, CPT(TransparencyAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_TransparencyAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > TransparencyAttrib::make(TransparencyAttrib::Mode mode)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (TransparencyAttrib::make)((TransparencyAttrib::Mode)arg_val);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((TransparencyAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_TransparencyAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TransparencyAttrib) {
    printf("TransparencyAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TransparencyAttrib *local_this = (TransparencyAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TransparencyAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TransparencyAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TransparencyAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TransparencyAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (TransparencyAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TransparencyAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TransparencyAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TransparencyAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LogicOpAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LogicOpAttrib::make_off(void)
 */
static PyObject *Dtool_LogicOpAttrib_make_off_490(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > LogicOpAttrib::make_off(void)
  ConstPointerTo< RenderAttrib > return_value = (LogicOpAttrib::make_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LogicOpAttrib_make_off_490_comment =
  "C++ Interface:\n"
  "make_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new LogicOpAttrib object that disables special-effect\n"
  " * blending, allowing normal transparency to be used instead.\n"
  " */";
#else
static const char *Dtool_LogicOpAttrib_make_off_490_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LogicOpAttrib::make(LogicOpAttrib::Operation op)
 */
static PyObject *Dtool_LogicOpAttrib_make_491(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > LogicOpAttrib::make(LogicOpAttrib::Operation op)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (LogicOpAttrib::make)((LogicOpAttrib::Operation)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int op)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LogicOpAttrib_make_491_comment =
  "C++ Interface:\n"
  "make(int op)\n"
  "\n"
  "/**\n"
  " * Constructs a new LogicOpAttrib object with the given logic operation.\n"
  " */";
#else
static const char *Dtool_LogicOpAttrib_make_491_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LogicOpAttrib::make_default(void)
 */
static PyObject *Dtool_LogicOpAttrib_make_default_492(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > LogicOpAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (LogicOpAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LogicOpAttrib_make_default_492_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_LogicOpAttrib_make_default_492_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LogicOpAttrib::Operation LogicOpAttrib::get_operation(void) const
 */
static PyObject *Dtool_LogicOpAttrib_get_operation_493(PyObject *self, PyObject *) {
  LogicOpAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LogicOpAttrib)) {
    return nullptr;
  }
  // 1-inline LogicOpAttrib::Operation LogicOpAttrib::get_operation(void) const
  LogicOpAttrib::Operation return_value = ((*(const LogicOpAttrib*)local_this).get_operation)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LogicOpAttrib_get_operation_493_comment =
  "C++ Interface:\n"
  "get_operation(LogicOpAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the logic operation specified by this attribute.\n"
  " */";
#else
static const char *Dtool_LogicOpAttrib_get_operation_493_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int LogicOpAttrib::get_class_slot(void)
 */
static PyObject *Dtool_LogicOpAttrib_get_class_slot_495(PyObject *, PyObject *) {
  // 1-static int LogicOpAttrib::get_class_slot(void)
  int return_value = (LogicOpAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LogicOpAttrib_get_class_slot_495_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_LogicOpAttrib_get_class_slot_495_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LogicOpAttrib::get_class_type(void)
 */
static PyObject *Dtool_LogicOpAttrib_get_class_type_497(PyObject *, PyObject *) {
  // 1-static TypeHandle LogicOpAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LogicOpAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LogicOpAttrib_get_class_type_497_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LogicOpAttrib_get_class_type_497_comment = nullptr;
#endif

static PyObject *Dtool_LogicOpAttrib_operation_Getter(PyObject *self, void *) {
  const LogicOpAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LogicOpAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LogicOpAttrib::Operation LogicOpAttrib::get_operation(void) const
  LogicOpAttrib::Operation return_value = ((*(const LogicOpAttrib*)local_this).get_operation)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LogicOpAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int LogicOpAttrib::get_class_slot(void)
  int return_value = (LogicOpAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_LogicOpAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_LogicOpAttrib(PyObject *args, CPT(LogicOpAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LogicOpAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > LogicOpAttrib::make(LogicOpAttrib::Operation op)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (LogicOpAttrib::make)((LogicOpAttrib::Operation)arg_val);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((LogicOpAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_LogicOpAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LogicOpAttrib) {
    printf("LogicOpAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LogicOpAttrib *local_this = (LogicOpAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LogicOpAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LogicOpAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LogicOpAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LogicOpAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (LogicOpAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LogicOpAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LogicOpAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LogicOpAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShaderInput
 */
/**
 * Python function wrapper for:
 * static ShaderInput const &ShaderInput::get_blank(void)
 */
static PyObject *Dtool_ShaderInput_get_blank_501(PyObject *, PyObject *) {
  // 1-static ShaderInput const &ShaderInput::get_blank(void)
  ShaderInput const *return_value = &((ShaderInput::get_blank)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ShaderInput, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ShaderInput_get_blank_501_comment =
  "C++ Interface:\n"
  "get_blank()\n"
  "\n"
  "/**\n"
  " * Returns a static ShaderInput object with name NULL, priority zero, type\n"
  " * INVALID, and all value-fields cleared.\n"
  " */";
#else
static const char *Dtool_ShaderInput_get_blank_501_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t ShaderInput::add_hash(std::size_t hash) const
 */
static PyObject *Dtool_ShaderInput_add_hash_508(PyObject *self, PyObject *arg) {
  ShaderInput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderInput)) {
    return nullptr;
  }
  // 1-std::size_t ShaderInput::add_hash(std::size_t hash) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::size_t return_value = ((*(const ShaderInput*)local_this).add_hash)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(ShaderInput self, int hash)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderInput_add_hash_508_comment =
  "C++ Interface:\n"
  "add_hash(ShaderInput self, int hash)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderInput_add_hash_508_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName const *ShaderInput::get_name(void) const
 */
static PyObject *Dtool_ShaderInput_get_name_509(PyObject *self, PyObject *) {
  ShaderInput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderInput)) {
    return nullptr;
  }
  // 1-inline InternalName const *ShaderInput::get_name(void) const
  InternalName const *return_value = ((*(const ShaderInput*)local_this).get_name)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
}

#ifndef NDEBUG
static const char *Dtool_ShaderInput_get_name_509_comment =
  "C++ Interface:\n"
  "get_name(ShaderInput self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderInput_get_name_509_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ShaderInput::get_value_type(void) const
 */
static PyObject *Dtool_ShaderInput_get_value_type_510(PyObject *self, PyObject *) {
  ShaderInput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderInput)) {
    return nullptr;
  }
  // 1-inline int ShaderInput::get_value_type(void) const
  int return_value = ((*(const ShaderInput*)local_this).get_value_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderInput_get_value_type_510_comment =
  "C++ Interface:\n"
  "get_value_type(ShaderInput self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderInput_get_value_type_510_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ShaderInput::get_priority(void) const
 */
static PyObject *Dtool_ShaderInput_get_priority_511(PyObject *self, PyObject *) {
  ShaderInput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderInput)) {
    return nullptr;
  }
  // 1-inline int ShaderInput::get_priority(void) const
  int return_value = ((*(const ShaderInput*)local_this).get_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderInput_get_priority_511_comment =
  "C++ Interface:\n"
  "get_priority(ShaderInput self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderInput_get_priority_511_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &ShaderInput::get_vector(void) const
 */
static PyObject *Dtool_ShaderInput_get_vector_512(PyObject *self, PyObject *) {
  ShaderInput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderInput)) {
    return nullptr;
  }
  // 1-inline LVecBase4 const &ShaderInput::get_vector(void) const
  LVecBase4 const *return_value = &(((*(const ShaderInput*)local_this).get_vector)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ShaderInput_get_vector_512_comment =
  "C++ Interface:\n"
  "get_vector(ShaderInput self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderInput_get_vector_512_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath ShaderInput::get_nodepath(void) const
 */
static PyObject *Dtool_ShaderInput_get_nodepath_514(PyObject *self, PyObject *) {
  ShaderInput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderInput)) {
    return nullptr;
  }
  // 1-NodePath ShaderInput::get_nodepath(void) const
  NodePath *return_value = new NodePath(((*(const ShaderInput*)local_this).get_nodepath)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderInput_get_nodepath_514_comment =
  "C++ Interface:\n"
  "get_nodepath(ShaderInput self)\n"
  "\n"
  "/**\n"
  " * Warning: no error checking is done.  This *will* crash if get_value_type()\n"
  " * is not M_nodepath.\n"
  " */";
#else
static const char *Dtool_ShaderInput_get_nodepath_514_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *ShaderInput::get_texture(void) const
 */
static PyObject *Dtool_ShaderInput_get_texture_515(PyObject *self, PyObject *) {
  ShaderInput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderInput)) {
    return nullptr;
  }
  // 1-Texture *ShaderInput::get_texture(void) const
  Texture *return_value = ((*(const ShaderInput*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ShaderInput_get_texture_515_comment =
  "C++ Interface:\n"
  "get_texture(ShaderInput self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderInput_get_texture_515_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SamplerState const &ShaderInput::get_sampler(void) const
 */
static PyObject *Dtool_ShaderInput_get_sampler_516(PyObject *self, PyObject *) {
  ShaderInput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderInput)) {
    return nullptr;
  }
  // 1-SamplerState const &ShaderInput::get_sampler(void) const
  SamplerState const *return_value = &(((*(const ShaderInput*)local_this).get_sampler)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SamplerState, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ShaderInput_get_sampler_516_comment =
  "C++ Interface:\n"
  "get_sampler(ShaderInput self)\n"
  "\n"
  "/**\n"
  " * Warning: no error checking is done.\n"
  " */";
#else
static const char *Dtool_ShaderInput_get_sampler_516_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit ShaderInput::ShaderInput(CPT_InternalName name, PyObject *value, int priority = 0)
 * explicit ShaderInput::ShaderInput(CPT_InternalName name, Texture *tex, SamplerState const &sampler, int priority = 0)
 * explicit ShaderInput::ShaderInput(CPT_InternalName name, Texture *tex, bool read, bool write, int z = -1, int n = 0, int priority = 0)
 * inline explicit ShaderInput::ShaderInput(CPT_InternalName name, int priority = 0)
 * inline ShaderInput::ShaderInput(ShaderInput const &) = default
 */
static int Dtool_Init_ShaderInput(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline explicit ShaderInput::ShaderInput(CPT_InternalName name, int priority)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "name")) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr) {
            ShaderInput *return_value = new ShaderInput(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
          }
        }
      }

      {
        // -2 inline ShaderInput::ShaderInput(ShaderInput const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          ShaderInput const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ShaderInput);
          if (param0_this != nullptr) {
            ShaderInput *return_value = new ShaderInput(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
          }
        }
      }

      {
        // -2 inline explicit ShaderInput::ShaderInput(CPT_InternalName name, int priority)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "name")) {
          CPT(InternalName) param0_this;
          if (Dtool_ConstCoerce_InternalName(param0, param0_this)) {
            ShaderInput *return_value = new ShaderInput(std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
          }
        }
      }

      // No coercion possible: inline ShaderInput::ShaderInput(ShaderInput const &) = default
    }
    break;
  case 2:
    {
      {
        // -2 explicit ShaderInput::ShaderInput(CPT_InternalName name, PyObject *value, int priority)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"name", "value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:ShaderInput", (char **)keyword_list, &param0, &param1)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr) {
            ShaderInput *result = new ShaderInput;
            invoke_extension(result).__init__(param0_this, param1);
            ShaderInput *return_value = result;
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            PyObject *exception = _PyErr_OCCURRED();
            if (exception == PyExc_TypeError) {
              // TypeError raised; continue to next overload type.
            } else if (exception != nullptr) {
              delete return_value;
              return -1;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (UNLIKELY(notify->has_assert_failed())) {
                delete return_value;
                Dtool_Raise_AssertionError();
                return -1;
              }
#endif
              return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline explicit ShaderInput::ShaderInput(CPT_InternalName name, int priority)
        PyObject *param0;
        int param1;
        static const char *keyword_list[] = {"name", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:ShaderInput", (char **)keyword_list, &param0, &param1)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr) {
            ShaderInput *return_value = new ShaderInput(param0_this, (int)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 explicit ShaderInput::ShaderInput(CPT_InternalName name, PyObject *value, int priority)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"name", "value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:ShaderInput", (char **)keyword_list, &param0, &param1)) {
          CPT(InternalName) param0_this;
          if (Dtool_ConstCoerce_InternalName(param0, param0_this)) {
            ShaderInput *result = new ShaderInput;
            invoke_extension(result).__init__(std::move(param0_this), param1);
            ShaderInput *return_value = result;
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            PyObject *exception = _PyErr_OCCURRED();
            if (exception == PyExc_TypeError) {
              // TypeError raised; continue to next overload type.
            } else if (exception != nullptr) {
              delete return_value;
              return -1;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (UNLIKELY(notify->has_assert_failed())) {
                delete return_value;
                Dtool_Raise_AssertionError();
                return -1;
              }
#endif
              return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline explicit ShaderInput::ShaderInput(CPT_InternalName name, int priority)
        PyObject *param0;
        int param1;
        static const char *keyword_list[] = {"name", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:ShaderInput", (char **)keyword_list, &param0, &param1)) {
          CPT(InternalName) param0_this;
          if (Dtool_ConstCoerce_InternalName(param0, param0_this)) {
            ShaderInput *return_value = new ShaderInput(std::move(param0_this), (int)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
    {
      {
        // -2 explicit ShaderInput::ShaderInput(CPT_InternalName name, Texture *tex, SamplerState const &sampler, int priority)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"name", "tex", "sampler", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:ShaderInput", (char **)keyword_list, &param0, &param1, &param2)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "ShaderInput.ShaderInput", false, false);
          SamplerState const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_SamplerState);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            ShaderInput *return_value = new ShaderInput(param0_this, param1_this, *param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 explicit ShaderInput::ShaderInput(CPT_InternalName name, PyObject *value, int priority)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"name", "value", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:ShaderInput", (char **)keyword_list, &param0, &param1, &param2)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr) {
            ShaderInput *result = new ShaderInput;
            invoke_extension(result).__init__(param0_this, param1, (int)param2);
            ShaderInput *return_value = result;
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            PyObject *exception = _PyErr_OCCURRED();
            if (exception == PyExc_TypeError) {
              // TypeError raised; continue to next overload type.
            } else if (exception != nullptr) {
              delete return_value;
              return -1;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (UNLIKELY(notify->has_assert_failed())) {
                delete return_value;
                Dtool_Raise_AssertionError();
                return -1;
              }
#endif
              return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 explicit ShaderInput::ShaderInput(CPT_InternalName name, Texture *tex, SamplerState const &sampler, int priority)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"name", "tex", "sampler", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:ShaderInput", (char **)keyword_list, &param0, &param1, &param2)) {
          CPT(InternalName) param0_this;
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "ShaderInput.ShaderInput", false, false);
          SamplerState const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_SamplerState);
          if (Dtool_ConstCoerce_InternalName(param0, param0_this) && param1_this != nullptr && param2_this != nullptr) {
            ShaderInput *return_value = new ShaderInput(std::move(param0_this), param1_this, *param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 explicit ShaderInput::ShaderInput(CPT_InternalName name, PyObject *value, int priority)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"name", "value", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:ShaderInput", (char **)keyword_list, &param0, &param1, &param2)) {
          CPT(InternalName) param0_this;
          if (Dtool_ConstCoerce_InternalName(param0, param0_this)) {
            ShaderInput *result = new ShaderInput;
            invoke_extension(result).__init__(std::move(param0_this), param1, (int)param2);
            ShaderInput *return_value = result;
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            PyObject *exception = _PyErr_OCCURRED();
            if (exception == PyExc_TypeError) {
              // TypeError raised; continue to next overload type.
            } else if (exception != nullptr) {
              delete return_value;
              return -1;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (UNLIKELY(notify->has_assert_failed())) {
                delete return_value;
                Dtool_Raise_AssertionError();
                return -1;
              }
#endif
              return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
            }
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 4:
  case 5:
  case 6:
  case 7:
    {
      {
        // -2 explicit ShaderInput::ShaderInput(CPT_InternalName name, Texture *tex, bool read, bool write, int z = -1, int n = 0, int priority = 0)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4 = -1;
        int param5 = 0;
        int param6 = 0;
        static const char *keyword_list[] = {"name", "tex", "read", "write", "z", "n", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO|iii:ShaderInput", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "ShaderInput.ShaderInput", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            ShaderInput *return_value = new ShaderInput(param0_this, param1_this, (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0), (int)param4, (int)param5, (int)param6);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 explicit ShaderInput::ShaderInput(CPT_InternalName name, Texture *tex, SamplerState const &sampler, int priority = 0)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"name", "tex", "sampler", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:ShaderInput", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "ShaderInput.ShaderInput", false, false);
          SamplerState const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_SamplerState);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            ShaderInput *return_value = new ShaderInput(param0_this, param1_this, *param2_this, (int)param3);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 explicit ShaderInput::ShaderInput(CPT_InternalName name, Texture *tex, bool read, bool write, int z = -1, int n = 0, int priority = 0)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4 = -1;
        int param5 = 0;
        int param6 = 0;
        static const char *keyword_list[] = {"name", "tex", "read", "write", "z", "n", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO|iii:ShaderInput", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
          CPT(InternalName) param0_this;
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "ShaderInput.ShaderInput", false, false);
          if (Dtool_ConstCoerce_InternalName(param0, param0_this) && param1_this != nullptr) {
            ShaderInput *return_value = new ShaderInput(std::move(param0_this), param1_this, (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0), (int)param4, (int)param5, (int)param6);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 explicit ShaderInput::ShaderInput(CPT_InternalName name, Texture *tex, SamplerState const &sampler, int priority = 0)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"name", "tex", "sampler", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:ShaderInput", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          CPT(InternalName) param0_this;
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "ShaderInput.ShaderInput", false, false);
          SamplerState const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_SamplerState);
          if (Dtool_ConstCoerce_InternalName(param0, param0_this) && param1_this != nullptr && param2_this != nullptr) {
            ShaderInput *return_value = new ShaderInput(std::move(param0_this), param1_this, *param2_this, (int)param3);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderInput, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ShaderInput() takes 1, 2, 3, 4, 5, 6 or 7 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShaderInput(const InternalName name)\n"
      "ShaderInput(const ShaderInput param0)\n"
      "ShaderInput(const InternalName name, object value)\n"
      "ShaderInput(const InternalName name, int priority)\n"
      "ShaderInput(const InternalName name, Texture tex, const SamplerState sampler)\n"
      "ShaderInput(const InternalName name, object value, int priority)\n"
      "ShaderInput(const InternalName name, Texture tex, bool read, bool write, int z, int n, int priority)\n"
      "ShaderInput(const InternalName name, Texture tex, const SamplerState sampler, int priority)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ShaderInput(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShaderInput) {
    printf("ShaderInput ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShaderInput *local_this = (ShaderInput *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShaderInput) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShaderInput(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShaderInput) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InternalNameCollection
 */
/**
 * Python function wrapper for:
 * void InternalNameCollection::operator =(InternalNameCollection const &copy)
 */
static PyObject *Dtool_InternalNameCollection_operator_520(PyObject *self, PyObject *arg) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalNameCollection, (void **)&local_this, "InternalNameCollection.assign")) {
    return nullptr;
  }
  // 1-void InternalNameCollection::operator =(InternalNameCollection const &copy)
  InternalNameCollection const *arg_this = (InternalNameCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InternalNameCollection, 1, "InternalNameCollection.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    InternalNameCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalNameCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const InternalNameCollection self, const InternalNameCollection copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_operator_520_comment =
  "C++ Interface:\n"
  "assign(const InternalNameCollection self, const InternalNameCollection copy)\n";
#else
static const char *Dtool_InternalNameCollection_operator_520_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InternalNameCollection::add_name(InternalName const *name)
 */
static PyObject *Dtool_InternalNameCollection_add_name_522(PyObject *self, PyObject *arg) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalNameCollection, (void **)&local_this, "InternalNameCollection.add_name")) {
    return nullptr;
  }
  // 1-void InternalNameCollection::add_name(InternalName const *name)
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "InternalNameCollection.add_name", "InternalName");
  }
  ((*local_this).add_name)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_name(const InternalNameCollection self, const InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_add_name_522_comment =
  "C++ Interface:\n"
  "add_name(const InternalNameCollection self, const InternalName name)\n"
  "\n"
  "/**\n"
  " * Adds a new InternalName to the collection.\n"
  " */";
#else
static const char *Dtool_InternalNameCollection_add_name_522_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool InternalNameCollection::remove_name(InternalName const *name)
 */
static PyObject *Dtool_InternalNameCollection_remove_name_523(PyObject *self, PyObject *arg) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalNameCollection, (void **)&local_this, "InternalNameCollection.remove_name")) {
    return nullptr;
  }
  // 1-bool InternalNameCollection::remove_name(InternalName const *name)
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "InternalNameCollection.remove_name", "InternalName");
  }
  bool return_value = ((*local_this).remove_name)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_name(const InternalNameCollection self, const InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_remove_name_523_comment =
  "C++ Interface:\n"
  "remove_name(const InternalNameCollection self, const InternalName name)\n"
  "\n"
  "/**\n"
  " * Removes the indicated InternalName from the collection.  Returns true if\n"
  " * the name was removed, false if it was not a member of the collection.\n"
  " */";
#else
static const char *Dtool_InternalNameCollection_remove_name_523_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InternalNameCollection::add_names_from(InternalNameCollection const &other)
 */
static PyObject *Dtool_InternalNameCollection_add_names_from_524(PyObject *self, PyObject *arg) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalNameCollection, (void **)&local_this, "InternalNameCollection.add_names_from")) {
    return nullptr;
  }
  // 1-void InternalNameCollection::add_names_from(InternalNameCollection const &other)
  InternalNameCollection const *arg_this = (InternalNameCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InternalNameCollection, 1, "InternalNameCollection.add_names_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_names_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_names_from(const InternalNameCollection self, const InternalNameCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_add_names_from_524_comment =
  "C++ Interface:\n"
  "add_names_from(const InternalNameCollection self, const InternalNameCollection other)\n"
  "\n"
  "/**\n"
  " * Adds all the InternalNames indicated in the other collection to this name.\n"
  " * The other names are simply appended to the end of the names in this list;\n"
  " * duplicates are not automatically removed.\n"
  " */";
#else
static const char *Dtool_InternalNameCollection_add_names_from_524_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InternalNameCollection::remove_names_from(InternalNameCollection const &other)
 */
static PyObject *Dtool_InternalNameCollection_remove_names_from_525(PyObject *self, PyObject *arg) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalNameCollection, (void **)&local_this, "InternalNameCollection.remove_names_from")) {
    return nullptr;
  }
  // 1-void InternalNameCollection::remove_names_from(InternalNameCollection const &other)
  InternalNameCollection const *arg_this = (InternalNameCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InternalNameCollection, 1, "InternalNameCollection.remove_names_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_names_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_names_from(const InternalNameCollection self, const InternalNameCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_remove_names_from_525_comment =
  "C++ Interface:\n"
  "remove_names_from(const InternalNameCollection self, const InternalNameCollection other)\n"
  "\n"
  "/**\n"
  " * Removes from this collection all of the InternalNames listed in the other\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_InternalNameCollection_remove_names_from_525_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InternalNameCollection::remove_duplicate_names(void)
 */
static PyObject *Dtool_InternalNameCollection_remove_duplicate_names_526(PyObject *self, PyObject *) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalNameCollection, (void **)&local_this, "InternalNameCollection.remove_duplicate_names")) {
    return nullptr;
  }
  // 1-void InternalNameCollection::remove_duplicate_names(void)
  ((*local_this).remove_duplicate_names)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_remove_duplicate_names_526_comment =
  "C++ Interface:\n"
  "remove_duplicate_names(const InternalNameCollection self)\n"
  "\n"
  "/**\n"
  " * Removes any duplicate entries of the same InternalNames on this collection.\n"
  " * If a InternalName appears multiple times, the first appearance is retained;\n"
  " * subsequent appearances are removed.\n"
  " */";
#else
static const char *Dtool_InternalNameCollection_remove_duplicate_names_526_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool InternalNameCollection::has_name(InternalName const *name) const
 */
static PyObject *Dtool_InternalNameCollection_has_name_527(PyObject *self, PyObject *arg) {
  InternalNameCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalNameCollection)) {
    return nullptr;
  }
  // 1-bool InternalNameCollection::has_name(InternalName const *name) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "InternalNameCollection.has_name", "InternalName");
  }
  bool return_value = ((*(const InternalNameCollection*)local_this).has_name)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_name(InternalNameCollection self, const InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_has_name_527_comment =
  "C++ Interface:\n"
  "has_name(InternalNameCollection self, const InternalName name)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated InternalName appears in this collection,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_InternalNameCollection_has_name_527_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InternalNameCollection::clear(void)
 */
static PyObject *Dtool_InternalNameCollection_clear_528(PyObject *self, PyObject *) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalNameCollection, (void **)&local_this, "InternalNameCollection.clear")) {
    return nullptr;
  }
  // 1-void InternalNameCollection::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_clear_528_comment =
  "C++ Interface:\n"
  "clear(const InternalNameCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all InternalNames from the collection.\n"
  " */";
#else
static const char *Dtool_InternalNameCollection_clear_528_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int InternalNameCollection::get_num_names(void) const
 */
static PyObject *Dtool_InternalNameCollection_get_num_names_529(PyObject *self, PyObject *) {
  InternalNameCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalNameCollection)) {
    return nullptr;
  }
  // 1-int InternalNameCollection::get_num_names(void) const
  int return_value = ((*(const InternalNameCollection*)local_this).get_num_names)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_get_num_names_529_comment =
  "C++ Interface:\n"
  "get_num_names(InternalNameCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of InternalNames in the collection.\n"
  " */";
#else
static const char *Dtool_InternalNameCollection_get_num_names_529_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * InternalName const *InternalNameCollection::get_name(int index) const
 */
static PyObject *Dtool_InternalNameCollection_get_name_530(PyObject *self, PyObject *arg) {
  InternalNameCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalNameCollection)) {
    return nullptr;
  }
  // 1-InternalName const *InternalNameCollection::get_name(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    InternalName const *return_value = ((*(const InternalNameCollection*)local_this).get_name)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_name(InternalNameCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_get_name_530_comment =
  "C++ Interface:\n"
  "get_name(InternalNameCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth InternalName in the collection.\n"
  " */";
#else
static const char *Dtool_InternalNameCollection_get_name_530_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InternalNameCollection::output(std::ostream &out) const
 */
static PyObject *Dtool_InternalNameCollection_output_536(PyObject *self, PyObject *arg) {
  InternalNameCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalNameCollection)) {
    return nullptr;
  }
  // 1-void InternalNameCollection::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "InternalNameCollection.output", false, true);
  if (arg_this != nullptr) {
    ((*(const InternalNameCollection*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(InternalNameCollection self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_output_536_comment =
  "C++ Interface:\n"
  "output(InternalNameCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the InternalNameCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_InternalNameCollection_output_536_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InternalNameCollection::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_InternalNameCollection_write_537(PyObject *self, PyObject *args, PyObject *kwds) {
  InternalNameCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalNameCollection)) {
    return nullptr;
  }
  // 1-void InternalNameCollection::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "InternalNameCollection.write", false, true);
    if (param1_this != nullptr) {
      ((*(const InternalNameCollection*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(InternalNameCollection self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalNameCollection_write_537_comment =
  "C++ Interface:\n"
  "write(InternalNameCollection self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the InternalNameCollection to\n"
  " * the indicated output stream.\n"
  " */";
#else
static const char *Dtool_InternalNameCollection_write_537_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * InternalNameCollection::InternalNameCollection(void)
 * InternalNameCollection::InternalNameCollection(InternalNameCollection const &copy)
 */
static int Dtool_Init_InternalNameCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-InternalNameCollection::InternalNameCollection(void)
      InternalNameCollection *return_value = new InternalNameCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InternalNameCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-InternalNameCollection::InternalNameCollection(InternalNameCollection const &copy)
        InternalNameCollection const *arg_this = (InternalNameCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InternalNameCollection, 0, "InternalNameCollection.InternalNameCollection", true, true);
        if (arg_this != nullptr) {
          InternalNameCollection *return_value = new InternalNameCollection(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InternalNameCollection, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "InternalNameCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "InternalNameCollection()\n"
      "InternalNameCollection(const InternalNameCollection copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_InternalNameCollection_get_names(PyObject *self, PyObject *) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalNameCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_names)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_InternalNameCollection_get_name_530(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_InternalNameCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InternalNameCollection) {
    printf("InternalNameCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InternalNameCollection *local_this = (InternalNameCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InternalNameCollection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InternalNameCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InternalNameCollection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MaterialCollection
 */
/**
 * Python function wrapper for:
 * void MaterialCollection::operator =(MaterialCollection const &copy)
 */
static PyObject *Dtool_MaterialCollection_operator_540(PyObject *self, PyObject *arg) {
  MaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MaterialCollection, (void **)&local_this, "MaterialCollection.assign")) {
    return nullptr;
  }
  // 1-void MaterialCollection::operator =(MaterialCollection const &copy)
  MaterialCollection const *arg_this = (MaterialCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MaterialCollection, 1, "MaterialCollection.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    MaterialCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MaterialCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const MaterialCollection self, const MaterialCollection copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_operator_540_comment =
  "C++ Interface:\n"
  "assign(const MaterialCollection self, const MaterialCollection copy)\n";
#else
static const char *Dtool_MaterialCollection_operator_540_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void MaterialCollection::add_material(Material *node_material)
 */
static PyObject *Dtool_MaterialCollection_add_material_542(PyObject *self, PyObject *arg) {
  MaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MaterialCollection, (void **)&local_this, "MaterialCollection.add_material")) {
    return nullptr;
  }
  // 1-void MaterialCollection::add_material(Material *node_material)
  Material *arg_this = (Material *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Material, 1, "MaterialCollection.add_material", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_material)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_material(const MaterialCollection self, Material node_material)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_add_material_542_comment =
  "C++ Interface:\n"
  "add_material(const MaterialCollection self, Material node_material)\n"
  "\n"
  "/**\n"
  " * Adds a new Material to the collection.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_add_material_542_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool MaterialCollection::remove_material(Material *node_material)
 */
static PyObject *Dtool_MaterialCollection_remove_material_543(PyObject *self, PyObject *arg) {
  MaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MaterialCollection, (void **)&local_this, "MaterialCollection.remove_material")) {
    return nullptr;
  }
  // 1-bool MaterialCollection::remove_material(Material *node_material)
  Material *arg_this = (Material *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Material, 1, "MaterialCollection.remove_material", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_material)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_material(const MaterialCollection self, Material node_material)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_remove_material_543_comment =
  "C++ Interface:\n"
  "remove_material(const MaterialCollection self, Material node_material)\n"
  "\n"
  "/**\n"
  " * Removes the indicated Material from the collection.  Returns true if the\n"
  " * material was removed, false if it was not a member of the collection.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_remove_material_543_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void MaterialCollection::add_materials_from(MaterialCollection const &other)
 */
static PyObject *Dtool_MaterialCollection_add_materials_from_544(PyObject *self, PyObject *arg) {
  MaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MaterialCollection, (void **)&local_this, "MaterialCollection.add_materials_from")) {
    return nullptr;
  }
  // 1-void MaterialCollection::add_materials_from(MaterialCollection const &other)
  MaterialCollection const *arg_this = (MaterialCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MaterialCollection, 1, "MaterialCollection.add_materials_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_materials_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_materials_from(const MaterialCollection self, const MaterialCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_add_materials_from_544_comment =
  "C++ Interface:\n"
  "add_materials_from(const MaterialCollection self, const MaterialCollection other)\n"
  "\n"
  "/**\n"
  " * Adds all the Materials indicated in the other collection to this material.\n"
  " * The other materials are simply appended to the end of the materials in this\n"
  " * list; duplicates are not automatically removed.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_add_materials_from_544_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void MaterialCollection::remove_materials_from(MaterialCollection const &other)
 */
static PyObject *Dtool_MaterialCollection_remove_materials_from_545(PyObject *self, PyObject *arg) {
  MaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MaterialCollection, (void **)&local_this, "MaterialCollection.remove_materials_from")) {
    return nullptr;
  }
  // 1-void MaterialCollection::remove_materials_from(MaterialCollection const &other)
  MaterialCollection const *arg_this = (MaterialCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MaterialCollection, 1, "MaterialCollection.remove_materials_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_materials_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_materials_from(const MaterialCollection self, const MaterialCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_remove_materials_from_545_comment =
  "C++ Interface:\n"
  "remove_materials_from(const MaterialCollection self, const MaterialCollection other)\n"
  "\n"
  "/**\n"
  " * Removes from this collection all of the Materials listed in the other\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_remove_materials_from_545_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void MaterialCollection::remove_duplicate_materials(void)
 */
static PyObject *Dtool_MaterialCollection_remove_duplicate_materials_546(PyObject *self, PyObject *) {
  MaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MaterialCollection, (void **)&local_this, "MaterialCollection.remove_duplicate_materials")) {
    return nullptr;
  }
  // 1-void MaterialCollection::remove_duplicate_materials(void)
  ((*local_this).remove_duplicate_materials)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_remove_duplicate_materials_546_comment =
  "C++ Interface:\n"
  "remove_duplicate_materials(const MaterialCollection self)\n"
  "\n"
  "/**\n"
  " * Removes any duplicate entries of the same Materials on this collection.  If\n"
  " * a Material appears multiple times, the first appearance is retained;\n"
  " * subsequent appearances are removed.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_remove_duplicate_materials_546_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool MaterialCollection::has_material(Material *material) const
 */
static PyObject *Dtool_MaterialCollection_has_material_547(PyObject *self, PyObject *arg) {
  MaterialCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MaterialCollection)) {
    return nullptr;
  }
  // 1-bool MaterialCollection::has_material(Material *material) const
  Material *arg_this = (Material *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Material, 1, "MaterialCollection.has_material", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const MaterialCollection*)local_this).has_material)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_material(MaterialCollection self, Material material)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_has_material_547_comment =
  "C++ Interface:\n"
  "has_material(MaterialCollection self, Material material)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated Material appears in this collection, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_has_material_547_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void MaterialCollection::clear(void)
 */
static PyObject *Dtool_MaterialCollection_clear_548(PyObject *self, PyObject *) {
  MaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MaterialCollection, (void **)&local_this, "MaterialCollection.clear")) {
    return nullptr;
  }
  // 1-void MaterialCollection::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_clear_548_comment =
  "C++ Interface:\n"
  "clear(const MaterialCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all Materials from the collection.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_clear_548_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Material *MaterialCollection::find_material(std::string const &name) const
 */
static PyObject *Dtool_MaterialCollection_find_material_549(PyObject *self, PyObject *arg) {
  MaterialCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MaterialCollection)) {
    return nullptr;
  }
  // 1-Material *MaterialCollection::find_material(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    Material *return_value = ((*(const MaterialCollection*)local_this).find_material)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Material, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_material(MaterialCollection self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_find_material_549_comment =
  "C++ Interface:\n"
  "find_material(MaterialCollection self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the material in the collection with the indicated name, if any, or\n"
  " * NULL if no material has that name.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_find_material_549_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int MaterialCollection::get_num_materials(void) const
 */
static PyObject *Dtool_MaterialCollection_get_num_materials_550(PyObject *self, PyObject *) {
  MaterialCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MaterialCollection)) {
    return nullptr;
  }
  // 1-int MaterialCollection::get_num_materials(void) const
  int return_value = ((*(const MaterialCollection*)local_this).get_num_materials)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_get_num_materials_550_comment =
  "C++ Interface:\n"
  "get_num_materials(MaterialCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of Materials in the collection.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_get_num_materials_550_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Material *MaterialCollection::get_material(int index) const
 */
static PyObject *Dtool_MaterialCollection_get_material_551(PyObject *self, PyObject *arg) {
  MaterialCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MaterialCollection)) {
    return nullptr;
  }
  // 1-Material *MaterialCollection::get_material(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Material *return_value = ((*(const MaterialCollection*)local_this).get_material)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Material, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_material(MaterialCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_get_material_551_comment =
  "C++ Interface:\n"
  "get_material(MaterialCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth Material in the collection.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_get_material_551_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void MaterialCollection::output(std::ostream &out) const
 */
static PyObject *Dtool_MaterialCollection_output_556(PyObject *self, PyObject *arg) {
  MaterialCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MaterialCollection)) {
    return nullptr;
  }
  // 1-void MaterialCollection::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "MaterialCollection.output", false, true);
  if (arg_this != nullptr) {
    ((*(const MaterialCollection*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(MaterialCollection self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_output_556_comment =
  "C++ Interface:\n"
  "output(MaterialCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the MaterialCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_output_556_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void MaterialCollection::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_MaterialCollection_write_557(PyObject *self, PyObject *args, PyObject *kwds) {
  MaterialCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MaterialCollection)) {
    return nullptr;
  }
  // 1-void MaterialCollection::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "MaterialCollection.write", false, true);
    if (param1_this != nullptr) {
      ((*(const MaterialCollection*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(MaterialCollection self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialCollection_write_557_comment =
  "C++ Interface:\n"
  "write(MaterialCollection self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the MaterialCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_MaterialCollection_write_557_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * MaterialCollection::MaterialCollection(void)
 * MaterialCollection::MaterialCollection(MaterialCollection const &copy)
 */
static int Dtool_Init_MaterialCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-MaterialCollection::MaterialCollection(void)
      MaterialCollection *return_value = new MaterialCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MaterialCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-MaterialCollection::MaterialCollection(MaterialCollection const &copy)
        MaterialCollection const *arg_this = (MaterialCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MaterialCollection, 0, "MaterialCollection.MaterialCollection", true, true);
        if (arg_this != nullptr) {
          MaterialCollection *return_value = new MaterialCollection(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MaterialCollection, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MaterialCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MaterialCollection()\n"
      "MaterialCollection(const MaterialCollection copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MaterialCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MaterialCollection) {
    printf("MaterialCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MaterialCollection *local_this = (MaterialCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MaterialCollection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MaterialCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MaterialCollection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextureStageCollection
 */
/**
 * Python function wrapper for:
 * void TextureStageCollection::operator =(TextureStageCollection const &copy)
 */
static PyObject *Dtool_TextureStageCollection_operator_560(PyObject *self, PyObject *arg) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStageCollection, (void **)&local_this, "TextureStageCollection.assign")) {
    return nullptr;
  }
  // 1-void TextureStageCollection::operator =(TextureStageCollection const &copy)
  TextureStageCollection const *arg_this = (TextureStageCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStageCollection, 1, "TextureStageCollection.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    TextureStageCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureStageCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TextureStageCollection self, const TextureStageCollection copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_operator_560_comment =
  "C++ Interface:\n"
  "assign(const TextureStageCollection self, const TextureStageCollection copy)\n";
#else
static const char *Dtool_TextureStageCollection_operator_560_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureStageCollection::add_texture_stage(TextureStage *node_texture_stage)
 */
static PyObject *Dtool_TextureStageCollection_add_texture_stage_562(PyObject *self, PyObject *arg) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStageCollection, (void **)&local_this, "TextureStageCollection.add_texture_stage")) {
    return nullptr;
  }
  // 1-void TextureStageCollection::add_texture_stage(TextureStage *node_texture_stage)
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureStageCollection.add_texture_stage", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_texture_stage)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_texture_stage(const TextureStageCollection self, TextureStage node_texture_stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_add_texture_stage_562_comment =
  "C++ Interface:\n"
  "add_texture_stage(const TextureStageCollection self, TextureStage node_texture_stage)\n"
  "\n"
  "/**\n"
  " * Adds a new TextureStage to the collection.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_add_texture_stage_562_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextureStageCollection::remove_texture_stage(TextureStage *node_texture_stage)
 */
static PyObject *Dtool_TextureStageCollection_remove_texture_stage_563(PyObject *self, PyObject *arg) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStageCollection, (void **)&local_this, "TextureStageCollection.remove_texture_stage")) {
    return nullptr;
  }
  // 1-bool TextureStageCollection::remove_texture_stage(TextureStage *node_texture_stage)
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureStageCollection.remove_texture_stage", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_texture_stage)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_texture_stage(const TextureStageCollection self, TextureStage node_texture_stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_remove_texture_stage_563_comment =
  "C++ Interface:\n"
  "remove_texture_stage(const TextureStageCollection self, TextureStage node_texture_stage)\n"
  "\n"
  "/**\n"
  " * Removes the indicated TextureStage from the collection.  Returns true if\n"
  " * the texture_stage was removed, false if it was not a member of the\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_remove_texture_stage_563_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureStageCollection::add_texture_stages_from(TextureStageCollection const &other)
 */
static PyObject *Dtool_TextureStageCollection_add_texture_stages_from_564(PyObject *self, PyObject *arg) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStageCollection, (void **)&local_this, "TextureStageCollection.add_texture_stages_from")) {
    return nullptr;
  }
  // 1-void TextureStageCollection::add_texture_stages_from(TextureStageCollection const &other)
  TextureStageCollection const *arg_this = (TextureStageCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStageCollection, 1, "TextureStageCollection.add_texture_stages_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_texture_stages_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_texture_stages_from(const TextureStageCollection self, const TextureStageCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_add_texture_stages_from_564_comment =
  "C++ Interface:\n"
  "add_texture_stages_from(const TextureStageCollection self, const TextureStageCollection other)\n"
  "\n"
  "/**\n"
  " * Adds all the TextureStages indicated in the other collection to this\n"
  " * texture_stage.  The other texture_stages are simply appended to the end of\n"
  " * the texture_stages in this list; duplicates are not automatically removed.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_add_texture_stages_from_564_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureStageCollection::remove_texture_stages_from(TextureStageCollection const &other)
 */
static PyObject *Dtool_TextureStageCollection_remove_texture_stages_from_565(PyObject *self, PyObject *arg) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStageCollection, (void **)&local_this, "TextureStageCollection.remove_texture_stages_from")) {
    return nullptr;
  }
  // 1-void TextureStageCollection::remove_texture_stages_from(TextureStageCollection const &other)
  TextureStageCollection const *arg_this = (TextureStageCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStageCollection, 1, "TextureStageCollection.remove_texture_stages_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_texture_stages_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_texture_stages_from(const TextureStageCollection self, const TextureStageCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_remove_texture_stages_from_565_comment =
  "C++ Interface:\n"
  "remove_texture_stages_from(const TextureStageCollection self, const TextureStageCollection other)\n"
  "\n"
  "/**\n"
  " * Removes from this collection all of the TextureStages listed in the other\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_remove_texture_stages_from_565_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureStageCollection::remove_duplicate_texture_stages(void)
 */
static PyObject *Dtool_TextureStageCollection_remove_duplicate_texture_stages_566(PyObject *self, PyObject *) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStageCollection, (void **)&local_this, "TextureStageCollection.remove_duplicate_texture_stages")) {
    return nullptr;
  }
  // 1-void TextureStageCollection::remove_duplicate_texture_stages(void)
  ((*local_this).remove_duplicate_texture_stages)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_remove_duplicate_texture_stages_566_comment =
  "C++ Interface:\n"
  "remove_duplicate_texture_stages(const TextureStageCollection self)\n"
  "\n"
  "/**\n"
  " * Removes any duplicate entries of the same TextureStages on this collection.\n"
  " * If a TextureStage appears multiple times, the first appearance is retained;\n"
  " * subsequent appearances are removed.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_remove_duplicate_texture_stages_566_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextureStageCollection::has_texture_stage(TextureStage *texture_stage) const
 */
static PyObject *Dtool_TextureStageCollection_has_texture_stage_567(PyObject *self, PyObject *arg) {
  TextureStageCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStageCollection)) {
    return nullptr;
  }
  // 1-bool TextureStageCollection::has_texture_stage(TextureStage *texture_stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureStageCollection.has_texture_stage", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const TextureStageCollection*)local_this).has_texture_stage)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_texture_stage(TextureStageCollection self, TextureStage texture_stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_has_texture_stage_567_comment =
  "C++ Interface:\n"
  "has_texture_stage(TextureStageCollection self, TextureStage texture_stage)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated TextureStage appears in this collection,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_has_texture_stage_567_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureStageCollection::clear(void)
 */
static PyObject *Dtool_TextureStageCollection_clear_568(PyObject *self, PyObject *) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStageCollection, (void **)&local_this, "TextureStageCollection.clear")) {
    return nullptr;
  }
  // 1-void TextureStageCollection::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_clear_568_comment =
  "C++ Interface:\n"
  "clear(const TextureStageCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all TextureStages from the collection.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_clear_568_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextureStage *TextureStageCollection::find_texture_stage(std::string const &name) const
 */
static PyObject *Dtool_TextureStageCollection_find_texture_stage_569(PyObject *self, PyObject *arg) {
  TextureStageCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStageCollection)) {
    return nullptr;
  }
  // 1-TextureStage *TextureStageCollection::find_texture_stage(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    TextureStage *return_value = ((*(const TextureStageCollection*)local_this).find_texture_stage)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_texture_stage(TextureStageCollection self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_find_texture_stage_569_comment =
  "C++ Interface:\n"
  "find_texture_stage(TextureStageCollection self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the texture_stage in the collection with the indicated name, if\n"
  " * any, or NULL if no texture_stage has that name.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_find_texture_stage_569_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TextureStageCollection::get_num_texture_stages(void) const
 */
static PyObject *Dtool_TextureStageCollection_get_num_texture_stages_570(PyObject *self, PyObject *) {
  TextureStageCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStageCollection)) {
    return nullptr;
  }
  // 1-int TextureStageCollection::get_num_texture_stages(void) const
  int return_value = ((*(const TextureStageCollection*)local_this).get_num_texture_stages)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_get_num_texture_stages_570_comment =
  "C++ Interface:\n"
  "get_num_texture_stages(TextureStageCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of TextureStages in the collection.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_get_num_texture_stages_570_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextureStage *TextureStageCollection::get_texture_stage(int index) const
 */
static PyObject *Dtool_TextureStageCollection_get_texture_stage_571(PyObject *self, PyObject *arg) {
  TextureStageCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStageCollection)) {
    return nullptr;
  }
  // 1-TextureStage *TextureStageCollection::get_texture_stage(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TextureStage *return_value = ((*(const TextureStageCollection*)local_this).get_texture_stage)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture_stage(TextureStageCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_get_texture_stage_571_comment =
  "C++ Interface:\n"
  "get_texture_stage(TextureStageCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth TextureStage in the collection.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_get_texture_stage_571_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureStageCollection::sort(void)
 */
static PyObject *Dtool_TextureStageCollection_sort_577(PyObject *self, PyObject *) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStageCollection, (void **)&local_this, "TextureStageCollection.sort")) {
    return nullptr;
  }
  // 1-void TextureStageCollection::sort(void)
  ((*local_this).sort)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_sort_577_comment =
  "C++ Interface:\n"
  "sort(const TextureStageCollection self)\n"
  "\n"
  "/**\n"
  " * Sorts the TextureStages in this collection into order by\n"
  " * TextureStage::sort(), from lowest to highest.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_sort_577_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureStageCollection::output(std::ostream &out) const
 */
static PyObject *Dtool_TextureStageCollection_output_578(PyObject *self, PyObject *arg) {
  TextureStageCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStageCollection)) {
    return nullptr;
  }
  // 1-void TextureStageCollection::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "TextureStageCollection.output", false, true);
  if (arg_this != nullptr) {
    ((*(const TextureStageCollection*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(TextureStageCollection self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_output_578_comment =
  "C++ Interface:\n"
  "output(TextureStageCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the TextureStageCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_output_578_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureStageCollection::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_TextureStageCollection_write_579(PyObject *self, PyObject *args, PyObject *kwds) {
  TextureStageCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStageCollection)) {
    return nullptr;
  }
  // 1-void TextureStageCollection::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "TextureStageCollection.write", false, true);
    if (param1_this != nullptr) {
      ((*(const TextureStageCollection*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TextureStageCollection self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStageCollection_write_579_comment =
  "C++ Interface:\n"
  "write(TextureStageCollection self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the TextureStageCollection to\n"
  " * the indicated output stream.\n"
  " */";
#else
static const char *Dtool_TextureStageCollection_write_579_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextureStageCollection::TextureStageCollection(void)
 * TextureStageCollection::TextureStageCollection(TextureStageCollection const &copy)
 */
static int Dtool_Init_TextureStageCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TextureStageCollection::TextureStageCollection(void)
      TextureStageCollection *return_value = new TextureStageCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureStageCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-TextureStageCollection::TextureStageCollection(TextureStageCollection const &copy)
        TextureStageCollection const *arg_this = (TextureStageCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStageCollection, 0, "TextureStageCollection.TextureStageCollection", true, true);
        if (arg_this != nullptr) {
          TextureStageCollection *return_value = new TextureStageCollection(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureStageCollection, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextureStageCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextureStageCollection()\n"
      "TextureStageCollection(const TextureStageCollection copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TextureStageCollection_get_texture_stages(PyObject *self, PyObject *) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStageCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_texture_stages)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TextureStageCollection_get_texture_stage_571(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_TextureStageCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextureStageCollection) {
    printf("TextureStageCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextureStageCollection *local_this = (TextureStageCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextureStageCollection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextureStageCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextureStageCollection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NodePath
 */
/**
 * Python function wrapper for:
 * static inline NodePath NodePath::any_path(PandaNode *node, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_any_path_583(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline NodePath NodePath::any_path(PandaNode *node, Thread *current_thread = Thread::get_current_thread())
  PyObject *param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"node", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:any_path", (char **)keyword_list, &param0, &param1)) {
    PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "NodePath.any_path", false, true);
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.any_path", false, true);
    }
    if (param0_this != nullptr && (param1 == nullptr || param1_this != nullptr)) {
      NodePath *return_value = new NodePath((NodePath::any_path)(param0_this, param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "any_path(PandaNode node, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_any_path_583_comment =
  "C++ Interface:\n"
  "any_path(PandaNode node, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a new NodePath that represents any arbitrary path from the root to\n"
  " * the indicated node.  This is the same thing that would be returned by\n"
  " * NodePath(node), except that no warning is issued if the path is ambiguous.\n"
  " */";
#else
static const char *Dtool_NodePath_any_path_583_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Rejected Remap [inline void NodePath::operator =(NodePath &&from) noexcept]
 * inline void NodePath::operator =(NodePath const &copy)
 */
static PyObject *Dtool_NodePath_operator_584(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.assign")) {
    return nullptr;
  }
  // 1-inline void NodePath::operator =(NodePath const &copy)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    NodePath *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const NodePath self, const NodePath copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_operator_584_comment =
  "C++ Interface:\n"
  "assign(const NodePath self, const NodePath copy)\n";
#else
static const char *Dtool_NodePath_operator_584_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::clear(void)
 */
static PyObject *Dtool_NodePath_clear_585(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear")) {
    return nullptr;
  }
  // 1-inline void NodePath::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_585_comment =
  "C++ Interface:\n"
  "clear(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Sets this NodePath to the empty NodePath.  It will no longer point to any\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_585_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::__copy__(void) const
 */
static PyObject *Dtool_NodePath_copy_586(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::__copy__(void) const
  NodePath *return_value = new NodePath(invoke_extension((const NodePath*)local_this).__copy__());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_copy_586_comment =
  "C++ Interface:\n"
  "__copy__(NodePath self)\n";
#else
static const char *Dtool_NodePath_copy_586_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *NodePath::__deepcopy__(PyObject *self, PyObject *memo) const
 */
static PyObject *Dtool_NodePath_deepcopy_587(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-PyObject *NodePath::__deepcopy__(PyObject *self, PyObject *memo) const
  PyObject *return_value = invoke_extension((const NodePath*)local_this).__deepcopy__(self, arg);
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__deepcopy__(NodePath self, object memo)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_deepcopy_587_comment =
  "C++ Interface:\n"
  "__deepcopy__(NodePath self, object memo)\n";
#else
static const char *Dtool_NodePath_deepcopy_587_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *NodePath::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_NodePath_reduce_588(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-PyObject *NodePath::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const NodePath*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_reduce_588_comment =
  "C++ Interface:\n"
  "__reduce__(NodePath self)\n";
#else
static const char *Dtool_NodePath_reduce_588_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *NodePath::__reduce_persist__(PyObject *self, PyObject *pickler) const
 */
static PyObject *Dtool_NodePath_reduce_persist_589(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-PyObject *NodePath::__reduce_persist__(PyObject *self, PyObject *pickler) const
  PyObject *return_value = invoke_extension((const NodePath*)local_this).__reduce_persist__(self, arg);
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__reduce_persist__(NodePath self, object pickler)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_reduce_persist_589_comment =
  "C++ Interface:\n"
  "__reduce_persist__(NodePath self, object pickler)\n";
#else
static const char *Dtool_NodePath_reduce_persist_589_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline NodePath NodePath::not_found(void)
 */
static PyObject *Dtool_NodePath_not_found_590(PyObject *, PyObject *) {
  // 1-static inline NodePath NodePath::not_found(void)
  NodePath *return_value = new NodePath((NodePath::not_found)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_not_found_590_comment =
  "C++ Interface:\n"
  "not_found()\n"
  "\n"
  "/**\n"
  " * Creates a NodePath with the ET_not_found error type set.\n"
  " */";
#else
static const char *Dtool_NodePath_not_found_590_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline NodePath NodePath::removed(void)
 */
static PyObject *Dtool_NodePath_removed_591(PyObject *, PyObject *) {
  // 1-static inline NodePath NodePath::removed(void)
  NodePath *return_value = new NodePath((NodePath::removed)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_removed_591_comment =
  "C++ Interface:\n"
  "removed()\n"
  "\n"
  "/**\n"
  " * Creates a NodePath with the ET_removed error type set.\n"
  " */";
#else
static const char *Dtool_NodePath_removed_591_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline NodePath NodePath::fail(void)
 */
static PyObject *Dtool_NodePath_fail_592(PyObject *, PyObject *) {
  // 1-static inline NodePath NodePath::fail(void)
  NodePath *return_value = new NodePath((NodePath::fail)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_fail_592_comment =
  "C++ Interface:\n"
  "fail()\n"
  "\n"
  "/**\n"
  " * Creates a NodePath with the ET_fail error type set.\n"
  " */";
#else
static const char *Dtool_NodePath_fail_592_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void NodePath::set_max_search_depth(int max_search_depth)
 */
static PyObject *Dtool_NodePath_set_max_search_depth_593(PyObject *, PyObject *arg) {
  // 1-static inline void NodePath::set_max_search_depth(int max_search_depth)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (NodePath::set_max_search_depth)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_search_depth(int max_search_depth)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_max_search_depth_593_comment =
  "C++ Interface:\n"
  "set_max_search_depth(int max_search_depth)\n"
  "\n"
  "/**\n"
  " * Certain operations, such as find() or find_all_matches(), require a\n"
  " * traversal of the scene graph to search for the target node or nodes.  This\n"
  " * traversal does not attempt to detect cycles, so an arbitrary cap is set on\n"
  " * the depth of the traversal as a poor man's cycle detection, in the event\n"
  " * that a cycle has inadvertently been introduced into the scene graph.\n"
  " *\n"
  " * There may be other reasons you'd want to truncate a search before the\n"
  " * bottom of the scene graph has been reached.  In any event, this function\n"
  " * sets the limit on the number of levels that a traversal will continue, and\n"
  " * hence the maximum length of a path that may be returned by a traversal.\n"
  " *\n"
  " * This is a static method, and so changing this parameter affects all of the\n"
  " * NodePaths in the universe.\n"
  " */";
#else
static const char *Dtool_NodePath_set_max_search_depth_593_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int NodePath::get_max_search_depth(void)
 */
static PyObject *Dtool_NodePath_get_max_search_depth_594(PyObject *, PyObject *) {
  // 1-static inline int NodePath::get_max_search_depth(void)
  int return_value = (NodePath::get_max_search_depth)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_max_search_depth_594_comment =
  "C++ Interface:\n"
  "get_max_search_depth()\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the search depth limit.  See\n"
  " * set_max_search_depth.\n"
  " */";
#else
static const char *Dtool_NodePath_get_max_search_depth_594_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::is_empty(void) const
 */
static PyObject *Dtool_NodePath_is_empty_595(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::is_empty(void) const
  bool return_value = ((*(const NodePath*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_is_empty_595_comment =
  "C++ Interface:\n"
  "is_empty(NodePath self)\n"
  "\n"
  "// Methods to query a NodePath's contents.\n"
  "\n"
  "/**\n"
  " * Returns true if the NodePath contains no nodes.\n"
  " */";
#else
static const char *Dtool_NodePath_is_empty_595_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::is_singleton(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_is_singleton_597(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::is_singleton(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.is_singleton", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      bool return_value = ((*(const NodePath*)local_this).is_singleton)(param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_singleton(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_is_singleton_597_comment =
  "C++ Interface:\n"
  "is_singleton(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns true if the NodePath contains exactly one node.\n"
  " */";
#else
static const char *Dtool_NodePath_is_singleton_597_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int NodePath::get_num_nodes(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_num_nodes_598(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-int NodePath::get_num_nodes(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_num_nodes", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*(const NodePath*)local_this).get_num_nodes)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_nodes(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_num_nodes_598_comment =
  "C++ Interface:\n"
  "get_num_nodes(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the number of nodes in the path.\n"
  " */";
#else
static const char *Dtool_NodePath_get_num_nodes_598_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PandaNode *NodePath::get_node(int index, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_node_599(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-PandaNode *NodePath::get_node(int index, Thread *current_thread = Thread::get_current_thread()) const
  int param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"index", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:get_node", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.get_node", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      PandaNode *return_value = ((*(const NodePath*)local_this).get_node)((int)param1, param2_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(NodePath self, int index, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_node_599_comment =
  "C++ Interface:\n"
  "get_node(NodePath self, int index, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the nth node of the path, where 0 is the referenced (bottom) node\n"
  " * and get_num_nodes() - 1 is the top node.  This requires iterating through\n"
  " * the path.\n"
  " *\n"
  " * Also see node(), which is a convenience function to return the same thing\n"
  " * as get_node(0) (since the bottom node is the most important node in the\n"
  " * NodePath, and is the one most frequently referenced).\n"
  " *\n"
  " * Note that this function returns the same thing as\n"
  " * get_ancestor(index).node().\n"
  " */";
#else
static const char *Dtool_NodePath_get_node_599_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::get_ancestor(int index, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_ancestor_603(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::get_ancestor(int index, Thread *current_thread = Thread::get_current_thread()) const
  int param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"index", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:get_ancestor", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.get_ancestor", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      NodePath *return_value = new NodePath(((*(const NodePath*)local_this).get_ancestor)((int)param1, param2_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ancestor(NodePath self, int index, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_ancestor_603_comment =
  "C++ Interface:\n"
  "get_ancestor(NodePath self, int index, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the nth ancestor of the path, where 0 is the NodePath itself and\n"
  " * get_num_nodes() - 1 is get_top(). This requires iterating through the path.\n"
  " *\n"
  " * Also see get_node(), which returns the same thing as a PandaNode pointer,\n"
  " * not a NodePath.\n"
  " */";
#else
static const char *Dtool_NodePath_get_ancestor_603_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath::ErrorType NodePath::get_error_type(void) const
 */
static PyObject *Dtool_NodePath_get_error_type_606(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline NodePath::ErrorType NodePath::get_error_type(void) const
  NodePath::ErrorType return_value = ((*(const NodePath*)local_this).get_error_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_error_type_606_comment =
  "C++ Interface:\n"
  "get_error_type(NodePath self)\n"
  "\n"
  "/**\n"
  " * If is_empty() is true, this returns a code that represents the reason why\n"
  " * the NodePath is empty.\n"
  " */";
#else
static const char *Dtool_NodePath_get_error_type_606_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *NodePath::get_top_node(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_top_node_608(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline PandaNode *NodePath::get_top_node(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_top_node", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      PandaNode *return_value = ((*(const NodePath*)local_this).get_top_node)(param1_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_top_node(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_top_node_608_comment =
  "C++ Interface:\n"
  "get_top_node(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the top node of the path, or NULL if the path is empty.  This\n"
  " * requires iterating through the path.\n"
  " */";
#else
static const char *Dtool_NodePath_get_top_node_608_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::get_top(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_top_609(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::get_top(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_top", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      NodePath *return_value = new NodePath(((*(const NodePath*)local_this).get_top)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_top(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_top_609_comment =
  "C++ Interface:\n"
  "get_top(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a singleton NodePath that represents the top of the path, or empty\n"
  " * NodePath if this path is empty.\n"
  " */";
#else
static const char *Dtool_NodePath_get_top_609_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *NodePath::node(void) const
 */
static PyObject *Dtool_NodePath_node_610(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline PandaNode *NodePath::node(void) const
  PandaNode *return_value = ((*(const NodePath*)local_this).node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NodePath_node_610_comment =
  "C++ Interface:\n"
  "node(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the referenced node of the path.\n"
  " */";
#else
static const char *Dtool_NodePath_node_610_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NodePath::get_key(void) const
 */
static PyObject *Dtool_NodePath_get_key_611(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline int NodePath::get_key(void) const
  int return_value = ((*(const NodePath*)local_this).get_key)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_key_611_comment =
  "C++ Interface:\n"
  "get_key(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns an integer that is guaranteed to be the same for all NodePaths that\n"
  " * represent the same node instance, and different for all NodePaths that\n"
  " * represent a different node instance.\n"
  " *\n"
  " * The same key will be returned for a particular instance as long as at least\n"
  " * one NodePath exists that represents that instance; if all NodePaths for a\n"
  " * particular instance destruct and a new one is later created, it may have a\n"
  " * different index.  However, a given key will never be reused for a different\n"
  " * instance (unless the app has been running long enough that we overflow the\n"
  " * integer key value).\n"
  " */";
#else
static const char *Dtool_NodePath_get_key_611_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t NodePath::add_hash(std::size_t hash) const
 */
static PyObject *Dtool_NodePath_add_hash_612(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline std::size_t NodePath::add_hash(std::size_t hash) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::size_t return_value = ((*(const NodePath*)local_this).add_hash)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(NodePath self, int hash)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_add_hash_612_comment =
  "C++ Interface:\n"
  "add_hash(NodePath self, int hash)\n"
  "\n"
  "/**\n"
  " * Adds the NodePath into the running hash.  This is intended to be used by\n"
  " * lower-level code that computes a hash for each NodePath.  It modifies the\n"
  " * hash value passed in by a unique adjustment for each NodePath, and returns\n"
  " * the modified hash.\n"
  " *\n"
  " * This is similar to the unique integer returned by get_key(), but it is not\n"
  " * guaranteed to remain unique beyond the lifetime of this particular\n"
  " * NodePath.  Once this NodePath destructs, a different NodePath may be\n"
  " * created which shares the same hash value.\n"
  " */";
#else
static const char *Dtool_NodePath_add_hash_612_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::is_same_graph(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_is_same_graph_613(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::is_same_graph(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"other", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:is_same_graph", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.is_same_graph", true, true);
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.is_same_graph", false, true);
    }
    if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
      bool return_value = ((*(const NodePath*)local_this).is_same_graph)(*param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_same_graph(NodePath self, const NodePath other, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_is_same_graph_613_comment =
  "C++ Interface:\n"
  "is_same_graph(NodePath self, const NodePath other, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns true if the node represented by this NodePath is parented within\n"
  " * the same graph as that of the other NodePath.  This is essentially the same\n"
  " * thing as asking whether get_top() of both NodePaths is the same (e.g., both\n"
  " * \"render\").\n"
  " */";
#else
static const char *Dtool_NodePath_is_same_graph_613_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::is_ancestor_of(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_is_ancestor_of_614(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::is_ancestor_of(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"other", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:is_ancestor_of", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.is_ancestor_of", true, true);
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.is_ancestor_of", false, true);
    }
    if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
      bool return_value = ((*(const NodePath*)local_this).is_ancestor_of)(*param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_ancestor_of(NodePath self, const NodePath other, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_is_ancestor_of_614_comment =
  "C++ Interface:\n"
  "is_ancestor_of(NodePath self, const NodePath other, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns true if the node represented by this NodePath is a parent or other\n"
  " * ancestor of the other NodePath, or false if it is not.\n"
  " */";
#else
static const char *Dtool_NodePath_is_ancestor_of_614_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath NodePath::get_common_ancestor(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_common_ancestor_615(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline NodePath NodePath::get_common_ancestor(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"other", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:get_common_ancestor", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.get_common_ancestor", true, true);
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.get_common_ancestor", false, true);
    }
    if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
      NodePath *return_value = new NodePath(((*(const NodePath*)local_this).get_common_ancestor)(*param1_this, param2_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_common_ancestor(NodePath self, const NodePath other, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_common_ancestor_615_comment =
  "C++ Interface:\n"
  "get_common_ancestor(NodePath self, const NodePath other, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the lowest NodePath that both of these two NodePaths have in\n"
  " * common: the first ancestor that both of them share.  If the two NodePaths\n"
  " * are unrelated, returns NodePath::not_found().\n"
  " */";
#else
static const char *Dtool_NodePath_get_common_ancestor_615_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePathCollection NodePath::get_children(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_children_616(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePathCollection NodePath::get_children(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_children", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      NodePathCollection *return_value = new NodePathCollection(((*(const NodePath*)local_this).get_children)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_children(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_children_616_comment =
  "C++ Interface:\n"
  "get_children(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the set of all child nodes of the referenced node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_children_616_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NodePath::get_num_children(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_num_children_617(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline int NodePath::get_num_children(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_num_children", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*(const NodePath*)local_this).get_num_children)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_children(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_num_children_617_comment =
  "C++ Interface:\n"
  "get_num_children(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the number of children of the referenced node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_num_children_617_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath NodePath::get_child(int n, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_child_618(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline NodePath NodePath::get_child(int n, Thread *current_thread = Thread::get_current_thread()) const
  int param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"n", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:get_child", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.get_child", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      NodePath *return_value = new NodePath(((*(const NodePath*)local_this).get_child)((int)param1, param2_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(NodePath self, int n, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_child_618_comment =
  "C++ Interface:\n"
  "get_child(NodePath self, int n, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a NodePath representing the nth child of the referenced node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_child_618_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePathCollection NodePath::get_stashed_children(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_stashed_children_619(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePathCollection NodePath::get_stashed_children(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_stashed_children", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      NodePathCollection *return_value = new NodePathCollection(((*(const NodePath*)local_this).get_stashed_children)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_stashed_children(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_stashed_children_619_comment =
  "C++ Interface:\n"
  "get_stashed_children(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the set of all child nodes of the referenced node that have been\n"
  " * stashed.  These children are not normally visible on the node, and do not\n"
  " * appear in the list returned by get_children().\n"
  " */";
#else
static const char *Dtool_NodePath_get_stashed_children_619_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NodePath::count_num_descendants(void) const
 */
static PyObject *Dtool_NodePath_count_num_descendants_665(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline int NodePath::count_num_descendants(void) const
  int return_value = ((*(const NodePath*)local_this).count_num_descendants)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_count_num_descendants_665_comment =
  "C++ Interface:\n"
  "count_num_descendants(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the number of nodes at and below this level.\n"
  " */";
#else
static const char *Dtool_NodePath_count_num_descendants_665_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::has_parent(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_has_parent_666(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::has_parent(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.has_parent", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      bool return_value = ((*(const NodePath*)local_this).has_parent)(param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_parent(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_parent_666_comment =
  "C++ Interface:\n"
  "has_parent(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns true if the referenced node has a parent; i.e.  the NodePath chain\n"
  " * contains at least two nodes.\n"
  " */";
#else
static const char *Dtool_NodePath_has_parent_666_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath NodePath::get_parent(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_parent_667(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline NodePath NodePath::get_parent(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_parent", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      NodePath *return_value = new NodePath(((*(const NodePath*)local_this).get_parent)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_parent_667_comment =
  "C++ Interface:\n"
  "get_parent(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath to the parent of the referenced node: that is, this\n"
  " * NodePath, shortened by one node.  The parent of a singleton NodePath is\n"
  " * defined to be the empty NodePath.\n"
  " */";
#else
static const char *Dtool_NodePath_get_parent_667_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int NodePath::get_sort(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_sort_668(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-int NodePath::get_sort(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_sort", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*(const NodePath*)local_this).get_sort)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sort(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_sort_668_comment =
  "C++ Interface:\n"
  "get_sort(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the sort value of the referenced node within its parent; that is,\n"
  " * the sort number passed on the last reparenting operation for this node.\n"
  " * This will control the position of the node within its parent's list of\n"
  " * children.\n"
  " */";
#else
static const char *Dtool_NodePath_get_sort_668_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::find(std::string const &path) const
 */
static PyObject *Dtool_NodePath_find_671(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::find(std::string const &path) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    NodePath *return_value = new NodePath(((*(const NodePath*)local_this).find)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find(NodePath self, str path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_671_comment =
  "C++ Interface:\n"
  "find(NodePath self, str path)\n"
  "\n"
  "/**\n"
  " * Searches for a node below the referenced node that matches the indicated\n"
  " * string.  Returns the shortest match found, if any, or an empty NodePath if\n"
  " * no match can be found.\n"
  " */";
#else
static const char *Dtool_NodePath_find_671_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::find_path_to(PandaNode *node) const
 */
static PyObject *Dtool_NodePath_find_path_to_672(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::find_path_to(PandaNode *node) const
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "NodePath.find_path_to", false, true);
  if (arg_this != nullptr) {
    NodePath *return_value = new NodePath(((*(const NodePath*)local_this).find_path_to)(arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_path_to(NodePath self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_path_to_672_comment =
  "C++ Interface:\n"
  "find_path_to(NodePath self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Searches for the indicated node below this node and returns the shortest\n"
  " * NodePath that connects them.\n"
  " */";
#else
static const char *Dtool_NodePath_find_path_to_672_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePathCollection NodePath::find_all_matches(std::string const &path) const
 */
static PyObject *Dtool_NodePath_find_all_matches_673(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePathCollection NodePath::find_all_matches(std::string const &path) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    NodePathCollection *return_value = new NodePathCollection(((*(const NodePath*)local_this).find_all_matches)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_matches(NodePath self, str path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_all_matches_673_comment =
  "C++ Interface:\n"
  "find_all_matches(NodePath self, str path)\n"
  "\n"
  "/**\n"
  " * Returns the complete set of all NodePaths that begin with this NodePath and\n"
  " * can be extended by path.  The shortest paths will be listed first.\n"
  " */";
#else
static const char *Dtool_NodePath_find_all_matches_673_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePathCollection NodePath::find_all_paths_to(PandaNode *node) const
 */
static PyObject *Dtool_NodePath_find_all_paths_to_674(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePathCollection NodePath::find_all_paths_to(PandaNode *node) const
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "NodePath.find_all_paths_to", false, true);
  if (arg_this != nullptr) {
    NodePathCollection *return_value = new NodePathCollection(((*(const NodePath*)local_this).find_all_paths_to)(arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_paths_to(NodePath self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_all_paths_to_674_comment =
  "C++ Interface:\n"
  "find_all_paths_to(NodePath self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Returns the set of all NodePaths that extend from this NodePath down to the\n"
  " * indicated node.  The shortest paths will be listed first.\n"
  " */";
#else
static const char *Dtool_NodePath_find_all_paths_to_674_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::reparent_to(NodePath const &other, int sort = 0, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_reparent_to_675(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.reparent_to")) {
    return nullptr;
  }
  // 1-void NodePath::reparent_to(NodePath const &other, int sort = 0, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  int param2 = 0;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"other", "sort", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|iO:reparent_to", (char **)keyword_list, &param1, &param2, &param3)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.reparent_to", true, true);
    Thread *param3_this;
    if (param3 == nullptr) {
      param3_this = Thread::get_current_thread();
    } else {
      param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "NodePath.reparent_to", false, true);
    }
    if (param1_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
      ((*local_this).reparent_to)(*param1_this, (int)param2, param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reparent_to(const NodePath self, const NodePath other, int sort, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_reparent_to_675_comment =
  "C++ Interface:\n"
  "reparent_to(const NodePath self, const NodePath other, int sort, Thread current_thread)\n"
  "\n"
  "// Methods that actually move nodes around in the scene graph.  The optional\n"
  "// \"sort\" parameter can be used to force a particular ordering between\n"
  "// sibling nodes, useful when dealing with LOD's and similar switch nodes.\n"
  "// If the sort value is the same, nodes will be arranged in the order they\n"
  "// were added.\n"
  "\n"
  "/**\n"
  " * Removes the referenced node of the NodePath from its current parent and\n"
  " * attaches it to the referenced node of the indicated NodePath.\n"
  " *\n"
  " * If the destination NodePath is empty, this is the same thing as\n"
  " * detach_node().\n"
  " *\n"
  " * If the referenced node is already a child of the indicated NodePath (via\n"
  " * some other instance), this operation fails and leaves the NodePath\n"
  " * detached.\n"
  " */";
#else
static const char *Dtool_NodePath_reparent_to_675_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::stash_to(NodePath const &other, int sort = 0, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_stash_to_676(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.stash_to")) {
    return nullptr;
  }
  // 1-void NodePath::stash_to(NodePath const &other, int sort = 0, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  int param2 = 0;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"other", "sort", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|iO:stash_to", (char **)keyword_list, &param1, &param2, &param3)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.stash_to", true, true);
    Thread *param3_this;
    if (param3 == nullptr) {
      param3_this = Thread::get_current_thread();
    } else {
      param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "NodePath.stash_to", false, true);
    }
    if (param1_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
      ((*local_this).stash_to)(*param1_this, (int)param2, param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "stash_to(const NodePath self, const NodePath other, int sort, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_stash_to_676_comment =
  "C++ Interface:\n"
  "stash_to(const NodePath self, const NodePath other, int sort, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Similar to reparent_to(), but the node is added to its new parent's stashed\n"
  " * list, so that the result is equivalent to calling reparent_to() immediately\n"
  " * followed by stash().\n"
  " */";
#else
static const char *Dtool_NodePath_stash_to_676_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::wrt_reparent_to(NodePath const &other, int sort = 0, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_wrt_reparent_to_677(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.wrt_reparent_to")) {
    return nullptr;
  }
  // 1-void NodePath::wrt_reparent_to(NodePath const &other, int sort = 0, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  int param2 = 0;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"other", "sort", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|iO:wrt_reparent_to", (char **)keyword_list, &param1, &param2, &param3)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.wrt_reparent_to", true, true);
    Thread *param3_this;
    if (param3 == nullptr) {
      param3_this = Thread::get_current_thread();
    } else {
      param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "NodePath.wrt_reparent_to", false, true);
    }
    if (param1_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
      ((*local_this).wrt_reparent_to)(*param1_this, (int)param2, param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wrt_reparent_to(const NodePath self, const NodePath other, int sort, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_wrt_reparent_to_677_comment =
  "C++ Interface:\n"
  "wrt_reparent_to(const NodePath self, const NodePath other, int sort, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * This functions identically to reparent_to(), except the transform on this\n"
  " * node is also adjusted so that the node remains in the same place in world\n"
  " * coordinates, even if it is reparented into a different coordinate system.\n"
  " */";
#else
static const char *Dtool_NodePath_wrt_reparent_to_677_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::instance_to(NodePath const &other, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_instance_to_678(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::instance_to(NodePath const &other, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1;
  int param2 = 0;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"other", "sort", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|iO:instance_to", (char **)keyword_list, &param1, &param2, &param3)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.instance_to", true, true);
    Thread *param3_this;
    if (param3 == nullptr) {
      param3_this = Thread::get_current_thread();
    } else {
      param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "NodePath.instance_to", false, true);
    }
    if (param1_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
      NodePath *return_value = new NodePath(((*(const NodePath*)local_this).instance_to)(*param1_this, (int)param2, param3_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "instance_to(NodePath self, const NodePath other, int sort, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_instance_to_678_comment =
  "C++ Interface:\n"
  "instance_to(NodePath self, const NodePath other, int sort, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Adds the referenced node of the NodePath as a child of the referenced node\n"
  " * of the indicated other NodePath.  Any other parent-child relations of the\n"
  " * node are unchanged; in particular, the node is not removed from its\n"
  " * existing parent, if any.\n"
  " *\n"
  " * If the node already had an existing parent, this method will create a new\n"
  " * instance of the node within the scene graph.\n"
  " *\n"
  " * This does not change the NodePath itself, but does return a new NodePath\n"
  " * that reflects the new instance node.\n"
  " *\n"
  " * If the destination NodePath is empty, this creates a new instance which is\n"
  " * not yet parented to any node.  A new instance of this sort cannot easily be\n"
  " * differentiated from other similar instances, but it is nevertheless a\n"
  " * different instance and it will return a different get_id() value.\n"
  " *\n"
  " * If the referenced node is already a child of the indicated NodePath,\n"
  " * returns that already-existing instance, unstashing it first if necessary.\n"
  " */";
#else
static const char *Dtool_NodePath_instance_to_678_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::instance_under_node(NodePath const &other, std::string const &name, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_instance_under_node_679(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::instance_under_node(NodePath const &other, std::string const &name, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  int param3 = 0;
  PyObject *param4 = nullptr;
  static const char *keyword_list[] = {"other", "name", "sort", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#|iO:instance_under_node", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.instance_under_node", true, true);
    Thread *param4_this;
    if (param4 == nullptr) {
      param4_this = Thread::get_current_thread();
    } else {
      param4_this = (Thread *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_Thread, 4, "NodePath.instance_under_node", false, true);
    }
    if (param1_this != nullptr && (param4 == nullptr || param4_this != nullptr)) {
      NodePath *return_value = new NodePath(((*(const NodePath*)local_this).instance_under_node)(*param1_this, std::string(param2_str, param2_len), (int)param3, param4_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "instance_under_node(NodePath self, const NodePath other, str name, int sort, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_instance_under_node_679_comment =
  "C++ Interface:\n"
  "instance_under_node(NodePath self, const NodePath other, str name, int sort, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Behaves like instance_to(), but implicitly creates a new node to instance\n"
  " * the geometry under, and returns a NodePath to that new node.  This allows\n"
  " * the programmer to set a unique state and/or transform on this instance.\n"
  " */";
#else
static const char *Dtool_NodePath_instance_under_node_679_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::copy_to(NodePath const &other, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_copy_to_680(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::copy_to(NodePath const &other, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1;
  int param2 = 0;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"other", "sort", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|iO:copy_to", (char **)keyword_list, &param1, &param2, &param3)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.copy_to", true, true);
    Thread *param3_this;
    if (param3 == nullptr) {
      param3_this = Thread::get_current_thread();
    } else {
      param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "NodePath.copy_to", false, true);
    }
    if (param1_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
      NodePath *return_value = new NodePath(((*(const NodePath*)local_this).copy_to)(*param1_this, (int)param2, param3_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_to(NodePath self, const NodePath other, int sort, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_copy_to_680_comment =
  "C++ Interface:\n"
  "copy_to(NodePath self, const NodePath other, int sort, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Functions like instance_to(), except a deep copy is made of the referenced\n"
  " * node and all of its descendents, which is then parented to the indicated\n"
  " * node.  A NodePath to the newly created copy is returned.\n"
  " */";
#else
static const char *Dtool_NodePath_copy_to_680_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::attach_new_node(PandaNode *node, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
 * inline NodePath NodePath::attach_new_node(std::string const &name, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_attach_new_node_681(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  {
    // -2 NodePath NodePath::attach_new_node(PandaNode *node, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
    PyObject *param1;
    int param2 = 0;
    PyObject *param3 = nullptr;
    static const char *keyword_list[] = {"node", "sort", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|iO:attach_new_node", (char **)keyword_list, &param1, &param2, &param3)) {
      PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "NodePath.attach_new_node", false, false);
      Thread *param3_this;
      if (param3 == nullptr) {
        param3_this = Thread::get_current_thread();
      } else {
        param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "NodePath.attach_new_node", false, false);
      }
      if (param1_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
        NodePath *return_value = new NodePath(((*(const NodePath*)local_this).attach_new_node)(param1_this, (int)param2, param3_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline NodePath NodePath::attach_new_node(std::string const &name, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    int param2 = 0;
    PyObject *param3 = nullptr;
    static const char *keyword_list[] = {"name", "sort", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|iO:attach_new_node", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
      Thread *param3_this;
      if (param3 == nullptr) {
        param3_this = Thread::get_current_thread();
      } else {
        param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "NodePath.attach_new_node", false, false);
      }
      if ((param3 == nullptr || param3_this != nullptr)) {
        NodePath *return_value = new NodePath(((*(const NodePath*)local_this).attach_new_node)(std::string(param1_str, param1_len), (int)param2, param3_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: NodePath NodePath::attach_new_node(PandaNode *node, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
  // No coercion possible: inline NodePath NodePath::attach_new_node(std::string const &name, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_new_node(NodePath self, PandaNode node, int sort, Thread current_thread)\n"
      "attach_new_node(NodePath self, str name, int sort, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_attach_new_node_681_comment =
  "C++ Interface:\n"
  "attach_new_node(NodePath self, PandaNode node, int sort, Thread current_thread)\n"
  "attach_new_node(NodePath self, str name, int sort, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Creates an ordinary PandaNode and attaches it below the current NodePath,\n"
  " * returning a new NodePath that references it.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Attaches a new node, with or without existing parents, to the scene graph\n"
  " * below the referenced node of this NodePath.  This is the preferred way to\n"
  " * add nodes to the graph.\n"
  " *\n"
  " * If the node was already a child of the parent, this returns a NodePath to\n"
  " * the existing child.\n"
  " *\n"
  " * This does *not* automatically extend the current NodePath to reflect the\n"
  " * attachment; however, a NodePath that does reflect this extension is\n"
  " * returned.\n"
  " */";
#else
static const char *Dtool_NodePath_attach_new_node_681_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::remove_node(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_remove_node_682(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.remove_node")) {
    return nullptr;
  }
  // 1-void NodePath::remove_node(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.remove_node", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).remove_node)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_node(const NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_remove_node_682_comment =
  "C++ Interface:\n"
  "remove_node(const NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Disconnects the referenced node from the scene graph.  This will also\n"
  " * delete the node if there are no other pointers to it.\n"
  " *\n"
  " * Normally, this should be called only when you are really done with the\n"
  " * node.  If you want to remove a node from the scene graph but keep it around\n"
  " * for later, you should probably use detach_node() instead.\n"
  " *\n"
  " * In practice, the only difference between remove_node() and detach_node() is\n"
  " * that remove_node() also resets the NodePath to empty, which will cause the\n"
  " * node to be deleted immediately if there are no other references.  On the\n"
  " * other hand, detach_node() leaves the NodePath referencing the node, which\n"
  " * will keep at least one reference to the node for as long as the NodePath\n"
  " * exists.\n"
  " */";
#else
static const char *Dtool_NodePath_remove_node_682_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::detach_node(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_detach_node_683(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.detach_node")) {
    return nullptr;
  }
  // 1-void NodePath::detach_node(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.detach_node", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).detach_node)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "detach_node(const NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_detach_node_683_comment =
  "C++ Interface:\n"
  "detach_node(const NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Disconnects the referenced node from its parent, but does not immediately\n"
  " * delete it.  The NodePath retains a pointer to the node, and becomes a\n"
  " * singleton NodePath.\n"
  " *\n"
  " * This should be called to detach a node from the scene graph, with the\n"
  " * option of reattaching it later to the same parent or to a different parent.\n"
  " *\n"
  " * In practice, the only difference between remove_node() and detach_node() is\n"
  " * that remove_node() also resets the NodePath to empty, which will cause the\n"
  " * node to be deleted immediately if there are no other references.  On the\n"
  " * other hand, detach_node() leaves the NodePath referencing the node, which\n"
  " * will keep at least one reference to the node for as long as the NodePath\n"
  " * exists.\n"
  " */";
#else
static const char *Dtool_NodePath_detach_node_683_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::output(std::ostream &out) const
 */
static PyObject *Dtool_NodePath_output_684(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-void NodePath::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "NodePath.output", false, true);
  if (arg_this != nullptr) {
    ((*(const NodePath*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(NodePath self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_output_684_comment =
  "C++ Interface:\n"
  "output(NodePath self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a sensible description of the NodePath to the indicated output\n"
  " * stream.\n"
  " */";
#else
static const char *Dtool_NodePath_output_684_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::ls(void) const
 * inline void NodePath::ls(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_NodePath_ls_685(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void NodePath::ls(void) const
      ((*(const NodePath*)local_this).ls)();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-inline void NodePath::ls(std::ostream &out, int indent_level = 0) const
      PyObject *param1;
      int param2 = 0;
      static const char *keyword_list[] = {"out", "indent_level", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:ls", (char **)keyword_list, &param1, &param2)) {
        std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "NodePath.ls", false, true);
        if (param1_this != nullptr) {
          ((*(const NodePath*)local_this).ls)(*param1_this, (int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "ls() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls(NodePath self)\n"
      "ls(NodePath self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_ls_685_comment =
  "C++ Interface:\n"
  "ls(NodePath self)\n"
  "ls(NodePath self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Lists the hierarchy at and below the referenced node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Lists the hierarchy at and below the referenced node.\n"
  " */";
#else
static const char *Dtool_NodePath_ls_685_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::reverse_ls(void) const
 * int NodePath::reverse_ls(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_NodePath_reverse_ls_686(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void NodePath::reverse_ls(void) const
      ((*(const NodePath*)local_this).reverse_ls)();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-int NodePath::reverse_ls(std::ostream &out, int indent_level = 0) const
      PyObject *param1;
      int param2 = 0;
      static const char *keyword_list[] = {"out", "indent_level", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:reverse_ls", (char **)keyword_list, &param1, &param2)) {
        std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "NodePath.reverse_ls", false, true);
        if (param1_this != nullptr) {
          int return_value = ((*(const NodePath*)local_this).reverse_ls)(*param1_this, (int)param2);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "reverse_ls() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reverse_ls(NodePath self)\n"
      "reverse_ls(NodePath self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_reverse_ls_686_comment =
  "C++ Interface:\n"
  "reverse_ls(NodePath self)\n"
  "reverse_ls(NodePath self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Lists the hierarchy at and above the referenced node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Lists the hierarchy at and above the referenced node.\n"
  " */";
#else
static const char *Dtool_NodePath_reverse_ls_686_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderState > NodePath::get_state(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
 * RenderState const *NodePath::get_state(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_state_687(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-RenderState const *NodePath::get_state(Thread *current_thread) const
      RenderState const *return_value = ((*(const NodePath*)local_this).get_state)();
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 ConstPointerTo< RenderState > NodePath::get_state(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"other", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:get_state", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.get_state", false, false);
          }
          if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            ConstPointerTo< RenderState > return_value = ((*(const NodePath*)local_this).get_state)(*param1_this, param2_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderState const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 RenderState const *NodePath::get_state(Thread *current_thread = Thread::get_current_thread()) const
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "current_thread")) {
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_state", false, false);
          if (param1_this != nullptr) {
            RenderState const *return_value = ((*(const NodePath*)local_this).get_state)(param1_this);
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (Dtool_CheckErrorOccurred()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return nullptr;
            }
            if (return_value == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
            }
          }
        }
      }

      // No coercion possible: ConstPointerTo< RenderState > NodePath::get_state(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
      // No coercion possible: RenderState const *NodePath::get_state(Thread *current_thread = Thread::get_current_thread()) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_state() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_state(NodePath self)\n"
      "get_state(NodePath self, const NodePath other, Thread current_thread)\n"
      "get_state(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_state_687_comment =
  "C++ Interface:\n"
  "get_state(NodePath self)\n"
  "get_state(NodePath self, const NodePath other, Thread current_thread)\n"
  "get_state(NodePath self, Thread current_thread)\n"
  "\n"
  "// Aggregate transform and state information.\n"
  "\n"
  "/**\n"
  " * Returns the complete state object set on this node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the state changes that must be made to transition to the render\n"
  " * state of this node from the render state of the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_state_687_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_state(NodePath const &other, RenderState const *state, Thread *current_thread = Thread::get_current_thread())
 * inline void NodePath::set_state(RenderState const *state, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_set_state_688(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_state")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "state")) {
        // 1-inline void NodePath::set_state(RenderState const *state, Thread *current_thread)
        CPT(RenderState) arg_this;
        if (!Dtool_ConstCoerce_RenderState(arg, arg_this)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.set_state", "RenderState");
        }
        ((*local_this).set_state)(std::move(arg_this));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
  case 3:
    {
      {
        // -2 void NodePath::set_state(NodePath const &other, RenderState const *state, Thread *current_thread = Thread::get_current_thread())
        PyObject *param1;
        PyObject *param2;
        PyObject *param3 = nullptr;
        static const char *keyword_list[] = {"other", "state", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:set_state", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          RenderState const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_RenderState);
          Thread *param3_this;
          if (param3 == nullptr) {
            param3_this = Thread::get_current_thread();
          } else {
            param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "NodePath.set_state", false, false);
          }
          if (param1_this != nullptr && param2_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
            ((*local_this).set_state)(*param1_this, param2_this, param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_state(RenderState const *state, Thread *current_thread = Thread::get_current_thread())
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"state", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_state", (char **)keyword_list, &param1, &param2)) {
          RenderState const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_RenderState);
          Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.set_state", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_state)(param1_this, param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_state(NodePath const &other, RenderState const *state, Thread *current_thread = Thread::get_current_thread())
        PyObject *param1;
        PyObject *param2;
        PyObject *param3 = nullptr;
        static const char *keyword_list[] = {"other", "state", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:set_state", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          CPT(RenderState) param2_this;
          Thread *param3_this;
          if (param3 == nullptr) {
            param3_this = Thread::get_current_thread();
          } else {
            param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "NodePath.set_state", false, false);
          }
          if (param1_this != nullptr && Dtool_ConstCoerce_RenderState(param2, param2_this) && (param3 == nullptr || param3_this != nullptr)) {
            ((*local_this).set_state)(*param1_this, std::move(param2_this), param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_state(RenderState const *state, Thread *current_thread = Thread::get_current_thread())
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"state", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_state", (char **)keyword_list, &param1, &param2)) {
          CPT(RenderState) param1_this;
          Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.set_state", false, false);
          if (Dtool_ConstCoerce_RenderState(param1, param1_this) && param2_this != nullptr) {
            ((*local_this).set_state)(std::move(param1_this), param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_state() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_state(const NodePath self, const RenderState state)\n"
      "set_state(const NodePath self, const NodePath other, const RenderState state, Thread current_thread)\n"
      "set_state(const NodePath self, const RenderState state, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_state_688_comment =
  "C++ Interface:\n"
  "set_state(const NodePath self, const RenderState state)\n"
  "set_state(const NodePath self, const NodePath other, const RenderState state, Thread current_thread)\n"
  "set_state(const NodePath self, const RenderState state, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Changes the complete state object on this node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the state object on this node, relative to the other node.  This\n"
  " * computes a new state object that will have the indicated value when seen\n"
  " * from the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_state_688_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< RenderState > NodePath::get_net_state(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_net_state_689(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< RenderState > NodePath::get_net_state(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_net_state", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< RenderState > return_value = ((*(const NodePath*)local_this).get_net_state)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_state(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_net_state_689_comment =
  "C++ Interface:\n"
  "get_net_state(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the net state on this node from the root.\n"
  " */";
#else
static const char *Dtool_NodePath_get_net_state_689_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_attrib(RenderAttrib const *attrib, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_attrib_690(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_attrib")) {
    return nullptr;
  }
  // 1-inline void NodePath::set_attrib(RenderAttrib const *attrib, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"attrib", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_attrib", (char **)keyword_list, &param1, &param2)) {
    RenderAttrib const *param1_this = (RenderAttrib *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_RenderAttrib, 1, "NodePath.set_attrib", true, true);
    if (param1_this != nullptr) {
      ((*local_this).set_attrib)(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_attrib(const NodePath self, const RenderAttrib attrib, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_attrib_690_comment =
  "C++ Interface:\n"
  "set_attrib(const NodePath self, const RenderAttrib attrib, int priority)\n"
  "\n"
  "/**\n"
  " * Adds the indicated render attribute to the scene graph on this node.  This\n"
  " * attribute will now apply to this node and everything below.  If there was\n"
  " * already an attribute of the same type, it is replaced.\n"
  " */";
#else
static const char *Dtool_NodePath_set_attrib_690_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderAttrib const *NodePath::get_attrib(TypeHandle type) const
 */
static PyObject *Dtool_NodePath_get_attrib_691(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline RenderAttrib const *NodePath::get_attrib(TypeHandle type) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.get_attrib", "TypeHandle");
  }
  RenderAttrib const *return_value = ((*(const NodePath*)local_this).get_attrib)(*arg_this);
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderAttrib, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_attrib(NodePath self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_attrib_691_comment =
  "C++ Interface:\n"
  "get_attrib(NodePath self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Returns the render attribute of the indicated type, if it is defined on the\n"
  " * node, or NULL if it is not.  This checks only what is set on this\n"
  " * particular node level, and has nothing to do with what render attributes\n"
  " * may be inherited from parent nodes.\n"
  " */";
#else
static const char *Dtool_NodePath_get_attrib_691_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::has_attrib(TypeHandle type) const
 */
static PyObject *Dtool_NodePath_has_attrib_692(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::has_attrib(TypeHandle type) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.has_attrib", "TypeHandle");
  }
  bool return_value = ((*(const NodePath*)local_this).has_attrib)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_attrib(NodePath self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_attrib_692_comment =
  "C++ Interface:\n"
  "has_attrib(NodePath self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a render attribute of the indicated type defined\n"
  " * on this node, or false if there is not.\n"
  " */";
#else
static const char *Dtool_NodePath_has_attrib_692_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::clear_attrib(TypeHandle type)
 */
static PyObject *Dtool_NodePath_clear_attrib_693(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_attrib")) {
    return nullptr;
  }
  // 1-inline void NodePath::clear_attrib(TypeHandle type)
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.clear_attrib", "TypeHandle");
  }
  ((*local_this).clear_attrib)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_attrib(const NodePath self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_attrib_693_comment =
  "C++ Interface:\n"
  "clear_attrib(const NodePath self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Removes the render attribute of the given type from this node.  This node,\n"
  " * and the subgraph below, will now inherit the indicated render attribute\n"
  " * from the nodes above this one.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_attrib_693_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_effect(RenderEffect const *effect)
 */
static PyObject *Dtool_NodePath_set_effect_694(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_effect")) {
    return nullptr;
  }
  // 1-inline void NodePath::set_effect(RenderEffect const *effect)
  RenderEffect const *arg_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderEffect, 1, "NodePath.set_effect", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_effect)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_effect(const NodePath self, const RenderEffect effect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_effect_694_comment =
  "C++ Interface:\n"
  "set_effect(const NodePath self, const RenderEffect effect)\n"
  "\n"
  "/**\n"
  " * Adds the indicated render effect to the scene graph on this node.  If there\n"
  " * was already an effect of the same type, it is replaced.\n"
  " */";
#else
static const char *Dtool_NodePath_set_effect_694_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderEffect const *NodePath::get_effect(TypeHandle type) const
 */
static PyObject *Dtool_NodePath_get_effect_695(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline RenderEffect const *NodePath::get_effect(TypeHandle type) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.get_effect", "TypeHandle");
  }
  RenderEffect const *return_value = ((*(const NodePath*)local_this).get_effect)(*arg_this);
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderEffect, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_effect(NodePath self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_effect_695_comment =
  "C++ Interface:\n"
  "get_effect(NodePath self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Returns the render effect of the indicated type, if it is defined on the\n"
  " * node, or NULL if it is not.\n"
  " */";
#else
static const char *Dtool_NodePath_get_effect_695_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::has_effect(TypeHandle type) const
 */
static PyObject *Dtool_NodePath_has_effect_696(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::has_effect(TypeHandle type) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.has_effect", "TypeHandle");
  }
  bool return_value = ((*(const NodePath*)local_this).has_effect)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_effect(NodePath self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_effect_696_comment =
  "C++ Interface:\n"
  "has_effect(NodePath self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a render effect of the indicated type defined on\n"
  " * this node, or false if there is not.\n"
  " */";
#else
static const char *Dtool_NodePath_has_effect_696_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::clear_effect(TypeHandle type)
 */
static PyObject *Dtool_NodePath_clear_effect_697(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_effect")) {
    return nullptr;
  }
  // 1-inline void NodePath::clear_effect(TypeHandle type)
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.clear_effect", "TypeHandle");
  }
  ((*local_this).clear_effect)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_effect(const NodePath self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_effect_697_comment =
  "C++ Interface:\n"
  "clear_effect(const NodePath self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Removes the render effect of the given type from this node.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_effect_697_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_effects(RenderEffects const *effects)
 */
static PyObject *Dtool_NodePath_set_effects_698(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_effects")) {
    return nullptr;
  }
  // 1-inline void NodePath::set_effects(RenderEffects const *effects)
  CPT(RenderEffects) arg_this;
  if (!Dtool_ConstCoerce_RenderEffects(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.set_effects", "RenderEffects");
  }
  ((*local_this).set_effects)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_effects(const NodePath self, const RenderEffects effects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_effects_698_comment =
  "C++ Interface:\n"
  "set_effects(const NodePath self, const RenderEffects effects)\n"
  "\n"
  "/**\n"
  " * Sets the complete RenderEffects that will be applied this node.  This\n"
  " * completely replaces whatever has been set on this node via repeated calls\n"
  " * to set_attrib().\n"
  " */";
#else
static const char *Dtool_NodePath_set_effects_698_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderEffects const *NodePath::get_effects(void) const
 */
static PyObject *Dtool_NodePath_get_effects_699(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline RenderEffects const *NodePath::get_effects(void) const
  RenderEffects const *return_value = ((*(const NodePath*)local_this).get_effects)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderEffects, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_effects_699_comment =
  "C++ Interface:\n"
  "get_effects(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the complete RenderEffects that will be applied to this node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_effects_699_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::clear_effects(void)
 */
static PyObject *Dtool_NodePath_clear_effects_700(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_effects")) {
    return nullptr;
  }
  // 1-inline void NodePath::clear_effects(void)
  ((*local_this).clear_effects)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_effects_700_comment =
  "C++ Interface:\n"
  "clear_effects(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Resets this node to have no render effects.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_effects_700_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > NodePath::get_transform(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
 * TransformState const *NodePath::get_transform(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_transform_701(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TransformState const *NodePath::get_transform(Thread *current_thread) const
      TransformState const *return_value = ((*(const NodePath*)local_this).get_transform)();
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 ConstPointerTo< TransformState > NodePath::get_transform(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"other", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:get_transform", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.get_transform", false, false);
          }
          if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            ConstPointerTo< TransformState > return_value = ((*(const NodePath*)local_this).get_transform)(*param1_this, param2_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            TransformState const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 TransformState const *NodePath::get_transform(Thread *current_thread = Thread::get_current_thread()) const
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "current_thread")) {
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_transform", false, false);
          if (param1_this != nullptr) {
            TransformState const *return_value = ((*(const NodePath*)local_this).get_transform)(param1_this);
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (Dtool_CheckErrorOccurred()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
          }
        }
      }

      // No coercion possible: ConstPointerTo< TransformState > NodePath::get_transform(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
      // No coercion possible: TransformState const *NodePath::get_transform(Thread *current_thread = Thread::get_current_thread()) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_transform() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_transform(NodePath self)\n"
      "get_transform(NodePath self, const NodePath other, Thread current_thread)\n"
      "get_transform(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_transform_701_comment =
  "C++ Interface:\n"
  "get_transform(NodePath self)\n"
  "get_transform(NodePath self, const NodePath other, Thread current_thread)\n"
  "get_transform(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the complete transform object set on this node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the relative transform to this node from the other node; i.e.  the\n"
  " * transformation of this node as seen from the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_transform_701_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::clear_transform(NodePath const &other, Thread *current_thread = Thread::get_current_thread())
 * inline void NodePath::clear_transform(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_clear_transform_702(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_transform")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void NodePath::clear_transform(Thread *current_thread)
      ((*local_this).clear_transform)();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 inline void NodePath::clear_transform(NodePath const &other, Thread *current_thread = Thread::get_current_thread())
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"other", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:clear_transform", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.clear_transform", false, false);
          }
          if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            ((*local_this).clear_transform)(*param1_this, param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::clear_transform(Thread *current_thread = Thread::get_current_thread())
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "current_thread")) {
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.clear_transform", false, false);
          if (param1_this != nullptr) {
            ((*local_this).clear_transform)(param1_this);
            return Dtool_Return_None();
          }
        }
      }

      // No coercion possible: inline void NodePath::clear_transform(NodePath const &other, Thread *current_thread = Thread::get_current_thread())
      // No coercion possible: inline void NodePath::clear_transform(Thread *current_thread = Thread::get_current_thread())
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_transform() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_transform(const NodePath self)\n"
      "clear_transform(const NodePath self, const NodePath other, Thread current_thread)\n"
      "clear_transform(const NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_transform_702_comment =
  "C++ Interface:\n"
  "clear_transform(const NodePath self)\n"
  "clear_transform(const NodePath self, const NodePath other, Thread current_thread)\n"
  "clear_transform(const NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Sets the transform object on this node to identity.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the transform object on this node to identity, relative to the other\n"
  " * node.  This effectively places this node at the same position as the other\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_transform_702_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_transform(NodePath const &other, TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
 * inline void NodePath::set_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_set_transform_703(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_transform")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "transform")) {
        // 1-inline void NodePath::set_transform(TransformState const *transform, Thread *current_thread)
        TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "NodePath.set_transform", true, true);
        if (arg_this != nullptr) {
          ((*local_this).set_transform)(arg_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
  case 3:
    {
      {
        // -2 void NodePath::set_transform(NodePath const &other, TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
        PyObject *param1;
        PyObject *param2;
        PyObject *param3 = nullptr;
        static const char *keyword_list[] = {"other", "transform", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:set_transform", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          TransformState const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_TransformState);
          Thread *param3_this;
          if (param3 == nullptr) {
            param3_this = Thread::get_current_thread();
          } else {
            param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "NodePath.set_transform", false, false);
          }
          if (param1_this != nullptr && param2_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
            ((*local_this).set_transform)(*param1_this, param2_this, param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"transform", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_transform", (char **)keyword_list, &param1, &param2)) {
          TransformState const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_TransformState);
          Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.set_transform", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_transform)(param1_this, param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePath::set_transform(NodePath const &other, TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
      // No coercion possible: inline void NodePath::set_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_transform() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform(const NodePath self, const TransformState transform)\n"
      "set_transform(const NodePath self, const NodePath other, const TransformState transform, Thread current_thread)\n"
      "set_transform(const NodePath self, const TransformState transform, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_transform_703_comment =
  "C++ Interface:\n"
  "set_transform(const NodePath self, const TransformState transform)\n"
  "set_transform(const NodePath self, const NodePath other, const TransformState transform, Thread current_thread)\n"
  "set_transform(const NodePath self, const TransformState transform, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Changes the complete transform object on this node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the transform object on this node, relative to the other node.  This\n"
  " * computes a new transform object that will have the indicated value when\n"
  " * seen from the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_transform_703_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< TransformState > NodePath::get_net_transform(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_net_transform_704(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< TransformState > NodePath::get_net_transform(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_net_transform", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< TransformState > return_value = ((*(const NodePath*)local_this).get_net_transform)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      TransformState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_transform(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_net_transform_704_comment =
  "C++ Interface:\n"
  "get_net_transform(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the net transform on this node from the root.\n"
  " */";
#else
static const char *Dtool_NodePath_get_net_transform_704_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > NodePath::get_prev_transform(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
 * TransformState const *NodePath::get_prev_transform(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_prev_transform_705(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TransformState const *NodePath::get_prev_transform(Thread *current_thread) const
      TransformState const *return_value = ((*(const NodePath*)local_this).get_prev_transform)();
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 ConstPointerTo< TransformState > NodePath::get_prev_transform(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"other", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:get_prev_transform", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.get_prev_transform", false, false);
          }
          if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            ConstPointerTo< TransformState > return_value = ((*(const NodePath*)local_this).get_prev_transform)(*param1_this, param2_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            TransformState const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 TransformState const *NodePath::get_prev_transform(Thread *current_thread = Thread::get_current_thread()) const
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "current_thread")) {
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_prev_transform", false, false);
          if (param1_this != nullptr) {
            TransformState const *return_value = ((*(const NodePath*)local_this).get_prev_transform)(param1_this);
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (Dtool_CheckErrorOccurred()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
          }
        }
      }

      // No coercion possible: ConstPointerTo< TransformState > NodePath::get_prev_transform(NodePath const &other, Thread *current_thread = Thread::get_current_thread()) const
      // No coercion possible: TransformState const *NodePath::get_prev_transform(Thread *current_thread = Thread::get_current_thread()) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_prev_transform() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_prev_transform(NodePath self)\n"
      "get_prev_transform(NodePath self, const NodePath other, Thread current_thread)\n"
      "get_prev_transform(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_prev_transform_705_comment =
  "C++ Interface:\n"
  "get_prev_transform(NodePath self)\n"
  "get_prev_transform(NodePath self, const NodePath other, Thread current_thread)\n"
  "get_prev_transform(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the transform that has been set as this node's \"previous\" position.\n"
  " * See set_prev_transform().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the relative \"previous\" transform to this node from the other node;\n"
  " * i.e.  the position of this node in the previous frame, as seen by the other\n"
  " * node in the previous frame.\n"
  " */";
#else
static const char *Dtool_NodePath_get_prev_transform_705_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_prev_transform(NodePath const &other, TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
 * inline void NodePath::set_prev_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_set_prev_transform_706(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_prev_transform")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "transform")) {
        // 1-inline void NodePath::set_prev_transform(TransformState const *transform, Thread *current_thread)
        TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "NodePath.set_prev_transform", true, true);
        if (arg_this != nullptr) {
          ((*local_this).set_prev_transform)(arg_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
  case 3:
    {
      {
        // -2 void NodePath::set_prev_transform(NodePath const &other, TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
        PyObject *param1;
        PyObject *param2;
        PyObject *param3 = nullptr;
        static const char *keyword_list[] = {"other", "transform", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:set_prev_transform", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          TransformState const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_TransformState);
          Thread *param3_this;
          if (param3 == nullptr) {
            param3_this = Thread::get_current_thread();
          } else {
            param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "NodePath.set_prev_transform", false, false);
          }
          if (param1_this != nullptr && param2_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
            ((*local_this).set_prev_transform)(*param1_this, param2_this, param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_prev_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"transform", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_prev_transform", (char **)keyword_list, &param1, &param2)) {
          TransformState const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_TransformState);
          Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.set_prev_transform", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_prev_transform)(param1_this, param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePath::set_prev_transform(NodePath const &other, TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
      // No coercion possible: inline void NodePath::set_prev_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread())
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_prev_transform() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_prev_transform(const NodePath self, const TransformState transform)\n"
      "set_prev_transform(const NodePath self, const NodePath other, const TransformState transform, Thread current_thread)\n"
      "set_prev_transform(const NodePath self, const TransformState transform, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_prev_transform_706_comment =
  "C++ Interface:\n"
  "set_prev_transform(const NodePath self, const TransformState transform)\n"
  "set_prev_transform(const NodePath self, const NodePath other, const TransformState transform, Thread current_thread)\n"
  "set_prev_transform(const NodePath self, const TransformState transform, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Sets the transform that represents this node's \"previous\" position, one\n"
  " * frame ago, for the purposes of detecting motion for accurate collision\n"
  " * calculations.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the \"previous\" transform object on this node, relative to the other\n"
  " * node.  This computes a new transform object that will have the indicated\n"
  " * value when seen from the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_prev_transform_706_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< TransformState > NodePath::get_net_prev_transform(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_net_prev_transform_707(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< TransformState > NodePath::get_net_prev_transform(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_net_prev_transform", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< TransformState > return_value = ((*(const NodePath*)local_this).get_net_prev_transform)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      TransformState const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_prev_transform(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_net_prev_transform_707_comment =
  "C++ Interface:\n"
  "get_net_prev_transform(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the net \"previous\" transform on this node from the root.  See\n"
  " * set_prev_transform().\n"
  " */";
#else
static const char *Dtool_NodePath_get_net_prev_transform_707_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_pos(LVecBase3 const &pos)
 * void NodePath::set_pos(NodePath const &other, LVecBase3 const &pos)
 * inline void NodePath::set_pos(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 * inline void NodePath::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_NodePath_set_pos_708(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_pos")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-void NodePath::set_pos(LVecBase3 const &pos)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.set_pos", "LVecBase3f");
        }
        ((*local_this).set_pos)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_pos(NodePath const &other, LVecBase3 const &pos)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "pos", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_pos", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_pos", true, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_pos)(*param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-inline void NodePath::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_pos)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void NodePath::set_pos(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"other", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:set_pos", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_pos", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_pos)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const NodePath self, const LVecBase3f pos)\n"
      "set_pos(const NodePath self, const NodePath other, const LVecBase3f pos)\n"
      "set_pos(const NodePath self, float x, float y, float z)\n"
      "set_pos(const NodePath self, const NodePath other, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_pos_708_comment =
  "C++ Interface:\n"
  "set_pos(const NodePath self, const LVecBase3f pos)\n"
  "set_pos(const NodePath self, const NodePath other, const LVecBase3f pos)\n"
  "set_pos(const NodePath self, float x, float y, float z)\n"
  "set_pos(const NodePath self, const NodePath other, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Sets the translation component of the transform, leaving rotation and scale\n"
  " * untouched.  This also resets the node's \"previous\" position, so that the\n"
  " * collision system will see the node as having suddenly appeared in the new\n"
  " * position, without passing any points in between.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the translation component of the transform, relative to the other\n"
  " * node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the translation component of the transform, leaving rotation and scale\n"
  " * untouched.  This also resets the node's \"previous\" position, so that the\n"
  " * collision system will see the node as having suddenly appeared in the new\n"
  " * position, without passing any points in between.  See Also:\n"
  " * NodePath::set_fluid_pos\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the translation component of the transform, relative to the other\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_pos_708_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_x(NodePath const &other, PN_stdfloat x)
 * void NodePath::set_x(PN_stdfloat x)
 */
static PyObject *Dtool_NodePath_set_x_709(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_x")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "x")) {
        // 1-void NodePath::set_x(PN_stdfloat x)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_x)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_x(NodePath const &other, PN_stdfloat x)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "x", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_x", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_x", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_x)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_x() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const NodePath self, float x)\n"
      "set_x(const NodePath self, const NodePath other, float x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_x_709_comment =
  "C++ Interface:\n"
  "set_x(const NodePath self, float x)\n"
  "set_x(const NodePath self, const NodePath other, float x)\n";
#else
static const char *Dtool_NodePath_set_x_709_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_y(NodePath const &other, PN_stdfloat y)
 * void NodePath::set_y(PN_stdfloat y)
 */
static PyObject *Dtool_NodePath_set_y_710(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_y")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "y")) {
        // 1-void NodePath::set_y(PN_stdfloat y)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_y)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_y(NodePath const &other, PN_stdfloat y)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_y", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_y", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_y)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_y() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const NodePath self, float y)\n"
      "set_y(const NodePath self, const NodePath other, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_y_710_comment =
  "C++ Interface:\n"
  "set_y(const NodePath self, float y)\n"
  "set_y(const NodePath self, const NodePath other, float y)\n";
#else
static const char *Dtool_NodePath_set_y_710_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_z(NodePath const &other, PN_stdfloat z)
 * void NodePath::set_z(PN_stdfloat z)
 */
static PyObject *Dtool_NodePath_set_z_711(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_z")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "z")) {
        // 1-void NodePath::set_z(PN_stdfloat z)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_z)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_z(NodePath const &other, PN_stdfloat z)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_z", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_z", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_z)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_z() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z(const NodePath self, float z)\n"
      "set_z(const NodePath self, const NodePath other, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_z_711_comment =
  "C++ Interface:\n"
  "set_z(const NodePath self, float z)\n"
  "set_z(const NodePath self, const NodePath other, float z)\n";
#else
static const char *Dtool_NodePath_set_z_711_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_fluid_pos(LVecBase3 const &pos)
 * void NodePath::set_fluid_pos(NodePath const &other, LVecBase3 const &pos)
 * inline void NodePath::set_fluid_pos(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 * inline void NodePath::set_fluid_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_NodePath_set_fluid_pos_712(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_fluid_pos")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-void NodePath::set_fluid_pos(LVecBase3 const &pos)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.set_fluid_pos", "LVecBase3f");
        }
        ((*local_this).set_fluid_pos)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_fluid_pos(NodePath const &other, LVecBase3 const &pos)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "pos", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_fluid_pos", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_fluid_pos", true, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_fluid_pos", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_fluid_pos)(*param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-inline void NodePath::set_fluid_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_fluid_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_fluid_pos)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void NodePath::set_fluid_pos(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"other", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:set_fluid_pos", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_fluid_pos", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_fluid_pos)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_fluid_pos() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fluid_pos(const NodePath self, const LVecBase3f pos)\n"
      "set_fluid_pos(const NodePath self, const NodePath other, const LVecBase3f pos)\n"
      "set_fluid_pos(const NodePath self, float x, float y, float z)\n"
      "set_fluid_pos(const NodePath self, const NodePath other, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_fluid_pos_712_comment =
  "C++ Interface:\n"
  "set_fluid_pos(const NodePath self, const LVecBase3f pos)\n"
  "set_fluid_pos(const NodePath self, const NodePath other, const LVecBase3f pos)\n"
  "set_fluid_pos(const NodePath self, float x, float y, float z)\n"
  "set_fluid_pos(const NodePath self, const NodePath other, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Sets the translation component, without changing the \"previous\" position,\n"
  " * so that the collision system will see the node as moving fluidly from its\n"
  " * previous position to its new position.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the translation component, without changing the \"previous\" position,\n"
  " * so that the collision system will see the node as moving fluidly from its\n"
  " * previous position to its new position.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the translation component, without changing the \"previous\" position,\n"
  " * so that the collision system will see the node as moving fluidly from its\n"
  " * previous position to its new position.  See Also: NodePath::set_pos\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the translation component of the transform, relative to the other\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_fluid_pos_712_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_fluid_x(NodePath const &other, PN_stdfloat x)
 * void NodePath::set_fluid_x(PN_stdfloat x)
 */
static PyObject *Dtool_NodePath_set_fluid_x_713(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_fluid_x")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "x")) {
        // 1-void NodePath::set_fluid_x(PN_stdfloat x)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_fluid_x)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_fluid_x(NodePath const &other, PN_stdfloat x)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "x", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_fluid_x", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_fluid_x", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_fluid_x)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_fluid_x() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fluid_x(const NodePath self, float x)\n"
      "set_fluid_x(const NodePath self, const NodePath other, float x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_fluid_x_713_comment =
  "C++ Interface:\n"
  "set_fluid_x(const NodePath self, float x)\n"
  "set_fluid_x(const NodePath self, const NodePath other, float x)\n";
#else
static const char *Dtool_NodePath_set_fluid_x_713_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_fluid_y(NodePath const &other, PN_stdfloat y)
 * void NodePath::set_fluid_y(PN_stdfloat y)
 */
static PyObject *Dtool_NodePath_set_fluid_y_714(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_fluid_y")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "y")) {
        // 1-void NodePath::set_fluid_y(PN_stdfloat y)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_fluid_y)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_fluid_y(NodePath const &other, PN_stdfloat y)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_fluid_y", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_fluid_y", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_fluid_y)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_fluid_y() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fluid_y(const NodePath self, float y)\n"
      "set_fluid_y(const NodePath self, const NodePath other, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_fluid_y_714_comment =
  "C++ Interface:\n"
  "set_fluid_y(const NodePath self, float y)\n"
  "set_fluid_y(const NodePath self, const NodePath other, float y)\n";
#else
static const char *Dtool_NodePath_set_fluid_y_714_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_fluid_z(NodePath const &other, PN_stdfloat z)
 * void NodePath::set_fluid_z(PN_stdfloat z)
 */
static PyObject *Dtool_NodePath_set_fluid_z_715(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_fluid_z")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "z")) {
        // 1-void NodePath::set_fluid_z(PN_stdfloat z)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_fluid_z)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_fluid_z(NodePath const &other, PN_stdfloat z)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_fluid_z", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_fluid_z", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_fluid_z)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_fluid_z() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fluid_z(const NodePath self, float z)\n"
      "set_fluid_z(const NodePath self, const NodePath other, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_fluid_z_715_comment =
  "C++ Interface:\n"
  "set_fluid_z(const NodePath self, float z)\n"
  "set_fluid_z(const NodePath self, const NodePath other, float z)\n";
#else
static const char *Dtool_NodePath_set_fluid_z_715_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3 NodePath::get_pos(void) const
 * LPoint3 NodePath::get_pos(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_pos_716(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-LPoint3 NodePath::get_pos(void) const
      LPoint3 *return_value = new LPoint3(((*(const NodePath*)local_this).get_pos)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-LPoint3 NodePath::get_pos(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_pos", true, true);
      if (arg_this != nullptr) {
        LPoint3 *return_value = new LPoint3(((*(const NodePath*)local_this).get_pos)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_pos() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pos(NodePath self)\n"
      "get_pos(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_pos_716_comment =
  "C++ Interface:\n"
  "get_pos(NodePath self)\n"
  "get_pos(NodePath self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Retrieves the translation component of the transform.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the relative position of the referenced node as seen from the other\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_pos_716_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_x(void) const
 * inline PN_stdfloat NodePath::get_x(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_x_717(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_x(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_x)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_x(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_x", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_x)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_x() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_x(NodePath self)\n"
      "get_x(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_x_717_comment =
  "C++ Interface:\n"
  "get_x(NodePath self)\n"
  "get_x(NodePath self, const NodePath other)\n";
#else
static const char *Dtool_NodePath_get_x_717_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_y(void) const
 * inline PN_stdfloat NodePath::get_y(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_y_718(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_y(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_y)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_y(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_y", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_y)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_y() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_y(NodePath self)\n"
      "get_y(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_y_718_comment =
  "C++ Interface:\n"
  "get_y(NodePath self)\n"
  "get_y(NodePath self, const NodePath other)\n";
#else
static const char *Dtool_NodePath_get_y_718_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_z(void) const
 * inline PN_stdfloat NodePath::get_z(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_z_719(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_z(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_z)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_z(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_z", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_z)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_z() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_z(NodePath self)\n"
      "get_z(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_z_719_comment =
  "C++ Interface:\n"
  "get_z(NodePath self)\n"
  "get_z(NodePath self, const NodePath other)\n";
#else
static const char *Dtool_NodePath_get_z_719_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 NodePath::get_pos_delta(void) const
 * LVector3 NodePath::get_pos_delta(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_pos_delta_720(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-LVector3 NodePath::get_pos_delta(void) const
      LVector3 *return_value = new LVector3(((*(const NodePath*)local_this).get_pos_delta)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-LVector3 NodePath::get_pos_delta(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_pos_delta", true, true);
      if (arg_this != nullptr) {
        LVector3 *return_value = new LVector3(((*(const NodePath*)local_this).get_pos_delta)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_pos_delta() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pos_delta(NodePath self)\n"
      "get_pos_delta(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_pos_delta_720_comment =
  "C++ Interface:\n"
  "get_pos_delta(NodePath self)\n"
  "get_pos_delta(NodePath self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Returns the delta vector from this node's position in the previous frame\n"
  " * (according to set_prev_transform(), typically set via the use of\n"
  " * set_fluid_pos()) and its position in the current frame.  This is the vector\n"
  " * used to determine collisions.  Generally, if the node was last repositioned\n"
  " * via set_pos(), the delta will be zero; if it was adjusted via\n"
  " * set_fluid_pos(), the delta will represent the change from the previous\n"
  " * frame's position.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the delta vector from this node's position in the previous frame\n"
  " * (according to set_prev_transform(), typically set via the use of\n"
  " * set_fluid_pos()) and its position in the current frame, as seen in the\n"
  " * indicated node's coordinate space.  This is the vector used to determine\n"
  " * collisions.  Generally, if the node was last repositioned via set_pos(),\n"
  " * the delta will be zero; if it was adjusted via set_fluid_pos(), the delta\n"
  " * will represent the change from the previous frame's position.\n"
  " */";
#else
static const char *Dtool_NodePath_get_pos_delta_720_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_hpr(LVecBase3 const &hpr)
 * void NodePath::set_hpr(NodePath const &other, LVecBase3 const &hpr)
 * inline void NodePath::set_hpr(NodePath const &other, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 * inline void NodePath::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_NodePath_set_hpr_721(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_hpr")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "hpr")) {
        // 1-void NodePath::set_hpr(LVecBase3 const &hpr)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.set_hpr", "LVecBase3f");
        }
        ((*local_this).set_hpr)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_hpr(NodePath const &other, LVecBase3 const &hpr)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "hpr", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_hpr", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_hpr", true, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_hpr", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_hpr)(*param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-inline void NodePath::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"h", "p", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_hpr", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_hpr)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void NodePath::set_hpr(NodePath const &other, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"other", "h", "p", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:set_hpr", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_hpr", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_hpr)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_hpr() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hpr(const NodePath self, const LVecBase3f hpr)\n"
      "set_hpr(const NodePath self, const NodePath other, const LVecBase3f hpr)\n"
      "set_hpr(const NodePath self, float h, float p, float r)\n"
      "set_hpr(const NodePath self, const NodePath other, float h, float p, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_hpr_721_comment =
  "C++ Interface:\n"
  "set_hpr(const NodePath self, const LVecBase3f hpr)\n"
  "set_hpr(const NodePath self, const NodePath other, const LVecBase3f hpr)\n"
  "set_hpr(const NodePath self, float h, float p, float r)\n"
  "set_hpr(const NodePath self, const NodePath other, float h, float p, float r)\n"
  "\n"
  "/**\n"
  " * Sets the rotation component of the transform, leaving translation and scale\n"
  " * untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the rotation component of the transform, relative to the other node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the rotation component of the transform, leaving translation and scale\n"
  " * untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the rotation component of the transform, relative to the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_hpr_721_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_h(NodePath const &other, PN_stdfloat h)
 * void NodePath::set_h(PN_stdfloat h)
 */
static PyObject *Dtool_NodePath_set_h_722(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_h")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "h")) {
        // 1-void NodePath::set_h(PN_stdfloat h)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_h)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_h(NodePath const &other, PN_stdfloat h)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "h", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_h", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_h", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_h)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_h() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_h(const NodePath self, float h)\n"
      "set_h(const NodePath self, const NodePath other, float h)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_h_722_comment =
  "C++ Interface:\n"
  "set_h(const NodePath self, float h)\n"
  "set_h(const NodePath self, const NodePath other, float h)\n";
#else
static const char *Dtool_NodePath_set_h_722_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_p(NodePath const &other, PN_stdfloat p)
 * void NodePath::set_p(PN_stdfloat p)
 */
static PyObject *Dtool_NodePath_set_p_723(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_p")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "p")) {
        // 1-void NodePath::set_p(PN_stdfloat p)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_p)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_p(NodePath const &other, PN_stdfloat p)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "p", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_p", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_p", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_p)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_p() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_p(const NodePath self, float p)\n"
      "set_p(const NodePath self, const NodePath other, float p)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_p_723_comment =
  "C++ Interface:\n"
  "set_p(const NodePath self, float p)\n"
  "set_p(const NodePath self, const NodePath other, float p)\n";
#else
static const char *Dtool_NodePath_set_p_723_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_r(NodePath const &other, PN_stdfloat r)
 * void NodePath::set_r(PN_stdfloat r)
 */
static PyObject *Dtool_NodePath_set_r_724(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_r")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "r")) {
        // 1-void NodePath::set_r(PN_stdfloat r)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_r)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_r(NodePath const &other, PN_stdfloat r)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_r", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_r", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_r)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_r() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_r(const NodePath self, float r)\n"
      "set_r(const NodePath self, const NodePath other, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_r_724_comment =
  "C++ Interface:\n"
  "set_r(const NodePath self, float r)\n"
  "set_r(const NodePath self, const NodePath other, float r)\n";
#else
static const char *Dtool_NodePath_set_r_724_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 NodePath::get_hpr(void) const
 * LVecBase3 NodePath::get_hpr(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_hpr_725(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-LVecBase3 NodePath::get_hpr(void) const
      LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_hpr)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-LVecBase3 NodePath::get_hpr(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_hpr", true, true);
      if (arg_this != nullptr) {
        LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_hpr)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_hpr() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hpr(NodePath self)\n"
      "get_hpr(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_hpr_725_comment =
  "C++ Interface:\n"
  "get_hpr(NodePath self)\n"
  "get_hpr(NodePath self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Retrieves the rotation component of the transform.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the relative orientation of the bottom node as seen from the other\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_hpr_725_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_h(void) const
 * inline PN_stdfloat NodePath::get_h(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_h_726(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_h(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_h)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_h(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_h", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_h)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_h() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_h(NodePath self)\n"
      "get_h(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_h_726_comment =
  "C++ Interface:\n"
  "get_h(NodePath self)\n"
  "get_h(NodePath self, const NodePath other)\n";
#else
static const char *Dtool_NodePath_get_h_726_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_p(void) const
 * inline PN_stdfloat NodePath::get_p(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_p_727(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_p(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_p)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_p(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_p", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_p)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_p() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_p(NodePath self)\n"
      "get_p(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_p_727_comment =
  "C++ Interface:\n"
  "get_p(NodePath self)\n"
  "get_p(NodePath self, const NodePath other)\n";
#else
static const char *Dtool_NodePath_get_p_727_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_r(void) const
 * inline PN_stdfloat NodePath::get_r(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_r_728(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_r(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_r)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_r(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_r", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_r)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_r() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_r(NodePath self)\n"
      "get_r(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_r_728_comment =
  "C++ Interface:\n"
  "get_r(NodePath self)\n"
  "get_r(NodePath self, const NodePath other)\n";
#else
static const char *Dtool_NodePath_get_r_728_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_quat(LQuaternion const &quat)
 * void NodePath::set_quat(NodePath const &other, LQuaternion const &quat)
 */
static PyObject *Dtool_NodePath_set_quat_729(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_quat")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "quat")) {
        // 1-void NodePath::set_quat(LQuaternion const &quat)
        LQuaternionf arg_local;
        LQuaternion const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.set_quat", "LQuaternionf");
        }
        ((*local_this).set_quat)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_quat(NodePath const &other, LQuaternion const &quat)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "quat", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_quat", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_quat", true, true);
        LQuaternionf param2_local;
        LQuaternion const *param2_this = Dtool_Coerce_LQuaternionf(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_quat", "LQuaternionf");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_quat)(*param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_quat() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quat(const NodePath self, const LQuaternionf quat)\n"
      "set_quat(const NodePath self, const NodePath other, const LQuaternionf quat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_quat_729_comment =
  "C++ Interface:\n"
  "set_quat(const NodePath self, const LQuaternionf quat)\n"
  "set_quat(const NodePath self, const NodePath other, const LQuaternionf quat)\n"
  "\n"
  "/**\n"
  " * Sets the rotation component of the transform, leaving translation and scale\n"
  " * untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the rotation component of the transform, relative to the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_quat_729_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LQuaternion NodePath::get_quat(void) const
 * LQuaternion NodePath::get_quat(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_quat_730(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-LQuaternion NodePath::get_quat(void) const
      LQuaternion *return_value = new LQuaternion(((*(const NodePath*)local_this).get_quat)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-LQuaternion NodePath::get_quat(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_quat", true, true);
      if (arg_this != nullptr) {
        LQuaternion *return_value = new LQuaternion(((*(const NodePath*)local_this).get_quat)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_quat() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_quat(NodePath self)\n"
      "get_quat(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_quat_730_comment =
  "C++ Interface:\n"
  "get_quat(NodePath self)\n"
  "get_quat(NodePath self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Retrieves the rotation component of the transform.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the relative orientation of the bottom node as seen from the other\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_quat_730_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_scale(LVecBase3 const &scale)
 * void NodePath::set_scale(NodePath const &other, LVecBase3 const &scale)
 * inline void NodePath::set_scale(NodePath const &other, PN_stdfloat scale)
 * inline void NodePath::set_scale(NodePath const &other, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
 * inline void NodePath::set_scale(PN_stdfloat scale)
 * inline void NodePath::set_scale(PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
 */
static PyObject *Dtool_NodePath_set_scale_731(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "scale")) {
        {
          // -2 void NodePath::set_scale(LVecBase3 const &scale)
          LVecBase3 const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
          if (arg_this != nullptr) {
            ((*local_this).set_scale)(*arg_this);
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void NodePath::set_scale(PN_stdfloat scale)
          if (PyNumber_Check(arg)) {
            ((*local_this).set_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
            return Dtool_Return_None();
          }
        }

        {
          // -2 void NodePath::set_scale(LVecBase3 const &scale)
          LVecBase3f arg_local;
          LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
          if ((arg_this != nullptr)) {
            ((*local_this).set_scale)(*arg_this);
            return Dtool_Return_None();
          }
        }

        // No coercion possible: inline void NodePath::set_scale(PN_stdfloat scale)
      }
    }
    break;
  case 2:
    {
      {
        // -2 void NodePath::set_scale(NodePath const &other, LVecBase3 const &scale)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"other", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_scale", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          LVecBase3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase3f);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_scale)(*param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_scale(NodePath const &other, PN_stdfloat scale)
        PyObject *param1;
        float param2;
        static const char *keyword_list[] = {"other", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_scale", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          if (param1_this != nullptr) {
            ((*local_this).set_scale)(*param1_this, (PN_stdfloat)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_scale(NodePath const &other, LVecBase3 const &scale)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"other", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_scale", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          LVecBase3f param2_local;
          LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          if (param1_this != nullptr && (param2_this != nullptr)) {
            ((*local_this).set_scale)(*param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void NodePath::set_scale(NodePath const &other, PN_stdfloat scale)
    }
    break;
  case 3:
    {
      // 1-inline void NodePath::set_scale(PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"sx", "sy", "sz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_scale", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_scale)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void NodePath::set_scale(NodePath const &other, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"other", "sx", "sy", "sz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:set_scale", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_scale", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_scale)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_scale() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale(const NodePath self, const LVecBase3f scale)\n"
      "set_scale(const NodePath self, float scale)\n"
      "set_scale(const NodePath self, const NodePath other, const LVecBase3f scale)\n"
      "set_scale(const NodePath self, const NodePath other, float scale)\n"
      "set_scale(const NodePath self, float sx, float sy, float sz)\n"
      "set_scale(const NodePath self, const NodePath other, float sx, float sy, float sz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_scale_731_comment =
  "C++ Interface:\n"
  "set_scale(const NodePath self, const LVecBase3f scale)\n"
  "set_scale(const NodePath self, float scale)\n"
  "set_scale(const NodePath self, const NodePath other, const LVecBase3f scale)\n"
  "set_scale(const NodePath self, const NodePath other, float scale)\n"
  "set_scale(const NodePath self, float sx, float sy, float sz)\n"
  "set_scale(const NodePath self, const NodePath other, float sx, float sy, float sz)\n"
  "\n"
  "/**\n"
  " * Sets the scale component of the transform, leaving translation and rotation\n"
  " * untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the scale component of the transform, relative to the other node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the scale component of the transform, relative to the other node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the scale component of the transform, leaving translation and rotation\n"
  " * untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the scale component of the transform, relative to the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_scale_731_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_sx(NodePath const &other, PN_stdfloat sx)
 * void NodePath::set_sx(PN_stdfloat sx)
 */
static PyObject *Dtool_NodePath_set_sx_732(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_sx")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "sx")) {
        // 1-void NodePath::set_sx(PN_stdfloat sx)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_sx)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_sx(NodePath const &other, PN_stdfloat sx)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "sx", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_sx", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_sx", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_sx)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_sx() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sx(const NodePath self, float sx)\n"
      "set_sx(const NodePath self, const NodePath other, float sx)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_sx_732_comment =
  "C++ Interface:\n"
  "set_sx(const NodePath self, float sx)\n"
  "set_sx(const NodePath self, const NodePath other, float sx)\n";
#else
static const char *Dtool_NodePath_set_sx_732_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_sy(NodePath const &other, PN_stdfloat sy)
 * void NodePath::set_sy(PN_stdfloat sy)
 */
static PyObject *Dtool_NodePath_set_sy_733(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_sy")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "sy")) {
        // 1-void NodePath::set_sy(PN_stdfloat sy)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_sy)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_sy(NodePath const &other, PN_stdfloat sy)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "sy", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_sy", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_sy", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_sy)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_sy() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sy(const NodePath self, float sy)\n"
      "set_sy(const NodePath self, const NodePath other, float sy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_sy_733_comment =
  "C++ Interface:\n"
  "set_sy(const NodePath self, float sy)\n"
  "set_sy(const NodePath self, const NodePath other, float sy)\n";
#else
static const char *Dtool_NodePath_set_sy_733_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_sz(NodePath const &other, PN_stdfloat sz)
 * void NodePath::set_sz(PN_stdfloat sz)
 */
static PyObject *Dtool_NodePath_set_sz_734(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_sz")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "sz")) {
        // 1-void NodePath::set_sz(PN_stdfloat sz)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_sz)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_sz(NodePath const &other, PN_stdfloat sz)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "sz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_sz", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_sz", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_sz)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_sz() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sz(const NodePath self, float sz)\n"
      "set_sz(const NodePath self, const NodePath other, float sz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_sz_734_comment =
  "C++ Interface:\n"
  "set_sz(const NodePath self, float sz)\n"
  "set_sz(const NodePath self, const NodePath other, float sz)\n";
#else
static const char *Dtool_NodePath_set_sz_734_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 NodePath::get_scale(void) const
 * LVecBase3 NodePath::get_scale(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_scale_735(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-LVecBase3 NodePath::get_scale(void) const
      LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_scale)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-LVecBase3 NodePath::get_scale(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_scale", true, true);
      if (arg_this != nullptr) {
        LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_scale)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_scale() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_scale(NodePath self)\n"
      "get_scale(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_scale_735_comment =
  "C++ Interface:\n"
  "get_scale(NodePath self)\n"
  "get_scale(NodePath self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Retrieves the scale component of the transform.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the relative scale of the bottom node as seen from the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_scale_735_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_sx(void) const
 * inline PN_stdfloat NodePath::get_sx(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_sx_736(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_sx(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_sx)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_sx(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_sx", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_sx)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_sx() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sx(NodePath self)\n"
      "get_sx(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_sx_736_comment =
  "C++ Interface:\n"
  "get_sx(NodePath self)\n"
  "get_sx(NodePath self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Returns the relative scale of the referenced node as seen from the other\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_sx_736_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_sy(void) const
 * inline PN_stdfloat NodePath::get_sy(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_sy_737(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_sy(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_sy)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_sy(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_sy", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_sy)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_sy() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sy(NodePath self)\n"
      "get_sy(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_sy_737_comment =
  "C++ Interface:\n"
  "get_sy(NodePath self)\n"
  "get_sy(NodePath self, const NodePath other)\n";
#else
static const char *Dtool_NodePath_get_sy_737_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_sz(void) const
 * inline PN_stdfloat NodePath::get_sz(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_sz_738(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_sz(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_sz)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_sz(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_sz", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_sz)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_sz() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sz(NodePath self)\n"
      "get_sz(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_sz_738_comment =
  "C++ Interface:\n"
  "get_sz(NodePath self)\n"
  "get_sz(NodePath self, const NodePath other)\n";
#else
static const char *Dtool_NodePath_get_sz_738_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_shear(LVecBase3 const &shear)
 * void NodePath::set_shear(NodePath const &other, LVecBase3 const &shear)
 * inline void NodePath::set_shear(NodePath const &other, PN_stdfloat shxy, PN_stdfloat shxz, PN_stdfloat shyz)
 * inline void NodePath::set_shear(PN_stdfloat shxy, PN_stdfloat shxz, PN_stdfloat shyz)
 */
static PyObject *Dtool_NodePath_set_shear_739(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_shear")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "shear")) {
        // 1-void NodePath::set_shear(LVecBase3 const &shear)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.set_shear", "LVecBase3f");
        }
        ((*local_this).set_shear)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_shear(NodePath const &other, LVecBase3 const &shear)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "shear", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_shear", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_shear", true, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_shear", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_shear)(*param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-inline void NodePath::set_shear(PN_stdfloat shxy, PN_stdfloat shxz, PN_stdfloat shyz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"shxy", "shxz", "shyz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_shear", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_shear)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void NodePath::set_shear(NodePath const &other, PN_stdfloat shxy, PN_stdfloat shxz, PN_stdfloat shyz)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"other", "shxy", "shxz", "shyz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:set_shear", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_shear", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_shear)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shear() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shear(const NodePath self, const LVecBase3f shear)\n"
      "set_shear(const NodePath self, const NodePath other, const LVecBase3f shear)\n"
      "set_shear(const NodePath self, float shxy, float shxz, float shyz)\n"
      "set_shear(const NodePath self, const NodePath other, float shxy, float shxz, float shyz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_shear_739_comment =
  "C++ Interface:\n"
  "set_shear(const NodePath self, const LVecBase3f shear)\n"
  "set_shear(const NodePath self, const NodePath other, const LVecBase3f shear)\n"
  "set_shear(const NodePath self, float shxy, float shxz, float shyz)\n"
  "set_shear(const NodePath self, const NodePath other, float shxy, float shxz, float shyz)\n"
  "\n"
  "/**\n"
  " * Sets the shear component of the transform, leaving translation, rotation,\n"
  " * and scale untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the shear component of the transform, relative to the other node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the shear component of the transform, leaving translation and rotation\n"
  " * untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the shear component of the transform, relative to the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_shear_739_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_shxy(NodePath const &other, PN_stdfloat shxy)
 * void NodePath::set_shxy(PN_stdfloat shxy)
 */
static PyObject *Dtool_NodePath_set_shxy_740(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_shxy")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "shxy")) {
        // 1-void NodePath::set_shxy(PN_stdfloat shxy)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_shxy)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_shxy(NodePath const &other, PN_stdfloat shxy)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "shxy", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_shxy", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_shxy", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_shxy)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shxy() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shxy(const NodePath self, float shxy)\n"
      "set_shxy(const NodePath self, const NodePath other, float shxy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_shxy_740_comment =
  "C++ Interface:\n"
  "set_shxy(const NodePath self, float shxy)\n"
  "set_shxy(const NodePath self, const NodePath other, float shxy)\n";
#else
static const char *Dtool_NodePath_set_shxy_740_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_shxz(NodePath const &other, PN_stdfloat shxz)
 * void NodePath::set_shxz(PN_stdfloat shxz)
 */
static PyObject *Dtool_NodePath_set_shxz_741(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_shxz")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "shxz")) {
        // 1-void NodePath::set_shxz(PN_stdfloat shxz)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_shxz)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_shxz(NodePath const &other, PN_stdfloat shxz)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "shxz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_shxz", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_shxz", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_shxz)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shxz() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shxz(const NodePath self, float shxz)\n"
      "set_shxz(const NodePath self, const NodePath other, float shxz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_shxz_741_comment =
  "C++ Interface:\n"
  "set_shxz(const NodePath self, float shxz)\n"
  "set_shxz(const NodePath self, const NodePath other, float shxz)\n";
#else
static const char *Dtool_NodePath_set_shxz_741_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_shyz(NodePath const &other, PN_stdfloat shyz)
 * void NodePath::set_shyz(PN_stdfloat shyz)
 */
static PyObject *Dtool_NodePath_set_shyz_742(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_shyz")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "shyz")) {
        // 1-void NodePath::set_shyz(PN_stdfloat shyz)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_shyz)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_shyz(NodePath const &other, PN_stdfloat shyz)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "shyz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_shyz", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_shyz", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_shyz)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shyz() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shyz(const NodePath self, float shyz)\n"
      "set_shyz(const NodePath self, const NodePath other, float shyz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_shyz_742_comment =
  "C++ Interface:\n"
  "set_shyz(const NodePath self, float shyz)\n"
  "set_shyz(const NodePath self, const NodePath other, float shyz)\n";
#else
static const char *Dtool_NodePath_set_shyz_742_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 NodePath::get_shear(void) const
 * LVecBase3 NodePath::get_shear(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_shear_743(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-LVecBase3 NodePath::get_shear(void) const
      LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_shear)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-LVecBase3 NodePath::get_shear(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_shear", true, true);
      if (arg_this != nullptr) {
        LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_shear)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_shear() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shear(NodePath self)\n"
      "get_shear(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_shear_743_comment =
  "C++ Interface:\n"
  "get_shear(NodePath self)\n"
  "get_shear(NodePath self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Retrieves the shear component of the transform.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the relative shear of the bottom node as seen from the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_shear_743_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_shxy(void) const
 * inline PN_stdfloat NodePath::get_shxy(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_shxy_744(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_shxy(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_shxy)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_shxy(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_shxy", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_shxy)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_shxy() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shxy(NodePath self)\n"
      "get_shxy(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_shxy_744_comment =
  "C++ Interface:\n"
  "get_shxy(NodePath self)\n"
  "get_shxy(NodePath self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Returns the relative shear of the referenced node as seen from the other\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_shxy_744_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_shxz(void) const
 * inline PN_stdfloat NodePath::get_shxz(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_shxz_745(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_shxz(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_shxz)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_shxz(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_shxz", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_shxz)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_shxz() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shxz(NodePath self)\n"
      "get_shxz(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_shxz_745_comment =
  "C++ Interface:\n"
  "get_shxz(NodePath self)\n"
  "get_shxz(NodePath self, const NodePath other)\n";
#else
static const char *Dtool_NodePath_get_shxz_745_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_shyz(void) const
 * inline PN_stdfloat NodePath::get_shyz(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_shyz_746(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PN_stdfloat NodePath::get_shyz(void) const
      PN_stdfloat return_value = ((*(const NodePath*)local_this).get_shyz)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PN_stdfloat NodePath::get_shyz(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_shyz", true, true);
      if (arg_this != nullptr) {
        PN_stdfloat return_value = ((*(const NodePath*)local_this).get_shyz)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_shyz() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shyz(NodePath self)\n"
      "get_shyz(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_shyz_746_comment =
  "C++ Interface:\n"
  "get_shyz(NodePath self)\n"
  "get_shyz(NodePath self, const NodePath other)\n";
#else
static const char *Dtool_NodePath_get_shyz_746_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_pos_hpr(LVecBase3 const &pos, LVecBase3 const &hpr)
 * void NodePath::set_pos_hpr(NodePath const &other, LVecBase3 const &pos, LVecBase3 const &hpr)
 * inline void NodePath::set_pos_hpr(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 * inline void NodePath::set_pos_hpr(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_NodePath_set_pos_hpr_747(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_pos_hpr")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void NodePath::set_pos_hpr(LVecBase3 const &pos, LVecBase3 const &hpr)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"pos", "hpr", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_pos_hpr", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_pos_hpr", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_hpr", "LVecBase3f");
        }
        ((*local_this).set_pos_hpr)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-void NodePath::set_pos_hpr(NodePath const &other, LVecBase3 const &pos, LVecBase3 const &hpr)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"other", "pos", "hpr", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_pos_hpr", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_pos_hpr", true, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_hpr", "LVecBase3f");
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_pos_hpr", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_pos_hpr)(*param1_this, *param2_this, *param3_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 6:
    {
      // 1-inline void NodePath::set_pos_hpr(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "z", "h", "p", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set_pos_hpr", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).set_pos_hpr)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
        return Dtool_Return_None();
      }
    }
    break;
  case 7:
    {
      // 1-inline void NodePath::set_pos_hpr(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      static const char *keyword_list[] = {"other", "x", "y", "z", "h", "p", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offffff:set_pos_hpr", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_pos_hpr", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_pos_hpr)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos_hpr() takes 3, 4, 7 or 8 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos_hpr(const NodePath self, const LVecBase3f pos, const LVecBase3f hpr)\n"
      "set_pos_hpr(const NodePath self, const NodePath other, const LVecBase3f pos, const LVecBase3f hpr)\n"
      "set_pos_hpr(const NodePath self, float x, float y, float z, float h, float p, float r)\n"
      "set_pos_hpr(const NodePath self, const NodePath other, float x, float y, float z, float h, float p, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_pos_hpr_747_comment =
  "C++ Interface:\n"
  "set_pos_hpr(const NodePath self, const LVecBase3f pos, const LVecBase3f hpr)\n"
  "set_pos_hpr(const NodePath self, const NodePath other, const LVecBase3f pos, const LVecBase3f hpr)\n"
  "set_pos_hpr(const NodePath self, float x, float y, float z, float h, float p, float r)\n"
  "set_pos_hpr(const NodePath self, const NodePath other, float x, float y, float z, float h, float p, float r)\n"
  "\n"
  "/**\n"
  " * Sets the translation and rotation component of the transform, leaving scale\n"
  " * untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the translation and rotation component of the transform, relative to\n"
  " * the other node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the translation and rotation component of the transform, leaving scale\n"
  " * untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the translation and rotation component of the transform, relative to\n"
  " * the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_pos_hpr_747_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_pos_quat(LVecBase3 const &pos, LQuaternion const &quat)
 * void NodePath::set_pos_quat(NodePath const &other, LVecBase3 const &pos, LQuaternion const &quat)
 */
static PyObject *Dtool_NodePath_set_pos_quat_748(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_pos_quat")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void NodePath::set_pos_quat(LVecBase3 const &pos, LQuaternion const &quat)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"pos", "quat", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_pos_quat", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_pos_quat", "LVecBase3f");
        }
        LQuaternionf param2_local;
        LQuaternion const *param2_this = Dtool_Coerce_LQuaternionf(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_quat", "LQuaternionf");
        }
        ((*local_this).set_pos_quat)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-void NodePath::set_pos_quat(NodePath const &other, LVecBase3 const &pos, LQuaternion const &quat)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"other", "pos", "quat", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_pos_quat", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_pos_quat", true, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_quat", "LVecBase3f");
        }
        LQuaternionf param3_local;
        LQuaternion const *param3_this = Dtool_Coerce_LQuaternionf(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_pos_quat", "LQuaternionf");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_pos_quat)(*param1_this, *param2_this, *param3_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos_quat() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos_quat(const NodePath self, const LVecBase3f pos, const LQuaternionf quat)\n"
      "set_pos_quat(const NodePath self, const NodePath other, const LVecBase3f pos, const LQuaternionf quat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_pos_quat_748_comment =
  "C++ Interface:\n"
  "set_pos_quat(const NodePath self, const LVecBase3f pos, const LQuaternionf quat)\n"
  "set_pos_quat(const NodePath self, const NodePath other, const LVecBase3f pos, const LQuaternionf quat)\n"
  "\n"
  "/**\n"
  " * Sets the translation and rotation component of the transform, leaving scale\n"
  " * untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the translation and rotation component of the transform, relative to\n"
  " * the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_pos_quat_748_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_hpr_scale(LVecBase3 const &hpr, LVecBase3 const &scale)
 * void NodePath::set_hpr_scale(NodePath const &other, LVecBase3 const &hpr, LVecBase3 const &scale)
 * inline void NodePath::set_hpr_scale(NodePath const &other, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
 * inline void NodePath::set_hpr_scale(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
 */
static PyObject *Dtool_NodePath_set_hpr_scale_749(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_hpr_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void NodePath::set_hpr_scale(LVecBase3 const &hpr, LVecBase3 const &scale)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"hpr", "scale", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_hpr_scale", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_hpr_scale", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_hpr_scale", "LVecBase3f");
        }
        ((*local_this).set_hpr_scale)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-void NodePath::set_hpr_scale(NodePath const &other, LVecBase3 const &hpr, LVecBase3 const &scale)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"other", "hpr", "scale", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_hpr_scale", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_hpr_scale", true, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_hpr_scale", "LVecBase3f");
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_hpr_scale", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_hpr_scale)(*param1_this, *param2_this, *param3_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 6:
    {
      // 1-inline void NodePath::set_hpr_scale(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"h", "p", "r", "sx", "sy", "sz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set_hpr_scale", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).set_hpr_scale)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
        return Dtool_Return_None();
      }
    }
    break;
  case 7:
    {
      // 1-inline void NodePath::set_hpr_scale(NodePath const &other, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      static const char *keyword_list[] = {"other", "h", "p", "r", "sx", "sy", "sz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offffff:set_hpr_scale", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_hpr_scale", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_hpr_scale)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_hpr_scale() takes 3, 4, 7 or 8 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hpr_scale(const NodePath self, const LVecBase3f hpr, const LVecBase3f scale)\n"
      "set_hpr_scale(const NodePath self, const NodePath other, const LVecBase3f hpr, const LVecBase3f scale)\n"
      "set_hpr_scale(const NodePath self, float h, float p, float r, float sx, float sy, float sz)\n"
      "set_hpr_scale(const NodePath self, const NodePath other, float h, float p, float r, float sx, float sy, float sz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_hpr_scale_749_comment =
  "C++ Interface:\n"
  "set_hpr_scale(const NodePath self, const LVecBase3f hpr, const LVecBase3f scale)\n"
  "set_hpr_scale(const NodePath self, const NodePath other, const LVecBase3f hpr, const LVecBase3f scale)\n"
  "set_hpr_scale(const NodePath self, float h, float p, float r, float sx, float sy, float sz)\n"
  "set_hpr_scale(const NodePath self, const NodePath other, float h, float p, float r, float sx, float sy, float sz)\n"
  "\n"
  "/**\n"
  " * Sets the rotation and scale components of the transform, leaving\n"
  " * translation untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the rotation and scale components of the transform, leaving\n"
  " * translation untouched.  This, or set_pos_hpr_scale, is the preferred way to\n"
  " * update a transform when both hpr and scale are to be changed.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the rotation and scale components of the transform, leaving\n"
  " * translation untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the rotation and scale components of the transform, leaving\n"
  " * translation untouched.  This, or set_pos_hpr_scale, is the preferred way to\n"
  " * update a transform when both hpr and scale are to be changed.\n"
  " */";
#else
static const char *Dtool_NodePath_set_hpr_scale_749_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_quat_scale(LQuaternion const &quat, LVecBase3 const &scale)
 * void NodePath::set_quat_scale(NodePath const &other, LQuaternion const &quat, LVecBase3 const &scale)
 */
static PyObject *Dtool_NodePath_set_quat_scale_750(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_quat_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void NodePath::set_quat_scale(LQuaternion const &quat, LVecBase3 const &scale)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"quat", "scale", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_quat_scale", (char **)keyword_list, &param1, &param2)) {
        LQuaternionf param1_local;
        LQuaternion const *param1_this = Dtool_Coerce_LQuaternionf(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_quat_scale", "LQuaternionf");
        }
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_quat_scale", "LVecBase3f");
        }
        ((*local_this).set_quat_scale)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-void NodePath::set_quat_scale(NodePath const &other, LQuaternion const &quat, LVecBase3 const &scale)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"other", "quat", "scale", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_quat_scale", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_quat_scale", true, true);
        LQuaternionf param2_local;
        LQuaternion const *param2_this = Dtool_Coerce_LQuaternionf(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_quat_scale", "LQuaternionf");
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_quat_scale", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_quat_scale)(*param1_this, *param2_this, *param3_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_quat_scale() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quat_scale(const NodePath self, const LQuaternionf quat, const LVecBase3f scale)\n"
      "set_quat_scale(const NodePath self, const NodePath other, const LQuaternionf quat, const LVecBase3f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_quat_scale_750_comment =
  "C++ Interface:\n"
  "set_quat_scale(const NodePath self, const LQuaternionf quat, const LVecBase3f scale)\n"
  "set_quat_scale(const NodePath self, const NodePath other, const LQuaternionf quat, const LVecBase3f scale)\n"
  "\n"
  "/**\n"
  " * Sets the rotation and scale components of the transform, leaving\n"
  " * translation untouched.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the rotation and scale components of the transform, leaving\n"
  " * translation untouched.  This, or set_pos_quat_scale, is the preferred way\n"
  " * to update a transform when both quat and scale are to be changed.\n"
  " */";
#else
static const char *Dtool_NodePath_set_quat_scale_750_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_pos_hpr_scale(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
 * void NodePath::set_pos_hpr_scale(NodePath const &other, LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
 * inline void NodePath::set_pos_hpr_scale(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
 * inline void NodePath::set_pos_hpr_scale(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
 */
static PyObject *Dtool_NodePath_set_pos_hpr_scale_751(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_pos_hpr_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-void NodePath::set_pos_hpr_scale(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"pos", "hpr", "scale", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_pos_hpr_scale", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_pos_hpr_scale", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_hpr_scale", "LVecBase3f");
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_pos_hpr_scale", "LVecBase3f");
        }
        ((*local_this).set_pos_hpr_scale)(*param1_this, *param2_this, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-void NodePath::set_pos_hpr_scale(NodePath const &other, LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"other", "pos", "hpr", "scale", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_pos_hpr_scale", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_pos_hpr_scale", true, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_hpr_scale", "LVecBase3f");
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_pos_hpr_scale", "LVecBase3f");
        }
        LVecBase3f param4_local;
        LVecBase3 const *param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
        if (!(param4_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "NodePath.set_pos_hpr_scale", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_pos_hpr_scale)(*param1_this, *param2_this, *param3_this, *param4_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 9:
    {
      // 1-inline void NodePath::set_pos_hpr_scale(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      float param9;
      static const char *keyword_list[] = {"x", "y", "z", "h", "p", "r", "sx", "sy", "sz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fffffffff:set_pos_hpr_scale", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
        ((*local_this).set_pos_hpr_scale)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, (PN_stdfloat)param9);
        return Dtool_Return_None();
      }
    }
    break;
  case 10:
    {
      // 1-inline void NodePath::set_pos_hpr_scale(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      float param9;
      float param10;
      static const char *keyword_list[] = {"other", "x", "y", "z", "h", "p", "r", "sx", "sy", "sz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offfffffff:set_pos_hpr_scale", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_pos_hpr_scale", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_pos_hpr_scale)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, (PN_stdfloat)param9, (PN_stdfloat)param10);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos_hpr_scale() takes 4, 5, 10 or 11 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos_hpr_scale(const NodePath self, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n"
      "set_pos_hpr_scale(const NodePath self, const NodePath other, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n"
      "set_pos_hpr_scale(const NodePath self, float x, float y, float z, float h, float p, float r, float sx, float sy, float sz)\n"
      "set_pos_hpr_scale(const NodePath self, const NodePath other, float x, float y, float z, float h, float p, float r, float sx, float sy, float sz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_pos_hpr_scale_751_comment =
  "C++ Interface:\n"
  "set_pos_hpr_scale(const NodePath self, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n"
  "set_pos_hpr_scale(const NodePath self, const NodePath other, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n"
  "set_pos_hpr_scale(const NodePath self, float x, float y, float z, float h, float p, float r, float sx, float sy, float sz)\n"
  "set_pos_hpr_scale(const NodePath self, const NodePath other, float x, float y, float z, float h, float p, float r, float sx, float sy, float sz)\n"
  "\n"
  "/**\n"
  " * Completely replaces the transform with new translation, rotation, and scale\n"
  " * components.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Completely replaces the transform with new translation, rotation, and scale\n"
  " * components, relative to the other node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the translation, rotation, and scale components, implicitly\n"
  " * setting shear to 0.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Completely replaces the transform with new translation, rotation, and scale\n"
  " * components, relative to the other node, implicitly setting shear to 0.\n"
  " */";
#else
static const char *Dtool_NodePath_set_pos_hpr_scale_751_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_pos_quat_scale(LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale)
 * void NodePath::set_pos_quat_scale(NodePath const &other, LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale)
 */
static PyObject *Dtool_NodePath_set_pos_quat_scale_752(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_pos_quat_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-void NodePath::set_pos_quat_scale(LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"pos", "quat", "scale", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_pos_quat_scale", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_pos_quat_scale", "LVecBase3f");
        }
        LQuaternionf param2_local;
        LQuaternion const *param2_this = Dtool_Coerce_LQuaternionf(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_quat_scale", "LQuaternionf");
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_pos_quat_scale", "LVecBase3f");
        }
        ((*local_this).set_pos_quat_scale)(*param1_this, *param2_this, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-void NodePath::set_pos_quat_scale(NodePath const &other, LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"other", "pos", "quat", "scale", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_pos_quat_scale", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_pos_quat_scale", true, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_quat_scale", "LVecBase3f");
        }
        LQuaternionf param3_local;
        LQuaternion const *param3_this = Dtool_Coerce_LQuaternionf(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_pos_quat_scale", "LQuaternionf");
        }
        LVecBase3f param4_local;
        LVecBase3 const *param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
        if (!(param4_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "NodePath.set_pos_quat_scale", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_pos_quat_scale)(*param1_this, *param2_this, *param3_this, *param4_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos_quat_scale() takes 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos_quat_scale(const NodePath self, const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale)\n"
      "set_pos_quat_scale(const NodePath self, const NodePath other, const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_pos_quat_scale_752_comment =
  "C++ Interface:\n"
  "set_pos_quat_scale(const NodePath self, const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale)\n"
  "set_pos_quat_scale(const NodePath self, const NodePath other, const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale)\n"
  "\n"
  "/**\n"
  " * Replaces the translation, rotation, and scale components, implicitly\n"
  " * setting shear to 0.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Completely replaces the transform with new translation, rotation, and scale\n"
  " * components, relative to the other node, implicitly setting shear to 0.\n"
  " */";
#else
static const char *Dtool_NodePath_set_pos_quat_scale_752_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_pos_hpr_scale_shear(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale, LVecBase3 const &shear)
 * void NodePath::set_pos_hpr_scale_shear(NodePath const &other, LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale, LVecBase3 const &shear)
 */
static PyObject *Dtool_NodePath_set_pos_hpr_scale_shear_753(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_pos_hpr_scale_shear")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 4:
    {
      // 1-void NodePath::set_pos_hpr_scale_shear(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale, LVecBase3 const &shear)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"pos", "hpr", "scale", "shear", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_pos_hpr_scale_shear", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_pos_hpr_scale_shear", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_hpr_scale_shear", "LVecBase3f");
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_pos_hpr_scale_shear", "LVecBase3f");
        }
        LVecBase3f param4_local;
        LVecBase3 const *param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
        if (!(param4_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "NodePath.set_pos_hpr_scale_shear", "LVecBase3f");
        }
        ((*local_this).set_pos_hpr_scale_shear)(*param1_this, *param2_this, *param3_this, *param4_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 5:
    {
      // 1-void NodePath::set_pos_hpr_scale_shear(NodePath const &other, LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale, LVecBase3 const &shear)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      static const char *keyword_list[] = {"other", "pos", "hpr", "scale", "shear", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO:set_pos_hpr_scale_shear", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_pos_hpr_scale_shear", true, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_hpr_scale_shear", "LVecBase3f");
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_pos_hpr_scale_shear", "LVecBase3f");
        }
        LVecBase3f param4_local;
        LVecBase3 const *param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
        if (!(param4_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "NodePath.set_pos_hpr_scale_shear", "LVecBase3f");
        }
        LVecBase3f param5_local;
        LVecBase3 const *param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
        if (!(param5_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param5, 5, "NodePath.set_pos_hpr_scale_shear", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_pos_hpr_scale_shear)(*param1_this, *param2_this, *param3_this, *param4_this, *param5_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos_hpr_scale_shear() takes 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos_hpr_scale_shear(const NodePath self, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale, const LVecBase3f shear)\n"
      "set_pos_hpr_scale_shear(const NodePath self, const NodePath other, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale, const LVecBase3f shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_pos_hpr_scale_shear_753_comment =
  "C++ Interface:\n"
  "set_pos_hpr_scale_shear(const NodePath self, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale, const LVecBase3f shear)\n"
  "set_pos_hpr_scale_shear(const NodePath self, const NodePath other, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale, const LVecBase3f shear)\n"
  "\n"
  "/**\n"
  " * Completely replaces the transform with new translation, rotation, scale,\n"
  " * and shear components.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Completely replaces the transform with new translation, rotation, scale,\n"
  " * and shear components, relative to the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_pos_hpr_scale_shear_753_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_pos_quat_scale_shear(LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale, LVecBase3 const &shear)
 * void NodePath::set_pos_quat_scale_shear(NodePath const &other, LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale, LVecBase3 const &shear)
 */
static PyObject *Dtool_NodePath_set_pos_quat_scale_shear_754(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_pos_quat_scale_shear")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 4:
    {
      // 1-void NodePath::set_pos_quat_scale_shear(LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale, LVecBase3 const &shear)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"pos", "quat", "scale", "shear", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_pos_quat_scale_shear", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_pos_quat_scale_shear", "LVecBase3f");
        }
        LQuaternionf param2_local;
        LQuaternion const *param2_this = Dtool_Coerce_LQuaternionf(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_quat_scale_shear", "LQuaternionf");
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_pos_quat_scale_shear", "LVecBase3f");
        }
        LVecBase3f param4_local;
        LVecBase3 const *param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
        if (!(param4_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "NodePath.set_pos_quat_scale_shear", "LVecBase3f");
        }
        ((*local_this).set_pos_quat_scale_shear)(*param1_this, *param2_this, *param3_this, *param4_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 5:
    {
      // 1-void NodePath::set_pos_quat_scale_shear(NodePath const &other, LVecBase3 const &pos, LQuaternion const &quat, LVecBase3 const &scale, LVecBase3 const &shear)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      static const char *keyword_list[] = {"other", "pos", "quat", "scale", "shear", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO:set_pos_quat_scale_shear", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_pos_quat_scale_shear", true, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_pos_quat_scale_shear", "LVecBase3f");
        }
        LQuaternionf param3_local;
        LQuaternion const *param3_this = Dtool_Coerce_LQuaternionf(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_pos_quat_scale_shear", "LQuaternionf");
        }
        LVecBase3f param4_local;
        LVecBase3 const *param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
        if (!(param4_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "NodePath.set_pos_quat_scale_shear", "LVecBase3f");
        }
        LVecBase3f param5_local;
        LVecBase3 const *param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
        if (!(param5_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param5, 5, "NodePath.set_pos_quat_scale_shear", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_pos_quat_scale_shear)(*param1_this, *param2_this, *param3_this, *param4_this, *param5_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos_quat_scale_shear() takes 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos_quat_scale_shear(const NodePath self, const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale, const LVecBase3f shear)\n"
      "set_pos_quat_scale_shear(const NodePath self, const NodePath other, const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale, const LVecBase3f shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_pos_quat_scale_shear_754_comment =
  "C++ Interface:\n"
  "set_pos_quat_scale_shear(const NodePath self, const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale, const LVecBase3f shear)\n"
  "set_pos_quat_scale_shear(const NodePath self, const NodePath other, const LVecBase3f pos, const LQuaternionf quat, const LVecBase3f scale, const LVecBase3f shear)\n"
  "\n"
  "/**\n"
  " * Completely replaces the transform with new translation, rotation, scale,\n"
  " * and shear components.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Completely replaces the transform with new translation, rotation, scale,\n"
  " * and shear components, relative to the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_pos_quat_scale_shear_754_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_mat(LMatrix4 const &mat)
 * void NodePath::set_mat(NodePath const &other, LMatrix4 const &mat)
 */
static PyObject *Dtool_NodePath_set_mat_755(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_mat")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "mat")) {
        // 1-void NodePath::set_mat(LMatrix4 const &mat)
        LMatrix4f arg_local;
        LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.set_mat", "LMatrix4f");
        }
        ((*local_this).set_mat)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_mat(NodePath const &other, LMatrix4 const &mat)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "mat", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_mat", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_mat", true, true);
        LMatrix4f param2_local;
        LMatrix4 const *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_mat", "LMatrix4f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_mat)(*param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_mat() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mat(const NodePath self, const LMatrix4f mat)\n"
      "set_mat(const NodePath self, const NodePath other, const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_mat_755_comment =
  "C++ Interface:\n"
  "set_mat(const NodePath self, const LMatrix4f mat)\n"
  "set_mat(const NodePath self, const NodePath other, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Directly sets an arbitrary 4x4 transform matrix.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Converts the indicated matrix from the other's coordinate space to the\n"
  " * local coordinate space, and applies it to the node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_mat_755_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::clear_mat(void)
 */
static PyObject *Dtool_NodePath_clear_mat_756(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_mat")) {
    return nullptr;
  }
  // 1-inline void NodePath::clear_mat(void)
  ((*local_this).clear_mat)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_mat_756_comment =
  "C++ Interface:\n"
  "clear_mat(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any transform from the referenced node.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_mat_756_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::has_mat(void) const
 */
static PyObject *Dtool_NodePath_has_mat_757(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::has_mat(void) const
  bool return_value = ((*(const NodePath*)local_this).has_mat)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_mat_757_comment =
  "C++ Interface:\n"
  "has_mat(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a non-identity transform matrix has been applied to the\n"
  " * referenced node, false otherwise.\n"
  " */";
#else
static const char *Dtool_NodePath_has_mat_757_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &NodePath::get_mat(void) const
 * LMatrix4 NodePath::get_mat(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_mat_758(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LMatrix4 const &NodePath::get_mat(void) const
      LMatrix4 const *return_value = &(((*(const NodePath*)local_this).get_mat)());
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-LMatrix4 NodePath::get_mat(NodePath const &other) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_mat", true, true);
      if (arg_this != nullptr) {
        LMatrix4 *return_value = new LMatrix4(((*(const NodePath*)local_this).get_mat)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_mat() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mat(NodePath self)\n"
      "get_mat(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_mat_758_comment =
  "C++ Interface:\n"
  "get_mat(NodePath self)\n"
  "get_mat(NodePath self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Returns the transform matrix that has been applied to the referenced node,\n"
  " * or the identity matrix if no matrix has been applied.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the matrix that describes the coordinate space of the bottom node,\n"
  " * relative to the other path's bottom node's coordinate space.\n"
  " */";
#else
static const char *Dtool_NodePath_get_mat_758_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::look_at(LPoint3 const &point, LVector3 const &up = LVector3::up())
 * void NodePath::look_at(NodePath const &other, LPoint3 const &point = LPoint3(0.0, 0.0, 0.0), LVector3 const &up = LVector3::up())
 * inline void NodePath::look_at(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 * inline void NodePath::look_at(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_NodePath_look_at_759(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.look_at")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 void NodePath::look_at(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "other")) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          if (param1_this != nullptr) {
            ((*local_this).look_at)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 void NodePath::look_at(LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "point")) {
          LPoint3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
          if (param1_this != nullptr) {
            ((*local_this).look_at)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 void NodePath::look_at(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "other")) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          if (param1_this != nullptr) {
            ((*local_this).look_at)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 void NodePath::look_at(LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "point")) {
          LPoint3f param1_local;
          LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
          if ((param1_this != nullptr)) {
            ((*local_this).look_at)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

    }
    break;
  case 2:
    {
      {
        // -2 void NodePath::look_at(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"other", "point", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          LPoint3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LPoint3f);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).look_at)(*param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::look_at(LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"point", "up", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param1, &param2)) {
          LPoint3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
          LVector3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3f);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).look_at)(*param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::look_at(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"other", "point", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          LPoint3f param2_local;
          LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
          if (param1_this != nullptr && (param2_this != nullptr)) {
            ((*local_this).look_at)(*param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::look_at(LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"point", "up", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param1, &param2)) {
          LPoint3f param1_local;
          LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
          LVector3f param2_local;
          LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param1_this != nullptr) && (param2_this != nullptr)) {
            ((*local_this).look_at)(*param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
    {
      {
        // -2 void NodePath::look_at(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"other", "point", "up", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:look_at", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          LPoint3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LPoint3f);
          LVector3 const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVector3f);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ((*local_this).look_at)(*param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::look_at(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
        float param1;
        float param2;
        float param3;
        static const char *keyword_list[] = {"x", "y", "z", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:look_at", (char **)keyword_list, &param1, &param2, &param3)) {
          ((*local_this).look_at)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::look_at(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"other", "point", "up", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:look_at", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          LPoint3f param2_local;
          LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
          LVector3f param3_local;
          LVector3 const *param3_this = Dtool_Coerce_LVector3f(param3, param3_local);
          if (param1_this != nullptr && (param2_this != nullptr) && (param3_this != nullptr)) {
            ((*local_this).look_at)(*param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void NodePath::look_at(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
    }
    break;
  case 4:
    {
      // 1-inline void NodePath::look_at(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"other", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:look_at", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.look_at", true, true);
        if (param1_this != nullptr) {
          ((*local_this).look_at)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "look_at() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "look_at(const NodePath self, const NodePath other)\n"
      "look_at(const NodePath self, const LPoint3f point)\n"
      "look_at(const NodePath self, const NodePath other, const LPoint3f point)\n"
      "look_at(const NodePath self, const LPoint3f point, const LVector3f up)\n"
      "look_at(const NodePath self, const NodePath other, const LPoint3f point, const LVector3f up)\n"
      "look_at(const NodePath self, float x, float y, float z)\n"
      "look_at(const NodePath self, const NodePath other, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_look_at_759_comment =
  "C++ Interface:\n"
  "look_at(const NodePath self, const NodePath other)\n"
  "look_at(const NodePath self, const LPoint3f point)\n"
  "look_at(const NodePath self, const NodePath other, const LPoint3f point)\n"
  "look_at(const NodePath self, const LPoint3f point, const LVector3f up)\n"
  "look_at(const NodePath self, const NodePath other, const LPoint3f point, const LVector3f up)\n"
  "look_at(const NodePath self, float x, float y, float z)\n"
  "look_at(const NodePath self, const NodePath other, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Sets the transform on this NodePath so that it rotates to face the\n"
  " * indicated point in space.  This will overwrite any previously existing\n"
  " * scale on the node, although it will preserve any translation.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the hpr on this NodePath so that it rotates to face the indicated\n"
  " * point in space, which is relative to the other NodePath.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the hpr on this NodePath so that it rotates to face the indicated\n"
  " * point in space.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the transform on this NodePath so that it rotates to face the\n"
  " * indicated point in space, which is relative to the other NodePath.\n"
  " */";
#else
static const char *Dtool_NodePath_look_at_759_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::heads_up(LPoint3 const &point, LVector3 const &up = LVector3::up())
 * void NodePath::heads_up(NodePath const &other, LPoint3 const &point = LPoint3(0.0, 0.0, 0.0), LVector3 const &up = LVector3::up())
 * inline void NodePath::heads_up(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 * inline void NodePath::heads_up(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_NodePath_heads_up_760(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.heads_up")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 void NodePath::heads_up(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "other")) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          if (param1_this != nullptr) {
            ((*local_this).heads_up)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 void NodePath::heads_up(LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "point")) {
          LPoint3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
          if (param1_this != nullptr) {
            ((*local_this).heads_up)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 void NodePath::heads_up(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "other")) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          if (param1_this != nullptr) {
            ((*local_this).heads_up)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 void NodePath::heads_up(LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "point")) {
          LPoint3f param1_local;
          LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
          if ((param1_this != nullptr)) {
            ((*local_this).heads_up)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

    }
    break;
  case 2:
    {
      {
        // -2 void NodePath::heads_up(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"other", "point", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          LPoint3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LPoint3f);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).heads_up)(*param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::heads_up(LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"point", "up", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param1, &param2)) {
          LPoint3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
          LVector3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3f);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).heads_up)(*param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::heads_up(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"other", "point", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          LPoint3f param2_local;
          LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
          if (param1_this != nullptr && (param2_this != nullptr)) {
            ((*local_this).heads_up)(*param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::heads_up(LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"point", "up", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param1, &param2)) {
          LPoint3f param1_local;
          LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
          LVector3f param2_local;
          LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param1_this != nullptr) && (param2_this != nullptr)) {
            ((*local_this).heads_up)(*param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
    {
      {
        // -2 void NodePath::heads_up(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"other", "point", "up", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:heads_up", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          LPoint3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LPoint3f);
          LVector3 const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVector3f);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ((*local_this).heads_up)(*param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::heads_up(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
        float param1;
        float param2;
        float param3;
        static const char *keyword_list[] = {"x", "y", "z", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:heads_up", (char **)keyword_list, &param1, &param2, &param3)) {
          ((*local_this).heads_up)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::heads_up(NodePath const &other, LPoint3 const &point, LVector3 const &up)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"other", "point", "up", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:heads_up", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          LPoint3f param2_local;
          LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
          LVector3f param3_local;
          LVector3 const *param3_this = Dtool_Coerce_LVector3f(param3, param3_local);
          if (param1_this != nullptr && (param2_this != nullptr) && (param3_this != nullptr)) {
            ((*local_this).heads_up)(*param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void NodePath::heads_up(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
    }
    break;
  case 4:
    {
      // 1-inline void NodePath::heads_up(NodePath const &other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"other", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:heads_up", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.heads_up", true, true);
        if (param1_this != nullptr) {
          ((*local_this).heads_up)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "heads_up() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "heads_up(const NodePath self, const NodePath other)\n"
      "heads_up(const NodePath self, const LPoint3f point)\n"
      "heads_up(const NodePath self, const NodePath other, const LPoint3f point)\n"
      "heads_up(const NodePath self, const LPoint3f point, const LVector3f up)\n"
      "heads_up(const NodePath self, const NodePath other, const LPoint3f point, const LVector3f up)\n"
      "heads_up(const NodePath self, float x, float y, float z)\n"
      "heads_up(const NodePath self, const NodePath other, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_heads_up_760_comment =
  "C++ Interface:\n"
  "heads_up(const NodePath self, const NodePath other)\n"
  "heads_up(const NodePath self, const LPoint3f point)\n"
  "heads_up(const NodePath self, const NodePath other, const LPoint3f point)\n"
  "heads_up(const NodePath self, const LPoint3f point, const LVector3f up)\n"
  "heads_up(const NodePath self, const NodePath other, const LPoint3f point, const LVector3f up)\n"
  "heads_up(const NodePath self, float x, float y, float z)\n"
  "heads_up(const NodePath self, const NodePath other, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Behaves like look_at(), but with a strong preference to keeping the up\n"
  " * vector oriented in the indicated \"up\" direction.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Behaves like look_at(), but with a strong preference to keeping the up\n"
  " * vector oriented in the indicated \"up\" direction.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Behaves like look_at(), but with a strong preference to keeping the up\n"
  " * vector oriented in the indicated \"up\" direction.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Behaves like look_at(), but with a strong preference to keeping the up\n"
  " * vector oriented in the indicated \"up\" direction.\n"
  " */";
#else
static const char *Dtool_NodePath_heads_up_760_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3 NodePath::get_relative_point(NodePath const &other, LVecBase3 const &point) const
 */
static PyObject *Dtool_NodePath_get_relative_point_761(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-LPoint3 NodePath::get_relative_point(NodePath const &other, LVecBase3 const &point) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"other", "point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_relative_point", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.get_relative_point", true, true);
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.get_relative_point", "LVecBase3f");
    }
    if (param1_this != nullptr) {
      LPoint3 *return_value = new LPoint3(((*(const NodePath*)local_this).get_relative_point)(*param1_this, *param2_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_relative_point(NodePath self, const NodePath other, const LVecBase3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_relative_point_761_comment =
  "C++ Interface:\n"
  "get_relative_point(NodePath self, const NodePath other, const LVecBase3f point)\n"
  "\n"
  "/**\n"
  " * Given that the indicated point is in the coordinate system of the other\n"
  " * node, returns the same point in this node's coordinate system.\n"
  " */";
#else
static const char *Dtool_NodePath_get_relative_point_761_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 NodePath::get_relative_vector(NodePath const &other, LVecBase3 const &vec) const
 */
static PyObject *Dtool_NodePath_get_relative_vector_762(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-LVector3 NodePath::get_relative_vector(NodePath const &other, LVecBase3 const &vec) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"other", "vec", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_relative_vector", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.get_relative_vector", true, true);
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.get_relative_vector", "LVecBase3f");
    }
    if (param1_this != nullptr) {
      LVector3 *return_value = new LVector3(((*(const NodePath*)local_this).get_relative_vector)(*param1_this, *param2_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_relative_vector(NodePath self, const NodePath other, const LVecBase3f vec)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_relative_vector_762_comment =
  "C++ Interface:\n"
  "get_relative_vector(NodePath self, const NodePath other, const LVecBase3f vec)\n"
  "\n"
  "/**\n"
  " * Given that the indicated vector is in the coordinate system of the other\n"
  " * node, returns the same vector in this node's coordinate system.\n"
  " */";
#else
static const char *Dtool_NodePath_get_relative_vector_762_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_distance(NodePath const &other) const
 */
static PyObject *Dtool_NodePath_get_distance_763(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NodePath::get_distance(NodePath const &other) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.get_distance", true, true);
  if (arg_this != nullptr) {
    PN_stdfloat return_value = ((*(const NodePath*)local_this).get_distance)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_distance(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_distance_763_comment =
  "C++ Interface:\n"
  "get_distance(NodePath self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Returns the straight-line distance between this referenced node's\n"
  " * coordinate frame's origin, and that of the other node's origin.\n"
  " */";
#else
static const char *Dtool_NodePath_get_distance_763_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_color(LColor const &color, int priority = 0)
 * void NodePath::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_color_764(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "color")) {
        // 1-void NodePath::set_color(LColor const &color, int priority)
        LVecBase4f arg_local;
        LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.set_color", "LVecBase4f");
        }
        ((*local_this).set_color)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_color(LColor const &color, int priority)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"color", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_color", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param1_local;
        LColor const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_color", "LVecBase4f");
        }
        ((*local_this).set_color)(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
  case 4:
  case 5:
    {
      // 1-void NodePath::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0)
      float param1;
      float param2;
      float param3;
      float param4 = 1.0;
      int param5 = 0;
      static const char *keyword_list[] = {"r", "g", "b", "a", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff|fi:set_color", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).set_color)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (int)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color() takes 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const NodePath self, const LVecBase4f color)\n"
      "set_color(const NodePath self, const LVecBase4f color, int priority)\n"
      "set_color(const NodePath self, float r, float g, float b, float a, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_color_764_comment =
  "C++ Interface:\n"
  "set_color(const NodePath self, const LVecBase4f color)\n"
  "set_color(const NodePath self, const LVecBase4f color, int priority)\n"
  "set_color(const NodePath self, float r, float g, float b, float a, int priority)\n"
  "\n"
  "/**\n"
  " * Applies a scene-graph color to the referenced node.  This color will apply\n"
  " * to all geometry at this level and below (that does not specify a new color\n"
  " * or a set_color_off()).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Applies a scene-graph color to the referenced node.  This color will apply\n"
  " * to all geometry at this level and below (that does not specify a new color\n"
  " * or a set_color_off()).\n"
  " */";
#else
static const char *Dtool_NodePath_set_color_764_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_color_off(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_color_off_765(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_color_off")) {
    return nullptr;
  }
  // 1-void NodePath::set_color_off(int priority = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:set_color_off", (char **)keyword_list, &param1)) {
    ((*local_this).set_color_off)((int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_off(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_color_off_765_comment =
  "C++ Interface:\n"
  "set_color_off(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render using the geometry\n"
  " * color.  This is normally the default, but it may be useful to use this to\n"
  " * contradict set_color() at a higher node level (or, with a priority, to\n"
  " * override a set_color() at a lower level).\n"
  " */";
#else
static const char *Dtool_NodePath_set_color_off_765_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_color(void)
 */
static PyObject *Dtool_NodePath_clear_color_766(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_color")) {
    return nullptr;
  }
  // 1-void NodePath::clear_color(void)
  ((*local_this).clear_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_color_766_comment =
  "C++ Interface:\n"
  "clear_color(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any color adjustment from the node.  This allows the\n"
  " * natural color of the geometry, or whatever color transitions might be\n"
  " * otherwise affecting the geometry, to show instead.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_color_766_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_color(void) const
 */
static PyObject *Dtool_NodePath_has_color_767(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_color(void) const
  bool return_value = ((*(const NodePath*)local_this).has_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_color_767_comment =
  "C++ Interface:\n"
  "has_color(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a color has been applied to the given node, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_NodePath_has_color_767_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LColor NodePath::get_color(void) const
 */
static PyObject *Dtool_NodePath_get_color_768(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-LColor NodePath::get_color(void) const
  LColor *return_value = new LColor(((*(const NodePath*)local_this).get_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_color_768_comment =
  "C++ Interface:\n"
  "get_color(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the color that has been assigned to the node, or black if no color\n"
  " * has been assigned.\n"
  " */";
#else
static const char *Dtool_NodePath_get_color_768_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_color_scale(void) const
 */
static PyObject *Dtool_NodePath_has_color_scale_769(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_color_scale(void) const
  bool return_value = ((*(const NodePath*)local_this).has_color_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_color_scale_769_comment =
  "C++ Interface:\n"
  "has_color_scale(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a color scale has been applied to the referenced node,\n"
  " * false otherwise.  It is still possible that color at this node might have\n"
  " * been scaled by an ancestor node.\n"
  " */";
#else
static const char *Dtool_NodePath_has_color_scale_769_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_color_scale(void)
 */
static PyObject *Dtool_NodePath_clear_color_scale_770(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_color_scale")) {
    return nullptr;
  }
  // 1-void NodePath::clear_color_scale(void)
  ((*local_this).clear_color_scale)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_color_scale_770_comment =
  "C++ Interface:\n"
  "clear_color_scale(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any color scale from the referenced node.  This is\n"
  " * preferable to simply setting the color scale to identity, as it also\n"
  " * removes the overhead associated with having a color scale at all.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_color_scale_770_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_color_scale(LVecBase4 const &scale, int priority = 0)
 * inline void NodePath::set_color_scale(PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz, PN_stdfloat sa, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_color_scale_771(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_color_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "scale")) {
        // 1-void NodePath::set_color_scale(LVecBase4 const &scale, int priority)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.set_color_scale", "LVecBase4f");
        }
        ((*local_this).set_color_scale)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_color_scale(LVecBase4 const &scale, int priority)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"scale", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_color_scale", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param1_local;
        LVecBase4 const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_color_scale", "LVecBase4f");
        }
        ((*local_this).set_color_scale)(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
  case 5:
    {
      // 1-inline void NodePath::set_color_scale(PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz, PN_stdfloat sa, int priority = 0)
      float param1;
      float param2;
      float param3;
      float param4;
      int param5 = 0;
      static const char *keyword_list[] = {"sx", "sy", "sz", "sa", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff|i:set_color_scale", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).set_color_scale)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (int)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color_scale() takes 2, 3, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_scale(const NodePath self, const LVecBase4f scale)\n"
      "set_color_scale(const NodePath self, const LVecBase4f scale, int priority)\n"
      "set_color_scale(const NodePath self, float sx, float sy, float sz, float sa, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_color_scale_771_comment =
  "C++ Interface:\n"
  "set_color_scale(const NodePath self, const LVecBase4f scale)\n"
  "set_color_scale(const NodePath self, const LVecBase4f scale, int priority)\n"
  "set_color_scale(const NodePath self, float sx, float sy, float sz, float sa, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the color scale component of the transform\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the color scale component of the transform, leaving translation and\n"
  " * rotation untouched.\n"
  " */";
#else
static const char *Dtool_NodePath_set_color_scale_771_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::compose_color_scale(LVecBase4 const &scale, int priority = 0)
 * inline void NodePath::compose_color_scale(PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz, PN_stdfloat sa, int priority = 0)
 */
static PyObject *Dtool_NodePath_compose_color_scale_772(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.compose_color_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "scale")) {
        // 1-void NodePath::compose_color_scale(LVecBase4 const &scale, int priority)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.compose_color_scale", "LVecBase4f");
        }
        ((*local_this).compose_color_scale)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::compose_color_scale(LVecBase4 const &scale, int priority)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"scale", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:compose_color_scale", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param1_local;
        LVecBase4 const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.compose_color_scale", "LVecBase4f");
        }
        ((*local_this).compose_color_scale)(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
  case 5:
    {
      // 1-inline void NodePath::compose_color_scale(PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz, PN_stdfloat sa, int priority = 0)
      float param1;
      float param2;
      float param3;
      float param4;
      int param5 = 0;
      static const char *keyword_list[] = {"sx", "sy", "sz", "sa", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff|i:compose_color_scale", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).compose_color_scale)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (int)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compose_color_scale() takes 2, 3, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compose_color_scale(const NodePath self, const LVecBase4f scale)\n"
      "compose_color_scale(const NodePath self, const LVecBase4f scale, int priority)\n"
      "compose_color_scale(const NodePath self, float sx, float sy, float sz, float sa, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_compose_color_scale_772_comment =
  "C++ Interface:\n"
  "compose_color_scale(const NodePath self, const LVecBase4f scale)\n"
  "compose_color_scale(const NodePath self, const LVecBase4f scale, int priority)\n"
  "compose_color_scale(const NodePath self, float sx, float sy, float sz, float sa, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the color scale component of the transform\n"
  " */\n"
  "\n"
  "/**\n"
  " * multiplies the color scale component of the transform, with previous color\n"
  " * scale leaving translation and rotation untouched.\n"
  " */";
#else
static const char *Dtool_NodePath_compose_color_scale_772_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_color_scale_off(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_color_scale_off_773(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_color_scale_off")) {
    return nullptr;
  }
  // 1-void NodePath::set_color_scale_off(int priority = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:set_color_scale_off", (char **)keyword_list, &param1)) {
    ((*local_this).set_color_scale_off)((int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_scale_off(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_color_scale_off_773_comment =
  "C++ Interface:\n"
  "set_color_scale_off(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " * Disables any color scale attribute inherited from above.  This is not the\n"
  " * same thing as clear_color_scale(), which undoes any previous\n"
  " * set_color_scale() operation on this node; rather, this actively disables\n"
  " * any set_color_scale() that might be inherited from a parent node.  This\n"
  " * also disables set_alpha_scale() at the same time.\n"
  " *\n"
  " * It is legal to specify a new color scale on the same node with a subsequent\n"
  " * call to set_color_scale() or set_alpha_scale(); this new scale will apply\n"
  " * to lower geometry.\n"
  " */";
#else
static const char *Dtool_NodePath_set_color_scale_off_773_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_alpha_scale(PN_stdfloat scale, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_alpha_scale_774(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_alpha_scale")) {
    return nullptr;
  }
  // 1-void NodePath::set_alpha_scale(PN_stdfloat scale, int priority = 0)
  float param1;
  int param2 = 0;
  static const char *keyword_list[] = {"scale", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "f|i:set_alpha_scale", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_alpha_scale)((PN_stdfloat)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_scale(const NodePath self, float scale, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_alpha_scale_774_comment =
  "C++ Interface:\n"
  "set_alpha_scale(const NodePath self, float scale, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the alpha scale component of the transform without (much) affecting\n"
  " * the color scale.  Note that any priority specified will also apply to the\n"
  " * color scale.\n"
  " */";
#else
static const char *Dtool_NodePath_set_alpha_scale_774_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_all_color_scale(PN_stdfloat scale, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_all_color_scale_775(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_all_color_scale")) {
    return nullptr;
  }
  // 1-void NodePath::set_all_color_scale(PN_stdfloat scale, int priority = 0)
  float param1;
  int param2 = 0;
  static const char *keyword_list[] = {"scale", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "f|i:set_all_color_scale", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_all_color_scale)((PN_stdfloat)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_all_color_scale(const NodePath self, float scale, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_all_color_scale_775_comment =
  "C++ Interface:\n"
  "set_all_color_scale(const NodePath self, float scale, int priority)\n"
  "\n"
  "/**\n"
  " * Scales all the color components of the object by the same amount, darkening\n"
  " * the object, without (much) affecting alpha.  Note that any priority\n"
  " * specified will also apply to the alpha scale.\n"
  " */";
#else
static const char *Dtool_NodePath_set_all_color_scale_775_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_sr(PN_stdfloat sr)
 */
static PyObject *Dtool_NodePath_set_sr_776(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_sr")) {
    return nullptr;
  }
  // 1-inline void NodePath::set_sr(PN_stdfloat sr)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_sr)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sr(const NodePath self, float sr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_sr_776_comment =
  "C++ Interface:\n"
  "set_sr(const NodePath self, float sr)\n"
  "\n"
  "/**\n"
  " * Sets the red scale component of the transform\n"
  " */";
#else
static const char *Dtool_NodePath_set_sr_776_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_sg(PN_stdfloat sg)
 */
static PyObject *Dtool_NodePath_set_sg_777(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_sg")) {
    return nullptr;
  }
  // 1-inline void NodePath::set_sg(PN_stdfloat sg)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_sg)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sg(const NodePath self, float sg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_sg_777_comment =
  "C++ Interface:\n"
  "set_sg(const NodePath self, float sg)\n"
  "\n"
  "/**\n"
  " * Sets the alpha scale component of the transform\n"
  " */";
#else
static const char *Dtool_NodePath_set_sg_777_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_sb(PN_stdfloat sb)
 */
static PyObject *Dtool_NodePath_set_sb_778(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_sb")) {
    return nullptr;
  }
  // 1-inline void NodePath::set_sb(PN_stdfloat sb)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_sb)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sb(const NodePath self, float sb)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_sb_778_comment =
  "C++ Interface:\n"
  "set_sb(const NodePath self, float sb)\n"
  "\n"
  "/**\n"
  " * Sets the blue scale component of the transform\n"
  " */";
#else
static const char *Dtool_NodePath_set_sb_778_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_sa(PN_stdfloat sa)
 */
static PyObject *Dtool_NodePath_set_sa_779(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_sa")) {
    return nullptr;
  }
  // 1-inline void NodePath::set_sa(PN_stdfloat sa)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_sa)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sa(const NodePath self, float sa)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_sa_779_comment =
  "C++ Interface:\n"
  "set_sa(const NodePath self, float sa)\n"
  "\n"
  "/**\n"
  " * Sets the alpha scale component of the transform\n"
  " */";
#else
static const char *Dtool_NodePath_set_sa_779_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase4 const &NodePath::get_color_scale(void) const
 */
static PyObject *Dtool_NodePath_get_color_scale_780(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-LVecBase4 const &NodePath::get_color_scale(void) const
  LVecBase4 const *return_value = &(((*(const NodePath*)local_this).get_color_scale)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_color_scale_780_comment =
  "C++ Interface:\n"
  "get_color_scale(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the complete color scale vector that has been applied to this node\n"
  " * via a previous call to set_color_scale() and/or set_alpha_scale(), or all\n"
  " * 1's (identity) if no scale has been applied to this particular node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_color_scale_780_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_sr(void) const
 */
static PyObject *Dtool_NodePath_get_sr_781(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NodePath::get_sr(void) const
  PN_stdfloat return_value = ((*(const NodePath*)local_this).get_sr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_sr_781_comment =
  "C++ Interface:\n"
  "get_sr(NodePath self)\n"
  "\n"
  "/**\n"
  " * Gets the red scale component of the transform\n"
  " */";
#else
static const char *Dtool_NodePath_get_sr_781_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_sg(void) const
 */
static PyObject *Dtool_NodePath_get_sg_782(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NodePath::get_sg(void) const
  PN_stdfloat return_value = ((*(const NodePath*)local_this).get_sg)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_sg_782_comment =
  "C++ Interface:\n"
  "get_sg(NodePath self)\n"
  "\n"
  "/**\n"
  " * Gets the green scale component of the transform\n"
  " */";
#else
static const char *Dtool_NodePath_get_sg_782_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_sb(void) const
 */
static PyObject *Dtool_NodePath_get_sb_783(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NodePath::get_sb(void) const
  PN_stdfloat return_value = ((*(const NodePath*)local_this).get_sb)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_sb_783_comment =
  "C++ Interface:\n"
  "get_sb(NodePath self)\n"
  "\n"
  "/**\n"
  " * Gets the blue scale component of the transform\n"
  " */";
#else
static const char *Dtool_NodePath_get_sb_783_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_sa(void) const
 */
static PyObject *Dtool_NodePath_get_sa_784(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NodePath::get_sa(void) const
  PN_stdfloat return_value = ((*(const NodePath*)local_this).get_sa)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_sa_784_comment =
  "C++ Interface:\n"
  "get_sa(NodePath self)\n"
  "\n"
  "/**\n"
  " * Gets the alpha scale component of the transform\n"
  " */";
#else
static const char *Dtool_NodePath_get_sa_784_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_light(NodePath const &light, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_light_785(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_light")) {
    return nullptr;
  }
  // 1-void NodePath::set_light(NodePath const &light, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"light", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_light", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_light", true, true);
    if (param1_this != nullptr) {
      ((*local_this).set_light)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_light(const NodePath self, const NodePath light, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_light_785_comment =
  "C++ Interface:\n"
  "set_light(const NodePath self, const NodePath light, int priority)\n"
  "\n"
  "/**\n"
  " * Adds the indicated Light or PolylightNode to the list of lights that\n"
  " * illuminate geometry at this node and below.  The light itself should be\n"
  " * parented into the scene graph elsewhere, to represent the light's position\n"
  " * in space; but until set_light() is called it will illuminate no geometry.\n"
  " */";
#else
static const char *Dtool_NodePath_set_light_785_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_light_off(NodePath const &light, int priority = 0)
 * void NodePath::set_light_off(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_light_off_786(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_light_off")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePath::set_light_off(int priority)
      ((*local_this).set_light_off)();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 void NodePath::set_light_off(NodePath const &light, int priority = 0)
        PyObject *param1;
        int param2 = 0;
        static const char *keyword_list[] = {"light", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_light_off", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          if (param1_this != nullptr) {
            ((*local_this).set_light_off)(*param1_this, (int)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_light_off(int priority = 0)
        int param1;
        static const char *keyword_list[] = {"priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:set_light_off", (char **)keyword_list, &param1)) {
          ((*local_this).set_light_off)((int)param1);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePath::set_light_off(NodePath const &light, int priority = 0)
      // No coercion possible: void NodePath::set_light_off(int priority = 0)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_light_off() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_light_off(const NodePath self)\n"
      "set_light_off(const NodePath self, const NodePath light, int priority)\n"
      "set_light_off(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_light_off_786_comment =
  "C++ Interface:\n"
  "set_light_off(const NodePath self)\n"
  "set_light_off(const NodePath self, const NodePath light, int priority)\n"
  "set_light_off(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render using no lights at all.\n"
  " * This is different from not specifying a light; rather, this specifically\n"
  " * contradicts set_light() at a higher node level (or, with a priority,\n"
  " * overrides a set_light() at a lower level).\n"
  " *\n"
  " * If no lights are in effect on a particular piece of geometry, that geometry\n"
  " * is rendered with lighting disabled.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render without using the\n"
  " * indicated Light.  This is different from not specifying the Light; rather,\n"
  " * this specifically contradicts set_light() at a higher node level (or, with\n"
  " * a priority, overrides a set_light() at a lower level).\n"
  " *\n"
  " * This interface does not support PolylightNodes, which cannot be turned off\n"
  " * at a lower level.\n"
  " */";
#else
static const char *Dtool_NodePath_set_light_off_786_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_light(void)
 * void NodePath::clear_light(NodePath const &light)
 */
static PyObject *Dtool_NodePath_clear_light_787(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_light")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePath::clear_light(void)
      ((*local_this).clear_light)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void NodePath::clear_light(NodePath const &light)
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.clear_light", true, true);
      if (arg_this != nullptr) {
        ((*local_this).clear_light)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_light() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_light(const NodePath self)\n"
      "clear_light(const NodePath self, const NodePath light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_light_787_comment =
  "C++ Interface:\n"
  "clear_light(const NodePath self)\n"
  "clear_light(const NodePath self, const NodePath light)\n"
  "\n"
  "/**\n"
  " * Completely removes any lighting operations that may have been set via\n"
  " * set_light() or set_light_off() from this particular node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes any reference to the indicated Light or PolylightNode from the\n"
  " * NodePath.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_light_787_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_light(NodePath const &light) const
 */
static PyObject *Dtool_NodePath_has_light_788(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_light(NodePath const &light) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.has_light", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const NodePath*)local_this).has_light)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_light(NodePath self, const NodePath light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_light_788_comment =
  "C++ Interface:\n"
  "has_light(NodePath self, const NodePath light)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated Light or PolylightNode has been specifically\n"
  " * enabled on this particular node.  This means that someone called\n"
  " * set_light() on this node with the indicated light.\n"
  " */";
#else
static const char *Dtool_NodePath_has_light_788_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_light_off(void) const
 * bool NodePath::has_light_off(NodePath const &light) const
 */
static PyObject *Dtool_NodePath_has_light_off_789(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-bool NodePath::has_light_off(void) const
      bool return_value = ((*(const NodePath*)local_this).has_light_off)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool NodePath::has_light_off(NodePath const &light) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.has_light_off", true, true);
      if (arg_this != nullptr) {
        bool return_value = ((*(const NodePath*)local_this).has_light_off)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_light_off() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_light_off(NodePath self)\n"
      "has_light_off(NodePath self, const NodePath light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_light_off_789_comment =
  "C++ Interface:\n"
  "has_light_off(NodePath self)\n"
  "has_light_off(NodePath self, const NodePath light)\n"
  "\n"
  "/**\n"
  " * Returns true if all Lights have been specifically disabled on this\n"
  " * particular node.  This means that someone called set_light_off() on this\n"
  " * node with no parameters.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated Light has been specifically disabled on this\n"
  " * particular node.  This means that someone called set_light_off() on this\n"
  " * node with the indicated light.\n"
  " *\n"
  " * This interface does not support PolylightNodes, which cannot be turned off\n"
  " * at a lower level.\n"
  " */";
#else
static const char *Dtool_NodePath_has_light_off_789_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_clip_plane(NodePath const &clip_plane, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_clip_plane_790(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_clip_plane")) {
    return nullptr;
  }
  // 1-void NodePath::set_clip_plane(NodePath const &clip_plane, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"clip_plane", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_clip_plane", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_clip_plane", true, true);
    if (param1_this != nullptr) {
      ((*local_this).set_clip_plane)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clip_plane(const NodePath self, const NodePath clip_plane, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_clip_plane_790_comment =
  "C++ Interface:\n"
  "set_clip_plane(const NodePath self, const NodePath clip_plane, int priority)\n"
  "\n"
  "/**\n"
  " * Adds the indicated clipping plane to the list of planes that apply to\n"
  " * geometry at this node and below.  The clipping plane itself, a PlaneNode,\n"
  " * should be parented into the scene graph elsewhere, to represent the plane's\n"
  " * position in space; but until set_clip_plane() is called it will clip no\n"
  " * geometry.\n"
  " */";
#else
static const char *Dtool_NodePath_set_clip_plane_790_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_clip_plane_off(NodePath const &clip_plane, int priority = 0)
 * void NodePath::set_clip_plane_off(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_clip_plane_off_791(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_clip_plane_off")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePath::set_clip_plane_off(int priority)
      ((*local_this).set_clip_plane_off)();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 void NodePath::set_clip_plane_off(NodePath const &clip_plane, int priority = 0)
        PyObject *param1;
        int param2 = 0;
        static const char *keyword_list[] = {"clip_plane", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_clip_plane_off", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          if (param1_this != nullptr) {
            ((*local_this).set_clip_plane_off)(*param1_this, (int)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_clip_plane_off(int priority = 0)
        int param1;
        static const char *keyword_list[] = {"priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:set_clip_plane_off", (char **)keyword_list, &param1)) {
          ((*local_this).set_clip_plane_off)((int)param1);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePath::set_clip_plane_off(NodePath const &clip_plane, int priority = 0)
      // No coercion possible: void NodePath::set_clip_plane_off(int priority = 0)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_clip_plane_off() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clip_plane_off(const NodePath self)\n"
      "set_clip_plane_off(const NodePath self, const NodePath clip_plane, int priority)\n"
      "set_clip_plane_off(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_clip_plane_off_791_comment =
  "C++ Interface:\n"
  "set_clip_plane_off(const NodePath self)\n"
  "set_clip_plane_off(const NodePath self, const NodePath clip_plane, int priority)\n"
  "set_clip_plane_off(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render using no clip_planes at\n"
  " * all.  This is different from not specifying a clip_plane; rather, this\n"
  " * specifically contradicts set_clip_plane() at a higher node level (or, with\n"
  " * a priority, overrides a set_clip_plane() at a lower level).\n"
  " *\n"
  " * If no clip_planes are in effect on a particular piece of geometry, that\n"
  " * geometry is rendered without being clipped (other than by the viewing\n"
  " * frustum).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render without being clipped\n"
  " * by the indicated PlaneNode.  This is different from not specifying the\n"
  " * PlaneNode; rather, this specifically contradicts set_clip_plane() at a\n"
  " * higher node level (or, with a priority, overrides a set_clip_plane() at a\n"
  " * lower level).\n"
  " */";
#else
static const char *Dtool_NodePath_set_clip_plane_off_791_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_clip_plane(void)
 * void NodePath::clear_clip_plane(NodePath const &clip_plane)
 */
static PyObject *Dtool_NodePath_clear_clip_plane_792(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_clip_plane")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePath::clear_clip_plane(void)
      ((*local_this).clear_clip_plane)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void NodePath::clear_clip_plane(NodePath const &clip_plane)
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.clear_clip_plane", true, true);
      if (arg_this != nullptr) {
        ((*local_this).clear_clip_plane)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_clip_plane() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_clip_plane(const NodePath self)\n"
      "clear_clip_plane(const NodePath self, const NodePath clip_plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_clip_plane_792_comment =
  "C++ Interface:\n"
  "clear_clip_plane(const NodePath self)\n"
  "clear_clip_plane(const NodePath self, const NodePath clip_plane)\n"
  "\n"
  "/**\n"
  " * Completely removes any clip planes that may have been set via\n"
  " * set_clip_plane() or set_clip_plane_off() from this particular node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes any reference to the indicated clipping plane from the NodePath.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_clip_plane_792_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_clip_plane(NodePath const &clip_plane) const
 */
static PyObject *Dtool_NodePath_has_clip_plane_793(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_clip_plane(NodePath const &clip_plane) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.has_clip_plane", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const NodePath*)local_this).has_clip_plane)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_clip_plane(NodePath self, const NodePath clip_plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_clip_plane_793_comment =
  "C++ Interface:\n"
  "has_clip_plane(NodePath self, const NodePath clip_plane)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated clipping plane has been specifically applied\n"
  " * to this particular node.  This means that someone called set_clip_plane()\n"
  " * on this node with the indicated clip_plane.\n"
  " */";
#else
static const char *Dtool_NodePath_has_clip_plane_793_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_clip_plane_off(void) const
 * bool NodePath::has_clip_plane_off(NodePath const &clip_plane) const
 */
static PyObject *Dtool_NodePath_has_clip_plane_off_794(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-bool NodePath::has_clip_plane_off(void) const
      bool return_value = ((*(const NodePath*)local_this).has_clip_plane_off)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool NodePath::has_clip_plane_off(NodePath const &clip_plane) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.has_clip_plane_off", true, true);
      if (arg_this != nullptr) {
        bool return_value = ((*(const NodePath*)local_this).has_clip_plane_off)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_clip_plane_off() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_clip_plane_off(NodePath self)\n"
      "has_clip_plane_off(NodePath self, const NodePath clip_plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_clip_plane_off_794_comment =
  "C++ Interface:\n"
  "has_clip_plane_off(NodePath self)\n"
  "has_clip_plane_off(NodePath self, const NodePath clip_plane)\n"
  "\n"
  "/**\n"
  " * Returns true if all clipping planes have been specifically disabled on this\n"
  " * particular node.  This means that someone called set_clip_plane_off() on\n"
  " * this node with no parameters.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated clipping plane has been specifically disabled\n"
  " * on this particular node.  This means that someone called\n"
  " * set_clip_plane_off() on this node with the indicated clip_plane.\n"
  " */";
#else
static const char *Dtool_NodePath_has_clip_plane_off_794_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_scissor(LPoint3 const &a, LPoint3 const &b)
 * void NodePath::set_scissor(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d)
 * void NodePath::set_scissor(NodePath const &other, LPoint3 const &a, LPoint3 const &b)
 * void NodePath::set_scissor(NodePath const &other, LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d)
 * void NodePath::set_scissor(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_NodePath_set_scissor_795(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_scissor")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void NodePath::set_scissor(LPoint3 const &a, LPoint3 const &b)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_scissor", (char **)keyword_list, &param1, &param2)) {
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_scissor", "LPoint3f");
        }
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_scissor", "LPoint3f");
        }
        ((*local_this).set_scissor)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-void NodePath::set_scissor(NodePath const &other, LPoint3 const &a, LPoint3 const &b)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"other", "a", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_scissor", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_scissor", true, true);
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_scissor", "LPoint3f");
        }
        LPoint3f param3_local;
        LPoint3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_scissor", "LPoint3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_scissor)(*param1_this, *param2_this, *param3_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 4:
    {
      {
        // -2 void NodePath::set_scissor(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        static const char *keyword_list[] = {"a", "b", "c", "d", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_scissor", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          LPoint3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_LPoint3f);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr && param4_this != nullptr) {
            ((*local_this).set_scissor)(*param1_this, *param2_this, *param3_this, *param4_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_scissor(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
        float param1;
        float param2;
        float param3;
        float param4;
        static const char *keyword_list[] = {"left", "right", "bottom", "top", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_scissor", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          ((*local_this).set_scissor)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_scissor(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        static const char *keyword_list[] = {"a", "b", "c", "d", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_scissor", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          LPoint3f param1_local;
          LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
          LPoint3f param2_local;
          LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
          LPoint3f param3_local;
          LPoint3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
          LPoint3f param4_local;
          LPoint3 const *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
          if ((param1_this != nullptr) && (param2_this != nullptr) && (param3_this != nullptr) && (param4_this != nullptr)) {
            ((*local_this).set_scissor)(*param1_this, *param2_this, *param3_this, *param4_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePath::set_scissor(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
    }
    break;
  case 5:
    {
      // 1-void NodePath::set_scissor(NodePath const &other, LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      static const char *keyword_list[] = {"other", "a", "b", "c", "d", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO:set_scissor", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_scissor", true, true);
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_scissor", "LPoint3f");
        }
        LPoint3f param3_local;
        LPoint3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_scissor", "LPoint3f");
        }
        LPoint3f param4_local;
        LPoint3 const *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
        if (!(param4_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "NodePath.set_scissor", "LPoint3f");
        }
        LPoint3f param5_local;
        LPoint3 const *param5_this = Dtool_Coerce_LPoint3f(param5, param5_local);
        if (!(param5_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param5, 5, "NodePath.set_scissor", "LPoint3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_scissor)(*param1_this, *param2_this, *param3_this, *param4_this, *param5_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_scissor() takes 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scissor(const NodePath self, const LPoint3f a, const LPoint3f b)\n"
      "set_scissor(const NodePath self, const NodePath other, const LPoint3f a, const LPoint3f b)\n"
      "set_scissor(const NodePath self, const LPoint3f a, const LPoint3f b, const LPoint3f c, const LPoint3f d)\n"
      "set_scissor(const NodePath self, float left, float right, float bottom, float top)\n"
      "set_scissor(const NodePath self, const NodePath other, const LPoint3f a, const LPoint3f b, const LPoint3f c, const LPoint3f d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_scissor_795_comment =
  "C++ Interface:\n"
  "set_scissor(const NodePath self, const LPoint3f a, const LPoint3f b)\n"
  "set_scissor(const NodePath self, const NodePath other, const LPoint3f a, const LPoint3f b)\n"
  "set_scissor(const NodePath self, const LPoint3f a, const LPoint3f b, const LPoint3f c, const LPoint3f d)\n"
  "set_scissor(const NodePath self, float left, float right, float bottom, float top)\n"
  "set_scissor(const NodePath self, const NodePath other, const LPoint3f a, const LPoint3f b, const LPoint3f c, const LPoint3f d)\n"
  "\n"
  "/**\n"
  " * Sets up a scissor region on the nodes rendered at this level and below.\n"
  " * The four coordinates are understood to define a rectangle in screen space.\n"
  " * These numbers are relative to the current DisplayRegion, where (0,0) is the\n"
  " * lower-left corner of the DisplayRegion, and (1,1) is the upper-right\n"
  " * corner.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up a scissor region on the nodes rendered at this level and below.\n"
  " * The two points are understood to be relative to this node.  When these\n"
  " * points are projected into screen space, they define the diagonally-opposite\n"
  " * points that determine the scissor region.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up a scissor region on the nodes rendered at this level and below.\n"
  " * The four points are understood to be relative to this node.  When these\n"
  " * points are projected into screen space, they define the bounding volume of\n"
  " * the scissor region (the scissor region is the smallest onscreen rectangle\n"
  " * that encloses all four points).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up a scissor region on the nodes rendered at this level and below.\n"
  " * The two points are understood to be relative to the indicated other node.\n"
  " * When these points are projected into screen space, they define the\n"
  " * diagonally-opposite points that determine the scissor region.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up a scissor region on the nodes rendered at this level and below.\n"
  " * The four points are understood to be relative to the indicated other node.\n"
  " * When these points are projected into screen space, they define the bounding\n"
  " * volume of the scissor region (the scissor region is the smallest onscreen\n"
  " * rectangle that encloses all four points).\n"
  " */";
#else
static const char *Dtool_NodePath_set_scissor_795_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_scissor(void)
 */
static PyObject *Dtool_NodePath_clear_scissor_796(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_scissor")) {
    return nullptr;
  }
  // 1-void NodePath::clear_scissor(void)
  ((*local_this).clear_scissor)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_scissor_796_comment =
  "C++ Interface:\n"
  "clear_scissor(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Removes the scissor region that was defined at this node level by a\n"
  " * previous call to set_scissor().\n"
  " */";
#else
static const char *Dtool_NodePath_clear_scissor_796_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_scissor(void) const
 */
static PyObject *Dtool_NodePath_has_scissor_797(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_scissor(void) const
  bool return_value = ((*(const NodePath*)local_this).has_scissor)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_scissor_797_comment =
  "C++ Interface:\n"
  "has_scissor(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a scissor region was defined at this node by a previous\n"
  " * call to set_scissor().  This does not check for scissor regions inherited\n"
  " * from a parent class.  It also does not check for the presence of a low-\n"
  " * level ScissorAttrib, which is different from the ScissorEffect added by\n"
  " * set_scissor.\n"
  " */";
#else
static const char *Dtool_NodePath_has_scissor_797_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_occluder(NodePath const &occluder)
 */
static PyObject *Dtool_NodePath_set_occluder_798(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_occluder")) {
    return nullptr;
  }
  // 1-void NodePath::set_occluder(NodePath const &occluder)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.set_occluder", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_occluder)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_occluder(const NodePath self, const NodePath occluder)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_occluder_798_comment =
  "C++ Interface:\n"
  "set_occluder(const NodePath self, const NodePath occluder)\n"
  "\n"
  "/**\n"
  " * Adds the indicated occluder to the list of occluders that apply to geometry\n"
  " * at this node and below.  The occluder itself, an OccluderNode, should be\n"
  " * parented into the scene graph elsewhere, to represent the occluder's\n"
  " * position in space; but until set_occluder() is called it will clip no\n"
  " * geometry.\n"
  " */";
#else
static const char *Dtool_NodePath_set_occluder_798_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_occluder(void)
 * void NodePath::clear_occluder(NodePath const &occluder)
 */
static PyObject *Dtool_NodePath_clear_occluder_799(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_occluder")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePath::clear_occluder(void)
      ((*local_this).clear_occluder)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void NodePath::clear_occluder(NodePath const &occluder)
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.clear_occluder", true, true);
      if (arg_this != nullptr) {
        ((*local_this).clear_occluder)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_occluder() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_occluder(const NodePath self)\n"
      "clear_occluder(const NodePath self, const NodePath occluder)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_occluder_799_comment =
  "C++ Interface:\n"
  "clear_occluder(const NodePath self)\n"
  "clear_occluder(const NodePath self, const NodePath occluder)\n"
  "\n"
  "/**\n"
  " * Completely removes any occluders that may have been set via set_occluder()\n"
  " * from this particular node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes any reference to the indicated occluder from the NodePath.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_occluder_799_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_occluder(NodePath const &occluder) const
 */
static PyObject *Dtool_NodePath_has_occluder_800(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_occluder(NodePath const &occluder) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePath.has_occluder", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const NodePath*)local_this).has_occluder)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_occluder(NodePath self, const NodePath occluder)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_occluder_800_comment =
  "C++ Interface:\n"
  "has_occluder(NodePath self, const NodePath occluder)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated occluder has been specifically applied to\n"
  " * this particular node.  This means that someone called set_occluder() on\n"
  " * this node with the indicated occluder.\n"
  " */";
#else
static const char *Dtool_NodePath_has_occluder_800_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_bin(std::string const &bin_name, int draw_order, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_bin_801(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_bin")) {
    return nullptr;
  }
  // 1-void NodePath::set_bin(std::string const &bin_name, int draw_order, int priority = 0)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  int param2;
  int param3 = 0;
  static const char *keyword_list[] = {"bin_name", "draw_order", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i|i:set_bin", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    ((*local_this).set_bin)(std::string(param1_str, param1_len), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin(const NodePath self, str bin_name, int draw_order, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_bin_801_comment =
  "C++ Interface:\n"
  "set_bin(const NodePath self, str bin_name, int draw_order, int priority)\n"
  "\n"
  "/**\n"
  " * Assigns the geometry at this level and below to the named rendering bin.\n"
  " * It is the user's responsibility to ensure that such a bin already exists,\n"
  " * either via the cull-bin Configrc variable, or by explicitly creating a\n"
  " * GeomBin of the appropriate type at runtime.\n"
  " *\n"
  " * There are two default bins created when Panda is started: \"default\" and\n"
  " * \"fixed\".  Normally, all geometry is assigned to \"default\" unless specified\n"
  " * otherwise.  This bin renders opaque geometry in state-sorted order,\n"
  " * followed by transparent geometry sorted back-to-front.  If any geometry is\n"
  " * assigned to \"fixed\", this will be rendered following all the geometry in\n"
  " * \"default\", in the order specified by draw_order for each piece of geometry\n"
  " * so assigned.\n"
  " *\n"
  " * The draw_order parameter is meaningful only for GeomBinFixed type bins,\n"
  " * e.g.  \"fixed\".  Other kinds of bins ignore it.\n"
  " */";
#else
static const char *Dtool_NodePath_set_bin_801_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_bin(void)
 */
static PyObject *Dtool_NodePath_clear_bin_802(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_bin")) {
    return nullptr;
  }
  // 1-void NodePath::clear_bin(void)
  ((*local_this).clear_bin)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_bin_802_comment =
  "C++ Interface:\n"
  "clear_bin(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any bin adjustment that may have been set via set_bin()\n"
  " * from this particular node.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_bin_802_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_bin(void) const
 */
static PyObject *Dtool_NodePath_has_bin_803(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_bin(void) const
  bool return_value = ((*(const NodePath*)local_this).has_bin)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_bin_803_comment =
  "C++ Interface:\n"
  "has_bin(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if the node has been assigned to the a particular rendering\n"
  " * bin via set_bin(), false otherwise.\n"
  " */";
#else
static const char *Dtool_NodePath_has_bin_803_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string NodePath::get_bin_name(void) const
 */
static PyObject *Dtool_NodePath_get_bin_name_804(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-std::string NodePath::get_bin_name(void) const
  std::string return_value = ((*(const NodePath*)local_this).get_bin_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_bin_name_804_comment =
  "C++ Interface:\n"
  "get_bin_name(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the bin that this particular node was assigned to via\n"
  " * set_bin(), or the empty string if no bin was assigned.  See set_bin() and\n"
  " * has_bin().\n"
  " */";
#else
static const char *Dtool_NodePath_get_bin_name_804_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int NodePath::get_bin_draw_order(void) const
 */
static PyObject *Dtool_NodePath_get_bin_draw_order_805(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-int NodePath::get_bin_draw_order(void) const
  int return_value = ((*(const NodePath*)local_this).get_bin_draw_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_bin_draw_order_805_comment =
  "C++ Interface:\n"
  "get_bin_draw_order(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the drawing order associated with the bin that this particular node\n"
  " * was assigned to via set_bin(), or 0 if no bin was assigned.  See set_bin()\n"
  " * and has_bin().\n"
  " */";
#else
static const char *Dtool_NodePath_get_bin_draw_order_805_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_texture(Texture *tex, SamplerState const &sampler, int priority = 0)
 * void NodePath::set_texture(Texture *tex, int priority = 0)
 * void NodePath::set_texture(TextureStage *stage, Texture *tex, SamplerState const &sampler, int priority = 0)
 * void NodePath::set_texture(TextureStage *stage, Texture *tex, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_texture_806(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_texture")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "tex")) {
        // 1-void NodePath::set_texture(Texture *tex, int priority)
        Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "NodePath.set_texture", false, true);
        if (arg_this != nullptr) {
          ((*local_this).set_texture)(arg_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      {
        // -2 void NodePath::set_texture(Texture *tex, SamplerState const &sampler, int priority)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"tex", "sampler", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_texture", (char **)keyword_list, &param1, &param2)) {
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "NodePath.set_texture", false, false);
          SamplerState const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_SamplerState);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_texture)(param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_texture(TextureStage *stage, Texture *tex, int priority)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"stage", "tex", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_texture", (char **)keyword_list, &param1, &param2)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_texture", false, false);
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePath.set_texture", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_texture)(param1_this, param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_texture(Texture *tex, int priority)
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"tex", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_texture", (char **)keyword_list, &param1, &param2)) {
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "NodePath.set_texture", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_texture)(param1_this, (int)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePath::set_texture(Texture *tex, SamplerState const &sampler, int priority)
      // No coercion possible: void NodePath::set_texture(TextureStage *stage, Texture *tex, int priority)
      // No coercion possible: void NodePath::set_texture(Texture *tex, int priority)
    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 void NodePath::set_texture(TextureStage *stage, Texture *tex, SamplerState const &sampler, int priority = 0)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4 = 0;
        static const char *keyword_list[] = {"stage", "tex", "sampler", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:set_texture", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_texture", false, false);
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePath.set_texture", false, false);
          SamplerState const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_SamplerState);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ((*local_this).set_texture)(param1_this, param2_this, *param3_this, (int)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_texture(Texture *tex, SamplerState const &sampler, int priority = 0)
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"tex", "sampler", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:set_texture", (char **)keyword_list, &param1, &param2, &param3)) {
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "NodePath.set_texture", false, false);
          SamplerState const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_SamplerState);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_texture)(param1_this, *param2_this, (int)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_texture(TextureStage *stage, Texture *tex, int priority = 0)
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"stage", "tex", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:set_texture", (char **)keyword_list, &param1, &param2, &param3)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_texture", false, false);
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePath.set_texture", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_texture)(param1_this, param2_this, (int)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePath::set_texture(TextureStage *stage, Texture *tex, SamplerState const &sampler, int priority = 0)
      // No coercion possible: void NodePath::set_texture(Texture *tex, SamplerState const &sampler, int priority = 0)
      // No coercion possible: void NodePath::set_texture(TextureStage *stage, Texture *tex, int priority = 0)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_texture() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture(const NodePath self, Texture tex)\n"
      "set_texture(const NodePath self, Texture tex, const SamplerState sampler)\n"
      "set_texture(const NodePath self, TextureStage stage, Texture tex)\n"
      "set_texture(const NodePath self, Texture tex, int priority)\n"
      "set_texture(const NodePath self, TextureStage stage, Texture tex, const SamplerState sampler, int priority)\n"
      "set_texture(const NodePath self, Texture tex, const SamplerState sampler, int priority)\n"
      "set_texture(const NodePath self, TextureStage stage, Texture tex, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_texture_806_comment =
  "C++ Interface:\n"
  "set_texture(const NodePath self, Texture tex)\n"
  "set_texture(const NodePath self, Texture tex, const SamplerState sampler)\n"
  "set_texture(const NodePath self, TextureStage stage, Texture tex)\n"
  "set_texture(const NodePath self, Texture tex, int priority)\n"
  "set_texture(const NodePath self, TextureStage stage, Texture tex, const SamplerState sampler, int priority)\n"
  "set_texture(const NodePath self, Texture tex, const SamplerState sampler, int priority)\n"
  "set_texture(const NodePath self, TextureStage stage, Texture tex, int priority)\n"
  "\n"
  "/**\n"
  " * Adds the indicated texture to the list of textures that will be rendered on\n"
  " * the default texture stage.\n"
  " *\n"
  " * This is the convenience single-texture variant of this method; it is now\n"
  " * superceded by set_texture() that accepts a stage and texture.  You may use\n"
  " * this method if you just want to adjust the default stage.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the indicated texture to the list of textures that will be rendered on\n"
  " * the indicated multitexture stage.  If there are multiple texture stages\n"
  " * specified (possibly on multiple different nodes at different levels), they\n"
  " * will all be applied to geometry together, according to the stage\n"
  " * specification set up in the TextureStage object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the indicated texture to the list of textures that will be rendered on\n"
  " * the default texture stage.\n"
  " *\n"
  " * The given sampler state will override the sampling settings on the texture\n"
  " * itself.  Note that this method makes a copy of the sampler settings that\n"
  " * you give; further changes to this object will not be reflected.\n"
  " *\n"
  " * This is the convenience single-texture variant of this method; it is now\n"
  " * superceded by set_texture() that accepts a stage and texture.  You may use\n"
  " * this method if you just want to adjust the default stage.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the indicated texture to the list of textures that will be rendered on\n"
  " * the indicated multitexture stage.  If there are multiple texture stages\n"
  " * specified (possibly on multiple different nodes at different levels), they\n"
  " * will all be applied to geometry together, according to the stage\n"
  " * specification set up in the TextureStage object.\n"
  " *\n"
  " * The given sampler state will override the sampling settings on the texture\n"
  " * itself.  Note that this method makes a copy of the sampler settings that\n"
  " * you give; further changes to this object will not be reflected.\n"
  " */";
#else
static const char *Dtool_NodePath_set_texture_806_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_texture_off(TextureStage *stage, int priority = 0)
 * void NodePath::set_texture_off(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_texture_off_807(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_texture_off")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePath::set_texture_off(int priority)
      ((*local_this).set_texture_off)();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 void NodePath::set_texture_off(TextureStage *stage, int priority = 0)
        PyObject *param1;
        int param2 = 0;
        static const char *keyword_list[] = {"stage", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_texture_off", (char **)keyword_list, &param1, &param2)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_texture_off", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_texture_off)(param1_this, (int)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_texture_off(int priority = 0)
        int param1;
        static const char *keyword_list[] = {"priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:set_texture_off", (char **)keyword_list, &param1)) {
          ((*local_this).set_texture_off)((int)param1);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePath::set_texture_off(TextureStage *stage, int priority = 0)
      // No coercion possible: void NodePath::set_texture_off(int priority = 0)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_texture_off() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_off(const NodePath self)\n"
      "set_texture_off(const NodePath self, TextureStage stage, int priority)\n"
      "set_texture_off(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_texture_off_807_comment =
  "C++ Interface:\n"
  "set_texture_off(const NodePath self)\n"
  "set_texture_off(const NodePath self, TextureStage stage, int priority)\n"
  "set_texture_off(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render using no texture, on\n"
  " * any stage.  This is different from not specifying a texture; rather, this\n"
  " * specifically contradicts set_texture() at a higher node level (or, with a\n"
  " * priority, overrides a set_texture() at a lower level).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render using no texture, on\n"
  " * the indicated stage.  This is different from not specifying a texture;\n"
  " * rather, this specifically contradicts set_texture() at a higher node level\n"
  " * (or, with a priority, overrides a set_texture() at a lower level).\n"
  " */";
#else
static const char *Dtool_NodePath_set_texture_off_807_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_texture(void)
 * void NodePath::clear_texture(TextureStage *stage)
 */
static PyObject *Dtool_NodePath_clear_texture_808(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_texture")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePath::clear_texture(void)
      ((*local_this).clear_texture)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void NodePath::clear_texture(TextureStage *stage)
      TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.clear_texture", false, true);
      if (arg_this != nullptr) {
        ((*local_this).clear_texture)(arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_texture() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_texture(const NodePath self)\n"
      "clear_texture(const NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_texture_808_comment =
  "C++ Interface:\n"
  "clear_texture(const NodePath self)\n"
  "clear_texture(const NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Completely removes any texture adjustment that may have been set via\n"
  " * set_texture() or set_texture_off() from this particular node.  This allows\n"
  " * whatever textures might be otherwise affecting the geometry to show\n"
  " * instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes any reference to the indicated texture stage from the NodePath.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_texture_808_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_texture(void) const
 * bool NodePath::has_texture(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_has_texture_809(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-bool NodePath::has_texture(void) const
      bool return_value = ((*(const NodePath*)local_this).has_texture)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool NodePath::has_texture(TextureStage *stage) const
      TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.has_texture", false, true);
      if (arg_this != nullptr) {
        bool return_value = ((*(const NodePath*)local_this).has_texture)(arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_texture() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_texture(NodePath self)\n"
      "has_texture(NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_texture_809_comment =
  "C++ Interface:\n"
  "has_texture(NodePath self)\n"
  "has_texture(NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns true if a texture has been applied to this particular node via\n"
  " * set_texture(), false otherwise.  This is not the same thing as asking\n"
  " * whether the geometry at this node will be rendered with texturing, as there\n"
  " * may be a texture in effect from a higher or lower level.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if texturing has been specifically enabled on this particular\n"
  " * node for the indicated stage.  This means that someone called set_texture()\n"
  " * on this node with the indicated stage name, or the stage_name is the\n"
  " * default stage_name, and someone called set_texture() on this node.\n"
  " */";
#else
static const char *Dtool_NodePath_has_texture_809_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_texture_off(void) const
 * bool NodePath::has_texture_off(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_has_texture_off_810(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-bool NodePath::has_texture_off(void) const
      bool return_value = ((*(const NodePath*)local_this).has_texture_off)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool NodePath::has_texture_off(TextureStage *stage) const
      TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.has_texture_off", false, true);
      if (arg_this != nullptr) {
        bool return_value = ((*(const NodePath*)local_this).has_texture_off)(arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_texture_off() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_texture_off(NodePath self)\n"
      "has_texture_off(NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_texture_off_810_comment =
  "C++ Interface:\n"
  "has_texture_off(NodePath self)\n"
  "has_texture_off(NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns true if texturing has been specifically disabled on this particular\n"
  " * node via set_texture_off(), false otherwise.  This is not the same thing as\n"
  " * asking whether the geometry at this node will be rendered untextured, as\n"
  " * there may be a texture in effect from a higher or lower level.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if texturing has been specifically disabled on this particular\n"
  " * node for the indicated stage.  This means that someone called\n"
  " * set_texture_off() on this node with the indicated stage name, or that\n"
  " * someone called set_texture_off() on this node to remove all stages.\n"
  " */";
#else
static const char *Dtool_NodePath_has_texture_off_810_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *NodePath::get_texture(void) const
 * Texture *NodePath::get_texture(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_texture_811(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-Texture *NodePath::get_texture(void) const
      Texture *return_value = ((*(const NodePath*)local_this).get_texture)();
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-Texture *NodePath::get_texture(TextureStage *stage) const
      TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_texture", false, true);
      if (arg_this != nullptr) {
        Texture *return_value = ((*(const NodePath*)local_this).get_texture)(arg_this);
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_texture() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture(NodePath self)\n"
      "get_texture(NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_texture_811_comment =
  "C++ Interface:\n"
  "get_texture(NodePath self)\n"
  "get_texture(NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the base-level texture that has been set on this particular node,\n"
  " * or NULL if no texture has been set.  This is not necessarily the texture\n"
  " * that will be applied to the geometry at or below this level, as another\n"
  " * texture at a higher or lower level may override.\n"
  " *\n"
  " * See also find_texture().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the texture that has been set on the indicated stage for this\n"
  " * particular node, or NULL if no texture has been set for this stage.\n"
  " */";
#else
static const char *Dtool_NodePath_get_texture_811_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::replace_texture(Texture *tex, Texture *new_tex)
 */
static PyObject *Dtool_NodePath_replace_texture_812(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.replace_texture")) {
    return nullptr;
  }
  // 1-void NodePath::replace_texture(Texture *tex, Texture *new_tex)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"tex", "new_tex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:replace_texture", (char **)keyword_list, &param1, &param2)) {
    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "NodePath.replace_texture", false, true);
    Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePath.replace_texture", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).replace_texture)(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "replace_texture(const NodePath self, Texture tex, Texture new_tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_replace_texture_812_comment =
  "C++ Interface:\n"
  "replace_texture(const NodePath self, Texture tex, Texture new_tex)\n"
  "\n"
  "/**\n"
  " * Recursively searches the scene graph for references to the given texture,\n"
  " * and replaces them with the new texture.\n"
  " *\n"
  " * @since 1.10.4\n"
  " */";
#else
static const char *Dtool_NodePath_replace_texture_812_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SamplerState const &NodePath::get_texture_sampler(void) const
 * SamplerState const &NodePath::get_texture_sampler(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_texture_sampler_813(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-SamplerState const &NodePath::get_texture_sampler(void) const
      SamplerState const *return_value = &(((*(const NodePath*)local_this).get_texture_sampler)());
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SamplerState, false, true);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-SamplerState const &NodePath::get_texture_sampler(TextureStage *stage) const
      TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_texture_sampler", false, true);
      if (arg_this != nullptr) {
        SamplerState const *return_value = &(((*(const NodePath*)local_this).get_texture_sampler)(arg_this));
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SamplerState, false, true);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_texture_sampler() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture_sampler(NodePath self)\n"
      "get_texture_sampler(NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_texture_sampler_813_comment =
  "C++ Interface:\n"
  "get_texture_sampler(NodePath self)\n"
  "get_texture_sampler(NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the sampler state that has been given for the base-level texture\n"
  " * that has been set on this particular node.  If no sampler state was given,\n"
  " * this returns the texture's default sampler settings.\n"
  " *\n"
  " * It is an error to call this if there is no base-level texture applied to\n"
  " * this particular node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the sampler state that has been given for the indicated texture\n"
  " * stage that has been set on this particular node.  If no sampler state was\n"
  " * given, this returns the texture's default sampler settings.\n"
  " *\n"
  " * It is an error to call this if there is no texture set for this stage on\n"
  " * this particular node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_texture_sampler_813_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_shader(Shader const *sha, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_shader_814(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_shader")) {
    return nullptr;
  }
  // 1-void NodePath::set_shader(Shader const *sha, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"sha", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_shader", (char **)keyword_list, &param1, &param2)) {
    CPT(Shader) param1_this;
    if (!Dtool_ConstCoerce_Shader(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_shader", "Shader");
    }
    ((*local_this).set_shader)(std::move(param1_this), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader(const NodePath self, const Shader sha, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_shader_814_comment =
  "C++ Interface:\n"
  "set_shader(const NodePath self, const Shader sha, int priority)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NodePath_set_shader_814_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_shader_off(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_shader_off_815(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_shader_off")) {
    return nullptr;
  }
  // 1-void NodePath::set_shader_off(int priority = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:set_shader_off", (char **)keyword_list, &param1)) {
    ((*local_this).set_shader_off)((int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader_off(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_shader_off_815_comment =
  "C++ Interface:\n"
  "set_shader_off(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NodePath_set_shader_off_815_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_shader_auto(BitMask32 shader_switch, int priority = 0)
 * void NodePath::set_shader_auto(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_shader_auto_816(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_shader_auto")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePath::set_shader_auto(int priority)
      ((*local_this).set_shader_auto)();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 void NodePath::set_shader_auto(BitMask32 shader_switch, int priority = 0)
        PyObject *param1;
        int param2 = 0;
        static const char *keyword_list[] = {"shader_switch", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_shader_auto", (char **)keyword_list, &param1, &param2)) {
          BitMask32 *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_BitMask_uint32_t_32);
          if (param1_this != nullptr) {
            ((*local_this).set_shader_auto)(*param1_this, (int)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_shader_auto(int priority = 0)
        int param1;
        static const char *keyword_list[] = {"priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:set_shader_auto", (char **)keyword_list, &param1)) {
          ((*local_this).set_shader_auto)((int)param1);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_shader_auto(BitMask32 shader_switch, int priority = 0)
        PyObject *param1;
        int param2 = 0;
        static const char *keyword_list[] = {"shader_switch", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_shader_auto", (char **)keyword_list, &param1, &param2)) {
          BitMask< uint32_t, 32 > param1_local;
          BitMask32 *param1_this = Dtool_Coerce_BitMask_uint32_t_32(param1, param1_local);
          if ((param1_this != nullptr)) {
            ((*local_this).set_shader_auto)(*param1_this, (int)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePath::set_shader_auto(int priority = 0)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shader_auto() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader_auto(const NodePath self)\n"
      "set_shader_auto(const NodePath self, BitMask shader_switch, int priority)\n"
      "set_shader_auto(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_shader_auto_816_comment =
  "C++ Interface:\n"
  "set_shader_auto(const NodePath self)\n"
  "set_shader_auto(const NodePath self, BitMask shader_switch, int priority)\n"
  "set_shader_auto(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " * overloaded for auto shader customization\n"
  " */";
#else
static const char *Dtool_NodePath_set_shader_auto_816_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_shader(void)
 */
static PyObject *Dtool_NodePath_clear_shader_817(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_shader")) {
    return nullptr;
  }
  // 1-void NodePath::clear_shader(void)
  ((*local_this).clear_shader)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_shader_817_comment =
  "C++ Interface:\n"
  "clear_shader(const NodePath self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NodePath_clear_shader_817_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_shader_input(CPT_InternalName id, PN_stdfloat n1, PN_stdfloat n2, PN_stdfloat n3 = 0, PN_stdfloat n4 = 0, int priority = 0)
 * void NodePath::set_shader_input(CPT_InternalName , PyObject *, int priority = 0)
 * inline void NodePath::set_shader_input(CPT_InternalName id, Texture *tex, SamplerState const &sampler, int priority = 0)
 * inline void NodePath::set_shader_input(CPT_InternalName id, Texture *tex, bool read, bool write, int z = -1, int n = 0, int priority = 0)
 * inline void NodePath::set_shader_input(CPT_InternalName id, int n1, int n2, int n3 = 0, int n4 = 0, int priority = 0)
 * Rejected Remap [void NodePath::set_shader_input(ShaderInput &&input)]
 * void NodePath::set_shader_input(ShaderInput const &input)
 */
static PyObject *Dtool_NodePath_set_shader_input_818(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_shader_input")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "input")) {
        // 1-void NodePath::set_shader_input(ShaderInput const &input)
        ShaderInput const *arg_this = (ShaderInput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShaderInput, 1, "NodePath.set_shader_input", true, true);
        if (arg_this != nullptr) {
          ((*local_this).set_shader_input)(*arg_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_shader_input(CPT_InternalName , PyObject *, int priority)
      PyObject *param1;
      PyObject *param2;
      if ((kwds == nullptr || PyDict_Size(kwds) == 0) && PyArg_UnpackTuple(args, "set_shader_input", 2, 2, &param1, &param2)) {
        CPT(InternalName) param1_this;
        if (!Dtool_ConstCoerce_InternalName(param1, param1_this)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_shader_input", "InternalName");
        }
        invoke_extension(local_this).set_shader_input(std::move(param1_this), param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, int n1, int n2, int n3, int n4, int priority)
        PyObject *param1;
        int param2;
        int param3;
        static const char *keyword_list[] = {"id", "n1", "n2", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_shader_input", (char **)keyword_list, &param1, &param2, &param3)) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          if (param1_this != nullptr) {
            ((*local_this).set_shader_input)(param1_this, (int)param2, (int)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, PN_stdfloat n1, PN_stdfloat n2, PN_stdfloat n3, PN_stdfloat n4, int priority)
        PyObject *param1;
        float param2;
        float param3;
        static const char *keyword_list[] = {"id", "n1", "n2", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:set_shader_input", (char **)keyword_list, &param1, &param2, &param3)) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          if (param1_this != nullptr) {
            ((*local_this).set_shader_input)(param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, Texture *tex, SamplerState const &sampler, int priority)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"id", "tex", "sampler", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_shader_input", (char **)keyword_list, &param1, &param2, &param3)) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePath.set_shader_input", false, false);
          SamplerState const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_SamplerState);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ((*local_this).set_shader_input)(param1_this, param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_shader_input(CPT_InternalName , PyObject *, int priority)
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"param0", "param1", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:set_shader_input", (char **)keyword_list, &param1, &param2, &param3)) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          if (param1_this != nullptr) {
            invoke_extension(local_this).set_shader_input(param1_this, param2, (int)param3);
            PyObject *exception = _PyErr_OCCURRED();
            if (exception == PyExc_TypeError) {
              // TypeError raised; continue to next overload type.
            } else if (exception != nullptr) {
              return nullptr;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (UNLIKELY(notify->has_assert_failed())) {
                return Dtool_Raise_AssertionError();
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, int n1, int n2, int n3, int n4, int priority)
        PyObject *param1;
        int param2;
        int param3;
        static const char *keyword_list[] = {"id", "n1", "n2", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_shader_input", (char **)keyword_list, &param1, &param2, &param3)) {
          CPT(InternalName) param1_this;
          if (Dtool_ConstCoerce_InternalName(param1, param1_this)) {
            ((*local_this).set_shader_input)(std::move(param1_this), (int)param2, (int)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, PN_stdfloat n1, PN_stdfloat n2, PN_stdfloat n3, PN_stdfloat n4, int priority)
        PyObject *param1;
        float param2;
        float param3;
        static const char *keyword_list[] = {"id", "n1", "n2", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:set_shader_input", (char **)keyword_list, &param1, &param2, &param3)) {
          CPT(InternalName) param1_this;
          if (Dtool_ConstCoerce_InternalName(param1, param1_this)) {
            ((*local_this).set_shader_input)(std::move(param1_this), (PN_stdfloat)param2, (PN_stdfloat)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, Texture *tex, SamplerState const &sampler, int priority)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"id", "tex", "sampler", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_shader_input", (char **)keyword_list, &param1, &param2, &param3)) {
          CPT(InternalName) param1_this;
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePath.set_shader_input", false, false);
          SamplerState const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_SamplerState);
          if (Dtool_ConstCoerce_InternalName(param1, param1_this) && param2_this != nullptr && param3_this != nullptr) {
            ((*local_this).set_shader_input)(std::move(param1_this), param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_shader_input(CPT_InternalName , PyObject *, int priority)
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"param0", "param1", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:set_shader_input", (char **)keyword_list, &param1, &param2, &param3)) {
          CPT(InternalName) param1_this;
          if (Dtool_ConstCoerce_InternalName(param1, param1_this)) {
            invoke_extension(local_this).set_shader_input(std::move(param1_this), param2, (int)param3);
            PyObject *exception = _PyErr_OCCURRED();
            if (exception == PyExc_TypeError) {
              // TypeError raised; continue to next overload type.
            } else if (exception != nullptr) {
              return nullptr;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (UNLIKELY(notify->has_assert_failed())) {
                return Dtool_Raise_AssertionError();
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 4:
  case 5:
  case 6:
  case 7:
    {
      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, Texture *tex, bool read, bool write, int z = -1, int n = 0, int priority = 0)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5 = -1;
        int param6 = 0;
        int param7 = 0;
        static const char *keyword_list[] = {"id", "tex", "read", "write", "z", "n", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO|iii:set_shader_input", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePath.set_shader_input", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_shader_input)(param1_this, param2_this, (PyObject_IsTrue(param3) != 0), (PyObject_IsTrue(param4) != 0), (int)param5, (int)param6, (int)param7);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, int n1, int n2, int n3 = 0, int n4 = 0, int priority = 0)
        PyObject *param1;
        int param2;
        int param3;
        int param4;
        int param5 = 0;
        int param6 = 0;
        static const char *keyword_list[] = {"id", "n1", "n2", "n3", "n4", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiii|ii:set_shader_input", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          if (param1_this != nullptr) {
            ((*local_this).set_shader_input)(param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, PN_stdfloat n1, PN_stdfloat n2, PN_stdfloat n3 = 0, PN_stdfloat n4 = 0, int priority = 0)
        PyObject *param1;
        float param2;
        float param3;
        float param4;
        float param5 = 0;
        int param6 = 0;
        static const char *keyword_list[] = {"id", "n1", "n2", "n3", "n4", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf|fi:set_shader_input", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          if (param1_this != nullptr) {
            ((*local_this).set_shader_input)(param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (int)param6);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, Texture *tex, SamplerState const &sampler, int priority = 0)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"id", "tex", "sampler", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:set_shader_input", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePath.set_shader_input", false, false);
          SamplerState const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_SamplerState);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ((*local_this).set_shader_input)(param1_this, param2_this, *param3_this, (int)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, Texture *tex, bool read, bool write, int z = -1, int n = 0, int priority = 0)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5 = -1;
        int param6 = 0;
        int param7 = 0;
        static const char *keyword_list[] = {"id", "tex", "read", "write", "z", "n", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO|iii:set_shader_input", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
          CPT(InternalName) param1_this;
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePath.set_shader_input", false, false);
          if (Dtool_ConstCoerce_InternalName(param1, param1_this) && param2_this != nullptr) {
            ((*local_this).set_shader_input)(std::move(param1_this), param2_this, (PyObject_IsTrue(param3) != 0), (PyObject_IsTrue(param4) != 0), (int)param5, (int)param6, (int)param7);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, int n1, int n2, int n3 = 0, int n4 = 0, int priority = 0)
        PyObject *param1;
        int param2;
        int param3;
        int param4;
        int param5 = 0;
        int param6 = 0;
        static const char *keyword_list[] = {"id", "n1", "n2", "n3", "n4", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiii|ii:set_shader_input", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
          CPT(InternalName) param1_this;
          if (Dtool_ConstCoerce_InternalName(param1, param1_this)) {
            ((*local_this).set_shader_input)(std::move(param1_this), (int)param2, (int)param3, (int)param4, (int)param5, (int)param6);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, PN_stdfloat n1, PN_stdfloat n2, PN_stdfloat n3 = 0, PN_stdfloat n4 = 0, int priority = 0)
        PyObject *param1;
        float param2;
        float param3;
        float param4;
        float param5 = 0;
        int param6 = 0;
        static const char *keyword_list[] = {"id", "n1", "n2", "n3", "n4", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf|fi:set_shader_input", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
          CPT(InternalName) param1_this;
          if (Dtool_ConstCoerce_InternalName(param1, param1_this)) {
            ((*local_this).set_shader_input)(std::move(param1_this), (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (int)param6);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_shader_input(CPT_InternalName id, Texture *tex, SamplerState const &sampler, int priority = 0)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"id", "tex", "sampler", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:set_shader_input", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          CPT(InternalName) param1_this;
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePath.set_shader_input", false, false);
          SamplerState const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_SamplerState);
          if (Dtool_ConstCoerce_InternalName(param1, param1_this) && param2_this != nullptr && param3_this != nullptr) {
            ((*local_this).set_shader_input)(std::move(param1_this), param2_this, *param3_this, (int)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shader_input() takes 2, 3, 4, 5, 6, 7 or 8 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader_input(const NodePath self, const ShaderInput input)\n"
      "set_shader_input(const NodePath self, const InternalName param0, object param1)\n"
      "set_shader_input(const NodePath self, const InternalName id, int n1, int n2)\n"
      "set_shader_input(const NodePath self, const InternalName id, float n1, float n2)\n"
      "set_shader_input(const NodePath self, const InternalName id, Texture tex, const SamplerState sampler)\n"
      "set_shader_input(const NodePath self, const InternalName param0, object param1, int priority)\n"
      "set_shader_input(const NodePath self, const InternalName id, Texture tex, bool read, bool write, int z, int n, int priority)\n"
      "set_shader_input(const NodePath self, const InternalName id, int n1, int n2, int n3, int n4, int priority)\n"
      "set_shader_input(const NodePath self, const InternalName id, float n1, float n2, float n3, float n4, int priority)\n"
      "set_shader_input(const NodePath self, const InternalName id, Texture tex, const SamplerState sampler, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_shader_input_818_comment =
  "C++ Interface:\n"
  "set_shader_input(const NodePath self, const ShaderInput input)\n"
  "set_shader_input(const NodePath self, const InternalName param0, object param1)\n"
  "set_shader_input(const NodePath self, const InternalName id, int n1, int n2)\n"
  "set_shader_input(const NodePath self, const InternalName id, float n1, float n2)\n"
  "set_shader_input(const NodePath self, const InternalName id, Texture tex, const SamplerState sampler)\n"
  "set_shader_input(const NodePath self, const InternalName param0, object param1, int priority)\n"
  "set_shader_input(const NodePath self, const InternalName id, Texture tex, bool read, bool write, int z, int n, int priority)\n"
  "set_shader_input(const NodePath self, const InternalName id, int n1, int n2, int n3, int n4, int priority)\n"
  "set_shader_input(const NodePath self, const InternalName id, float n1, float n2, float n3, float n4, int priority)\n"
  "set_shader_input(const NodePath self, const InternalName id, Texture tex, const SamplerState sampler, int priority)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NodePath_set_shader_input_818_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_shader_inputs(PyObject *args, PyObject *kwargs)
 */
static PyObject *Dtool_NodePath_set_shader_inputs_819(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_shader_inputs")) {
    return nullptr;
  }
  invoke_extension(local_this).set_shader_inputs(args, kwds);
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_shader_inputs_819_comment =
  "";
#else
static const char *Dtool_NodePath_set_shader_inputs_819_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_shader_input(CPT_InternalName id)
 */
static PyObject *Dtool_NodePath_clear_shader_input_820(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_shader_input")) {
    return nullptr;
  }
  // 1-void NodePath::clear_shader_input(CPT_InternalName id)
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.clear_shader_input", "InternalName");
  }
  ((*local_this).clear_shader_input)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_shader_input(const NodePath self, const InternalName id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_shader_input_820_comment =
  "C++ Interface:\n"
  "clear_shader_input(const NodePath self, const InternalName id)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NodePath_clear_shader_input_820_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_instance_count(int instance_count)
 */
static PyObject *Dtool_NodePath_set_instance_count_821(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_instance_count")) {
    return nullptr;
  }
  // 1-void NodePath::set_instance_count(int instance_count)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_instance_count)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_instance_count(const NodePath self, int instance_count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_instance_count_821_comment =
  "C++ Interface:\n"
  "set_instance_count(const NodePath self, int instance_count)\n"
  "\n"
  "/**\n"
  " * Sets the geometry instance count, or 0 if geometry instancing should be\n"
  " * disabled.  Do not confuse with instanceTo which only applies to animation\n"
  " * instancing.\n"
  " */";
#else
static const char *Dtool_NodePath_set_instance_count_821_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Shader const *NodePath::get_shader(void) const
 */
static PyObject *Dtool_NodePath_get_shader_822(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-Shader const *NodePath::get_shader(void) const
  Shader const *return_value = ((*(const NodePath*)local_this).get_shader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Shader, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_shader_822_comment =
  "C++ Interface:\n"
  "get_shader(NodePath self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NodePath_get_shader_822_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ShaderInput NodePath::get_shader_input(CPT_InternalName id) const
 */
static PyObject *Dtool_NodePath_get_shader_input_823(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-ShaderInput NodePath::get_shader_input(CPT_InternalName id) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.get_shader_input", "InternalName");
  }
  ShaderInput *return_value = new ShaderInput(((*(const NodePath*)local_this).get_shader_input)(std::move(arg_this)));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ShaderInput, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shader_input(NodePath self, const InternalName id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_shader_input_823_comment =
  "C++ Interface:\n"
  "get_shader_input(NodePath self, const InternalName id)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NodePath_get_shader_input_823_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int NodePath::get_instance_count(void) const
 */
static PyObject *Dtool_NodePath_get_instance_count_824(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-int NodePath::get_instance_count(void) const
  int return_value = ((*(const NodePath*)local_this).get_instance_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_instance_count_824_comment =
  "C++ Interface:\n"
  "get_instance_count(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the geometry instance count, or 0 if disabled.  See\n"
  " * set_instance_count.\n"
  " */";
#else
static const char *Dtool_NodePath_get_instance_count_824_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_tex_transform(NodePath const &other, TextureStage *stage, TransformState const *transform)
 * void NodePath::set_tex_transform(TextureStage *stage, TransformState const *transform)
 */
static PyObject *Dtool_NodePath_set_tex_transform_825(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_tex_transform")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void NodePath::set_tex_transform(TextureStage *stage, TransformState const *transform)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"stage", "transform", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_tex_transform", (char **)keyword_list, &param1, &param2)) {
        TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_transform", false, true);
        TransformState const *param2_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TransformState, 2, "NodePath.set_tex_transform", true, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          ((*local_this).set_tex_transform)(param1_this, param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-void NodePath::set_tex_transform(NodePath const &other, TextureStage *stage, TransformState const *transform)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"other", "stage", "transform", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_tex_transform", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_tex_transform", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_transform", false, true);
        TransformState const *param3_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_TransformState, 3, "NodePath.set_tex_transform", true, true);
        if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
          ((*local_this).set_tex_transform)(*param1_this, param2_this, param3_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_tex_transform() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_transform(const NodePath self, TextureStage stage, const TransformState transform)\n"
      "set_tex_transform(const NodePath self, const NodePath other, TextureStage stage, const TransformState transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_tex_transform_825_comment =
  "C++ Interface:\n"
  "set_tex_transform(const NodePath self, TextureStage stage, const TransformState transform)\n"
  "set_tex_transform(const NodePath self, const NodePath other, TextureStage stage, const TransformState transform)\n"
  "\n"
  "/**\n"
  " * Sets the texture matrix on the current node to the indicated transform for\n"
  " * the given stage.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the texture matrix on the current node to the indicated transform for\n"
  " * the given stage.\n"
  " */";
#else
static const char *Dtool_NodePath_set_tex_transform_825_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_tex_transform(void)
 * void NodePath::clear_tex_transform(TextureStage *stage)
 */
static PyObject *Dtool_NodePath_clear_tex_transform_826(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_tex_transform")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePath::clear_tex_transform(void)
      ((*local_this).clear_tex_transform)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void NodePath::clear_tex_transform(TextureStage *stage)
      TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.clear_tex_transform", false, true);
      if (arg_this != nullptr) {
        ((*local_this).clear_tex_transform)(arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_tex_transform() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_tex_transform(const NodePath self)\n"
      "clear_tex_transform(const NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_tex_transform_826_comment =
  "C++ Interface:\n"
  "clear_tex_transform(const NodePath self)\n"
  "clear_tex_transform(const NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Removes all texture matrices from the current node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the texture matrix on the current node for the given stage.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_tex_transform_826_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_tex_transform(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_has_tex_transform_827(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_tex_transform(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.has_tex_transform", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const NodePath*)local_this).has_tex_transform)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_tex_transform(NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_tex_transform_827_comment =
  "C++ Interface:\n"
  "has_tex_transform(NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns true if there is an explicit texture matrix on the current node for\n"
  " * the given stage.\n"
  " */";
#else
static const char *Dtool_NodePath_has_tex_transform_827_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > NodePath::get_tex_transform(NodePath const &other, TextureStage *stage) const
 * ConstPointerTo< TransformState > NodePath::get_tex_transform(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_tex_transform_828(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "stage")) {
        // 1-ConstPointerTo< TransformState > NodePath::get_tex_transform(TextureStage *stage) const
        TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_tex_transform", false, true);
        if (arg_this != nullptr) {
          ConstPointerTo< TransformState > return_value = ((*(const NodePath*)local_this).get_tex_transform)(arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          TransformState const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
        }
      }
    }
    break;
  case 2:
    {
      // 1-ConstPointerTo< TransformState > NodePath::get_tex_transform(NodePath const &other, TextureStage *stage) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "stage", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_tex_transform", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.get_tex_transform", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.get_tex_transform", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          ConstPointerTo< TransformState > return_value = ((*(const NodePath*)local_this).get_tex_transform)(*param1_this, param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          TransformState const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_tex_transform() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tex_transform(NodePath self, TextureStage stage)\n"
      "get_tex_transform(NodePath self, const NodePath other, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tex_transform_828_comment =
  "C++ Interface:\n"
  "get_tex_transform(NodePath self, TextureStage stage)\n"
  "get_tex_transform(NodePath self, const NodePath other, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the texture matrix on the current node for the given stage, or\n"
  " * identity transform if there is no explicit transform set for the given\n"
  " * stage.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the texture matrix on the current node for the given stage,\n"
  " * relative to the other node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_tex_transform_828_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_tex_offset(NodePath const &other, TextureStage *stage, LVecBase2 const &uv)
 * inline void NodePath::set_tex_offset(NodePath const &other, TextureStage *stage, PN_stdfloat u, PN_stdfloat v)
 * inline void NodePath::set_tex_offset(TextureStage *stage, LVecBase2 const &uv)
 * inline void NodePath::set_tex_offset(TextureStage *stage, PN_stdfloat u, PN_stdfloat v)
 */
static PyObject *Dtool_NodePath_set_tex_offset_829(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_tex_offset")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void NodePath::set_tex_offset(TextureStage *stage, LVecBase2 const &uv)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"stage", "uv", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_tex_offset", (char **)keyword_list, &param1, &param2)) {
        TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_offset", false, true);
        LVecBase2f param2_local;
        LVecBase2 const *param2_this = Dtool_Coerce_LVecBase2f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_tex_offset", "LVecBase2f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_tex_offset)(param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      {
        // -2 inline void NodePath::set_tex_offset(NodePath const &other, TextureStage *stage, LVecBase2 const &uv)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"other", "stage", "uv", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_tex_offset", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_offset", false, false);
          LVecBase2 const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase2f);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ((*local_this).set_tex_offset)(*param1_this, param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_offset(TextureStage *stage, PN_stdfloat u, PN_stdfloat v)
        PyObject *param1;
        float param2;
        float param3;
        static const char *keyword_list[] = {"stage", "u", "v", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:set_tex_offset", (char **)keyword_list, &param1, &param2, &param3)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_offset", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_tex_offset)(param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_offset(NodePath const &other, TextureStage *stage, LVecBase2 const &uv)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"other", "stage", "uv", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_tex_offset", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_offset", false, false);
          LVecBase2f param3_local;
          LVecBase2 const *param3_this = Dtool_Coerce_LVecBase2f(param3, param3_local);
          if (param1_this != nullptr && param2_this != nullptr && (param3_this != nullptr)) {
            ((*local_this).set_tex_offset)(*param1_this, param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void NodePath::set_tex_offset(TextureStage *stage, PN_stdfloat u, PN_stdfloat v)
    }
    break;
  case 4:
    {
      // 1-inline void NodePath::set_tex_offset(NodePath const &other, TextureStage *stage, PN_stdfloat u, PN_stdfloat v)
      PyObject *param1;
      PyObject *param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"other", "stage", "u", "v", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOff:set_tex_offset", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_tex_offset", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_offset", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          ((*local_this).set_tex_offset)(*param1_this, param2_this, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_tex_offset() takes 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_offset(const NodePath self, TextureStage stage, const LVecBase2f uv)\n"
      "set_tex_offset(const NodePath self, const NodePath other, TextureStage stage, const LVecBase2f uv)\n"
      "set_tex_offset(const NodePath self, TextureStage stage, float u, float v)\n"
      "set_tex_offset(const NodePath self, const NodePath other, TextureStage stage, float u, float v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_tex_offset_829_comment =
  "C++ Interface:\n"
  "set_tex_offset(const NodePath self, TextureStage stage, const LVecBase2f uv)\n"
  "set_tex_offset(const NodePath self, const NodePath other, TextureStage stage, const LVecBase2f uv)\n"
  "set_tex_offset(const NodePath self, TextureStage stage, float u, float v)\n"
  "set_tex_offset(const NodePath self, const NodePath other, TextureStage stage, float u, float v)\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated offset to\n"
  " * UV's for the given stage.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated offset to\n"
  " * UV's for the given stage.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated offset to\n"
  " * UV's for the given stage.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated offset to\n"
  " * UV's for the given stage.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */";
#else
static const char *Dtool_NodePath_set_tex_offset_829_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_tex_rotate(NodePath const &other, TextureStage *stage, PN_stdfloat r)
 * inline void NodePath::set_tex_rotate(TextureStage *stage, PN_stdfloat r)
 */
static PyObject *Dtool_NodePath_set_tex_rotate_830(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_tex_rotate")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void NodePath::set_tex_rotate(TextureStage *stage, PN_stdfloat r)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"stage", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_tex_rotate", (char **)keyword_list, &param1, &param2)) {
        TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_rotate", false, true);
        if (param1_this != nullptr) {
          ((*local_this).set_tex_rotate)(param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-inline void NodePath::set_tex_rotate(NodePath const &other, TextureStage *stage, PN_stdfloat r)
      PyObject *param1;
      PyObject *param2;
      float param3;
      static const char *keyword_list[] = {"other", "stage", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOf:set_tex_rotate", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_tex_rotate", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_rotate", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          ((*local_this).set_tex_rotate)(*param1_this, param2_this, (PN_stdfloat)param3);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_tex_rotate() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_rotate(const NodePath self, TextureStage stage, float r)\n"
      "set_tex_rotate(const NodePath self, const NodePath other, TextureStage stage, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_tex_rotate_830_comment =
  "C++ Interface:\n"
  "set_tex_rotate(const NodePath self, TextureStage stage, float r)\n"
  "set_tex_rotate(const NodePath self, const NodePath other, TextureStage stage, float r)\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated rotation,\n"
  " * clockwise in degrees, to UV's for the given stage.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated rotation,\n"
  " * clockwise in degrees, to UV's for the given stage.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */";
#else
static const char *Dtool_NodePath_set_tex_rotate_830_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, LVecBase2 const &scale)
 * inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, LVecBase3 const &scale)
 * inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, PN_stdfloat scale)
 * inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, PN_stdfloat su, PN_stdfloat sv)
 * inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, PN_stdfloat su, PN_stdfloat sv, PN_stdfloat sw)
 * inline void NodePath::set_tex_scale(TextureStage *stage, LVecBase2 const &scale)
 * inline void NodePath::set_tex_scale(TextureStage *stage, LVecBase3 const &scale)
 * inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat scale)
 * inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat su, PN_stdfloat sv)
 * inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat su, PN_stdfloat sv, PN_stdfloat sw)
 */
static PyObject *Dtool_NodePath_set_tex_scale_831(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_tex_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 inline void NodePath::set_tex_scale(TextureStage *stage, LVecBase2 const &scale)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"stage", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_tex_scale", (char **)keyword_list, &param1, &param2)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_scale", false, false);
          LVecBase2 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase2f);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_tex_scale)(param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_scale(TextureStage *stage, LVecBase3 const &scale)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"stage", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_tex_scale", (char **)keyword_list, &param1, &param2)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_scale", false, false);
          LVecBase3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase3f);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_tex_scale)(param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat scale)
        PyObject *param1;
        float param2;
        static const char *keyword_list[] = {"stage", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_tex_scale", (char **)keyword_list, &param1, &param2)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_scale", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_tex_scale)(param1_this, (PN_stdfloat)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_scale(TextureStage *stage, LVecBase2 const &scale)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"stage", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_tex_scale", (char **)keyword_list, &param1, &param2)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_scale", false, false);
          LVecBase2f param2_local;
          LVecBase2 const *param2_this = Dtool_Coerce_LVecBase2f(param2, param2_local);
          if (param1_this != nullptr && (param2_this != nullptr)) {
            ((*local_this).set_tex_scale)(param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_scale(TextureStage *stage, LVecBase3 const &scale)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"stage", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_tex_scale", (char **)keyword_list, &param1, &param2)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_scale", false, false);
          LVecBase3f param2_local;
          LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          if (param1_this != nullptr && (param2_this != nullptr)) {
            ((*local_this).set_tex_scale)(param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat scale)
    }
    break;
  case 3:
    {
      {
        // -2 inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, LVecBase2 const &scale)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"other", "stage", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_tex_scale", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_scale", false, false);
          LVecBase2 const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase2f);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ((*local_this).set_tex_scale)(*param1_this, param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, LVecBase3 const &scale)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"other", "stage", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_tex_scale", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_scale", false, false);
          LVecBase3 const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase3f);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ((*local_this).set_tex_scale)(*param1_this, param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, PN_stdfloat scale)
        PyObject *param1;
        PyObject *param2;
        float param3;
        static const char *keyword_list[] = {"other", "stage", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOf:set_tex_scale", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_scale", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_tex_scale)(*param1_this, param2_this, (PN_stdfloat)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat su, PN_stdfloat sv)
        PyObject *param1;
        float param2;
        float param3;
        static const char *keyword_list[] = {"stage", "su", "sv", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:set_tex_scale", (char **)keyword_list, &param1, &param2, &param3)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_scale", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_tex_scale)(param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, LVecBase2 const &scale)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"other", "stage", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_tex_scale", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_scale", false, false);
          LVecBase2f param3_local;
          LVecBase2 const *param3_this = Dtool_Coerce_LVecBase2f(param3, param3_local);
          if (param1_this != nullptr && param2_this != nullptr && (param3_this != nullptr)) {
            ((*local_this).set_tex_scale)(*param1_this, param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, LVecBase3 const &scale)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"other", "stage", "scale", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_tex_scale", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_scale", false, false);
          LVecBase3f param3_local;
          LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if (param1_this != nullptr && param2_this != nullptr && (param3_this != nullptr)) {
            ((*local_this).set_tex_scale)(*param1_this, param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, PN_stdfloat scale)
      // No coercion possible: inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat su, PN_stdfloat sv)
    }
    break;
  case 4:
    {
      {
        // -2 inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, PN_stdfloat su, PN_stdfloat sv)
        PyObject *param1;
        PyObject *param2;
        float param3;
        float param4;
        static const char *keyword_list[] = {"other", "stage", "su", "sv", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOff:set_tex_scale", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_scale", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_tex_scale)(*param1_this, param2_this, (PN_stdfloat)param3, (PN_stdfloat)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat su, PN_stdfloat sv, PN_stdfloat sw)
        PyObject *param1;
        float param2;
        float param3;
        float param4;
        static const char *keyword_list[] = {"stage", "su", "sv", "sw", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:set_tex_scale", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_scale", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_tex_scale)(param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, PN_stdfloat su, PN_stdfloat sv)
      // No coercion possible: inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat su, PN_stdfloat sv, PN_stdfloat sw)
    }
    break;
  case 5:
    {
      // 1-inline void NodePath::set_tex_scale(NodePath const &other, TextureStage *stage, PN_stdfloat su, PN_stdfloat sv, PN_stdfloat sw)
      PyObject *param1;
      PyObject *param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"other", "stage", "su", "sv", "sw", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOfff:set_tex_scale", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_tex_scale", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_scale", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          ((*local_this).set_tex_scale)(*param1_this, param2_this, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_tex_scale() takes 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_scale(const NodePath self, TextureStage stage, const LVecBase2f scale)\n"
      "set_tex_scale(const NodePath self, TextureStage stage, const LVecBase3f scale)\n"
      "set_tex_scale(const NodePath self, TextureStage stage, float scale)\n"
      "set_tex_scale(const NodePath self, const NodePath other, TextureStage stage, const LVecBase2f scale)\n"
      "set_tex_scale(const NodePath self, const NodePath other, TextureStage stage, const LVecBase3f scale)\n"
      "set_tex_scale(const NodePath self, const NodePath other, TextureStage stage, float scale)\n"
      "set_tex_scale(const NodePath self, TextureStage stage, float su, float sv)\n"
      "set_tex_scale(const NodePath self, const NodePath other, TextureStage stage, float su, float sv)\n"
      "set_tex_scale(const NodePath self, TextureStage stage, float su, float sv, float sw)\n"
      "set_tex_scale(const NodePath self, const NodePath other, TextureStage stage, float su, float sv, float sw)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_tex_scale_831_comment =
  "C++ Interface:\n"
  "set_tex_scale(const NodePath self, TextureStage stage, const LVecBase2f scale)\n"
  "set_tex_scale(const NodePath self, TextureStage stage, const LVecBase3f scale)\n"
  "set_tex_scale(const NodePath self, TextureStage stage, float scale)\n"
  "set_tex_scale(const NodePath self, const NodePath other, TextureStage stage, const LVecBase2f scale)\n"
  "set_tex_scale(const NodePath self, const NodePath other, TextureStage stage, const LVecBase3f scale)\n"
  "set_tex_scale(const NodePath self, const NodePath other, TextureStage stage, float scale)\n"
  "set_tex_scale(const NodePath self, TextureStage stage, float su, float sv)\n"
  "set_tex_scale(const NodePath self, const NodePath other, TextureStage stage, float su, float sv)\n"
  "set_tex_scale(const NodePath self, TextureStage stage, float su, float sv, float sw)\n"
  "set_tex_scale(const NodePath self, const NodePath other, TextureStage stage, float su, float sv, float sw)\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated scale to\n"
  " * UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 2-d or 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated scale to\n"
  " * UV's for the given stage.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated scale to\n"
  " * UV's for the given stage.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated scale to\n"
  " * UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated scale to\n"
  " * UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated scale to\n"
  " * UV's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 2-d or 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated scale to\n"
  " * UV's for the given stage.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated scale to\n"
  " * UV's for the given stage.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated scale to\n"
  " * UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated scale to\n"
  " * UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */";
#else
static const char *Dtool_NodePath_set_tex_scale_831_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 NodePath::get_tex_offset(NodePath const &other, TextureStage *stage) const
 * inline LVecBase2 NodePath::get_tex_offset(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_tex_offset_832(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "stage")) {
        // 1-inline LVecBase2 NodePath::get_tex_offset(TextureStage *stage) const
        TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_tex_offset", false, true);
        if (arg_this != nullptr) {
          LVecBase2 *return_value = new LVecBase2(((*(const NodePath*)local_this).get_tex_offset)(arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline LVecBase2 NodePath::get_tex_offset(NodePath const &other, TextureStage *stage) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "stage", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_tex_offset", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.get_tex_offset", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.get_tex_offset", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          LVecBase2 *return_value = new LVecBase2(((*(const NodePath*)local_this).get_tex_offset)(*param1_this, param2_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_tex_offset() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tex_offset(NodePath self, TextureStage stage)\n"
      "get_tex_offset(NodePath self, const NodePath other, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tex_offset_832_comment =
  "C++ Interface:\n"
  "get_tex_offset(NodePath self, TextureStage stage)\n"
  "get_tex_offset(NodePath self, const NodePath other, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the offset set for the UV's for the given stage on the current\n"
  " * node.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the offset set for the UV's for the given stage on the current\n"
  " * node.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */";
#else
static const char *Dtool_NodePath_get_tex_offset_832_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NodePath::get_tex_rotate(NodePath const &other, TextureStage *stage) const
 * inline PN_stdfloat NodePath::get_tex_rotate(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_tex_rotate_833(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "stage")) {
        // 1-inline PN_stdfloat NodePath::get_tex_rotate(TextureStage *stage) const
        TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_tex_rotate", false, true);
        if (arg_this != nullptr) {
          PN_stdfloat return_value = ((*(const NodePath*)local_this).get_tex_rotate)(arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline PN_stdfloat NodePath::get_tex_rotate(NodePath const &other, TextureStage *stage) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "stage", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_tex_rotate", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.get_tex_rotate", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.get_tex_rotate", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          PN_stdfloat return_value = ((*(const NodePath*)local_this).get_tex_rotate)(*param1_this, param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_tex_rotate() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tex_rotate(NodePath self, TextureStage stage)\n"
      "get_tex_rotate(NodePath self, const NodePath other, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tex_rotate_833_comment =
  "C++ Interface:\n"
  "get_tex_rotate(NodePath self, TextureStage stage)\n"
  "get_tex_rotate(NodePath self, const NodePath other, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the rotation set for the UV's for the given stage on the current\n"
  " * node.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the rotation set for the UV's for the given stage on the current\n"
  " * node.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */";
#else
static const char *Dtool_NodePath_get_tex_rotate_833_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 NodePath::get_tex_scale(NodePath const &other, TextureStage *stage) const
 * inline LVecBase2 NodePath::get_tex_scale(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_tex_scale_834(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "stage")) {
        // 1-inline LVecBase2 NodePath::get_tex_scale(TextureStage *stage) const
        TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_tex_scale", false, true);
        if (arg_this != nullptr) {
          LVecBase2 *return_value = new LVecBase2(((*(const NodePath*)local_this).get_tex_scale)(arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline LVecBase2 NodePath::get_tex_scale(NodePath const &other, TextureStage *stage) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "stage", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_tex_scale", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.get_tex_scale", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.get_tex_scale", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          LVecBase2 *return_value = new LVecBase2(((*(const NodePath*)local_this).get_tex_scale)(*param1_this, param2_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_tex_scale() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tex_scale(NodePath self, TextureStage stage)\n"
      "get_tex_scale(NodePath self, const NodePath other, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tex_scale_834_comment =
  "C++ Interface:\n"
  "get_tex_scale(NodePath self, TextureStage stage)\n"
  "get_tex_scale(NodePath self, const NodePath other, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the scale set for the UV's for the given stage on the current node.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the scale set for the UV's for the given stage on the current node.\n"
  " *\n"
  " * This call is appropriate for ordinary 2-d texture coordinates.\n"
  " */";
#else
static const char *Dtool_NodePath_get_tex_scale_834_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_tex_pos(NodePath const &other, TextureStage *stage, LVecBase3 const &uvw)
 * inline void NodePath::set_tex_pos(NodePath const &other, TextureStage *stage, PN_stdfloat u, PN_stdfloat v, PN_stdfloat w)
 * inline void NodePath::set_tex_pos(TextureStage *stage, LVecBase3 const &uvw)
 * inline void NodePath::set_tex_pos(TextureStage *stage, PN_stdfloat u, PN_stdfloat v, PN_stdfloat w)
 */
static PyObject *Dtool_NodePath_set_tex_pos_835(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_tex_pos")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void NodePath::set_tex_pos(TextureStage *stage, LVecBase3 const &uvw)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"stage", "uvw", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_tex_pos", (char **)keyword_list, &param1, &param2)) {
        TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_pos", false, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_tex_pos", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_tex_pos)(param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-inline void NodePath::set_tex_pos(NodePath const &other, TextureStage *stage, LVecBase3 const &uvw)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"other", "stage", "uvw", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_tex_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_tex_pos", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_pos", false, true);
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_tex_pos", "LVecBase3f");
        }
        if (param1_this != nullptr && param2_this != nullptr) {
          ((*local_this).set_tex_pos)(*param1_this, param2_this, *param3_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 4:
    {
      // 1-inline void NodePath::set_tex_pos(TextureStage *stage, PN_stdfloat u, PN_stdfloat v, PN_stdfloat w)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"stage", "u", "v", "w", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:set_tex_pos", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_pos", false, true);
        if (param1_this != nullptr) {
          ((*local_this).set_tex_pos)(param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 5:
    {
      // 1-inline void NodePath::set_tex_pos(NodePath const &other, TextureStage *stage, PN_stdfloat u, PN_stdfloat v, PN_stdfloat w)
      PyObject *param1;
      PyObject *param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"other", "stage", "u", "v", "w", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOfff:set_tex_pos", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_tex_pos", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_pos", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          ((*local_this).set_tex_pos)(*param1_this, param2_this, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_tex_pos() takes 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_pos(const NodePath self, TextureStage stage, const LVecBase3f uvw)\n"
      "set_tex_pos(const NodePath self, const NodePath other, TextureStage stage, const LVecBase3f uvw)\n"
      "set_tex_pos(const NodePath self, TextureStage stage, float u, float v, float w)\n"
      "set_tex_pos(const NodePath self, const NodePath other, TextureStage stage, float u, float v, float w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_tex_pos_835_comment =
  "C++ Interface:\n"
  "set_tex_pos(const NodePath self, TextureStage stage, const LVecBase3f uvw)\n"
  "set_tex_pos(const NodePath self, const NodePath other, TextureStage stage, const LVecBase3f uvw)\n"
  "set_tex_pos(const NodePath self, TextureStage stage, float u, float v, float w)\n"
  "set_tex_pos(const NodePath self, const NodePath other, TextureStage stage, float u, float v, float w)\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated offset to\n"
  " * UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated offset to\n"
  " * UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated offset to\n"
  " * UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated offset to\n"
  " * UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */";
#else
static const char *Dtool_NodePath_set_tex_pos_835_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_tex_hpr(NodePath const &other, TextureStage *stage, LVecBase3 const &hpr)
 * inline void NodePath::set_tex_hpr(NodePath const &other, TextureStage *stage, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 * inline void NodePath::set_tex_hpr(TextureStage *stage, LVecBase3 const &hpr)
 * inline void NodePath::set_tex_hpr(TextureStage *stage, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_NodePath_set_tex_hpr_836(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_tex_hpr")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void NodePath::set_tex_hpr(TextureStage *stage, LVecBase3 const &hpr)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"stage", "hpr", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_tex_hpr", (char **)keyword_list, &param1, &param2)) {
        TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_hpr", false, true);
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_tex_hpr", "LVecBase3f");
        }
        if (param1_this != nullptr) {
          ((*local_this).set_tex_hpr)(param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-inline void NodePath::set_tex_hpr(NodePath const &other, TextureStage *stage, LVecBase3 const &hpr)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"other", "stage", "hpr", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_tex_hpr", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_tex_hpr", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_hpr", false, true);
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_tex_hpr", "LVecBase3f");
        }
        if (param1_this != nullptr && param2_this != nullptr) {
          ((*local_this).set_tex_hpr)(*param1_this, param2_this, *param3_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 4:
    {
      // 1-inline void NodePath::set_tex_hpr(TextureStage *stage, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"stage", "h", "p", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:set_tex_hpr", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_hpr", false, true);
        if (param1_this != nullptr) {
          ((*local_this).set_tex_hpr)(param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 5:
    {
      // 1-inline void NodePath::set_tex_hpr(NodePath const &other, TextureStage *stage, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      PyObject *param1;
      PyObject *param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"other", "stage", "h", "p", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOfff:set_tex_hpr", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_tex_hpr", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.set_tex_hpr", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          ((*local_this).set_tex_hpr)(*param1_this, param2_this, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_tex_hpr() takes 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_hpr(const NodePath self, TextureStage stage, const LVecBase3f hpr)\n"
      "set_tex_hpr(const NodePath self, const NodePath other, TextureStage stage, const LVecBase3f hpr)\n"
      "set_tex_hpr(const NodePath self, TextureStage stage, float h, float p, float r)\n"
      "set_tex_hpr(const NodePath self, const NodePath other, TextureStage stage, float h, float p, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_tex_hpr_836_comment =
  "C++ Interface:\n"
  "set_tex_hpr(const NodePath self, TextureStage stage, const LVecBase3f hpr)\n"
  "set_tex_hpr(const NodePath self, const NodePath other, TextureStage stage, const LVecBase3f hpr)\n"
  "set_tex_hpr(const NodePath self, TextureStage stage, float h, float p, float r)\n"
  "set_tex_hpr(const NodePath self, const NodePath other, TextureStage stage, float h, float p, float r)\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated rotation,\n"
  " * as a 3-D HPR, to UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated rotation,\n"
  " * as a 3-D HPR, to UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated rotation,\n"
  " * as a 3-D HPR, to UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a texture matrix on the current node to apply the indicated rotation,\n"
  " * as a 3-D HPR, to UVW's for the given stage.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */";
#else
static const char *Dtool_NodePath_set_tex_hpr_836_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 NodePath::get_tex_pos(NodePath const &other, TextureStage *stage) const
 * inline LVecBase3 NodePath::get_tex_pos(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_tex_pos_837(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "stage")) {
        // 1-inline LVecBase3 NodePath::get_tex_pos(TextureStage *stage) const
        TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_tex_pos", false, true);
        if (arg_this != nullptr) {
          LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_tex_pos)(arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline LVecBase3 NodePath::get_tex_pos(NodePath const &other, TextureStage *stage) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "stage", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_tex_pos", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.get_tex_pos", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.get_tex_pos", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_tex_pos)(*param1_this, param2_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_tex_pos() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tex_pos(NodePath self, TextureStage stage)\n"
      "get_tex_pos(NodePath self, const NodePath other, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tex_pos_837_comment =
  "C++ Interface:\n"
  "get_tex_pos(NodePath self, TextureStage stage)\n"
  "get_tex_pos(NodePath self, const NodePath other, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the offset set for the UVW's for the given stage on the current\n"
  " * node.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the offset set for the UVW's for the given stage on the current\n"
  " * node.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */";
#else
static const char *Dtool_NodePath_get_tex_pos_837_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 NodePath::get_tex_hpr(NodePath const &other, TextureStage *stage) const
 * inline LVecBase3 NodePath::get_tex_hpr(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_tex_hpr_838(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "stage")) {
        // 1-inline LVecBase3 NodePath::get_tex_hpr(TextureStage *stage) const
        TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_tex_hpr", false, true);
        if (arg_this != nullptr) {
          LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_tex_hpr)(arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline LVecBase3 NodePath::get_tex_hpr(NodePath const &other, TextureStage *stage) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "stage", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_tex_hpr", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.get_tex_hpr", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.get_tex_hpr", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_tex_hpr)(*param1_this, param2_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_tex_hpr() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tex_hpr(NodePath self, TextureStage stage)\n"
      "get_tex_hpr(NodePath self, const NodePath other, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tex_hpr_838_comment =
  "C++ Interface:\n"
  "get_tex_hpr(NodePath self, TextureStage stage)\n"
  "get_tex_hpr(NodePath self, const NodePath other, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the 3-D HPR set for the UVW's for the given stage on the current\n"
  " * node.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the 3-D HPR set for the UVW's for the given stage on the current\n"
  " * node.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */";
#else
static const char *Dtool_NodePath_get_tex_hpr_838_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 NodePath::get_tex_scale_3d(NodePath const &other, TextureStage *stage) const
 * inline LVecBase3 NodePath::get_tex_scale_3d(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_tex_scale_3d_839(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "stage")) {
        // 1-inline LVecBase3 NodePath::get_tex_scale_3d(TextureStage *stage) const
        TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_tex_scale_3d", false, true);
        if (arg_this != nullptr) {
          LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_tex_scale_3d)(arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline LVecBase3 NodePath::get_tex_scale_3d(NodePath const &other, TextureStage *stage) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"other", "stage", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_tex_scale_3d", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.get_tex_scale_3d", true, true);
        TextureStage *param2_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextureStage, 2, "NodePath.get_tex_scale_3d", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          LVecBase3 *return_value = new LVecBase3(((*(const NodePath*)local_this).get_tex_scale_3d)(*param1_this, param2_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_tex_scale_3d() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tex_scale_3d(NodePath self, TextureStage stage)\n"
      "get_tex_scale_3d(NodePath self, const NodePath other, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tex_scale_3d_839_comment =
  "C++ Interface:\n"
  "get_tex_scale_3d(NodePath self, TextureStage stage)\n"
  "get_tex_scale_3d(NodePath self, const NodePath other, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the scale set for the UVW's for the given stage on the current\n"
  " * node.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the scale set for the UVW's for the given stage on the current\n"
  " * node.\n"
  " *\n"
  " * This call is appropriate for 3-d texture coordinates.\n"
  " */";
#else
static const char *Dtool_NodePath_get_tex_scale_3d_839_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_tex_gen(TextureStage *stage, RenderAttrib::TexGenMode mode, LTexCoord3 const &constant_value, int priority = 0)
 * void NodePath::set_tex_gen(TextureStage *stage, RenderAttrib::TexGenMode mode, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_tex_gen_840(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_tex_gen")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void NodePath::set_tex_gen(TextureStage *stage, RenderAttrib::TexGenMode mode, int priority)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"stage", "mode", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_tex_gen", (char **)keyword_list, &param1, &param2)) {
        TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_gen", false, true);
        if (param1_this != nullptr) {
          ((*local_this).set_tex_gen)(param1_this, (RenderAttrib::TexGenMode)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 void NodePath::set_tex_gen(TextureStage *stage, RenderAttrib::TexGenMode mode, LTexCoord3 const &constant_value, int priority = 0)
        PyObject *param1;
        int param2;
        PyObject *param3;
        int param4 = 0;
        static const char *keyword_list[] = {"stage", "mode", "constant_value", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO|i:set_tex_gen", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_gen", false, false);
          LTexCoord3 const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LPoint3f);
          if (param1_this != nullptr && param3_this != nullptr) {
            ((*local_this).set_tex_gen)(param1_this, (RenderAttrib::TexGenMode)param2, *param3_this, (int)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_tex_gen(TextureStage *stage, RenderAttrib::TexGenMode mode, int priority = 0)
        PyObject *param1;
        int param2;
        int param3;
        static const char *keyword_list[] = {"stage", "mode", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_tex_gen", (char **)keyword_list, &param1, &param2, &param3)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_gen", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_tex_gen)(param1_this, (RenderAttrib::TexGenMode)param2, (int)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePath::set_tex_gen(TextureStage *stage, RenderAttrib::TexGenMode mode, LTexCoord3 const &constant_value, int priority = 0)
        PyObject *param1;
        int param2;
        PyObject *param3;
        int param4 = 0;
        static const char *keyword_list[] = {"stage", "mode", "constant_value", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO|i:set_tex_gen", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_gen", false, false);
          LPoint3f param3_local;
          LTexCoord3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
          if (param1_this != nullptr && (param3_this != nullptr)) {
            ((*local_this).set_tex_gen)(param1_this, (RenderAttrib::TexGenMode)param2, *param3_this, (int)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePath::set_tex_gen(TextureStage *stage, RenderAttrib::TexGenMode mode, int priority = 0)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_tex_gen() takes 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_gen(const NodePath self, TextureStage stage, int mode)\n"
      "set_tex_gen(const NodePath self, TextureStage stage, int mode, const LPoint3f constant_value, int priority)\n"
      "set_tex_gen(const NodePath self, TextureStage stage, int mode, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_tex_gen_840_comment =
  "C++ Interface:\n"
  "set_tex_gen(const NodePath self, TextureStage stage, int mode)\n"
  "set_tex_gen(const NodePath self, TextureStage stage, int mode, const LPoint3f constant_value, int priority)\n"
  "set_tex_gen(const NodePath self, TextureStage stage, int mode, int priority)\n"
  "\n"
  "/**\n"
  " * Enables automatic texture coordinate generation for the indicated texture\n"
  " * stage.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Enables automatic texture coordinate generation for the indicated texture\n"
  " * stage.  This version of this method is useful when setting M_constant,\n"
  " * which requires a constant texture coordinate value.\n"
  " */";
#else
static const char *Dtool_NodePath_set_tex_gen_840_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_tex_gen(void)
 * void NodePath::clear_tex_gen(TextureStage *stage)
 */
static PyObject *Dtool_NodePath_clear_tex_gen_841(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_tex_gen")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePath::clear_tex_gen(void)
      ((*local_this).clear_tex_gen)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void NodePath::clear_tex_gen(TextureStage *stage)
      TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.clear_tex_gen", false, true);
      if (arg_this != nullptr) {
        ((*local_this).clear_tex_gen)(arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_tex_gen() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_tex_gen(const NodePath self)\n"
      "clear_tex_gen(const NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_tex_gen_841_comment =
  "C++ Interface:\n"
  "clear_tex_gen(const NodePath self)\n"
  "clear_tex_gen(const NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Removes the texture coordinate generation mode from all texture stages on\n"
  " * this node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Disables automatic texture coordinate generation for the indicated texture\n"
  " * stage.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_tex_gen_841_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_tex_gen(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_has_tex_gen_842(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_tex_gen(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.has_tex_gen", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const NodePath*)local_this).has_tex_gen)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_tex_gen(NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_tex_gen_842_comment =
  "C++ Interface:\n"
  "has_tex_gen(NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a mode for automatic texture coordinate generation\n"
  " * on the current node for the given stage.\n"
  " */";
#else
static const char *Dtool_NodePath_has_tex_gen_842_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * RenderAttrib::TexGenMode NodePath::get_tex_gen(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_tex_gen_843(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-RenderAttrib::TexGenMode NodePath::get_tex_gen(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_tex_gen", false, true);
  if (arg_this != nullptr) {
    RenderAttrib::TexGenMode return_value = ((*(const NodePath*)local_this).get_tex_gen)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tex_gen(NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tex_gen_843_comment =
  "C++ Interface:\n"
  "get_tex_gen(NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the texture coordinate generation mode for the given stage, or\n"
  " * M_off if there is no explicit mode set for the given stage.\n"
  " */";
#else
static const char *Dtool_NodePath_get_tex_gen_843_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_tex_projector(TextureStage *stage, NodePath const &from, NodePath const &to, int lens_index = 0)
 */
static PyObject *Dtool_NodePath_set_tex_projector_844(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_tex_projector")) {
    return nullptr;
  }
  // 1-void NodePath::set_tex_projector(TextureStage *stage, NodePath const &from, NodePath const &to, int lens_index = 0)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  int param4 = 0;
  static const char *keyword_list[] = {"stage", "from", "to", "lens_index", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:set_tex_projector", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.set_tex_projector", false, true);
    NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "NodePath.set_tex_projector", true, true);
    NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "NodePath.set_tex_projector", true, true);
    if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
      ((*local_this).set_tex_projector)(param1_this, *param2_this, *param3_this, (int)param4);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_projector(const NodePath self, TextureStage stage, const NodePath from, const NodePath to, int lens_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_tex_projector_844_comment =
  "C++ Interface:\n"
  "set_tex_projector(const NodePath self, TextureStage stage, const NodePath from, const NodePath to, int lens_index)\n"
  "\n"
  "/**\n"
  " * Establishes a TexProjectorEffect on this node, which can be used to\n"
  " * establish projective texturing (but see also the\n"
  " * NodePath::project_texture() convenience function), or it can be used to\n"
  " * bind this node's texture transform to particular node's position in space,\n"
  " * allowing a LerpInterval (for instance) to adjust this node's texture\n"
  " * coordinates.\n"
  " *\n"
  " * If to is a LensNode, then the fourth parameter, lens_index, can be provided\n"
  " * to select a particular lens to apply.  Otherwise lens_index is not used.\n"
  " */";
#else
static const char *Dtool_NodePath_set_tex_projector_844_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_tex_projector(void)
 * void NodePath::clear_tex_projector(TextureStage *stage)
 */
static PyObject *Dtool_NodePath_clear_tex_projector_845(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_tex_projector")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePath::clear_tex_projector(void)
      ((*local_this).clear_tex_projector)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void NodePath::clear_tex_projector(TextureStage *stage)
      TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.clear_tex_projector", false, true);
      if (arg_this != nullptr) {
        ((*local_this).clear_tex_projector)(arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_tex_projector() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_tex_projector(const NodePath self)\n"
      "clear_tex_projector(const NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_tex_projector_845_comment =
  "C++ Interface:\n"
  "clear_tex_projector(const NodePath self)\n"
  "clear_tex_projector(const NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Removes the TexProjectorEffect for the indicated stage from this node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the TexProjectorEffect for all stages from this node.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_tex_projector_845_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_tex_projector(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_has_tex_projector_846(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_tex_projector(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.has_tex_projector", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const NodePath*)local_this).has_tex_projector)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_tex_projector(NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_tex_projector_846_comment =
  "C++ Interface:\n"
  "has_tex_projector(NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns true if this node has a TexProjectorEffect for the indicated stage,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_NodePath_has_tex_projector_846_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::get_tex_projector_from(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_tex_projector_from_847(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::get_tex_projector_from(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_tex_projector_from", false, true);
  if (arg_this != nullptr) {
    NodePath *return_value = new NodePath(((*(const NodePath*)local_this).get_tex_projector_from)(arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tex_projector_from(NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tex_projector_from_847_comment =
  "C++ Interface:\n"
  "get_tex_projector_from(NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the \"from\" node associated with the TexProjectorEffect on the\n"
  " * indicated stage.  The relative transform between the \"from\" and the \"to\"\n"
  " * nodes is automatically applied to the texture transform each frame.\n"
  " */";
#else
static const char *Dtool_NodePath_get_tex_projector_from_847_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::get_tex_projector_to(TextureStage *stage) const
 */
static PyObject *Dtool_NodePath_get_tex_projector_to_848(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::get_tex_projector_to(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.get_tex_projector_to", false, true);
  if (arg_this != nullptr) {
    NodePath *return_value = new NodePath(((*(const NodePath*)local_this).get_tex_projector_to)(arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tex_projector_to(NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tex_projector_to_848_comment =
  "C++ Interface:\n"
  "get_tex_projector_to(NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the \"to\" node associated with the TexProjectorEffect on the\n"
  " * indicated stage.  The relative transform between the \"from\" and the \"to\"\n"
  " * nodes is automatically applied to the texture transform each frame.\n"
  " */";
#else
static const char *Dtool_NodePath_get_tex_projector_to_848_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::project_texture(TextureStage *stage, Texture *tex, NodePath const &projector)
 */
static PyObject *Dtool_NodePath_project_texture_849(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.project_texture")) {
    return nullptr;
  }
  // 1-void NodePath::project_texture(TextureStage *stage, Texture *tex, NodePath const &projector)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"stage", "tex", "projector", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:project_texture", (char **)keyword_list, &param1, &param2, &param3)) {
    TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePath.project_texture", false, true);
    Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePath.project_texture", false, true);
    NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "NodePath.project_texture", true, true);
    if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
      ((*local_this).project_texture)(param1_this, param2_this, *param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project_texture(const NodePath self, TextureStage stage, Texture tex, const NodePath projector)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_project_texture_849_comment =
  "C++ Interface:\n"
  "project_texture(const NodePath self, TextureStage stage, Texture tex, const NodePath projector)\n"
  "\n"
  "/**\n"
  " * A convenience function to enable projective texturing at this node level\n"
  " * and below, using the indicated NodePath (which should contain a LensNode)\n"
  " * as the projector.\n"
  " */";
#else
static const char *Dtool_NodePath_project_texture_849_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::clear_project_texture(TextureStage *stage)
 */
static PyObject *Dtool_NodePath_clear_project_texture_850(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_project_texture")) {
    return nullptr;
  }
  // 1-inline void NodePath::clear_project_texture(TextureStage *stage)
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.clear_project_texture", false, true);
  if (arg_this != nullptr) {
    ((*local_this).clear_project_texture)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_project_texture(const NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_project_texture_850_comment =
  "C++ Interface:\n"
  "clear_project_texture(const NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of project_texture().\n"
  " */";
#else
static const char *Dtool_NodePath_clear_project_texture_850_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::has_texcoord(std::string const &texcoord_name) const
 */
static PyObject *Dtool_NodePath_has_texcoord_851(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::has_texcoord(std::string const &texcoord_name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const NodePath*)local_this).has_texcoord)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_texcoord(NodePath self, str texcoord_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_texcoord_851_comment =
  "C++ Interface:\n"
  "has_texcoord(NodePath self, str texcoord_name)\n"
  "\n"
  "/**\n"
  " * Returns true if there are at least some vertices at this node and below\n"
  " * that use the named texture coordinate set, false otherwise.  Pass the empty\n"
  " * string for the default texture coordinate set.\n"
  " */";
#else
static const char *Dtool_NodePath_has_texcoord_851_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_vertex_column(InternalName const *name) const
 */
static PyObject *Dtool_NodePath_has_vertex_column_852(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_vertex_column(InternalName const *name) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.has_vertex_column", "InternalName");
  }
  bool return_value = ((*(const NodePath*)local_this).has_vertex_column)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_vertex_column(NodePath self, const InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_vertex_column_852_comment =
  "C++ Interface:\n"
  "has_vertex_column(NodePath self, const InternalName name)\n"
  "\n"
  "/**\n"
  " * Returns true if there are at least some vertices at this node and below\n"
  " * that contain a reference to the indicated vertex data column name, false\n"
  " * otherwise.\n"
  " *\n"
  " * This is particularly useful for testing whether a particular model has a\n"
  " * given texture coordinate set (but see has_texcoord()).\n"
  " */";
#else
static const char *Dtool_NodePath_has_vertex_column_852_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * InternalNameCollection NodePath::find_all_vertex_columns(void) const
 * InternalNameCollection NodePath::find_all_vertex_columns(std::string const &name) const
 */
static PyObject *Dtool_NodePath_find_all_vertex_columns_853(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-InternalNameCollection NodePath::find_all_vertex_columns(void) const
      InternalNameCollection *return_value = new InternalNameCollection(((*(const NodePath*)local_this).find_all_vertex_columns)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalNameCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-InternalNameCollection NodePath::find_all_vertex_columns(std::string const &name) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        InternalNameCollection *return_value = new InternalNameCollection(((*(const NodePath*)local_this).find_all_vertex_columns)(std::string(param1_str, param1_len)));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalNameCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "find_all_vertex_columns() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_vertex_columns(NodePath self)\n"
      "find_all_vertex_columns(NodePath self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_all_vertex_columns_853_comment =
  "C++ Interface:\n"
  "find_all_vertex_columns(NodePath self)\n"
  "find_all_vertex_columns(NodePath self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a list of all vertex array columns stored on some geometry found at\n"
  " * this node level and below.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a list of all vertex array columns stored on some geometry found at\n"
  " * this node level and below that match the indicated name (which may contain\n"
  " * wildcard characters).\n"
  " */";
#else
static const char *Dtool_NodePath_find_all_vertex_columns_853_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * InternalNameCollection NodePath::find_all_texcoords(void) const
 * InternalNameCollection NodePath::find_all_texcoords(std::string const &name) const
 */
static PyObject *Dtool_NodePath_find_all_texcoords_854(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-InternalNameCollection NodePath::find_all_texcoords(void) const
      InternalNameCollection *return_value = new InternalNameCollection(((*(const NodePath*)local_this).find_all_texcoords)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalNameCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-InternalNameCollection NodePath::find_all_texcoords(std::string const &name) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        InternalNameCollection *return_value = new InternalNameCollection(((*(const NodePath*)local_this).find_all_texcoords)(std::string(param1_str, param1_len)));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalNameCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "find_all_texcoords() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_texcoords(NodePath self)\n"
      "find_all_texcoords(NodePath self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_all_texcoords_854_comment =
  "C++ Interface:\n"
  "find_all_texcoords(NodePath self)\n"
  "find_all_texcoords(NodePath self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a list of all texture coordinate sets used by any geometry at this\n"
  " * node level and below.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a list of all texture coordinate sets used by any geometry at this\n"
  " * node level and below that match the indicated name (which may contain\n"
  " * wildcard characters).\n"
  " */";
#else
static const char *Dtool_NodePath_find_all_texcoords_854_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *NodePath::find_texture(TextureStage *stage) const
 * Texture *NodePath::find_texture(std::string const &name) const
 */
static PyObject *Dtool_NodePath_find_texture_855(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  {
    // -2 Texture *NodePath::find_texture(TextureStage *stage) const
    TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.find_texture", false, false);
    if (arg_this != nullptr) {
      Texture *return_value = ((*(const NodePath*)local_this).find_texture)(arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 Texture *NodePath::find_texture(std::string const &name) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      Texture *return_value = ((*(const NodePath*)local_this).find_texture)(std::string(param1_str, param1_len));
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: Texture *NodePath::find_texture(TextureStage *stage) const
  // No coercion possible: Texture *NodePath::find_texture(std::string const &name) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_texture(NodePath self, TextureStage stage)\n"
      "find_texture(NodePath self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_texture_855_comment =
  "C++ Interface:\n"
  "find_texture(NodePath self, TextureStage stage)\n"
  "find_texture(NodePath self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first texture found applied to geometry at this node or below\n"
  " * that matches the indicated name (which may contain wildcards).  Returns the\n"
  " * texture if it is found, or NULL if it is not.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the first texture found applied to geometry at this node or below\n"
  " * that is assigned to the indicated texture stage.  Returns the texture if it\n"
  " * is found, or NULL if it is not.\n"
  " */";
#else
static const char *Dtool_NodePath_find_texture_855_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextureCollection NodePath::find_all_textures(void) const
 * TextureCollection NodePath::find_all_textures(TextureStage *stage) const
 * TextureCollection NodePath::find_all_textures(std::string const &name) const
 */
static PyObject *Dtool_NodePath_find_all_textures_856(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-TextureCollection NodePath::find_all_textures(void) const
      TextureCollection *return_value = new TextureCollection(((*(const NodePath*)local_this).find_all_textures)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 TextureCollection NodePath::find_all_textures(TextureStage *stage) const
        TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.find_all_textures", false, false);
        if (arg_this != nullptr) {
          TextureCollection *return_value = new TextureCollection(((*(const NodePath*)local_this).find_all_textures)(arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureCollection, true, false);
        }
      }

      {
        // -2 TextureCollection NodePath::find_all_textures(std::string const &name) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TextureCollection *return_value = new TextureCollection(((*(const NodePath*)local_this).find_all_textures)(std::string(param1_str, param1_len)));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureCollection, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: TextureCollection NodePath::find_all_textures(TextureStage *stage) const
      // No coercion possible: TextureCollection NodePath::find_all_textures(std::string const &name) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "find_all_textures() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_textures(NodePath self)\n"
      "find_all_textures(NodePath self, TextureStage stage)\n"
      "find_all_textures(NodePath self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_all_textures_856_comment =
  "C++ Interface:\n"
  "find_all_textures(NodePath self)\n"
  "find_all_textures(NodePath self, TextureStage stage)\n"
  "find_all_textures(NodePath self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a list of a textures applied to geometry at this node and below.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a list of a textures applied to geometry at this node and below\n"
  " * that match the indicated name (which may contain wildcard characters).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a list of a textures on geometry at this node and below that are\n"
  " * assigned to the indicated texture stage.\n"
  " */";
#else
static const char *Dtool_NodePath_find_all_textures_856_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextureStage *NodePath::find_texture_stage(std::string const &name) const
 */
static PyObject *Dtool_NodePath_find_texture_stage_857(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-TextureStage *NodePath::find_texture_stage(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    TextureStage *return_value = ((*(const NodePath*)local_this).find_texture_stage)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_texture_stage(NodePath self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_texture_stage_857_comment =
  "C++ Interface:\n"
  "find_texture_stage(NodePath self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first TextureStage found applied to geometry at this node or\n"
  " * below that matches the indicated name (which may contain wildcards).\n"
  " * Returns the TextureStage if it is found, or NULL if it is not.\n"
  " */";
#else
static const char *Dtool_NodePath_find_texture_stage_857_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextureStageCollection NodePath::find_all_texture_stages(void) const
 * TextureStageCollection NodePath::find_all_texture_stages(std::string const &name) const
 */
static PyObject *Dtool_NodePath_find_all_texture_stages_858(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-TextureStageCollection NodePath::find_all_texture_stages(void) const
      TextureStageCollection *return_value = new TextureStageCollection(((*(const NodePath*)local_this).find_all_texture_stages)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureStageCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-TextureStageCollection NodePath::find_all_texture_stages(std::string const &name) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        TextureStageCollection *return_value = new TextureStageCollection(((*(const NodePath*)local_this).find_all_texture_stages)(std::string(param1_str, param1_len)));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureStageCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "find_all_texture_stages() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_texture_stages(NodePath self)\n"
      "find_all_texture_stages(NodePath self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_all_texture_stages_858_comment =
  "C++ Interface:\n"
  "find_all_texture_stages(NodePath self)\n"
  "find_all_texture_stages(NodePath self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a list of a TextureStages applied to geometry at this node and\n"
  " * below.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a list of a TextureStages applied to geometry at this node and\n"
  " * below that match the indicated name (which may contain wildcard\n"
  " * characters).\n"
  " */";
#else
static const char *Dtool_NodePath_find_all_texture_stages_858_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::unify_texture_stages(TextureStage *stage)
 */
static PyObject *Dtool_NodePath_unify_texture_stages_859(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.unify_texture_stages")) {
    return nullptr;
  }
  // 1-void NodePath::unify_texture_stages(TextureStage *stage)
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "NodePath.unify_texture_stages", false, true);
  if (arg_this != nullptr) {
    ((*local_this).unify_texture_stages)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unify_texture_stages(const NodePath self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_unify_texture_stages_859_comment =
  "C++ Interface:\n"
  "unify_texture_stages(const NodePath self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Searches through all TextureStages at this node and below.  Any\n"
  " * TextureStages that share the same name as the indicated TextureStage object\n"
  " * are replaced with this object, thus ensuring that all geometry at this node\n"
  " * and below with a particular TextureStage name is using the same\n"
  " * TextureStage object.\n"
  " */";
#else
static const char *Dtool_NodePath_unify_texture_stages_859_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Material *NodePath::find_material(std::string const &name) const
 */
static PyObject *Dtool_NodePath_find_material_860(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-Material *NodePath::find_material(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    Material *return_value = ((*(const NodePath*)local_this).find_material)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Material, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_material(NodePath self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_material_860_comment =
  "C++ Interface:\n"
  "find_material(NodePath self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first material found applied to geometry at this node or below\n"
  " * that matches the indicated name (which may contain wildcards).  Returns the\n"
  " * material if it is found, or NULL if it is not.\n"
  " */";
#else
static const char *Dtool_NodePath_find_material_860_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * MaterialCollection NodePath::find_all_materials(void) const
 * MaterialCollection NodePath::find_all_materials(std::string const &name) const
 */
static PyObject *Dtool_NodePath_find_all_materials_861(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-MaterialCollection NodePath::find_all_materials(void) const
      MaterialCollection *return_value = new MaterialCollection(((*(const NodePath*)local_this).find_all_materials)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MaterialCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-MaterialCollection NodePath::find_all_materials(std::string const &name) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        MaterialCollection *return_value = new MaterialCollection(((*(const NodePath*)local_this).find_all_materials)(std::string(param1_str, param1_len)));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MaterialCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "find_all_materials() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_materials(NodePath self)\n"
      "find_all_materials(NodePath self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_all_materials_861_comment =
  "C++ Interface:\n"
  "find_all_materials(NodePath self)\n"
  "find_all_materials(NodePath self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a list of a materials applied to geometry at this node and below.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a list of a materials applied to geometry at this node and below\n"
  " * that match the indicated name (which may contain wildcard characters).\n"
  " */";
#else
static const char *Dtool_NodePath_find_all_materials_861_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_material(Material *tex, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_material_862(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_material")) {
    return nullptr;
  }
  // 1-void NodePath::set_material(Material *tex, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"tex", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_material", (char **)keyword_list, &param1, &param2)) {
    Material *param1_this = (Material *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Material, 1, "NodePath.set_material", false, true);
    if (param1_this != nullptr) {
      ((*local_this).set_material)(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_material(const NodePath self, Material tex, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_material_862_comment =
  "C++ Interface:\n"
  "set_material(const NodePath self, Material tex, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render using the indicated\n"
  " * material.\n"
  " *\n"
  " * Previously, this operation made a copy of the material structure, but\n"
  " * nowadays it assigns the pointer directly.\n"
  " */";
#else
static const char *Dtool_NodePath_set_material_862_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_material_off(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_material_off_863(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_material_off")) {
    return nullptr;
  }
  // 1-void NodePath::set_material_off(int priority = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:set_material_off", (char **)keyword_list, &param1)) {
    ((*local_this).set_material_off)((int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_material_off(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_material_off_863_comment =
  "C++ Interface:\n"
  "set_material_off(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render using no material.\n"
  " * This is normally the default, but it may be useful to use this to\n"
  " * contradict set_material() at a higher node level (or, with a priority, to\n"
  " * override a set_material() at a lower level).\n"
  " */";
#else
static const char *Dtool_NodePath_set_material_off_863_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_material(void)
 */
static PyObject *Dtool_NodePath_clear_material_864(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_material")) {
    return nullptr;
  }
  // 1-void NodePath::clear_material(void)
  ((*local_this).clear_material)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_material_864_comment =
  "C++ Interface:\n"
  "clear_material(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any material adjustment that may have been set via\n"
  " * set_material() from this particular node.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_material_864_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_material(void) const
 */
static PyObject *Dtool_NodePath_has_material_865(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_material(void) const
  bool return_value = ((*(const NodePath*)local_this).has_material)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_material_865_comment =
  "C++ Interface:\n"
  "has_material(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a material has been applied to this particular node via\n"
  " * set_material(), false otherwise.\n"
  " */";
#else
static const char *Dtool_NodePath_has_material_865_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< Material > NodePath::get_material(void) const
 */
static PyObject *Dtool_NodePath_get_material_866(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-PointerTo< Material > NodePath::get_material(void) const
  PointerTo< Material > return_value = ((*(const NodePath*)local_this).get_material)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Material *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Material, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_material_866_comment =
  "C++ Interface:\n"
  "get_material(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the material that has been set on this particular node, or NULL if\n"
  " * no material has been set.  This is not necessarily the material that will\n"
  " * be applied to the geometry at or below this level, as another material at a\n"
  " * higher or lower level may override.\n"
  " *\n"
  " * See also find_material().\n"
  " */";
#else
static const char *Dtool_NodePath_get_material_866_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::replace_material(Material *mat, Material *new_mat)
 */
static PyObject *Dtool_NodePath_replace_material_867(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.replace_material")) {
    return nullptr;
  }
  // 1-void NodePath::replace_material(Material *mat, Material *new_mat)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"mat", "new_mat", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:replace_material", (char **)keyword_list, &param1, &param2)) {
    Material *param1_this = (Material *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Material, 1, "NodePath.replace_material", false, true);
    Material *param2_this = (Material *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Material, 2, "NodePath.replace_material", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).replace_material)(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "replace_material(const NodePath self, Material mat, Material new_mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_replace_material_867_comment =
  "C++ Interface:\n"
  "replace_material(const NodePath self, Material mat, Material new_mat)\n"
  "\n"
  "/**\n"
  " * Recursively searches the scene graph for references to the given material,\n"
  " * and replaces them with the new material.\n"
  " */";
#else
static const char *Dtool_NodePath_replace_material_867_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_fog(Fog *fog, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_fog_868(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_fog")) {
    return nullptr;
  }
  // 1-void NodePath::set_fog(Fog *fog, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"fog", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_fog", (char **)keyword_list, &param1, &param2)) {
    Fog *param1_this = (Fog *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Fog, 1, "NodePath.set_fog", false, true);
    if (param1_this != nullptr) {
      ((*local_this).set_fog)(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fog(const NodePath self, Fog fog, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_fog_868_comment =
  "C++ Interface:\n"
  "set_fog(const NodePath self, Fog fog, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render using the indicated\n"
  " * fog.\n"
  " */";
#else
static const char *Dtool_NodePath_set_fog_868_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_fog_off(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_fog_off_869(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_fog_off")) {
    return nullptr;
  }
  // 1-void NodePath::set_fog_off(int priority = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:set_fog_off", (char **)keyword_list, &param1)) {
    ((*local_this).set_fog_off)((int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fog_off(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_fog_off_869_comment =
  "C++ Interface:\n"
  "set_fog_off(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render using no fog.  This is\n"
  " * normally the default, but it may be useful to use this to contradict\n"
  " * set_fog() at a higher node level (or, with a priority, to override a\n"
  " * set_fog() at a lower level).\n"
  " */";
#else
static const char *Dtool_NodePath_set_fog_off_869_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_fog(void)
 */
static PyObject *Dtool_NodePath_clear_fog_870(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_fog")) {
    return nullptr;
  }
  // 1-void NodePath::clear_fog(void)
  ((*local_this).clear_fog)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_fog_870_comment =
  "C++ Interface:\n"
  "clear_fog(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any fog adjustment that may have been set via set_fog()\n"
  " * or set_fog_off() from this particular node.  This allows whatever fogs\n"
  " * might be otherwise affecting the geometry to show instead.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_fog_870_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_fog(void) const
 */
static PyObject *Dtool_NodePath_has_fog_871(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_fog(void) const
  bool return_value = ((*(const NodePath*)local_this).has_fog)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_fog_871_comment =
  "C++ Interface:\n"
  "has_fog(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a fog has been applied to this particular node via\n"
  " * set_fog(), false otherwise.  This is not the same thing as asking whether\n"
  " * the geometry at this node will be rendered with fog, as there may be a fog\n"
  " * in effect from a higher or lower level.\n"
  " */";
#else
static const char *Dtool_NodePath_has_fog_871_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_fog_off(void) const
 */
static PyObject *Dtool_NodePath_has_fog_off_872(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_fog_off(void) const
  bool return_value = ((*(const NodePath*)local_this).has_fog_off)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_fog_off_872_comment =
  "C++ Interface:\n"
  "has_fog_off(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a fog has been specifically disabled on this particular\n"
  " * node via set_fog_off(), false otherwise.  This is not the same thing as\n"
  " * asking whether the geometry at this node will be rendered unfogged, as\n"
  " * there may be a fog in effect from a higher or lower level.\n"
  " */";
#else
static const char *Dtool_NodePath_has_fog_off_872_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Fog *NodePath::get_fog(void) const
 */
static PyObject *Dtool_NodePath_get_fog_873(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-Fog *NodePath::get_fog(void) const
  Fog *return_value = ((*(const NodePath*)local_this).get_fog)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Fog, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_fog_873_comment =
  "C++ Interface:\n"
  "get_fog(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the fog that has been set on this particular node, or NULL if no\n"
  " * fog has been set.  This is not necessarily the fog that will be applied to\n"
  " * the geometry at or below this level, as another fog at a higher or lower\n"
  " * level may override.\n"
  " */";
#else
static const char *Dtool_NodePath_get_fog_873_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_render_mode_wireframe(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_render_mode_wireframe_874(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_render_mode_wireframe")) {
    return nullptr;
  }
  // 1-void NodePath::set_render_mode_wireframe(int priority = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:set_render_mode_wireframe", (char **)keyword_list, &param1)) {
    ((*local_this).set_render_mode_wireframe)((int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_mode_wireframe(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_render_mode_wireframe_874_comment =
  "C++ Interface:\n"
  "set_render_mode_wireframe(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " * Sets up the geometry at this level and below (unless overridden) to render\n"
  " * in wireframe mode.\n"
  " */";
#else
static const char *Dtool_NodePath_set_render_mode_wireframe_874_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_render_mode_filled(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_render_mode_filled_875(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_render_mode_filled")) {
    return nullptr;
  }
  // 1-void NodePath::set_render_mode_filled(int priority = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:set_render_mode_filled", (char **)keyword_list, &param1)) {
    ((*local_this).set_render_mode_filled)((int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_mode_filled(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_render_mode_filled_875_comment =
  "C++ Interface:\n"
  "set_render_mode_filled(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " * Sets up the geometry at this level and below (unless overridden) to render\n"
  " * in filled (i.e.  not wireframe) mode.\n"
  " */";
#else
static const char *Dtool_NodePath_set_render_mode_filled_875_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_render_mode_filled_wireframe(LColor const &wireframe_color, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_render_mode_filled_wireframe_876(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_render_mode_filled_wireframe")) {
    return nullptr;
  }
  // 1-void NodePath::set_render_mode_filled_wireframe(LColor const &wireframe_color, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"wireframe_color", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_render_mode_filled_wireframe", (char **)keyword_list, &param1, &param2)) {
    LVecBase4f param1_local;
    LColor const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_render_mode_filled_wireframe", "LVecBase4f");
    }
    ((*local_this).set_render_mode_filled_wireframe)(*param1_this, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_mode_filled_wireframe(const NodePath self, const LVecBase4f wireframe_color, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_render_mode_filled_wireframe_876_comment =
  "C++ Interface:\n"
  "set_render_mode_filled_wireframe(const NodePath self, const LVecBase4f wireframe_color, int priority)\n"
  "\n"
  "/**\n"
  " * Sets up the geometry at this level and below (unless overridden) to render\n"
  " * in filled, but overlay the wireframe on top with a fixed color.  This is\n"
  " * useful for debug visualizations.\n"
  " */";
#else
static const char *Dtool_NodePath_set_render_mode_filled_wireframe_876_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_render_mode_thickness(PN_stdfloat thickness, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_render_mode_thickness_877(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_render_mode_thickness")) {
    return nullptr;
  }
  // 1-void NodePath::set_render_mode_thickness(PN_stdfloat thickness, int priority = 0)
  float param1;
  int param2 = 0;
  static const char *keyword_list[] = {"thickness", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "f|i:set_render_mode_thickness", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_render_mode_thickness)((PN_stdfloat)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_mode_thickness(const NodePath self, float thickness, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_render_mode_thickness_877_comment =
  "C++ Interface:\n"
  "set_render_mode_thickness(const NodePath self, float thickness, int priority)\n"
  "\n"
  "/**\n"
  " * Sets up the point geometry at this level and below to render as thick\n"
  " * points (that is, billboarded quads).  The thickness is in pixels, unless\n"
  " * set_render_mode_perspective is also true, in which case it is in 3-D units.\n"
  " *\n"
  " * If you want the quads to be individually textured, you should also set a\n"
  " * TexGenAttrib::M_point_sprite on the node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_render_mode_thickness_877_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_render_mode_perspective(bool perspective, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_render_mode_perspective_878(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_render_mode_perspective")) {
    return nullptr;
  }
  // 1-void NodePath::set_render_mode_perspective(bool perspective, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"perspective", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_render_mode_perspective", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_render_mode_perspective)((PyObject_IsTrue(param1) != 0), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_mode_perspective(const NodePath self, bool perspective, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_render_mode_perspective_878_comment =
  "C++ Interface:\n"
  "set_render_mode_perspective(const NodePath self, bool perspective, int priority)\n"
  "\n"
  "/**\n"
  " * Sets up the point geometry at this level and below to render as perspective\n"
  " * sprites (that is, billboarded quads).  The thickness, as specified with\n"
  " * set_render_mode_thickness(), is the width of each point in 3-D units,\n"
  " * unless it is overridden on a per-vertex basis.  This does not affect\n"
  " * geometry other than points.\n"
  " *\n"
  " * If you want the quads to be individually textured, you should also set a\n"
  " * TexGenAttrib::M_point_sprite on the node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_render_mode_perspective_878_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_render_mode(RenderModeAttrib::Mode mode, PN_stdfloat thickness, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_render_mode_879(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_render_mode")) {
    return nullptr;
  }
  // 1-void NodePath::set_render_mode(RenderModeAttrib::Mode mode, PN_stdfloat thickness, int priority = 0)
  int param1;
  float param2;
  int param3 = 0;
  static const char *keyword_list[] = {"mode", "thickness", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if|i:set_render_mode", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_render_mode)((RenderModeAttrib::Mode)param1, (PN_stdfloat)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_mode(const NodePath self, int mode, float thickness, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_render_mode_879_comment =
  "C++ Interface:\n"
  "set_render_mode(const NodePath self, int mode, float thickness, int priority)\n"
  "\n"
  "/**\n"
  " * Sets up the geometry at this level and below (unless overridden) to render\n"
  " * in the specified mode and with the indicated line and/or point thickness.\n"
  " */";
#else
static const char *Dtool_NodePath_set_render_mode_879_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_render_mode(void)
 */
static PyObject *Dtool_NodePath_clear_render_mode_880(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_render_mode")) {
    return nullptr;
  }
  // 1-void NodePath::clear_render_mode(void)
  ((*local_this).clear_render_mode)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_render_mode_880_comment =
  "C++ Interface:\n"
  "clear_render_mode(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any render mode adjustment that may have been set on\n"
  " * this node via set_render_mode_wireframe() or set_render_mode_filled().\n"
  " */";
#else
static const char *Dtool_NodePath_clear_render_mode_880_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_render_mode(void) const
 */
static PyObject *Dtool_NodePath_has_render_mode_881(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_render_mode(void) const
  bool return_value = ((*(const NodePath*)local_this).has_render_mode)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_render_mode_881_comment =
  "C++ Interface:\n"
  "has_render_mode(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a render mode has been explicitly set on this particular\n"
  " * node via set_render_mode() (or set_render_mode_wireframe() or\n"
  " * set_render_mode_filled()), false otherwise.\n"
  " */";
#else
static const char *Dtool_NodePath_has_render_mode_881_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * RenderModeAttrib::Mode NodePath::get_render_mode(void) const
 */
static PyObject *Dtool_NodePath_get_render_mode_882(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-RenderModeAttrib::Mode NodePath::get_render_mode(void) const
  RenderModeAttrib::Mode return_value = ((*(const NodePath*)local_this).get_render_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_render_mode_882_comment =
  "C++ Interface:\n"
  "get_render_mode(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the render mode that has been specifically set on this node via\n"
  " * set_render_mode(), or M_unchanged if nothing has been set.\n"
  " */";
#else
static const char *Dtool_NodePath_get_render_mode_882_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NodePath::get_render_mode_thickness(void) const
 */
static PyObject *Dtool_NodePath_get_render_mode_thickness_883(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-PN_stdfloat NodePath::get_render_mode_thickness(void) const
  PN_stdfloat return_value = ((*(const NodePath*)local_this).get_render_mode_thickness)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_render_mode_thickness_883_comment =
  "C++ Interface:\n"
  "get_render_mode_thickness(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the render mode thickness that has been specifically set on this\n"
  " * node via set_render_mode(), or 1.0 if nothing has been set.\n"
  " */";
#else
static const char *Dtool_NodePath_get_render_mode_thickness_883_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::get_render_mode_perspective(void) const
 */
static PyObject *Dtool_NodePath_get_render_mode_perspective_884(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::get_render_mode_perspective(void) const
  bool return_value = ((*(const NodePath*)local_this).get_render_mode_perspective)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_render_mode_perspective_884_comment =
  "C++ Interface:\n"
  "get_render_mode_perspective(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the flag that has been set on this node via\n"
  " * set_render_mode_perspective(), or false if no flag has been set.\n"
  " */";
#else
static const char *Dtool_NodePath_get_render_mode_perspective_884_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_two_sided(bool two_sided, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_two_sided_885(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_two_sided")) {
    return nullptr;
  }
  // 1-void NodePath::set_two_sided(bool two_sided, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"two_sided", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_two_sided", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_two_sided)((PyObject_IsTrue(param1) != 0), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_two_sided(const NodePath self, bool two_sided, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_two_sided_885_comment =
  "C++ Interface:\n"
  "set_two_sided(const NodePath self, bool two_sided, int priority)\n"
  "\n"
  "/**\n"
  " * Specifically sets or disables two-sided rendering mode on this particular\n"
  " * node.  If no other nodes override, this will cause backfacing polygons to\n"
  " * be drawn (in two-sided mode, true) or culled (in one-sided mode, false).\n"
  " */";
#else
static const char *Dtool_NodePath_set_two_sided_885_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_two_sided(void)
 */
static PyObject *Dtool_NodePath_clear_two_sided_886(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_two_sided")) {
    return nullptr;
  }
  // 1-void NodePath::clear_two_sided(void)
  ((*local_this).clear_two_sided)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_two_sided_886_comment =
  "C++ Interface:\n"
  "clear_two_sided(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any two-sided adjustment that may have been set on this\n"
  " * node via set_two_sided(). The geometry at this level and below will\n"
  " * subsequently be rendered either two-sided or one-sided, according to\n"
  " * whatever other nodes may have had set_two_sided() on it, or according to\n"
  " * the initial state otherwise.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_two_sided_886_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_two_sided(void) const
 */
static PyObject *Dtool_NodePath_has_two_sided_887(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_two_sided(void) const
  bool return_value = ((*(const NodePath*)local_this).has_two_sided)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_two_sided_887_comment =
  "C++ Interface:\n"
  "has_two_sided(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a two-sided adjustment has been explicitly set on this\n"
  " * particular node via set_two_sided().  If this returns true, then\n"
  " * get_two_sided() may be called to determine which has been set.\n"
  " */";
#else
static const char *Dtool_NodePath_has_two_sided_887_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::get_two_sided(void) const
 */
static PyObject *Dtool_NodePath_get_two_sided_888(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::get_two_sided(void) const
  bool return_value = ((*(const NodePath*)local_this).get_two_sided)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_two_sided_888_comment =
  "C++ Interface:\n"
  "get_two_sided(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if two-sided rendering has been specifically set on this node\n"
  " * via set_two_sided(), or false if one-sided rendering has been specifically\n"
  " * set, or if nothing has been specifically set.  See also has_two_sided().\n"
  " * This does not necessarily imply that the geometry will or will not be\n"
  " * rendered two-sided, as there may be other nodes that override.\n"
  " */";
#else
static const char *Dtool_NodePath_get_two_sided_888_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_depth_test(bool depth_test, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_depth_test_889(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_depth_test")) {
    return nullptr;
  }
  // 1-void NodePath::set_depth_test(bool depth_test, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"depth_test", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_depth_test", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_depth_test)((PyObject_IsTrue(param1) != 0), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth_test(const NodePath self, bool depth_test, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_depth_test_889_comment =
  "C++ Interface:\n"
  "set_depth_test(const NodePath self, bool depth_test, int priority)\n"
  "\n"
  "/**\n"
  " * Specifically sets or disables the testing of the depth buffer on this\n"
  " * particular node.  This is normally on in the 3-d scene graph and off in the\n"
  " * 2-d scene graph; it should be on for rendering most 3-d objects properly.\n"
  " */";
#else
static const char *Dtool_NodePath_set_depth_test_889_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_depth_test(void)
 */
static PyObject *Dtool_NodePath_clear_depth_test_890(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_depth_test")) {
    return nullptr;
  }
  // 1-void NodePath::clear_depth_test(void)
  ((*local_this).clear_depth_test)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_depth_test_890_comment =
  "C++ Interface:\n"
  "clear_depth_test(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any depth-test adjustment that may have been set on this\n"
  " * node via set_depth_test().\n"
  " */";
#else
static const char *Dtool_NodePath_clear_depth_test_890_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_depth_test(void) const
 */
static PyObject *Dtool_NodePath_has_depth_test_891(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_depth_test(void) const
  bool return_value = ((*(const NodePath*)local_this).has_depth_test)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_depth_test_891_comment =
  "C++ Interface:\n"
  "has_depth_test(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a depth-test adjustment has been explicitly set on this\n"
  " * particular node via set_depth_test().  If this returns true, then\n"
  " * get_depth_test() may be called to determine which has been set.\n"
  " */";
#else
static const char *Dtool_NodePath_has_depth_test_891_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::get_depth_test(void) const
 */
static PyObject *Dtool_NodePath_get_depth_test_892(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::get_depth_test(void) const
  bool return_value = ((*(const NodePath*)local_this).get_depth_test)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_depth_test_892_comment =
  "C++ Interface:\n"
  "get_depth_test(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if depth-test rendering has been specifically set on this node\n"
  " * via set_depth_test(), or false if depth-test rendering has been\n"
  " * specifically disabled.  If nothing has been specifically set, returns true.\n"
  " * See also has_depth_test().\n"
  " */";
#else
static const char *Dtool_NodePath_get_depth_test_892_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_depth_write(bool depth_write, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_depth_write_893(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_depth_write")) {
    return nullptr;
  }
  // 1-void NodePath::set_depth_write(bool depth_write, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"depth_write", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_depth_write", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_depth_write)((PyObject_IsTrue(param1) != 0), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth_write(const NodePath self, bool depth_write, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_depth_write_893_comment =
  "C++ Interface:\n"
  "set_depth_write(const NodePath self, bool depth_write, int priority)\n"
  "\n"
  "/**\n"
  " * Specifically sets or disables the writing to the depth buffer on this\n"
  " * particular node.  This is normally on in the 3-d scene graph and off in the\n"
  " * 2-d scene graph; it should be on for rendering most 3-d objects properly.\n"
  " */";
#else
static const char *Dtool_NodePath_set_depth_write_893_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_depth_write(void)
 */
static PyObject *Dtool_NodePath_clear_depth_write_894(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_depth_write")) {
    return nullptr;
  }
  // 1-void NodePath::clear_depth_write(void)
  ((*local_this).clear_depth_write)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_depth_write_894_comment =
  "C++ Interface:\n"
  "clear_depth_write(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any depth-write adjustment that may have been set on\n"
  " * this node via set_depth_write().\n"
  " */";
#else
static const char *Dtool_NodePath_clear_depth_write_894_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_depth_write(void) const
 */
static PyObject *Dtool_NodePath_has_depth_write_895(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_depth_write(void) const
  bool return_value = ((*(const NodePath*)local_this).has_depth_write)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_depth_write_895_comment =
  "C++ Interface:\n"
  "has_depth_write(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a depth-write adjustment has been explicitly set on this\n"
  " * particular node via set_depth_write().  If this returns true, then\n"
  " * get_depth_write() may be called to determine which has been set.\n"
  " */";
#else
static const char *Dtool_NodePath_has_depth_write_895_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::get_depth_write(void) const
 */
static PyObject *Dtool_NodePath_get_depth_write_896(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::get_depth_write(void) const
  bool return_value = ((*(const NodePath*)local_this).get_depth_write)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_depth_write_896_comment =
  "C++ Interface:\n"
  "get_depth_write(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if depth-write rendering has been specifically set on this\n"
  " * node via set_depth_write(), or false if depth-write rendering has been\n"
  " * specifically disabled.  If nothing has been specifically set, returns true.\n"
  " * See also has_depth_write().\n"
  " */";
#else
static const char *Dtool_NodePath_get_depth_write_896_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_depth_offset(int bias, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_depth_offset_897(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_depth_offset")) {
    return nullptr;
  }
  // 1-void NodePath::set_depth_offset(int bias, int priority = 0)
  int param1;
  int param2 = 0;
  static const char *keyword_list[] = {"bias", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|i:set_depth_offset", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_depth_offset)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth_offset(const NodePath self, int bias, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_depth_offset_897_comment =
  "C++ Interface:\n"
  "set_depth_offset(const NodePath self, int bias, int priority)\n"
  "\n"
  "/**\n"
  " * This instructs the graphics driver to apply an offset or bias to the\n"
  " * generated depth values for rendered polygons, before they are written to\n"
  " * the depth buffer.  This can be used to shift polygons forward slightly, to\n"
  " * resolve depth conflicts, or self-shadowing artifacts on thin objects.  The\n"
  " * bias is always an integer number, and each integer increment represents the\n"
  " * smallest possible increment in Z that is sufficient to completely resolve\n"
  " * two coplanar polygons.  Positive numbers are closer towards the camera.\n"
  " */";
#else
static const char *Dtool_NodePath_set_depth_offset_897_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_depth_offset(void)
 */
static PyObject *Dtool_NodePath_clear_depth_offset_898(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_depth_offset")) {
    return nullptr;
  }
  // 1-void NodePath::clear_depth_offset(void)
  ((*local_this).clear_depth_offset)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_depth_offset_898_comment =
  "C++ Interface:\n"
  "clear_depth_offset(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any depth-offset adjustment that may have been set on\n"
  " * this node via set_depth_offset().\n"
  " */";
#else
static const char *Dtool_NodePath_clear_depth_offset_898_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_depth_offset(void) const
 */
static PyObject *Dtool_NodePath_has_depth_offset_899(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_depth_offset(void) const
  bool return_value = ((*(const NodePath*)local_this).has_depth_offset)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_depth_offset_899_comment =
  "C++ Interface:\n"
  "has_depth_offset(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a depth-offset adjustment has been explicitly set on this\n"
  " * particular node via set_depth_offset().  If this returns true, then\n"
  " * get_depth_offset() may be called to determine which has been set.\n"
  " */";
#else
static const char *Dtool_NodePath_has_depth_offset_899_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int NodePath::get_depth_offset(void) const
 */
static PyObject *Dtool_NodePath_get_depth_offset_900(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-int NodePath::get_depth_offset(void) const
  int return_value = ((*(const NodePath*)local_this).get_depth_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_depth_offset_900_comment =
  "C++ Interface:\n"
  "get_depth_offset(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the depth offset value if it has been specified using\n"
  " * set_depth_offset, or 0 if not.\n"
  " */";
#else
static const char *Dtool_NodePath_get_depth_offset_900_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::do_billboard_axis(NodePath const &camera, PN_stdfloat offset)
 */
static PyObject *Dtool_NodePath_do_billboard_axis_901(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.do_billboard_axis")) {
    return nullptr;
  }
  // 1-void NodePath::do_billboard_axis(NodePath const &camera, PN_stdfloat offset)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"camera", "offset", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:do_billboard_axis", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.do_billboard_axis", true, true);
    if (param1_this != nullptr) {
      ((*local_this).do_billboard_axis)(*param1_this, (PN_stdfloat)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "do_billboard_axis(const NodePath self, const NodePath camera, float offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_do_billboard_axis_901_comment =
  "C++ Interface:\n"
  "do_billboard_axis(const NodePath self, const NodePath camera, float offset)\n"
  "\n"
  "/**\n"
  " * Performs a billboard-type rotate to the indicated camera node, one time\n"
  " * only, and leaves the object rotated.  This is similar in principle to\n"
  " * heads_up().\n"
  " */";
#else
static const char *Dtool_NodePath_do_billboard_axis_901_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::do_billboard_point_eye(NodePath const &camera, PN_stdfloat offset)
 */
static PyObject *Dtool_NodePath_do_billboard_point_eye_902(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.do_billboard_point_eye")) {
    return nullptr;
  }
  // 1-void NodePath::do_billboard_point_eye(NodePath const &camera, PN_stdfloat offset)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"camera", "offset", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:do_billboard_point_eye", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.do_billboard_point_eye", true, true);
    if (param1_this != nullptr) {
      ((*local_this).do_billboard_point_eye)(*param1_this, (PN_stdfloat)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "do_billboard_point_eye(const NodePath self, const NodePath camera, float offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_do_billboard_point_eye_902_comment =
  "C++ Interface:\n"
  "do_billboard_point_eye(const NodePath self, const NodePath camera, float offset)\n"
  "\n"
  "/**\n"
  " * Performs a billboard-type rotate to the indicated camera node, one time\n"
  " * only, and leaves the object rotated.  This is similar in principle to\n"
  " * look_at(), although the point_eye billboard effect cannot be achieved using\n"
  " * the ordinary look_at() call.\n"
  " */";
#else
static const char *Dtool_NodePath_do_billboard_point_eye_902_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::do_billboard_point_world(NodePath const &camera, PN_stdfloat offset)
 */
static PyObject *Dtool_NodePath_do_billboard_point_world_903(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.do_billboard_point_world")) {
    return nullptr;
  }
  // 1-void NodePath::do_billboard_point_world(NodePath const &camera, PN_stdfloat offset)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"camera", "offset", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:do_billboard_point_world", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.do_billboard_point_world", true, true);
    if (param1_this != nullptr) {
      ((*local_this).do_billboard_point_world)(*param1_this, (PN_stdfloat)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "do_billboard_point_world(const NodePath self, const NodePath camera, float offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_do_billboard_point_world_903_comment =
  "C++ Interface:\n"
  "do_billboard_point_world(const NodePath self, const NodePath camera, float offset)\n"
  "\n"
  "/**\n"
  " * Performs a billboard-type rotate to the indicated camera node, one time\n"
  " * only, and leaves the object rotated.  This is similar in principle to\n"
  " * look_at().\n"
  " */";
#else
static const char *Dtool_NodePath_do_billboard_point_world_903_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_billboard_axis(NodePath const &camera, PN_stdfloat offset)
 * inline void NodePath::set_billboard_axis(PN_stdfloat offset = 0.0)
 */
static PyObject *Dtool_NodePath_set_billboard_axis_904(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_billboard_axis")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void NodePath::set_billboard_axis(PN_stdfloat offset)
      ((*local_this).set_billboard_axis)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "offset")) {
        // 1-inline void NodePath::set_billboard_axis(PN_stdfloat offset)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_billboard_axis)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_billboard_axis(NodePath const &camera, PN_stdfloat offset)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"camera", "offset", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_billboard_axis", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_billboard_axis", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_billboard_axis)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_billboard_axis() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_billboard_axis(const NodePath self)\n"
      "set_billboard_axis(const NodePath self, float offset)\n"
      "set_billboard_axis(const NodePath self, const NodePath camera, float offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_billboard_axis_904_comment =
  "C++ Interface:\n"
  "set_billboard_axis(const NodePath self)\n"
  "set_billboard_axis(const NodePath self, float offset)\n"
  "set_billboard_axis(const NodePath self, const NodePath camera, float offset)\n"
  "\n"
  "/**\n"
  " * Puts a billboard transition on the node such that it will rotate in two\n"
  " * dimensions around the up axis.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Puts a billboard transition on the node such that it will rotate in two\n"
  " * dimensions around the up axis, towards a specified \"camera\" instead of to\n"
  " * the viewing camera.\n"
  " */";
#else
static const char *Dtool_NodePath_set_billboard_axis_904_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_billboard_point_eye(NodePath const &camera, PN_stdfloat offset, bool fixed_depth = false)
 * inline void NodePath::set_billboard_point_eye(PN_stdfloat offset = 0.0, bool fixed_depth = false)
 */
static PyObject *Dtool_NodePath_set_billboard_point_eye_905(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_billboard_point_eye")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void NodePath::set_billboard_point_eye(PN_stdfloat offset, bool fixed_depth)
      ((*local_this).set_billboard_point_eye)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "offset")) {
        // 1-inline void NodePath::set_billboard_point_eye(PN_stdfloat offset, bool fixed_depth)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_billboard_point_eye)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
  case 3:
    {
      {
        // -2 void NodePath::set_billboard_point_eye(NodePath const &camera, PN_stdfloat offset, bool fixed_depth = false)
        PyObject *param1;
        float param2;
        PyObject *param3 = Py_False;
        static const char *keyword_list[] = {"camera", "offset", "fixed_depth", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Of|O:set_billboard_point_eye", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
          if (param1_this != nullptr) {
            ((*local_this).set_billboard_point_eye)(*param1_this, (PN_stdfloat)param2, (PyObject_IsTrue(param3) != 0));
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void NodePath::set_billboard_point_eye(PN_stdfloat offset, bool fixed_depth = false)
        float param1;
        PyObject *param2;
        static const char *keyword_list[] = {"offset", "fixed_depth", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:set_billboard_point_eye", (char **)keyword_list, &param1, &param2)) {
          ((*local_this).set_billboard_point_eye)((PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePath::set_billboard_point_eye(NodePath const &camera, PN_stdfloat offset, bool fixed_depth = false)
      // No coercion possible: inline void NodePath::set_billboard_point_eye(PN_stdfloat offset, bool fixed_depth = false)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_billboard_point_eye() takes 1, 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_billboard_point_eye(const NodePath self)\n"
      "set_billboard_point_eye(const NodePath self, float offset)\n"
      "set_billboard_point_eye(const NodePath self, const NodePath camera, float offset, bool fixed_depth)\n"
      "set_billboard_point_eye(const NodePath self, float offset, bool fixed_depth)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_billboard_point_eye_905_comment =
  "C++ Interface:\n"
  "set_billboard_point_eye(const NodePath self)\n"
  "set_billboard_point_eye(const NodePath self, float offset)\n"
  "set_billboard_point_eye(const NodePath self, const NodePath camera, float offset, bool fixed_depth)\n"
  "set_billboard_point_eye(const NodePath self, float offset, bool fixed_depth)\n"
  "\n"
  "/**\n"
  " * Puts a billboard transition on the node such that it will rotate in three\n"
  " * dimensions about the origin, keeping its up vector oriented to the top of\n"
  " * the camera.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Puts a billboard transition on the node such that it will rotate in three\n"
  " * dimensions about the origin, keeping its up vector oriented to the top of\n"
  " * the camera, towards a specified \"camera\" instead of to the viewing camera.\n"
  " */";
#else
static const char *Dtool_NodePath_set_billboard_point_eye_905_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_billboard_point_world(NodePath const &camera, PN_stdfloat offset)
 * inline void NodePath::set_billboard_point_world(PN_stdfloat offset = 0.0)
 */
static PyObject *Dtool_NodePath_set_billboard_point_world_906(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_billboard_point_world")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void NodePath::set_billboard_point_world(PN_stdfloat offset)
      ((*local_this).set_billboard_point_world)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "offset")) {
        // 1-inline void NodePath::set_billboard_point_world(PN_stdfloat offset)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_billboard_point_world)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void NodePath::set_billboard_point_world(NodePath const &camera, PN_stdfloat offset)
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"camera", "offset", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_billboard_point_world", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_billboard_point_world", true, true);
        if (param1_this != nullptr) {
          ((*local_this).set_billboard_point_world)(*param1_this, (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_billboard_point_world() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_billboard_point_world(const NodePath self)\n"
      "set_billboard_point_world(const NodePath self, float offset)\n"
      "set_billboard_point_world(const NodePath self, const NodePath camera, float offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_billboard_point_world_906_comment =
  "C++ Interface:\n"
  "set_billboard_point_world(const NodePath self)\n"
  "set_billboard_point_world(const NodePath self, float offset)\n"
  "set_billboard_point_world(const NodePath self, const NodePath camera, float offset)\n"
  "\n"
  "/**\n"
  " * Puts a billboard transition on the node such that it will rotate in three\n"
  " * dimensions about the origin, keeping its up vector oriented to the sky.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Puts a billboard transition on the node such that it will rotate in three\n"
  " * dimensions about the origin, keeping its up vector oriented to the sky,\n"
  " * towards a specified \"camera\" instead of to the viewing camera.\n"
  " */";
#else
static const char *Dtool_NodePath_set_billboard_point_world_906_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_billboard(void)
 */
static PyObject *Dtool_NodePath_clear_billboard_907(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_billboard")) {
    return nullptr;
  }
  // 1-void NodePath::clear_billboard(void)
  ((*local_this).clear_billboard)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_billboard_907_comment =
  "C++ Interface:\n"
  "clear_billboard(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Removes any billboard effect from the node.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_billboard_907_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_billboard(void) const
 */
static PyObject *Dtool_NodePath_has_billboard_908(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_billboard(void) const
  bool return_value = ((*(const NodePath*)local_this).has_billboard)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_billboard_908_comment =
  "C++ Interface:\n"
  "has_billboard(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is any billboard effect on the node.\n"
  " */";
#else
static const char *Dtool_NodePath_has_billboard_908_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_compass(NodePath const &reference = NodePath())
 */
static PyObject *Dtool_NodePath_set_compass_909(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_compass")) {
    return nullptr;
  }
  // 1-void NodePath::set_compass(NodePath const &reference = NodePath())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "reference")) {
    NodePath const *param1_this;
    const NodePath &param1_ref = NodePath();
    if (param1 == nullptr) {
      param1_this = &param1_ref;
    } else {
      param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.set_compass", true, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).set_compass)(*param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_compass(const NodePath self, const NodePath reference)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_compass_909_comment =
  "C++ Interface:\n"
  "set_compass(const NodePath self, const NodePath reference)\n"
  "\n"
  "/**\n"
  " * Puts a compass effect on the node, so that it will retain a fixed rotation\n"
  " * relative to the reference node (or render if the reference node is empty)\n"
  " * regardless of the transforms above it.\n"
  " */";
#else
static const char *Dtool_NodePath_set_compass_909_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_compass(void)
 */
static PyObject *Dtool_NodePath_clear_compass_910(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_compass")) {
    return nullptr;
  }
  // 1-void NodePath::clear_compass(void)
  ((*local_this).clear_compass)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_compass_910_comment =
  "C++ Interface:\n"
  "clear_compass(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Removes any compass effect from the node.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_compass_910_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_compass(void) const
 */
static PyObject *Dtool_NodePath_has_compass_911(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_compass(void) const
  bool return_value = ((*(const NodePath*)local_this).has_compass)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_compass_911_comment =
  "C++ Interface:\n"
  "has_compass(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is any compass effect on the node.\n"
  " */";
#else
static const char *Dtool_NodePath_has_compass_911_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_transparency(TransparencyAttrib::Mode mode, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_transparency_912(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_transparency")) {
    return nullptr;
  }
  // 1-void NodePath::set_transparency(TransparencyAttrib::Mode mode, int priority = 0)
  int param1;
  int param2 = 0;
  static const char *keyword_list[] = {"mode", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|i:set_transparency", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_transparency)((TransparencyAttrib::Mode)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transparency(const NodePath self, int mode, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_transparency_912_comment =
  "C++ Interface:\n"
  "set_transparency(const NodePath self, int mode, int priority)\n"
  "\n"
  "/**\n"
  " * Specifically sets or disables transparent rendering mode on this particular\n"
  " * node.  If no other nodes override, this will cause items with a non-1 value\n"
  " * for alpha color to be rendered partially transparent.\n"
  " */";
#else
static const char *Dtool_NodePath_set_transparency_912_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_transparency(void)
 */
static PyObject *Dtool_NodePath_clear_transparency_913(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_transparency")) {
    return nullptr;
  }
  // 1-void NodePath::clear_transparency(void)
  ((*local_this).clear_transparency)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_transparency_913_comment =
  "C++ Interface:\n"
  "clear_transparency(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any transparency adjustment that may have been set on\n"
  " * this node via set_transparency(). The geometry at this level and below will\n"
  " * subsequently be rendered either transparent or not, to whatever other nodes\n"
  " * may have had set_transparency() on them.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_transparency_913_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_transparency(void) const
 */
static PyObject *Dtool_NodePath_has_transparency_914(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_transparency(void) const
  bool return_value = ((*(const NodePath*)local_this).has_transparency)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_transparency_914_comment =
  "C++ Interface:\n"
  "has_transparency(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a transparent-rendering adjustment has been explicitly set\n"
  " * on this particular node via set_transparency().  If this returns true, then\n"
  " * get_transparency() may be called to determine whether transparency has been\n"
  " * explicitly enabled or explicitly disabled for this node.\n"
  " */";
#else
static const char *Dtool_NodePath_has_transparency_914_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TransparencyAttrib::Mode NodePath::get_transparency(void) const
 */
static PyObject *Dtool_NodePath_get_transparency_915(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-TransparencyAttrib::Mode NodePath::get_transparency(void) const
  TransparencyAttrib::Mode return_value = ((*(const NodePath*)local_this).get_transparency)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_transparency_915_comment =
  "C++ Interface:\n"
  "get_transparency(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the transparent rendering that has been specifically set on this\n"
  " * node via set_transparency(), or M_none if nontransparent rendering has been\n"
  " * specifically set, or if nothing has been specifically set.  See also\n"
  " * has_transparency().  This does not necessarily imply that the geometry will\n"
  " * or will not be rendered transparent, as there may be other nodes that\n"
  " * override.\n"
  " */";
#else
static const char *Dtool_NodePath_get_transparency_915_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_logic_op(LogicOpAttrib::Operation op, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_logic_op_916(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_logic_op")) {
    return nullptr;
  }
  // 1-void NodePath::set_logic_op(LogicOpAttrib::Operation op, int priority = 0)
  int param1;
  int param2 = 0;
  static const char *keyword_list[] = {"op", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|i:set_logic_op", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_logic_op)((LogicOpAttrib::Operation)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_logic_op(const NodePath self, int op, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_logic_op_916_comment =
  "C++ Interface:\n"
  "set_logic_op(const NodePath self, int op, int priority)\n"
  "\n"
  "/**\n"
  " * Specifically sets or disables a logical operation on this particular node.\n"
  " * If no other nodes override, this will cause geometry to be rendered without\n"
  " * color blending but instead using the given logical operator.\n"
  " */";
#else
static const char *Dtool_NodePath_set_logic_op_916_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_logic_op(void)
 */
static PyObject *Dtool_NodePath_clear_logic_op_917(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_logic_op")) {
    return nullptr;
  }
  // 1-void NodePath::clear_logic_op(void)
  ((*local_this).clear_logic_op)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_logic_op_917_comment =
  "C++ Interface:\n"
  "clear_logic_op(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any logical operation that may have been set on this\n"
  " * node via set_logic_op(). The geometry at this level and below will\n"
  " * subsequently be rendered using standard color blending.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_logic_op_917_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_logic_op(void) const
 */
static PyObject *Dtool_NodePath_has_logic_op_918(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_logic_op(void) const
  bool return_value = ((*(const NodePath*)local_this).has_logic_op)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_logic_op_918_comment =
  "C++ Interface:\n"
  "has_logic_op(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if a logical operation has been explicitly set on this\n"
  " * particular node via set_logic_op().  If this returns true, then\n"
  " * get_logic_op() may be called to determine whether a logical operation has\n"
  " * been explicitly disabled for this node or set to particular operation.\n"
  " */";
#else
static const char *Dtool_NodePath_has_logic_op_918_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LogicOpAttrib::Operation NodePath::get_logic_op(void) const
 */
static PyObject *Dtool_NodePath_get_logic_op_919(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-LogicOpAttrib::Operation NodePath::get_logic_op(void) const
  LogicOpAttrib::Operation return_value = ((*(const NodePath*)local_this).get_logic_op)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_logic_op_919_comment =
  "C++ Interface:\n"
  "get_logic_op(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the logical operation that has been specifically set on this node\n"
  " * via set_logic_op(), or O_none if standard color blending has been\n"
  " * specifically set, or if nothing has been specifically set.  See also\n"
  " * has_logic_op().  This does not necessarily imply that the geometry will\n"
  " * or will not be rendered with the given logical operation, as there may be\n"
  " * other nodes that override.\n"
  " */";
#else
static const char *Dtool_NodePath_get_logic_op_919_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_antialias(unsigned short int mode, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_antialias_920(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_antialias")) {
    return nullptr;
  }
  // 1-void NodePath::set_antialias(unsigned short int mode, int priority = 0)
  long param1;
  int param2 = 0;
  static const char *keyword_list[] = {"mode", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "l|i:set_antialias", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    ((*local_this).set_antialias)((unsigned short int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_antialias(const NodePath self, int mode, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_antialias_920_comment =
  "C++ Interface:\n"
  "set_antialias(const NodePath self, int mode, int priority)\n"
  "\n"
  "/**\n"
  " * Specifies the antialiasing type that should be applied at this node and\n"
  " * below.  See AntialiasAttrib.\n"
  " */";
#else
static const char *Dtool_NodePath_set_antialias_920_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_antialias(void)
 */
static PyObject *Dtool_NodePath_clear_antialias_921(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_antialias")) {
    return nullptr;
  }
  // 1-void NodePath::clear_antialias(void)
  ((*local_this).clear_antialias)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_antialias_921_comment =
  "C++ Interface:\n"
  "clear_antialias(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any antialias setting that may have been set on this\n"
  " * node via set_antialias().\n"
  " */";
#else
static const char *Dtool_NodePath_clear_antialias_921_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_antialias(void) const
 */
static PyObject *Dtool_NodePath_has_antialias_922(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_antialias(void) const
  bool return_value = ((*(const NodePath*)local_this).has_antialias)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_antialias_922_comment =
  "C++ Interface:\n"
  "has_antialias(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if an antialias setting has been explicitly mode on this\n"
  " * particular node via set_antialias().  If this returns true, then\n"
  " * get_antialias() may be called to determine what the setting was.\n"
  " */";
#else
static const char *Dtool_NodePath_has_antialias_922_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * unsigned short int NodePath::get_antialias(void) const
 */
static PyObject *Dtool_NodePath_get_antialias_923(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-unsigned short int NodePath::get_antialias(void) const
  unsigned short int return_value = ((*(const NodePath*)local_this).get_antialias)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_antialias_923_comment =
  "C++ Interface:\n"
  "get_antialias(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the antialias setting that has been specifically set on this node\n"
  " * via set_antialias(), or M_none if no setting has been made.\n"
  " */";
#else
static const char *Dtool_NodePath_get_antialias_923_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::has_audio_volume(void) const
 */
static PyObject *Dtool_NodePath_has_audio_volume_924(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::has_audio_volume(void) const
  bool return_value = ((*(const NodePath*)local_this).has_audio_volume)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_audio_volume_924_comment =
  "C++ Interface:\n"
  "has_audio_volume(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if an audio volume has been applied to the referenced node,\n"
  " * false otherwise.  It is still possible that volume at this node might have\n"
  " * been scaled by an ancestor node.\n"
  " */";
#else
static const char *Dtool_NodePath_has_audio_volume_924_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::clear_audio_volume(void)
 */
static PyObject *Dtool_NodePath_clear_audio_volume_925(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_audio_volume")) {
    return nullptr;
  }
  // 1-void NodePath::clear_audio_volume(void)
  ((*local_this).clear_audio_volume)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_audio_volume_925_comment =
  "C++ Interface:\n"
  "clear_audio_volume(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Completely removes any audio volume from the referenced node.  This is\n"
  " * preferable to simply setting the audio volume to identity, as it also\n"
  " * removes the overhead associated with having an audio volume at all.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_audio_volume_925_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_audio_volume(PN_stdfloat volume, int priority = 0)
 */
static PyObject *Dtool_NodePath_set_audio_volume_926(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_audio_volume")) {
    return nullptr;
  }
  // 1-void NodePath::set_audio_volume(PN_stdfloat volume, int priority = 0)
  float param1;
  int param2 = 0;
  static const char *keyword_list[] = {"volume", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "f|i:set_audio_volume", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_audio_volume)((PN_stdfloat)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_audio_volume(const NodePath self, float volume, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_audio_volume_926_comment =
  "C++ Interface:\n"
  "set_audio_volume(const NodePath self, float volume, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the audio volume component of the transform\n"
  " */";
#else
static const char *Dtool_NodePath_set_audio_volume_926_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::set_audio_volume_off(int priority = 0)
 */
static PyObject *Dtool_NodePath_set_audio_volume_off_927(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_audio_volume_off")) {
    return nullptr;
  }
  // 1-void NodePath::set_audio_volume_off(int priority = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:set_audio_volume_off", (char **)keyword_list, &param1)) {
    ((*local_this).set_audio_volume_off)((int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_audio_volume_off(const NodePath self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_audio_volume_off_927_comment =
  "C++ Interface:\n"
  "set_audio_volume_off(const NodePath self, int priority)\n"
  "\n"
  "/**\n"
  " * Disables any audio volume attribute inherited from above.  This is not the\n"
  " * same thing as clear_audio_volume(), which undoes any previous\n"
  " * set_audio_volume() operation on this node; rather, this actively disables\n"
  " * any set_audio_volume() that might be inherited from a parent node.\n"
  " *\n"
  " * It is legal to specify a new volume on the same node with a subsequent call\n"
  " * to set_audio_volume(); this new scale will apply to lower nodes.\n"
  " */";
#else
static const char *Dtool_NodePath_set_audio_volume_off_927_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NodePath::get_audio_volume(void) const
 */
static PyObject *Dtool_NodePath_get_audio_volume_928(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-PN_stdfloat NodePath::get_audio_volume(void) const
  PN_stdfloat return_value = ((*(const NodePath*)local_this).get_audio_volume)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_audio_volume_928_comment =
  "C++ Interface:\n"
  "get_audio_volume(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the complete audio volume that has been applied to this node via a\n"
  " * previous call to set_audio_volume(), or 1. (identity) if no volume has been\n"
  " * applied to this particular node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_audio_volume_928_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NodePath::get_net_audio_volume(void) const
 */
static PyObject *Dtool_NodePath_get_net_audio_volume_929(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-PN_stdfloat NodePath::get_net_audio_volume(void) const
  PN_stdfloat return_value = ((*(const NodePath*)local_this).get_net_audio_volume)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_net_audio_volume_929_comment =
  "C++ Interface:\n"
  "get_net_audio_volume(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the complete audio volume for this node taking highers nodes in the\n"
  " * graph into account.\n"
  " */";
#else
static const char *Dtool_NodePath_get_net_audio_volume_929_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::adjust_all_priorities(int adjustment)
 */
static PyObject *Dtool_NodePath_adjust_all_priorities_930(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.adjust_all_priorities")) {
    return nullptr;
  }
  // 1-inline void NodePath::adjust_all_priorities(int adjustment)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).adjust_all_priorities)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_all_priorities(const NodePath self, int adjustment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_adjust_all_priorities_930_comment =
  "C++ Interface:\n"
  "adjust_all_priorities(const NodePath self, int adjustment)\n"
  "\n"
  "/**\n"
  " * Adds the indicated adjustment amount (which may be negative) to the\n"
  " * priority for all transitions on the referenced node, and for all nodes in\n"
  " * the subgraph below.  This can be used to force these nodes not to be\n"
  " * overridden by a high-level state change above.  If the priority would drop\n"
  " * below zero, it is set to zero.\n"
  " */";
#else
static const char *Dtool_NodePath_adjust_all_priorities_930_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::show(void)
 * inline void NodePath::show(DrawMask camera_mask)
 */
static PyObject *Dtool_NodePath_show_931(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.show")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void NodePath::show(void)
      ((*local_this).show)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline void NodePath::show(DrawMask camera_mask)
      BitMask< uint32_t, 32 > arg_local;
      DrawMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.show", "BitMask");
      }
      ((*local_this).show)(*arg_this);
      return Dtool_Return_None();
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "show() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "show(const NodePath self)\n"
      "show(const NodePath self, BitMask camera_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_show_931_comment =
  "C++ Interface:\n"
  "show(const NodePath self)\n"
  "show(const NodePath self, BitMask camera_mask)\n"
  "\n"
  "// Variants on show and hide\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous hide() on this node: makes the referenced\n"
  " * node (and the entire subgraph below this node) visible to all cameras.\n"
  " *\n"
  " * This will not reveal the node if a parent node has been hidden.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Makes the referenced node visible just to the cameras whose camera_mask\n"
  " * shares the indicated bits.\n"
  " *\n"
  " * This undoes the effect of a previous hide() call.  It will not reveal the\n"
  " * node if a parent node has been hidden.  However, see show_through().\n"
  " */";
#else
static const char *Dtool_NodePath_show_931_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::show_through(void)
 * inline void NodePath::show_through(DrawMask camera_mask)
 */
static PyObject *Dtool_NodePath_show_through_932(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.show_through")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void NodePath::show_through(void)
      ((*local_this).show_through)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline void NodePath::show_through(DrawMask camera_mask)
      BitMask< uint32_t, 32 > arg_local;
      DrawMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.show_through", "BitMask");
      }
      ((*local_this).show_through)(*arg_this);
      return Dtool_Return_None();
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "show_through() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "show_through(const NodePath self)\n"
      "show_through(const NodePath self, BitMask camera_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_show_through_932_comment =
  "C++ Interface:\n"
  "show_through(const NodePath self)\n"
  "show_through(const NodePath self, BitMask camera_mask)\n"
  "\n"
  "/**\n"
  " * Makes the referenced node visible just to the cameras whose camera_mask\n"
  " * shares the indicated bits.\n"
  " *\n"
  " * Unlike show(), this will reveal the node even if a parent node has been\n"
  " * hidden, thus \"showing through\" a parent's hide().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Makes the referenced node visible just to the cameras whose camera_mask\n"
  " * shares the indicated bits.\n"
  " *\n"
  " * Unlike show(), this will reveal the node even if a parent node has been\n"
  " * hidden via the one-parameter hide() method, thus \"showing through\" a\n"
  " * parent's hide().  (However, it will not show through a parent's hide() call\n"
  " * if the no-parameter form of hide() was used.)\n"
  " */";
#else
static const char *Dtool_NodePath_show_through_932_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::hide(void)
 * inline void NodePath::hide(DrawMask camera_mask)
 */
static PyObject *Dtool_NodePath_hide_933(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.hide")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void NodePath::hide(void)
      ((*local_this).hide)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline void NodePath::hide(DrawMask camera_mask)
      BitMask< uint32_t, 32 > arg_local;
      DrawMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.hide", "BitMask");
      }
      ((*local_this).hide)(*arg_this);
      return Dtool_Return_None();
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "hide() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hide(const NodePath self)\n"
      "hide(const NodePath self, BitMask camera_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_hide_933_comment =
  "C++ Interface:\n"
  "hide(const NodePath self)\n"
  "hide(const NodePath self, BitMask camera_mask)\n"
  "\n"
  "/**\n"
  " * Makes the referenced node (and the entire subgraph below this node)\n"
  " * invisible to all cameras.  It remains part of the scene graph, its bounding\n"
  " * volume still contributes to its parent's bounding volume, and it will still\n"
  " * be involved in collision tests.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Makes the referenced node invisible just to the cameras whose camera_mask\n"
  " * shares the indicated bits.\n"
  " *\n"
  " * This will also hide any nodes below this node in the scene graph, including\n"
  " * those nodes for which show() has been called, but it will not hide\n"
  " * descendent nodes for which show_through() has been called.\n"
  " */";
#else
static const char *Dtool_NodePath_hide_933_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::is_hidden(DrawMask camera_mask = PandaNode::get_overall_bit()) const
 */
static PyObject *Dtool_NodePath_is_hidden_934(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::is_hidden(DrawMask camera_mask = PandaNode::get_overall_bit()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "camera_mask")) {
    BitMask< uint32_t, 32 > param1_local;
    DrawMask *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_BitMask_uint32_t_32(param1, param1_local);
    } else {
      param1_local = PandaNode::get_overall_bit();
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.is_hidden", "BitMask");
    }
    bool return_value = ((*(const NodePath*)local_this).is_hidden)(*param1_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_hidden(NodePath self, BitMask camera_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_is_hidden_934_comment =
  "C++ Interface:\n"
  "is_hidden(NodePath self, BitMask camera_mask)\n"
  "\n"
  "/**\n"
  " * Returns true if the referenced node is hidden from the indicated camera(s)\n"
  " * either directly, or because some ancestor is hidden.\n"
  " */";
#else
static const char *Dtool_NodePath_is_hidden_934_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::get_hidden_ancestor(DrawMask camera_mask = PandaNode::get_overall_bit(), Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_hidden_ancestor_935(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::get_hidden_ancestor(DrawMask camera_mask = PandaNode::get_overall_bit(), Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"camera_mask", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|OO:get_hidden_ancestor", (char **)keyword_list, &param1, &param2)) {
    BitMask< uint32_t, 32 > param1_local;
    DrawMask *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_BitMask_uint32_t_32(param1, param1_local);
    } else {
      param1_local = PandaNode::get_overall_bit();
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.get_hidden_ancestor", "BitMask");
    }
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.get_hidden_ancestor", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      NodePath *return_value = new NodePath(((*(const NodePath*)local_this).get_hidden_ancestor)(*param1_this, param2_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hidden_ancestor(NodePath self, BitMask camera_mask, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_hidden_ancestor_935_comment =
  "C++ Interface:\n"
  "get_hidden_ancestor(NodePath self, BitMask camera_mask, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath at or above the referenced node that is hidden to the\n"
  " * indicated camera(s), or an empty NodePath if no ancestor of the referenced\n"
  " * node is hidden (and the node should be visible).\n"
  " */";
#else
static const char *Dtool_NodePath_get_hidden_ancestor_935_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::stash(int sort = 0, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_stash_936(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.stash")) {
    return nullptr;
  }
  // 1-void NodePath::stash(int sort = 0, Thread *current_thread = Thread::get_current_thread())
  int param1 = 0;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"sort", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|iO:stash", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.stash", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).stash)((int)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "stash(const NodePath self, int sort, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_stash_936_comment =
  "C++ Interface:\n"
  "stash(const NodePath self, int sort, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Removes the referenced node (and the entire subgraph below this node) from\n"
  " * the scene graph in any normal sense.  The node will no longer be visible\n"
  " * and is not tested for collisions; furthermore, no normal scene graph\n"
  " * traversal will visit the node.  The node's bounding volume no longer\n"
  " * contributes to its parent's bounding volume.\n"
  " *\n"
  " * A stashed node cannot be located by a normal find() operation (although a\n"
  " * special find string can still retrieve it).\n"
  " */";
#else
static const char *Dtool_NodePath_stash_936_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::unstash(int sort = 0, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_unstash_937(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.unstash")) {
    return nullptr;
  }
  // 1-void NodePath::unstash(int sort = 0, Thread *current_thread = Thread::get_current_thread())
  int param1 = 0;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"sort", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|iO:unstash", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.unstash", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).unstash)((int)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unstash(const NodePath self, int sort, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_unstash_937_comment =
  "C++ Interface:\n"
  "unstash(const NodePath self, int sort, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous stash() on this node: makes the referenced\n"
  " * node (and the entire subgraph below this node) once again part of the scene\n"
  " * graph.\n"
  " */";
#else
static const char *Dtool_NodePath_unstash_937_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::unstash_all(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_NodePath_unstash_all_938(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.unstash_all")) {
    return nullptr;
  }
  // 1-void NodePath::unstash_all(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.unstash_all", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).unstash_all)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unstash_all(const NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_unstash_all_938_comment =
  "C++ Interface:\n"
  "unstash_all(const NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Unstashes this node and all stashed child nodes.\n"
  " */";
#else
static const char *Dtool_NodePath_unstash_all_938_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::is_stashed(void) const
 */
static PyObject *Dtool_NodePath_is_stashed_939(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::is_stashed(void) const
  bool return_value = ((*(const NodePath*)local_this).is_stashed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_is_stashed_939_comment =
  "C++ Interface:\n"
  "is_stashed(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if the referenced node is stashed either directly, or because\n"
  " * some ancestor is stashed.\n"
  " */";
#else
static const char *Dtool_NodePath_is_stashed_939_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::get_stashed_ancestor(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_stashed_ancestor_940(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::get_stashed_ancestor(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_stashed_ancestor", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      NodePath *return_value = new NodePath(((*(const NodePath*)local_this).get_stashed_ancestor)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_stashed_ancestor(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_stashed_ancestor_940_comment =
  "C++ Interface:\n"
  "get_stashed_ancestor(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath at or above the referenced node that is stashed, or an\n"
  " * empty NodePath if no ancestor of the referenced node is stashed (and the\n"
  " * node should be visible).\n"
  " */";
#else
static const char *Dtool_NodePath_get_stashed_ancestor_940_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask NodePath::get_collide_mask(void) const
 */
static PyObject *Dtool_NodePath_get_collide_mask_941(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline CollideMask NodePath::get_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const NodePath*)local_this).get_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_collide_mask_941_comment =
  "C++ Interface:\n"
  "get_collide_mask(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the union of all of the into_collide_masks for nodes at this level\n"
  " * and below.  This is the same thing as node()->get_net_collide_mask().\n"
  " *\n"
  " * If you want to return what the into_collide_mask of this node itself is,\n"
  " * without regard to its children, use node()->get_into_collide_mask().\n"
  " */";
#else
static const char *Dtool_NodePath_get_collide_mask_941_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_collide_mask(CollideMask new_mask, CollideMask bits_to_change = CollideMask::all_on(), TypeHandle node_type = TypeHandle::none())
 */
static PyObject *Dtool_NodePath_set_collide_mask_942(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_collide_mask")) {
    return nullptr;
  }
  // 1-inline void NodePath::set_collide_mask(CollideMask new_mask, CollideMask bits_to_change = CollideMask::all_on(), TypeHandle node_type = TypeHandle::none())
  PyObject *param1;
  PyObject *param2 = nullptr;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"new_mask", "bits_to_change", "node_type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:set_collide_mask", (char **)keyword_list, &param1, &param2, &param3)) {
    BitMask< uint32_t, 32 > param1_local;
    CollideMask *param1_this = Dtool_Coerce_BitMask_uint32_t_32(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.set_collide_mask", "BitMask");
    }
    BitMask< uint32_t, 32 > param2_local;
    CollideMask *param2_this;
    if (param2 != nullptr) {
      param2_this = Dtool_Coerce_BitMask_uint32_t_32(param2, param2_local);
    } else {
      param2_local = BitMask< uint32_t, 32 >::all_on();
      param2_this = &param2_local;
    }
    if (param2 != nullptr && !(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.set_collide_mask", "BitMask");
    }
    TypeHandle param3_local;
    TypeHandle *param3_this;
    if (param3 != nullptr) {
      param3_this = Dtool_Coerce_TypeHandle(param3, param3_local);
    } else {
      param3_local = TypeHandle::none();
      param3_this = &param3_local;
    }
    if (param3 != nullptr && !(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "NodePath.set_collide_mask", "TypeHandle");
    }
    ((*local_this).set_collide_mask)(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_mask(const NodePath self, BitMask new_mask, BitMask bits_to_change, TypeHandle node_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_collide_mask_942_comment =
  "C++ Interface:\n"
  "set_collide_mask(const NodePath self, BitMask new_mask, BitMask bits_to_change, TypeHandle node_type)\n"
  "\n"
  "/**\n"
  " * Recursively applies the indicated CollideMask to the into_collide_masks for\n"
  " * all nodes at this level and below.  If node_type is not TypeHandle::none(),\n"
  " * then only nodes matching (or inheriting from) the indicated PandaNode\n"
  " * subclass are modified.\n"
  " *\n"
  " * The default is to change all bits, but if bits_to_change is not all bits\n"
  " * on, then only the bits that are set in bits_to_change are modified,\n"
  " * allowing this call to change only a subset of the bits in the subgraph.\n"
  " */";
#else
static const char *Dtool_NodePath_set_collide_mask_942_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NodePath::compare_to(NodePath const &other) const
 * int NodePath::compare_to(WeakNodePath const &other) const
 */
static PyObject *Dtool_NodePath_compare_to_946(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  {
    // -2 inline int NodePath::compare_to(NodePath const &other) const
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      int return_value = ((*(const NodePath*)local_this).compare_to)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 int NodePath::compare_to(WeakNodePath const &other) const
    WeakNodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_WeakNodePath);
    if (arg_this != nullptr) {
      int return_value = ((*(const NodePath*)local_this).compare_to)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline int NodePath::compare_to(NodePath const &other) const
  // No coercion possible: int NodePath::compare_to(WeakNodePath const &other) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(NodePath self, const NodePath other)\n"
      "compare_to(NodePath self, const WeakNodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_compare_to_946_comment =
  "C++ Interface:\n"
  "compare_to(NodePath self, const NodePath other)\n"
  "compare_to(NodePath self, const WeakNodePath other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this NodePath sorts before the other\n"
  " * one, greater than zero if it sorts after, or zero if they are equivalent.\n"
  " *\n"
  " * Two NodePaths are considered equivalent if they consist of exactly the same\n"
  " * list of nodes in the same order.  Otherwise, they are different; different\n"
  " * NodePaths will be ranked in a consistent but undefined ordering; the\n"
  " * ordering is useful only for placing the NodePaths in a sorted container\n"
  " * like an STL set.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this NodePath sorts before the other\n"
  " * one, greater than zero if it sorts after, or zero if they are equivalent.\n"
  " *\n"
  " * Two NodePaths are considered equivalent if they consist of exactly the same\n"
  " * list of nodes in the same order.  Otherwise, they are different; different\n"
  " * NodePaths will be ranked in a consistent but undefined ordering; the\n"
  " * ordering is useful only for placing the NodePaths in a sorted container\n"
  " * like an STL set.\n"
  " */";
#else
static const char *Dtool_NodePath_compare_to_946_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::verify_complete(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_verify_complete_947(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::verify_complete(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.verify_complete", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      bool return_value = ((*(const NodePath*)local_this).verify_complete)(param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "verify_complete(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_verify_complete_947_comment =
  "C++ Interface:\n"
  "verify_complete(NodePath self, Thread current_thread)\n"
  "\n"
  "// Miscellaneous\n"
  "\n"
  "/**\n"
  " * Returns true if all of the nodes described in the NodePath are connected,\n"
  " * or false otherwise.\n"
  " */";
#else
static const char *Dtool_NodePath_verify_complete_947_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::premunge_scene(GraphicsStateGuardianBase *gsg = nullptr)
 */
static PyObject *Dtool_NodePath_premunge_scene_948(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.premunge_scene")) {
    return nullptr;
  }
  // 1-void NodePath::premunge_scene(GraphicsStateGuardianBase *gsg = nullptr)
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "gsg")) {
    GraphicsStateGuardianBase *param1_this = nullptr;
    if (param1 != nullptr && param1 != Py_None) {
      param1_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsStateGuardianBase, 1, "NodePath.premunge_scene", false, true);
    }
    if ((param1 == nullptr || param1 == Py_None || param1_this != nullptr)) {
      ((*local_this).premunge_scene)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "premunge_scene(const NodePath self, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_premunge_scene_948_comment =
  "C++ Interface:\n"
  "premunge_scene(const NodePath self, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Walks through the scene graph beginning at the bottom node, and internally\n"
  " * adjusts any GeomVertexFormats for optimal rendering on the indicated GSG.\n"
  " * If this step is not done prior to rendering, the formats will be optimized\n"
  " * at render time instead, for a small cost.\n"
  " *\n"
  " * It is not normally necessary to do this on a model loaded directly from\n"
  " * disk, since the loader will do this by default.\n"
  " */";
#else
static const char *Dtool_NodePath_premunge_scene_948_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::prepare_scene(GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_NodePath_prepare_scene_949(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.prepare_scene")) {
    return nullptr;
  }
  // 1-void NodePath::prepare_scene(GraphicsStateGuardianBase *gsg)
  GraphicsStateGuardianBase *arg_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsStateGuardianBase, 1, "NodePath.prepare_scene", false, true);
  if (arg_this != nullptr) {
    ((*local_this).prepare_scene)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_scene(const NodePath self, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_prepare_scene_949_comment =
  "C++ Interface:\n"
  "prepare_scene(const NodePath self, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Walks through the scene graph beginning at the bottom node, and does\n"
  " * whatever initialization is required to render the scene properly with the\n"
  " * indicated GSG.  It is not strictly necessary to call this, since the GSG\n"
  " * will initialize itself when the scene is rendered, but this may take some\n"
  " * of the overhead away from that process.\n"
  " *\n"
  " * In particular, this will ensure that textures and vertex buffers within the\n"
  " * scene are loaded into graphics memory.\n"
  " */";
#else
static const char *Dtool_NodePath_prepare_scene_949_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::show_bounds(void)
 */
static PyObject *Dtool_NodePath_show_bounds_950(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.show_bounds")) {
    return nullptr;
  }
  // 1-void NodePath::show_bounds(void)
  ((*local_this).show_bounds)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_show_bounds_950_comment =
  "C++ Interface:\n"
  "show_bounds(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Causes the bounding volume of the bottom node and all of its descendants\n"
  " * (that is, the bounding volume associated with the the bottom arc) to be\n"
  " * rendered, if possible.  The rendering method is less than optimal; this is\n"
  " * intended primarily for debugging.\n"
  " */";
#else
static const char *Dtool_NodePath_show_bounds_950_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::show_tight_bounds(void)
 */
static PyObject *Dtool_NodePath_show_tight_bounds_951(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.show_tight_bounds")) {
    return nullptr;
  }
  // 1-void NodePath::show_tight_bounds(void)
  ((*local_this).show_tight_bounds)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_show_tight_bounds_951_comment =
  "C++ Interface:\n"
  "show_tight_bounds(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Similar to show_bounds(), this draws a bounding box representing the\n"
  " * \"tight\" bounds of this node and all of its descendants.  The bounding box\n"
  " * is recomputed every frame by reexamining all of the vertices; this is far\n"
  " * from efficient, but this is intended for debugging.\n"
  " */";
#else
static const char *Dtool_NodePath_show_tight_bounds_951_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::hide_bounds(void)
 */
static PyObject *Dtool_NodePath_hide_bounds_952(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.hide_bounds")) {
    return nullptr;
  }
  // 1-void NodePath::hide_bounds(void)
  ((*local_this).hide_bounds)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_hide_bounds_952_comment =
  "C++ Interface:\n"
  "hide_bounds(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Stops the rendering of the bounding volume begun with show_bounds().\n"
  " */";
#else
static const char *Dtool_NodePath_hide_bounds_952_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< BoundingVolume > NodePath::get_bounds(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_get_bounds_953(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-PointerTo< BoundingVolume > NodePath::get_bounds(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.get_bounds", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      PointerTo< BoundingVolume > return_value = ((*(const NodePath*)local_this).get_bounds)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      BoundingVolume *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bounds(NodePath self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_bounds_953_comment =
  "C++ Interface:\n"
  "get_bounds(NodePath self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a newly-allocated bounding volume containing the bottom node and\n"
  " * all of its descendants.  This is the bounding volume on the bottom arc,\n"
  " * converted to the local coordinate space of the node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_bounds_953_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::force_recompute_bounds(void)
 */
static PyObject *Dtool_NodePath_force_recompute_bounds_954(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.force_recompute_bounds")) {
    return nullptr;
  }
  // 1-void NodePath::force_recompute_bounds(void)
  ((*local_this).force_recompute_bounds)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_force_recompute_bounds_954_comment =
  "C++ Interface:\n"
  "force_recompute_bounds(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Forces the recomputing of all the bounding volumes at every node in the\n"
  " * subgraph beginning at this node and below.\n"
  " *\n"
  " * This should not normally need to be called, since the bounding volumes are\n"
  " * supposed to be recomputed automatically when necessary.  It may be useful\n"
  " * when debugging, to verify that the bounding volumes have not become\n"
  " * inadvertently stale; it may also be useful to force animated characters to\n"
  " * update their bounding volumes (which does not presently happen\n"
  " * automatically).\n"
  " */";
#else
static const char *Dtool_NodePath_force_recompute_bounds_954_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::write_bounds(std::ostream &out) const
 */
static PyObject *Dtool_NodePath_write_bounds_955(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-void NodePath::write_bounds(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "NodePath.write_bounds", false, true);
  if (arg_this != nullptr) {
    ((*(const NodePath*)local_this).write_bounds)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_bounds(NodePath self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_write_bounds_955_comment =
  "C++ Interface:\n"
  "write_bounds(NodePath self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a description of the bounding volume containing the bottom node and\n"
  " * all of its descendants to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_NodePath_write_bounds_955_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::calc_tight_bounds(LPoint3 &min_point, LPoint3 &max_point, NodePath const &other = NodePath(), Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_NodePath_calc_tight_bounds_956(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::calc_tight_bounds(LPoint3 &min_point, LPoint3 &max_point, NodePath const &other = NodePath(), Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3 = nullptr;
  PyObject *param4 = nullptr;
  static const char *keyword_list[] = {"min_point", "max_point", "other", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|OO:calc_tight_bounds", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LPoint3f param1_local;
    LPoint3 *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "NodePath.calc_tight_bounds", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NodePath.calc_tight_bounds", "LPoint3f");
    }
    NodePath const *param3_this;
    const NodePath &param3_ref = NodePath();
    if (param3 == nullptr) {
      param3_this = &param3_ref;
    } else {
      param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "NodePath.calc_tight_bounds", true, true);
    }
    Thread *param4_this;
    if (param4 == nullptr) {
      param4_this = Thread::get_current_thread();
    } else {
      param4_this = (Thread *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_Thread, 4, "NodePath.calc_tight_bounds", false, true);
    }
    if ((param3 == nullptr || param3_this != nullptr) && (param4 == nullptr || param4_this != nullptr)) {
      bool return_value = ((*(const NodePath*)local_this).calc_tight_bounds)(*param1_this, *param2_this, *param3_this, param4_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_tight_bounds(NodePath self, LPoint3f min_point, LPoint3f max_point, const NodePath other, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_calc_tight_bounds_956_comment =
  "C++ Interface:\n"
  "calc_tight_bounds(NodePath self, LPoint3f min_point, LPoint3f max_point, const NodePath other, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Calculates the minimum and maximum vertices of all Geoms at this NodePath's\n"
  " * bottom node and below.  This is a tight bounding box; it will generally be\n"
  " * tighter than the bounding volume returned by get_bounds() (but it is more\n"
  " * expensive to compute).\n"
  " *\n"
  " * The bounding box is computed relative to the parent node's coordinate\n"
  " * system by default.  You can optionally specify a different NodePath to\n"
  " * compute the bounds relative to.  Note that the box is always axis-aligned\n"
  " * against the given NodePath's coordinate system, so you might get a\n"
  " * differently sized box depending on which node you pass.\n"
  " *\n"
  " * The return value is true if any points are within the bounding volume, or\n"
  " * false if none are.\n"
  " */";
#else
static const char *Dtool_NodePath_calc_tight_bounds_956_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *NodePath::get_tight_bounds(NodePath const &other = NodePath()) const
 */
static PyObject *Dtool_NodePath_get_tight_bounds_957(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-PyObject *NodePath::get_tight_bounds(NodePath const &other = NodePath()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "other")) {
    NodePath const *param1_this;
    const NodePath &param1_ref = NodePath();
    if (param1 == nullptr) {
      param1_this = &param1_ref;
    } else {
      param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NodePath.get_tight_bounds", true, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      PyObject *return_value = invoke_extension((const NodePath*)local_this).get_tight_bounds(*param1_this);
      return Dtool_Return(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tight_bounds(NodePath self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tight_bounds_957_comment =
  "C++ Interface:\n"
  "get_tight_bounds(NodePath self, const NodePath other)\n";
#else
static const char *Dtool_NodePath_get_tight_bounds_957_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int NodePath::flatten_light(void)
 */
static PyObject *Dtool_NodePath_flatten_light_958(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.flatten_light")) {
    return nullptr;
  }
  // 1-int NodePath::flatten_light(void)
  int return_value = ((*local_this).flatten_light)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_flatten_light_958_comment =
  "C++ Interface:\n"
  "flatten_light(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Lightly flattens out the hierarchy below this node by applying transforms,\n"
  " * colors, and texture matrices from the nodes onto the vertices, but does not\n"
  " * remove any nodes.\n"
  " *\n"
  " * This can result in improved rendering performance because there will be\n"
  " * fewer transforms in the resulting scene graph, but the number of nodes will\n"
  " * remain the same.\n"
  " *\n"
  " * In particular, any NodePaths that reference nodes within this hierarchy\n"
  " * will not be damaged.  However, since this operation will remove transforms\n"
  " * from the scene graph, it may be dangerous to apply to nodes where you\n"
  " * expect to dynamically modify the transform, or where you expect the\n"
  " * geometry to remain in a particular local coordinate system.\n"
  " *\n"
  " * The return value is always 0, since flatten_light does not remove any\n"
  " * nodes.\n"
  " */";
#else
static const char *Dtool_NodePath_flatten_light_958_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int NodePath::flatten_medium(void)
 */
static PyObject *Dtool_NodePath_flatten_medium_959(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.flatten_medium")) {
    return nullptr;
  }
  // 1-int NodePath::flatten_medium(void)
  int return_value = ((*local_this).flatten_medium)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_flatten_medium_959_comment =
  "C++ Interface:\n"
  "flatten_medium(const NodePath self)\n"
  "\n"
  "/**\n"
  " * A more thorough flattening than flatten_light(), this first applies all the\n"
  " * transforms, colors, and texture matrices from the nodes onto the vertices,\n"
  " * and then removes unneeded grouping nodes--nodes that have exactly one\n"
  " * child, for instance, but have no special properties in themselves.\n"
  " *\n"
  " * This results in improved performance over flatten_light() because the\n"
  " * number of nodes in the scene graph is reduced.\n"
  " *\n"
  " * The return value is the number of nodes removed.\n"
  " */";
#else
static const char *Dtool_NodePath_flatten_medium_959_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int NodePath::flatten_strong(void)
 */
static PyObject *Dtool_NodePath_flatten_strong_960(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.flatten_strong")) {
    return nullptr;
  }
  // 1-int NodePath::flatten_strong(void)
  int return_value = ((*local_this).flatten_strong)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_flatten_strong_960_comment =
  "C++ Interface:\n"
  "flatten_strong(const NodePath self)\n"
  "\n"
  "/**\n"
  " * The strongest possible flattening.  This first applies all of the\n"
  " * transforms to the vertices, as in flatten_medium(), but then it will\n"
  " * combine sibling nodes together when possible, in addition to removing\n"
  " * unnecessary parent-child nodes.  This can result in substantially fewer\n"
  " * nodes, but any nicely-grouped hierachical bounding volumes may be lost.\n"
  " *\n"
  " * It is generally a good idea to apply this kind of flattening only to nodes\n"
  " * that will be culled largely as a single unit, like a car.  Applying this to\n"
  " * an entire scene may result in overall poorer performance because of less-\n"
  " * effective culling.\n"
  " */";
#else
static const char *Dtool_NodePath_flatten_strong_960_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePath::apply_texture_colors(void)
 */
static PyObject *Dtool_NodePath_apply_texture_colors_961(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.apply_texture_colors")) {
    return nullptr;
  }
  // 1-void NodePath::apply_texture_colors(void)
  ((*local_this).apply_texture_colors)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_apply_texture_colors_961_comment =
  "C++ Interface:\n"
  "apply_texture_colors(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Removes textures from Geoms at this node and below by applying the texture\n"
  " * colors to the vertices.  This is primarily useful to simplify a low-LOD\n"
  " * model.  The texture colors are replaced by flat colors that approximate the\n"
  " * original textures.\n"
  " *\n"
  " * Only the bottommost texture on each Geom is used (if there is more than\n"
  " * one), and it is applied as if it were M_modulate, and WM_repeat, regardless\n"
  " * of its actual settings.  If the texture has a simple_ram_image, this may be\n"
  " * used if the main image isn't resident.\n"
  " *\n"
  " * After this call, there will be no texturing specified at this level and\n"
  " * below.  Of course, there might still be texturing inherited from above.\n"
  " */";
#else
static const char *Dtool_NodePath_apply_texture_colors_961_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NodePath::clear_model_nodes(void)
 */
static PyObject *Dtool_NodePath_clear_model_nodes_962(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_model_nodes")) {
    return nullptr;
  }
  // 1-inline int NodePath::clear_model_nodes(void)
  int return_value = ((*local_this).clear_model_nodes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_model_nodes_962_comment =
  "C++ Interface:\n"
  "clear_model_nodes(const NodePath self)\n"
  "\n"
  "/**\n"
  " * Recursively walks through the scene graph at this level and below, looking\n"
  " * for ModelNodes, and calls model_node->set_preserve_transform(PT_drop_node)\n"
  " * on each one.  This allows a subsequent call to flatten_strong() to\n"
  " * eliminate all of the ModelNodes.\n"
  " *\n"
  " * Returns the number of ModelNodes found.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_model_nodes_962_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_tag(std::string const &key, std::string const &value)
 */
static PyObject *Dtool_NodePath_set_tag_963(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_tag")) {
    return nullptr;
  }
  // 1-inline void NodePath::set_tag(std::string const &key, std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"key", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:set_tag", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    ((*local_this).set_tag)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tag(const NodePath self, str key, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_tag_963_comment =
  "C++ Interface:\n"
  "set_tag(const NodePath self, str key, str value)\n"
  "\n"
  "/**\n"
  " * Associates a user-defined value with a user-defined key which is stored on\n"
  " * the node.  This value has no meaning to Panda; but it is stored\n"
  " * indefinitely on the node until it is requested again.\n"
  " *\n"
  " * Each unique key stores a different string value.  There is no effective\n"
  " * limit on the number of different keys that may be stored or on the length\n"
  " * of any one key's value.\n"
  " */";
#else
static const char *Dtool_NodePath_set_tag_963_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string NodePath::get_tag(std::string const &key) const
 */
static PyObject *Dtool_NodePath_get_tag_964(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline std::string NodePath::get_tag(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    std::string return_value = ((*(const NodePath*)local_this).get_tag)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tag(NodePath self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tag_964_comment =
  "C++ Interface:\n"
  "get_tag(NodePath self, str key)\n"
  "\n"
  "/**\n"
  " * Retrieves the user-defined value that was previously set on this node for\n"
  " * the particular key, if any.  If no value has been previously set, returns\n"
  " * the empty string.  See also get_net_tag().\n"
  " */";
#else
static const char *Dtool_NodePath_get_tag_964_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *NodePath::get_tag_keys(void) const
 * Rejected Remap [inline void NodePath::get_tag_keys(vector_string &keys) const]
 */
static PyObject *Dtool_NodePath_get_tag_keys_965(PyObject *self, PyObject *args) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    return Dtool_Raise_TypeError("function takes no arguments");
#else
    return PyErr_Format(PyExc_TypeError,
                        "get_tag_keys() takes no arguments (%d given)",
                        parameter_count);
#endif
  }
  // 1-inline PyObject *NodePath::get_tag_keys(void) const
  PyObject *return_value = invoke_extension((const NodePath*)local_this).get_tag_keys();
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tag_keys(NodePath self)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tag_keys_965_comment =
  "C++ Interface:\n"
  "get_tag_keys(NodePath self)\n"
  "\n"
  "/**\n"
  " * Fills the given vector up with the list of tags on this PandaNode.\n"
  " *\n"
  " * It is the user's responsibility to ensure that the keys vector is empty\n"
  " * before making this call; otherwise, the new files will be appended to it.\n"
  " */";
#else
static const char *Dtool_NodePath_get_tag_keys_965_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::has_tag(std::string const &key) const
 */
static PyObject *Dtool_NodePath_has_tag_966(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::has_tag(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const NodePath*)local_this).has_tag)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_tag(NodePath self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_tag_966_comment =
  "C++ Interface:\n"
  "has_tag(NodePath self, str key)\n"
  "\n"
  "/**\n"
  " * Returns true if a value has been defined on this node for the particular\n"
  " * key (even if that value is the empty string), or false if no value has been\n"
  " * set.  See also has_net_tag().\n"
  " */";
#else
static const char *Dtool_NodePath_has_tag_966_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::clear_tag(std::string const &key)
 */
static PyObject *Dtool_NodePath_clear_tag_967(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_tag")) {
    return nullptr;
  }
  // 1-inline void NodePath::clear_tag(std::string const &key)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).clear_tag)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_tag(const NodePath self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_tag_967_comment =
  "C++ Interface:\n"
  "clear_tag(const NodePath self, str key)\n"
  "\n"
  "/**\n"
  " * Removes the value defined for this key on this particular node.  After a\n"
  " * call to clear_tag(), has_tag() will return false for the indicated key.\n"
  " */";
#else
static const char *Dtool_NodePath_clear_tag_967_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string NodePath::get_net_tag(std::string const &key) const
 */
static PyObject *Dtool_NodePath_get_net_tag_968(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline std::string NodePath::get_net_tag(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    std::string return_value = ((*(const NodePath*)local_this).get_net_tag)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_tag(NodePath self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_net_tag_968_comment =
  "C++ Interface:\n"
  "get_net_tag(NodePath self, str key)\n"
  "\n"
  "/**\n"
  " * Returns the tag value that has been defined on this node, or the nearest\n"
  " * ancestor node, for the indicated key.  If no value has been defined for the\n"
  " * indicated key on any ancestor node, returns the empty string.  See also\n"
  " * get_tag().\n"
  " */";
#else
static const char *Dtool_NodePath_get_net_tag_968_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::has_net_tag(std::string const &key) const
 */
static PyObject *Dtool_NodePath_has_net_tag_969(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::has_net_tag(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const NodePath*)local_this).has_net_tag)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_net_tag(NodePath self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_net_tag_969_comment =
  "C++ Interface:\n"
  "has_net_tag(NodePath self, str key)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated tag value has been defined on this node or on\n"
  " * any ancestor node, or false otherwise.  See also has_tag().\n"
  " */";
#else
static const char *Dtool_NodePath_has_net_tag_969_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::find_net_tag(std::string const &key) const
 */
static PyObject *Dtool_NodePath_find_net_tag_970(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::find_net_tag(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    NodePath *return_value = new NodePath(((*(const NodePath*)local_this).find_net_tag)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_net_tag(NodePath self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_net_tag_970_comment =
  "C++ Interface:\n"
  "find_net_tag(NodePath self, str key)\n"
  "\n"
  "/**\n"
  " * Returns the lowest ancestor of this node that contains a tag definition\n"
  " * with the indicated key, if any, or an empty NodePath if no ancestor of this\n"
  " * node contains this tag definition.  See set_tag().\n"
  " */";
#else
static const char *Dtool_NodePath_find_net_tag_970_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *NodePath::get_tags(void) const
 */
static PyObject *Dtool_NodePath_get_tags_972(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline PyObject *NodePath::get_tags(void) const
  PyObject *return_value = invoke_extension((const NodePath*)local_this).get_tags();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_tags_972_comment =
  "C++ Interface:\n"
  "get_tags(NodePath self)\n";
#else
static const char *Dtool_NodePath_get_tags_972_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *NodePath::get_python_tags(void)
 */
static PyObject *Dtool_NodePath_get_python_tags_974(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.get_python_tags")) {
    return nullptr;
  }
  // 1-PyObject *NodePath::get_python_tags(void)
  PyObject *return_value = invoke_extension(local_this).get_python_tags();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_python_tags_974_comment =
  "C++ Interface:\n"
  "get_python_tags(const NodePath self)\n";
#else
static const char *Dtool_NodePath_get_python_tags_974_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_python_tag(PyObject *keys, PyObject *value)
 */
static PyObject *Dtool_NodePath_set_python_tag_975(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_python_tag")) {
    return nullptr;
  }
  // 1-inline void NodePath::set_python_tag(PyObject *keys, PyObject *value)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"keys", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_python_tag", (char **)keyword_list, &param1, &param2)) {
    invoke_extension(local_this).set_python_tag(param1, param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_python_tag(const NodePath self, object keys, object value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_python_tag_975_comment =
  "C++ Interface:\n"
  "set_python_tag(const NodePath self, object keys, object value)\n";
#else
static const char *Dtool_NodePath_set_python_tag_975_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *NodePath::get_python_tag(PyObject *keys) const
 */
static PyObject *Dtool_NodePath_get_python_tag_976(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline PyObject *NodePath::get_python_tag(PyObject *keys) const
  PyObject *return_value = invoke_extension((const NodePath*)local_this).get_python_tag(arg);
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_python_tag(NodePath self, object keys)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_python_tag_976_comment =
  "C++ Interface:\n"
  "get_python_tag(NodePath self, object keys)\n";
#else
static const char *Dtool_NodePath_get_python_tag_976_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *NodePath::get_python_tag_keys(void) const
 */
static PyObject *Dtool_NodePath_get_python_tag_keys_977(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline PyObject *NodePath::get_python_tag_keys(void) const
  PyObject *return_value = invoke_extension((const NodePath*)local_this).get_python_tag_keys();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_python_tag_keys_977_comment =
  "C++ Interface:\n"
  "get_python_tag_keys(NodePath self)\n";
#else
static const char *Dtool_NodePath_get_python_tag_keys_977_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::has_python_tag(PyObject *keys) const
 */
static PyObject *Dtool_NodePath_has_python_tag_978(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::has_python_tag(PyObject *keys) const
  bool return_value = invoke_extension((const NodePath*)local_this).has_python_tag(arg);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_python_tag(NodePath self, object keys)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_python_tag_978_comment =
  "C++ Interface:\n"
  "has_python_tag(NodePath self, object keys)\n";
#else
static const char *Dtool_NodePath_has_python_tag_978_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::clear_python_tag(PyObject *keys)
 */
static PyObject *Dtool_NodePath_clear_python_tag_979(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.clear_python_tag")) {
    return nullptr;
  }
  // 1-inline void NodePath::clear_python_tag(PyObject *keys)
  invoke_extension(local_this).clear_python_tag(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_python_tag(const NodePath self, object keys)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_clear_python_tag_979_comment =
  "C++ Interface:\n"
  "clear_python_tag(const NodePath self, object keys)\n";
#else
static const char *Dtool_NodePath_clear_python_tag_979_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *NodePath::get_net_python_tag(PyObject *keys) const
 */
static PyObject *Dtool_NodePath_get_net_python_tag_980(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline PyObject *NodePath::get_net_python_tag(PyObject *keys) const
  PyObject *return_value = invoke_extension((const NodePath*)local_this).get_net_python_tag(arg);
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_python_tag(NodePath self, object keys)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_net_python_tag_980_comment =
  "C++ Interface:\n"
  "get_net_python_tag(NodePath self, object keys)\n";
#else
static const char *Dtool_NodePath_get_net_python_tag_980_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodePath::has_net_python_tag(PyObject *keys) const
 */
static PyObject *Dtool_NodePath_has_net_python_tag_981(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline bool NodePath::has_net_python_tag(PyObject *keys) const
  bool return_value = invoke_extension((const NodePath*)local_this).has_net_python_tag(arg);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_net_python_tag(NodePath self, object keys)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_has_net_python_tag_981_comment =
  "C++ Interface:\n"
  "has_net_python_tag(NodePath self, object keys)\n";
#else
static const char *Dtool_NodePath_has_net_python_tag_981_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePath::find_net_python_tag(PyObject *keys) const
 */
static PyObject *Dtool_NodePath_find_net_python_tag_982(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-NodePath NodePath::find_net_python_tag(PyObject *keys) const
  NodePath *return_value = new NodePath(invoke_extension((const NodePath*)local_this).find_net_python_tag(arg));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_net_python_tag(NodePath self, object keys)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_find_net_python_tag_982_comment =
  "C++ Interface:\n"
  "find_net_python_tag(NodePath self, object keys)\n";
#else
static const char *Dtool_NodePath_find_net_python_tag_982_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::list_tags(void) const
 */
static PyObject *Dtool_NodePath_list_tags_985(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline void NodePath::list_tags(void) const
  ((*(const NodePath*)local_this).list_tags)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePath_list_tags_985_comment =
  "C++ Interface:\n"
  "list_tags(NodePath self)\n"
  "\n"
  "/**\n"
  " * Lists the tags to the nout stream, one per line.  See\n"
  " * PandaNode::list_tags() for a variant that allows you to specify the output\n"
  " * stream.\n"
  " */";
#else
static const char *Dtool_NodePath_list_tags_985_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePath::set_name(std::string const &name)
 */
static PyObject *Dtool_NodePath_set_name_986(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.set_name")) {
    return nullptr;
  }
  // 1-inline void NodePath::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const NodePath self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_set_name_986_comment =
  "C++ Interface:\n"
  "set_name(const NodePath self, str name)\n"
  "\n"
  "/**\n"
  " * Changes the name of the referenced node.\n"
  " */";
#else
static const char *Dtool_NodePath_set_name_986_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string NodePath::get_name(void) const
 */
static PyObject *Dtool_NodePath_get_name_987(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-inline std::string NodePath::get_name(void) const
  std::string return_value = ((*(const NodePath*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_name_987_comment =
  "C++ Interface:\n"
  "get_name(NodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the referenced node.\n"
  " */";
#else
static const char *Dtool_NodePath_get_name_987_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::write_bam_file(Filename const &filename) const
 */
static PyObject *Dtool_NodePath_write_bam_file_989(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::write_bam_file(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePath.write_bam_file", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*(const NodePath*)local_this).write_bam_file)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_bam_file(NodePath self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_write_bam_file_989_comment =
  "C++ Interface:\n"
  "write_bam_file(NodePath self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Writes the contents of this node and below out to a bam file with the\n"
  " * indicated filename.  This file may then be read in again, as is, at some\n"
  " * later point.  Returns true if successful, false on some kind of error.\n"
  " */";
#else
static const char *Dtool_NodePath_write_bam_file_989_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePath::write_bam_stream(std::ostream &out) const
 */
static PyObject *Dtool_NodePath_write_bam_stream_990(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  // 1-bool NodePath::write_bam_stream(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "NodePath.write_bam_stream", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*(const NodePath*)local_this).write_bam_stream)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_bam_stream(NodePath self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_write_bam_stream_990_comment =
  "C++ Interface:\n"
  "write_bam_stream(NodePath self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes the contents of this node and below out to the indicated stream.\n"
  " */";
#else
static const char *Dtool_NodePath_write_bam_stream_990_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar NodePath::encode_to_bam_stream(void) const
 * Rejected Remap [bool NodePath::encode_to_bam_stream(vector_uchar &data, BamWriter *writer) const]
 */
static PyObject *Dtool_NodePath_encode_to_bam_stream_991(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePath)) {
    return nullptr;
  }
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("function takes no keyword arguments");
#else
    return Dtool_Raise_TypeError("encode_to_bam_stream() takes no keyword arguments");
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    return Dtool_Raise_TypeError("function takes no arguments");
#else
    return PyErr_Format(PyExc_TypeError,
                        "encode_to_bam_stream() takes no arguments (%d given)",
                        parameter_count);
#endif
  }
  // 1-inline vector_uchar NodePath::encode_to_bam_stream(void) const
  vector_uchar return_value = ((*(const NodePath*)local_this).encode_to_bam_stream)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encode_to_bam_stream(NodePath self)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_encode_to_bam_stream_991_comment =
  "C++ Interface:\n"
  "encode_to_bam_stream(NodePath self)\n"
  "\n"
  "/**\n"
  " * Converts the NodePath object into a single stream of data using a\n"
  " * BamWriter, and returns that data as a string string.  Returns empty string\n"
  " * on failure.  This is similar to write_bam_stream().\n"
  " *\n"
  " * This method is used by __reduce__ to handle streaming of NodePaths to a\n"
  " * pickle file.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Converts the NodePath object into a single stream of data using a\n"
  " * BamWriter, and stores that data in the indicated string.  Returns true on\n"
  " * success, false on failure.\n"
  " *\n"
  " * If the BamWriter is NULL, this behaves the same way as\n"
  " * NodePath::write_bam_stream() and PandaNode::encode_to_bam_stream(), in the\n"
  " * sense that it only writes this node and all nodes below it.\n"
  " *\n"
  " * However, if the BamWriter is not NULL, it behaves very differently.  In\n"
  " * this case, it encodes the *entire graph* of all nodes connected to the\n"
  " * NodePath, including all parent nodes and siblings.  This is necessary for\n"
  " * correct streaming of related NodePaths and restoration of instances, etc.,\n"
  " * but it does mean you must detach() a node before writing it if you want to\n"
  " * limit the nodes that get written.\n"
  " *\n"
  " * This method is used by __reduce__ to handle streaming of NodePaths to a\n"
  " * pickle file.  The BamWriter case is used by the direct.stdpy.pickle module,\n"
  " * while the saner, non-BamWriter case is used when the standard pickle module\n"
  " * calls this function.\n"
  " */";
#else
static const char *Dtool_NodePath_encode_to_bam_stream_991_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static NodePath NodePath::decode_from_bam_stream(vector_uchar data, BamReader *reader = nullptr)
 */
static PyObject *Dtool_NodePath_decode_from_bam_stream_992(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static NodePath NodePath::decode_from_bam_stream(vector_uchar data, BamReader *reader = nullptr)
  unsigned char *param0_str = nullptr;
  Py_ssize_t param0_len;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"data", "reader", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "" FMTCHAR_BYTES "#|O:decode_from_bam_stream", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    BamReader *param1_this = nullptr;
    if (param1 != nullptr && param1 != Py_None) {
      param1_this = (BamReader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BamReader, 1, "NodePath.decode_from_bam_stream", false, true);
    }
    if ((param1 == nullptr || param1 == Py_None || param1_this != nullptr)) {
      NodePath *return_value = new NodePath((NodePath::decode_from_bam_stream)(vector_uchar(param0_str, param0_str + param0_len), param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decode_from_bam_stream(bytes data, BamReader reader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePath_decode_from_bam_stream_992_comment =
  "C++ Interface:\n"
  "decode_from_bam_stream(bytes data, BamReader reader)\n"
  "\n"
  "/**\n"
  " * Reads the string created by a previous call to encode_to_bam_stream(), and\n"
  " * extracts and returns the NodePath on that string.  Returns NULL on error.\n"
  " */";
#else
static const char *Dtool_NodePath_decode_from_bam_stream_992_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NodePath::get_class_type(void)
 */
static PyObject *Dtool_NodePath_get_class_type_993(PyObject *, PyObject *) {
  // 1-static TypeHandle NodePath::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((NodePath::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodePath_get_class_type_993_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NodePath_get_class_type_993_comment = nullptr;
#endif

/**
 * sequence length function for property NodePath::nodes
 */
static Py_ssize_t Dtool_NodePath_nodes_Len(PyObject *self) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_nodes)();
}

/**
 * sequence getter for property NodePath::nodes
 */
static PyObject *Dtool_NodePath_nodes_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_nodes)()) {
    PyErr_SetString(PyExc_IndexError, "NodePath.nodes[] index out of range");
    return nullptr;
  }
  // 1-PandaNode *NodePath::get_node(int index, Thread *current_thread) const
  PandaNode *return_value = ((*(const NodePath*)local_this).get_node)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(NodePath self, index)\n");
  }
}

static PyObject *Dtool_NodePath_nodes_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "NodePath.nodes");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_NodePath_nodes_Len;
    wrap->_getitem_func = &Dtool_NodePath_nodes_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property NodePath::ancestors
 */
static Py_ssize_t Dtool_NodePath_ancestors_Len(PyObject *self) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_nodes)();
}

/**
 * sequence getter for property NodePath::ancestors
 */
static PyObject *Dtool_NodePath_ancestors_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_nodes)()) {
    PyErr_SetString(PyExc_IndexError, "NodePath.ancestors[] index out of range");
    return nullptr;
  }
  // 1-NodePath NodePath::get_ancestor(int index, Thread *current_thread) const
  NodePath *return_value = new NodePath(((*(const NodePath*)local_this).get_ancestor)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ancestor(NodePath self, index)\n");
  }
}

static PyObject *Dtool_NodePath_ancestors_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "NodePath.ancestors");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_NodePath_ancestors_Len;
    wrap->_getitem_func = &Dtool_NodePath_ancestors_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_NodePath_error_type_Getter(PyObject *self, void *) {
  const NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath::ErrorType NodePath::get_error_type(void) const
  NodePath::ErrorType return_value = ((*(const NodePath*)local_this).get_error_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_NodePath_children_Getter(PyObject *self, void *) {
  const NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }

  // 1-NodePathCollection NodePath::get_children(Thread *current_thread) const
  NodePathCollection *return_value = new NodePathCollection(((*(const NodePath*)local_this).get_children)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
}

static PyObject *Dtool_NodePath_stashed_children_Getter(PyObject *self, void *) {
  const NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }

  // 1-NodePathCollection NodePath::get_stashed_children(Thread *current_thread) const
  NodePathCollection *return_value = new NodePathCollection(((*(const NodePath*)local_this).get_stashed_children)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
}

static PyObject *Dtool_NodePath_parent_Getter(PyObject *self, void *) {
  const NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_parent()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline NodePath NodePath::get_parent(Thread *current_thread) const
  NodePath *return_value = new NodePath(((*(const NodePath*)local_this).get_parent)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

static PyObject *Dtool_NodePath_sort_Getter(PyObject *self, void *) {
  const NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int NodePath::get_sort(Thread *current_thread) const
  int return_value = ((*(const NodePath*)local_this).get_sort)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * mapping getitem for property NodePath::net_tags
 */
static PyObject *Dtool_NodePath_net_tags_Mapping_Getitem(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }
  {
    // 1-inline bool NodePath::has_net_tag(std::string const &key) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      bool return_value = ((*(const NodePath*)local_this).has_net_tag)(std::string(param1_str, param1_len));
      if (!return_value) {
        PyErr_SetObject(PyExc_KeyError, arg);
        return nullptr;
      }
    }
  }
  // 1-inline std::string NodePath::get_net_tag(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    std::string return_value = ((*(const NodePath*)local_this).get_net_tag)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_tag(NodePath self, str key)\n");
  }
  return nullptr;
}

static PyObject *Dtool_NodePath_net_tags_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MappingWrapper *wrap = Dtool_NewMappingWrapper(self, "NodePath.net_tags");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_NodePath_net_tags_Mapping_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_NodePath_tags_Getter(PyObject *self, void *) {
  const NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PyObject *NodePath::get_tags(void) const
  PyObject *return_value = invoke_extension((const NodePath*)local_this).get_tags();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_NodePath_python_tags_Getter(PyObject *self, void *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.python_tags")) {
    return nullptr;
  }

  // 1-PyObject *NodePath::get_python_tags(void)
  PyObject *return_value = invoke_extension(local_this).get_python_tags();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_NodePath_name_Getter(PyObject *self, void *) {
  const NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string NodePath::get_name(void) const
  std::string return_value = ((*(const NodePath*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_NodePath_name_Setter(PyObject *self, PyObject *arg, void *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePath, (void **)&local_this, "NodePath.name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete name attribute");
    return -1;
  }
  // 1-inline void NodePath::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_name(const NodePath self, str name)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline NodePath::NodePath(void)
 * Rejected Remap [inline NodePath::NodePath(NodePath &&from) noexcept]
 * inline NodePath::NodePath(NodePath const &copy)
 * explicit NodePath::NodePath(NodePath const &parent, PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
 * inline explicit NodePath::NodePath(PandaNode *node, Thread *current_thread = Thread::get_current_thread())
 * inline explicit NodePath::NodePath(std::string const &top_node_name, Thread *current_thread = Thread::get_current_thread())
 */
static int Dtool_Init_NodePath(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline NodePath::NodePath(void)
      NodePath *return_value = new NodePath();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodePath, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline explicit NodePath::NodePath(PandaNode *node, Thread *current_thread)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "node")) {
          PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "NodePath.NodePath", false, false);
          if (param0_this != nullptr) {
            NodePath *return_value = new NodePath(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodePath, true, false);
          }
        }
      }

      {
        // -2 inline explicit NodePath::NodePath(std::string const &top_node_name, Thread *current_thread)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"top_node_name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:NodePath", (char **)keyword_list, &param0_str, &param0_len)) {
          NodePath *return_value = new NodePath(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodePath, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline NodePath::NodePath(NodePath const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          NodePath const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NodePath);
          if (param0_this != nullptr) {
            NodePath *return_value = new NodePath(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodePath, true, false);
          }
        }
      }

      // No coercion possible: inline explicit NodePath::NodePath(PandaNode *node, Thread *current_thread)
      // No coercion possible: inline explicit NodePath::NodePath(std::string const &top_node_name, Thread *current_thread)
      // No coercion possible: inline NodePath::NodePath(NodePath const &copy)
    }
    break;
  case 2:
  case 3:
    {
      {
        // -2 explicit NodePath::NodePath(NodePath const &parent, PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"parent", "child_node", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:NodePath", (char **)keyword_list, &param0, &param1, &param2)) {
          NodePath const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NodePath);
          PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "NodePath.NodePath", false, false);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "NodePath.NodePath", false, false);
          }
          if (param0_this != nullptr && param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            NodePath *return_value = new NodePath(*param0_this, param1_this, param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodePath, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline explicit NodePath::NodePath(PandaNode *node, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"node", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:NodePath", (char **)keyword_list, &param0, &param1)) {
          PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "NodePath.NodePath", false, false);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.NodePath", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            NodePath *return_value = new NodePath(param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodePath, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline explicit NodePath::NodePath(std::string const &top_node_name, Thread *current_thread = Thread::get_current_thread())
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        static const char *keyword_list[] = {"top_node_name", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:NodePath", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "NodePath.NodePath", false, false);
          if (param1_this != nullptr) {
            NodePath *return_value = new NodePath(std::string(param0_str, param0_len), param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodePath, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: explicit NodePath::NodePath(NodePath const &parent, PandaNode *child_node, Thread *current_thread = Thread::get_current_thread())
      // No coercion possible: inline explicit NodePath::NodePath(PandaNode *node, Thread *current_thread = Thread::get_current_thread())
      // No coercion possible: inline explicit NodePath::NodePath(std::string const &top_node_name, Thread *current_thread = Thread::get_current_thread())
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NodePath() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NodePath()\n"
      "NodePath(PandaNode node)\n"
      "NodePath(str top_node_name)\n"
      "NodePath(const NodePath copy)\n"
      "NodePath(const NodePath parent, PandaNode child_node, Thread current_thread)\n"
      "NodePath(PandaNode node, Thread current_thread)\n"
      "NodePath(str top_node_name, Thread current_thread)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NodePath_get_nodes(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_nodes)();
  PyTupleObject args;
  (void)PyObject_INIT_VAR((PyVarObject *)&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_NodePath_get_node_599(self, (PyObject *)&args, nullptr);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NodePath_get_ancestors(PyObject *self, PyObject *) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_nodes)();
  PyTupleObject args;
  (void)PyObject_INIT_VAR((PyVarObject *)&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_NodePath_get_ancestor_603(self, (PyObject *)&args, nullptr);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NodePath(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NodePath) {
    printf("NodePath ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NodePath *local_this = (NodePath *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NodePath) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NodePath(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NodePath) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NodePathCollection
 */
/**
 * Python function wrapper for:
 * PyObject *NodePathCollection::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_NodePathCollection_reduce_623(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  // 1-PyObject *NodePathCollection::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const NodePathCollection*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_reduce_623_comment =
  "C++ Interface:\n"
  "__reduce__(NodePathCollection self)\n";
#else
static const char *Dtool_NodePathCollection_reduce_623_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::add_path(NodePath const &node_path)
 */
static PyObject *Dtool_NodePathCollection_add_path_624(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.add_path")) {
    return nullptr;
  }
  // 1-void NodePathCollection::add_path(NodePath const &node_path)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePathCollection.add_path", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_path)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_path(const NodePathCollection self, const NodePath node_path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_add_path_624_comment =
  "C++ Interface:\n"
  "add_path(const NodePathCollection self, const NodePath node_path)\n"
  "\n"
  "/**\n"
  " * Adds a new NodePath to the collection.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_add_path_624_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePathCollection::remove_path(NodePath const &node_path)
 */
static PyObject *Dtool_NodePathCollection_remove_path_625(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.remove_path")) {
    return nullptr;
  }
  // 1-bool NodePathCollection::remove_path(NodePath const &node_path)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePathCollection.remove_path", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_path)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_path(const NodePathCollection self, const NodePath node_path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_remove_path_625_comment =
  "C++ Interface:\n"
  "remove_path(const NodePathCollection self, const NodePath node_path)\n"
  "\n"
  "/**\n"
  " * Removes the indicated NodePath from the collection.  Returns true if the\n"
  " * path was removed, false if it was not a member of the collection.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_remove_path_625_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::add_paths_from(NodePathCollection const &other)
 */
static PyObject *Dtool_NodePathCollection_add_paths_from_626(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.add_paths_from")) {
    return nullptr;
  }
  // 1-void NodePathCollection::add_paths_from(NodePathCollection const &other)
  NodePathCollection arg_local;
  NodePathCollection const *arg_this = Dtool_Coerce_NodePathCollection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePathCollection.add_paths_from", "NodePathCollection");
  }
  ((*local_this).add_paths_from)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_paths_from(const NodePathCollection self, const NodePathCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_add_paths_from_626_comment =
  "C++ Interface:\n"
  "add_paths_from(const NodePathCollection self, const NodePathCollection other)\n"
  "\n"
  "/**\n"
  " * Adds all the NodePaths indicated in the other collection to this path.  The\n"
  " * other paths are simply appended to the end of the paths in this list;\n"
  " * duplicates are not automatically removed.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_add_paths_from_626_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::remove_paths_from(NodePathCollection const &other)
 */
static PyObject *Dtool_NodePathCollection_remove_paths_from_627(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.remove_paths_from")) {
    return nullptr;
  }
  // 1-void NodePathCollection::remove_paths_from(NodePathCollection const &other)
  NodePathCollection arg_local;
  NodePathCollection const *arg_this = Dtool_Coerce_NodePathCollection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePathCollection.remove_paths_from", "NodePathCollection");
  }
  ((*local_this).remove_paths_from)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_paths_from(const NodePathCollection self, const NodePathCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_remove_paths_from_627_comment =
  "C++ Interface:\n"
  "remove_paths_from(const NodePathCollection self, const NodePathCollection other)\n"
  "\n"
  "/**\n"
  " * Removes from this collection all of the NodePaths listed in the other\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_remove_paths_from_627_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::remove_duplicate_paths(void)
 */
static PyObject *Dtool_NodePathCollection_remove_duplicate_paths_628(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.remove_duplicate_paths")) {
    return nullptr;
  }
  // 1-void NodePathCollection::remove_duplicate_paths(void)
  ((*local_this).remove_duplicate_paths)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_remove_duplicate_paths_628_comment =
  "C++ Interface:\n"
  "remove_duplicate_paths(const NodePathCollection self)\n"
  "\n"
  "/**\n"
  " * Removes any duplicate entries of the same NodePaths on this collection.  If\n"
  " * a NodePath appears multiple times, the first appearance is retained;\n"
  " * subsequent appearances are removed.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_remove_duplicate_paths_628_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePathCollection::has_path(NodePath const &path) const
 */
static PyObject *Dtool_NodePathCollection_has_path_629(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  // 1-bool NodePathCollection::has_path(NodePath const &path) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePathCollection.has_path", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const NodePathCollection*)local_this).has_path)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_path(NodePathCollection self, const NodePath path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_has_path_629_comment =
  "C++ Interface:\n"
  "has_path(NodePathCollection self, const NodePath path)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated NodePath appears in this collection, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_has_path_629_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::clear(void)
 */
static PyObject *Dtool_NodePathCollection_clear_630(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.clear")) {
    return nullptr;
  }
  // 1-void NodePathCollection::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_clear_630_comment =
  "C++ Interface:\n"
  "clear(const NodePathCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all NodePaths from the collection.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_clear_630_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::reserve(std::size_t num)
 */
static PyObject *Dtool_NodePathCollection_reserve_631(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.reserve")) {
    return nullptr;
  }
  // 1-void NodePathCollection::reserve(std::size_t num)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).reserve)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reserve(const NodePathCollection self, int num)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_reserve_631_comment =
  "C++ Interface:\n"
  "reserve(const NodePathCollection self, int num)\n"
  "\n"
  "/**\n"
  " * This is a hint to Panda to allocate enough memory to hold the given number\n"
  " * of NodePaths, if you know ahead of time how many you will be adding.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_reserve_631_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePathCollection::is_empty(void) const
 */
static PyObject *Dtool_NodePathCollection_is_empty_632(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  // 1-bool NodePathCollection::is_empty(void) const
  bool return_value = ((*(const NodePathCollection*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_is_empty_632_comment =
  "C++ Interface:\n"
  "is_empty(NodePathCollection self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are no NodePaths in the collection, false otherwise.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_is_empty_632_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int NodePathCollection::get_num_paths(void) const
 */
static PyObject *Dtool_NodePathCollection_get_num_paths_633(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  // 1-int NodePathCollection::get_num_paths(void) const
  int return_value = ((*(const NodePathCollection*)local_this).get_num_paths)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_get_num_paths_633_comment =
  "C++ Interface:\n"
  "get_num_paths(NodePathCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of NodePaths in the collection.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_get_num_paths_633_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NodePathCollection::get_path(int index) const
 */
static PyObject *Dtool_NodePathCollection_get_path_634(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  // 1-NodePath NodePathCollection::get_path(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath(((*(const NodePathCollection*)local_this).get_path)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_path(NodePathCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_get_path_634_comment =
  "C++ Interface:\n"
  "get_path(NodePathCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth NodePath in the collection.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_get_path_634_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePathCollection::append(NodePath const &node_path)
 */
static PyObject *Dtool_NodePathCollection_append_640(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.append")) {
    return nullptr;
  }
  // 1-inline void NodePathCollection::append(NodePath const &node_path)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePathCollection.append", true, true);
  if (arg_this != nullptr) {
    ((*local_this).append)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append(const NodePathCollection self, const NodePath node_path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_append_640_comment =
  "C++ Interface:\n"
  "append(const NodePathCollection self, const NodePath node_path)\n"
  "\n"
  "// Method names to satisfy Python's conventions.\n"
  "\n"
  "/**\n"
  " * Adds a new NodePath to the collection.  This method duplicates the\n"
  " * add_path() method; it is provided to satisfy Python's naming convention.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_append_640_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePathCollection::extend(NodePathCollection const &other)
 */
static PyObject *Dtool_NodePathCollection_extend_641(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.extend")) {
    return nullptr;
  }
  // 1-inline void NodePathCollection::extend(NodePathCollection const &other)
  NodePathCollection arg_local;
  NodePathCollection const *arg_this = Dtool_Coerce_NodePathCollection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePathCollection.extend", "NodePathCollection");
  }
  ((*local_this).extend)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extend(const NodePathCollection self, const NodePathCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_extend_641_comment =
  "C++ Interface:\n"
  "extend(const NodePathCollection self, const NodePathCollection other)\n"
  "\n"
  "/**\n"
  " * Appends the other list onto the end of this one.  This method duplicates\n"
  " * the += operator; it is provided to satisfy Python's naming convention.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_extend_641_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodePathCollection::ls(void) const
 * void NodePathCollection::ls(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_NodePathCollection_ls_642(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void NodePathCollection::ls(void) const
      ((*(const NodePathCollection*)local_this).ls)();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-void NodePathCollection::ls(std::ostream &out, int indent_level = 0) const
      PyObject *param1;
      int param2 = 0;
      static const char *keyword_list[] = {"out", "indent_level", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:ls", (char **)keyword_list, &param1, &param2)) {
        std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "NodePathCollection.ls", false, true);
        if (param1_this != nullptr) {
          ((*(const NodePathCollection*)local_this).ls)(*param1_this, (int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "ls() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls(NodePathCollection self)\n"
      "ls(NodePathCollection self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_ls_642_comment =
  "C++ Interface:\n"
  "ls(NodePathCollection self)\n"
  "ls(NodePathCollection self, ostream out, int indent_level)\n"
  "\n"
  "// Handy operations on many NodePaths at once.\n"
  "\n"
  "/**\n"
  " * Lists all the nodes at and below each node in the collection\n"
  " * hierarchically.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Lists all the nodes at and below each node in the collection\n"
  " * hierarchically.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_ls_642_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePathCollection NodePathCollection::find_all_matches(std::string const &path) const
 */
static PyObject *Dtool_NodePathCollection_find_all_matches_643(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  // 1-NodePathCollection NodePathCollection::find_all_matches(std::string const &path) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    NodePathCollection *return_value = new NodePathCollection(((*(const NodePathCollection*)local_this).find_all_matches)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_matches(NodePathCollection self, str path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_find_all_matches_643_comment =
  "C++ Interface:\n"
  "find_all_matches(NodePathCollection self, str path)\n"
  "\n"
  "/**\n"
  " * Returns the complete set of all NodePaths that begin with any NodePath in\n"
  " * this collection and can be extended by path.  The shortest paths will be\n"
  " * listed first.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_find_all_matches_643_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::reparent_to(NodePath const &other)
 */
static PyObject *Dtool_NodePathCollection_reparent_to_644(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.reparent_to")) {
    return nullptr;
  }
  // 1-void NodePathCollection::reparent_to(NodePath const &other)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePathCollection.reparent_to", true, true);
  if (arg_this != nullptr) {
    ((*local_this).reparent_to)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reparent_to(const NodePathCollection self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_reparent_to_644_comment =
  "C++ Interface:\n"
  "reparent_to(const NodePathCollection self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Reparents all the NodePaths in the collection to the indicated node.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_reparent_to_644_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::wrt_reparent_to(NodePath const &other)
 */
static PyObject *Dtool_NodePathCollection_wrt_reparent_to_645(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.wrt_reparent_to")) {
    return nullptr;
  }
  // 1-void NodePathCollection::wrt_reparent_to(NodePath const &other)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NodePathCollection.wrt_reparent_to", true, true);
  if (arg_this != nullptr) {
    ((*local_this).wrt_reparent_to)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wrt_reparent_to(const NodePathCollection self, const NodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_wrt_reparent_to_645_comment =
  "C++ Interface:\n"
  "wrt_reparent_to(const NodePathCollection self, const NodePath other)\n"
  "\n"
  "/**\n"
  " * Reparents all the NodePaths in the collection to the indicated node,\n"
  " * adjusting each transform so as not to move in world coordinates.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_wrt_reparent_to_645_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::show(void)
 */
static PyObject *Dtool_NodePathCollection_show_646(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.show")) {
    return nullptr;
  }
  // 1-void NodePathCollection::show(void)
  ((*local_this).show)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_show_646_comment =
  "C++ Interface:\n"
  "show(const NodePathCollection self)\n"
  "\n"
  "/**\n"
  " * Shows all NodePaths in the collection.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_show_646_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::hide(void)
 */
static PyObject *Dtool_NodePathCollection_hide_647(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.hide")) {
    return nullptr;
  }
  // 1-void NodePathCollection::hide(void)
  ((*local_this).hide)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_hide_647_comment =
  "C++ Interface:\n"
  "hide(const NodePathCollection self)\n"
  "\n"
  "/**\n"
  " * Hides all NodePaths in the collection.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_hide_647_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::stash(void)
 */
static PyObject *Dtool_NodePathCollection_stash_648(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.stash")) {
    return nullptr;
  }
  // 1-void NodePathCollection::stash(void)
  ((*local_this).stash)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_stash_648_comment =
  "C++ Interface:\n"
  "stash(const NodePathCollection self)\n"
  "\n"
  "/**\n"
  " * Stashes all NodePaths in the collection.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_stash_648_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::unstash(void)
 */
static PyObject *Dtool_NodePathCollection_unstash_649(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.unstash")) {
    return nullptr;
  }
  // 1-void NodePathCollection::unstash(void)
  ((*local_this).unstash)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_unstash_649_comment =
  "C++ Interface:\n"
  "unstash(const NodePathCollection self)\n"
  "\n"
  "/**\n"
  " * Unstashes all NodePaths in the collection.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_unstash_649_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::detach(void)
 */
static PyObject *Dtool_NodePathCollection_detach_650(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.detach")) {
    return nullptr;
  }
  // 1-void NodePathCollection::detach(void)
  ((*local_this).detach)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_detach_650_comment =
  "C++ Interface:\n"
  "detach(const NodePathCollection self)\n"
  "\n"
  "/**\n"
  " * Detaches all NodePaths in the collection.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_detach_650_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CollideMask NodePathCollection::get_collide_mask(void) const
 */
static PyObject *Dtool_NodePathCollection_get_collide_mask_651(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  // 1-CollideMask NodePathCollection::get_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const NodePathCollection*)local_this).get_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_get_collide_mask_651_comment =
  "C++ Interface:\n"
  "get_collide_mask(NodePathCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the union of all of the into_collide_masks for nodes at this level\n"
  " * and below.  This is the same thing as node()->get_net_collide_mask().\n"
  " *\n"
  " * If you want to return what the into_collide_mask of this node itself is,\n"
  " * without regard to its children, use node()->get_into_collide_mask().\n"
  " */";
#else
static const char *Dtool_NodePathCollection_get_collide_mask_651_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::set_collide_mask(CollideMask new_mask, CollideMask bits_to_change = CollideMask::all_on(), TypeHandle node_type = TypeHandle::none())
 */
static PyObject *Dtool_NodePathCollection_set_collide_mask_652(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.set_collide_mask")) {
    return nullptr;
  }
  // 1-void NodePathCollection::set_collide_mask(CollideMask new_mask, CollideMask bits_to_change = CollideMask::all_on(), TypeHandle node_type = TypeHandle::none())
  PyObject *param1;
  PyObject *param2 = nullptr;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"new_mask", "bits_to_change", "node_type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:set_collide_mask", (char **)keyword_list, &param1, &param2, &param3)) {
    BitMask< uint32_t, 32 > param1_local;
    CollideMask *param1_this = Dtool_Coerce_BitMask_uint32_t_32(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "NodePathCollection.set_collide_mask", "BitMask");
    }
    BitMask< uint32_t, 32 > param2_local;
    CollideMask *param2_this;
    if (param2 != nullptr) {
      param2_this = Dtool_Coerce_BitMask_uint32_t_32(param2, param2_local);
    } else {
      param2_local = BitMask< uint32_t, 32 >::all_on();
      param2_this = &param2_local;
    }
    if (param2 != nullptr && !(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NodePathCollection.set_collide_mask", "BitMask");
    }
    TypeHandle param3_local;
    TypeHandle *param3_this;
    if (param3 != nullptr) {
      param3_this = Dtool_Coerce_TypeHandle(param3, param3_local);
    } else {
      param3_local = TypeHandle::none();
      param3_this = &param3_local;
    }
    if (param3 != nullptr && !(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "NodePathCollection.set_collide_mask", "TypeHandle");
    }
    ((*local_this).set_collide_mask)(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_mask(const NodePathCollection self, BitMask new_mask, BitMask bits_to_change, TypeHandle node_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_set_collide_mask_652_comment =
  "C++ Interface:\n"
  "set_collide_mask(const NodePathCollection self, BitMask new_mask, BitMask bits_to_change, TypeHandle node_type)\n"
  "\n"
  "/**\n"
  " * Recursively applies the indicated CollideMask to the into_collide_masks for\n"
  " * all nodes at this level and below.\n"
  " *\n"
  " * The default is to change all bits, but if bits_to_change is not all bits\n"
  " * on, then only the bits that are set in bits_to_change are modified,\n"
  " * allowing this call to change only a subset of the bits in the subgraph.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_set_collide_mask_652_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NodePathCollection::calc_tight_bounds(LPoint3 &min_point, LPoint3 &max_point) const
 */
static PyObject *Dtool_NodePathCollection_calc_tight_bounds_653(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  // 1-bool NodePathCollection::calc_tight_bounds(LPoint3 &min_point, LPoint3 &max_point) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"min_point", "max_point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:calc_tight_bounds", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "NodePathCollection.calc_tight_bounds", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NodePathCollection.calc_tight_bounds", "LPoint3f");
    }
    bool return_value = ((*(const NodePathCollection*)local_this).calc_tight_bounds)(*param1_this, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_tight_bounds(NodePathCollection self, LPoint3f min_point, LPoint3f max_point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_calc_tight_bounds_653_comment =
  "C++ Interface:\n"
  "calc_tight_bounds(NodePathCollection self, LPoint3f min_point, LPoint3f max_point)\n"
  "\n"
  "/**\n"
  " * Calculates the minimum and maximum vertices of all Geoms at these\n"
  " * NodePath's bottom nodes and below This is a tight bounding box; it will\n"
  " * generally be tighter than the bounding volume returned by get_bounds() (but\n"
  " * it is more expensive to compute).\n"
  " *\n"
  " * The return value is true if any points are within the bounding volume, or\n"
  " * false if none are.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_calc_tight_bounds_653_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *NodePathCollection::get_tight_bounds(void) const
 */
static PyObject *Dtool_NodePathCollection_get_tight_bounds_654(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  // 1-PyObject *NodePathCollection::get_tight_bounds(void) const
  PyObject *return_value = invoke_extension((const NodePathCollection*)local_this).get_tight_bounds();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_get_tight_bounds_654_comment =
  "C++ Interface:\n"
  "get_tight_bounds(NodePathCollection self)\n";
#else
static const char *Dtool_NodePathCollection_get_tight_bounds_654_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::set_texture(Texture *tex, int priority = 0)
 * void NodePathCollection::set_texture(TextureStage *stage, Texture *tex, int priority = 0)
 */
static PyObject *Dtool_NodePathCollection_set_texture_655(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.set_texture")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "tex")) {
        // 1-void NodePathCollection::set_texture(Texture *tex, int priority)
        Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "NodePathCollection.set_texture", false, true);
        if (arg_this != nullptr) {
          ((*local_this).set_texture)(arg_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
  case 3:
    {
      {
        // -2 void NodePathCollection::set_texture(TextureStage *stage, Texture *tex, int priority = 0)
        PyObject *param1;
        PyObject *param2;
        int param3 = 0;
        static const char *keyword_list[] = {"stage", "tex", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:set_texture", (char **)keyword_list, &param1, &param2, &param3)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePathCollection.set_texture", false, false);
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "NodePathCollection.set_texture", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_texture)(param1_this, param2_this, (int)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePathCollection::set_texture(Texture *tex, int priority = 0)
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"tex", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_texture", (char **)keyword_list, &param1, &param2)) {
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "NodePathCollection.set_texture", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_texture)(param1_this, (int)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePathCollection::set_texture(TextureStage *stage, Texture *tex, int priority = 0)
      // No coercion possible: void NodePathCollection::set_texture(Texture *tex, int priority = 0)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_texture() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture(const NodePathCollection self, Texture tex)\n"
      "set_texture(const NodePathCollection self, TextureStage stage, Texture tex, int priority)\n"
      "set_texture(const NodePathCollection self, Texture tex, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_set_texture_655_comment =
  "C++ Interface:\n"
  "set_texture(const NodePathCollection self, Texture tex)\n"
  "set_texture(const NodePathCollection self, TextureStage stage, Texture tex, int priority)\n"
  "set_texture(const NodePathCollection self, Texture tex, int priority)\n"
  "\n"
  "/**\n"
  " * Adds the indicated texture to the list of textures that will be rendered on\n"
  " * the default texture stage.\n"
  " *\n"
  " * This is the deprecated single-texture variant of this method; it is now\n"
  " * superceded by set_texture() that accepts a stage and texture.  However,\n"
  " * this method may be used in the presence of multitexture if you just want to\n"
  " * adjust the default stage.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the indicated texture to the list of textures that will be rendered on\n"
  " * the indicated multitexture stage.  If there are multiple texture stages\n"
  " * specified (possibly on multiple different nodes at different levels), they\n"
  " * will all be applied to geometry together, according to the stage\n"
  " * specification set up in the TextureStage object.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_set_texture_655_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::set_texture_off(TextureStage *stage, int priority = 0)
 * void NodePathCollection::set_texture_off(int priority = 0)
 */
static PyObject *Dtool_NodePathCollection_set_texture_off_656(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.set_texture_off")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void NodePathCollection::set_texture_off(int priority)
      ((*local_this).set_texture_off)();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 void NodePathCollection::set_texture_off(TextureStage *stage, int priority = 0)
        PyObject *param1;
        int param2 = 0;
        static const char *keyword_list[] = {"stage", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_texture_off", (char **)keyword_list, &param1, &param2)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "NodePathCollection.set_texture_off", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_texture_off)(param1_this, (int)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void NodePathCollection::set_texture_off(int priority = 0)
        int param1;
        static const char *keyword_list[] = {"priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:set_texture_off", (char **)keyword_list, &param1)) {
          ((*local_this).set_texture_off)((int)param1);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      // No coercion possible: void NodePathCollection::set_texture_off(TextureStage *stage, int priority = 0)
      // No coercion possible: void NodePathCollection::set_texture_off(int priority = 0)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_texture_off() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_off(const NodePathCollection self)\n"
      "set_texture_off(const NodePathCollection self, TextureStage stage, int priority)\n"
      "set_texture_off(const NodePathCollection self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_set_texture_off_656_comment =
  "C++ Interface:\n"
  "set_texture_off(const NodePathCollection self)\n"
  "set_texture_off(const NodePathCollection self, TextureStage stage, int priority)\n"
  "set_texture_off(const NodePathCollection self, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render using no texture, on\n"
  " * any stage.  This is different from not specifying a texture; rather, this\n"
  " * specifically contradicts set_texture() at a higher node level (or, with a\n"
  " * priority, overrides a set_texture() at a lower level).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the geometry at this level and below to render using no texture, on\n"
  " * the indicated stage.  This is different from not specifying a texture;\n"
  " * rather, this specifically contradicts set_texture() at a higher node level\n"
  " * (or, with a priority, overrides a set_texture() at a lower level).\n"
  " */";
#else
static const char *Dtool_NodePathCollection_set_texture_off_656_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::set_color(LColor const &color, int priority = 0)
 * inline void NodePathCollection::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0)
 */
static PyObject *Dtool_NodePathCollection_set_color_657(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.set_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "color")) {
        // 1-void NodePathCollection::set_color(LColor const &color, int priority)
        LVecBase4f arg_local;
        LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePathCollection.set_color", "LVecBase4f");
        }
        ((*local_this).set_color)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePathCollection::set_color(LColor const &color, int priority)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"color", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_color", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param1_local;
        LColor const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePathCollection.set_color", "LVecBase4f");
        }
        ((*local_this).set_color)(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
  case 4:
  case 5:
    {
      // 1-inline void NodePathCollection::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0)
      float param1;
      float param2;
      float param3;
      float param4 = 1.0;
      int param5 = 0;
      static const char *keyword_list[] = {"r", "g", "b", "a", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff|fi:set_color", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).set_color)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (int)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color() takes 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const NodePathCollection self, const LVecBase4f color)\n"
      "set_color(const NodePathCollection self, const LVecBase4f color, int priority)\n"
      "set_color(const NodePathCollection self, float r, float g, float b, float a, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_set_color_657_comment =
  "C++ Interface:\n"
  "set_color(const NodePathCollection self, const LVecBase4f color)\n"
  "set_color(const NodePathCollection self, const LVecBase4f color, int priority)\n"
  "set_color(const NodePathCollection self, float r, float g, float b, float a, int priority)\n"
  "\n"
  "/**\n"
  " * Colors all NodePaths in the collection\n"
  " */\n"
  "\n"
  "/**\n"
  " * Colors all NodePaths in the collection\n"
  " */";
#else
static const char *Dtool_NodePathCollection_set_color_657_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::set_color_scale(LVecBase4 const &scale, int priority = 0)
 * inline void NodePathCollection::set_color_scale(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0)
 */
static PyObject *Dtool_NodePathCollection_set_color_scale_658(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.set_color_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "scale")) {
        // 1-void NodePathCollection::set_color_scale(LVecBase4 const &scale, int priority)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePathCollection.set_color_scale", "LVecBase4f");
        }
        ((*local_this).set_color_scale)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePathCollection::set_color_scale(LVecBase4 const &scale, int priority)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"scale", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_color_scale", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param1_local;
        LVecBase4 const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePathCollection.set_color_scale", "LVecBase4f");
        }
        ((*local_this).set_color_scale)(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
  case 4:
  case 5:
    {
      // 1-inline void NodePathCollection::set_color_scale(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0)
      float param1;
      float param2;
      float param3;
      float param4 = 1.0;
      int param5 = 0;
      static const char *keyword_list[] = {"r", "g", "b", "a", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff|fi:set_color_scale", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).set_color_scale)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (int)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color_scale() takes 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_scale(const NodePathCollection self, const LVecBase4f scale)\n"
      "set_color_scale(const NodePathCollection self, const LVecBase4f scale, int priority)\n"
      "set_color_scale(const NodePathCollection self, float r, float g, float b, float a, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_set_color_scale_658_comment =
  "C++ Interface:\n"
  "set_color_scale(const NodePathCollection self, const LVecBase4f scale)\n"
  "set_color_scale(const NodePathCollection self, const LVecBase4f scale, int priority)\n"
  "set_color_scale(const NodePathCollection self, float r, float g, float b, float a, int priority)\n"
  "\n"
  "/**\n"
  " * Applies color scales to all NodePaths in the collection.  The existing\n"
  " * color scale is replaced.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Applies color scales to all NodePaths in the collection.  The existing\n"
  " * color scale is replaced.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_set_color_scale_658_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::compose_color_scale(LVecBase4 const &scale, int priority = 0)
 * inline void NodePathCollection::compose_color_scale(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0)
 */
static PyObject *Dtool_NodePathCollection_compose_color_scale_659(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.compose_color_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "scale")) {
        // 1-void NodePathCollection::compose_color_scale(LVecBase4 const &scale, int priority)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "NodePathCollection.compose_color_scale", "LVecBase4f");
        }
        ((*local_this).compose_color_scale)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void NodePathCollection::compose_color_scale(LVecBase4 const &scale, int priority)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"scale", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:compose_color_scale", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param1_local;
        LVecBase4 const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "NodePathCollection.compose_color_scale", "LVecBase4f");
        }
        ((*local_this).compose_color_scale)(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
  case 4:
  case 5:
    {
      // 1-inline void NodePathCollection::compose_color_scale(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0)
      float param1;
      float param2;
      float param3;
      float param4 = 1.0;
      int param5 = 0;
      static const char *keyword_list[] = {"r", "g", "b", "a", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff|fi:compose_color_scale", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).compose_color_scale)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (int)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compose_color_scale() takes 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compose_color_scale(const NodePathCollection self, const LVecBase4f scale)\n"
      "compose_color_scale(const NodePathCollection self, const LVecBase4f scale, int priority)\n"
      "compose_color_scale(const NodePathCollection self, float r, float g, float b, float a, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_compose_color_scale_659_comment =
  "C++ Interface:\n"
  "compose_color_scale(const NodePathCollection self, const LVecBase4f scale)\n"
  "compose_color_scale(const NodePathCollection self, const LVecBase4f scale, int priority)\n"
  "compose_color_scale(const NodePathCollection self, float r, float g, float b, float a, int priority)\n"
  "\n"
  "/**\n"
  " * Applies color scales to all NodePaths in the collection.  The existing\n"
  " * color scale, if any, is multiplied by the specified color scale.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Applies color scales to all NodePaths in the collection.  The existing\n"
  " * color scale, if any, is multiplied by the specified color scale.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_compose_color_scale_659_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::set_attrib(RenderAttrib const *attrib, int priority = 0)
 */
static PyObject *Dtool_NodePathCollection_set_attrib_660(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NodePathCollection, (void **)&local_this, "NodePathCollection.set_attrib")) {
    return nullptr;
  }
  // 1-void NodePathCollection::set_attrib(RenderAttrib const *attrib, int priority = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"attrib", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_attrib", (char **)keyword_list, &param1, &param2)) {
    RenderAttrib const *param1_this = (RenderAttrib *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_RenderAttrib, 1, "NodePathCollection.set_attrib", true, true);
    if (param1_this != nullptr) {
      ((*local_this).set_attrib)(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_attrib(const NodePathCollection self, const RenderAttrib attrib, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_set_attrib_660_comment =
  "C++ Interface:\n"
  "set_attrib(const NodePathCollection self, const RenderAttrib attrib, int priority)\n"
  "\n"
  "/**\n"
  " * Applies the indicated RenderAttrib to all NodePaths in the collection.  An\n"
  " * effort is made to apply the attrib to many NodePaths as quickly as\n"
  " * possible; redundant RenderState compositions are not duplicated.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_set_attrib_660_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::output(std::ostream &out) const
 */
static PyObject *Dtool_NodePathCollection_output_661(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  // 1-void NodePathCollection::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "NodePathCollection.output", false, true);
  if (arg_this != nullptr) {
    ((*(const NodePathCollection*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(NodePathCollection self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_output_661_comment =
  "C++ Interface:\n"
  "output(NodePathCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the NodePathCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_output_661_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NodePathCollection::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_NodePathCollection_write_662(PyObject *self, PyObject *args, PyObject *kwds) {
  NodePathCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodePathCollection)) {
    return nullptr;
  }
  // 1-void NodePathCollection::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "NodePathCollection.write", false, true);
    if (param1_this != nullptr) {
      ((*(const NodePathCollection*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(NodePathCollection self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NodePathCollection_write_662_comment =
  "C++ Interface:\n"
  "write(NodePathCollection self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the NodePathCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_NodePathCollection_write_662_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePathCollection::NodePathCollection(void) = default
 * inline NodePathCollection::NodePathCollection(NodePathCollection const &) = default
 * NodePathCollection::NodePathCollection(PyObject *self, PyObject *sequence)
 */
static int Dtool_Init_NodePathCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-NodePathCollection::NodePathCollection(void) = default
      NodePathCollection *return_value = new NodePathCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodePathCollection, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline NodePathCollection::NodePathCollection(NodePathCollection const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          NodePathCollection const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NodePathCollection);
          if (param0_this != nullptr) {
            NodePathCollection *return_value = new NodePathCollection(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodePathCollection, true, false);
          }
        }
      }

      {
        // -2 NodePathCollection::NodePathCollection(PyObject *self, PyObject *sequence)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "sequence")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_NodePathCollection, false, false);
          NodePathCollection *result = new NodePathCollection;
          invoke_extension(result).__init__(self, param0);
          NodePathCollection *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodePathCollection, true, false);
          }
        }
      }

      {
        // -2 inline NodePathCollection::NodePathCollection(NodePathCollection const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          NodePathCollection param0_local;
          NodePathCollection const *param0_this = Dtool_Coerce_NodePathCollection(param0, param0_local);
          if ((param0_this != nullptr)) {
            NodePathCollection *return_value = new NodePathCollection(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodePathCollection, true, false);
          }
        }
      }

      // No coercion possible: NodePathCollection::NodePathCollection(PyObject *self, PyObject *sequence)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NodePathCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NodePathCollection()\n"
      "NodePathCollection(const NodePathCollection param0)\n"
      "NodePathCollection(object sequence)\n");
  }
  return -1;
}

NodePathCollection *Dtool_Coerce_NodePathCollection(PyObject *args, NodePathCollection &coerced) {
  NodePathCollection *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_NodePathCollection)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const NodePathCollection *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NodePathCollection::NodePathCollection(PyObject *self, PyObject *sequence)
    // Pre-initialize self for the constructor
    PyObject *self = Dtool_new_NodePathCollection(&Dtool_NodePathCollection._PyType, nullptr, nullptr);
    invoke_extension(&coerced).__init__(self, arg);
    PyObject_Del(self);
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      return nullptr;
    } else {
      return &coerced;
    }
  }
  return nullptr;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NodePathCollection_get_paths(PyObject *self, PyObject *) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePathCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_paths)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NodePathCollection_get_path_634(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NodePathCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NodePathCollection) {
    printf("NodePathCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NodePathCollection *local_this = (NodePathCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NodePathCollection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NodePathCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NodePathCollection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AttribNodeRegistry
 */
/**
 * Python function wrapper for:
 * void AttribNodeRegistry::add_node(NodePath const &attrib_node)
 */
static PyObject *Dtool_AttribNodeRegistry_add_node_996(PyObject *self, PyObject *arg) {
  AttribNodeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AttribNodeRegistry, (void **)&local_this, "AttribNodeRegistry.add_node")) {
    return nullptr;
  }
  // 1-void AttribNodeRegistry::add_node(NodePath const &attrib_node)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AttribNodeRegistry.add_node", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_node)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_node(const AttribNodeRegistry self, const NodePath attrib_node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_add_node_996_comment =
  "C++ Interface:\n"
  "add_node(const AttribNodeRegistry self, const NodePath attrib_node)\n"
  "\n"
  "/**\n"
  " * Adds the indicated NodePath to the registry.  The name and type of the node\n"
  " * are noted at the time of this call; if the name changes later, it will not\n"
  " * update the registry index.\n"
  " *\n"
  " * The NodePath must reference some kind of an attribute node, such as a\n"
  " * LightNode or a PlaneNode.  When bam files that reference an attribute node\n"
  " * of the same type and the same name are loaded, they will quietly be\n"
  " * redirected to reference this NodePath.\n"
  " *\n"
  " * If there is already a node matching the indicated name and type, it will be\n"
  " * replaced.\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_add_node_996_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AttribNodeRegistry::remove_node(NodePath const &attrib_node)
 * void AttribNodeRegistry::remove_node(int n)
 */
static PyObject *Dtool_AttribNodeRegistry_remove_node_997(PyObject *self, PyObject *arg) {
  AttribNodeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AttribNodeRegistry, (void **)&local_this, "AttribNodeRegistry.remove_node")) {
    return nullptr;
  }
  {
    // -2 bool AttribNodeRegistry::remove_node(NodePath const &attrib_node)
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).remove_node)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 void AttribNodeRegistry::remove_node(int n)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      ((*local_this).remove_node)((int)arg_val);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: bool AttribNodeRegistry::remove_node(NodePath const &attrib_node)
  // No coercion possible: void AttribNodeRegistry::remove_node(int n)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_node(const AttribNodeRegistry self, const NodePath attrib_node)\n"
      "remove_node(const AttribNodeRegistry self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_remove_node_997_comment =
  "C++ Interface:\n"
  "remove_node(const AttribNodeRegistry self, const NodePath attrib_node)\n"
  "remove_node(const AttribNodeRegistry self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the indicated NodePath from the registry.  The name of the node\n"
  " * must not have changed since the matching call to add_node(), or it will not\n"
  " * be successfully removed.\n"
  " *\n"
  " * Returns true if the NodePath is found and removed, false if it is not found\n"
  " * (for instance, because the name has changed).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the nth node from the registry.\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_remove_node_997_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath AttribNodeRegistry::lookup_node(NodePath const &orig_node) const
 */
static PyObject *Dtool_AttribNodeRegistry_lookup_node_998(PyObject *self, PyObject *arg) {
  AttribNodeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AttribNodeRegistry)) {
    return nullptr;
  }
  // 1-NodePath AttribNodeRegistry::lookup_node(NodePath const &orig_node) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AttribNodeRegistry.lookup_node", true, true);
  if (arg_this != nullptr) {
    NodePath *return_value = new NodePath(((*(const AttribNodeRegistry*)local_this).lookup_node)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lookup_node(AttribNodeRegistry self, const NodePath orig_node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_lookup_node_998_comment =
  "C++ Interface:\n"
  "lookup_node(AttribNodeRegistry self, const NodePath orig_node)\n"
  "\n"
  "/**\n"
  " * Looks up the indicated NodePath in the registry.  If there is a node\n"
  " * already in the registry with the matching name and type, returns that\n"
  " * NodePath instead; otherwise, returns the original NodePath.\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_lookup_node_998_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int AttribNodeRegistry::get_num_nodes(void) const
 */
static PyObject *Dtool_AttribNodeRegistry_get_num_nodes_999(PyObject *self, PyObject *) {
  AttribNodeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AttribNodeRegistry)) {
    return nullptr;
  }
  // 1-int AttribNodeRegistry::get_num_nodes(void) const
  int return_value = ((*(const AttribNodeRegistry*)local_this).get_num_nodes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_get_num_nodes_999_comment =
  "C++ Interface:\n"
  "get_num_nodes(AttribNodeRegistry self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of nodes in the registry.\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_get_num_nodes_999_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath AttribNodeRegistry::get_node(int n) const
 */
static PyObject *Dtool_AttribNodeRegistry_get_node_1000(PyObject *self, PyObject *arg) {
  AttribNodeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AttribNodeRegistry)) {
    return nullptr;
  }
  // 1-NodePath AttribNodeRegistry::get_node(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath(((*(const AttribNodeRegistry*)local_this).get_node)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(AttribNodeRegistry self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_get_node_1000_comment =
  "C++ Interface:\n"
  "get_node(AttribNodeRegistry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth NodePath recorded in the registry.\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_get_node_1000_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypeHandle AttribNodeRegistry::get_node_type(int n) const
 */
static PyObject *Dtool_AttribNodeRegistry_get_node_type_1002(PyObject *self, PyObject *arg) {
  AttribNodeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AttribNodeRegistry)) {
    return nullptr;
  }
  // 1-TypeHandle AttribNodeRegistry::get_node_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle(((*(const AttribNodeRegistry*)local_this).get_node_type)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node_type(AttribNodeRegistry self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_get_node_type_1002_comment =
  "C++ Interface:\n"
  "get_node_type(AttribNodeRegistry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the type of the nth node, as recorded in the registry.\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_get_node_type_1002_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string AttribNodeRegistry::get_node_name(int n) const
 */
static PyObject *Dtool_AttribNodeRegistry_get_node_name_1003(PyObject *self, PyObject *arg) {
  AttribNodeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AttribNodeRegistry)) {
    return nullptr;
  }
  // 1-std::string AttribNodeRegistry::get_node_name(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const AttribNodeRegistry*)local_this).get_node_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node_name(AttribNodeRegistry self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_get_node_name_1003_comment =
  "C++ Interface:\n"
  "get_node_name(AttribNodeRegistry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth node, as recorded in the registry.  This will\n"
  " * be the node name as it was at the time the node was recorded; if the node\n"
  " * has changed names since then, this will still return the original name.\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_get_node_name_1003_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int AttribNodeRegistry::find_node(NodePath const &attrib_node) const
 * int AttribNodeRegistry::find_node(TypeHandle type, std::string const &name) const
 */
static PyObject *Dtool_AttribNodeRegistry_find_node_1004(PyObject *self, PyObject *args, PyObject *kwds) {
  AttribNodeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AttribNodeRegistry)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "attrib_node")) {
        // 1-int AttribNodeRegistry::find_node(NodePath const &attrib_node) const
        NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AttribNodeRegistry.find_node", true, true);
        if (arg_this != nullptr) {
          int return_value = ((*(const AttribNodeRegistry*)local_this).find_node)(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-int AttribNodeRegistry::find_node(TypeHandle type, std::string const &name) const
      PyObject *param1;
      const char *param2_str = nullptr;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"type", "name", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:find_node", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "AttribNodeRegistry.find_node", "TypeHandle");
        }
        int return_value = ((*(const AttribNodeRegistry*)local_this).find_node)(*param1_this, std::string(param2_str, param2_len));
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "find_node() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_node(AttribNodeRegistry self, const NodePath attrib_node)\n"
      "find_node(AttribNodeRegistry self, TypeHandle type, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_find_node_1004_comment =
  "C++ Interface:\n"
  "find_node(AttribNodeRegistry self, const NodePath attrib_node)\n"
  "find_node(AttribNodeRegistry self, TypeHandle type, str name)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the indicated NodePath in the registry\n"
  " * (assuming its name hasn't changed since it was recorded in the registry),\n"
  " * or -1 if the NodePath cannot be found (for instance, because its name has\n"
  " * changed).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the index number of the node with the indicated type and name in\n"
  " * the registry, or -1 if there is no such node in the registry.\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_find_node_1004_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AttribNodeRegistry::clear(void)
 */
static PyObject *Dtool_AttribNodeRegistry_clear_1005(PyObject *self, PyObject *) {
  AttribNodeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AttribNodeRegistry, (void **)&local_this, "AttribNodeRegistry.clear")) {
    return nullptr;
  }
  // 1-void AttribNodeRegistry::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_clear_1005_comment =
  "C++ Interface:\n"
  "clear(const AttribNodeRegistry self)\n"
  "\n"
  "/**\n"
  " * Removes all nodes from the registry.\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_clear_1005_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AttribNodeRegistry::output(std::ostream &out) const
 */
static PyObject *Dtool_AttribNodeRegistry_output_1006(PyObject *self, PyObject *arg) {
  AttribNodeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AttribNodeRegistry)) {
    return nullptr;
  }
  // 1-void AttribNodeRegistry::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AttribNodeRegistry.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AttribNodeRegistry*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AttribNodeRegistry self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_output_1006_comment =
  "C++ Interface:\n"
  "output(AttribNodeRegistry self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_output_1006_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AttribNodeRegistry::write(std::ostream &out) const
 */
static PyObject *Dtool_AttribNodeRegistry_write_1007(PyObject *self, PyObject *arg) {
  AttribNodeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AttribNodeRegistry)) {
    return nullptr;
  }
  // 1-void AttribNodeRegistry::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AttribNodeRegistry.write", false, true);
  if (arg_this != nullptr) {
    ((*(const AttribNodeRegistry*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AttribNodeRegistry self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_write_1007_comment =
  "C++ Interface:\n"
  "write(AttribNodeRegistry self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_write_1007_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline AttribNodeRegistry *AttribNodeRegistry::get_global_ptr(void)
 */
static PyObject *Dtool_AttribNodeRegistry_get_global_ptr_1008(PyObject *, PyObject *) {
  // 1-static inline AttribNodeRegistry *AttribNodeRegistry::get_global_ptr(void)
  AttribNodeRegistry *return_value = (AttribNodeRegistry::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AttribNodeRegistry, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AttribNodeRegistry_get_global_ptr_1008_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AttribNodeRegistry_get_global_ptr_1008_comment = nullptr;
#endif

static int Dtool_Init_AttribNodeRegistry(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_AttribNodeRegistry_get_nodes(PyObject *self, PyObject *) {
  AttribNodeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AttribNodeRegistry, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_nodes)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_AttribNodeRegistry_get_node_1000(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_AttribNodeRegistry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AttribNodeRegistry) {
    printf("AttribNodeRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AttribNodeRegistry *local_this = (AttribNodeRegistry *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AttribNodeRegistry) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AttribNodeRegistry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AttribNodeRegistry) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AudioVolumeAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > AudioVolumeAttrib::make_identity(void)
 */
static PyObject *Dtool_AudioVolumeAttrib_make_identity_1011(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > AudioVolumeAttrib::make_identity(void)
  ConstPointerTo< RenderAttrib > return_value = (AudioVolumeAttrib::make_identity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AudioVolumeAttrib_make_identity_1011_comment =
  "C++ Interface:\n"
  "make_identity()\n"
  "\n"
  "/**\n"
  " * Constructs an identity audio volume attrib.\n"
  " */";
#else
static const char *Dtool_AudioVolumeAttrib_make_identity_1011_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > AudioVolumeAttrib::make(PN_stdfloat volume)
 */
static PyObject *Dtool_AudioVolumeAttrib_make_1012(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > AudioVolumeAttrib::make(PN_stdfloat volume)
  if (PyNumber_Check(arg)) {
    ConstPointerTo< RenderAttrib > return_value = (AudioVolumeAttrib::make)((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(float volume)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioVolumeAttrib_make_1012_comment =
  "C++ Interface:\n"
  "make(float volume)\n"
  "\n"
  "/**\n"
  " * Constructs a new AudioVolumeAttrib object that indicates audio volume\n"
  " * should be scaled by the indicated factor.\n"
  " */";
#else
static const char *Dtool_AudioVolumeAttrib_make_1012_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > AudioVolumeAttrib::make_off(void)
 */
static PyObject *Dtool_AudioVolumeAttrib_make_off_1013(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > AudioVolumeAttrib::make_off(void)
  ConstPointerTo< RenderAttrib > return_value = (AudioVolumeAttrib::make_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AudioVolumeAttrib_make_off_1013_comment =
  "C++ Interface:\n"
  "make_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new AudioVolumeAttrib object that ignores any\n"
  " * AudioVolumeAttrib inherited from above.  You may also specify an additional\n"
  " * volume scale to apply to geometry below (using set_volume()).\n"
  " */";
#else
static const char *Dtool_AudioVolumeAttrib_make_off_1013_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > AudioVolumeAttrib::make_default(void)
 */
static PyObject *Dtool_AudioVolumeAttrib_make_default_1014(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > AudioVolumeAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (AudioVolumeAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AudioVolumeAttrib_make_default_1014_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_AudioVolumeAttrib_make_default_1014_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AudioVolumeAttrib::is_off(void) const
 */
static PyObject *Dtool_AudioVolumeAttrib_is_off_1015(PyObject *self, PyObject *) {
  AudioVolumeAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioVolumeAttrib)) {
    return nullptr;
  }
  // 1-inline bool AudioVolumeAttrib::is_off(void) const
  bool return_value = ((*(const AudioVolumeAttrib*)local_this).is_off)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioVolumeAttrib_is_off_1015_comment =
  "C++ Interface:\n"
  "is_off(AudioVolumeAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if the AudioVolumeAttrib will ignore any color scales\n"
  " * inherited from above, false otherwise.  This is not the same thing as\n"
  " * !has_scale(); a AudioVolumeAttrib may have the \"off\" flag set and also have\n"
  " * another scale specified.\n"
  " */";
#else
static const char *Dtool_AudioVolumeAttrib_is_off_1015_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AudioVolumeAttrib::has_volume(void) const
 */
static PyObject *Dtool_AudioVolumeAttrib_has_volume_1016(PyObject *self, PyObject *) {
  AudioVolumeAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioVolumeAttrib)) {
    return nullptr;
  }
  // 1-inline bool AudioVolumeAttrib::has_volume(void) const
  bool return_value = ((*(const AudioVolumeAttrib*)local_this).has_volume)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioVolumeAttrib_has_volume_1016_comment =
  "C++ Interface:\n"
  "has_volume(AudioVolumeAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if the AudioVolumeAttrib has a non-identity volume, false\n"
  " * otherwise (in which case it might be an off attrib or an identity attrib).\n"
  " */";
#else
static const char *Dtool_AudioVolumeAttrib_has_volume_1016_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat AudioVolumeAttrib::get_volume(void) const
 */
static PyObject *Dtool_AudioVolumeAttrib_get_volume_1017(PyObject *self, PyObject *) {
  AudioVolumeAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioVolumeAttrib)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat AudioVolumeAttrib::get_volume(void) const
  PN_stdfloat return_value = ((*(const AudioVolumeAttrib*)local_this).get_volume)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioVolumeAttrib_get_volume_1017_comment =
  "C++ Interface:\n"
  "get_volume(AudioVolumeAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the volume to be applied to sounds.\n"
  " */";
#else
static const char *Dtool_AudioVolumeAttrib_get_volume_1017_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > AudioVolumeAttrib::set_volume(PN_stdfloat volume) const
 */
static PyObject *Dtool_AudioVolumeAttrib_set_volume_1018(PyObject *self, PyObject *arg) {
  AudioVolumeAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioVolumeAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > AudioVolumeAttrib::set_volume(PN_stdfloat volume) const
  if (PyNumber_Check(arg)) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const AudioVolumeAttrib*)local_this).set_volume)((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_volume(AudioVolumeAttrib self, float volume)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioVolumeAttrib_set_volume_1018_comment =
  "C++ Interface:\n"
  "set_volume(AudioVolumeAttrib self, float volume)\n"
  "\n"
  "/**\n"
  " * Returns a new AudioVolumeAttrib, just like this one, but with the volume\n"
  " * changed to the indicated value.\n"
  " */";
#else
static const char *Dtool_AudioVolumeAttrib_set_volume_1018_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int AudioVolumeAttrib::get_class_slot(void)
 */
static PyObject *Dtool_AudioVolumeAttrib_get_class_slot_1020(PyObject *, PyObject *) {
  // 1-static int AudioVolumeAttrib::get_class_slot(void)
  int return_value = (AudioVolumeAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioVolumeAttrib_get_class_slot_1020_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_AudioVolumeAttrib_get_class_slot_1020_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AudioVolumeAttrib::get_class_type(void)
 */
static PyObject *Dtool_AudioVolumeAttrib_get_class_type_1022(PyObject *, PyObject *) {
  // 1-static TypeHandle AudioVolumeAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AudioVolumeAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AudioVolumeAttrib_get_class_type_1022_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AudioVolumeAttrib_get_class_type_1022_comment = nullptr;
#endif

static PyObject *Dtool_AudioVolumeAttrib_volume_Getter(PyObject *self, void *) {
  const AudioVolumeAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioVolumeAttrib, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_volume()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat AudioVolumeAttrib::get_volume(void) const
  PN_stdfloat return_value = ((*(const AudioVolumeAttrib*)local_this).get_volume)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AudioVolumeAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int AudioVolumeAttrib::get_class_slot(void)
  int return_value = (AudioVolumeAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_AudioVolumeAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_AudioVolumeAttrib(PyObject *args, CPT(AudioVolumeAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_AudioVolumeAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > AudioVolumeAttrib::make(PN_stdfloat volume)
    if (PyNumber_Check(arg)) {
      ConstPointerTo< RenderAttrib > return_value = (AudioVolumeAttrib::make)((PN_stdfloat)PyFloat_AsDouble(arg));
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((AudioVolumeAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_AudioVolumeAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AudioVolumeAttrib) {
    printf("AudioVolumeAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AudioVolumeAttrib *local_this = (AudioVolumeAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AudioVolumeAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AudioVolumeAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AudioVolumeAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AudioVolumeAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (AudioVolumeAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AudioVolumeAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AudioVolumeAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AudioVolumeAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AuxBitplaneAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > AuxBitplaneAttrib::make(void)
 * static ConstPointerTo< RenderAttrib > AuxBitplaneAttrib::make(int outputs)
 */
static PyObject *Dtool_AuxBitplaneAttrib_make_1026(PyObject *, PyObject *args) {
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-static ConstPointerTo< RenderAttrib > AuxBitplaneAttrib::make(void)
      ConstPointerTo< RenderAttrib > return_value = (AuxBitplaneAttrib::make)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-static ConstPointerTo< RenderAttrib > AuxBitplaneAttrib::make(int outputs)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        ConstPointerTo< RenderAttrib > return_value = (AuxBitplaneAttrib::make)((int)arg_val);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderAttrib const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 0 or 1 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make()\n"
      "make(int outputs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AuxBitplaneAttrib_make_1026_comment =
  "C++ Interface:\n"
  "make()\n"
  "make(int outputs)\n"
  "\n"
  "/**\n"
  " * Constructs a default AuxBitplaneAttrib object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a specified AuxBitplaneAttrib object.\n"
  " */";
#else
static const char *Dtool_AuxBitplaneAttrib_make_1026_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > AuxBitplaneAttrib::make_default(void)
 */
static PyObject *Dtool_AuxBitplaneAttrib_make_default_1027(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > AuxBitplaneAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (AuxBitplaneAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AuxBitplaneAttrib_make_default_1027_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_AuxBitplaneAttrib_make_default_1027_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AuxBitplaneAttrib::get_outputs(void) const
 */
static PyObject *Dtool_AuxBitplaneAttrib_get_outputs_1028(PyObject *self, PyObject *) {
  AuxBitplaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AuxBitplaneAttrib)) {
    return nullptr;
  }
  // 1-inline int AuxBitplaneAttrib::get_outputs(void) const
  int return_value = ((*(const AuxBitplaneAttrib*)local_this).get_outputs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AuxBitplaneAttrib_get_outputs_1028_comment =
  "C++ Interface:\n"
  "get_outputs(AuxBitplaneAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the AuxBitplaneAttrib output bits.\n"
  " */";
#else
static const char *Dtool_AuxBitplaneAttrib_get_outputs_1028_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int AuxBitplaneAttrib::get_class_slot(void)
 */
static PyObject *Dtool_AuxBitplaneAttrib_get_class_slot_1030(PyObject *, PyObject *) {
  // 1-static int AuxBitplaneAttrib::get_class_slot(void)
  int return_value = (AuxBitplaneAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AuxBitplaneAttrib_get_class_slot_1030_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_AuxBitplaneAttrib_get_class_slot_1030_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AuxBitplaneAttrib::get_class_type(void)
 */
static PyObject *Dtool_AuxBitplaneAttrib_get_class_type_1032(PyObject *, PyObject *) {
  // 1-static TypeHandle AuxBitplaneAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AuxBitplaneAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AuxBitplaneAttrib_get_class_type_1032_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AuxBitplaneAttrib_get_class_type_1032_comment = nullptr;
#endif

static PyObject *Dtool_AuxBitplaneAttrib_outputs_Getter(PyObject *self, void *) {
  const AuxBitplaneAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AuxBitplaneAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int AuxBitplaneAttrib::get_outputs(void) const
  int return_value = ((*(const AuxBitplaneAttrib*)local_this).get_outputs)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AuxBitplaneAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int AuxBitplaneAttrib::get_class_slot(void)
  int return_value = (AuxBitplaneAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_AuxBitplaneAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_AuxBitplaneAttrib(PyObject *args, CPT(AuxBitplaneAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_AuxBitplaneAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > AuxBitplaneAttrib::make(int outputs)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (AuxBitplaneAttrib::make)((int)arg_val);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((AuxBitplaneAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_AuxBitplaneAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AuxBitplaneAttrib) {
    printf("AuxBitplaneAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AuxBitplaneAttrib *local_this = (AuxBitplaneAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AuxBitplaneAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AuxBitplaneAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AuxBitplaneAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AuxBitplaneAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (AuxBitplaneAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AuxBitplaneAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AuxBitplaneAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AuxBitplaneAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AuxSceneData
 */
/**
 * Python function wrapper for:
 * inline void AuxSceneData::set_duration(double duration)
 */
static PyObject *Dtool_AuxSceneData_set_duration_1036(PyObject *self, PyObject *arg) {
  AuxSceneData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AuxSceneData, (void **)&local_this, "AuxSceneData.set_duration")) {
    return nullptr;
  }
  // 1-inline void AuxSceneData::set_duration(double duration)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_duration)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_duration(const AuxSceneData self, double duration)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AuxSceneData_set_duration_1036_comment =
  "C++ Interface:\n"
  "set_duration(const AuxSceneData self, double duration)\n"
  "\n"
  "/**\n"
  " * Specifies the minimum length in time, in seconds, to keep this AuxSceneData\n"
  " * object around in the scene graph after the last time it was rendered.\n"
  " */";
#else
static const char *Dtool_AuxSceneData_set_duration_1036_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AuxSceneData::get_duration(void) const
 */
static PyObject *Dtool_AuxSceneData_get_duration_1037(PyObject *self, PyObject *) {
  AuxSceneData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AuxSceneData)) {
    return nullptr;
  }
  // 1-inline double AuxSceneData::get_duration(void) const
  double return_value = ((*(const AuxSceneData*)local_this).get_duration)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AuxSceneData_get_duration_1037_comment =
  "C++ Interface:\n"
  "get_duration(AuxSceneData self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum length in time, in seconds, to keep this AuxSceneData\n"
  " * object around in the scene graph after the last time it was rendered.\n"
  " */";
#else
static const char *Dtool_AuxSceneData_get_duration_1037_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AuxSceneData::set_last_render_time(double render_time)
 */
static PyObject *Dtool_AuxSceneData_set_last_render_time_1038(PyObject *self, PyObject *arg) {
  AuxSceneData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AuxSceneData, (void **)&local_this, "AuxSceneData.set_last_render_time")) {
    return nullptr;
  }
  // 1-inline void AuxSceneData::set_last_render_time(double render_time)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_last_render_time)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_last_render_time(const AuxSceneData self, double render_time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AuxSceneData_set_last_render_time_1038_comment =
  "C++ Interface:\n"
  "set_last_render_time(const AuxSceneData self, double render_time)\n"
  "\n"
  "/**\n"
  " * Should be called with the current frame_time each time the AuxSceneData is\n"
  " * used during traversal.\n"
  " */";
#else
static const char *Dtool_AuxSceneData_set_last_render_time_1038_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AuxSceneData::get_last_render_time(void) const
 */
static PyObject *Dtool_AuxSceneData_get_last_render_time_1039(PyObject *self, PyObject *) {
  AuxSceneData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AuxSceneData)) {
    return nullptr;
  }
  // 1-inline double AuxSceneData::get_last_render_time(void) const
  double return_value = ((*(const AuxSceneData*)local_this).get_last_render_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AuxSceneData_get_last_render_time_1039_comment =
  "C++ Interface:\n"
  "get_last_render_time(AuxSceneData self)\n"
  "\n"
  "/**\n"
  " * Returns the last time this object was used during traversal (according to\n"
  " * set_last_render_time()).\n"
  " */";
#else
static const char *Dtool_AuxSceneData_get_last_render_time_1039_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AuxSceneData::get_expiration_time(void) const
 */
static PyObject *Dtool_AuxSceneData_get_expiration_time_1040(PyObject *self, PyObject *) {
  AuxSceneData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AuxSceneData)) {
    return nullptr;
  }
  // 1-inline double AuxSceneData::get_expiration_time(void) const
  double return_value = ((*(const AuxSceneData*)local_this).get_expiration_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AuxSceneData_get_expiration_time_1040_comment =
  "C++ Interface:\n"
  "get_expiration_time(AuxSceneData self)\n"
  "\n"
  "/**\n"
  " * Returns the frame_time at which this AuxSceneData object is currently\n"
  " * scheduled to be removed from the scene graph.\n"
  " */";
#else
static const char *Dtool_AuxSceneData_get_expiration_time_1040_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AuxSceneData::output(std::ostream &out) const
 */
static PyObject *Dtool_AuxSceneData_output_1041(PyObject *self, PyObject *arg) {
  AuxSceneData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AuxSceneData)) {
    return nullptr;
  }
  // 1-virtual void AuxSceneData::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AuxSceneData.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AuxSceneData*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AuxSceneData self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AuxSceneData_output_1041_comment =
  "C++ Interface:\n"
  "output(AuxSceneData self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AuxSceneData_output_1041_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AuxSceneData::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_AuxSceneData_write_1042(PyObject *self, PyObject *args, PyObject *kwds) {
  AuxSceneData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AuxSceneData)) {
    return nullptr;
  }
  // 1-virtual void AuxSceneData::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "AuxSceneData.write", false, true);
    if (param1_this != nullptr) {
      ((*(const AuxSceneData*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AuxSceneData self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AuxSceneData_write_1042_comment =
  "C++ Interface:\n"
  "write(AuxSceneData self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AuxSceneData_write_1042_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AuxSceneData::get_class_type(void)
 */
static PyObject *Dtool_AuxSceneData_get_class_type_1043(PyObject *, PyObject *) {
  // 1-static TypeHandle AuxSceneData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AuxSceneData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AuxSceneData_get_class_type_1043_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AuxSceneData_get_class_type_1043_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AuxSceneData::AuxSceneData(AuxSceneData const &) = default
 */
static int Dtool_Init_AuxSceneData(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("AuxSceneData() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline AuxSceneData::AuxSceneData(AuxSceneData const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    AuxSceneData const *param0_this = (AuxSceneData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AuxSceneData, 0, "AuxSceneData.AuxSceneData", true, true);
    if (param0_this != nullptr) {
      AuxSceneData *return_value = new AuxSceneData(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AuxSceneData, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AuxSceneData(const AuxSceneData param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AuxSceneData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AuxSceneData) {
    printf("AuxSceneData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AuxSceneData *local_this = (AuxSceneData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AuxSceneData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AuxSceneData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AuxSceneData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AuxSceneData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AuxSceneData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AuxSceneData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BamFile
 */
/**
 * Python function wrapper for:
 * bool BamFile::open_read(Filename const &bam_filename, bool report_errors = true)
 * bool BamFile::open_read(std::istream &in, std::string const &bam_filename = "stream", bool report_errors = true)
 */
static PyObject *Dtool_BamFile_open_read_1050(PyObject *self, PyObject *args, PyObject *kwds) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.open_read")) {
    return nullptr;
  }
  {
    // -2 bool BamFile::open_read(std::istream &in, std::string const &bam_filename = "stream", bool report_errors = true)
    PyObject *param1;
    const char *param2_str = "stream";
    Py_ssize_t param2_len = 6;
    PyObject *param3 = Py_True;
    static const char *keyword_list[] = {"in", "bam_filename", "report_errors", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#O:open_read", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
      std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "BamFile.open_read", false, false);
      if (param1_this != nullptr) {
        bool return_value = ((*local_this).open_read)(*param1_this, std::string(param2_str, param2_len), (PyObject_IsTrue(param3) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool BamFile::open_read(std::istream &in, std::string const &bam_filename = "stream", bool report_errors = true)
  {
    // -2 bool BamFile::open_read(Filename const &bam_filename, bool report_errors = true)
    PyObject *param1;
    PyObject *param2 = Py_True;
    static const char *keyword_list[] = {"bam_filename", "report_errors", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_read", (char **)keyword_list, &param1, &param2)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
        bool return_value = ((*local_this).open_read)(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read(const BamFile self, istream in, str bam_filename, bool report_errors)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamFile_open_read_1050_comment =
  "C++ Interface:\n"
  "open_read(const BamFile self, istream in, str bam_filename, bool report_errors)\n"
  "\n"
  "/**\n"
  " * Attempts to open the indicated filename for reading.  Returns true if\n"
  " * successful, false on error.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Attempts to open the indicated stream for reading.  The filename is just\n"
  " * for information purposes only.  Returns true if successful, false on error.\n"
  " */";
#else
static const char *Dtool_BamFile_open_read_1050_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritable *BamFile::read_object(void)
 */
static PyObject *Dtool_BamFile_read_object_1051(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.read_object")) {
    return nullptr;
  }
  // 1-TypedWritable *BamFile::read_object(void)
  TypedWritable *return_value = ((*local_this).read_object)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    ReferenceCount *rc = return_value->as_reference_count();
    bool is_refcount = (rc != nullptr);
    if (is_refcount) {
      rc->ref();
    }
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, is_refcount, false, return_value->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BamFile_read_object_1051_comment =
  "C++ Interface:\n"
  "read_object(const BamFile self)\n"
  "\n"
  "/**\n"
  " * Reads and returns the next object from the Bam file, or NULL if the end of\n"
  " * the file has been reached, or if there is an error condition.  Use is_eof()\n"
  " * to differentiate these two cases.\n"
  " *\n"
  " * The pointers returned by this method will not be valid for use until\n"
  " * resolve() is subsequently called.\n"
  " */";
#else
static const char *Dtool_BamFile_read_object_1051_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamFile::is_eof(void) const
 */
static PyObject *Dtool_BamFile_is_eof_1052(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamFile)) {
    return nullptr;
  }
  // 1-bool BamFile::is_eof(void) const
  bool return_value = ((*(const BamFile*)local_this).is_eof)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_is_eof_1052_comment =
  "C++ Interface:\n"
  "is_eof(BamFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the reader has reached end-of-file, false otherwise.  This\n"
  " * call is only valid after a call to read_object().\n"
  " */";
#else
static const char *Dtool_BamFile_is_eof_1052_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamFile::resolve(void)
 */
static PyObject *Dtool_BamFile_resolve_1053(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.resolve")) {
    return nullptr;
  }
  // 1-bool BamFile::resolve(void)
  bool return_value = ((*local_this).resolve)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_resolve_1053_comment =
  "C++ Interface:\n"
  "resolve(const BamFile self)\n"
  "\n"
  "/**\n"
  " * This must be called after one or more objects have been read via calls to\n"
  " * read_object() in order to resolve all internal pointer references in the\n"
  " * objects read and make all the pointers valid.  It returns true if all\n"
  " * objects are successfully resolved, or false if some have not been (in which\n"
  " * case you must call resolve() again later).\n"
  " */";
#else
static const char *Dtool_BamFile_resolve_1053_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > BamFile::read_node(bool report_errors = true)
 */
static PyObject *Dtool_BamFile_read_node_1054(PyObject *self, PyObject *args, PyObject *kwds) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.read_node")) {
    return nullptr;
  }
  // 1-PointerTo< PandaNode > BamFile::read_node(bool report_errors = true)
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "report_errors")) {
    PointerTo< PandaNode > return_value = ((*local_this).read_node)((PyObject_IsTrue(param1) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    PandaNode *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_node(const BamFile self, bool report_errors)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamFile_read_node_1054_comment =
  "C++ Interface:\n"
  "read_node(const BamFile self, bool report_errors)\n"
  "\n"
  "/**\n"
  " * Although the bam file format is general enough to store a list of objects\n"
  " * of arbitrary type, bam files on disk usually contain just one object, a\n"
  " * PandaNode that is the root of a scene graph.  (Bam files that store other\n"
  " * kinds of things are usually given the extension \"boo\", for \"binary other\n"
  " * objects\", to differentiate them from the normal scene graph type file.)\n"
  " *\n"
  " * This is a convenience method for when you believe you are reading a scene\n"
  " * graph bam file.  It reads the one PandaNode and returns it.  It also calls\n"
  " * resolve() to fully resolve the object, since we expect this will be the\n"
  " * only object in the file.\n"
  " *\n"
  " * If the bam file contains something other than a PandaNode, an error is\n"
  " * printed and NULL is returned.\n"
  " */";
#else
static const char *Dtool_BamFile_read_node_1054_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamFile::open_write(Filename const &bam_filename, bool report_errors = true)
 * bool BamFile::open_write(std::ostream &out, std::string const &bam_filename = "stream", bool report_errors = true)
 */
static PyObject *Dtool_BamFile_open_write_1055(PyObject *self, PyObject *args, PyObject *kwds) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.open_write")) {
    return nullptr;
  }
  {
    // -2 bool BamFile::open_write(std::ostream &out, std::string const &bam_filename = "stream", bool report_errors = true)
    PyObject *param1;
    const char *param2_str = "stream";
    Py_ssize_t param2_len = 6;
    PyObject *param3 = Py_True;
    static const char *keyword_list[] = {"out", "bam_filename", "report_errors", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#O:open_write", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
      std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BamFile.open_write", false, false);
      if (param1_this != nullptr) {
        bool return_value = ((*local_this).open_write)(*param1_this, std::string(param2_str, param2_len), (PyObject_IsTrue(param3) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool BamFile::open_write(std::ostream &out, std::string const &bam_filename = "stream", bool report_errors = true)
  {
    // -2 bool BamFile::open_write(Filename const &bam_filename, bool report_errors = true)
    PyObject *param1;
    PyObject *param2 = Py_True;
    static const char *keyword_list[] = {"bam_filename", "report_errors", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_write", (char **)keyword_list, &param1, &param2)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
        bool return_value = ((*local_this).open_write)(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_write(const BamFile self, ostream out, str bam_filename, bool report_errors)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamFile_open_write_1055_comment =
  "C++ Interface:\n"
  "open_write(const BamFile self, ostream out, str bam_filename, bool report_errors)\n"
  "\n"
  "/**\n"
  " * Attempts to open the indicated file for writing.  If another file by the\n"
  " * same name already exists, it will be silently removed.  Returns true if\n"
  " * successful, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Attempts to open the indicated stream for writing.  The filename is just\n"
  " * for information purposes only.  Returns true if successful, false on error.\n"
  " */";
#else
static const char *Dtool_BamFile_open_write_1055_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamFile::write_object(TypedWritable const *object)
 */
static PyObject *Dtool_BamFile_write_object_1056(PyObject *self, PyObject *arg) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.write_object")) {
    return nullptr;
  }
  // 1-bool BamFile::write_object(TypedWritable const *object)
  TypedWritable const *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamFile.write_object", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).write_object)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_object(const BamFile self, const TypedWritable object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamFile_write_object_1056_comment =
  "C++ Interface:\n"
  "write_object(const BamFile self, const TypedWritable object)\n"
  "\n"
  "/**\n"
  " * Writes the indicated object to the Bam file.  Returns true if successful,\n"
  " * false on error.\n"
  " */";
#else
static const char *Dtool_BamFile_write_object_1056_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BamFile::close(void)
 */
static PyObject *Dtool_BamFile_close_1057(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.close")) {
    return nullptr;
  }
  // 1-void BamFile::close(void)
  ((*local_this).close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamFile_close_1057_comment =
  "C++ Interface:\n"
  "close(const BamFile self)\n"
  "\n"
  "/**\n"
  " * Closes the input or output stream.\n"
  " */";
#else
static const char *Dtool_BamFile_close_1057_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamFile::is_valid_read(void) const
 */
static PyObject *Dtool_BamFile_is_valid_read_1058(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamFile)) {
    return nullptr;
  }
  // 1-inline bool BamFile::is_valid_read(void) const
  bool return_value = ((*(const BamFile*)local_this).is_valid_read)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_is_valid_read_1058_comment =
  "C++ Interface:\n"
  "is_valid_read(BamFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Bam file is open and ready for reading with no errors\n"
  " * so far detected, or false otherwise.\n"
  " */";
#else
static const char *Dtool_BamFile_is_valid_read_1058_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamFile::is_valid_write(void) const
 */
static PyObject *Dtool_BamFile_is_valid_write_1059(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamFile)) {
    return nullptr;
  }
  // 1-inline bool BamFile::is_valid_write(void) const
  bool return_value = ((*(const BamFile*)local_this).is_valid_write)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_is_valid_write_1059_comment =
  "C++ Interface:\n"
  "is_valid_write(BamFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Bam file is open and ready for writing with no errors\n"
  " * so far detected, or false otherwise.\n"
  " */";
#else
static const char *Dtool_BamFile_is_valid_write_1059_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BamFile::get_file_major_ver(void)
 */
static PyObject *Dtool_BamFile_get_file_major_ver_1060(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.get_file_major_ver")) {
    return nullptr;
  }
  // 1-int BamFile::get_file_major_ver(void)
  int return_value = ((*local_this).get_file_major_ver)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_get_file_major_ver_1060_comment =
  "C++ Interface:\n"
  "get_file_major_ver(const BamFile self)\n"
  "\n"
  "/**\n"
  " * Returns the major version number of the file currently being read, or the\n"
  " * system current major version number if no file is currently open for\n"
  " * reading.\n"
  " */";
#else
static const char *Dtool_BamFile_get_file_major_ver_1060_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BamFile::get_file_minor_ver(void)
 */
static PyObject *Dtool_BamFile_get_file_minor_ver_1061(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.get_file_minor_ver")) {
    return nullptr;
  }
  // 1-int BamFile::get_file_minor_ver(void)
  int return_value = ((*local_this).get_file_minor_ver)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_get_file_minor_ver_1061_comment =
  "C++ Interface:\n"
  "get_file_minor_ver(const BamFile self)\n"
  "\n"
  "/**\n"
  " * Returns the minor version number of the file currently being read, or the\n"
  " * system current minor version number if no file is currently open for\n"
  " * reading.\n"
  " */";
#else
static const char *Dtool_BamFile_get_file_minor_ver_1061_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BamEnums::BamEndian BamFile::get_file_endian(void) const
 */
static PyObject *Dtool_BamFile_get_file_endian_1062(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamFile)) {
    return nullptr;
  }
  // 1-BamEnums::BamEndian BamFile::get_file_endian(void) const
  BamEnums::BamEndian return_value = ((*(const BamFile*)local_this).get_file_endian)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_get_file_endian_1062_comment =
  "C++ Interface:\n"
  "get_file_endian(BamFile self)\n"
  "\n"
  "/**\n"
  " * Returns the endian preference indicated by the Bam file currently being\n"
  " * read or written.\n"
  " */";
#else
static const char *Dtool_BamFile_get_file_endian_1062_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamFile::get_file_stdfloat_double(void) const
 */
static PyObject *Dtool_BamFile_get_file_stdfloat_double_1063(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamFile)) {
    return nullptr;
  }
  // 1-bool BamFile::get_file_stdfloat_double(void) const
  bool return_value = ((*(const BamFile*)local_this).get_file_stdfloat_double)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_get_file_stdfloat_double_1063_comment =
  "C++ Interface:\n"
  "get_file_stdfloat_double(BamFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the file stores all \"standard\" floats as 64-bit doubles, or\n"
  " * false if they are 32-bit floats.\n"
  " */";
#else
static const char *Dtool_BamFile_get_file_stdfloat_double_1063_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BamFile::get_current_major_ver(void)
 */
static PyObject *Dtool_BamFile_get_current_major_ver_1064(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.get_current_major_ver")) {
    return nullptr;
  }
  // 1-int BamFile::get_current_major_ver(void)
  int return_value = ((*local_this).get_current_major_ver)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_get_current_major_ver_1064_comment =
  "C++ Interface:\n"
  "get_current_major_ver(const BamFile self)\n"
  "\n"
  "/**\n"
  " * Returns the system current major version number.  This is the version\n"
  " * number that will be assigned to any generated Bam files.\n"
  " */";
#else
static const char *Dtool_BamFile_get_current_major_ver_1064_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BamFile::get_current_minor_ver(void)
 */
static PyObject *Dtool_BamFile_get_current_minor_ver_1065(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.get_current_minor_ver")) {
    return nullptr;
  }
  // 1-int BamFile::get_current_minor_ver(void)
  int return_value = ((*local_this).get_current_minor_ver)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_get_current_minor_ver_1065_comment =
  "C++ Interface:\n"
  "get_current_minor_ver(const BamFile self)\n"
  "\n"
  "/**\n"
  " * Returns the system current minor version number.  This is the version\n"
  " * number that will be assigned to any generated Bam files.\n"
  " */";
#else
static const char *Dtool_BamFile_get_current_minor_ver_1065_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BamReader *BamFile::get_reader(void)
 */
static PyObject *Dtool_BamFile_get_reader_1066(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.get_reader")) {
    return nullptr;
  }
  // 1-BamReader *BamFile::get_reader(void)
  BamReader *return_value = ((*local_this).get_reader)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BamReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_get_reader_1066_comment =
  "C++ Interface:\n"
  "get_reader(const BamFile self)\n"
  "\n"
  "/**\n"
  " * Returns the BamReader in charge of performing the read operations.  This\n"
  " * will return NULL unless open_read() was called.\n"
  " */";
#else
static const char *Dtool_BamFile_get_reader_1066_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BamWriter *BamFile::get_writer(void)
 */
static PyObject *Dtool_BamFile_get_writer_1067(PyObject *self, PyObject *) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.get_writer")) {
    return nullptr;
  }
  // 1-BamWriter *BamFile::get_writer(void)
  BamWriter *return_value = ((*local_this).get_writer)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BamWriter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_BamFile_get_writer_1067_comment =
  "C++ Interface:\n"
  "get_writer(const BamFile self)\n"
  "\n"
  "/**\n"
  " * Returns the BamWriter in charge of performing the write operations.  This\n"
  " * will return NULL unless open_write() was called.\n"
  " */";
#else
static const char *Dtool_BamFile_get_writer_1067_comment = nullptr;
#endif

static PyObject *Dtool_BamFile_file_endian_Getter(PyObject *self, void *) {
  const BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamFile, (void **)&local_this)) {
    return nullptr;
  }

  // 1-BamEnums::BamEndian BamFile::get_file_endian(void) const
  BamEnums::BamEndian return_value = ((*(const BamFile*)local_this).get_file_endian)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamFile_file_stdfloat_double_Getter(PyObject *self, void *) {
  const BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamFile, (void **)&local_this)) {
    return nullptr;
  }

  // 1-bool BamFile::get_file_stdfloat_double(void) const
  bool return_value = ((*(const BamFile*)local_this).get_file_stdfloat_double)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamFile_reader_Getter(PyObject *self, void *) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.reader")) {
    return nullptr;
  }

  // 1-BamReader *BamFile::get_reader(void)
  BamReader *return_value = ((*local_this).get_reader)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BamReader, false, false);
}

static PyObject *Dtool_BamFile_writer_Getter(PyObject *self, void *) {
  BamFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamFile, (void **)&local_this, "BamFile.writer")) {
    return nullptr;
  }

  // 1-BamWriter *BamFile::get_writer(void)
  BamWriter *return_value = ((*local_this).get_writer)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BamWriter, false, false);
}

/**
 * Python function wrapper for:
 * BamFile::BamFile(void)
 */
static int Dtool_Init_BamFile(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("BamFile() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BamFile() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-BamFile::BamFile(void)
  BamFile *return_value = new BamFile();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamFile, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BamFile()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BamFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BamFile) {
    printf("BamFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BamFile *local_this = (BamFile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BamFile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BamEnums) {
    return (BamEnums *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BamFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BamFile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BamEnums) {
    BamEnums* other_this = (BamEnums*)from_this;
    return (BamFile*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BillboardEffect
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > BillboardEffect::make(LVector3 const &up_vector, bool eye_relative, bool axial_rotate, PN_stdfloat offset, NodePath const &look_at, LPoint3 const &look_at_point, bool fixed_depth = false)
 */
static PyObject *Dtool_BillboardEffect_make_1078(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderEffect > BillboardEffect::make(LVector3 const &up_vector, bool eye_relative, bool axial_rotate, PN_stdfloat offset, NodePath const &look_at, LPoint3 const &look_at_point, bool fixed_depth = false)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  float param3;
  PyObject *param4;
  PyObject *param5;
  PyObject *param6 = Py_False;
  static const char *keyword_list[] = {"up_vector", "eye_relative", "axial_rotate", "offset", "look_at", "look_at_point", "fixed_depth", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOfOO|O:make", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
    LVector3f param0_local;
    LVector3 const *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "BillboardEffect.make", "LVector3f");
    }
    NodePath const *param4_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_NodePath, 4, "BillboardEffect.make", true, true);
    LPoint3f param5_local;
    LPoint3 const *param5_this = Dtool_Coerce_LPoint3f(param5, param5_local);
    if (!(param5_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "BillboardEffect.make", "LPoint3f");
    }
    if (param4_this != nullptr) {
      ConstPointerTo< RenderEffect > return_value = (BillboardEffect::make)(*param0_this, (PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (PN_stdfloat)param3, *param4_this, *param5_this, (PyObject_IsTrue(param6) != 0));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderEffect const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const LVector3f up_vector, bool eye_relative, bool axial_rotate, float offset, const NodePath look_at, const LPoint3f look_at_point, bool fixed_depth)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_make_1078_comment =
  "C++ Interface:\n"
  "make(const LVector3f up_vector, bool eye_relative, bool axial_rotate, float offset, const NodePath look_at, const LPoint3f look_at_point, bool fixed_depth)\n"
  "\n"
  "/**\n"
  " * Constructs a new BillboardEffect object with the indicated properties.\n"
  " */";
#else
static const char *Dtool_BillboardEffect_make_1078_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< RenderEffect > BillboardEffect::make_axis(void)
 */
static PyObject *Dtool_BillboardEffect_make_axis_1079(PyObject *, PyObject *) {
  // 1-static inline ConstPointerTo< RenderEffect > BillboardEffect::make_axis(void)
  ConstPointerTo< RenderEffect > return_value = (BillboardEffect::make_axis)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffect const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_make_axis_1079_comment =
  "C++ Interface:\n"
  "make_axis()\n"
  "\n"
  "/**\n"
  " * A convenience function to make a typical axis-rotating billboard.\n"
  " */";
#else
static const char *Dtool_BillboardEffect_make_axis_1079_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< RenderEffect > BillboardEffect::make_point_eye(void)
 */
static PyObject *Dtool_BillboardEffect_make_point_eye_1080(PyObject *, PyObject *) {
  // 1-static inline ConstPointerTo< RenderEffect > BillboardEffect::make_point_eye(void)
  ConstPointerTo< RenderEffect > return_value = (BillboardEffect::make_point_eye)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffect const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_make_point_eye_1080_comment =
  "C++ Interface:\n"
  "make_point_eye()\n"
  "\n"
  "/**\n"
  " * A convenience function to make a typical eye-relative point-rotating\n"
  " * billboard.\n"
  " */";
#else
static const char *Dtool_BillboardEffect_make_point_eye_1080_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< RenderEffect > BillboardEffect::make_point_world(void)
 */
static PyObject *Dtool_BillboardEffect_make_point_world_1081(PyObject *, PyObject *) {
  // 1-static inline ConstPointerTo< RenderEffect > BillboardEffect::make_point_world(void)
  ConstPointerTo< RenderEffect > return_value = (BillboardEffect::make_point_world)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffect const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_make_point_world_1081_comment =
  "C++ Interface:\n"
  "make_point_world()\n"
  "\n"
  "/**\n"
  " * A convenience function to make a typical world-relative point-rotating\n"
  " * billboard.\n"
  " */";
#else
static const char *Dtool_BillboardEffect_make_point_world_1081_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BillboardEffect::is_off(void) const
 */
static PyObject *Dtool_BillboardEffect_is_off_1082(PyObject *self, PyObject *) {
  BillboardEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BillboardEffect)) {
    return nullptr;
  }
  // 1-inline bool BillboardEffect::is_off(void) const
  bool return_value = ((*(const BillboardEffect*)local_this).is_off)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_is_off_1082_comment =
  "C++ Interface:\n"
  "is_off(BillboardEffect self)\n"
  "\n"
  "/**\n"
  " * Returns true if the BillboardEffect is an 'off' BillboardEffect, indicating\n"
  " * that it does not enable billboarding.  This kind of BillboardEffect isn't\n"
  " * particularly useful and isn't normally created or stored in the graph; it\n"
  " * might be implicitly discovered as the result of a\n"
  " * NodePath::get_rel_state().\n"
  " */";
#else
static const char *Dtool_BillboardEffect_is_off_1082_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &BillboardEffect::get_up_vector(void) const
 */
static PyObject *Dtool_BillboardEffect_get_up_vector_1083(PyObject *self, PyObject *) {
  BillboardEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BillboardEffect)) {
    return nullptr;
  }
  // 1-inline LVector3 const &BillboardEffect::get_up_vector(void) const
  LVector3 const *return_value = &(((*(const BillboardEffect*)local_this).get_up_vector)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_get_up_vector_1083_comment =
  "C++ Interface:\n"
  "get_up_vector(BillboardEffect self)\n"
  "\n"
  "/**\n"
  " * Returns the up vector in effect for this billboard.\n"
  " */";
#else
static const char *Dtool_BillboardEffect_get_up_vector_1083_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BillboardEffect::get_eye_relative(void) const
 */
static PyObject *Dtool_BillboardEffect_get_eye_relative_1084(PyObject *self, PyObject *) {
  BillboardEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BillboardEffect)) {
    return nullptr;
  }
  // 1-inline bool BillboardEffect::get_eye_relative(void) const
  bool return_value = ((*(const BillboardEffect*)local_this).get_eye_relative)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_get_eye_relative_1084_comment =
  "C++ Interface:\n"
  "get_eye_relative(BillboardEffect self)\n"
  "\n"
  "/**\n"
  " * Returns true if this billboard interprets the up vector relative to the\n"
  " * camera, or false if it is relative to the world.\n"
  " */";
#else
static const char *Dtool_BillboardEffect_get_eye_relative_1084_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BillboardEffect::get_axial_rotate(void) const
 */
static PyObject *Dtool_BillboardEffect_get_axial_rotate_1085(PyObject *self, PyObject *) {
  BillboardEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BillboardEffect)) {
    return nullptr;
  }
  // 1-inline bool BillboardEffect::get_axial_rotate(void) const
  bool return_value = ((*(const BillboardEffect*)local_this).get_axial_rotate)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_get_axial_rotate_1085_comment =
  "C++ Interface:\n"
  "get_axial_rotate(BillboardEffect self)\n"
  "\n"
  "/**\n"
  " * Returns true if this billboard rotates only around the axis of the up\n"
  " * vector, or false if it rotates freely in three dimensions.\n"
  " */";
#else
static const char *Dtool_BillboardEffect_get_axial_rotate_1085_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BillboardEffect::get_fixed_depth(void) const
 */
static PyObject *Dtool_BillboardEffect_get_fixed_depth_1086(PyObject *self, PyObject *) {
  BillboardEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BillboardEffect)) {
    return nullptr;
  }
  // 1-inline bool BillboardEffect::get_fixed_depth(void) const
  bool return_value = ((*(const BillboardEffect*)local_this).get_fixed_depth)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_get_fixed_depth_1086_comment =
  "C++ Interface:\n"
  "get_fixed_depth(BillboardEffect self)\n"
  "\n"
  "/**\n"
  " * Returns true if this billboard always appears at a fixed distance from the\n"
  " * camera.\n"
  " */";
#else
static const char *Dtool_BillboardEffect_get_fixed_depth_1086_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BillboardEffect::get_offset(void) const
 */
static PyObject *Dtool_BillboardEffect_get_offset_1087(PyObject *self, PyObject *) {
  BillboardEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BillboardEffect)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat BillboardEffect::get_offset(void) const
  PN_stdfloat return_value = ((*(const BillboardEffect*)local_this).get_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_get_offset_1087_comment =
  "C++ Interface:\n"
  "get_offset(BillboardEffect self)\n"
  "\n"
  "/**\n"
  " * Returns the distance toward the camera (or the look_at_point) the billboard\n"
  " * is moved towards, after rotating.  This can be used to ensure the billboard\n"
  " * is not obscured by nearby geometry.\n"
  " */";
#else
static const char *Dtool_BillboardEffect_get_offset_1087_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &BillboardEffect::get_look_at(void) const
 */
static PyObject *Dtool_BillboardEffect_get_look_at_1088(PyObject *self, PyObject *) {
  BillboardEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BillboardEffect)) {
    return nullptr;
  }
  // 1-inline NodePath const &BillboardEffect::get_look_at(void) const
  NodePath const *return_value = &(((*(const BillboardEffect*)local_this).get_look_at)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_get_look_at_1088_comment =
  "C++ Interface:\n"
  "get_look_at(BillboardEffect self)\n"
  "\n"
  "/**\n"
  " * Returns the node this billboard will rotate to look towards.  If this is\n"
  " * empty, it means the billboard will rotate towards the current camera node,\n"
  " * wherever that might be.\n"
  " */";
#else
static const char *Dtool_BillboardEffect_get_look_at_1088_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &BillboardEffect::get_look_at_point(void) const
 */
static PyObject *Dtool_BillboardEffect_get_look_at_point_1089(PyObject *self, PyObject *) {
  BillboardEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BillboardEffect)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &BillboardEffect::get_look_at_point(void) const
  LPoint3 const *return_value = &(((*(const BillboardEffect*)local_this).get_look_at_point)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_get_look_at_point_1089_comment =
  "C++ Interface:\n"
  "get_look_at_point(BillboardEffect self)\n"
  "\n"
  "/**\n"
  " * Returns the point, relative to the look_at node, towards which the\n"
  " * billboard will rotate.  Normally this is (0, 0, 0).\n"
  " */";
#else
static const char *Dtool_BillboardEffect_get_look_at_point_1089_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BillboardEffect::get_class_type(void)
 */
static PyObject *Dtool_BillboardEffect_get_class_type_1090(PyObject *, PyObject *) {
  // 1-static TypeHandle BillboardEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BillboardEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BillboardEffect_get_class_type_1090_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BillboardEffect_get_class_type_1090_comment = nullptr;
#endif

static int Dtool_Init_BillboardEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_BillboardEffect(PyObject *args, CPT(BillboardEffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BillboardEffect)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 6 && size <= 7) {
      // 1-static ConstPointerTo< RenderEffect > BillboardEffect::make(LVector3 const &up_vector, bool eye_relative, bool axial_rotate, PN_stdfloat offset, NodePath const &look_at, LPoint3 const &look_at_point, bool fixed_depth = false)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      float param3;
      PyObject *param4;
      PyObject *param5;
      PyObject *param6 = Py_False;
      if (PyArg_ParseTuple(args, "OOOfOO|O:make", &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        LVector3 const *param0_this = nullptr;
        DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVector3f);
        NodePath const *param4_this = nullptr;
        DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_NodePath);
        LPoint3 const *param5_this = nullptr;
        DtoolInstance_GetPointer(param5, param5_this, *Dtool_Ptr_LPoint3f);
        if (param0_this != nullptr && param4_this != nullptr && param5_this != nullptr) {
          ConstPointerTo< RenderEffect > return_value = (BillboardEffect::make)(*param0_this, (PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (PN_stdfloat)param3, *param4_this, *param5_this, (PyObject_IsTrue(param6) != 0));
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move((BillboardEffect const *) return_value.p());
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_BillboardEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BillboardEffect) {
    printf("BillboardEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BillboardEffect *local_this = (BillboardEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BillboardEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BillboardEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BillboardEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BillboardEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (BillboardEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BillboardEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BillboardEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BillboardEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LensNode
 */
/**
 * Python function wrapper for:
 * inline void LensNode::copy_lens(Lens const &lens)
 * inline void LensNode::copy_lens(int index, Lens const &lens)
 */
static PyObject *Dtool_LensNode_copy_lens_1094(PyObject *self, PyObject *args, PyObject *kwds) {
  LensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LensNode, (void **)&local_this, "LensNode.copy_lens")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "lens")) {
        // 1-inline void LensNode::copy_lens(Lens const &lens)
        Lens const *arg_this = (Lens *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Lens, 1, "LensNode.copy_lens", true, true);
        if (arg_this != nullptr) {
          ((*local_this).copy_lens)(*arg_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline void LensNode::copy_lens(int index, Lens const &lens)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"index", "lens", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:copy_lens", (char **)keyword_list, &param1, &param2)) {
        Lens const *param2_this = (Lens *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Lens, 2, "LensNode.copy_lens", true, true);
        if (param2_this != nullptr) {
          ((*local_this).copy_lens)((int)param1, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "copy_lens() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_lens(const LensNode self, const Lens lens)\n"
      "copy_lens(const LensNode self, int index, const Lens lens)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LensNode_copy_lens_1094_comment =
  "C++ Interface:\n"
  "copy_lens(const LensNode self, const Lens lens)\n"
  "copy_lens(const LensNode self, int index, const Lens lens)\n"
  "\n"
  "/**\n"
  " * Sets up the LensNode using a copy of the indicated Lens.  If the original\n"
  " * Lens is changed or destroyed, this LensNode is not affected.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies the indicated lens into the specified slot.\n"
  " */";
#else
static const char *Dtool_LensNode_copy_lens_1094_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LensNode::set_lens(Lens *lens)
 * void LensNode::set_lens(int index, Lens *lens)
 */
static PyObject *Dtool_LensNode_set_lens_1095(PyObject *self, PyObject *args, PyObject *kwds) {
  LensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LensNode, (void **)&local_this, "LensNode.set_lens")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "lens")) {
        // 1-inline void LensNode::set_lens(Lens *lens)
        Lens *arg_this = (Lens *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Lens, 1, "LensNode.set_lens", false, true);
        if (arg_this != nullptr) {
          ((*local_this).set_lens)(arg_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void LensNode::set_lens(int index, Lens *lens)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"index", "lens", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_lens", (char **)keyword_list, &param1, &param2)) {
        Lens *param2_this = (Lens *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Lens, 2, "LensNode.set_lens", false, true);
        if (param2_this != nullptr) {
          ((*local_this).set_lens)((int)param1, param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_lens() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lens(const LensNode self, Lens lens)\n"
      "set_lens(const LensNode self, int index, Lens lens)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LensNode_set_lens_1095_comment =
  "C++ Interface:\n"
  "set_lens(const LensNode self, Lens lens)\n"
  "set_lens(const LensNode self, int index, Lens lens)\n"
  "\n"
  "/**\n"
  " * Sets up the LensNode using this particular Lens pointer.  If the lens is\n"
  " * subsequently modified, the LensNode properties immediately reflect the\n"
  " * change.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the indicated lens.  Although a LensNode normally holds only one lens,\n"
  " * it may optionally include multiple lenses, each with a different index\n"
  " * number.  The different lenses may be referenced by index number on the\n"
  " * DisplayRegion.  Adding a new lens automatically makes it active.\n"
  " */";
#else
static const char *Dtool_LensNode_set_lens_1095_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Lens *LensNode::get_lens(int index = 0) const
 */
static PyObject *Dtool_LensNode_get_lens_1096(PyObject *self, PyObject *args, PyObject *kwds) {
  LensNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LensNode)) {
    return nullptr;
  }
  // 1-inline Lens *LensNode::get_lens(int index = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"index", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_lens", (char **)keyword_list, &param1)) {
    Lens *return_value = ((*(const LensNode*)local_this).get_lens)((int)param1);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Lens, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_lens(LensNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LensNode_get_lens_1096_comment =
  "C++ Interface:\n"
  "get_lens(LensNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the particular Lens associated with this LensNode, or\n"
  " * NULL if there is not yet a Lens associated.  If an index number is\n"
  " * specified, returns the nth lens.\n"
  " */";
#else
static const char *Dtool_LensNode_get_lens_1096_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool LensNode::set_lens_active(int index, bool active)
 */
static PyObject *Dtool_LensNode_set_lens_active_1097(PyObject *self, PyObject *args, PyObject *kwds) {
  LensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LensNode, (void **)&local_this, "LensNode.set_lens_active")) {
    return nullptr;
  }
  // 1-bool LensNode::set_lens_active(int index, bool active)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "active", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_lens_active", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*local_this).set_lens_active)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lens_active(const LensNode self, int index, bool active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LensNode_set_lens_active_1097_comment =
  "C++ Interface:\n"
  "set_lens_active(const LensNode self, int index, bool active)\n"
  "\n"
  "/**\n"
  " * Sets the active flag for the nth lens.  When a lens is inactive, it is not\n"
  " * used for rendering, and any DisplayRegions associated with it are\n"
  " * implicitly inactive as well.  Returns true if the flag is changed, false if\n"
  " * it already had this value.\n"
  " */";
#else
static const char *Dtool_LensNode_set_lens_active_1097_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LensNode::get_lens_active(int index) const
 */
static PyObject *Dtool_LensNode_get_lens_active_1098(PyObject *self, PyObject *arg) {
  LensNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LensNode)) {
    return nullptr;
  }
  // 1-inline bool LensNode::get_lens_active(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const LensNode*)local_this).get_lens_active)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_lens_active(LensNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LensNode_get_lens_active_1098_comment =
  "C++ Interface:\n"
  "get_lens_active(LensNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the active flag for the nth lens.\n"
  " */";
#else
static const char *Dtool_LensNode_get_lens_active_1098_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LensNode::activate_lens(int index)
 */
static PyObject *Dtool_LensNode_activate_lens_1099(PyObject *self, PyObject *arg) {
  LensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LensNode, (void **)&local_this, "LensNode.activate_lens")) {
    return nullptr;
  }
  // 1-inline bool LensNode::activate_lens(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).activate_lens)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "activate_lens(const LensNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LensNode_activate_lens_1099_comment =
  "C++ Interface:\n"
  "activate_lens(const LensNode self, int index)\n"
  "\n"
  "/**\n"
  " * An alternate way to call set_lens_active(index, true).\n"
  " */";
#else
static const char *Dtool_LensNode_activate_lens_1099_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LensNode::deactivate_lens(int index)
 */
static PyObject *Dtool_LensNode_deactivate_lens_1100(PyObject *self, PyObject *arg) {
  LensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LensNode, (void **)&local_this, "LensNode.deactivate_lens")) {
    return nullptr;
  }
  // 1-inline bool LensNode::deactivate_lens(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).deactivate_lens)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "deactivate_lens(const LensNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LensNode_deactivate_lens_1100_comment =
  "C++ Interface:\n"
  "deactivate_lens(const LensNode self, int index)\n"
  "\n"
  "/**\n"
  " * An alternate way to call set_lens_active(index, false).\n"
  " */";
#else
static const char *Dtool_LensNode_deactivate_lens_1100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LensNode::is_in_view(LPoint3 const &pos)
 * bool LensNode::is_in_view(int index, LPoint3 const &pos)
 */
static PyObject *Dtool_LensNode_is_in_view_1101(PyObject *self, PyObject *args, PyObject *kwds) {
  LensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LensNode, (void **)&local_this, "LensNode.is_in_view")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline bool LensNode::is_in_view(LPoint3 const &pos)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "LensNode.is_in_view", "LPoint3f");
        }
        bool return_value = ((*local_this).is_in_view)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-bool LensNode::is_in_view(int index, LPoint3 const &pos)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"index", "pos", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:is_in_view", (char **)keyword_list, &param1, &param2)) {
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "LensNode.is_in_view", "LPoint3f");
        }
        bool return_value = ((*local_this).is_in_view)((int)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "is_in_view() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_in_view(const LensNode self, const LPoint3f pos)\n"
      "is_in_view(const LensNode self, int index, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LensNode_is_in_view_1101_comment =
  "C++ Interface:\n"
  "is_in_view(const LensNode self, const LPoint3f pos)\n"
  "is_in_view(const LensNode self, int index, const LPoint3f pos)\n"
  "\n"
  "/**\n"
  " * Returns true if the given point is within the bounds of the lens of the\n"
  " * LensNode (i.e.  if the camera can see the point).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the given point is within the bounds of the lens of the\n"
  " * LensNode (i.e.  if the camera can see the point).\n"
  " */";
#else
static const char *Dtool_LensNode_is_in_view_1101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LensNode::show_frustum(void)
 */
static PyObject *Dtool_LensNode_show_frustum_1102(PyObject *self, PyObject *) {
  LensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LensNode, (void **)&local_this, "LensNode.show_frustum")) {
    return nullptr;
  }
  // 1-void LensNode::show_frustum(void)
  ((*local_this).show_frustum)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LensNode_show_frustum_1102_comment =
  "C++ Interface:\n"
  "show_frustum(const LensNode self)\n"
  "\n"
  "/**\n"
  " * Enables the drawing of the lens's frustum to aid in visualization.  This\n"
  " * actually creates a GeomNode which is parented to the LensNode.\n"
  " */";
#else
static const char *Dtool_LensNode_show_frustum_1102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LensNode::hide_frustum(void)
 */
static PyObject *Dtool_LensNode_hide_frustum_1103(PyObject *self, PyObject *) {
  LensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LensNode, (void **)&local_this, "LensNode.hide_frustum")) {
    return nullptr;
  }
  // 1-void LensNode::hide_frustum(void)
  ((*local_this).hide_frustum)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LensNode_hide_frustum_1103_comment =
  "C++ Interface:\n"
  "hide_frustum(const LensNode self)\n"
  "\n"
  "/**\n"
  " * Disables the drawing of the lens's frustum to aid in visualization.\n"
  " */";
#else
static const char *Dtool_LensNode_hide_frustum_1103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LensNode::get_class_type(void)
 */
static PyObject *Dtool_LensNode_get_class_type_1104(PyObject *, PyObject *) {
  // 1-static TypeHandle LensNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LensNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LensNode_get_class_type_1104_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LensNode_get_class_type_1104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit LensNode::LensNode(std::string const &name, Lens *lens = nullptr)
 */
static int Dtool_Init_LensNode(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit LensNode::LensNode(std::string const &name, Lens *lens = nullptr)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"name", "lens", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:LensNode", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    Lens *param1_this = nullptr;
    if (param1 != nullptr && param1 != Py_None) {
      param1_this = (Lens *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Lens, 1, "LensNode.LensNode", false, true);
    }
    if ((param1 == nullptr || param1 == Py_None || param1_this != nullptr)) {
      LensNode *return_value = new LensNode(std::string(param0_str, param0_len), param1_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LensNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LensNode(str name, Lens lens)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LensNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LensNode) {
    printf("LensNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LensNode *local_this = (LensNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LensNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LensNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (LensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (LensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LensNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class WeakNodePath
 */
/**
 * Python function wrapper for:
 * inline void WeakNodePath::operator =(NodePath const &node_path)
 * inline void WeakNodePath::operator =(WeakNodePath const &copy)
 */
static PyObject *Dtool_WeakNodePath_operator_1109(PyObject *self, PyObject *arg) {
  WeakNodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WeakNodePath, (void **)&local_this, "WeakNodePath.assign")) {
    return nullptr;
  }
  {
    // -2 inline void WeakNodePath::operator =(NodePath const &node_path)
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      ((*local_this).operator =)(*arg_this);
      WeakNodePath *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WeakNodePath, false, false);
    }
  }

  {
    // -2 inline void WeakNodePath::operator =(WeakNodePath const &copy)
    WeakNodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_WeakNodePath);
    if (arg_this != nullptr) {
      ((*local_this).operator =)(*arg_this);
      WeakNodePath *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WeakNodePath, false, false);
    }
  }

  // No coercion possible: inline void WeakNodePath::operator =(NodePath const &node_path)
  // No coercion possible: inline void WeakNodePath::operator =(WeakNodePath const &copy)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const WeakNodePath self, const NodePath node_path)\n"
      "assign(const WeakNodePath self, const WeakNodePath copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WeakNodePath_operator_1109_comment =
  "C++ Interface:\n"
  "assign(const WeakNodePath self, const NodePath node_path)\n"
  "assign(const WeakNodePath self, const WeakNodePath copy)\n";
#else
static const char *Dtool_WeakNodePath_operator_1109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WeakNodePath::clear(void)
 */
static PyObject *Dtool_WeakNodePath_clear_1110(PyObject *self, PyObject *) {
  WeakNodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WeakNodePath, (void **)&local_this, "WeakNodePath.clear")) {
    return nullptr;
  }
  // 1-inline void WeakNodePath::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WeakNodePath_clear_1110_comment =
  "C++ Interface:\n"
  "clear(const WeakNodePath self)\n"
  "\n"
  "/**\n"
  " * Sets this NodePath to the empty NodePath.  It will no longer point to any\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_WeakNodePath_clear_1110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WeakNodePath::is_empty(void) const
 */
static PyObject *Dtool_WeakNodePath_is_empty_1112(PyObject *self, PyObject *) {
  WeakNodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WeakNodePath)) {
    return nullptr;
  }
  // 1-inline bool WeakNodePath::is_empty(void) const
  bool return_value = ((*(const WeakNodePath*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WeakNodePath_is_empty_1112_comment =
  "C++ Interface:\n"
  "is_empty(WeakNodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if the NodePath contains no nodes, or if it has been deleted.\n"
  " */";
#else
static const char *Dtool_WeakNodePath_is_empty_1112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WeakNodePath::was_deleted(void) const
 */
static PyObject *Dtool_WeakNodePath_was_deleted_1113(PyObject *self, PyObject *) {
  WeakNodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WeakNodePath)) {
    return nullptr;
  }
  // 1-inline bool WeakNodePath::was_deleted(void) const
  bool return_value = ((*(const WeakNodePath*)local_this).was_deleted)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WeakNodePath_was_deleted_1113_comment =
  "C++ Interface:\n"
  "was_deleted(WeakNodePath self)\n"
  "\n"
  "/**\n"
  " * Returns true if the NodePath we were referencing has been quietly deleted\n"
  " * outside of the WeakNodePath.\n"
  " */";
#else
static const char *Dtool_WeakNodePath_was_deleted_1113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath WeakNodePath::get_node_path(void) const
 */
static PyObject *Dtool_WeakNodePath_get_node_path_1114(PyObject *self, PyObject *) {
  WeakNodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WeakNodePath)) {
    return nullptr;
  }
  // 1-inline NodePath WeakNodePath::get_node_path(void) const
  NodePath *return_value = new NodePath(((*(const WeakNodePath*)local_this).get_node_path)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WeakNodePath_get_node_path_1114_comment =
  "C++ Interface:\n"
  "get_node_path(WeakNodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath held within this object, or an empty NodePath with the\n"
  " * error flag set if the object was deleted.\n"
  " */";
#else
static const char *Dtool_WeakNodePath_get_node_path_1114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< PandaNode > WeakNodePath::node(void) const
 */
static PyObject *Dtool_WeakNodePath_node_1115(PyObject *self, PyObject *) {
  WeakNodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WeakNodePath)) {
    return nullptr;
  }
  // 1-inline PointerTo< PandaNode > WeakNodePath::node(void) const
  PointerTo< PandaNode > return_value = ((*(const WeakNodePath*)local_this).node)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  PandaNode *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_WeakNodePath_node_1115_comment =
  "C++ Interface:\n"
  "node(WeakNodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the PandaNode held within this object, or nullptr if the object was\n"
  " * deleted.\n"
  " */";
#else
static const char *Dtool_WeakNodePath_node_1115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int WeakNodePath::compare_to(NodePath const &other) const
 * inline int WeakNodePath::compare_to(WeakNodePath const &other) const
 */
static PyObject *Dtool_WeakNodePath_compare_to_1119(PyObject *self, PyObject *arg) {
  WeakNodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WeakNodePath)) {
    return nullptr;
  }
  {
    // -2 inline int WeakNodePath::compare_to(NodePath const &other) const
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      int return_value = ((*(const WeakNodePath*)local_this).compare_to)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline int WeakNodePath::compare_to(WeakNodePath const &other) const
    WeakNodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_WeakNodePath);
    if (arg_this != nullptr) {
      int return_value = ((*(const WeakNodePath*)local_this).compare_to)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline int WeakNodePath::compare_to(NodePath const &other) const
  // No coercion possible: inline int WeakNodePath::compare_to(WeakNodePath const &other) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(WeakNodePath self, const NodePath other)\n"
      "compare_to(WeakNodePath self, const WeakNodePath other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WeakNodePath_compare_to_1119_comment =
  "C++ Interface:\n"
  "compare_to(WeakNodePath self, const NodePath other)\n"
  "compare_to(WeakNodePath self, const WeakNodePath other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this NodePath sorts before the other\n"
  " * one, greater than zero if it sorts after, or zero if they are equivalent.\n"
  " *\n"
  " * Two NodePaths are considered equivalent if they consist of exactly the same\n"
  " * list of nodes in the same order.  Otherwise, they are different; different\n"
  " * NodePaths will be ranked in a consistent but undefined ordering; the\n"
  " * ordering is useful only for placing the NodePaths in a sorted container\n"
  " * like an STL set.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this WeakNodePath sorts before the other\n"
  " * one, greater than zero if it sorts after, or zero if they are equivalent.\n"
  " *\n"
  " * Two WeakNodePaths are considered equivalent if they consist of exactly the\n"
  " * same list of nodes in the same order.  Otherwise, they are different;\n"
  " * different WeakNodePaths will be ranked in a consistent but undefined\n"
  " * ordering; the ordering is useful only for placing the WeakNodePaths in a\n"
  " * sorted container like an STL set.\n"
  " */";
#else
static const char *Dtool_WeakNodePath_compare_to_1119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int WeakNodePath::get_key(void) const
 */
static PyObject *Dtool_WeakNodePath_get_key_1120(PyObject *self, PyObject *) {
  WeakNodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WeakNodePath)) {
    return nullptr;
  }
  // 1-inline int WeakNodePath::get_key(void) const
  int return_value = ((*(const WeakNodePath*)local_this).get_key)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WeakNodePath_get_key_1120_comment =
  "C++ Interface:\n"
  "get_key(WeakNodePath self)\n"
  "\n"
  "/**\n"
  " * Returns the same values as NodePath::get_key().\n"
  " */";
#else
static const char *Dtool_WeakNodePath_get_key_1120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void WeakNodePath::output(std::ostream &out) const
 */
static PyObject *Dtool_WeakNodePath_output_1121(PyObject *self, PyObject *arg) {
  WeakNodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WeakNodePath)) {
    return nullptr;
  }
  // 1-void WeakNodePath::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "WeakNodePath.output", false, true);
  if (arg_this != nullptr) {
    ((*(const WeakNodePath*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(WeakNodePath self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WeakNodePath_output_1121_comment =
  "C++ Interface:\n"
  "output(WeakNodePath self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_WeakNodePath_output_1121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline WeakNodePath::WeakNodePath(NodePath const &node_path)
 * inline WeakNodePath::WeakNodePath(WeakNodePath const &copy)
 */
static int Dtool_Init_WeakNodePath(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "WeakNodePath() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline WeakNodePath::WeakNodePath(NodePath const &node_path)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "node_path")) {
      NodePath const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NodePath);
      if (param0_this != nullptr) {
        WeakNodePath *return_value = new WeakNodePath(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WeakNodePath, true, false);
      }
    }
  }

  {
    // -2 inline WeakNodePath::WeakNodePath(WeakNodePath const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      WeakNodePath const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_WeakNodePath);
      if (param0_this != nullptr) {
        WeakNodePath *return_value = new WeakNodePath(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WeakNodePath, true, false);
      }
    }
  }

  // No coercion possible: inline WeakNodePath::WeakNodePath(NodePath const &node_path)
  // No coercion possible: inline WeakNodePath::WeakNodePath(WeakNodePath const &copy)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "WeakNodePath(const NodePath node_path)\n"
      "WeakNodePath(const WeakNodePath copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_WeakNodePath(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_WeakNodePath) {
    printf("WeakNodePath ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  WeakNodePath *local_this = (WeakNodePath *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_WeakNodePath) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_WeakNodePath(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_WeakNodePath) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Camera
 */
/**
 * Python function wrapper for:
 * inline void Camera::set_active(bool active)
 */
static PyObject *Dtool_Camera_set_active_1124(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.set_active")) {
    return nullptr;
  }
  // 1-inline void Camera::set_active(bool active)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const Camera self, bool active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_set_active_1124_comment =
  "C++ Interface:\n"
  "set_active(const Camera self, bool active)\n"
  "\n"
  "/**\n"
  " * Sets the active flag on the camera.  When the camera is not active, nothing\n"
  " * will be rendered.\n"
  " */";
#else
static const char *Dtool_Camera_set_active_1124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Camera::is_active(void) const
 */
static PyObject *Dtool_Camera_is_active_1125(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-inline bool Camera::is_active(void) const
  bool return_value = ((*(const Camera*)local_this).is_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Camera_is_active_1125_comment =
  "C++ Interface:\n"
  "is_active(Camera self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the active flag on the camera.\n"
  " */";
#else
static const char *Dtool_Camera_is_active_1125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Camera::set_scene(NodePath const &scene)
 */
static PyObject *Dtool_Camera_set_scene_1127(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.set_scene")) {
    return nullptr;
  }
  // 1-inline void Camera::set_scene(NodePath const &scene)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.set_scene", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_scene)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scene(const Camera self, const NodePath scene)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_set_scene_1127_comment =
  "C++ Interface:\n"
  "set_scene(const Camera self, const NodePath scene)\n"
  "\n"
  "/**\n"
  " * Sets the scene that will be rendered by the camera.  This is normally the\n"
  " * root node of a scene graph, typically a node called 'render', although it\n"
  " * could represent the root of any subgraph.\n"
  " *\n"
  " * Note that the use of this method is now deprecated.  In the absence of an\n"
  " * explicit scene set on the camera, the camera will render whatever scene it\n"
  " * is parented into.  This is the preferred way to specify the scene, since it\n"
  " * is the more intuitive mechanism.\n"
  " */";
#else
static const char *Dtool_Camera_set_scene_1127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &Camera::get_scene(void) const
 */
static PyObject *Dtool_Camera_get_scene_1128(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-inline NodePath const &Camera::get_scene(void) const
  NodePath const *return_value = &(((*(const Camera*)local_this).get_scene)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_scene_1128_comment =
  "C++ Interface:\n"
  "get_scene(Camera self)\n"
  "\n"
  "/**\n"
  " * Returns the scene that will be rendered by the camera.  See set_scene().\n"
  " */";
#else
static const char *Dtool_Camera_get_scene_1128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Camera::get_num_display_regions(void) const
 */
static PyObject *Dtool_Camera_get_num_display_regions_1131(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-inline std::size_t Camera::get_num_display_regions(void) const
  std::size_t return_value = ((*(const Camera*)local_this).get_num_display_regions)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_num_display_regions_1131_comment =
  "C++ Interface:\n"
  "get_num_display_regions(Camera self)\n"
  "\n"
  "/**\n"
  " * Returns the number of display regions associated with the camera.\n"
  " */";
#else
static const char *Dtool_Camera_get_num_display_regions_1131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DisplayRegion *Camera::get_display_region(std::size_t n) const
 */
static PyObject *Dtool_Camera_get_display_region_1132(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-inline DisplayRegion *Camera::get_display_region(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    DisplayRegion *return_value = ((*(const Camera*)local_this).get_display_region)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DisplayRegion, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_display_region(Camera self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_display_region_1132_comment =
  "C++ Interface:\n"
  "get_display_region(Camera self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth display region associated with the camera.\n"
  " */";
#else
static const char *Dtool_Camera_get_display_region_1132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Camera::set_camera_mask(DrawMask mask)
 */
static PyObject *Dtool_Camera_set_camera_mask_1137(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.set_camera_mask")) {
    return nullptr;
  }
  // 1-inline void Camera::set_camera_mask(DrawMask mask)
  BitMask< uint32_t, 32 > arg_local;
  DrawMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Camera.set_camera_mask", "BitMask");
  }
  ((*local_this).set_camera_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera_mask(const Camera self, BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_set_camera_mask_1137_comment =
  "C++ Interface:\n"
  "set_camera_mask(const Camera self, BitMask mask)\n"
  "\n"
  "/**\n"
  " * Changes the set of bits that represent the subset of the scene graph the\n"
  " * camera will render.\n"
  " *\n"
  " * During the cull traversal, a node is not visited if none of its draw mask\n"
  " * bits intersect with the camera's camera mask bits.  These masks can be used\n"
  " * to selectively hide and show different parts of the scene graph from\n"
  " * different cameras that are otherwise viewing the same scene.\n"
  " */";
#else
static const char *Dtool_Camera_set_camera_mask_1137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DrawMask Camera::get_camera_mask(void) const
 */
static PyObject *Dtool_Camera_get_camera_mask_1138(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-inline DrawMask Camera::get_camera_mask(void) const
  DrawMask *return_value = new DrawMask(((*(const Camera*)local_this).get_camera_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_camera_mask_1138_comment =
  "C++ Interface:\n"
  "get_camera_mask(Camera self)\n"
  "\n"
  "/**\n"
  " * Returns the set of bits that represent the subset of the scene graph the\n"
  " * camera will render.  See set_camera_mask().\n"
  " */";
#else
static const char *Dtool_Camera_get_camera_mask_1138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Camera::set_cull_center(NodePath const &cull_center)
 */
static PyObject *Dtool_Camera_set_cull_center_1140(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.set_cull_center")) {
    return nullptr;
  }
  // 1-inline void Camera::set_cull_center(NodePath const &cull_center)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.set_cull_center", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cull_center)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cull_center(const Camera self, const NodePath cull_center)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_set_cull_center_1140_comment =
  "C++ Interface:\n"
  "set_cull_center(const Camera self, const NodePath cull_center)\n"
  "\n"
  "/**\n"
  " * Specifies the point from which the culling operations are performed.\n"
  " * Normally, this is the same as the camera, and that is the default if this\n"
  " * is not specified; but it may sometimes be useful to perform the culling\n"
  " * from some other viewpoint, particularly when you are debugging the culling\n"
  " * itself.\n"
  " */";
#else
static const char *Dtool_Camera_set_cull_center_1140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &Camera::get_cull_center(void) const
 */
static PyObject *Dtool_Camera_get_cull_center_1141(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-inline NodePath const &Camera::get_cull_center(void) const
  NodePath const *return_value = &(((*(const Camera*)local_this).get_cull_center)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_cull_center_1141_comment =
  "C++ Interface:\n"
  "get_cull_center(Camera self)\n"
  "\n"
  "/**\n"
  " * Returns the point from which the culling operations will be performed, if\n"
  " * it was set by set_cull_center(), or the empty NodePath otherwise.\n"
  " */";
#else
static const char *Dtool_Camera_get_cull_center_1141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Camera::set_cull_bounds(BoundingVolume *cull_bounds)
 */
static PyObject *Dtool_Camera_set_cull_bounds_1143(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.set_cull_bounds")) {
    return nullptr;
  }
  // 1-inline void Camera::set_cull_bounds(BoundingVolume *cull_bounds)
  BoundingVolume *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "Camera.set_cull_bounds", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cull_bounds)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cull_bounds(const Camera self, BoundingVolume cull_bounds)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_set_cull_bounds_1143_comment =
  "C++ Interface:\n"
  "set_cull_bounds(const Camera self, BoundingVolume cull_bounds)\n"
  "\n"
  "/**\n"
  " * Specifies the bounding volume that should be used to perform culling from\n"
  " * this camera.  Normally, this is the bounding volume returned from the\n"
  " * active lens' make_bounds() call, but you may override this to specify a\n"
  " * custom volume if you require.  The specified bounding volume will be\n"
  " * understood to be in the coordinate space of the get_cull_center() node.\n"
  " */";
#else
static const char *Dtool_Camera_set_cull_bounds_1143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BoundingVolume *Camera::get_cull_bounds(void) const
 */
static PyObject *Dtool_Camera_get_cull_bounds_1144(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-inline BoundingVolume *Camera::get_cull_bounds(void) const
  BoundingVolume *return_value = ((*(const Camera*)local_this).get_cull_bounds)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BoundingVolume, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_cull_bounds_1144_comment =
  "C++ Interface:\n"
  "get_cull_bounds(Camera self)\n"
  "\n"
  "/**\n"
  " * Returns the custom cull volume that was set by set_cull_bounds(), if any,\n"
  " * or NULL if no custom cull volume was set.\n"
  " */";
#else
static const char *Dtool_Camera_get_cull_bounds_1144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Camera::set_lod_center(NodePath const &lod_center)
 */
static PyObject *Dtool_Camera_set_lod_center_1147(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.set_lod_center")) {
    return nullptr;
  }
  // 1-inline void Camera::set_lod_center(NodePath const &lod_center)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.set_lod_center", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_lod_center)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod_center(const Camera self, const NodePath lod_center)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_set_lod_center_1147_comment =
  "C++ Interface:\n"
  "set_lod_center(const Camera self, const NodePath lod_center)\n"
  "\n"
  "/**\n"
  " * Specifies the point from which the LOD distances are measured.  Normally,\n"
  " * this is the same as the camera, and that is the default if this is not\n"
  " * specified; but it may sometimes be useful to perform the distance test from\n"
  " * some other viewpoint.  This may be used, for instance, to reduce LOD\n"
  " * popping when the camera rotates in a small circle about an avatar.\n"
  " */";
#else
static const char *Dtool_Camera_set_lod_center_1147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &Camera::get_lod_center(void) const
 */
static PyObject *Dtool_Camera_get_lod_center_1148(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-inline NodePath const &Camera::get_lod_center(void) const
  NodePath const *return_value = &(((*(const Camera*)local_this).get_lod_center)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_lod_center_1148_comment =
  "C++ Interface:\n"
  "get_lod_center(Camera self)\n"
  "\n"
  "/**\n"
  " * Returns the point from which the LOD distances will be measured, if it was\n"
  " * set by set_lod_center(), or the empty NodePath otherwise.\n"
  " */";
#else
static const char *Dtool_Camera_get_lod_center_1148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Camera::set_initial_state(RenderState const *state)
 */
static PyObject *Dtool_Camera_set_initial_state_1150(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.set_initial_state")) {
    return nullptr;
  }
  // 1-inline void Camera::set_initial_state(RenderState const *state)
  CPT(RenderState) arg_this;
  if (!Dtool_ConstCoerce_RenderState(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Camera.set_initial_state", "RenderState");
  }
  ((*local_this).set_initial_state)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_initial_state(const Camera self, const RenderState state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_set_initial_state_1150_comment =
  "C++ Interface:\n"
  "set_initial_state(const Camera self, const RenderState state)\n"
  "\n"
  "/**\n"
  " * Sets the initial state which is applied to all nodes in the scene, as if it\n"
  " * were set at the top of the scene graph.\n"
  " */";
#else
static const char *Dtool_Camera_set_initial_state_1150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< RenderState > Camera::get_initial_state(void) const
 */
static PyObject *Dtool_Camera_get_initial_state_1151(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< RenderState > Camera::get_initial_state(void) const
  ConstPointerTo< RenderState > return_value = ((*(const Camera*)local_this).get_initial_state)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_initial_state_1151_comment =
  "C++ Interface:\n"
  "get_initial_state(Camera self)\n"
  "\n"
  "/**\n"
  " * Returns the initial state as set by a previous call to set_initial_state().\n"
  " */";
#else
static const char *Dtool_Camera_get_initial_state_1151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Camera::set_tag_state_key(std::string const &tag_state_key)
 */
static PyObject *Dtool_Camera_set_tag_state_key_1153(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.set_tag_state_key")) {
    return nullptr;
  }
  // 1-inline void Camera::set_tag_state_key(std::string const &tag_state_key)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_tag_state_key)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tag_state_key(const Camera self, str tag_state_key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_set_tag_state_key_1153_comment =
  "C++ Interface:\n"
  "set_tag_state_key(const Camera self, str tag_state_key)\n"
  "\n"
  "/**\n"
  " * Sets the tag key which, when encountered as a tag on nodes in the scene\n"
  " * graph, causes this Camera to apply an arbitrary state transition based on\n"
  " * the value of the tag (as specified to set_tag_state()).\n"
  " */";
#else
static const char *Dtool_Camera_set_tag_state_key_1153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Camera::get_tag_state_key(void) const
 */
static PyObject *Dtool_Camera_get_tag_state_key_1154(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-inline std::string const &Camera::get_tag_state_key(void) const
  std::string const &return_value = ((*(const Camera*)local_this).get_tag_state_key)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_tag_state_key_1154_comment =
  "C++ Interface:\n"
  "get_tag_state_key(Camera self)\n"
  "\n"
  "/**\n"
  " * Returns the tag key as set by a previous call to set_tag_state_key().\n"
  " */";
#else
static const char *Dtool_Camera_get_tag_state_key_1154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Camera::set_lod_scale(PN_stdfloat value)
 */
static PyObject *Dtool_Camera_set_lod_scale_1157(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.set_lod_scale")) {
    return nullptr;
  }
  // 1-inline void Camera::set_lod_scale(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_lod_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod_scale(const Camera self, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_set_lod_scale_1157_comment =
  "C++ Interface:\n"
  "set_lod_scale(const Camera self, float value)\n"
  "\n"
  "/**\n"
  " * Sets the multiplier for LOD distances.  This value is multiplied with the\n"
  " * LOD scale set on LodNodes.\n"
  " */";
#else
static const char *Dtool_Camera_set_lod_scale_1157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Camera::get_lod_scale(void) const
 */
static PyObject *Dtool_Camera_get_lod_scale_1158(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Camera::get_lod_scale(void) const
  PN_stdfloat return_value = ((*(const Camera*)local_this).get_lod_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_lod_scale_1158_comment =
  "C++ Interface:\n"
  "get_lod_scale(Camera self)\n"
  "\n"
  "/**\n"
  " * Returns the multiplier for LOD distances.\n"
  " */";
#else
static const char *Dtool_Camera_get_lod_scale_1158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Camera::set_tag_state(std::string const &tag_state, RenderState const *state)
 */
static PyObject *Dtool_Camera_set_tag_state_1160(PyObject *self, PyObject *args, PyObject *kwds) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.set_tag_state")) {
    return nullptr;
  }
  // 1-void Camera::set_tag_state(std::string const &tag_state, RenderState const *state)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"tag_state", "state", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_tag_state", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    CPT(RenderState) param2_this;
    if (!Dtool_ConstCoerce_RenderState(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Camera.set_tag_state", "RenderState");
    }
    ((*local_this).set_tag_state)(std::string(param1_str, param1_len), std::move(param2_this));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tag_state(const Camera self, str tag_state, const RenderState state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_set_tag_state_1160_comment =
  "C++ Interface:\n"
  "set_tag_state(const Camera self, str tag_state, const RenderState state)\n"
  "\n"
  "/**\n"
  " * Associates a particular state transition with the indicated tag value.\n"
  " * When a node is encountered during traversal with the tag key specified by\n"
  " * set_tag_state_key(), if the value of that tag matches tag_state, then the\n"
  " * indicated state is applied to this node--but only when it is rendered by\n"
  " * this camera.\n"
  " *\n"
  " * This can be used to apply special effects to nodes when they are rendered\n"
  " * by certain cameras.  It is particularly useful for multipass rendering, in\n"
  " * which specialty cameras might be needed to render the scene with a\n"
  " * particular set of effects.\n"
  " */";
#else
static const char *Dtool_Camera_set_tag_state_1160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Camera::clear_tag_state(std::string const &tag_state)
 */
static PyObject *Dtool_Camera_clear_tag_state_1161(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.clear_tag_state")) {
    return nullptr;
  }
  // 1-void Camera::clear_tag_state(std::string const &tag_state)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).clear_tag_state)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_tag_state(const Camera self, str tag_state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_clear_tag_state_1161_comment =
  "C++ Interface:\n"
  "clear_tag_state(const Camera self, str tag_state)\n"
  "\n"
  "/**\n"
  " * Removes the association established by a previous call to set_tag_state().\n"
  " */";
#else
static const char *Dtool_Camera_clear_tag_state_1161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Camera::clear_tag_states(void)
 */
static PyObject *Dtool_Camera_clear_tag_states_1162(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.clear_tag_states")) {
    return nullptr;
  }
  // 1-void Camera::clear_tag_states(void)
  ((*local_this).clear_tag_states)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Camera_clear_tag_states_1162_comment =
  "C++ Interface:\n"
  "clear_tag_states(const Camera self)\n"
  "\n"
  "/**\n"
  " * Removes all associations established by previous calls to set_tag_state().\n"
  " */";
#else
static const char *Dtool_Camera_clear_tag_states_1162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Camera::has_tag_state(std::string const &tag_state) const
 */
static PyObject *Dtool_Camera_has_tag_state_1163(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-bool Camera::has_tag_state(std::string const &tag_state) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const Camera*)local_this).has_tag_state)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_tag_state(Camera self, str tag_state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_has_tag_state_1163_comment =
  "C++ Interface:\n"
  "has_tag_state(Camera self, str tag_state)\n"
  "\n"
  "/**\n"
  " * Returns true if set_tag_state() has previously been called with the\n"
  " * indicated tag state, false otherwise.\n"
  " */";
#else
static const char *Dtool_Camera_has_tag_state_1163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderState > Camera::get_tag_state(std::string const &tag_state) const
 */
static PyObject *Dtool_Camera_get_tag_state_1164(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderState > Camera::get_tag_state(std::string const &tag_state) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ConstPointerTo< RenderState > return_value = ((*(const Camera*)local_this).get_tag_state)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tag_state(Camera self, str tag_state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_tag_state_1164_comment =
  "C++ Interface:\n"
  "get_tag_state(Camera self, str tag_state)\n"
  "\n"
  "/**\n"
  " * Returns the state associated with the indicated tag state by a previous\n"
  " * call to set_tag_state(), or the empty state if nothing has been associated.\n"
  " */";
#else
static const char *Dtool_Camera_get_tag_state_1164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Camera::set_aux_scene_data(NodePath const &node_path, AuxSceneData *data)
 */
static PyObject *Dtool_Camera_set_aux_scene_data_1166(PyObject *self, PyObject *args, PyObject *kwds) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.set_aux_scene_data")) {
    return nullptr;
  }
  // 1-void Camera::set_aux_scene_data(NodePath const &node_path, AuxSceneData *data)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"node_path", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_aux_scene_data", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "Camera.set_aux_scene_data", true, true);
    AuxSceneData *param2_this = (AuxSceneData *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_AuxSceneData, 2, "Camera.set_aux_scene_data", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).set_aux_scene_data)(*param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux_scene_data(const Camera self, const NodePath node_path, AuxSceneData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_set_aux_scene_data_1166_comment =
  "C++ Interface:\n"
  "set_aux_scene_data(const Camera self, const NodePath node_path, AuxSceneData data)\n"
  "\n"
  "/**\n"
  " * Associates the indicated AuxSceneData object with the given NodePath,\n"
  " * possibly replacing a previous data defined for the same NodePath, if any.\n"
  " */";
#else
static const char *Dtool_Camera_set_aux_scene_data_1166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Camera::clear_aux_scene_data(NodePath const &node_path)
 */
static PyObject *Dtool_Camera_clear_aux_scene_data_1167(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.clear_aux_scene_data")) {
    return nullptr;
  }
  // 1-bool Camera::clear_aux_scene_data(NodePath const &node_path)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.clear_aux_scene_data", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).clear_aux_scene_data)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_aux_scene_data(const Camera self, const NodePath node_path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_clear_aux_scene_data_1167_comment =
  "C++ Interface:\n"
  "clear_aux_scene_data(const Camera self, const NodePath node_path)\n"
  "\n"
  "/**\n"
  " * Removes the AuxSceneData associated with the indicated NodePath.  Returns\n"
  " * true if it is removed successfully, false if it was already gone.\n"
  " */";
#else
static const char *Dtool_Camera_clear_aux_scene_data_1167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AuxSceneData *Camera::get_aux_scene_data(NodePath const &node_path) const
 */
static PyObject *Dtool_Camera_get_aux_scene_data_1168(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-AuxSceneData *Camera::get_aux_scene_data(NodePath const &node_path) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.get_aux_scene_data", true, true);
  if (arg_this != nullptr) {
    AuxSceneData *return_value = ((*(const Camera*)local_this).get_aux_scene_data)(*arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AuxSceneData, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_aux_scene_data(Camera self, const NodePath node_path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_aux_scene_data_1168_comment =
  "C++ Interface:\n"
  "get_aux_scene_data(Camera self, const NodePath node_path)\n"
  "\n"
  "/**\n"
  " * Returns the AuxSceneData associated with the indicated NodePath, or NULL if\n"
  " * nothing is associated.\n"
  " */";
#else
static const char *Dtool_Camera_get_aux_scene_data_1168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Camera::list_aux_scene_data(std::ostream &out) const
 */
static PyObject *Dtool_Camera_list_aux_scene_data_1169(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Camera)) {
    return nullptr;
  }
  // 1-void Camera::list_aux_scene_data(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Camera.list_aux_scene_data", false, true);
  if (arg_this != nullptr) {
    ((*(const Camera*)local_this).list_aux_scene_data)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_aux_scene_data(Camera self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_list_aux_scene_data_1169_comment =
  "C++ Interface:\n"
  "list_aux_scene_data(Camera self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs all of the NodePaths and AuxSceneDatas in use.\n"
  " */";
#else
static const char *Dtool_Camera_list_aux_scene_data_1169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Camera::cleanup_aux_scene_data(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_Camera_cleanup_aux_scene_data_1170(PyObject *self, PyObject *args, PyObject *kwds) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.cleanup_aux_scene_data")) {
    return nullptr;
  }
  // 1-int Camera::cleanup_aux_scene_data(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "Camera.cleanup_aux_scene_data", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*local_this).cleanup_aux_scene_data)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cleanup_aux_scene_data(const Camera self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Camera_cleanup_aux_scene_data_1170_comment =
  "C++ Interface:\n"
  "cleanup_aux_scene_data(const Camera self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Walks through the list of currently-assigned AuxSceneData objects and\n"
  " * releases any that are past their expiration times.  Returns the number of\n"
  " * elements released.\n"
  " */";
#else
static const char *Dtool_Camera_cleanup_aux_scene_data_1170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Camera::get_class_type(void)
 */
static PyObject *Dtool_Camera_get_class_type_1173(PyObject *, PyObject *) {
  // 1-static TypeHandle Camera::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Camera::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Camera_get_class_type_1173_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Camera_get_class_type_1173_comment = nullptr;
#endif

static PyObject *Dtool_Camera_active_Getter(PyObject *self, void *) {
  const Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool Camera::is_active(void) const
  bool return_value = ((*(const Camera*)local_this).is_active)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Camera_active_Setter(PyObject *self, PyObject *arg, void *) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.active")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete active attribute");
    return -1;
  }
  // 1-inline void Camera::set_active(bool active)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_active(const Camera self, bool active)\n");
  }
  return -1;
}

static PyObject *Dtool_Camera_scene_Getter(PyObject *self, void *) {
  const Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath const &Camera::get_scene(void) const
  NodePath const *return_value = &(((*(const Camera*)local_this).get_scene)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

static int Dtool_Camera_scene_Setter(PyObject *self, PyObject *arg, void *) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.scene")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete scene attribute");
    return -1;
  }
  // 1-inline void Camera::set_scene(NodePath const &scene)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.set_scene", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_scene)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scene(const Camera self, const NodePath scene)\n");
  }
  return -1;
}

/**
 * sequence length function for property Camera::display_regions
 */
static Py_ssize_t Dtool_Camera_display_regions_Len(PyObject *self) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_display_regions)();
}

/**
 * sequence getter for property Camera::display_regions
 */
static PyObject *Dtool_Camera_display_regions_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_display_regions)()) {
    PyErr_SetString(PyExc_IndexError, "Camera.display_regions[] index out of range");
    return nullptr;
  }
  // 1-inline DisplayRegion *Camera::get_display_region(std::size_t n) const
  DisplayRegion *return_value = ((*(const Camera*)local_this).get_display_region)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DisplayRegion, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_display_region(Camera self, index)\n");
  }
}

static PyObject *Dtool_Camera_display_regions_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "Camera.display_regions");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_Camera_display_regions_Len;
    wrap->_getitem_func = &Dtool_Camera_display_regions_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_Camera_camera_mask_Getter(PyObject *self, void *) {
  const Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline DrawMask Camera::get_camera_mask(void) const
  DrawMask *return_value = new DrawMask(((*(const Camera*)local_this).get_camera_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_Camera_camera_mask_Setter(PyObject *self, PyObject *arg, void *) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.camera_mask")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete camera_mask attribute");
    return -1;
  }
  // 1-inline void Camera::set_camera_mask(DrawMask mask)
  BitMask< uint32_t, 32 > arg_local;
  DrawMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Camera.set_camera_mask", "BitMask");
    return -1;
  }
  ((*local_this).set_camera_mask)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_camera_mask(const Camera self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_Camera_cull_center_Getter(PyObject *self, void *) {
  const Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath const &Camera::get_cull_center(void) const
  NodePath const *return_value = &(((*(const Camera*)local_this).get_cull_center)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

static int Dtool_Camera_cull_center_Setter(PyObject *self, PyObject *arg, void *) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.cull_center")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cull_center attribute");
    return -1;
  }
  // 1-inline void Camera::set_cull_center(NodePath const &cull_center)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.set_cull_center", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cull_center)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cull_center(const Camera self, const NodePath cull_center)\n");
  }
  return -1;
}

static PyObject *Dtool_Camera_cull_bounds_Getter(PyObject *self, void *) {
  const Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline BoundingVolume *Camera::get_cull_bounds(void) const
  BoundingVolume *return_value = ((*(const Camera*)local_this).get_cull_bounds)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BoundingVolume, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Camera_cull_bounds_Setter(PyObject *self, PyObject *arg, void *) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.cull_bounds")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cull_bounds attribute");
    return -1;
  }
  // 1-inline void Camera::set_cull_bounds(BoundingVolume *cull_bounds)
  BoundingVolume *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "Camera.set_cull_bounds", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cull_bounds)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cull_bounds(const Camera self, BoundingVolume cull_bounds)\n");
  }
  return -1;
}

static PyObject *Dtool_Camera_lod_center_Getter(PyObject *self, void *) {
  const Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath const &Camera::get_lod_center(void) const
  NodePath const *return_value = &(((*(const Camera*)local_this).get_lod_center)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

static int Dtool_Camera_lod_center_Setter(PyObject *self, PyObject *arg, void *) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.lod_center")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete lod_center attribute");
    return -1;
  }
  // 1-inline void Camera::set_lod_center(NodePath const &lod_center)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.set_lod_center", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_lod_center)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_lod_center(const Camera self, const NodePath lod_center)\n");
  }
  return -1;
}

static PyObject *Dtool_Camera_initial_state_Getter(PyObject *self, void *) {
  const Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConstPointerTo< RenderState > Camera::get_initial_state(void) const
  ConstPointerTo< RenderState > return_value = ((*(const Camera*)local_this).get_initial_state)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  RenderState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

static int Dtool_Camera_initial_state_Setter(PyObject *self, PyObject *arg, void *) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.initial_state")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete initial_state attribute");
    return -1;
  }
  // 1-inline void Camera::set_initial_state(RenderState const *state)
  CPT(RenderState) arg_this;
  if (!Dtool_ConstCoerce_RenderState(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Camera.set_initial_state", "RenderState");
    return -1;
  }
  ((*local_this).set_initial_state)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_initial_state(const Camera self, const RenderState state)\n");
  }
  return -1;
}

static PyObject *Dtool_Camera_tag_state_key_Getter(PyObject *self, void *) {
  const Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &Camera::get_tag_state_key(void) const
  std::string const &return_value = ((*(const Camera*)local_this).get_tag_state_key)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Camera_tag_state_key_Setter(PyObject *self, PyObject *arg, void *) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.tag_state_key")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete tag_state_key attribute");
    return -1;
  }
  // 1-inline void Camera::set_tag_state_key(std::string const &tag_state_key)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_tag_state_key)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tag_state_key(const Camera self, str tag_state_key)\n");
  }
  return -1;
}

static PyObject *Dtool_Camera_lod_scale_Getter(PyObject *self, void *) {
  const Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Camera::get_lod_scale(void) const
  PN_stdfloat return_value = ((*(const Camera*)local_this).get_lod_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Camera_lod_scale_Setter(PyObject *self, PyObject *arg, void *) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.lod_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete lod_scale attribute");
    return -1;
  }
  // 1-inline void Camera::set_lod_scale(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_lod_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_lod_scale(const Camera self, float value)\n");
  }
  return -1;
}

/**
 * mapping getitem for property Camera::tag_states
 */
static PyObject *Dtool_Camera_tag_states_Mapping_Getitem(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }
  {
    // 1-bool Camera::has_tag_state(std::string const &tag_state) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      bool return_value = ((*(const Camera*)local_this).has_tag_state)(std::string(param1_str, param1_len));
      if (!return_value) {
        PyErr_SetObject(PyExc_KeyError, arg);
        return nullptr;
      }
    }
  }
  // 1-ConstPointerTo< RenderState > Camera::get_tag_state(std::string const &tag_state) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ConstPointerTo< RenderState > return_value = ((*(const Camera*)local_this).get_tag_state)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    // Transfer ownership of return_value.
    RenderState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderState, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tag_state(Camera self, str tag_state)\n");
  }
  return nullptr;
}

/**
 * mapping setitem for property Camera::tag_states
 */
static int Dtool_Camera_tag_states_Mapping_Setitem(PyObject *self, PyObject *key, PyObject *value) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.tag_states")) {
    return -1;
  }

  if (value == nullptr) {
    PyObject *arg = key;
    {
      // 1-bool Camera::has_tag_state(std::string const &tag_state) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        bool return_value = ((*(const Camera*)local_this).has_tag_state)(std::string(param1_str, param1_len));
        if (!return_value) {
          PyErr_SetObject(PyExc_KeyError, arg);
          return -1;
        }
      }
    }
    // 1-void Camera::clear_tag_state(std::string const &tag_state)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).clear_tag_state)(std::string(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
    return -1;
  }
  PyObject *args = PyTuple_New(2);
  PyTuple_SET_ITEM(args, 0, key);
  PyTuple_SET_ITEM(args, 1, value);
  Py_INCREF(key);
  Py_INCREF(value);
  // 1-void Camera::set_tag_state(std::string const &tag_state, RenderState const *state)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  if (PyArg_ParseTuple(args, "s#O:set_tag_state", &param1_str, &param1_len, &param2)) {
    CPT(RenderState) param2_this;
    if (!Dtool_ConstCoerce_RenderState(param2, param2_this)) {
      Dtool_Raise_ArgTypeError(param2, 2, "Camera.set_tag_state", "RenderState");
      Py_DECREF(args);
      return -1;
    }
    ((*local_this).set_tag_state)(std::string(param1_str, param1_len), std::move(param2_this));
    Py_DECREF(args);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tag_state(const Camera self, str tag_state, const RenderState state)\n");
  }
  Py_DECREF(args);
  return -1;
}

static PyObject *Dtool_Camera_tag_states_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MappingWrapper *wrap = Dtool_NewMutableMappingWrapper(self, "Camera.tag_states");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_Camera_tag_states_Mapping_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_Camera_tag_states_Mapping_Setitem;
    }
  }
  return (PyObject *)wrap;
}

/**
 * mapping getitem for property Camera::aux_scene_data
 */
static PyObject *Dtool_Camera_aux_scene_data_Mapping_Getitem(PyObject *self, PyObject *arg) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }
  {
    // 1-AuxSceneData *Camera::get_aux_scene_data(NodePath const &node_path) const
    NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.get_aux_scene_data", true, true);
    if (arg_this != nullptr) {
      AuxSceneData *return_value = ((*(const Camera*)local_this).get_aux_scene_data)(*arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (!return_value) {
        PyErr_SetObject(PyExc_KeyError, arg);
        return nullptr;
      }
    }
  }
  // 1-AuxSceneData *Camera::get_aux_scene_data(NodePath const &node_path) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.get_aux_scene_data", true, true);
  if (arg_this != nullptr) {
    AuxSceneData *return_value = ((*(const Camera*)local_this).get_aux_scene_data)(*arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return Dtool_Raise_AssertionError();
    }
#endif
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AuxSceneData, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_aux_scene_data(Camera self, const NodePath node_path)\n");
  }
  return nullptr;
}

/**
 * mapping setitem for property Camera::aux_scene_data
 */
static int Dtool_Camera_aux_scene_data_Mapping_Setitem(PyObject *self, PyObject *key, PyObject *value) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Camera, (void **)&local_this, "Camera.aux_scene_data")) {
    return -1;
  }

  if (value == nullptr) {
    PyObject *arg = key;
    {
      // 1-AuxSceneData *Camera::get_aux_scene_data(NodePath const &node_path) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.get_aux_scene_data", true, true);
      if (arg_this != nullptr) {
        AuxSceneData *return_value = ((*(const Camera*)local_this).get_aux_scene_data)(*arg_this);
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (!return_value) {
          PyErr_SetObject(PyExc_KeyError, arg);
          return -1;
        }
      }
    }
    // 1-bool Camera::clear_aux_scene_data(NodePath const &node_path)
    NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Camera.clear_aux_scene_data", true, true);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).clear_aux_scene_data)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return (return_value) ? 0 : -1;
    }
    return -1;
  }
  PyObject *args = PyTuple_New(2);
  PyTuple_SET_ITEM(args, 0, key);
  PyTuple_SET_ITEM(args, 1, value);
  Py_INCREF(key);
  Py_INCREF(value);
  // 1-void Camera::set_aux_scene_data(NodePath const &node_path, AuxSceneData *data)
  PyObject *param1;
  PyObject *param2;
  if (PyArg_UnpackTuple(args, "set_aux_scene_data", 2, 2, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "Camera.set_aux_scene_data", true, true);
    AuxSceneData *param2_this = (AuxSceneData *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_AuxSceneData, 2, "Camera.set_aux_scene_data", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).set_aux_scene_data)(*param1_this, param2_this);
      Py_DECREF(args);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_aux_scene_data(const Camera self, const NodePath node_path, AuxSceneData data)\n");
  }
  Py_DECREF(args);
  return -1;
}

static PyObject *Dtool_Camera_aux_scene_data_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MappingWrapper *wrap = Dtool_NewMutableMappingWrapper(self, "Camera.aux_scene_data");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_Camera_aux_scene_data_Mapping_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_Camera_aux_scene_data_Mapping_Setitem;
    }
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * Camera::Camera(Camera const &copy)
 * explicit Camera::Camera(std::string const &name, Lens *lens = (new PerspectiveLens()))
 */
static int Dtool_Init_Camera(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 explicit Camera::Camera(std::string const &name, Lens *lens = (new PerspectiveLens()))
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    PyObject *param1 = nullptr;
    static const char *keyword_list[] = {"name", "lens", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:Camera", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
      Lens *param1_this;
      if (param1 == nullptr) {
        param1_this = (new PerspectiveLens());
      } else {
        param1_this = (Lens *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Lens, 1, "Camera.Camera", false, false);
      }
      if ((param1 == nullptr || param1_this != nullptr)) {
        Camera *return_value = new Camera(std::string(param0_str, param0_len), param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Camera, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 Camera::Camera(Camera const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      Camera const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Camera);
      if (param0_this != nullptr) {
        Camera *return_value = new Camera(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Camera, true, false);
      }
    }
  }

  // No coercion possible: explicit Camera::Camera(std::string const &name, Lens *lens = (new PerspectiveLens()))
  // No coercion possible: Camera::Camera(Camera const &copy)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Camera(str name, Lens lens)\n"
      "Camera(const Camera copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Camera_get_display_regions(PyObject *self, PyObject *) {
  Camera *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Camera, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_display_regions)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Camera_get_display_region_1132(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Camera(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Camera) {
    printf("Camera ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Camera *local_this = (Camera *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Camera) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Camera(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Camera) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (Camera*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Camera*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (Camera*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Camera*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Camera*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Camera*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Camera*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PlaneNode
 */
/**
 * Python function wrapper for:
 * inline void PlaneNode::set_plane(LPlane const &plane)
 */
static PyObject *Dtool_PlaneNode_set_plane_1176(PyObject *self, PyObject *arg) {
  PlaneNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PlaneNode, (void **)&local_this, "PlaneNode.set_plane")) {
    return nullptr;
  }
  // 1-inline void PlaneNode::set_plane(LPlane const &plane)
  LPlanef arg_local;
  LPlane const *arg_this = Dtool_Coerce_LPlanef(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PlaneNode.set_plane", "LPlanef");
  }
  ((*local_this).set_plane)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_plane(const PlaneNode self, const LPlanef plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PlaneNode_set_plane_1176_comment =
  "C++ Interface:\n"
  "set_plane(const PlaneNode self, const LPlanef plane)\n"
  "\n"
  "/**\n"
  " * Sets the particular plane represented by the PlaneNode.\n"
  " */";
#else
static const char *Dtool_PlaneNode_set_plane_1176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlane const &PlaneNode::get_plane(void) const
 */
static PyObject *Dtool_PlaneNode_get_plane_1177(PyObject *self, PyObject *) {
  PlaneNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PlaneNode)) {
    return nullptr;
  }
  // 1-inline LPlane const &PlaneNode::get_plane(void) const
  LPlane const *return_value = &(((*(const PlaneNode*)local_this).get_plane)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PlaneNode_get_plane_1177_comment =
  "C++ Interface:\n"
  "get_plane(PlaneNode self)\n"
  "\n"
  "/**\n"
  " * Returns the plane represented by the PlaneNode.\n"
  " */";
#else
static const char *Dtool_PlaneNode_get_plane_1177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PlaneNode::set_viz_scale(PN_stdfloat viz_scale)
 */
static PyObject *Dtool_PlaneNode_set_viz_scale_1178(PyObject *self, PyObject *arg) {
  PlaneNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PlaneNode, (void **)&local_this, "PlaneNode.set_viz_scale")) {
    return nullptr;
  }
  // 1-inline void PlaneNode::set_viz_scale(PN_stdfloat viz_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_viz_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_viz_scale(const PlaneNode self, float viz_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PlaneNode_set_viz_scale_1178_comment =
  "C++ Interface:\n"
  "set_viz_scale(const PlaneNode self, float viz_scale)\n"
  "\n"
  "/**\n"
  " * Specifies the size of the visual representation of the plane that is drawn\n"
  " * if the PlaneNode is shown.\n"
  " */";
#else
static const char *Dtool_PlaneNode_set_viz_scale_1178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PlaneNode::get_viz_scale(void) const
 */
static PyObject *Dtool_PlaneNode_get_viz_scale_1179(PyObject *self, PyObject *) {
  PlaneNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PlaneNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PlaneNode::get_viz_scale(void) const
  PN_stdfloat return_value = ((*(const PlaneNode*)local_this).get_viz_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PlaneNode_get_viz_scale_1179_comment =
  "C++ Interface:\n"
  "get_viz_scale(PlaneNode self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the visual representation of the plane that is drawn if\n"
  " * the PlaneNode is shown.\n"
  " */";
#else
static const char *Dtool_PlaneNode_get_viz_scale_1179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PlaneNode::set_priority(int priority)
 */
static PyObject *Dtool_PlaneNode_set_priority_1180(PyObject *self, PyObject *arg) {
  PlaneNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PlaneNode, (void **)&local_this, "PlaneNode.set_priority")) {
    return nullptr;
  }
  // 1-inline void PlaneNode::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_priority)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_priority(const PlaneNode self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PlaneNode_set_priority_1180_comment =
  "C++ Interface:\n"
  "set_priority(const PlaneNode self, int priority)\n"
  "\n"
  "/**\n"
  " * Changes the relative importance of this PlaneNode (when it is used as a\n"
  " * clip plane) relative to the other clip planes that are applied\n"
  " * simultaneously.\n"
  " *\n"
  " * The priority number is used to decide which of the requested clip planes\n"
  " * are to be activated when more clip planes are requested than the hardware\n"
  " * will support.  The highest-priority n planes are selected for rendering.\n"
  " *\n"
  " * This is similar to TextureStage::set_priority().\n"
  " */";
#else
static const char *Dtool_PlaneNode_set_priority_1180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PlaneNode::get_priority(void) const
 */
static PyObject *Dtool_PlaneNode_get_priority_1181(PyObject *self, PyObject *) {
  PlaneNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PlaneNode)) {
    return nullptr;
  }
  // 1-inline int PlaneNode::get_priority(void) const
  int return_value = ((*(const PlaneNode*)local_this).get_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PlaneNode_get_priority_1181_comment =
  "C++ Interface:\n"
  "get_priority(PlaneNode self)\n"
  "\n"
  "/**\n"
  " * Returns the priority associated with this clip plane.  See set_priority().\n"
  " */";
#else
static const char *Dtool_PlaneNode_get_priority_1181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PlaneNode::set_clip_effect(int clip_effect)
 */
static PyObject *Dtool_PlaneNode_set_clip_effect_1183(PyObject *self, PyObject *arg) {
  PlaneNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PlaneNode, (void **)&local_this, "PlaneNode.set_clip_effect")) {
    return nullptr;
  }
  // 1-inline void PlaneNode::set_clip_effect(int clip_effect)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_clip_effect)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clip_effect(const PlaneNode self, int clip_effect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PlaneNode_set_clip_effect_1183_comment =
  "C++ Interface:\n"
  "set_clip_effect(const PlaneNode self, int clip_effect)\n"
  "\n"
  "/**\n"
  " * Specifies the sort of things this plane will actually clip (when it is used\n"
  " * as a clip plane).  This is a bitmask union of ClipEffect values.  If it\n"
  " * includes CE_visible, then it will clip visible geometry; if it includes\n"
  " * CE_collision, then it will clip collision polygons.  If it includes neither\n"
  " * bit, it will still affect culling, but objects will either be wholly behind\n"
  " * the clipping plane, or wholly present.\n"
  " */";
#else
static const char *Dtool_PlaneNode_set_clip_effect_1183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PlaneNode::get_clip_effect(void) const
 */
static PyObject *Dtool_PlaneNode_get_clip_effect_1184(PyObject *self, PyObject *) {
  PlaneNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PlaneNode)) {
    return nullptr;
  }
  // 1-inline int PlaneNode::get_clip_effect(void) const
  int return_value = ((*(const PlaneNode*)local_this).get_clip_effect)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PlaneNode_get_clip_effect_1184_comment =
  "C++ Interface:\n"
  "get_clip_effect(PlaneNode self)\n"
  "\n"
  "/**\n"
  " * Returns the clip_effect bits for this clip plane.  See set_clip_effect().\n"
  " */";
#else
static const char *Dtool_PlaneNode_get_clip_effect_1184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PlaneNode::get_class_type(void)
 */
static PyObject *Dtool_PlaneNode_get_class_type_1185(PyObject *, PyObject *) {
  // 1-static TypeHandle PlaneNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PlaneNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PlaneNode_get_class_type_1185_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PlaneNode_get_class_type_1185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit PlaneNode::PlaneNode(std::string const &name, LPlane const &plane = LPlane())
 */
static int Dtool_Init_PlaneNode(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit PlaneNode::PlaneNode(std::string const &name, LPlane const &plane = LPlane())
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"name", "plane", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:PlaneNode", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    LPlanef param1_local;
    LPlane const *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_LPlanef(param1, param1_local);
    } else {
      param1_local = LPlane();
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      Dtool_Raise_ArgTypeError(param1, 1, "PlaneNode.PlaneNode", "LPlanef");
      return -1;
    }
    PlaneNode *return_value = new PlaneNode(std::string(param0_str, param0_len), *param1_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PlaneNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PlaneNode(str name, const LPlanef plane)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PlaneNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PlaneNode) {
    printf("PlaneNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PlaneNode *local_this = (PlaneNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PlaneNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PlaneNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PlaneNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PlaneNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PlaneNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PlaneNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PlaneNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PlaneNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PlaneNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ClipPlaneAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(void)
 * static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane)
 * static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2)
 * static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2, PlaneNode *plane3)
 * static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2, PlaneNode *plane3, PlaneNode *plane4)
 */
static PyObject *Dtool_ClipPlaneAttrib_make_1189(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(void)
      ConstPointerTo< RenderAttrib > return_value = (ClipPlaneAttrib::make)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 2:
    {
      // 1-static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane)
      int param0;
      PyObject *param1;
      static const char *keyword_list[] = {"op", "plane", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:make", (char **)keyword_list, &param0, &param1)) {
        PlaneNode *param1_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PlaneNode, 1, "ClipPlaneAttrib.make", false, true);
        if (param1_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (ClipPlaneAttrib::make)((ClipPlaneAttrib::Operation)param0, param1_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 3:
    {
      // 1-static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2)
      int param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"op", "plane1", "plane2", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iOO:make", (char **)keyword_list, &param0, &param1, &param2)) {
        PlaneNode *param1_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PlaneNode, 1, "ClipPlaneAttrib.make", false, true);
        PlaneNode *param2_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PlaneNode, 2, "ClipPlaneAttrib.make", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (ClipPlaneAttrib::make)((ClipPlaneAttrib::Operation)param0, param1_this, param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 4:
    {
      // 1-static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2, PlaneNode *plane3)
      int param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"op", "plane1", "plane2", "plane3", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iOOO:make", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        PlaneNode *param1_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PlaneNode, 1, "ClipPlaneAttrib.make", false, true);
        PlaneNode *param2_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PlaneNode, 2, "ClipPlaneAttrib.make", false, true);
        PlaneNode *param3_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PlaneNode, 3, "ClipPlaneAttrib.make", false, true);
        if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (ClipPlaneAttrib::make)((ClipPlaneAttrib::Operation)param0, param1_this, param2_this, param3_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 5:
    {
      // 1-static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2, PlaneNode *plane3, PlaneNode *plane4)
      int param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"op", "plane1", "plane2", "plane3", "plane4", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iOOOO:make", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        PlaneNode *param1_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PlaneNode, 1, "ClipPlaneAttrib.make", false, true);
        PlaneNode *param2_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PlaneNode, 2, "ClipPlaneAttrib.make", false, true);
        PlaneNode *param3_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PlaneNode, 3, "ClipPlaneAttrib.make", false, true);
        PlaneNode *param4_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_PlaneNode, 4, "ClipPlaneAttrib.make", false, true);
        if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr && param4_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (ClipPlaneAttrib::make)((ClipPlaneAttrib::Operation)param0, param1_this, param2_this, param3_this, param4_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 0, 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make()\n"
      "make(int op, PlaneNode plane)\n"
      "make(int op, PlaneNode plane1, PlaneNode plane2)\n"
      "make(int op, PlaneNode plane1, PlaneNode plane2, PlaneNode plane3)\n"
      "make(int op, PlaneNode plane1, PlaneNode plane2, PlaneNode plane3, PlaneNode plane4)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_make_1189_comment =
  "C++ Interface:\n"
  "make()\n"
  "make(int op, PlaneNode plane)\n"
  "make(int op, PlaneNode plane1, PlaneNode plane2)\n"
  "make(int op, PlaneNode plane1, PlaneNode plane2, PlaneNode plane3)\n"
  "make(int op, PlaneNode plane1, PlaneNode plane2, PlaneNode plane3, PlaneNode plane4)\n"
  "\n"
  "// The following is the new, more general interface to the ClipPlaneAttrib.\n"
  "\n"
  "/**\n"
  " * Constructs a new ClipPlaneAttrib object that enables (or disables,\n"
  " * according to op) the indicated plane(s).\n"
  " *\n"
  " * @deprecated Use add_on_plane() or add_off_plane() instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new ClipPlaneAttrib object that turns on (or off, according to\n"
  " * op) the indicate plane(s).\n"
  " *\n"
  " * @deprecated Use add_on_plane() or add_off_plane() instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new ClipPlaneAttrib object that turns on (or off, according to\n"
  " * op) the indicate plane(s).\n"
  " *\n"
  " * @deprecated Use add_on_plane() or add_off_plane() instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new ClipPlaneAttrib object that turns on (or off, according to\n"
  " * op) the indicate plane(s).\n"
  " *\n"
  " * @deprecated Use add_on_plane() or add_off_plane() instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new ClipPlaneAttrib object that does nothing.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_make_1189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make_default(void)
 */
static PyObject *Dtool_ClipPlaneAttrib_make_default_1190(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (ClipPlaneAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_make_default_1190_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_make_default_1190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ClipPlaneAttrib::Operation ClipPlaneAttrib::get_operation(void) const
 */
static PyObject *Dtool_ClipPlaneAttrib_get_operation_1191(PyObject *self, PyObject *) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-ClipPlaneAttrib::Operation ClipPlaneAttrib::get_operation(void) const
  ClipPlaneAttrib::Operation return_value = ((*(const ClipPlaneAttrib*)local_this).get_operation)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_get_operation_1191_comment =
  "C++ Interface:\n"
  "get_operation(ClipPlaneAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the basic operation type of the ClipPlaneAttrib.  If this is O_set,\n"
  " * the planes listed here completely replace any planes that were already on.\n"
  " * If this is O_add, the planes here are added to the set of planes that\n"
  " * were already on, and if O_remove, the planes here are removed from the set\n"
  " * of planes that were on.\n"
  " *\n"
  " * @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and\n"
  " * off_planes, so this method no longer makes sense.  Query the lists\n"
  " * independently.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_get_operation_1191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ClipPlaneAttrib::get_num_planes(void) const
 */
static PyObject *Dtool_ClipPlaneAttrib_get_num_planes_1192(PyObject *self, PyObject *) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-int ClipPlaneAttrib::get_num_planes(void) const
  int return_value = ((*(const ClipPlaneAttrib*)local_this).get_num_planes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_get_num_planes_1192_comment =
  "C++ Interface:\n"
  "get_num_planes(ClipPlaneAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of planes listed in the attribute.\n"
  " *\n"
  " * @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and\n"
  " * off_planes, so this method no longer makes sense.  Query the lists\n"
  " * independently.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_get_num_planes_1192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PlaneNode *ClipPlaneAttrib::get_plane(int n) const
 */
static PyObject *Dtool_ClipPlaneAttrib_get_plane_1193(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-PlaneNode *ClipPlaneAttrib::get_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PlaneNode *return_value = ((*(const ClipPlaneAttrib*)local_this).get_plane)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PlaneNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(ClipPlaneAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_get_plane_1193_comment =
  "C++ Interface:\n"
  "get_plane(ClipPlaneAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth plane listed in the attribute.\n"
  " *\n"
  " * @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and\n"
  " * off_planes, so this method no longer makes sense.  Query the lists\n"
  " * independently.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_get_plane_1193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ClipPlaneAttrib::has_plane(PlaneNode *plane) const
 */
static PyObject *Dtool_ClipPlaneAttrib_has_plane_1194(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-bool ClipPlaneAttrib::has_plane(PlaneNode *plane) const
  PlaneNode *arg_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PlaneNode, 1, "ClipPlaneAttrib.has_plane", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const ClipPlaneAttrib*)local_this).has_plane)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_plane(ClipPlaneAttrib self, PlaneNode plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_has_plane_1194_comment =
  "C++ Interface:\n"
  "has_plane(ClipPlaneAttrib self, PlaneNode plane)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated plane is listed in the attrib, false\n"
  " * otherwise.\n"
  " *\n"
  " * @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and\n"
  " * off_planes, so this method no longer makes sense.  Query the lists\n"
  " * independently.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_has_plane_1194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ClipPlaneAttrib::add_plane(PlaneNode *plane) const
 */
static PyObject *Dtool_ClipPlaneAttrib_add_plane_1195(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ClipPlaneAttrib::add_plane(PlaneNode *plane) const
  PlaneNode *arg_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PlaneNode, 1, "ClipPlaneAttrib.add_plane", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const ClipPlaneAttrib*)local_this).add_plane)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_plane(ClipPlaneAttrib self, PlaneNode plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_add_plane_1195_comment =
  "C++ Interface:\n"
  "add_plane(ClipPlaneAttrib self, PlaneNode plane)\n"
  "\n"
  "/**\n"
  " * Returns a new ClipPlaneAttrib, just like this one, but with the indicated\n"
  " * plane added to the list of planes.\n"
  " *\n"
  " * @deprecated Use add_on_plane() or add_off_plane() instead.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_add_plane_1195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ClipPlaneAttrib::remove_plane(PlaneNode *plane) const
 */
static PyObject *Dtool_ClipPlaneAttrib_remove_plane_1196(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ClipPlaneAttrib::remove_plane(PlaneNode *plane) const
  PlaneNode *arg_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PlaneNode, 1, "ClipPlaneAttrib.remove_plane", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const ClipPlaneAttrib*)local_this).remove_plane)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_plane(ClipPlaneAttrib self, PlaneNode plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_remove_plane_1196_comment =
  "C++ Interface:\n"
  "remove_plane(ClipPlaneAttrib self, PlaneNode plane)\n"
  "\n"
  "/**\n"
  " * Returns a new ClipPlaneAttrib, just like this one, but with the indicated\n"
  " * plane removed from the list of planes.\n"
  " *\n"
  " * @deprecated Use remove_on_plane() or remove_off_plane() instead.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_remove_plane_1196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make_all_off(void)
 */
static PyObject *Dtool_ClipPlaneAttrib_make_all_off_1197(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make_all_off(void)
  ConstPointerTo< RenderAttrib > return_value = (ClipPlaneAttrib::make_all_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_make_all_off_1197_comment =
  "C++ Interface:\n"
  "make_all_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new ClipPlaneAttrib object that disables all planes (and hence\n"
  " * disables clipping).\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_make_all_off_1197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ClipPlaneAttrib::get_num_on_planes(void) const
 */
static PyObject *Dtool_ClipPlaneAttrib_get_num_on_planes_1198(PyObject *self, PyObject *) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-inline int ClipPlaneAttrib::get_num_on_planes(void) const
  int return_value = ((*(const ClipPlaneAttrib*)local_this).get_num_on_planes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_get_num_on_planes_1198_comment =
  "C++ Interface:\n"
  "get_num_on_planes(ClipPlaneAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of planes that are enabled by the attribute.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_get_num_on_planes_1198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath ClipPlaneAttrib::get_on_plane(int n) const
 */
static PyObject *Dtool_ClipPlaneAttrib_get_on_plane_1199(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-inline NodePath ClipPlaneAttrib::get_on_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath(((*(const ClipPlaneAttrib*)local_this).get_on_plane)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_plane(ClipPlaneAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_get_on_plane_1199_comment =
  "C++ Interface:\n"
  "get_on_plane(ClipPlaneAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth plane enabled by the attribute, sorted in render order.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_get_on_plane_1199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ClipPlaneAttrib::has_on_plane(NodePath const &plane) const
 */
static PyObject *Dtool_ClipPlaneAttrib_has_on_plane_1201(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-inline bool ClipPlaneAttrib::has_on_plane(NodePath const &plane) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "ClipPlaneAttrib.has_on_plane", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const ClipPlaneAttrib*)local_this).has_on_plane)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_on_plane(ClipPlaneAttrib self, const NodePath plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_has_on_plane_1201_comment =
  "C++ Interface:\n"
  "has_on_plane(ClipPlaneAttrib self, const NodePath plane)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated plane is enabled by the attrib, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_has_on_plane_1201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ClipPlaneAttrib::get_num_off_planes(void) const
 */
static PyObject *Dtool_ClipPlaneAttrib_get_num_off_planes_1202(PyObject *self, PyObject *) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-inline int ClipPlaneAttrib::get_num_off_planes(void) const
  int return_value = ((*(const ClipPlaneAttrib*)local_this).get_num_off_planes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_get_num_off_planes_1202_comment =
  "C++ Interface:\n"
  "get_num_off_planes(ClipPlaneAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of planes that are disabled by the attribute.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_get_num_off_planes_1202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath ClipPlaneAttrib::get_off_plane(int n) const
 */
static PyObject *Dtool_ClipPlaneAttrib_get_off_plane_1203(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-inline NodePath ClipPlaneAttrib::get_off_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath(((*(const ClipPlaneAttrib*)local_this).get_off_plane)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_off_plane(ClipPlaneAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_get_off_plane_1203_comment =
  "C++ Interface:\n"
  "get_off_plane(ClipPlaneAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth plane disabled by the attribute, sorted in arbitrary\n"
  " * (pointer) order.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_get_off_plane_1203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ClipPlaneAttrib::has_off_plane(NodePath const &plane) const
 */
static PyObject *Dtool_ClipPlaneAttrib_has_off_plane_1205(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-inline bool ClipPlaneAttrib::has_off_plane(NodePath const &plane) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "ClipPlaneAttrib.has_off_plane", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const ClipPlaneAttrib*)local_this).has_off_plane)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_off_plane(ClipPlaneAttrib self, const NodePath plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_has_off_plane_1205_comment =
  "C++ Interface:\n"
  "has_off_plane(ClipPlaneAttrib self, const NodePath plane)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated plane is disabled by the attrib, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_has_off_plane_1205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ClipPlaneAttrib::has_all_off(void) const
 */
static PyObject *Dtool_ClipPlaneAttrib_has_all_off_1206(PyObject *self, PyObject *) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-inline bool ClipPlaneAttrib::has_all_off(void) const
  bool return_value = ((*(const ClipPlaneAttrib*)local_this).has_all_off)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_has_all_off_1206_comment =
  "C++ Interface:\n"
  "has_all_off(ClipPlaneAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if this attrib disables all planes (although it may also\n"
  " * enable some).\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_has_all_off_1206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ClipPlaneAttrib::is_identity(void) const
 */
static PyObject *Dtool_ClipPlaneAttrib_is_identity_1207(PyObject *self, PyObject *) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-inline bool ClipPlaneAttrib::is_identity(void) const
  bool return_value = ((*(const ClipPlaneAttrib*)local_this).is_identity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_is_identity_1207_comment =
  "C++ Interface:\n"
  "is_identity(ClipPlaneAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is an identity attrib: it does not change the set of\n"
  " * planes in use.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_is_identity_1207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ClipPlaneAttrib::add_on_plane(NodePath const &plane) const
 */
static PyObject *Dtool_ClipPlaneAttrib_add_on_plane_1208(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ClipPlaneAttrib::add_on_plane(NodePath const &plane) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "ClipPlaneAttrib.add_on_plane", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const ClipPlaneAttrib*)local_this).add_on_plane)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_on_plane(ClipPlaneAttrib self, const NodePath plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_add_on_plane_1208_comment =
  "C++ Interface:\n"
  "add_on_plane(ClipPlaneAttrib self, const NodePath plane)\n"
  "\n"
  "/**\n"
  " * Returns a new ClipPlaneAttrib, just like this one, but with the indicated\n"
  " * plane added to the list of planes enabled by this attrib.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_add_on_plane_1208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ClipPlaneAttrib::remove_on_plane(NodePath const &plane) const
 */
static PyObject *Dtool_ClipPlaneAttrib_remove_on_plane_1209(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ClipPlaneAttrib::remove_on_plane(NodePath const &plane) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "ClipPlaneAttrib.remove_on_plane", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const ClipPlaneAttrib*)local_this).remove_on_plane)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_on_plane(ClipPlaneAttrib self, const NodePath plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_remove_on_plane_1209_comment =
  "C++ Interface:\n"
  "remove_on_plane(ClipPlaneAttrib self, const NodePath plane)\n"
  "\n"
  "/**\n"
  " * Returns a new ClipPlaneAttrib, just like this one, but with the indicated\n"
  " * plane removed from the list of planes enabled by this attrib.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_remove_on_plane_1209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ClipPlaneAttrib::add_off_plane(NodePath const &plane) const
 */
static PyObject *Dtool_ClipPlaneAttrib_add_off_plane_1210(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ClipPlaneAttrib::add_off_plane(NodePath const &plane) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "ClipPlaneAttrib.add_off_plane", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const ClipPlaneAttrib*)local_this).add_off_plane)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_off_plane(ClipPlaneAttrib self, const NodePath plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_add_off_plane_1210_comment =
  "C++ Interface:\n"
  "add_off_plane(ClipPlaneAttrib self, const NodePath plane)\n"
  "\n"
  "/**\n"
  " * Returns a new ClipPlaneAttrib, just like this one, but with the indicated\n"
  " * plane added to the list of planes disabled by this attrib.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_add_off_plane_1210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ClipPlaneAttrib::remove_off_plane(NodePath const &plane) const
 */
static PyObject *Dtool_ClipPlaneAttrib_remove_off_plane_1211(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ClipPlaneAttrib::remove_off_plane(NodePath const &plane) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "ClipPlaneAttrib.remove_off_plane", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const ClipPlaneAttrib*)local_this).remove_off_plane)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_off_plane(ClipPlaneAttrib self, const NodePath plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_remove_off_plane_1211_comment =
  "C++ Interface:\n"
  "remove_off_plane(ClipPlaneAttrib self, const NodePath plane)\n"
  "\n"
  "/**\n"
  " * Returns a new ClipPlaneAttrib, just like this one, but with the indicated\n"
  " * plane removed from the list of planes disabled by this attrib.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_remove_off_plane_1211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< ClipPlaneAttrib > ClipPlaneAttrib::filter_to_max(int max_clip_planes) const
 */
static PyObject *Dtool_ClipPlaneAttrib_filter_to_max_1212(PyObject *self, PyObject *arg) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClipPlaneAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< ClipPlaneAttrib > ClipPlaneAttrib::filter_to_max(int max_clip_planes) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< ClipPlaneAttrib > return_value = ((*(const ClipPlaneAttrib*)local_this).filter_to_max)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    ClipPlaneAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_ClipPlaneAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "filter_to_max(ClipPlaneAttrib self, int max_clip_planes)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_filter_to_max_1212_comment =
  "C++ Interface:\n"
  "filter_to_max(ClipPlaneAttrib self, int max_clip_planes)\n"
  "\n"
  "/**\n"
  " * Returns a new ClipPlaneAttrib, very much like this one, but with the number\n"
  " * of on_planes reduced to be no more than max_clip_planes.  The number of\n"
  " * off_planes in the new ClipPlaneAttrib is undefined.\n"
  " */";
#else
static const char *Dtool_ClipPlaneAttrib_filter_to_max_1212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int ClipPlaneAttrib::get_class_slot(void)
 */
static PyObject *Dtool_ClipPlaneAttrib_get_class_slot_1213(PyObject *, PyObject *) {
  // 1-static int ClipPlaneAttrib::get_class_slot(void)
  int return_value = (ClipPlaneAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_get_class_slot_1213_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_ClipPlaneAttrib_get_class_slot_1213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ClipPlaneAttrib::get_class_type(void)
 */
static PyObject *Dtool_ClipPlaneAttrib_get_class_type_1215(PyObject *, PyObject *) {
  // 1-static TypeHandle ClipPlaneAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ClipPlaneAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ClipPlaneAttrib_get_class_type_1215_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ClipPlaneAttrib_get_class_type_1215_comment = nullptr;
#endif

static PyObject *Dtool_ClipPlaneAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int ClipPlaneAttrib::get_class_slot(void)
  int return_value = (ClipPlaneAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ClipPlaneAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ClipPlaneAttrib(PyObject *args, CPT(ClipPlaneAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ClipPlaneAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane)
        int param0;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "iO:make", &param0, &param1)) {
          PlaneNode *param1_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PlaneNode, 1, "ClipPlaneAttrib.make", false, false);
          if (param1_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = (ClipPlaneAttrib::make)((ClipPlaneAttrib::Operation)param0, param1_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((ClipPlaneAttrib const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2)
        int param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_ParseTuple(args, "iOO:make", &param0, &param1, &param2)) {
          PlaneNode *param1_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PlaneNode, 1, "ClipPlaneAttrib.make", false, false);
          PlaneNode *param2_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PlaneNode, 2, "ClipPlaneAttrib.make", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = (ClipPlaneAttrib::make)((ClipPlaneAttrib::Operation)param0, param1_this, param2_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((ClipPlaneAttrib const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2, PlaneNode *plane3)
        int param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        if (PyArg_ParseTuple(args, "iOOO:make", &param0, &param1, &param2, &param3)) {
          PlaneNode *param1_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PlaneNode, 1, "ClipPlaneAttrib.make", false, false);
          PlaneNode *param2_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PlaneNode, 2, "ClipPlaneAttrib.make", false, false);
          PlaneNode *param3_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PlaneNode, 3, "ClipPlaneAttrib.make", false, false);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = (ClipPlaneAttrib::make)((ClipPlaneAttrib::Operation)param0, param1_this, param2_this, param3_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((ClipPlaneAttrib const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 5: {
        // 1-static ConstPointerTo< RenderAttrib > ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2, PlaneNode *plane3, PlaneNode *plane4)
        int param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        if (PyArg_ParseTuple(args, "iOOOO:make", &param0, &param1, &param2, &param3, &param4)) {
          PlaneNode *param1_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PlaneNode, 1, "ClipPlaneAttrib.make", false, false);
          PlaneNode *param2_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PlaneNode, 2, "ClipPlaneAttrib.make", false, false);
          PlaneNode *param3_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PlaneNode, 3, "ClipPlaneAttrib.make", false, false);
          PlaneNode *param4_this = (PlaneNode *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_PlaneNode, 4, "ClipPlaneAttrib.make", false, false);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr && param4_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = (ClipPlaneAttrib::make)((ClipPlaneAttrib::Operation)param0, param1_this, param2_this, param3_this, param4_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((ClipPlaneAttrib const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ClipPlaneAttrib_get_on_planes(PyObject *self, PyObject *) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClipPlaneAttrib, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_on_planes)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ClipPlaneAttrib_get_on_plane_1199(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ClipPlaneAttrib_get_off_planes(PyObject *self, PyObject *) {
  ClipPlaneAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClipPlaneAttrib, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_off_planes)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ClipPlaneAttrib_get_off_plane_1203(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ClipPlaneAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ClipPlaneAttrib) {
    printf("ClipPlaneAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ClipPlaneAttrib *local_this = (ClipPlaneAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ClipPlaneAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ClipPlaneAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ClipPlaneAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ClipPlaneAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (ClipPlaneAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ClipPlaneAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ClipPlaneAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ClipPlaneAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ColorAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorAttrib::make_vertex(void)
 */
static PyObject *Dtool_ColorAttrib_make_vertex_1219(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ColorAttrib::make_vertex(void)
  ConstPointerTo< RenderAttrib > return_value = (ColorAttrib::make_vertex)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ColorAttrib_make_vertex_1219_comment =
  "C++ Interface:\n"
  "make_vertex()\n"
  "\n"
  "/**\n"
  " * Constructs a new ColorAttrib object that indicates geometry should be\n"
  " * rendered according to its own vertex color.\n"
  " */";
#else
static const char *Dtool_ColorAttrib_make_vertex_1219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorAttrib::make_flat(LColor const &color)
 */
static PyObject *Dtool_ColorAttrib_make_flat_1220(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > ColorAttrib::make_flat(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "ColorAttrib.make_flat", "LVecBase4f");
  }
  ConstPointerTo< RenderAttrib > return_value = (ColorAttrib::make_flat)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_flat(const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ColorAttrib_make_flat_1220_comment =
  "C++ Interface:\n"
  "make_flat(const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Constructs a new ColorAttrib object that indicates geometry should be\n"
  " * rendered in the indicated color.\n"
  " */";
#else
static const char *Dtool_ColorAttrib_make_flat_1220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorAttrib::make_off(void)
 */
static PyObject *Dtool_ColorAttrib_make_off_1221(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ColorAttrib::make_off(void)
  ConstPointerTo< RenderAttrib > return_value = (ColorAttrib::make_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ColorAttrib_make_off_1221_comment =
  "C++ Interface:\n"
  "make_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new ColorAttrib object that indicates geometry should be\n"
  " * rendered in white.\n"
  " */";
#else
static const char *Dtool_ColorAttrib_make_off_1221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorAttrib::make_default(void)
 */
static PyObject *Dtool_ColorAttrib_make_default_1222(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ColorAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (ColorAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ColorAttrib_make_default_1222_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_ColorAttrib_make_default_1222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ColorAttrib::Type ColorAttrib::get_color_type(void) const
 */
static PyObject *Dtool_ColorAttrib_get_color_type_1223(PyObject *self, PyObject *) {
  ColorAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorAttrib)) {
    return nullptr;
  }
  // 1-inline ColorAttrib::Type ColorAttrib::get_color_type(void) const
  ColorAttrib::Type return_value = ((*(const ColorAttrib*)local_this).get_color_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorAttrib_get_color_type_1223_comment =
  "C++ Interface:\n"
  "get_color_type(ColorAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the type of color specified by this ColorAttrib.  The options are:\n"
  " *\n"
  " * T_vertex - use the vertex color specified in the geometry itself.\n"
  " *\n"
  " * T_flat - use the color specified in this ColorAttrib for all geometry.  You\n"
  " * can get this color via get_color().\n"
  " *\n"
  " * T_off - use the color white.\n"
  " */";
#else
static const char *Dtool_ColorAttrib_get_color_type_1223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &ColorAttrib::get_color(void) const
 */
static PyObject *Dtool_ColorAttrib_get_color_1224(PyObject *self, PyObject *) {
  ColorAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorAttrib)) {
    return nullptr;
  }
  // 1-inline LColor const &ColorAttrib::get_color(void) const
  LColor const *return_value = &(((*(const ColorAttrib*)local_this).get_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ColorAttrib_get_color_1224_comment =
  "C++ Interface:\n"
  "get_color(ColorAttrib self)\n"
  "\n"
  "/**\n"
  " * If the type is T_flat or T_off, this returns the color that will be applied\n"
  " * to geometry.  If the type is T_vertex, this is meaningless.\n"
  " */";
#else
static const char *Dtool_ColorAttrib_get_color_1224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int ColorAttrib::get_class_slot(void)
 */
static PyObject *Dtool_ColorAttrib_get_class_slot_1227(PyObject *, PyObject *) {
  // 1-static int ColorAttrib::get_class_slot(void)
  int return_value = (ColorAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorAttrib_get_class_slot_1227_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_ColorAttrib_get_class_slot_1227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ColorAttrib::get_class_type(void)
 */
static PyObject *Dtool_ColorAttrib_get_class_type_1229(PyObject *, PyObject *) {
  // 1-static TypeHandle ColorAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ColorAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ColorAttrib_get_class_type_1229_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ColorAttrib_get_class_type_1229_comment = nullptr;
#endif

static PyObject *Dtool_ColorAttrib_color_type_Getter(PyObject *self, void *) {
  const ColorAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ColorAttrib::Type ColorAttrib::get_color_type(void) const
  ColorAttrib::Type return_value = ((*(const ColorAttrib*)local_this).get_color_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ColorAttrib_color_Getter(PyObject *self, void *) {
  const ColorAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor const &ColorAttrib::get_color(void) const
  LColor const *return_value = &(((*(const ColorAttrib*)local_this).get_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static PyObject *Dtool_ColorAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int ColorAttrib::get_class_slot(void)
  int return_value = (ColorAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ColorAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ColorAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ColorAttrib) {
    printf("ColorAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ColorAttrib *local_this = (ColorAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ColorAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ColorAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ColorAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ColorAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (ColorAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ColorAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ColorAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ColorAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ColorBlendAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make_off(void)
 */
static PyObject *Dtool_ColorBlendAttrib_make_off_1234(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make_off(void)
  ConstPointerTo< RenderAttrib > return_value = (ColorBlendAttrib::make_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_make_off_1234_comment =
  "C++ Interface:\n"
  "make_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new ColorBlendAttrib object that disables special-effect\n"
  " * blending, allowing normal transparency to be used instead.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_make_off_1234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make(ColorBlendAttrib::Mode mode)
 * static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make(ColorBlendAttrib::Mode rgb_mode, ColorBlendAttrib::Operand rgb_a, ColorBlendAttrib::Operand rgb_b, ColorBlendAttrib::Mode alpha_mode, ColorBlendAttrib::Operand alpha_a, ColorBlendAttrib::Operand alpha_b, LColor const &color = LColor::zero())
 * static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make(ColorBlendAttrib::Mode mode, ColorBlendAttrib::Operand a, ColorBlendAttrib::Operand b, LColor const &color = LColor::zero())
 */
static PyObject *Dtool_ColorBlendAttrib_make_1235(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "mode")) {
        // 1-static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make(ColorBlendAttrib::Mode mode)
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          ConstPointerTo< RenderAttrib > return_value = (ColorBlendAttrib::make)((ColorBlendAttrib::Mode)arg_val);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 3:
    {
      // 1-static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make(ColorBlendAttrib::Mode mode, ColorBlendAttrib::Operand a, ColorBlendAttrib::Operand b, LColor const &color)
      int param0;
      int param1;
      int param2;
      static const char *keyword_list[] = {"mode", "a", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:make", (char **)keyword_list, &param0, &param1, &param2)) {
        ConstPointerTo< RenderAttrib > return_value = (ColorBlendAttrib::make)((ColorBlendAttrib::Mode)param0, (ColorBlendAttrib::Operand)param1, (ColorBlendAttrib::Operand)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderAttrib const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 4:
    {
      // 1-static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make(ColorBlendAttrib::Mode mode, ColorBlendAttrib::Operand a, ColorBlendAttrib::Operand b, LColor const &color)
      int param0;
      int param1;
      int param2;
      PyObject *param3;
      static const char *keyword_list[] = {"mode", "a", "b", "color", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiO:make", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LVecBase4f param3_local;
        LColor const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "ColorBlendAttrib.make", "LVecBase4f");
        }
        ConstPointerTo< RenderAttrib > return_value = (ColorBlendAttrib::make)((ColorBlendAttrib::Mode)param0, (ColorBlendAttrib::Operand)param1, (ColorBlendAttrib::Operand)param2, *param3_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderAttrib const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 6:
  case 7:
    {
      // 1-static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make(ColorBlendAttrib::Mode rgb_mode, ColorBlendAttrib::Operand rgb_a, ColorBlendAttrib::Operand rgb_b, ColorBlendAttrib::Mode alpha_mode, ColorBlendAttrib::Operand alpha_a, ColorBlendAttrib::Operand alpha_b, LColor const &color = LColor::zero())
      int param0;
      int param1;
      int param2;
      int param3;
      int param4;
      int param5;
      PyObject *param6 = nullptr;
      static const char *keyword_list[] = {"rgb_mode", "rgb_a", "rgb_b", "alpha_mode", "alpha_a", "alpha_b", "color", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiiii|O:make", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        LVecBase4f param6_local;
        LColor const *param6_this;
        if (param6 != nullptr) {
          param6_this = Dtool_Coerce_LVecBase4f(param6, param6_local);
        } else {
          param6_local = LVecBase4f::zero();
          param6_this = &param6_local;
        }
        if (param6 != nullptr && !(param6_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param6, 6, "ColorBlendAttrib.make", "LVecBase4f");
        }
        ConstPointerTo< RenderAttrib > return_value = (ColorBlendAttrib::make)((ColorBlendAttrib::Mode)param0, (ColorBlendAttrib::Operand)param1, (ColorBlendAttrib::Operand)param2, (ColorBlendAttrib::Mode)param3, (ColorBlendAttrib::Operand)param4, (ColorBlendAttrib::Operand)param5, *param6_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderAttrib const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 1, 3, 4, 6 or 7 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int mode)\n"
      "make(int mode, int a, int b)\n"
      "make(int mode, int a, int b, const LVecBase4f color)\n"
      "make(int rgb_mode, int rgb_a, int rgb_b, int alpha_mode, int alpha_a, int alpha_b, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_make_1235_comment =
  "C++ Interface:\n"
  "make(int mode)\n"
  "make(int mode, int a, int b)\n"
  "make(int mode, int a, int b, const LVecBase4f color)\n"
  "make(int rgb_mode, int rgb_a, int rgb_b, int alpha_mode, int alpha_a, int alpha_b, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Constructs a new ColorBlendAttrib object.\n"
  " *\n"
  " * @deprecated Use the three- or four-parameter constructor instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new ColorBlendAttrib object that enables special-effect\n"
  " * blending.  This supercedes transparency.  The given mode and operands are\n"
  " * used for both the RGB and alpha channels.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new ColorBlendAttrib object that enables special-effect\n"
  " * blending.  This supercedes transparency.  This form is used to specify\n"
  " * separate blending parameters for the RGB and alpha channels.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_make_1235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make_default(void)
 */
static PyObject *Dtool_ColorBlendAttrib_make_default_1236(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (ColorBlendAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_make_default_1236_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_make_default_1236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ColorBlendAttrib::Mode ColorBlendAttrib::get_mode(void) const
 */
static PyObject *Dtool_ColorBlendAttrib_get_mode_1237(PyObject *self, PyObject *) {
  ColorBlendAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorBlendAttrib)) {
    return nullptr;
  }
  // 1-inline ColorBlendAttrib::Mode ColorBlendAttrib::get_mode(void) const
  ColorBlendAttrib::Mode return_value = ((*(const ColorBlendAttrib*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_get_mode_1237_comment =
  "C++ Interface:\n"
  "get_mode(ColorBlendAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the blending mode for the RGB channels.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_get_mode_1237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ColorBlendAttrib::Operand ColorBlendAttrib::get_operand_a(void) const
 */
static PyObject *Dtool_ColorBlendAttrib_get_operand_a_1238(PyObject *self, PyObject *) {
  ColorBlendAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorBlendAttrib)) {
    return nullptr;
  }
  // 1-inline ColorBlendAttrib::Operand ColorBlendAttrib::get_operand_a(void) const
  ColorBlendAttrib::Operand return_value = ((*(const ColorBlendAttrib*)local_this).get_operand_a)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_get_operand_a_1238_comment =
  "C++ Interface:\n"
  "get_operand_a(ColorBlendAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the RGB multiplier for the first component.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_get_operand_a_1238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ColorBlendAttrib::Operand ColorBlendAttrib::get_operand_b(void) const
 */
static PyObject *Dtool_ColorBlendAttrib_get_operand_b_1239(PyObject *self, PyObject *) {
  ColorBlendAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorBlendAttrib)) {
    return nullptr;
  }
  // 1-inline ColorBlendAttrib::Operand ColorBlendAttrib::get_operand_b(void) const
  ColorBlendAttrib::Operand return_value = ((*(const ColorBlendAttrib*)local_this).get_operand_b)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_get_operand_b_1239_comment =
  "C++ Interface:\n"
  "get_operand_b(ColorBlendAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the RGB multiplier for the second component.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_get_operand_b_1239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ColorBlendAttrib::Mode ColorBlendAttrib::get_alpha_mode(void) const
 */
static PyObject *Dtool_ColorBlendAttrib_get_alpha_mode_1240(PyObject *self, PyObject *) {
  ColorBlendAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorBlendAttrib)) {
    return nullptr;
  }
  // 1-inline ColorBlendAttrib::Mode ColorBlendAttrib::get_alpha_mode(void) const
  ColorBlendAttrib::Mode return_value = ((*(const ColorBlendAttrib*)local_this).get_alpha_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_get_alpha_mode_1240_comment =
  "C++ Interface:\n"
  "get_alpha_mode(ColorBlendAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the blending mode for the alpha channel.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_get_alpha_mode_1240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ColorBlendAttrib::Operand ColorBlendAttrib::get_alpha_operand_a(void) const
 */
static PyObject *Dtool_ColorBlendAttrib_get_alpha_operand_a_1241(PyObject *self, PyObject *) {
  ColorBlendAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorBlendAttrib)) {
    return nullptr;
  }
  // 1-inline ColorBlendAttrib::Operand ColorBlendAttrib::get_alpha_operand_a(void) const
  ColorBlendAttrib::Operand return_value = ((*(const ColorBlendAttrib*)local_this).get_alpha_operand_a)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_get_alpha_operand_a_1241_comment =
  "C++ Interface:\n"
  "get_alpha_operand_a(ColorBlendAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the alpha multiplier for the first component.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_get_alpha_operand_a_1241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ColorBlendAttrib::Operand ColorBlendAttrib::get_alpha_operand_b(void) const
 */
static PyObject *Dtool_ColorBlendAttrib_get_alpha_operand_b_1242(PyObject *self, PyObject *) {
  ColorBlendAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorBlendAttrib)) {
    return nullptr;
  }
  // 1-inline ColorBlendAttrib::Operand ColorBlendAttrib::get_alpha_operand_b(void) const
  ColorBlendAttrib::Operand return_value = ((*(const ColorBlendAttrib*)local_this).get_alpha_operand_b)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_get_alpha_operand_b_1242_comment =
  "C++ Interface:\n"
  "get_alpha_operand_b(ColorBlendAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the alpha multiplier for the second component.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_get_alpha_operand_b_1242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor ColorBlendAttrib::get_color(void) const
 */
static PyObject *Dtool_ColorBlendAttrib_get_color_1243(PyObject *self, PyObject *) {
  ColorBlendAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorBlendAttrib)) {
    return nullptr;
  }
  // 1-inline LColor ColorBlendAttrib::get_color(void) const
  LColor *return_value = new LColor(((*(const ColorBlendAttrib*)local_this).get_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_get_color_1243_comment =
  "C++ Interface:\n"
  "get_color(ColorBlendAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the constant color associated with the attrib.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_get_color_1243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ColorBlendAttrib::involves_constant_color(void) const
 * static inline bool ColorBlendAttrib::involves_constant_color(ColorBlendAttrib::Operand operand)
 */
static PyObject *Dtool_ColorBlendAttrib_involves_constant_color_1244(PyObject *self, PyObject *args) {
  ColorBlendAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorBlendAttrib)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool ColorBlendAttrib::involves_constant_color(void) const
      bool return_value = ((*(const ColorBlendAttrib*)local_this).involves_constant_color)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-static inline bool ColorBlendAttrib::involves_constant_color(ColorBlendAttrib::Operand operand)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        bool return_value = (ColorBlendAttrib::involves_constant_color)((ColorBlendAttrib::Operand)arg_val);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "involves_constant_color() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "involves_constant_color(ColorBlendAttrib self)\n"
      "involves_constant_color(int operand)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_involves_constant_color_1244_comment =
  "C++ Interface:\n"
  "involves_constant_color(ColorBlendAttrib self)\n"
  "involves_constant_color(int operand)\n"
  "\n"
  "/**\n"
  " * Returns true if the this attrib uses the constant color, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated operand uses the constant color, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_involves_constant_color_1244_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ColorBlendAttrib::involves_color_scale(void) const
 * static inline bool ColorBlendAttrib::involves_color_scale(ColorBlendAttrib::Operand operand)
 */
static PyObject *Dtool_ColorBlendAttrib_involves_color_scale_1245(PyObject *self, PyObject *args) {
  ColorBlendAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorBlendAttrib)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool ColorBlendAttrib::involves_color_scale(void) const
      bool return_value = ((*(const ColorBlendAttrib*)local_this).involves_color_scale)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-static inline bool ColorBlendAttrib::involves_color_scale(ColorBlendAttrib::Operand operand)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        bool return_value = (ColorBlendAttrib::involves_color_scale)((ColorBlendAttrib::Operand)arg_val);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "involves_color_scale() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "involves_color_scale(ColorBlendAttrib self)\n"
      "involves_color_scale(int operand)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_involves_color_scale_1245_comment =
  "C++ Interface:\n"
  "involves_color_scale(ColorBlendAttrib self)\n"
  "involves_color_scale(int operand)\n"
  "\n"
  "/**\n"
  " * Returns true if the this attrib uses the color scale attrib, false\n"
  " * otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated operand uses the color scale attrib, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_ColorBlendAttrib_involves_color_scale_1245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int ColorBlendAttrib::get_class_slot(void)
 */
static PyObject *Dtool_ColorBlendAttrib_get_class_slot_1253(PyObject *, PyObject *) {
  // 1-static int ColorBlendAttrib::get_class_slot(void)
  int return_value = (ColorBlendAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_get_class_slot_1253_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_ColorBlendAttrib_get_class_slot_1253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ColorBlendAttrib::get_class_type(void)
 */
static PyObject *Dtool_ColorBlendAttrib_get_class_type_1255(PyObject *, PyObject *) {
  // 1-static TypeHandle ColorBlendAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ColorBlendAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ColorBlendAttrib_get_class_type_1255_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ColorBlendAttrib_get_class_type_1255_comment = nullptr;
#endif

static PyObject *Dtool_ColorBlendAttrib_rgb_mode_Getter(PyObject *self, void *) {
  const ColorBlendAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorBlendAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ColorBlendAttrib::Mode ColorBlendAttrib::get_mode(void) const
  ColorBlendAttrib::Mode return_value = ((*(const ColorBlendAttrib*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ColorBlendAttrib_rgb_operand_a_Getter(PyObject *self, void *) {
  const ColorBlendAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorBlendAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ColorBlendAttrib::Operand ColorBlendAttrib::get_operand_a(void) const
  ColorBlendAttrib::Operand return_value = ((*(const ColorBlendAttrib*)local_this).get_operand_a)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ColorBlendAttrib_rgb_operand_b_Getter(PyObject *self, void *) {
  const ColorBlendAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorBlendAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ColorBlendAttrib::Operand ColorBlendAttrib::get_operand_b(void) const
  ColorBlendAttrib::Operand return_value = ((*(const ColorBlendAttrib*)local_this).get_operand_b)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ColorBlendAttrib_alpha_mode_Getter(PyObject *self, void *) {
  const ColorBlendAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorBlendAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ColorBlendAttrib::Mode ColorBlendAttrib::get_alpha_mode(void) const
  ColorBlendAttrib::Mode return_value = ((*(const ColorBlendAttrib*)local_this).get_alpha_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ColorBlendAttrib_alpha_operand_a_Getter(PyObject *self, void *) {
  const ColorBlendAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorBlendAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ColorBlendAttrib::Operand ColorBlendAttrib::get_alpha_operand_a(void) const
  ColorBlendAttrib::Operand return_value = ((*(const ColorBlendAttrib*)local_this).get_alpha_operand_a)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ColorBlendAttrib_alpha_operand_b_Getter(PyObject *self, void *) {
  const ColorBlendAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorBlendAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ColorBlendAttrib::Operand ColorBlendAttrib::get_alpha_operand_b(void) const
  ColorBlendAttrib::Operand return_value = ((*(const ColorBlendAttrib*)local_this).get_alpha_operand_b)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ColorBlendAttrib_color_Getter(PyObject *self, void *) {
  const ColorBlendAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorBlendAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor ColorBlendAttrib::get_color(void) const
  LColor *return_value = new LColor(((*(const ColorBlendAttrib*)local_this).get_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static PyObject *Dtool_ColorBlendAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int ColorBlendAttrib::get_class_slot(void)
  int return_value = (ColorBlendAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ColorBlendAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ColorBlendAttrib(PyObject *args, CPT(ColorBlendAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ColorBlendAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make(ColorBlendAttrib::Mode mode)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (ColorBlendAttrib::make)((ColorBlendAttrib::Mode)arg_val);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((ColorBlendAttrib const *) return_value.p());
        return true;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 3: {
        // 1-static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make(ColorBlendAttrib::Mode mode, ColorBlendAttrib::Operand a, ColorBlendAttrib::Operand b, LColor const &color)
        int param0;
        int param1;
        int param2;
        if (PyArg_ParseTuple(args, "iii:make", &param0, &param1, &param2)) {
          ConstPointerTo< RenderAttrib > return_value = (ColorBlendAttrib::make)((ColorBlendAttrib::Mode)param0, (ColorBlendAttrib::Operand)param1, (ColorBlendAttrib::Operand)param2);
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move((ColorBlendAttrib const *) return_value.p());
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make(ColorBlendAttrib::Mode mode, ColorBlendAttrib::Operand a, ColorBlendAttrib::Operand b, LColor const &color)
        int param0;
        int param1;
        int param2;
        PyObject *param3;
        if (PyArg_ParseTuple(args, "iiiO:make", &param0, &param1, &param2, &param3)) {
          LColor const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase4f);
          if (param3_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = (ColorBlendAttrib::make)((ColorBlendAttrib::Mode)param0, (ColorBlendAttrib::Operand)param1, (ColorBlendAttrib::Operand)param2, *param3_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((ColorBlendAttrib const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6:
      case 7: {
        // 1-static ConstPointerTo< RenderAttrib > ColorBlendAttrib::make(ColorBlendAttrib::Mode rgb_mode, ColorBlendAttrib::Operand rgb_a, ColorBlendAttrib::Operand rgb_b, ColorBlendAttrib::Mode alpha_mode, ColorBlendAttrib::Operand alpha_a, ColorBlendAttrib::Operand alpha_b, LColor const &color = LColor::zero())
        int param0;
        int param1;
        int param2;
        int param3;
        int param4;
        int param5;
        PyObject *param6 = nullptr;
        if (PyArg_ParseTuple(args, "iiiiii|O:make", &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
          LColor const *param6_this;
          const LVecBase4f &param6_ref = LVecBase4f::zero();
          if (param6 == nullptr) {
            param6_this = &param6_ref;
          } else {
            param6_this = nullptr;
            DtoolInstance_GetPointer(param6, param6_this, *Dtool_Ptr_LVecBase4f);
          }
          if ((param6 == nullptr || param6_this != nullptr)) {
            ConstPointerTo< RenderAttrib > return_value = (ColorBlendAttrib::make)((ColorBlendAttrib::Mode)param0, (ColorBlendAttrib::Operand)param1, (ColorBlendAttrib::Operand)param2, (ColorBlendAttrib::Mode)param3, (ColorBlendAttrib::Operand)param4, (ColorBlendAttrib::Operand)param5, *param6_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((ColorBlendAttrib const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ColorBlendAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ColorBlendAttrib) {
    printf("ColorBlendAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ColorBlendAttrib *local_this = (ColorBlendAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ColorBlendAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ColorBlendAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ColorBlendAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ColorBlendAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (ColorBlendAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ColorBlendAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ColorBlendAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ColorBlendAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ColorScaleAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorScaleAttrib::make_identity(void)
 */
static PyObject *Dtool_ColorScaleAttrib_make_identity_1258(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ColorScaleAttrib::make_identity(void)
  ConstPointerTo< RenderAttrib > return_value = (ColorScaleAttrib::make_identity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_make_identity_1258_comment =
  "C++ Interface:\n"
  "make_identity()\n"
  "\n"
  "/**\n"
  " * Constructs an identity scale attrib.\n"
  " */";
#else
static const char *Dtool_ColorScaleAttrib_make_identity_1258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorScaleAttrib::make(LVecBase4 const &scale)
 */
static PyObject *Dtool_ColorScaleAttrib_make_1259(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > ColorScaleAttrib::make(LVecBase4 const &scale)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "ColorScaleAttrib.make", "LVecBase4f");
  }
  ConstPointerTo< RenderAttrib > return_value = (ColorScaleAttrib::make)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const LVecBase4f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_make_1259_comment =
  "C++ Interface:\n"
  "make(const LVecBase4f scale)\n"
  "\n"
  "/**\n"
  " * Constructs a new ColorScaleAttrib object that indicates geometry should be\n"
  " * scaled by the indicated factor.\n"
  " */";
#else
static const char *Dtool_ColorScaleAttrib_make_1259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorScaleAttrib::make_off(void)
 */
static PyObject *Dtool_ColorScaleAttrib_make_off_1260(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ColorScaleAttrib::make_off(void)
  ConstPointerTo< RenderAttrib > return_value = (ColorScaleAttrib::make_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_make_off_1260_comment =
  "C++ Interface:\n"
  "make_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new ColorScaleAttrib object that ignores any ColorScaleAttrib\n"
  " * inherited from above.  You may also specify an additional color scale to\n"
  " * apply to geometry below (using set_scale()).\n"
  " */";
#else
static const char *Dtool_ColorScaleAttrib_make_off_1260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorScaleAttrib::make_default(void)
 */
static PyObject *Dtool_ColorScaleAttrib_make_default_1261(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ColorScaleAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (ColorScaleAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_make_default_1261_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_ColorScaleAttrib_make_default_1261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ColorScaleAttrib::is_off(void) const
 */
static PyObject *Dtool_ColorScaleAttrib_is_off_1262(PyObject *self, PyObject *) {
  ColorScaleAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorScaleAttrib)) {
    return nullptr;
  }
  // 1-inline bool ColorScaleAttrib::is_off(void) const
  bool return_value = ((*(const ColorScaleAttrib*)local_this).is_off)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_is_off_1262_comment =
  "C++ Interface:\n"
  "is_off(ColorScaleAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ColorScaleAttrib will ignore any color scales inherited\n"
  " * from above, false otherwise.  This is not the same thing as !has_scale(); a\n"
  " * ColorScaleAttrib may have the \"off\" flag set and also have another scale\n"
  " * specified.\n"
  " */";
#else
static const char *Dtool_ColorScaleAttrib_is_off_1262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ColorScaleAttrib::is_identity(void) const
 */
static PyObject *Dtool_ColorScaleAttrib_is_identity_1263(PyObject *self, PyObject *) {
  ColorScaleAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorScaleAttrib)) {
    return nullptr;
  }
  // 1-inline bool ColorScaleAttrib::is_identity(void) const
  bool return_value = ((*(const ColorScaleAttrib*)local_this).is_identity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_is_identity_1263_comment =
  "C++ Interface:\n"
  "is_identity(ColorScaleAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ColorScaleAttrib is an identity attrib, false if it is\n"
  " * either an off attrib or it has a scale.\n"
  " */";
#else
static const char *Dtool_ColorScaleAttrib_is_identity_1263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ColorScaleAttrib::has_scale(void) const
 */
static PyObject *Dtool_ColorScaleAttrib_has_scale_1264(PyObject *self, PyObject *) {
  ColorScaleAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorScaleAttrib)) {
    return nullptr;
  }
  // 1-inline bool ColorScaleAttrib::has_scale(void) const
  bool return_value = ((*(const ColorScaleAttrib*)local_this).has_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_has_scale_1264_comment =
  "C++ Interface:\n"
  "has_scale(ColorScaleAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ColorScaleAttrib has a non-identity scale, false\n"
  " * otherwise (in which case it might be an off attrib or an identity attrib).\n"
  " */";
#else
static const char *Dtool_ColorScaleAttrib_has_scale_1264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ColorScaleAttrib::has_rgb_scale(void) const
 */
static PyObject *Dtool_ColorScaleAttrib_has_rgb_scale_1265(PyObject *self, PyObject *) {
  ColorScaleAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorScaleAttrib)) {
    return nullptr;
  }
  // 1-inline bool ColorScaleAttrib::has_rgb_scale(void) const
  bool return_value = ((*(const ColorScaleAttrib*)local_this).has_rgb_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_has_rgb_scale_1265_comment =
  "C++ Interface:\n"
  "has_rgb_scale(ColorScaleAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ColorScaleAttrib has a non-identity scale in the RGB\n"
  " * components (ignoring alpha), or false otherwise.\n"
  " */";
#else
static const char *Dtool_ColorScaleAttrib_has_rgb_scale_1265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ColorScaleAttrib::has_alpha_scale(void) const
 */
static PyObject *Dtool_ColorScaleAttrib_has_alpha_scale_1266(PyObject *self, PyObject *) {
  ColorScaleAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorScaleAttrib)) {
    return nullptr;
  }
  // 1-inline bool ColorScaleAttrib::has_alpha_scale(void) const
  bool return_value = ((*(const ColorScaleAttrib*)local_this).has_alpha_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_has_alpha_scale_1266_comment =
  "C++ Interface:\n"
  "has_alpha_scale(ColorScaleAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ColorScaleAttrib has a non-identity scale in the alpha\n"
  " * component (ignoring RGB), or false otherwise.\n"
  " */";
#else
static const char *Dtool_ColorScaleAttrib_has_alpha_scale_1266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &ColorScaleAttrib::get_scale(void) const
 */
static PyObject *Dtool_ColorScaleAttrib_get_scale_1267(PyObject *self, PyObject *) {
  ColorScaleAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorScaleAttrib)) {
    return nullptr;
  }
  // 1-inline LVecBase4 const &ColorScaleAttrib::get_scale(void) const
  LVecBase4 const *return_value = &(((*(const ColorScaleAttrib*)local_this).get_scale)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_get_scale_1267_comment =
  "C++ Interface:\n"
  "get_scale(ColorScaleAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the scale to be applied to colors.\n"
  " */";
#else
static const char *Dtool_ColorScaleAttrib_get_scale_1267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ColorScaleAttrib::set_scale(LVecBase4 const &scale) const
 */
static PyObject *Dtool_ColorScaleAttrib_set_scale_1268(PyObject *self, PyObject *arg) {
  ColorScaleAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorScaleAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ColorScaleAttrib::set_scale(LVecBase4 const &scale) const
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ColorScaleAttrib.set_scale", "LVecBase4f");
  }
  ConstPointerTo< RenderAttrib > return_value = ((*(const ColorScaleAttrib*)local_this).set_scale)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale(ColorScaleAttrib self, const LVecBase4f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_set_scale_1268_comment =
  "C++ Interface:\n"
  "set_scale(ColorScaleAttrib self, const LVecBase4f scale)\n"
  "\n"
  "/**\n"
  " * Returns a new ColorScaleAttrib, just like this one, but with the scale\n"
  " * changed to the indicated value.\n"
  " */";
#else
static const char *Dtool_ColorScaleAttrib_set_scale_1268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int ColorScaleAttrib::get_class_slot(void)
 */
static PyObject *Dtool_ColorScaleAttrib_get_class_slot_1272(PyObject *, PyObject *) {
  // 1-static int ColorScaleAttrib::get_class_slot(void)
  int return_value = (ColorScaleAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_get_class_slot_1272_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_ColorScaleAttrib_get_class_slot_1272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ColorScaleAttrib::get_class_type(void)
 */
static PyObject *Dtool_ColorScaleAttrib_get_class_type_1274(PyObject *, PyObject *) {
  // 1-static TypeHandle ColorScaleAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ColorScaleAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ColorScaleAttrib_get_class_type_1274_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ColorScaleAttrib_get_class_type_1274_comment = nullptr;
#endif

static PyObject *Dtool_ColorScaleAttrib_scale_Getter(PyObject *self, void *) {
  const ColorScaleAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorScaleAttrib, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LVecBase4 const &ColorScaleAttrib::get_scale(void) const
  LVecBase4 const *return_value = &(((*(const ColorScaleAttrib*)local_this).get_scale)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static PyObject *Dtool_ColorScaleAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int ColorScaleAttrib::get_class_slot(void)
  int return_value = (ColorScaleAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ColorScaleAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ColorScaleAttrib(PyObject *args, CPT(ColorScaleAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ColorScaleAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > ColorScaleAttrib::make(LVecBase4 const &scale)
    LVecBase4 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4f);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = (ColorScaleAttrib::make)(*arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((ColorScaleAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ColorScaleAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ColorScaleAttrib) {
    printf("ColorScaleAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ColorScaleAttrib *local_this = (ColorScaleAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ColorScaleAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ColorScaleAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ColorScaleAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ColorScaleAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (ColorScaleAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ColorScaleAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ColorScaleAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ColorScaleAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ColorWriteAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorWriteAttrib::make(unsigned int channels)
 */
static PyObject *Dtool_ColorWriteAttrib_make_1278(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > ColorWriteAttrib::make(unsigned int channels)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param0 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param0);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (ColorWriteAttrib::make)((unsigned int)param0);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int channels)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ColorWriteAttrib_make_1278_comment =
  "C++ Interface:\n"
  "make(int channels)\n"
  "\n"
  "/**\n"
  " * Constructs a new ColorWriteAttrib object.\n"
  " */";
#else
static const char *Dtool_ColorWriteAttrib_make_1278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ColorWriteAttrib::make_default(void)
 */
static PyObject *Dtool_ColorWriteAttrib_make_default_1279(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ColorWriteAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (ColorWriteAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ColorWriteAttrib_make_default_1279_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_ColorWriteAttrib_make_default_1279_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int ColorWriteAttrib::get_channels(void) const
 */
static PyObject *Dtool_ColorWriteAttrib_get_channels_1280(PyObject *self, PyObject *) {
  ColorWriteAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ColorWriteAttrib)) {
    return nullptr;
  }
  // 1-inline unsigned int ColorWriteAttrib::get_channels(void) const
  unsigned int return_value = ((*(const ColorWriteAttrib*)local_this).get_channels)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorWriteAttrib_get_channels_1280_comment =
  "C++ Interface:\n"
  "get_channels(ColorWriteAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the mask of color channels that are enabled by this attrib.\n"
  " */";
#else
static const char *Dtool_ColorWriteAttrib_get_channels_1280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int ColorWriteAttrib::get_class_slot(void)
 */
static PyObject *Dtool_ColorWriteAttrib_get_class_slot_1283(PyObject *, PyObject *) {
  // 1-static int ColorWriteAttrib::get_class_slot(void)
  int return_value = (ColorWriteAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorWriteAttrib_get_class_slot_1283_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_ColorWriteAttrib_get_class_slot_1283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ColorWriteAttrib::get_class_type(void)
 */
static PyObject *Dtool_ColorWriteAttrib_get_class_type_1285(PyObject *, PyObject *) {
  // 1-static TypeHandle ColorWriteAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ColorWriteAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ColorWriteAttrib_get_class_type_1285_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ColorWriteAttrib_get_class_type_1285_comment = nullptr;
#endif

static PyObject *Dtool_ColorWriteAttrib_channels_Getter(PyObject *self, void *) {
  const ColorWriteAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorWriteAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline unsigned int ColorWriteAttrib::get_channels(void) const
  unsigned int return_value = ((*(const ColorWriteAttrib*)local_this).get_channels)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ColorWriteAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int ColorWriteAttrib::get_class_slot(void)
  int return_value = (ColorWriteAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ColorWriteAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ColorWriteAttrib(PyObject *args, CPT(ColorWriteAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ColorWriteAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > ColorWriteAttrib::make(unsigned int channels)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (param0 > UINT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %lu out of range for unsigned integer",
                     param0);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (ColorWriteAttrib::make)((unsigned int)param0);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((ColorWriteAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ColorWriteAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ColorWriteAttrib) {
    printf("ColorWriteAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ColorWriteAttrib *local_this = (ColorWriteAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ColorWriteAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ColorWriteAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ColorWriteAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ColorWriteAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (ColorWriteAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ColorWriteAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ColorWriteAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ColorWriteAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CompassEffect
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > CompassEffect::make(NodePath const &reference, int properties = ::CompassEffect::P_rot)
 */
static PyObject *Dtool_CompassEffect_make_1289(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderEffect > CompassEffect::make(NodePath const &reference, int properties = ::CompassEffect::P_rot)
  PyObject *param0;
  int param1 = CompassEffect::P_rot;
  static const char *keyword_list[] = {"reference", "properties", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:make", (char **)keyword_list, &param0, &param1)) {
    NodePath const *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "CompassEffect.make", true, true);
    if (param0_this != nullptr) {
      ConstPointerTo< RenderEffect > return_value = (CompassEffect::make)(*param0_this, (int)param1);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderEffect const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const NodePath reference, int properties)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CompassEffect_make_1289_comment =
  "C++ Interface:\n"
  "make(const NodePath reference, int properties)\n"
  "\n"
  "/**\n"
  " * Constructs a new CompassEffect object.  If the reference is an empty\n"
  " * NodePath, it means the CompassEffect is relative to the root of the scene\n"
  " * graph; otherwise, it's relative to the indicated node.  The properties\n"
  " * bitmask specifies the set of properties that the compass node inherits from\n"
  " * the reference instead of from its parent.\n"
  " */";
#else
static const char *Dtool_CompassEffect_make_1289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CompassEffect::get_reference(void) const
 */
static PyObject *Dtool_CompassEffect_get_reference_1290(PyObject *self, PyObject *) {
  CompassEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CompassEffect)) {
    return nullptr;
  }
  // 1-inline NodePath const &CompassEffect::get_reference(void) const
  NodePath const *return_value = &(((*(const CompassEffect*)local_this).get_reference)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CompassEffect_get_reference_1290_comment =
  "C++ Interface:\n"
  "get_reference(CompassEffect self)\n"
  "\n"
  "/**\n"
  " * Returns the reference node from which the CompassEffect inherits its\n"
  " * transform.  If this is empty, it means the root of the scene graph.\n"
  " */";
#else
static const char *Dtool_CompassEffect_get_reference_1290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CompassEffect::get_properties(void) const
 */
static PyObject *Dtool_CompassEffect_get_properties_1291(PyObject *self, PyObject *) {
  CompassEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CompassEffect)) {
    return nullptr;
  }
  // 1-inline int CompassEffect::get_properties(void) const
  int return_value = ((*(const CompassEffect*)local_this).get_properties)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CompassEffect_get_properties_1291_comment =
  "C++ Interface:\n"
  "get_properties(CompassEffect self)\n"
  "\n"
  "/**\n"
  " * Returns the bitmask of properties that this CompassEffect object inherits\n"
  " * from its reference node (or from the root).\n"
  " */";
#else
static const char *Dtool_CompassEffect_get_properties_1291_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CompassEffect::get_class_type(void)
 */
static PyObject *Dtool_CompassEffect_get_class_type_1292(PyObject *, PyObject *) {
  // 1-static TypeHandle CompassEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CompassEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CompassEffect_get_class_type_1292_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CompassEffect_get_class_type_1292_comment = nullptr;
#endif

static int Dtool_Init_CompassEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_CompassEffect(PyObject *args, CPT(CompassEffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CompassEffect)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderEffect > CompassEffect::make(NodePath const &reference, int properties)
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderEffect > return_value = (CompassEffect::make)(*arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((CompassEffect const *) return_value.p());
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-static ConstPointerTo< RenderEffect > CompassEffect::make(NodePath const &reference, int properties)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:make", &param0, &param1)) {
        NodePath const *param0_this = nullptr;
        DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NodePath);
        if (param0_this != nullptr) {
          ConstPointerTo< RenderEffect > return_value = (CompassEffect::make)(*param0_this, (int)param1);
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move((CompassEffect const *) return_value.p());
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CompassEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CompassEffect) {
    printf("CompassEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CompassEffect *local_this = (CompassEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CompassEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CompassEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CompassEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CompassEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (CompassEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CompassEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CompassEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CompassEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CullBinEnums
 */
/**
 * Python function wrapper for:
 * inline CullBinEnums::CullBinEnums(void) = default
 * inline CullBinEnums::CullBinEnums(CullBinEnums const &) = default
 */
static int Dtool_Init_CullBinEnums(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CullBinEnums() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline CullBinEnums::CullBinEnums(void) = default
      CullBinEnums *return_value = new CullBinEnums();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CullBinEnums, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CullBinEnums::CullBinEnums(CullBinEnums const &) = default
      CullBinEnums const *arg_this = (CullBinEnums *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CullBinEnums, 0, "CullBinEnums.CullBinEnums", true, true);
      if (arg_this != nullptr) {
        CullBinEnums *return_value = new CullBinEnums(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CullBinEnums, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CullBinEnums() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CullBinEnums()\n"
      "CullBinEnums(const CullBinEnums param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CullBinEnums(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CullBinEnums) {
    printf("CullBinEnums ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CullBinEnums *local_this = (CullBinEnums *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CullBinEnums) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CullBinEnums(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CullBinEnums) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomNode
 */
/**
 * Python function wrapper for:
 * inline void GeomNode::set_preserved(bool value)
 */
static PyObject *Dtool_GeomNode_set_preserved_1300(PyObject *self, PyObject *arg) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomNode, (void **)&local_this, "GeomNode.set_preserved")) {
    return nullptr;
  }
  // 1-inline void GeomNode::set_preserved(bool value)
  ((*local_this).set_preserved)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_preserved(const GeomNode self, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_set_preserved_1300_comment =
  "C++ Interface:\n"
  "set_preserved(const GeomNode self, bool value)\n"
  "\n"
  "/**\n"
  " * Sets the \"preserved\" flag.  When this is true, the GeomNode will be left\n"
  " * untouched by any flatten operations.\n"
  " */";
#else
static const char *Dtool_GeomNode_set_preserved_1300_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomNode::get_preserved(void) const
 */
static PyObject *Dtool_GeomNode_get_preserved_1301(PyObject *self, PyObject *) {
  GeomNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomNode)) {
    return nullptr;
  }
  // 1-inline bool GeomNode::get_preserved(void) const
  bool return_value = ((*(const GeomNode*)local_this).get_preserved)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_get_preserved_1301_comment =
  "C++ Interface:\n"
  "get_preserved(GeomNode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"preserved\" flag.  When this is true, the GeomNode will be left\n"
  " * untouched by any flatten operations.\n"
  " */";
#else
static const char *Dtool_GeomNode_get_preserved_1301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomNode::get_num_geoms(void) const
 */
static PyObject *Dtool_GeomNode_get_num_geoms_1302(PyObject *self, PyObject *) {
  GeomNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomNode)) {
    return nullptr;
  }
  // 1-inline int GeomNode::get_num_geoms(void) const
  int return_value = ((*(const GeomNode*)local_this).get_num_geoms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_get_num_geoms_1302_comment =
  "C++ Interface:\n"
  "get_num_geoms(GeomNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of geoms in the node.\n"
  " */";
#else
static const char *Dtool_GeomNode_get_num_geoms_1302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< Geom > GeomNode::get_geom(int n) const
 */
static PyObject *Dtool_GeomNode_get_geom_1303(PyObject *self, PyObject *arg) {
  GeomNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomNode)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< Geom > GeomNode::get_geom(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< Geom > return_value = ((*(const GeomNode*)local_this).get_geom)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    Geom const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geom(GeomNode self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_get_geom_1303_comment =
  "C++ Interface:\n"
  "get_geom(GeomNode self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth geom of the node.  This object should not be modified,\n"
  " * since the same object might be shared between multiple different GeomNodes,\n"
  " * but see modify_geom().\n"
  " */";
#else
static const char *Dtool_GeomNode_get_geom_1303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Geom > GeomNode::modify_geom(int n)
 */
static PyObject *Dtool_GeomNode_modify_geom_1305(PyObject *self, PyObject *arg) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomNode, (void **)&local_this, "GeomNode.modify_geom")) {
    return nullptr;
  }
  // 1-inline PointerTo< Geom > GeomNode::modify_geom(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< Geom > return_value = ((*local_this).modify_geom)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    Geom *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_geom(const GeomNode self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_modify_geom_1305_comment =
  "C++ Interface:\n"
  "modify_geom(const GeomNode self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth geom of the node, suitable for modifying it.  If the nth\n"
  " * Geom has multiple reference counts to it, reassigns it to an identical copy\n"
  " * first, and returns the new copy--this provides a \"copy on write\" that\n"
  " * ensures that the Geom that is returned is unique to this GeomNode and is\n"
  " * not shared with any other GeomNodes.\n"
  " *\n"
  " * Note that if this method is called in a downstream stage (for instance,\n"
  " * during cull or draw), then it will propagate the new list of Geoms upstream\n"
  " * all the way to pipeline stage 0, which may step on changes that were made\n"
  " * independently in pipeline stage 0. Use with caution.\n"
  " */";
#else
static const char *Dtool_GeomNode_modify_geom_1305_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderState const *GeomNode::get_geom_state(int n) const
 */
static PyObject *Dtool_GeomNode_get_geom_state_1307(PyObject *self, PyObject *arg) {
  GeomNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomNode)) {
    return nullptr;
  }
  // 1-inline RenderState const *GeomNode::get_geom_state(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    RenderState const *return_value = ((*(const GeomNode*)local_this).get_geom_state)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geom_state(GeomNode self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_get_geom_state_1307_comment =
  "C++ Interface:\n"
  "get_geom_state(GeomNode self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the RenderState associated with the nth geom of the node.  This is\n"
  " * just the RenderState directly associated with the Geom; the actual state in\n"
  " * which the Geom is rendered will also be affected by RenderStates that\n"
  " * appear on the scene graph in nodes above this GeomNode.\n"
  " */";
#else
static const char *Dtool_GeomNode_get_geom_state_1307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomNode::set_geom_state(int n, RenderState const *state)
 */
static PyObject *Dtool_GeomNode_set_geom_state_1309(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomNode, (void **)&local_this, "GeomNode.set_geom_state")) {
    return nullptr;
  }
  // 1-inline void GeomNode::set_geom_state(int n, RenderState const *state)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "state", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_geom_state", (char **)keyword_list, &param1, &param2)) {
    CPT(RenderState) param2_this;
    if (!Dtool_ConstCoerce_RenderState(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "GeomNode.set_geom_state", "RenderState");
    }
    ((*local_this).set_geom_state)((int)param1, std::move(param2_this));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_geom_state(const GeomNode self, int n, const RenderState state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_set_geom_state_1309_comment =
  "C++ Interface:\n"
  "set_geom_state(const GeomNode self, int n, const RenderState state)\n"
  "\n"
  "/**\n"
  " * Changes the RenderState associated with the nth geom of the node.  This is\n"
  " * just the RenderState directly associated with the Geom; the actual state in\n"
  " * which the Geom is rendered will also be affected by RenderStates that\n"
  " * appear on the scene graph in nodes above this GeomNode.\n"
  " *\n"
  " * Note that if this method is called in a downstream stage (for instance,\n"
  " * during cull or draw), then it will propagate the new list of Geoms upstream\n"
  " * all the way to pipeline stage 0, which may step on changes that were made\n"
  " * independently in pipeline stage 0. Use with caution.\n"
  " */";
#else
static const char *Dtool_GeomNode_set_geom_state_1309_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomNode::add_geom(Geom *geom, RenderState const *state = RenderState::make_empty())
 */
static PyObject *Dtool_GeomNode_add_geom_1310(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomNode, (void **)&local_this, "GeomNode.add_geom")) {
    return nullptr;
  }
  // 1-void GeomNode::add_geom(Geom *geom, RenderState const *state = RenderState::make_empty())
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"geom", "state", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:add_geom", (char **)keyword_list, &param1, &param2)) {
    Geom *param1_this = (Geom *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Geom, 1, "GeomNode.add_geom", false, true);
    CPT(RenderState) param2_this = RenderState::make_empty();
    if (param2 != nullptr && !Dtool_ConstCoerce_RenderState(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "GeomNode.add_geom", "RenderState");
    }
    if (param1_this != nullptr) {
      ((*local_this).add_geom)(param1_this, std::move(param2_this));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_geom(const GeomNode self, Geom geom, const RenderState state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_add_geom_1310_comment =
  "C++ Interface:\n"
  "add_geom(const GeomNode self, Geom geom, const RenderState state)\n"
  "\n"
  "/**\n"
  " * Adds a new Geom to the node.  The geom is given the indicated state (which\n"
  " * may be RenderState::make_empty(), to completely inherit its state from the\n"
  " * scene graph).\n"
  " */";
#else
static const char *Dtool_GeomNode_add_geom_1310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomNode::add_geoms_from(GeomNode const *other)
 */
static PyObject *Dtool_GeomNode_add_geoms_from_1311(PyObject *self, PyObject *arg) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomNode, (void **)&local_this, "GeomNode.add_geoms_from")) {
    return nullptr;
  }
  // 1-void GeomNode::add_geoms_from(GeomNode const *other)
  GeomNode const *arg_this = (GeomNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomNode, 1, "GeomNode.add_geoms_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_geoms_from)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_geoms_from(const GeomNode self, const GeomNode other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_add_geoms_from_1311_comment =
  "C++ Interface:\n"
  "add_geoms_from(const GeomNode self, const GeomNode other)\n"
  "\n"
  "/**\n"
  " * Copies the Geoms (and their associated RenderStates) from the indicated\n"
  " * GeomNode into this one.\n"
  " */";
#else
static const char *Dtool_GeomNode_add_geoms_from_1311_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomNode::set_geom(int n, Geom *geom)
 */
static PyObject *Dtool_GeomNode_set_geom_1312(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomNode, (void **)&local_this, "GeomNode.set_geom")) {
    return nullptr;
  }
  // 1-void GeomNode::set_geom(int n, Geom *geom)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "geom", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_geom", (char **)keyword_list, &param1, &param2)) {
    Geom *param2_this = (Geom *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Geom, 2, "GeomNode.set_geom", false, true);
    if (param2_this != nullptr) {
      ((*local_this).set_geom)((int)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_geom(const GeomNode self, int n, Geom geom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_set_geom_1312_comment =
  "C++ Interface:\n"
  "set_geom(const GeomNode self, int n, Geom geom)\n"
  "\n"
  "/**\n"
  " * Replaces the nth Geom of the node with a new pointer.  There must already\n"
  " * be a Geom in this slot.\n"
  " *\n"
  " * Note that if this method is called in a downstream stage (for instance,\n"
  " * during cull or draw), then it will propagate the new list of Geoms upstream\n"
  " * all the way to pipeline stage 0, which may step on changes that were made\n"
  " * independently in pipeline stage 0. Use with caution.\n"
  " */";
#else
static const char *Dtool_GeomNode_set_geom_1312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomNode::remove_geom(int n)
 */
static PyObject *Dtool_GeomNode_remove_geom_1313(PyObject *self, PyObject *arg) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomNode, (void **)&local_this, "GeomNode.remove_geom")) {
    return nullptr;
  }
  // 1-inline void GeomNode::remove_geom(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).remove_geom)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_geom(const GeomNode self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_remove_geom_1313_comment =
  "C++ Interface:\n"
  "remove_geom(const GeomNode self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the nth geom from the node.\n"
  " */";
#else
static const char *Dtool_GeomNode_remove_geom_1313_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomNode::remove_all_geoms(void)
 */
static PyObject *Dtool_GeomNode_remove_all_geoms_1314(PyObject *self, PyObject *) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomNode, (void **)&local_this, "GeomNode.remove_all_geoms")) {
    return nullptr;
  }
  // 1-inline void GeomNode::remove_all_geoms(void)
  ((*local_this).remove_all_geoms)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_remove_all_geoms_1314_comment =
  "C++ Interface:\n"
  "remove_all_geoms(const GeomNode self)\n"
  "\n"
  "/**\n"
  " * Removes all the geoms from the node at once.\n"
  " */";
#else
static const char *Dtool_GeomNode_remove_all_geoms_1314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GeomNode::check_valid(void) const
 */
static PyObject *Dtool_GeomNode_check_valid_1315(PyObject *self, PyObject *) {
  GeomNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomNode)) {
    return nullptr;
  }
  // 1-bool GeomNode::check_valid(void) const
  bool return_value = ((*(const GeomNode*)local_this).check_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_check_valid_1315_comment =
  "C++ Interface:\n"
  "check_valid(GeomNode self)\n"
  "\n"
  "/**\n"
  " * Verifies that the each Geom within the GeomNode reference vertices that\n"
  " * actually exist within its GeomVertexData.  Returns true if the GeomNode\n"
  " * appears to be valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_GeomNode_check_valid_1315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomNode::decompose(void)
 */
static PyObject *Dtool_GeomNode_decompose_1316(PyObject *self, PyObject *) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomNode, (void **)&local_this, "GeomNode.decompose")) {
    return nullptr;
  }
  // 1-void GeomNode::decompose(void)
  ((*local_this).decompose)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_decompose_1316_comment =
  "C++ Interface:\n"
  "decompose(const GeomNode self)\n"
  "\n"
  "/**\n"
  " * Calls decompose() on each Geom with the GeomNode.  This decomposes higher-\n"
  " * order primitive types, like triangle strips, into lower-order types like\n"
  " * indexed triangles.  Normally there is no reason to do this, but it can be\n"
  " * useful as an early preprocessing step, to allow a later call to unify() to\n"
  " * proceed more quickly.\n"
  " *\n"
  " * See also SceneGraphReducer::decompose(), which is the normal way this is\n"
  " * called.\n"
  " */";
#else
static const char *Dtool_GeomNode_decompose_1316_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomNode::unify(int max_indices, bool preserve_order)
 */
static PyObject *Dtool_GeomNode_unify_1317(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomNode, (void **)&local_this, "GeomNode.unify")) {
    return nullptr;
  }
  // 1-void GeomNode::unify(int max_indices, bool preserve_order)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"max_indices", "preserve_order", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:unify", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).unify)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unify(const GeomNode self, int max_indices, bool preserve_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_unify_1317_comment =
  "C++ Interface:\n"
  "unify(const GeomNode self, int max_indices, bool preserve_order)\n"
  "\n"
  "/**\n"
  " * Attempts to unify all of the Geoms contained within this node into a single\n"
  " * Geom, or at least as few Geoms as possible.  In turn, the individual\n"
  " * GeomPrimitives contained within each resulting Geom are also unified.  The\n"
  " * goal is to reduce the number of GeomPrimitives within the node as far as\n"
  " * possible.  This may result in composite primitives, such as triangle strips\n"
  " * and triangle fans, being decomposed into triangles.  See also\n"
  " * Geom::unify().\n"
  " *\n"
  " * max_indices represents the maximum number of indices that will be put in\n"
  " * any one GeomPrimitive.  If preserve_order is true, then the primitives will\n"
  " * not be reordered during the operation, even if this results in a suboptimal\n"
  " * result.\n"
  " *\n"
  " * In order for this to be successful, the primitives must reference the same\n"
  " * GeomVertexData, have the same fundamental primitive type, and have\n"
  " * compatible shade models.\n"
  " */";
#else
static const char *Dtool_GeomNode_unify_1317_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomNode::write_geoms(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_GeomNode_write_geoms_1318(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomNode)) {
    return nullptr;
  }
  // 1-void GeomNode::write_geoms(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_geoms", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "GeomNode.write_geoms", false, true);
    if (param1_this != nullptr) {
      ((*(const GeomNode*)local_this).write_geoms)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_geoms(GeomNode self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_write_geoms_1318_comment =
  "C++ Interface:\n"
  "write_geoms(GeomNode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a short description of all the Geoms in the node.\n"
  " */";
#else
static const char *Dtool_GeomNode_write_geoms_1318_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomNode::write_verbose(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_GeomNode_write_verbose_1319(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomNode)) {
    return nullptr;
  }
  // 1-void GeomNode::write_verbose(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_verbose", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "GeomNode.write_verbose", false, true);
    if (param1_this != nullptr) {
      ((*(const GeomNode*)local_this).write_verbose)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_verbose(GeomNode self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_write_verbose_1319_comment =
  "C++ Interface:\n"
  "write_verbose(GeomNode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a detailed description of all the Geoms in the node.\n"
  " */";
#else
static const char *Dtool_GeomNode_write_verbose_1319_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline CollideMask GeomNode::get_default_collide_mask(void)
 */
static PyObject *Dtool_GeomNode_get_default_collide_mask_1320(PyObject *, PyObject *) {
  // 1-static inline CollideMask GeomNode::get_default_collide_mask(void)
  CollideMask *return_value = new CollideMask((GeomNode::get_default_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_get_default_collide_mask_1320_comment =
  "C++ Interface:\n"
  "get_default_collide_mask()\n"
  "\n"
  "/**\n"
  " * Returns the default into_collide_mask assigned to new GeomNodes.\n"
  " */";
#else
static const char *Dtool_GeomNode_get_default_collide_mask_1320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeomNode::get_class_type(void)
 */
static PyObject *Dtool_GeomNode_get_class_type_1322(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomNode_get_class_type_1322_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomNode_get_class_type_1322_comment = nullptr;
#endif

static PyObject *Dtool_GeomNode_default_collide_mask_Getter(PyObject *self, void *) {
  // 1-static inline CollideMask GeomNode::get_default_collide_mask(void)
  CollideMask *return_value = new CollideMask((GeomNode::get_default_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

/**
 * Python function wrapper for:
 * explicit GeomNode::GeomNode(std::string const &name)
 */
static int Dtool_Init_GeomNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeomNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit GeomNode::GeomNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      GeomNode *return_value = new GeomNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomNode(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomNode_get_geoms(PyObject *self, PyObject *) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_geoms)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomNode_get_geom_1303(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomNode_modify_geoms(PyObject *self, PyObject *) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_geoms)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomNode_modify_geom_1305(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomNode_get_geom_states(PyObject *self, PyObject *) {
  GeomNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_geoms)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomNode_get_geom_state_1307(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_GeomNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomNode) {
    printf("GeomNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomNode *local_this = (GeomNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (GeomNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (GeomNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CullBinAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > CullBinAttrib::make(std::string const &bin_name, int draw_order)
 */
static PyObject *Dtool_CullBinAttrib_make_1324(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > CullBinAttrib::make(std::string const &bin_name, int draw_order)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  int param1;
  static const char *keyword_list[] = {"bin_name", "draw_order", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:make", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    ConstPointerTo< RenderAttrib > return_value = (CullBinAttrib::make)(std::string(param0_str, param0_len), (int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(str bin_name, int draw_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinAttrib_make_1324_comment =
  "C++ Interface:\n"
  "make(str bin_name, int draw_order)\n"
  "\n"
  "/**\n"
  " * Constructs a new CullBinAttrib assigning geometry into the named bin.  If\n"
  " * the bin name is the empty string, the default bin is used.\n"
  " *\n"
  " * The draw_order specifies further ordering information which is relevant\n"
  " * only to certain kinds of bins (in particular CullBinFixed type bins).\n"
  " */";
#else
static const char *Dtool_CullBinAttrib_make_1324_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > CullBinAttrib::make_default(void)
 */
static PyObject *Dtool_CullBinAttrib_make_default_1325(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > CullBinAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (CullBinAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CullBinAttrib_make_default_1325_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_CullBinAttrib_make_default_1325_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &CullBinAttrib::get_bin_name(void) const
 */
static PyObject *Dtool_CullBinAttrib_get_bin_name_1326(PyObject *self, PyObject *) {
  CullBinAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinAttrib)) {
    return nullptr;
  }
  // 1-inline std::string const &CullBinAttrib::get_bin_name(void) const
  std::string const &return_value = ((*(const CullBinAttrib*)local_this).get_bin_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullBinAttrib_get_bin_name_1326_comment =
  "C++ Interface:\n"
  "get_bin_name(CullBinAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the bin this attribute specifies.  If this is the empty\n"
  " * string, it refers to the default bin.\n"
  " */";
#else
static const char *Dtool_CullBinAttrib_get_bin_name_1326_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CullBinAttrib::get_draw_order(void) const
 */
static PyObject *Dtool_CullBinAttrib_get_draw_order_1327(PyObject *self, PyObject *) {
  CullBinAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinAttrib)) {
    return nullptr;
  }
  // 1-inline int CullBinAttrib::get_draw_order(void) const
  int return_value = ((*(const CullBinAttrib*)local_this).get_draw_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullBinAttrib_get_draw_order_1327_comment =
  "C++ Interface:\n"
  "get_draw_order(CullBinAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the draw order this attribute specifies.  Some bins (in particular,\n"
  " * CullBinFixed bins) use this to further specify the order in which objects\n"
  " * should be rendered.\n"
  " */";
#else
static const char *Dtool_CullBinAttrib_get_draw_order_1327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int CullBinAttrib::get_class_slot(void)
 */
static PyObject *Dtool_CullBinAttrib_get_class_slot_1330(PyObject *, PyObject *) {
  // 1-static int CullBinAttrib::get_class_slot(void)
  int return_value = (CullBinAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullBinAttrib_get_class_slot_1330_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_CullBinAttrib_get_class_slot_1330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CullBinAttrib::get_class_type(void)
 */
static PyObject *Dtool_CullBinAttrib_get_class_type_1332(PyObject *, PyObject *) {
  // 1-static TypeHandle CullBinAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CullBinAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CullBinAttrib_get_class_type_1332_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CullBinAttrib_get_class_type_1332_comment = nullptr;
#endif

static PyObject *Dtool_CullBinAttrib_bin_name_Getter(PyObject *self, void *) {
  const CullBinAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CullBinAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &CullBinAttrib::get_bin_name(void) const
  std::string const &return_value = ((*(const CullBinAttrib*)local_this).get_bin_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CullBinAttrib_draw_order_Getter(PyObject *self, void *) {
  const CullBinAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CullBinAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int CullBinAttrib::get_draw_order(void) const
  int return_value = ((*(const CullBinAttrib*)local_this).get_draw_order)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CullBinAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int CullBinAttrib::get_class_slot(void)
  int return_value = (CullBinAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_CullBinAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_CullBinAttrib(PyObject *args, CPT(CullBinAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CullBinAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-static ConstPointerTo< RenderAttrib > CullBinAttrib::make(std::string const &bin_name, int draw_order)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      int param1;
      if (PyArg_ParseTuple(args, "s#i:make", &param0_str, &param0_len, &param1)) {
        ConstPointerTo< RenderAttrib > return_value = (CullBinAttrib::make)(std::string(param0_str, param0_len), (int)param1);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move((CullBinAttrib const *) return_value.p());
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CullBinAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CullBinAttrib) {
    printf("CullBinAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CullBinAttrib *local_this = (CullBinAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CullBinAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CullBinAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CullBinAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CullBinAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (CullBinAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CullBinAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CullBinAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CullBinAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CullBinManager
 */
/**
 * Python function wrapper for:
 * int CullBinManager::add_bin(std::string const &name, CullBinManager::BinType type, int sort)
 */
static PyObject *Dtool_CullBinManager_add_bin_1335(PyObject *self, PyObject *args, PyObject *kwds) {
  CullBinManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullBinManager, (void **)&local_this, "CullBinManager.add_bin")) {
    return nullptr;
  }
  // 1-int CullBinManager::add_bin(std::string const &name, CullBinManager::BinType type, int sort)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  int param2;
  int param3;
  static const char *keyword_list[] = {"name", "type", "sort", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#ii:add_bin", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    int return_value = ((*local_this).add_bin)(std::string(param1_str, param1_len), (CullBinManager::BinType)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_bin(const CullBinManager self, str name, int type, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_add_bin_1335_comment =
  "C++ Interface:\n"
  "add_bin(const CullBinManager self, str name, int type, int sort)\n"
  "\n"
  "/**\n"
  " * Defines a new bin with the indicated name, and returns the new bin_index.\n"
  " * If there is already a bin with the same name returns its bin_index if it\n"
  " * had the same properties; otherwise, reports an error and returns -1.\n"
  " */";
#else
static const char *Dtool_CullBinManager_add_bin_1335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CullBinManager::remove_bin(int bin_index)
 */
static PyObject *Dtool_CullBinManager_remove_bin_1336(PyObject *self, PyObject *arg) {
  CullBinManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullBinManager, (void **)&local_this, "CullBinManager.remove_bin")) {
    return nullptr;
  }
  // 1-void CullBinManager::remove_bin(int bin_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).remove_bin)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_bin(const CullBinManager self, int bin_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_remove_bin_1336_comment =
  "C++ Interface:\n"
  "remove_bin(const CullBinManager self, int bin_index)\n"
  "\n"
  "/**\n"
  " * Permanently removes the indicated bin.  This operation is not protected\n"
  " * from the pipeline and will disturb whatever is currently rendering in draw.\n"
  " * You should not call this during the normal course of rendering a frame; it\n"
  " * is intended only as an aid to development, to allow the developer to\n"
  " * interactively fiddle with the set of bins.\n"
  " */";
#else
static const char *Dtool_CullBinManager_remove_bin_1336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CullBinManager::get_num_bins(void) const
 */
static PyObject *Dtool_CullBinManager_get_num_bins_1337(PyObject *self, PyObject *) {
  CullBinManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinManager)) {
    return nullptr;
  }
  // 1-inline int CullBinManager::get_num_bins(void) const
  int return_value = ((*(const CullBinManager*)local_this).get_num_bins)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_get_num_bins_1337_comment =
  "C++ Interface:\n"
  "get_num_bins(CullBinManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bins in the world.\n"
  " */";
#else
static const char *Dtool_CullBinManager_get_num_bins_1337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CullBinManager::get_bin(int n) const
 */
static PyObject *Dtool_CullBinManager_get_bin_1338(PyObject *self, PyObject *arg) {
  CullBinManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinManager)) {
    return nullptr;
  }
  // 1-inline int CullBinManager::get_bin(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const CullBinManager*)local_this).get_bin)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bin(CullBinManager self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_get_bin_1338_comment =
  "C++ Interface:\n"
  "get_bin(CullBinManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the bin_index of the nth bin in the set, where n is a number\n"
  " * between 0 and get_num_bins(). This returns the list of bin_index numbers,\n"
  " * in sorted order (that is, in the order in which the bins should be\n"
  " * rendered).\n"
  " */";
#else
static const char *Dtool_CullBinManager_get_bin_1338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CullBinManager::find_bin(std::string const &name) const
 */
static PyObject *Dtool_CullBinManager_find_bin_1340(PyObject *self, PyObject *arg) {
  CullBinManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinManager)) {
    return nullptr;
  }
  // 1-int CullBinManager::find_bin(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    int return_value = ((*(const CullBinManager*)local_this).find_bin)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_bin(CullBinManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_find_bin_1340_comment =
  "C++ Interface:\n"
  "find_bin(CullBinManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the bin_index associated with the bin of the given name, or -1 if\n"
  " * no bin has that name.\n"
  " */";
#else
static const char *Dtool_CullBinManager_find_bin_1340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string CullBinManager::get_bin_name(int bin_index) const
 */
static PyObject *Dtool_CullBinManager_get_bin_name_1341(PyObject *self, PyObject *arg) {
  CullBinManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinManager)) {
    return nullptr;
  }
  // 1-inline std::string CullBinManager::get_bin_name(int bin_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const CullBinManager*)local_this).get_bin_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bin_name(CullBinManager self, int bin_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_get_bin_name_1341_comment =
  "C++ Interface:\n"
  "get_bin_name(CullBinManager self, int bin_index)\n"
  "\n"
  "/**\n"
  " * Returns the name of the bin with the indicated bin_index (where bin_index\n"
  " * was retrieved by get_bin() or find_bin()).  The bin's name may not be\n"
  " * changed during the life of the bin.\n"
  " */";
#else
static const char *Dtool_CullBinManager_get_bin_name_1341_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CullBinManager::BinType CullBinManager::get_bin_type(int bin_index) const
 * inline CullBinManager::BinType CullBinManager::get_bin_type(std::string const &name) const
 */
static PyObject *Dtool_CullBinManager_get_bin_type_1342(PyObject *self, PyObject *arg) {
  CullBinManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinManager)) {
    return nullptr;
  }
  {
    // -2 inline CullBinManager::BinType CullBinManager::get_bin_type(std::string const &name) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      CullBinManager::BinType return_value = ((*(const CullBinManager*)local_this).get_bin_type)(std::string(param1_str, param1_len));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline CullBinManager::BinType CullBinManager::get_bin_type(int bin_index) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      CullBinManager::BinType return_value = ((*(const CullBinManager*)local_this).get_bin_type)((int)arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline CullBinManager::BinType CullBinManager::get_bin_type(std::string const &name) const
  // No coercion possible: inline CullBinManager::BinType CullBinManager::get_bin_type(int bin_index) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bin_type(CullBinManager self, str name)\n"
      "get_bin_type(CullBinManager self, int bin_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_get_bin_type_1342_comment =
  "C++ Interface:\n"
  "get_bin_type(CullBinManager self, str name)\n"
  "get_bin_type(CullBinManager self, int bin_index)\n"
  "\n"
  "/**\n"
  " * Returns the type of the bin with the indicated bin_index (where bin_index\n"
  " * was retrieved by get_bin() or find_bin()).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the type of the bin with the indicated name.\n"
  " */";
#else
static const char *Dtool_CullBinManager_get_bin_type_1342_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CullBinManager::set_bin_type(int bin_index, CullBinManager::BinType type)
 * inline void CullBinManager::set_bin_type(std::string const &name, CullBinManager::BinType type)
 */
static PyObject *Dtool_CullBinManager_set_bin_type_1343(PyObject *self, PyObject *args, PyObject *kwds) {
  CullBinManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullBinManager, (void **)&local_this, "CullBinManager.set_bin_type")) {
    return nullptr;
  }
  {
    // -2 inline void CullBinManager::set_bin_type(std::string const &name, CullBinManager::BinType type)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    int param2;
    static const char *keyword_list[] = {"name", "type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:set_bin_type", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      ((*local_this).set_bin_type)(std::string(param1_str, param1_len), (CullBinManager::BinType)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 inline void CullBinManager::set_bin_type(int bin_index, CullBinManager::BinType type)
    int param1;
    int param2;
    static const char *keyword_list[] = {"bin_index", "type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_bin_type", (char **)keyword_list, &param1, &param2)) {
      ((*local_this).set_bin_type)((int)param1, (CullBinManager::BinType)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: inline void CullBinManager::set_bin_type(std::string const &name, CullBinManager::BinType type)
  // No coercion possible: inline void CullBinManager::set_bin_type(int bin_index, CullBinManager::BinType type)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin_type(const CullBinManager self, str name, int type)\n"
      "set_bin_type(const CullBinManager self, int bin_index, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_set_bin_type_1343_comment =
  "C++ Interface:\n"
  "set_bin_type(const CullBinManager self, str name, int type)\n"
  "set_bin_type(const CullBinManager self, int bin_index, int type)\n"
  "\n"
  "/**\n"
  " * Changes the type of the bin with the indicated bin_index (where bin_index\n"
  " * was retrieved by get_bin() or find_bin()).\n"
  " *\n"
  " * The change might be effective immediately, or it might take place next\n"
  " * frame, depending on the bin type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the type of the bin with the indicated name.\n"
  " *\n"
  " * The change might be effective immediately, or it might take place next\n"
  " * frame, depending on the bin type.\n"
  " */";
#else
static const char *Dtool_CullBinManager_set_bin_type_1343_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CullBinManager::get_bin_sort(int bin_index) const
 * inline int CullBinManager::get_bin_sort(std::string const &name) const
 */
static PyObject *Dtool_CullBinManager_get_bin_sort_1344(PyObject *self, PyObject *arg) {
  CullBinManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinManager)) {
    return nullptr;
  }
  {
    // -2 inline int CullBinManager::get_bin_sort(std::string const &name) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      int return_value = ((*(const CullBinManager*)local_this).get_bin_sort)(std::string(param1_str, param1_len));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline int CullBinManager::get_bin_sort(int bin_index) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      int return_value = ((*(const CullBinManager*)local_this).get_bin_sort)((int)arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline int CullBinManager::get_bin_sort(std::string const &name) const
  // No coercion possible: inline int CullBinManager::get_bin_sort(int bin_index) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bin_sort(CullBinManager self, str name)\n"
      "get_bin_sort(CullBinManager self, int bin_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_get_bin_sort_1344_comment =
  "C++ Interface:\n"
  "get_bin_sort(CullBinManager self, str name)\n"
  "get_bin_sort(CullBinManager self, int bin_index)\n"
  "\n"
  "/**\n"
  " * Returns the sort order of the bin with the indicated bin_index (where\n"
  " * bin_index was retrieved by get_bin() or find_bin()).\n"
  " *\n"
  " * The bins are rendered in increasing order by their sort order; this number\n"
  " * may be changed from time to time to reorder the bins.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the sort order of the bin with the indicated name.\n"
  " *\n"
  " * The bins are rendered in increasing order by their sort order; this number\n"
  " * may be changed from time to time to reorder the bins.\n"
  " */";
#else
static const char *Dtool_CullBinManager_get_bin_sort_1344_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CullBinManager::set_bin_sort(int bin_index, int sort)
 * inline void CullBinManager::set_bin_sort(std::string const &name, int sort)
 */
static PyObject *Dtool_CullBinManager_set_bin_sort_1345(PyObject *self, PyObject *args, PyObject *kwds) {
  CullBinManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullBinManager, (void **)&local_this, "CullBinManager.set_bin_sort")) {
    return nullptr;
  }
  {
    // -2 inline void CullBinManager::set_bin_sort(std::string const &name, int sort)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    int param2;
    static const char *keyword_list[] = {"name", "sort", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:set_bin_sort", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      ((*local_this).set_bin_sort)(std::string(param1_str, param1_len), (int)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 inline void CullBinManager::set_bin_sort(int bin_index, int sort)
    int param1;
    int param2;
    static const char *keyword_list[] = {"bin_index", "sort", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_bin_sort", (char **)keyword_list, &param1, &param2)) {
      ((*local_this).set_bin_sort)((int)param1, (int)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: inline void CullBinManager::set_bin_sort(std::string const &name, int sort)
  // No coercion possible: inline void CullBinManager::set_bin_sort(int bin_index, int sort)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin_sort(const CullBinManager self, str name, int sort)\n"
      "set_bin_sort(const CullBinManager self, int bin_index, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_set_bin_sort_1345_comment =
  "C++ Interface:\n"
  "set_bin_sort(const CullBinManager self, str name, int sort)\n"
  "set_bin_sort(const CullBinManager self, int bin_index, int sort)\n"
  "\n"
  "/**\n"
  " * Changes the sort order of the bin with the indicated bin_index (where\n"
  " * bin_index was retrieved by get_bin() or find_bin()).\n"
  " *\n"
  " * The bins are rendered in increasing order by their sort order; this number\n"
  " * may be changed from time to time to reorder the bins.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the sort order of the bin with the indicated name.\n"
  " *\n"
  " * The bins are rendered in increasing order by their sort order; this number\n"
  " * may be changed from time to time to reorder the bins.\n"
  " */";
#else
static const char *Dtool_CullBinManager_set_bin_sort_1345_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CullBinManager::get_bin_active(int bin_index) const
 * inline bool CullBinManager::get_bin_active(std::string const &name) const
 */
static PyObject *Dtool_CullBinManager_get_bin_active_1346(PyObject *self, PyObject *arg) {
  CullBinManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinManager)) {
    return nullptr;
  }
  {
    // -2 inline bool CullBinManager::get_bin_active(std::string const &name) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      bool return_value = ((*(const CullBinManager*)local_this).get_bin_active)(std::string(param1_str, param1_len));
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool CullBinManager::get_bin_active(int bin_index) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      bool return_value = ((*(const CullBinManager*)local_this).get_bin_active)((int)arg_val);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: inline bool CullBinManager::get_bin_active(std::string const &name) const
  // No coercion possible: inline bool CullBinManager::get_bin_active(int bin_index) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bin_active(CullBinManager self, str name)\n"
      "get_bin_active(CullBinManager self, int bin_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_get_bin_active_1346_comment =
  "C++ Interface:\n"
  "get_bin_active(CullBinManager self, str name)\n"
  "get_bin_active(CullBinManager self, int bin_index)\n"
  "\n"
  "/**\n"
  " * Returns the active flag of the bin with the indicated bin_index (where\n"
  " * bin_index was retrieved by get_bin() or find_bin()).\n"
  " *\n"
  " * When a bin is marked inactive, all geometry assigned to it is not rendered.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the active flag of the bin with the indicated name.\n"
  " *\n"
  " * When a bin is marked inactive, all geometry assigned to it is not rendered.\n"
  " */";
#else
static const char *Dtool_CullBinManager_get_bin_active_1346_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CullBinManager::set_bin_active(int bin_index, bool active)
 * inline void CullBinManager::set_bin_active(std::string const &name, bool active)
 */
static PyObject *Dtool_CullBinManager_set_bin_active_1347(PyObject *self, PyObject *args, PyObject *kwds) {
  CullBinManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullBinManager, (void **)&local_this, "CullBinManager.set_bin_active")) {
    return nullptr;
  }
  {
    // -2 inline void CullBinManager::set_bin_active(std::string const &name, bool active)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    PyObject *param2;
    static const char *keyword_list[] = {"name", "active", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_bin_active", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      ((*local_this).set_bin_active)(std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 inline void CullBinManager::set_bin_active(int bin_index, bool active)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"bin_index", "active", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bin_active", (char **)keyword_list, &param1, &param2)) {
      ((*local_this).set_bin_active)((int)param1, (PyObject_IsTrue(param2) != 0));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: inline void CullBinManager::set_bin_active(std::string const &name, bool active)
  // No coercion possible: inline void CullBinManager::set_bin_active(int bin_index, bool active)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin_active(const CullBinManager self, str name, bool active)\n"
      "set_bin_active(const CullBinManager self, int bin_index, bool active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_set_bin_active_1347_comment =
  "C++ Interface:\n"
  "set_bin_active(const CullBinManager self, str name, bool active)\n"
  "set_bin_active(const CullBinManager self, int bin_index, bool active)\n"
  "\n"
  "/**\n"
  " * Changes the active flag of the bin with the indicated bin_index (where\n"
  " * bin_index was retrieved by get_bin() or find_bin()).\n"
  " *\n"
  " * When a bin is marked inactive, all geometry assigned to it is not rendered.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the active flag of the bin with the indicated name.\n"
  " *\n"
  " * When a bin is marked inactive, all geometry assigned to it is not rendered.\n"
  " */";
#else
static const char *Dtool_CullBinManager_set_bin_active_1347_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CullBinManager::get_bin_flash_active(int bin_index) const
 */
static PyObject *Dtool_CullBinManager_get_bin_flash_active_1348(PyObject *self, PyObject *arg) {
  CullBinManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinManager)) {
    return nullptr;
  }
  // 1-inline bool CullBinManager::get_bin_flash_active(int bin_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const CullBinManager*)local_this).get_bin_flash_active)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bin_flash_active(CullBinManager self, int bin_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_get_bin_flash_active_1348_comment =
  "C++ Interface:\n"
  "get_bin_flash_active(CullBinManager self, int bin_index)\n"
  "\n"
  "/**\n"
  " * Returns true if the bin with the given bin_index is configured to flash at\n"
  " * a predetermined color (where bin_index was retrieved by get_bin() or\n"
  " * find_bin()).\n"
  " *\n"
  " * This method is not available in release builds.\n"
  " */";
#else
static const char *Dtool_CullBinManager_get_bin_flash_active_1348_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &CullBinManager::get_bin_flash_color(int bin_index) const
 */
static PyObject *Dtool_CullBinManager_get_bin_flash_color_1349(PyObject *self, PyObject *arg) {
  CullBinManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinManager)) {
    return nullptr;
  }
  // 1-inline LColor const &CullBinManager::get_bin_flash_color(int bin_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LColor const *return_value = &(((*(const CullBinManager*)local_this).get_bin_flash_color)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bin_flash_color(CullBinManager self, int bin_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_get_bin_flash_color_1349_comment =
  "C++ Interface:\n"
  "get_bin_flash_color(CullBinManager self, int bin_index)\n"
  "\n"
  "/**\n"
  " * Returns the color that this bin has been configured to flash to, if\n"
  " * configured.\n"
  " *\n"
  " * This method is not available in release builds.\n"
  " */";
#else
static const char *Dtool_CullBinManager_get_bin_flash_color_1349_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CullBinManager::set_bin_flash_active(int bin_index, bool active)
 */
static PyObject *Dtool_CullBinManager_set_bin_flash_active_1350(PyObject *self, PyObject *args, PyObject *kwds) {
  CullBinManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullBinManager, (void **)&local_this, "CullBinManager.set_bin_flash_active")) {
    return nullptr;
  }
  // 1-inline void CullBinManager::set_bin_flash_active(int bin_index, bool active)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"bin_index", "active", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bin_flash_active", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_bin_flash_active)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin_flash_active(const CullBinManager self, int bin_index, bool active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_set_bin_flash_active_1350_comment =
  "C++ Interface:\n"
  "set_bin_flash_active(const CullBinManager self, int bin_index, bool active)\n"
  "\n"
  "/**\n"
  " * When set to true, the given bin_index is configured to flash at a\n"
  " * predetermined color (where bin_index was retrieved by get_bin() or\n"
  " * find_bin()).\n"
  " *\n"
  " * This method is not available in release builds.\n"
  " */";
#else
static const char *Dtool_CullBinManager_set_bin_flash_active_1350_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CullBinManager::set_bin_flash_color(int bin_index, LColor const &color)
 */
static PyObject *Dtool_CullBinManager_set_bin_flash_color_1351(PyObject *self, PyObject *args, PyObject *kwds) {
  CullBinManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullBinManager, (void **)&local_this, "CullBinManager.set_bin_flash_color")) {
    return nullptr;
  }
  // 1-inline void CullBinManager::set_bin_flash_color(int bin_index, LColor const &color)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"bin_index", "color", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bin_flash_color", (char **)keyword_list, &param1, &param2)) {
    LVecBase4f param2_local;
    LColor const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CullBinManager.set_bin_flash_color", "LVecBase4f");
    }
    ((*local_this).set_bin_flash_color)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin_flash_color(const CullBinManager self, int bin_index, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_set_bin_flash_color_1351_comment =
  "C++ Interface:\n"
  "set_bin_flash_color(const CullBinManager self, int bin_index, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Changes the flash color for the given bin index.\n"
  " *\n"
  " * This method is not available in release builds.\n"
  " */";
#else
static const char *Dtool_CullBinManager_set_bin_flash_color_1351_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CullBinManager::write(std::ostream &out) const
 */
static PyObject *Dtool_CullBinManager_write_1352(PyObject *self, PyObject *arg) {
  CullBinManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullBinManager)) {
    return nullptr;
  }
  // 1-void CullBinManager::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CullBinManager.write", false, true);
  if (arg_this != nullptr) {
    ((*(const CullBinManager*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CullBinManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_write_1352_comment =
  "C++ Interface:\n"
  "write(CullBinManager self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CullBinManager_write_1352_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline CullBinManager *CullBinManager::get_global_ptr(void)
 */
static PyObject *Dtool_CullBinManager_get_global_ptr_1353(PyObject *, PyObject *) {
  // 1-static inline CullBinManager *CullBinManager::get_global_ptr(void)
  CullBinManager *return_value = (CullBinManager::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_CullBinManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CullBinManager_get_global_ptr_1353_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the global CullBinManager object.\n"
  " */";
#else
static const char *Dtool_CullBinManager_get_global_ptr_1353_comment = nullptr;
#endif

static int Dtool_Init_CullBinManager(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CullBinManager_get_bins(PyObject *self, PyObject *) {
  CullBinManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CullBinManager, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_bins)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CullBinManager_get_bin_1338(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CullBinManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CullBinManager) {
    printf("CullBinManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CullBinManager *local_this = (CullBinManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CullBinManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CullBinEnums) {
    return (CullBinEnums *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CullBinManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CullBinManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CullBinEnums) {
    CullBinEnums* other_this = (CullBinEnums*)from_this;
    return (CullBinManager*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CullFaceAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > CullFaceAttrib::make(CullFaceAttrib::Mode mode = ::CullFaceAttrib::M_cull_clockwise)
 */
static PyObject *Dtool_CullFaceAttrib_make_1356(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > CullFaceAttrib::make(CullFaceAttrib::Mode mode = ::CullFaceAttrib::M_cull_clockwise)
  int param0 = CullFaceAttrib::M_cull_clockwise;
  static const char *keyword_list[] = {"mode", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:make", (char **)keyword_list, &param0)) {
    ConstPointerTo< RenderAttrib > return_value = (CullFaceAttrib::make)((CullFaceAttrib::Mode)param0);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullFaceAttrib_make_1356_comment =
  "C++ Interface:\n"
  "make(int mode)\n"
  "\n"
  "/**\n"
  " * Constructs a new CullFaceAttrib object that specifies how to cull geometry.\n"
  " * By Panda convention, vertices are ordered counterclockwise when seen from\n"
  " * the front, so the M_cull_clockwise will cull backfacing polygons.\n"
  " *\n"
  " * M_cull_unchanged is an identity attrib; if this is applied to vertices\n"
  " * without any other intervening attrib, it is the same as applying the\n"
  " * default attrib.\n"
  " */";
#else
static const char *Dtool_CullFaceAttrib_make_1356_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > CullFaceAttrib::make_reverse(void)
 */
static PyObject *Dtool_CullFaceAttrib_make_reverse_1357(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > CullFaceAttrib::make_reverse(void)
  ConstPointerTo< RenderAttrib > return_value = (CullFaceAttrib::make_reverse)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CullFaceAttrib_make_reverse_1357_comment =
  "C++ Interface:\n"
  "make_reverse()\n"
  "\n"
  "/**\n"
  " * Constructs a new CullFaceAttrib object that reverses the effects of any\n"
  " * other CullFaceAttrib objects in the scene graph.  M_cull_clockwise will be\n"
  " * treated as M_cull_counter_clockwise, and vice-versa.  M_cull_none is\n"
  " * unchanged.\n"
  " */";
#else
static const char *Dtool_CullFaceAttrib_make_reverse_1357_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > CullFaceAttrib::make_default(void)
 */
static PyObject *Dtool_CullFaceAttrib_make_default_1358(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > CullFaceAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (CullFaceAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CullFaceAttrib_make_default_1358_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_CullFaceAttrib_make_default_1358_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CullFaceAttrib::Mode CullFaceAttrib::get_actual_mode(void) const
 */
static PyObject *Dtool_CullFaceAttrib_get_actual_mode_1359(PyObject *self, PyObject *) {
  CullFaceAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullFaceAttrib)) {
    return nullptr;
  }
  // 1-inline CullFaceAttrib::Mode CullFaceAttrib::get_actual_mode(void) const
  CullFaceAttrib::Mode return_value = ((*(const CullFaceAttrib*)local_this).get_actual_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullFaceAttrib_get_actual_mode_1359_comment =
  "C++ Interface:\n"
  "get_actual_mode(CullFaceAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the actual culling mode, without considering the effects of the\n"
  " * reverse flag.  See also get_effective_mode().\n"
  " */";
#else
static const char *Dtool_CullFaceAttrib_get_actual_mode_1359_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CullFaceAttrib::get_reverse(void) const
 */
static PyObject *Dtool_CullFaceAttrib_get_reverse_1360(PyObject *self, PyObject *) {
  CullFaceAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullFaceAttrib)) {
    return nullptr;
  }
  // 1-inline bool CullFaceAttrib::get_reverse(void) const
  bool return_value = ((*(const CullFaceAttrib*)local_this).get_reverse)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullFaceAttrib_get_reverse_1360_comment =
  "C++ Interface:\n"
  "get_reverse(CullFaceAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the 'reverse' flag.  If this is true, the actual cull direction\n"
  " * (clockwise vs.  counterclockwise) is the reverse of what is specified here.\n"
  " * This allows support for make_reverse(), which defines a CullFaceAttrib that\n"
  " * reverses whatever the sense of culling would have been.\n"
  " */";
#else
static const char *Dtool_CullFaceAttrib_get_reverse_1360_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CullFaceAttrib::Mode CullFaceAttrib::get_effective_mode(void) const
 */
static PyObject *Dtool_CullFaceAttrib_get_effective_mode_1361(PyObject *self, PyObject *) {
  CullFaceAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullFaceAttrib)) {
    return nullptr;
  }
  // 1-CullFaceAttrib::Mode CullFaceAttrib::get_effective_mode(void) const
  CullFaceAttrib::Mode return_value = ((*(const CullFaceAttrib*)local_this).get_effective_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullFaceAttrib_get_effective_mode_1361_comment =
  "C++ Interface:\n"
  "get_effective_mode(CullFaceAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the effective culling mode.  This is the same as the actual culling\n"
  " * mode, unless the reverse flag is set, which swaps CW for CCW and vice-\n"
  " * versa.  Also, M_cull_unchanged is mapped to M_cull_none.\n"
  " */";
#else
static const char *Dtool_CullFaceAttrib_get_effective_mode_1361_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int CullFaceAttrib::get_class_slot(void)
 */
static PyObject *Dtool_CullFaceAttrib_get_class_slot_1365(PyObject *, PyObject *) {
  // 1-static int CullFaceAttrib::get_class_slot(void)
  int return_value = (CullFaceAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullFaceAttrib_get_class_slot_1365_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_CullFaceAttrib_get_class_slot_1365_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CullFaceAttrib::get_class_type(void)
 */
static PyObject *Dtool_CullFaceAttrib_get_class_type_1367(PyObject *, PyObject *) {
  // 1-static TypeHandle CullFaceAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CullFaceAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CullFaceAttrib_get_class_type_1367_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CullFaceAttrib_get_class_type_1367_comment = nullptr;
#endif

static PyObject *Dtool_CullFaceAttrib_mode_Getter(PyObject *self, void *) {
  const CullFaceAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CullFaceAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CullFaceAttrib::Mode CullFaceAttrib::get_actual_mode(void) const
  CullFaceAttrib::Mode return_value = ((*(const CullFaceAttrib*)local_this).get_actual_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CullFaceAttrib_reverse_Getter(PyObject *self, void *) {
  const CullFaceAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CullFaceAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CullFaceAttrib::get_reverse(void) const
  bool return_value = ((*(const CullFaceAttrib*)local_this).get_reverse)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CullFaceAttrib_effective_mode_Getter(PyObject *self, void *) {
  const CullFaceAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CullFaceAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-CullFaceAttrib::Mode CullFaceAttrib::get_effective_mode(void) const
  CullFaceAttrib::Mode return_value = ((*(const CullFaceAttrib*)local_this).get_effective_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CullFaceAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int CullFaceAttrib::get_class_slot(void)
  int return_value = (CullFaceAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_CullFaceAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_CullFaceAttrib(PyObject *args, CPT(CullFaceAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CullFaceAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > CullFaceAttrib::make(CullFaceAttrib::Mode mode)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (CullFaceAttrib::make)((CullFaceAttrib::Mode)arg_val);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((CullFaceAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_CullFaceAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CullFaceAttrib) {
    printf("CullFaceAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CullFaceAttrib *local_this = (CullFaceAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CullFaceAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CullFaceAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CullFaceAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CullFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (CullFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CullFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CullFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CullFaceAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class WorkingNodePath
 */
static PyObject *Dtool_WorkingNodePath_valid_Getter(PyObject *self, void *) {
  const WorkingNodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WorkingNodePath, (void **)&local_this)) {
    return nullptr;
  }

  // 1-bool WorkingNodePath::is_valid(void) const
  bool return_value = ((*(const WorkingNodePath*)local_this).is_valid)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_WorkingNodePath_node_path_Getter(PyObject *self, void *) {
  const WorkingNodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WorkingNodePath, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath WorkingNodePath::get_node_path(void) const
  NodePath *return_value = new NodePath(((*(const WorkingNodePath*)local_this).get_node_path)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

static int Dtool_Init_WorkingNodePath(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_WorkingNodePath(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_WorkingNodePath) {
    printf("WorkingNodePath ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  WorkingNodePath *local_this = (WorkingNodePath *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_WorkingNodePath) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_WorkingNodePath(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_WorkingNodePath) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CullTraverserData
 */
/**
 * Python function wrapper for:
 * inline PandaNode *CullTraverserData::node(void) const
 */
static PyObject *Dtool_CullTraverserData_node_1376(PyObject *self, PyObject *) {
  CullTraverserData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverserData)) {
    return nullptr;
  }
  // 1-inline PandaNode *CullTraverserData::node(void) const
  PandaNode *return_value = ((*(const CullTraverserData*)local_this).node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CullTraverserData_node_1376_comment =
  "C++ Interface:\n"
  "node(CullTraverserData self)\n"
  "\n"
  "/**\n"
  " * Returns the node traversed to so far.\n"
  " */";
#else
static const char *Dtool_CullTraverserData_node_1376_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< TransformState > CullTraverserData::get_modelview_transform(CullTraverser const *trav) const
 */
static PyObject *Dtool_CullTraverserData_get_modelview_transform_1377(PyObject *self, PyObject *arg) {
  CullTraverserData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverserData)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< TransformState > CullTraverserData::get_modelview_transform(CullTraverser const *trav) const
  CullTraverser const *arg_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CullTraverser, 1, "CullTraverserData.get_modelview_transform", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< TransformState > return_value = ((*(const CullTraverserData*)local_this).get_modelview_transform)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_modelview_transform(CullTraverserData self, const CullTraverser trav)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverserData_get_modelview_transform_1377_comment =
  "C++ Interface:\n"
  "get_modelview_transform(CullTraverserData self, const CullTraverser trav)\n"
  "\n"
  "/**\n"
  " * Returns the modelview transform: the relative transform from the camera to\n"
  " * the model.\n"
  " */";
#else
static const char *Dtool_CullTraverserData_get_modelview_transform_1377_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< TransformState > CullTraverserData::get_internal_transform(CullTraverser const *trav) const
 */
static PyObject *Dtool_CullTraverserData_get_internal_transform_1378(PyObject *self, PyObject *arg) {
  CullTraverserData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverserData)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< TransformState > CullTraverserData::get_internal_transform(CullTraverser const *trav) const
  CullTraverser const *arg_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CullTraverser, 1, "CullTraverserData.get_internal_transform", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< TransformState > return_value = ((*(const CullTraverserData*)local_this).get_internal_transform)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformState const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_internal_transform(CullTraverserData self, const CullTraverser trav)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverserData_get_internal_transform_1378_comment =
  "C++ Interface:\n"
  "get_internal_transform(CullTraverserData self, const CullTraverser trav)\n"
  "\n"
  "/**\n"
  " * Returns the internal transform: the modelview transform in the GSG's\n"
  " * internal coordinate system.\n"
  " */";
#else
static const char *Dtool_CullTraverserData_get_internal_transform_1378_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *CullTraverserData::get_net_transform(CullTraverser const *trav) const
 */
static PyObject *Dtool_CullTraverserData_get_net_transform_1379(PyObject *self, PyObject *arg) {
  CullTraverserData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverserData)) {
    return nullptr;
  }
  // 1-inline TransformState const *CullTraverserData::get_net_transform(CullTraverser const *trav) const
  CullTraverser const *arg_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CullTraverser, 1, "CullTraverserData.get_net_transform", true, true);
  if (arg_this != nullptr) {
    TransformState const *return_value = ((*(const CullTraverserData*)local_this).get_net_transform)(arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_transform(CullTraverserData self, const CullTraverser trav)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverserData_get_net_transform_1379_comment =
  "C++ Interface:\n"
  "get_net_transform(CullTraverserData self, const CullTraverser trav)\n"
  "\n"
  "/**\n"
  " * Returns the net transform: the relative transform from root of the scene\n"
  " * graph to the current node.\n"
  " */";
#else
static const char *Dtool_CullTraverserData_get_net_transform_1379_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CullTraverserData::is_in_view(DrawMask const &camera_mask)
 */
static PyObject *Dtool_CullTraverserData_is_in_view_1380(PyObject *self, PyObject *arg) {
  CullTraverserData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullTraverserData, (void **)&local_this, "CullTraverserData.is_in_view")) {
    return nullptr;
  }
  // 1-inline bool CullTraverserData::is_in_view(DrawMask const &camera_mask)
  BitMask< uint32_t, 32 > arg_local;
  DrawMask const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CullTraverserData.is_in_view", "BitMask");
  }
  bool return_value = ((*local_this).is_in_view)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_in_view(const CullTraverserData self, const BitMask camera_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverserData_is_in_view_1380_comment =
  "C++ Interface:\n"
  "is_in_view(const CullTraverserData self, const BitMask camera_mask)\n"
  "\n"
  "/**\n"
  " * Returns true if the current node is within the view frustum, false\n"
  " * otherwise.  If the node's bounding volume falls completely within the view\n"
  " * frustum, this will also reset the view frustum pointer, saving some work\n"
  " * for future nodes.\n"
  " */";
#else
static const char *Dtool_CullTraverserData_is_in_view_1380_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CullTraverserData::is_this_node_hidden(DrawMask const &camera_mask) const
 */
static PyObject *Dtool_CullTraverserData_is_this_node_hidden_1381(PyObject *self, PyObject *arg) {
  CullTraverserData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverserData)) {
    return nullptr;
  }
  // 1-inline bool CullTraverserData::is_this_node_hidden(DrawMask const &camera_mask) const
  BitMask< uint32_t, 32 > arg_local;
  DrawMask const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CullTraverserData.is_this_node_hidden", "BitMask");
  }
  bool return_value = ((*(const CullTraverserData*)local_this).is_this_node_hidden)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_this_node_hidden(CullTraverserData self, const BitMask camera_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverserData_is_this_node_hidden_1381_comment =
  "C++ Interface:\n"
  "is_this_node_hidden(CullTraverserData self, const BitMask camera_mask)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular node is hidden, even though we might be\n"
  " * traversing past this node to find a child node that has had show_through()\n"
  " * called for it.  If this returns true, the node should not be rendered.\n"
  " */";
#else
static const char *Dtool_CullTraverserData_is_this_node_hidden_1381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CullTraverserData::apply_transform_and_state(CullTraverser *trav)
 */
static PyObject *Dtool_CullTraverserData_apply_transform_and_state_1382(PyObject *self, PyObject *arg) {
  CullTraverserData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullTraverserData, (void **)&local_this, "CullTraverserData.apply_transform_and_state")) {
    return nullptr;
  }
  // 1-void CullTraverserData::apply_transform_and_state(CullTraverser *trav)
  CullTraverser *arg_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CullTraverser, 1, "CullTraverserData.apply_transform_and_state", false, true);
  if (arg_this != nullptr) {
    ((*local_this).apply_transform_and_state)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_transform_and_state(const CullTraverserData self, CullTraverser trav)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverserData_apply_transform_and_state_1382_comment =
  "C++ Interface:\n"
  "apply_transform_and_state(const CullTraverserData self, CullTraverser trav)\n"
  "\n"
  "/**\n"
  " * Applies the transform and state from the current node onto the current\n"
  " * data.  This also evaluates billboards, etc.\n"
  " */";
#else
static const char *Dtool_CullTraverserData_apply_transform_and_state_1382_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CullTraverserData::apply_transform(TransformState const *node_transform)
 */
static PyObject *Dtool_CullTraverserData_apply_transform_1383(PyObject *self, PyObject *arg) {
  CullTraverserData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullTraverserData, (void **)&local_this, "CullTraverserData.apply_transform")) {
    return nullptr;
  }
  // 1-void CullTraverserData::apply_transform(TransformState const *node_transform)
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "CullTraverserData.apply_transform", true, true);
  if (arg_this != nullptr) {
    ((*local_this).apply_transform)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_transform(const CullTraverserData self, const TransformState node_transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverserData_apply_transform_1383_comment =
  "C++ Interface:\n"
  "apply_transform(const CullTraverserData self, const TransformState node_transform)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transform changes onto the current data.\n"
  " */";
#else
static const char *Dtool_CullTraverserData_apply_transform_1383_comment = nullptr;
#endif

static PyObject *Dtool_CullTraverserData_node_path_Getter(PyObject *self, void *) {
  const CullTraverserData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CullTraverserData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath CullTraverserData::get_node_path(void) const
  NodePath *return_value = new NodePath(((*(const CullTraverserData*)local_this).get_node_path)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

/**
 * Python function wrapper for:
 * inline CullTraverserData::CullTraverserData(CullTraverserData const &) = default
 */
static int Dtool_Init_CullTraverserData(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CullTraverserData() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline CullTraverserData::CullTraverserData(CullTraverserData const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    CullTraverserData const *param0_this = (CullTraverserData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CullTraverserData, 0, "CullTraverserData.CullTraverserData", true, true);
    if (param0_this != nullptr) {
      CullTraverserData *return_value = new CullTraverserData(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CullTraverserData, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CullTraverserData(const CullTraverserData param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CullTraverserData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CullTraverserData) {
    printf("CullTraverserData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CullTraverserData *local_this = (CullTraverserData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CullTraverserData) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CullTraverserData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CullTraverserData) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SceneSetup
 */
/**
 * Python function wrapper for:
 * inline void SceneSetup::set_display_region(DisplayRegion *display_region)
 */
static PyObject *Dtool_SceneSetup_set_display_region_1389(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_display_region")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_display_region(DisplayRegion *display_region)
  DisplayRegion *arg_this = (DisplayRegion *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DisplayRegion, 1, "SceneSetup.set_display_region", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_display_region)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_display_region(const SceneSetup self, DisplayRegion display_region)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_display_region_1389_comment =
  "C++ Interface:\n"
  "set_display_region(const SceneSetup self, DisplayRegion display_region)\n"
  "\n"
  "/**\n"
  " * Specifies the display region for the scene.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_display_region_1389_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DisplayRegion *SceneSetup::get_display_region(void) const
 */
static PyObject *Dtool_SceneSetup_get_display_region_1390(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline DisplayRegion *SceneSetup::get_display_region(void) const
  DisplayRegion *return_value = ((*(const SceneSetup*)local_this).get_display_region)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DisplayRegion, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_display_region_1390_comment =
  "C++ Interface:\n"
  "get_display_region(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the display region for the scene.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_display_region_1390_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_viewport_size(int width, int height)
 */
static PyObject *Dtool_SceneSetup_set_viewport_size_1391(PyObject *self, PyObject *args, PyObject *kwds) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_viewport_size")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_viewport_size(int width, int height)
  int param1;
  int param2;
  static const char *keyword_list[] = {"width", "height", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_viewport_size", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_viewport_size)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_viewport_size(const SceneSetup self, int width, int height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_viewport_size_1391_comment =
  "C++ Interface:\n"
  "set_viewport_size(const SceneSetup self, int width, int height)\n"
  "\n"
  "/**\n"
  " * Specifies the size of the viewport (display region), in pixels.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_viewport_size_1391_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneSetup::get_viewport_width(void) const
 */
static PyObject *Dtool_SceneSetup_get_viewport_width_1392(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline int SceneSetup::get_viewport_width(void) const
  int return_value = ((*(const SceneSetup*)local_this).get_viewport_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_viewport_width_1392_comment =
  "C++ Interface:\n"
  "get_viewport_width(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the width of the viewport (display region) in pixels.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_viewport_width_1392_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneSetup::get_viewport_height(void) const
 */
static PyObject *Dtool_SceneSetup_get_viewport_height_1393(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline int SceneSetup::get_viewport_height(void) const
  int return_value = ((*(const SceneSetup*)local_this).get_viewport_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_viewport_height_1393_comment =
  "C++ Interface:\n"
  "get_viewport_height(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the height of the viewport (display region) in pixels.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_viewport_height_1393_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_scene_root(NodePath const &scene_root)
 */
static PyObject *Dtool_SceneSetup_set_scene_root_1394(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_scene_root")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_scene_root(NodePath const &scene_root)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "SceneSetup.set_scene_root", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_scene_root)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scene_root(const SceneSetup self, const NodePath scene_root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_scene_root_1394_comment =
  "C++ Interface:\n"
  "set_scene_root(const SceneSetup self, const NodePath scene_root)\n"
  "\n"
  "/**\n"
  " * Specifies the root node of the scene.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_scene_root_1394_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &SceneSetup::get_scene_root(void) const
 */
static PyObject *Dtool_SceneSetup_get_scene_root_1395(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline NodePath const &SceneSetup::get_scene_root(void) const
  NodePath const *return_value = &(((*(const SceneSetup*)local_this).get_scene_root)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_scene_root_1395_comment =
  "C++ Interface:\n"
  "get_scene_root(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the root node of the scene.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_scene_root_1395_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_camera_path(NodePath const &camera_path)
 */
static PyObject *Dtool_SceneSetup_set_camera_path_1396(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_camera_path")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_camera_path(NodePath const &camera_path)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "SceneSetup.set_camera_path", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_camera_path)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera_path(const SceneSetup self, const NodePath camera_path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_camera_path_1396_comment =
  "C++ Interface:\n"
  "set_camera_path(const SceneSetup self, const NodePath camera_path)\n"
  "\n"
  "/**\n"
  " * Specifies the NodePath to the camera.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_camera_path_1396_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &SceneSetup::get_camera_path(void) const
 */
static PyObject *Dtool_SceneSetup_get_camera_path_1397(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline NodePath const &SceneSetup::get_camera_path(void) const
  NodePath const *return_value = &(((*(const SceneSetup*)local_this).get_camera_path)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_camera_path_1397_comment =
  "C++ Interface:\n"
  "get_camera_path(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath to the camera.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_camera_path_1397_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_camera_node(Camera *camera_node)
 */
static PyObject *Dtool_SceneSetup_set_camera_node_1398(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_camera_node")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_camera_node(Camera *camera_node)
  Camera *arg_this = (Camera *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Camera, 1, "SceneSetup.set_camera_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_camera_node)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera_node(const SceneSetup self, Camera camera_node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_camera_node_1398_comment =
  "C++ Interface:\n"
  "set_camera_node(const SceneSetup self, Camera camera_node)\n"
  "\n"
  "/**\n"
  " * Specifies the camera used to render the scene.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_camera_node_1398_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Camera *SceneSetup::get_camera_node(void) const
 */
static PyObject *Dtool_SceneSetup_get_camera_node_1399(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline Camera *SceneSetup::get_camera_node(void) const
  Camera *return_value = ((*(const SceneSetup*)local_this).get_camera_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Camera, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_camera_node_1399_comment =
  "C++ Interface:\n"
  "get_camera_node(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the camera used to render the scene.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_camera_node_1399_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_lens(Lens const *lens)
 */
static PyObject *Dtool_SceneSetup_set_lens_1400(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_lens")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_lens(Lens const *lens)
  Lens const *arg_this = (Lens *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Lens, 1, "SceneSetup.set_lens", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_lens)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lens(const SceneSetup self, const Lens lens)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_lens_1400_comment =
  "C++ Interface:\n"
  "set_lens(const SceneSetup self, const Lens lens)\n"
  "\n"
  "/**\n"
  " * Indicates the particular Lens used for rendering.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_lens_1400_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Lens const *SceneSetup::get_lens(void) const
 */
static PyObject *Dtool_SceneSetup_get_lens_1401(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline Lens const *SceneSetup::get_lens(void) const
  Lens const *return_value = ((*(const SceneSetup*)local_this).get_lens)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Lens, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_lens_1401_comment =
  "C++ Interface:\n"
  "get_lens(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the particular Lens used for rendering.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_lens_1401_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_inverted(bool inverted)
 */
static PyObject *Dtool_SceneSetup_set_inverted_1402(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_inverted")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_inverted(bool inverted)
  ((*local_this).set_inverted)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_inverted(const SceneSetup self, bool inverted)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_inverted_1402_comment =
  "C++ Interface:\n"
  "set_inverted(const SceneSetup self, bool inverted)\n"
  "\n"
  "/**\n"
  " * Changes the current setting of the inverted flag.  When this is true, the\n"
  " * scene is rendered into the window upside-down and backwards, that is,\n"
  " * inverted as if viewed through a mirror placed on the floor.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_inverted_1402_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SceneSetup::get_inverted(void) const
 */
static PyObject *Dtool_SceneSetup_get_inverted_1403(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline bool SceneSetup::get_inverted(void) const
  bool return_value = ((*(const SceneSetup*)local_this).get_inverted)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_inverted_1403_comment =
  "C++ Interface:\n"
  "get_inverted(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the inverted flag.  When this is true, the\n"
  " * scene is rendered into the window upside-down, flipped like a mirror along\n"
  " * the X axis.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_inverted_1403_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &SceneSetup::get_cull_center(void) const
 */
static PyObject *Dtool_SceneSetup_get_cull_center_1404(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline NodePath const &SceneSetup::get_cull_center(void) const
  NodePath const *return_value = &(((*(const SceneSetup*)local_this).get_cull_center)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_cull_center_1404_comment =
  "C++ Interface:\n"
  "get_cull_center(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the point from which the culling operations will be performed.\n"
  " * This is normally the camera, but if camera->set_cull_center() has been\n"
  " * specified, it will be that special node instead.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_cull_center_1404_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< BoundingVolume > SceneSetup::get_cull_bounds(void) const
 */
static PyObject *Dtool_SceneSetup_get_cull_bounds_1405(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline PointerTo< BoundingVolume > SceneSetup::get_cull_bounds(void) const
  PointerTo< BoundingVolume > return_value = ((*(const SceneSetup*)local_this).get_cull_bounds)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  BoundingVolume *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_cull_bounds_1405_comment =
  "C++ Interface:\n"
  "get_cull_bounds(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the bounding volume that should be used to perform view-frustum\n"
  " * culling (in the space of get_cull_center()).  This is normally the current\n"
  " * lens' bounding volume, but it may be overridden with\n"
  " * Camera::set_cull_bounds().\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_cull_bounds_1405_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_view_frustum(PointerTo< GeometricBoundingVolume > view_frustum)
 */
static PyObject *Dtool_SceneSetup_set_view_frustum_1406(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_view_frustum")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_view_frustum(PointerTo< GeometricBoundingVolume > view_frustum)
  GeometricBoundingVolume *arg_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeometricBoundingVolume, 1, "SceneSetup.set_view_frustum", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_view_frustum)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_view_frustum(const SceneSetup self, GeometricBoundingVolume view_frustum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_view_frustum_1406_comment =
  "C++ Interface:\n"
  "set_view_frustum(const SceneSetup self, GeometricBoundingVolume view_frustum)\n"
  "\n"
  "/**\n"
  " * Returns the camera's cull bounds transformed to world space, or null if\n"
  " * view frustum culling is disabled.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_view_frustum_1406_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeometricBoundingVolume *SceneSetup::get_view_frustum(void) const
 */
static PyObject *Dtool_SceneSetup_get_view_frustum_1407(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline GeometricBoundingVolume *SceneSetup::get_view_frustum(void) const
  GeometricBoundingVolume *return_value = ((*(const SceneSetup*)local_this).get_view_frustum)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeometricBoundingVolume, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_view_frustum_1407_comment =
  "C++ Interface:\n"
  "get_view_frustum(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the initial state as set by a previous call to set_initial_state().\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_view_frustum_1407_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_initial_state(RenderState const *initial_state)
 */
static PyObject *Dtool_SceneSetup_set_initial_state_1408(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_initial_state")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_initial_state(RenderState const *initial_state)
  CPT(RenderState) arg_this;
  if (!Dtool_ConstCoerce_RenderState(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SceneSetup.set_initial_state", "RenderState");
  }
  ((*local_this).set_initial_state)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_initial_state(const SceneSetup self, const RenderState initial_state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_initial_state_1408_comment =
  "C++ Interface:\n"
  "set_initial_state(const SceneSetup self, const RenderState initial_state)\n"
  "\n"
  "/**\n"
  " * Sets the initial state which is applied to all nodes in the scene, as if it\n"
  " * were set at the top of the scene graph.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_initial_state_1408_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderState const *SceneSetup::get_initial_state(void) const
 */
static PyObject *Dtool_SceneSetup_get_initial_state_1409(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline RenderState const *SceneSetup::get_initial_state(void) const
  RenderState const *return_value = ((*(const SceneSetup*)local_this).get_initial_state)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_initial_state_1409_comment =
  "C++ Interface:\n"
  "get_initial_state(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the initial state as set by a previous call to set_initial_state().\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_initial_state_1409_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_camera_transform(TransformState const *camera_transform)
 */
static PyObject *Dtool_SceneSetup_set_camera_transform_1410(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_camera_transform")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_camera_transform(TransformState const *camera_transform)
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "SceneSetup.set_camera_transform", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_camera_transform)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera_transform(const SceneSetup self, const TransformState camera_transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_camera_transform_1410_comment =
  "C++ Interface:\n"
  "set_camera_transform(const SceneSetup self, const TransformState camera_transform)\n"
  "\n"
  "/**\n"
  " * Specifies the position of the camera relative to the starting node.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_camera_transform_1410_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *SceneSetup::get_camera_transform(void) const
 */
static PyObject *Dtool_SceneSetup_get_camera_transform_1411(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline TransformState const *SceneSetup::get_camera_transform(void) const
  TransformState const *return_value = ((*(const SceneSetup*)local_this).get_camera_transform)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_camera_transform_1411_comment =
  "C++ Interface:\n"
  "get_camera_transform(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the position of the camera relative to the starting node.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_camera_transform_1411_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_world_transform(TransformState const *world_transform)
 */
static PyObject *Dtool_SceneSetup_set_world_transform_1412(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_world_transform")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_world_transform(TransformState const *world_transform)
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "SceneSetup.set_world_transform", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_world_transform)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_world_transform(const SceneSetup self, const TransformState world_transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_world_transform_1412_comment =
  "C++ Interface:\n"
  "set_world_transform(const SceneSetup self, const TransformState world_transform)\n"
  "\n"
  "/**\n"
  " * Specifies the position of the starting node relative to the camera.  This\n"
  " * is the inverse of the camera transform.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_world_transform_1412_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *SceneSetup::get_world_transform(void) const
 */
static PyObject *Dtool_SceneSetup_get_world_transform_1413(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline TransformState const *SceneSetup::get_world_transform(void) const
  TransformState const *return_value = ((*(const SceneSetup*)local_this).get_world_transform)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_world_transform_1413_comment =
  "C++ Interface:\n"
  "get_world_transform(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the position of the starting node relative to the camera.  This is\n"
  " * the inverse of the camera transform.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_world_transform_1413_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_cs_transform(TransformState const *cs_transform)
 */
static PyObject *Dtool_SceneSetup_set_cs_transform_1414(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_cs_transform")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_cs_transform(TransformState const *cs_transform)
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "SceneSetup.set_cs_transform", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cs_transform)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cs_transform(const SceneSetup self, const TransformState cs_transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_cs_transform_1414_comment =
  "C++ Interface:\n"
  "set_cs_transform(const SceneSetup self, const TransformState cs_transform)\n"
  "\n"
  "/**\n"
  " * Specifies the transform from the camera's coordinate system to the GSG's\n"
  " * internal coordinate system.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_cs_transform_1414_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *SceneSetup::get_cs_transform(void) const
 */
static PyObject *Dtool_SceneSetup_get_cs_transform_1415(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline TransformState const *SceneSetup::get_cs_transform(void) const
  TransformState const *return_value = ((*(const SceneSetup*)local_this).get_cs_transform)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_cs_transform_1415_comment =
  "C++ Interface:\n"
  "get_cs_transform(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the transform from the camera's coordinate system to the GSG's\n"
  " * internal coordinate system.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_cs_transform_1415_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneSetup::set_cs_world_transform(TransformState const *cs_world_transform)
 */
static PyObject *Dtool_SceneSetup_set_cs_world_transform_1416(PyObject *self, PyObject *arg) {
  SceneSetup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneSetup, (void **)&local_this, "SceneSetup.set_cs_world_transform")) {
    return nullptr;
  }
  // 1-inline void SceneSetup::set_cs_world_transform(TransformState const *cs_world_transform)
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "SceneSetup.set_cs_world_transform", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cs_world_transform)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cs_world_transform(const SceneSetup self, const TransformState cs_world_transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_set_cs_world_transform_1416_comment =
  "C++ Interface:\n"
  "set_cs_world_transform(const SceneSetup self, const TransformState cs_world_transform)\n"
  "\n"
  "/**\n"
  " * Specifies the position from the starting node relative to the camera, in\n"
  " * the GSG's internal coordinate system.\n"
  " */";
#else
static const char *Dtool_SceneSetup_set_cs_world_transform_1416_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *SceneSetup::get_cs_world_transform(void) const
 */
static PyObject *Dtool_SceneSetup_get_cs_world_transform_1417(PyObject *self, PyObject *) {
  SceneSetup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneSetup)) {
    return nullptr;
  }
  // 1-inline TransformState const *SceneSetup::get_cs_world_transform(void) const
  TransformState const *return_value = ((*(const SceneSetup*)local_this).get_cs_world_transform)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_cs_world_transform_1417_comment =
  "C++ Interface:\n"
  "get_cs_world_transform(SceneSetup self)\n"
  "\n"
  "/**\n"
  " * Returns the position from the starting node relative to the camera, in the\n"
  " * GSG's internal coordinate system.\n"
  " */";
#else
static const char *Dtool_SceneSetup_get_cs_world_transform_1417_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SceneSetup::get_class_type(void)
 */
static PyObject *Dtool_SceneSetup_get_class_type_1418(PyObject *, PyObject *) {
  // 1-static TypeHandle SceneSetup::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((SceneSetup::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SceneSetup_get_class_type_1418_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SceneSetup_get_class_type_1418_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SceneSetup::SceneSetup(SceneSetup const &) = default
 */
static int Dtool_Init_SceneSetup(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("SceneSetup() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline SceneSetup::SceneSetup(SceneSetup const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    SceneSetup const *param0_this = (SceneSetup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_SceneSetup, 0, "SceneSetup.SceneSetup", true, true);
    if (param0_this != nullptr) {
      SceneSetup *return_value = new SceneSetup(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SceneSetup, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SceneSetup(const SceneSetup param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SceneSetup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SceneSetup) {
    printf("SceneSetup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SceneSetup *local_this = (SceneSetup *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SceneSetup) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SceneSetup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SceneSetup) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SceneSetup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SceneSetup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (SceneSetup*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Fog
 */
/**
 * Python function wrapper for:
 * inline Fog::Mode Fog::get_mode(void) const
 */
static PyObject *Dtool_Fog_get_mode_1424(PyObject *self, PyObject *) {
  Fog *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Fog)) {
    return nullptr;
  }
  // 1-inline Fog::Mode Fog::get_mode(void) const
  Fog::Mode return_value = ((*(const Fog*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Fog_get_mode_1424_comment =
  "C++ Interface:\n"
  "get_mode(Fog self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Fog_get_mode_1424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Fog::set_mode(Fog::Mode mode)
 */
static PyObject *Dtool_Fog_set_mode_1425(PyObject *self, PyObject *arg) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.set_mode")) {
    return nullptr;
  }
  // 1-inline void Fog::set_mode(Fog::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_mode)((Fog::Mode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mode(const Fog self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Fog_set_mode_1425_comment =
  "C++ Interface:\n"
  "set_mode(const Fog self, int mode)\n"
  "\n"
  "/**\n"
  " * Specifies the computation that is used to determine the fog effect.  If\n"
  " * this is M_linear, then the fog will range from linearly from the onset\n"
  " * point to the opaque point (or for the distances specified in\n"
  " * set_linear_range), and the fog object should be parented into the scene\n"
  " * graph, or to the camera.\n"
  " *\n"
  " * If this is anything else, the onset point and opaque point are not used,\n"
  " * and the fog effect is based on the value specified to set_exp_density(),\n"
  " * and it doesn't matter to which node the fog object is parented, or if it is\n"
  " * parented anywhere at all.\n"
  " */";
#else
static const char *Dtool_Fog_set_mode_1425_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &Fog::get_color(void) const
 */
static PyObject *Dtool_Fog_get_color_1427(PyObject *self, PyObject *) {
  Fog *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Fog)) {
    return nullptr;
  }
  // 1-inline LColor const &Fog::get_color(void) const
  LColor const *return_value = &(((*(const Fog*)local_this).get_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Fog_get_color_1427_comment =
  "C++ Interface:\n"
  "get_color(Fog self)\n"
  "\n"
  "/**\n"
  " * Returns the color of the fog.\n"
  " */";
#else
static const char *Dtool_Fog_get_color_1427_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Fog::set_color(LColor const &color)
 * inline void Fog::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b)
 */
static PyObject *Dtool_Fog_set_color_1428(PyObject *self, PyObject *args, PyObject *kwds) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.set_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "color")) {
        // 1-inline void Fog::set_color(LColor const &color)
        LVecBase4f arg_local;
        LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "Fog.set_color", "LVecBase4f");
        }
        ((*local_this).set_color)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void Fog::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"r", "g", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_color", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_color)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const Fog self, const LVecBase4f color)\n"
      "set_color(const Fog self, float r, float g, float b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Fog_set_color_1428_comment =
  "C++ Interface:\n"
  "set_color(const Fog self, const LVecBase4f color)\n"
  "set_color(const Fog self, float r, float g, float b)\n"
  "\n"
  "/**\n"
  " * Sets the color of the fog.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the color of the fog.  The alpha component is not used.\n"
  " */";
#else
static const char *Dtool_Fog_set_color_1428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Fog::set_linear_range(PN_stdfloat onset, PN_stdfloat opaque)
 */
static PyObject *Dtool_Fog_set_linear_range_1430(PyObject *self, PyObject *args, PyObject *kwds) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.set_linear_range")) {
    return nullptr;
  }
  // 1-inline void Fog::set_linear_range(PN_stdfloat onset, PN_stdfloat opaque)
  float param1;
  float param2;
  static const char *keyword_list[] = {"onset", "opaque", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_linear_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_linear_range)((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_linear_range(const Fog self, float onset, float opaque)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Fog_set_linear_range_1430_comment =
  "C++ Interface:\n"
  "set_linear_range(const Fog self, float onset, float opaque)\n"
  "\n"
  "/**\n"
  " * Specifies the effects of the fog in linear distance units.  This is only\n"
  " * used if the mode is M_linear.\n"
  " *\n"
  " * This specifies a fog that begins at distance onset units from the origin,\n"
  " * and becomes totally opaque at distance opaque units from the origin, along\n"
  " * the forward axis (usually Y).\n"
  " *\n"
  " * This function also implicitly sets the mode the M_linear, if it is not\n"
  " * already set.\n"
  " */";
#else
static const char *Dtool_Fog_set_linear_range_1430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &Fog::get_linear_onset_point(void) const
 */
static PyObject *Dtool_Fog_get_linear_onset_point_1431(PyObject *self, PyObject *) {
  Fog *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Fog)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &Fog::get_linear_onset_point(void) const
  LPoint3 const *return_value = &(((*(const Fog*)local_this).get_linear_onset_point)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Fog_get_linear_onset_point_1431_comment =
  "C++ Interface:\n"
  "get_linear_onset_point(Fog self)\n"
  "\n"
  "/**\n"
  " * Returns the point in space at which the fog begins.  This is only used if\n"
  " * the mode is M_linear.\n"
  " */";
#else
static const char *Dtool_Fog_get_linear_onset_point_1431_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Fog::set_linear_onset_point(LPoint3 const &linear_onset_point)
 * inline void Fog::set_linear_onset_point(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_Fog_set_linear_onset_point_1432(PyObject *self, PyObject *args, PyObject *kwds) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.set_linear_onset_point")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "linear_onset_point")) {
        // 1-inline void Fog::set_linear_onset_point(LPoint3 const &linear_onset_point)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "Fog.set_linear_onset_point", "LPoint3f");
        }
        ((*local_this).set_linear_onset_point)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void Fog::set_linear_onset_point(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_linear_onset_point", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_linear_onset_point)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_linear_onset_point() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_linear_onset_point(const Fog self, const LPoint3f linear_onset_point)\n"
      "set_linear_onset_point(const Fog self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Fog_set_linear_onset_point_1432_comment =
  "C++ Interface:\n"
  "set_linear_onset_point(const Fog self, const LPoint3f linear_onset_point)\n"
  "set_linear_onset_point(const Fog self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Specifies the point in space at which the fog begins.  This is only used if\n"
  " * the mode is M_linear.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies the point in space at which the fog begins.  This is only used if\n"
  " * the mode is M_linear.\n"
  " */";
#else
static const char *Dtool_Fog_set_linear_onset_point_1432_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &Fog::get_linear_opaque_point(void) const
 */
static PyObject *Dtool_Fog_get_linear_opaque_point_1434(PyObject *self, PyObject *) {
  Fog *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Fog)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &Fog::get_linear_opaque_point(void) const
  LPoint3 const *return_value = &(((*(const Fog*)local_this).get_linear_opaque_point)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Fog_get_linear_opaque_point_1434_comment =
  "C++ Interface:\n"
  "get_linear_opaque_point(Fog self)\n"
  "\n"
  "/**\n"
  " * Returns the point in space at which the fog completely obscures geometry.\n"
  " * This is only used if the mode is M_linear.\n"
  " */";
#else
static const char *Dtool_Fog_get_linear_opaque_point_1434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Fog::set_linear_opaque_point(LPoint3 const &linear_opaque_point)
 * inline void Fog::set_linear_opaque_point(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_Fog_set_linear_opaque_point_1435(PyObject *self, PyObject *args, PyObject *kwds) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.set_linear_opaque_point")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "linear_opaque_point")) {
        // 1-inline void Fog::set_linear_opaque_point(LPoint3 const &linear_opaque_point)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "Fog.set_linear_opaque_point", "LPoint3f");
        }
        ((*local_this).set_linear_opaque_point)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void Fog::set_linear_opaque_point(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_linear_opaque_point", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_linear_opaque_point)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_linear_opaque_point() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_linear_opaque_point(const Fog self, const LPoint3f linear_opaque_point)\n"
      "set_linear_opaque_point(const Fog self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Fog_set_linear_opaque_point_1435_comment =
  "C++ Interface:\n"
  "set_linear_opaque_point(const Fog self, const LPoint3f linear_opaque_point)\n"
  "set_linear_opaque_point(const Fog self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Specifies the point in space at which the fog completely obscures geometry.\n"
  " * This is only used if the mode is M_linear.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies the point in space at which the fog completely obscures geometry.\n"
  " * This is only used if the mode is M_linear.\n"
  " */";
#else
static const char *Dtool_Fog_set_linear_opaque_point_1435_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Fog::set_linear_fallback(PN_stdfloat angle, PN_stdfloat onset, PN_stdfloat opaque)
 */
static PyObject *Dtool_Fog_set_linear_fallback_1437(PyObject *self, PyObject *args, PyObject *kwds) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.set_linear_fallback")) {
    return nullptr;
  }
  // 1-inline void Fog::set_linear_fallback(PN_stdfloat angle, PN_stdfloat onset, PN_stdfloat opaque)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"angle", "onset", "opaque", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_linear_fallback", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_linear_fallback)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_linear_fallback(const Fog self, float angle, float onset, float opaque)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Fog_set_linear_fallback_1437_comment =
  "C++ Interface:\n"
  "set_linear_fallback(const Fog self, float angle, float onset, float opaque)\n"
  "\n"
  "/**\n"
  " * Fog effects are traditionally defined in camera-relative space, but the\n"
  " * Panda Fog node has a special mode in which it can define a linear fog\n"
  " * effect in an arbitrary coordinate space.\n"
  " *\n"
  " * This is done by specifying 3-d onset and opaque points, and parenting the\n"
  " * Fog object somewhere within the scene graph.  In this mode, the fog will be\n"
  " * rendered as if it extended along the vector from the onset point to the\n"
  " * opaque point, in 3-d space.\n"
  " *\n"
  " * However, the underlying fog effect supported by hardware is generally only\n"
  " * one-dimensional, and must be rendered based on linear distance from the\n"
  " * camera plane.  Thus, this in-the-world effect is most effective when the\n"
  " * fog vector from onset point to opaque point is most nearly parallel to the\n"
  " * camera's eye vector.\n"
  " *\n"
  " * As the angle between the fog vector and the eye vector increases, the\n"
  " * accuracy of the effect diminishes, up to a complete breakdown of the effect\n"
  " * at a 90 degree angle.\n"
  " *\n"
  " * This function exists to define the workaround to this problem.  The linear\n"
  " * fallback parameters given here specify how the fog should be rendered when\n"
  " * the parameters are exceeded in this way.\n"
  " *\n"
  " * The angle parameter is the minimum angle, in degrees, of the fog vector to\n"
  " * the eye vector, at which the fallback effect should be employed.  The onset\n"
  " * and opaque parameters specify the camera-relative onset and opaque\n"
  " * distances to pass to the rendering hardware when employing the fallback\n"
  " * effect.  This supercedes the 3-d onset point and opaque points.\n"
  " */";
#else
static const char *Dtool_Fog_set_linear_fallback_1437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Fog::get_exp_density(void) const
 */
static PyObject *Dtool_Fog_get_exp_density_1438(PyObject *self, PyObject *) {
  Fog *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Fog)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Fog::get_exp_density(void) const
  PN_stdfloat return_value = ((*(const Fog*)local_this).get_exp_density)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Fog_get_exp_density_1438_comment =
  "C++ Interface:\n"
  "get_exp_density(Fog self)\n"
  "\n"
  "/**\n"
  " * Returns the density of the fog for exponential calculations.  This is only\n"
  " * used if the mode is not M_linear.\n"
  " */";
#else
static const char *Dtool_Fog_get_exp_density_1438_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Fog::set_exp_density(PN_stdfloat exp_density)
 */
static PyObject *Dtool_Fog_set_exp_density_1439(PyObject *self, PyObject *arg) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.set_exp_density")) {
    return nullptr;
  }
  // 1-inline void Fog::set_exp_density(PN_stdfloat exp_density)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_exp_density)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_exp_density(const Fog self, float exp_density)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Fog_set_exp_density_1439_comment =
  "C++ Interface:\n"
  "set_exp_density(const Fog self, float exp_density)\n"
  "\n"
  "/**\n"
  " * Sets the density of the fog for exponential calculations.  This is only\n"
  " * used if the mode is not M_linear.\n"
  " *\n"
  " * If the mode is currently set to M_linear, this function implicitly sets it\n"
  " * to M_exponential.\n"
  " */";
#else
static const char *Dtool_Fog_set_exp_density_1439_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Fog::get_class_type(void)
 */
static PyObject *Dtool_Fog_get_class_type_1441(PyObject *, PyObject *) {
  // 1-static TypeHandle Fog::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Fog::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Fog_get_class_type_1441_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Fog_get_class_type_1441_comment = nullptr;
#endif

static PyObject *Dtool_Fog_mode_Getter(PyObject *self, void *) {
  const Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Fog, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Fog::Mode Fog::get_mode(void) const
  Fog::Mode return_value = ((*(const Fog*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Fog_mode_Setter(PyObject *self, PyObject *arg, void *) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete mode attribute");
    return -1;
  }
  // 1-inline void Fog::set_mode(Fog::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_mode)((Fog::Mode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_mode(const Fog self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_Fog_color_Getter(PyObject *self, void *) {
  const Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Fog, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor const &Fog::get_color(void) const
  LColor const *return_value = &(((*(const Fog*)local_this).get_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_Fog_color_Setter(PyObject *self, PyObject *arg, void *) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete color attribute");
    return -1;
  }
  // 1-inline void Fog::set_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Fog.set_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_color(const Fog self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_Fog_linear_onset_point_Getter(PyObject *self, void *) {
  const Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Fog, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &Fog::get_linear_onset_point(void) const
  LPoint3 const *return_value = &(((*(const Fog*)local_this).get_linear_onset_point)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_Fog_linear_onset_point_Setter(PyObject *self, PyObject *arg, void *) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.linear_onset_point")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete linear_onset_point attribute");
    return -1;
  }
  // 1-inline void Fog::set_linear_onset_point(LPoint3 const &linear_onset_point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Fog.set_linear_onset_point", "LPoint3f");
    return -1;
  }
  ((*local_this).set_linear_onset_point)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_linear_onset_point(const Fog self, const LPoint3f linear_onset_point)\n");
  }
  return -1;
}

static PyObject *Dtool_Fog_linear_opaque_point_Getter(PyObject *self, void *) {
  const Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Fog, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &Fog::get_linear_opaque_point(void) const
  LPoint3 const *return_value = &(((*(const Fog*)local_this).get_linear_opaque_point)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_Fog_linear_opaque_point_Setter(PyObject *self, PyObject *arg, void *) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.linear_opaque_point")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete linear_opaque_point attribute");
    return -1;
  }
  // 1-inline void Fog::set_linear_opaque_point(LPoint3 const &linear_opaque_point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Fog.set_linear_opaque_point", "LPoint3f");
    return -1;
  }
  ((*local_this).set_linear_opaque_point)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_linear_opaque_point(const Fog self, const LPoint3f linear_opaque_point)\n");
  }
  return -1;
}

static PyObject *Dtool_Fog_exp_density_Getter(PyObject *self, void *) {
  const Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Fog, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Fog::get_exp_density(void) const
  PN_stdfloat return_value = ((*(const Fog*)local_this).get_exp_density)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Fog_exp_density_Setter(PyObject *self, PyObject *arg, void *) {
  Fog *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Fog, (void **)&local_this, "Fog.exp_density")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete exp_density attribute");
    return -1;
  }
  // 1-inline void Fog::set_exp_density(PN_stdfloat exp_density)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_exp_density)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_exp_density(const Fog self, float exp_density)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit Fog::Fog(std::string const &name)
 */
static int Dtool_Init_Fog(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Fog() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit Fog::Fog(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      Fog *return_value = new Fog(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Fog, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Fog(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Fog(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Fog) {
    printf("Fog ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Fog *local_this = (Fog *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Fog) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Fog(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Fog) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Fog*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (Fog*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Fog*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Fog*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Fog*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Fog*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class FogAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > FogAttrib::make(Fog *fog)
 */
static PyObject *Dtool_FogAttrib_make_1443(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > FogAttrib::make(Fog *fog)
  Fog *arg_this = (Fog *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Fog, 0, "FogAttrib.make", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = (FogAttrib::make)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(Fog fog)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FogAttrib_make_1443_comment =
  "C++ Interface:\n"
  "make(Fog fog)\n"
  "\n"
  "/**\n"
  " * Constructs a new FogAttrib object suitable for rendering the indicated fog\n"
  " * onto geometry.\n"
  " */";
#else
static const char *Dtool_FogAttrib_make_1443_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > FogAttrib::make_off(void)
 */
static PyObject *Dtool_FogAttrib_make_off_1444(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > FogAttrib::make_off(void)
  ConstPointerTo< RenderAttrib > return_value = (FogAttrib::make_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_FogAttrib_make_off_1444_comment =
  "C++ Interface:\n"
  "make_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new FogAttrib object suitable for rendering unfogd geometry.\n"
  " */";
#else
static const char *Dtool_FogAttrib_make_off_1444_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > FogAttrib::make_default(void)
 */
static PyObject *Dtool_FogAttrib_make_default_1445(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > FogAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (FogAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_FogAttrib_make_default_1445_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_FogAttrib_make_default_1445_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FogAttrib::is_off(void) const
 */
static PyObject *Dtool_FogAttrib_is_off_1446(PyObject *self, PyObject *) {
  FogAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FogAttrib)) {
    return nullptr;
  }
  // 1-inline bool FogAttrib::is_off(void) const
  bool return_value = ((*(const FogAttrib*)local_this).is_off)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FogAttrib_is_off_1446_comment =
  "C++ Interface:\n"
  "is_off(FogAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if the FogAttrib is an 'off' FogAttrib, indicating that it\n"
  " * should disable fog.\n"
  " */";
#else
static const char *Dtool_FogAttrib_is_off_1446_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Fog *FogAttrib::get_fog(void) const
 */
static PyObject *Dtool_FogAttrib_get_fog_1447(PyObject *self, PyObject *) {
  FogAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FogAttrib)) {
    return nullptr;
  }
  // 1-inline Fog *FogAttrib::get_fog(void) const
  Fog *return_value = ((*(const FogAttrib*)local_this).get_fog)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Fog, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_FogAttrib_get_fog_1447_comment =
  "C++ Interface:\n"
  "get_fog(FogAttrib self)\n"
  "\n"
  "/**\n"
  " * If the FogAttrib is not an 'off' FogAttrib, returns the fog that is\n"
  " * associated.  Otherwise, return NULL.\n"
  " */";
#else
static const char *Dtool_FogAttrib_get_fog_1447_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int FogAttrib::get_class_slot(void)
 */
static PyObject *Dtool_FogAttrib_get_class_slot_1450(PyObject *, PyObject *) {
  // 1-static int FogAttrib::get_class_slot(void)
  int return_value = (FogAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FogAttrib_get_class_slot_1450_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_FogAttrib_get_class_slot_1450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle FogAttrib::get_class_type(void)
 */
static PyObject *Dtool_FogAttrib_get_class_type_1452(PyObject *, PyObject *) {
  // 1-static TypeHandle FogAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((FogAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FogAttrib_get_class_type_1452_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FogAttrib_get_class_type_1452_comment = nullptr;
#endif

static PyObject *Dtool_FogAttrib_fog_Getter(PyObject *self, void *) {
  const FogAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FogAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Fog *FogAttrib::get_fog(void) const
  Fog *return_value = ((*(const FogAttrib*)local_this).get_fog)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Fog, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_FogAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int FogAttrib::get_class_slot(void)
  int return_value = (FogAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_FogAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_FogAttrib(PyObject *args, CPT(FogAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_FogAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > FogAttrib::make(Fog *fog)
    Fog *arg_this = (Fog *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Fog, 0, "FogAttrib.make", false, false);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = (FogAttrib::make)(arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((FogAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_FogAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FogAttrib) {
    printf("FogAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FogAttrib *local_this = (FogAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FogAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FogAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FogAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FogAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (FogAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FogAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (FogAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (FogAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CullTraverser
 */
/**
 * Python function wrapper for:
 * inline GraphicsStateGuardianBase *CullTraverser::get_gsg(void) const
 */
static PyObject *Dtool_CullTraverser_get_gsg_1456(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline GraphicsStateGuardianBase *CullTraverser::get_gsg(void) const
  GraphicsStateGuardianBase *return_value = ((*(const CullTraverser*)local_this).get_gsg)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsStateGuardianBase, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_gsg_1456_comment =
  "C++ Interface:\n"
  "get_gsg(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the GraphicsStateGuardian in effect.\n"
  " */";
#else
static const char *Dtool_CullTraverser_get_gsg_1456_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Thread *CullTraverser::get_current_thread(void) const
 */
static PyObject *Dtool_CullTraverser_get_current_thread_1457(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline Thread *CullTraverser::get_current_thread(void) const
  Thread *return_value = ((*(const CullTraverser*)local_this).get_current_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_current_thread_1457_comment =
  "C++ Interface:\n"
  "get_current_thread(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the currently-executing thread object, as passed to the\n"
  " * CullTraverser constructor.\n"
  " */";
#else
static const char *Dtool_CullTraverser_get_current_thread_1457_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CullTraverser::set_scene(SceneSetup *scene_setup, GraphicsStateGuardianBase *gsg, bool dr_incomplete_render)
 */
static PyObject *Dtool_CullTraverser_set_scene_1458(PyObject *self, PyObject *args, PyObject *kwds) {
  CullTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullTraverser, (void **)&local_this, "CullTraverser.set_scene")) {
    return nullptr;
  }
  // 1-virtual void CullTraverser::set_scene(SceneSetup *scene_setup, GraphicsStateGuardianBase *gsg, bool dr_incomplete_render)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"scene_setup", "gsg", "dr_incomplete_render", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_scene", (char **)keyword_list, &param1, &param2, &param3)) {
    SceneSetup *param1_this = (SceneSetup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_SceneSetup, 1, "CullTraverser.set_scene", false, true);
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "CullTraverser.set_scene", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).set_scene)(param1_this, param2_this, (PyObject_IsTrue(param3) != 0));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scene(const CullTraverser self, SceneSetup scene_setup, GraphicsStateGuardianBase gsg, bool dr_incomplete_render)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_set_scene_1458_comment =
  "C++ Interface:\n"
  "set_scene(const CullTraverser self, SceneSetup scene_setup, GraphicsStateGuardianBase gsg, bool dr_incomplete_render)\n"
  "\n"
  "/**\n"
  " * Sets the SceneSetup object that indicates the initial camera position, etc.\n"
  " * This must be called before traversal begins.\n"
  " */";
#else
static const char *Dtool_CullTraverser_set_scene_1458_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SceneSetup *CullTraverser::get_scene(void) const
 */
static PyObject *Dtool_CullTraverser_get_scene_1459(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline SceneSetup *CullTraverser::get_scene(void) const
  SceneSetup *return_value = ((*(const CullTraverser*)local_this).get_scene)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SceneSetup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_scene_1459_comment =
  "C++ Interface:\n"
  "get_scene(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the SceneSetup object.\n"
  " */";
#else
static const char *Dtool_CullTraverser_get_scene_1459_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CullTraverser::has_tag_state_key(void) const
 */
static PyObject *Dtool_CullTraverser_has_tag_state_key_1460(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline bool CullTraverser::has_tag_state_key(void) const
  bool return_value = ((*(const CullTraverser*)local_this).has_tag_state_key)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_has_tag_state_key_1460_comment =
  "C++ Interface:\n"
  "has_tag_state_key(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns true if a nonempty tag state key has been specified for the scene's\n"
  " * camera, false otherwise.\n"
  " */";
#else
static const char *Dtool_CullTraverser_has_tag_state_key_1460_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &CullTraverser::get_tag_state_key(void) const
 */
static PyObject *Dtool_CullTraverser_get_tag_state_key_1461(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline std::string const &CullTraverser::get_tag_state_key(void) const
  std::string const &return_value = ((*(const CullTraverser*)local_this).get_tag_state_key)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_tag_state_key_1461_comment =
  "C++ Interface:\n"
  "get_tag_state_key(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the tag state key that has been specified for the scene's camera,\n"
  " * if any.\n"
  " */";
#else
static const char *Dtool_CullTraverser_get_tag_state_key_1461_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CullTraverser::set_camera_mask(DrawMask const &camera_mask)
 */
static PyObject *Dtool_CullTraverser_set_camera_mask_1462(PyObject *self, PyObject *arg) {
  CullTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullTraverser, (void **)&local_this, "CullTraverser.set_camera_mask")) {
    return nullptr;
  }
  // 1-inline void CullTraverser::set_camera_mask(DrawMask const &camera_mask)
  BitMask< uint32_t, 32 > arg_local;
  DrawMask const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CullTraverser.set_camera_mask", "BitMask");
  }
  ((*local_this).set_camera_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera_mask(const CullTraverser self, const BitMask camera_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_set_camera_mask_1462_comment =
  "C++ Interface:\n"
  "set_camera_mask(const CullTraverser self, const BitMask camera_mask)\n"
  "\n"
  "/**\n"
  " * Changes the visibility mask for the camera viewing the scene.  This is\n"
  " * normally set automatically at the time setup_scene() is called; you should\n"
  " * change this only if you want to render some set of objects different from\n"
  " * what the camera normally would draw.\n"
  " */";
#else
static const char *Dtool_CullTraverser_set_camera_mask_1462_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DrawMask const &CullTraverser::get_camera_mask(void) const
 */
static PyObject *Dtool_CullTraverser_get_camera_mask_1463(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline DrawMask const &CullTraverser::get_camera_mask(void) const
  DrawMask const *return_value = &(((*(const CullTraverser*)local_this).get_camera_mask)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_camera_mask_1463_comment =
  "C++ Interface:\n"
  "get_camera_mask(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the visibility mask from the camera viewing the scene.\n"
  " */";
#else
static const char *Dtool_CullTraverser_get_camera_mask_1463_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *CullTraverser::get_camera_transform(void) const
 */
static PyObject *Dtool_CullTraverser_get_camera_transform_1464(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline TransformState const *CullTraverser::get_camera_transform(void) const
  TransformState const *return_value = ((*(const CullTraverser*)local_this).get_camera_transform)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_camera_transform_1464_comment =
  "C++ Interface:\n"
  "get_camera_transform(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the position of the camera relative to the starting node.\n"
  " */";
#else
static const char *Dtool_CullTraverser_get_camera_transform_1464_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *CullTraverser::get_world_transform(void) const
 */
static PyObject *Dtool_CullTraverser_get_world_transform_1465(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline TransformState const *CullTraverser::get_world_transform(void) const
  TransformState const *return_value = ((*(const CullTraverser*)local_this).get_world_transform)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_world_transform_1465_comment =
  "C++ Interface:\n"
  "get_world_transform(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the position of the starting node relative to the camera.  This is\n"
  " * the inverse of the camera transform.\n"
  " *\n"
  " * Note that this value is always the position of the starting node, not the\n"
  " * current node, even if it is sampled during a traversal.  To get the\n"
  " * transform of the current node use\n"
  " * CullTraverserData::get_modelview_transform().\n"
  " */";
#else
static const char *Dtool_CullTraverser_get_world_transform_1465_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderState const *CullTraverser::get_initial_state(void) const
 */
static PyObject *Dtool_CullTraverser_get_initial_state_1466(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline RenderState const *CullTraverser::get_initial_state(void) const
  RenderState const *return_value = ((*(const CullTraverser*)local_this).get_initial_state)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_initial_state_1466_comment =
  "C++ Interface:\n"
  "get_initial_state(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the initial RenderState at the top of the scene graph we are\n"
  " * traversing, or the empty state if the initial state was never set.\n"
  " */";
#else
static const char *Dtool_CullTraverser_get_initial_state_1466_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CullTraverser::get_depth_offset_decals(void) const
 */
static PyObject *Dtool_CullTraverser_get_depth_offset_decals_1467(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline bool CullTraverser::get_depth_offset_decals(void) const
  bool return_value = ((*(const CullTraverser*)local_this).get_depth_offset_decals)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_depth_offset_decals_1467_comment =
  "C++ Interface:\n"
  "get_depth_offset_decals(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns true, as depth offsets are the only way that we implement decals\n"
  " * nowadays.\n"
  " */";
#else
static const char *Dtool_CullTraverser_get_depth_offset_decals_1467_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CullTraverser::set_view_frustum(GeometricBoundingVolume *view_frustum)
 */
static PyObject *Dtool_CullTraverser_set_view_frustum_1468(PyObject *self, PyObject *arg) {
  CullTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullTraverser, (void **)&local_this, "CullTraverser.set_view_frustum")) {
    return nullptr;
  }
  // 1-inline void CullTraverser::set_view_frustum(GeometricBoundingVolume *view_frustum)
  GeometricBoundingVolume *arg_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeometricBoundingVolume, 1, "CullTraverser.set_view_frustum", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_view_frustum)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_view_frustum(const CullTraverser self, GeometricBoundingVolume view_frustum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_set_view_frustum_1468_comment =
  "C++ Interface:\n"
  "set_view_frustum(const CullTraverser self, GeometricBoundingVolume view_frustum)\n"
  "\n"
  "/**\n"
  " * Specifies the bounding volume that corresponds to the view frustum.  Any\n"
  " * primitives that fall entirely outside of this volume are not drawn.\n"
  " *\n"
  " * Nowadays, this gets set automatically by set_scene().\n"
  " */";
#else
static const char *Dtool_CullTraverser_set_view_frustum_1468_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeometricBoundingVolume *CullTraverser::get_view_frustum(void) const
 */
static PyObject *Dtool_CullTraverser_get_view_frustum_1469(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline GeometricBoundingVolume *CullTraverser::get_view_frustum(void) const
  GeometricBoundingVolume *return_value = ((*(const CullTraverser*)local_this).get_view_frustum)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeometricBoundingVolume, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_view_frustum_1469_comment =
  "C++ Interface:\n"
  "get_view_frustum(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the bounding volume that corresponds to the view frustum, or NULL\n"
  " * if the view frustum is not in use or has not been set.\n"
  " *\n"
  " * Note that the view frustum returned here is always in the coordinate space\n"
  " * of the starting node, not the current node, even if it is sampled during a\n"
  " * traversal.  To get the view frustum in the current node's coordinate space,\n"
  " * check in the current CullTraverserData.\n"
  " */";
#else
static const char *Dtool_CullTraverser_get_view_frustum_1469_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CullTraverser::get_effective_incomplete_render(void) const
 */
static PyObject *Dtool_CullTraverser_get_effective_incomplete_render_1474(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-inline bool CullTraverser::get_effective_incomplete_render(void) const
  bool return_value = ((*(const CullTraverser*)local_this).get_effective_incomplete_render)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_effective_incomplete_render_1474_comment =
  "C++ Interface:\n"
  "get_effective_incomplete_render(CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns true if the cull traversal is effectively in incomplete_render\n"
  " * state, considering both the GSG's incomplete_render and the current\n"
  " * DisplayRegion's incomplete_render flags.  This returns the flag during the\n"
  " * cull traversal; see GSG::get_effective_incomplete_render() for this same\n"
  " * flag during the draw traversal.\n"
  " */";
#else
static const char *Dtool_CullTraverser_get_effective_incomplete_render_1474_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CullTraverser::traverse(CullTraverserData &data)
 * void CullTraverser::traverse(NodePath const &root)
 */
static PyObject *Dtool_CullTraverser_traverse_1475(PyObject *self, PyObject *arg) {
  CullTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullTraverser, (void **)&local_this, "CullTraverser.traverse")) {
    return nullptr;
  }
  {
    // -2 void CullTraverser::traverse(CullTraverserData &data)
    CullTraverserData *arg_this = (CullTraverserData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CullTraverserData, 1, "CullTraverser.traverse", false, false);
    if (arg_this != nullptr) {
      ((*local_this).traverse)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void CullTraverser::traverse(NodePath const &root)
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      ((*local_this).traverse)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void CullTraverser::traverse(CullTraverserData &data)
  // No coercion possible: void CullTraverser::traverse(NodePath const &root)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "traverse(const CullTraverser self, CullTraverserData data)\n"
      "traverse(const CullTraverser self, const NodePath root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_traverse_1475_comment =
  "C++ Interface:\n"
  "traverse(const CullTraverser self, CullTraverserData data)\n"
  "traverse(const CullTraverser self, const NodePath root)\n"
  "\n"
  "/**\n"
  " * Begins the traversal from the indicated node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Traverses from the next node with the given data, which has been\n"
  " * constructed with the node but has not yet been converted into the node's\n"
  " * space.\n"
  " */";
#else
static const char *Dtool_CullTraverser_traverse_1475_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CullTraverser::traverse_below(CullTraverserData &data)
 */
static PyObject *Dtool_CullTraverser_traverse_below_1476(PyObject *self, PyObject *arg) {
  CullTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullTraverser, (void **)&local_this, "CullTraverser.traverse_below")) {
    return nullptr;
  }
  // 1-virtual void CullTraverser::traverse_below(CullTraverserData &data)
  CullTraverserData *arg_this = (CullTraverserData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CullTraverserData, 1, "CullTraverser.traverse_below", false, true);
  if (arg_this != nullptr) {
    ((*local_this).traverse_below)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "traverse_below(const CullTraverser self, CullTraverserData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_traverse_below_1476_comment =
  "C++ Interface:\n"
  "traverse_below(const CullTraverser self, CullTraverserData data)\n"
  "\n"
  "/**\n"
  " * Traverses all the children of the indicated node, with the given data,\n"
  " * which has been converted into the node's space.\n"
  " */";
#else
static const char *Dtool_CullTraverser_traverse_below_1476_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CullTraverser::end_traverse(void)
 */
static PyObject *Dtool_CullTraverser_end_traverse_1477(PyObject *self, PyObject *) {
  CullTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullTraverser, (void **)&local_this, "CullTraverser.end_traverse")) {
    return nullptr;
  }
  // 1-virtual void CullTraverser::end_traverse(void)
  ((*local_this).end_traverse)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_end_traverse_1477_comment =
  "C++ Interface:\n"
  "end_traverse(const CullTraverser self)\n"
  "\n"
  "/**\n"
  " * Should be called when the traverser has finished traversing its scene, this\n"
  " * gives it a chance to do any necessary finalization.\n"
  " */";
#else
static const char *Dtool_CullTraverser_end_traverse_1477_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void CullTraverser::flush_level(void)
 */
static PyObject *Dtool_CullTraverser_flush_level_1478(PyObject *, PyObject *) {
  // 1-static inline void CullTraverser::flush_level(void)
  (CullTraverser::flush_level)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_flush_level_1478_comment =
  "C++ Interface:\n"
  "flush_level()\n"
  "\n"
  "/**\n"
  " * Flushes the PStatCollectors used during traversal.\n"
  " */";
#else
static const char *Dtool_CullTraverser_flush_level_1478_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CullTraverser::draw_bounding_volume(BoundingVolume const *vol, TransformState const *internal_transform) const
 */
static PyObject *Dtool_CullTraverser_draw_bounding_volume_1479(PyObject *self, PyObject *args, PyObject *kwds) {
  CullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullTraverser)) {
    return nullptr;
  }
  // 1-void CullTraverser::draw_bounding_volume(BoundingVolume const *vol, TransformState const *internal_transform) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"vol", "internal_transform", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:draw_bounding_volume", (char **)keyword_list, &param1, &param2)) {
    BoundingVolume const *param1_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BoundingVolume, 1, "CullTraverser.draw_bounding_volume", true, true);
    TransformState const *param2_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TransformState, 2, "CullTraverser.draw_bounding_volume", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*(const CullTraverser*)local_this).draw_bounding_volume)(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "draw_bounding_volume(CullTraverser self, const BoundingVolume vol, const TransformState internal_transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_draw_bounding_volume_1479_comment =
  "C++ Interface:\n"
  "draw_bounding_volume(CullTraverser self, const BoundingVolume vol, const TransformState internal_transform)\n"
  "\n"
  "/**\n"
  " * Draws an appropriate visualization of the indicated bounding volume.\n"
  " */";
#else
static const char *Dtool_CullTraverser_draw_bounding_volume_1479_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CullTraverser::get_class_type(void)
 */
static PyObject *Dtool_CullTraverser_get_class_type_1480(PyObject *, PyObject *) {
  // 1-static TypeHandle CullTraverser::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CullTraverser::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CullTraverser_get_class_type_1480_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CullTraverser_get_class_type_1480_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CullTraverser::CullTraverser(void)
 * CullTraverser::CullTraverser(CullTraverser const &copy)
 */
static int Dtool_Init_CullTraverser(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-CullTraverser::CullTraverser(void)
      CullTraverser *return_value = new CullTraverser();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CullTraverser, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-CullTraverser::CullTraverser(CullTraverser const &copy)
        CullTraverser const *arg_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CullTraverser, 0, "CullTraverser.CullTraverser", true, true);
        if (arg_this != nullptr) {
          CullTraverser *return_value = new CullTraverser(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CullTraverser, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CullTraverser() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CullTraverser()\n"
      "CullTraverser(const CullTraverser copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CullTraverser(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CullTraverser) {
    printf("CullTraverser ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CullTraverser *local_this = (CullTraverser *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CullTraverser) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CullTraverser(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CullTraverser) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CullTraverser*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CullTraverser*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CullTraverser*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomDrawCallbackData
 */
/**
 * Python function wrapper for:
 * inline GraphicsStateGuardianBase *GeomDrawCallbackData::get_gsg(void) const
 */
static PyObject *Dtool_GeomDrawCallbackData_get_gsg_1485(PyObject *self, PyObject *) {
  GeomDrawCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomDrawCallbackData)) {
    return nullptr;
  }
  // 1-inline GraphicsStateGuardianBase *GeomDrawCallbackData::get_gsg(void) const
  GraphicsStateGuardianBase *return_value = ((*(const GeomDrawCallbackData*)local_this).get_gsg)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsStateGuardianBase, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomDrawCallbackData_get_gsg_1485_comment =
  "C++ Interface:\n"
  "get_gsg(GeomDrawCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the current GSG.\n"
  " */";
#else
static const char *Dtool_GeomDrawCallbackData_get_gsg_1485_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomDrawCallbackData::get_force(void) const
 */
static PyObject *Dtool_GeomDrawCallbackData_get_force_1486(PyObject *self, PyObject *) {
  GeomDrawCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomDrawCallbackData)) {
    return nullptr;
  }
  // 1-inline bool GeomDrawCallbackData::get_force(void) const
  bool return_value = ((*(const GeomDrawCallbackData*)local_this).get_force)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomDrawCallbackData_get_force_1486_comment =
  "C++ Interface:\n"
  "get_force(GeomDrawCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns true if any required data should be forced into memory if necessary\n"
  " * to render the object, or false if the object should be omitted if some of\n"
  " * the data is not available (at least until the data becomes available\n"
  " * later).\n"
  " */";
#else
static const char *Dtool_GeomDrawCallbackData_get_force_1486_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomDrawCallbackData::set_lost_state(bool lost_state)
 */
static PyObject *Dtool_GeomDrawCallbackData_set_lost_state_1487(PyObject *self, PyObject *arg) {
  GeomDrawCallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomDrawCallbackData, (void **)&local_this, "GeomDrawCallbackData.set_lost_state")) {
    return nullptr;
  }
  // 1-inline void GeomDrawCallbackData::set_lost_state(bool lost_state)
  ((*local_this).set_lost_state)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lost_state(const GeomDrawCallbackData self, bool lost_state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomDrawCallbackData_set_lost_state_1487_comment =
  "C++ Interface:\n"
  "set_lost_state(const GeomDrawCallbackData self, bool lost_state)\n"
  "\n"
  "/**\n"
  " * Sets the lost_state flag.  If this is true, the callback does not have to\n"
  " * be quite so careful to clean up after itself; Panda will assume that the\n"
  " * graphics state is in an unknown state after the callback has finished, and\n"
  " * will issue all the necessary calls to restore it.  If this is false, Panda\n"
  " * will assume the callback will leave the graphics state exactly as it came\n"
  " * in, and won't bother to try to restore it.  The default is true.\n"
  " */";
#else
static const char *Dtool_GeomDrawCallbackData_set_lost_state_1487_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomDrawCallbackData::get_lost_state(void) const
 */
static PyObject *Dtool_GeomDrawCallbackData_get_lost_state_1488(PyObject *self, PyObject *) {
  GeomDrawCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomDrawCallbackData)) {
    return nullptr;
  }
  // 1-inline bool GeomDrawCallbackData::get_lost_state(void) const
  bool return_value = ((*(const GeomDrawCallbackData*)local_this).get_lost_state)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomDrawCallbackData_get_lost_state_1488_comment =
  "C++ Interface:\n"
  "get_lost_state(GeomDrawCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns the lost_state flag.  See set_lost_state().\n"
  " */";
#else
static const char *Dtool_GeomDrawCallbackData_get_lost_state_1488_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeomDrawCallbackData::get_class_type(void)
 */
static PyObject *Dtool_GeomDrawCallbackData_get_class_type_1489(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomDrawCallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomDrawCallbackData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomDrawCallbackData_get_class_type_1489_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomDrawCallbackData_get_class_type_1489_comment = nullptr;
#endif

static int Dtool_Init_GeomDrawCallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GeomDrawCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomDrawCallbackData) {
    printf("GeomDrawCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomDrawCallbackData *local_this = (GeomDrawCallbackData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomDrawCallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackData) {
    return (CallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(CallbackData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomDrawCallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomDrawCallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    CallbackData* other_this = (CallbackData*)from_this;
    return (GeomDrawCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomDrawCallbackData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RescaleNormalAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > RescaleNormalAttrib::make(RescaleNormalAttrib::Mode mode)
 */
static PyObject *Dtool_RescaleNormalAttrib_make_1493(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > RescaleNormalAttrib::make(RescaleNormalAttrib::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (RescaleNormalAttrib::make)((RescaleNormalAttrib::Mode)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RescaleNormalAttrib_make_1493_comment =
  "C++ Interface:\n"
  "make(int mode)\n"
  "\n"
  "/**\n"
  " * Constructs a new RescaleNormalAttrib object that specifies whether to\n"
  " * rescale normals to compensate for transform scales or incorrectly defined\n"
  " * normals.\n"
  " */";
#else
static const char *Dtool_RescaleNormalAttrib_make_1493_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< RenderAttrib > RescaleNormalAttrib::make_default(void)
 */
static PyObject *Dtool_RescaleNormalAttrib_make_default_1494(PyObject *, PyObject *) {
  // 1-static inline ConstPointerTo< RenderAttrib > RescaleNormalAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (RescaleNormalAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_RescaleNormalAttrib_make_default_1494_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Constructs a RescaleNormalAttrib object that's suitable for putting at the\n"
  " * top of a scene graph.  This will contain whatever attrib was suggested by\n"
  " * the user's rescale-normals Config variable.\n"
  " */";
#else
static const char *Dtool_RescaleNormalAttrib_make_default_1494_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RescaleNormalAttrib::Mode RescaleNormalAttrib::get_mode(void) const
 */
static PyObject *Dtool_RescaleNormalAttrib_get_mode_1495(PyObject *self, PyObject *) {
  RescaleNormalAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RescaleNormalAttrib)) {
    return nullptr;
  }
  // 1-inline RescaleNormalAttrib::Mode RescaleNormalAttrib::get_mode(void) const
  RescaleNormalAttrib::Mode return_value = ((*(const RescaleNormalAttrib*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RescaleNormalAttrib_get_mode_1495_comment =
  "C++ Interface:\n"
  "get_mode(RescaleNormalAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the render mode.\n"
  " */";
#else
static const char *Dtool_RescaleNormalAttrib_get_mode_1495_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int RescaleNormalAttrib::get_class_slot(void)
 */
static PyObject *Dtool_RescaleNormalAttrib_get_class_slot_1497(PyObject *, PyObject *) {
  // 1-static int RescaleNormalAttrib::get_class_slot(void)
  int return_value = (RescaleNormalAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RescaleNormalAttrib_get_class_slot_1497_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_RescaleNormalAttrib_get_class_slot_1497_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RescaleNormalAttrib::get_class_type(void)
 */
static PyObject *Dtool_RescaleNormalAttrib_get_class_type_1499(PyObject *, PyObject *) {
  // 1-static TypeHandle RescaleNormalAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RescaleNormalAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RescaleNormalAttrib_get_class_type_1499_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RescaleNormalAttrib_get_class_type_1499_comment = nullptr;
#endif

static PyObject *Dtool_RescaleNormalAttrib_mode_Getter(PyObject *self, void *) {
  const RescaleNormalAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RescaleNormalAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline RescaleNormalAttrib::Mode RescaleNormalAttrib::get_mode(void) const
  RescaleNormalAttrib::Mode return_value = ((*(const RescaleNormalAttrib*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_RescaleNormalAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int RescaleNormalAttrib::get_class_slot(void)
  int return_value = (RescaleNormalAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_RescaleNormalAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_RescaleNormalAttrib(PyObject *args, CPT(RescaleNormalAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_RescaleNormalAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > RescaleNormalAttrib::make(RescaleNormalAttrib::Mode mode)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (RescaleNormalAttrib::make)((RescaleNormalAttrib::Mode)arg_val);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((RescaleNormalAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_RescaleNormalAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RescaleNormalAttrib) {
    printf("RescaleNormalAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RescaleNormalAttrib *local_this = (RescaleNormalAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RescaleNormalAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RescaleNormalAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RescaleNormalAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RescaleNormalAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (RescaleNormalAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RescaleNormalAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RescaleNormalAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RescaleNormalAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CullResult
 */
/**
 * Python function wrapper for:
 * PointerTo< CullResult > CullResult::make_next(void) const
 */
static PyObject *Dtool_CullResult_make_next_1503(PyObject *self, PyObject *) {
  CullResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CullResult)) {
    return nullptr;
  }
  // 1-PointerTo< CullResult > CullResult::make_next(void) const
  PointerTo< CullResult > return_value = ((*(const CullResult*)local_this).make_next)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  CullResult *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_CullResult, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CullResult_make_next_1503_comment =
  "C++ Interface:\n"
  "make_next(CullResult self)\n"
  "\n"
  "/**\n"
  " * Returns a newly-allocated CullResult object that contains a copy of just\n"
  " * the subset of the data from this CullResult object that is worth keeping\n"
  " * around for next frame.\n"
  " */";
#else
static const char *Dtool_CullResult_make_next_1503_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CullResult::finish_cull(SceneSetup *scene_setup, Thread *current_thread)
 */
static PyObject *Dtool_CullResult_finish_cull_1506(PyObject *self, PyObject *args, PyObject *kwds) {
  CullResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullResult, (void **)&local_this, "CullResult.finish_cull")) {
    return nullptr;
  }
  // 1-void CullResult::finish_cull(SceneSetup *scene_setup, Thread *current_thread)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"scene_setup", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:finish_cull", (char **)keyword_list, &param1, &param2)) {
    SceneSetup *param1_this = (SceneSetup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_SceneSetup, 1, "CullResult.finish_cull", false, true);
    Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "CullResult.finish_cull", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).finish_cull)(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "finish_cull(const CullResult self, SceneSetup scene_setup, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullResult_finish_cull_1506_comment =
  "C++ Interface:\n"
  "finish_cull(const CullResult self, SceneSetup scene_setup, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Called after all the geoms have been added, this indicates that the cull\n"
  " * process is finished for this frame and gives the bins a chance to do any\n"
  " * post-processing (like sorting) before moving on to draw.\n"
  " */";
#else
static const char *Dtool_CullResult_finish_cull_1506_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CullResult::draw(Thread *current_thread)
 */
static PyObject *Dtool_CullResult_draw_1507(PyObject *self, PyObject *arg) {
  CullResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullResult, (void **)&local_this, "CullResult.draw")) {
    return nullptr;
  }
  // 1-void CullResult::draw(Thread *current_thread)
  Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "CullResult.draw", false, true);
  if (arg_this != nullptr) {
    ((*local_this).draw)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "draw(const CullResult self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CullResult_draw_1507_comment =
  "C++ Interface:\n"
  "draw(const CullResult self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Asks all the bins to draw themselves in the correct order.\n"
  " */";
#else
static const char *Dtool_CullResult_draw_1507_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > CullResult::make_result_graph(void)
 */
static PyObject *Dtool_CullResult_make_result_graph_1508(PyObject *self, PyObject *) {
  CullResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CullResult, (void **)&local_this, "CullResult.make_result_graph")) {
    return nullptr;
  }
  // 1-PointerTo< PandaNode > CullResult::make_result_graph(void)
  PointerTo< PandaNode > return_value = ((*local_this).make_result_graph)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  PandaNode *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CullResult_make_result_graph_1508_comment =
  "C++ Interface:\n"
  "make_result_graph(const CullResult self)\n"
  "\n"
  "/**\n"
  " * Returns a special scene graph constructed to represent the results of the\n"
  " * cull.  This will be a hierarchy of nodes, one node for each bin, each of\n"
  " * which will in term be a parent of a number of GeomNodes, representing the\n"
  " * geometry drawn in each bin.\n"
  " *\n"
  " * This is useful mainly for high-level debugging and abstraction tools; it\n"
  " * should not be mistaken for the low-level cull result itself.  For the low-\n"
  " * level cull result, use draw() to efficiently draw the culled scene.\n"
  " */";
#else
static const char *Dtool_CullResult_make_result_graph_1508_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CullResult::get_class_type(void)
 */
static PyObject *Dtool_CullResult_get_class_type_1509(PyObject *, PyObject *) {
  // 1-static TypeHandle CullResult::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CullResult::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CullResult_get_class_type_1509_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CullResult_get_class_type_1509_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CullResult::CullResult(CullResult const &) = default
 */
static int Dtool_Init_CullResult(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CullResult() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline CullResult::CullResult(CullResult const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    CullResult const *param0_this = (CullResult *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CullResult, 0, "CullResult.CullResult", true, true);
    if (param0_this != nullptr) {
      CullResult *return_value = new CullResult(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CullResult, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CullResult(const CullResult param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CullResult(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CullResult) {
    printf("CullResult ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CullResult *local_this = (CullResult *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CullResult) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CullResult(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CullResult) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CullResult*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DecalEffect
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > DecalEffect::make(void)
 */
static PyObject *Dtool_DecalEffect_make_1512(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderEffect > DecalEffect::make(void)
  ConstPointerTo< RenderEffect > return_value = (DecalEffect::make)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffect const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DecalEffect_make_1512_comment =
  "C++ Interface:\n"
  "make()\n"
  "\n"
  "/**\n"
  " * Constructs a new DecalEffect object.\n"
  " */";
#else
static const char *Dtool_DecalEffect_make_1512_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DecalEffect::get_class_type(void)
 */
static PyObject *Dtool_DecalEffect_get_class_type_1513(PyObject *, PyObject *) {
  // 1-static TypeHandle DecalEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DecalEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DecalEffect_get_class_type_1513_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DecalEffect_get_class_type_1513_comment = nullptr;
#endif

static int Dtool_Init_DecalEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DecalEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DecalEffect) {
    printf("DecalEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DecalEffect *local_this = (DecalEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DecalEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DecalEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DecalEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DecalEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (DecalEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DecalEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (DecalEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (DecalEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DepthOffsetAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > DepthOffsetAttrib::make(int offset = 1)
 * static ConstPointerTo< RenderAttrib > DepthOffsetAttrib::make(int offset, PN_stdfloat min_value, PN_stdfloat max_value)
 */
static PyObject *Dtool_DepthOffsetAttrib_make_1516(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-static ConstPointerTo< RenderAttrib > DepthOffsetAttrib::make(int offset)
      ConstPointerTo< RenderAttrib > return_value = (DepthOffsetAttrib::make)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "offset")) {
        // 1-static ConstPointerTo< RenderAttrib > DepthOffsetAttrib::make(int offset)
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          ConstPointerTo< RenderAttrib > return_value = (DepthOffsetAttrib::make)((int)arg_val);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 3:
    {
      // 1-static ConstPointerTo< RenderAttrib > DepthOffsetAttrib::make(int offset, PN_stdfloat min_value, PN_stdfloat max_value)
      int param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"offset", "min_value", "max_value", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iff:make", (char **)keyword_list, &param0, &param1, &param2)) {
        ConstPointerTo< RenderAttrib > return_value = (DepthOffsetAttrib::make)((int)param0, (PN_stdfloat)param1, (PN_stdfloat)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderAttrib const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 0, 1 or 3 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make()\n"
      "make(int offset)\n"
      "make(int offset, float min_value, float max_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DepthOffsetAttrib_make_1516_comment =
  "C++ Interface:\n"
  "make()\n"
  "make(int offset)\n"
  "make(int offset, float min_value, float max_value)\n"
  "\n"
  "/**\n"
  " * Constructs a new DepthOffsetAttrib object that indicates the relative\n"
  " * amount of bias to write to the depth buffer for subsequent geometry.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new DepthOffsetAttrib object that indicates the bias, and also\n"
  " * specifies a minimum and maximum (or, more precisely, nearest and farthest)\n"
  " * values to write to the depth buffer, in the range 0 .. 1.  This range is 0,\n"
  " * 1 by default; setting it to some other range can be used to create\n"
  " * additional depth buffer effects.\n"
  " */";
#else
static const char *Dtool_DepthOffsetAttrib_make_1516_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > DepthOffsetAttrib::make_default(void)
 */
static PyObject *Dtool_DepthOffsetAttrib_make_default_1517(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > DepthOffsetAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (DepthOffsetAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DepthOffsetAttrib_make_default_1517_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_DepthOffsetAttrib_make_default_1517_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DepthOffsetAttrib::get_offset(void) const
 */
static PyObject *Dtool_DepthOffsetAttrib_get_offset_1518(PyObject *self, PyObject *) {
  DepthOffsetAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DepthOffsetAttrib)) {
    return nullptr;
  }
  // 1-inline int DepthOffsetAttrib::get_offset(void) const
  int return_value = ((*(const DepthOffsetAttrib*)local_this).get_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DepthOffsetAttrib_get_offset_1518_comment =
  "C++ Interface:\n"
  "get_offset(DepthOffsetAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the depth offset represented by this attrib.\n"
  " */";
#else
static const char *Dtool_DepthOffsetAttrib_get_offset_1518_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DepthOffsetAttrib::get_min_value(void) const
 */
static PyObject *Dtool_DepthOffsetAttrib_get_min_value_1519(PyObject *self, PyObject *) {
  DepthOffsetAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DepthOffsetAttrib)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DepthOffsetAttrib::get_min_value(void) const
  PN_stdfloat return_value = ((*(const DepthOffsetAttrib*)local_this).get_min_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DepthOffsetAttrib_get_min_value_1519_comment =
  "C++ Interface:\n"
  "get_min_value(DepthOffsetAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the value for the minimum (closest) depth value to be stored in the\n"
  " * buffer, in the range 0 .. 1.\n"
  " */";
#else
static const char *Dtool_DepthOffsetAttrib_get_min_value_1519_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DepthOffsetAttrib::get_max_value(void) const
 */
static PyObject *Dtool_DepthOffsetAttrib_get_max_value_1520(PyObject *self, PyObject *) {
  DepthOffsetAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DepthOffsetAttrib)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DepthOffsetAttrib::get_max_value(void) const
  PN_stdfloat return_value = ((*(const DepthOffsetAttrib*)local_this).get_max_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DepthOffsetAttrib_get_max_value_1520_comment =
  "C++ Interface:\n"
  "get_max_value(DepthOffsetAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the value for the maximum (farthest) depth value to be stored in\n"
  " * the buffer, in the range 0 .. 1.\n"
  " */";
#else
static const char *Dtool_DepthOffsetAttrib_get_max_value_1520_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int DepthOffsetAttrib::get_class_slot(void)
 */
static PyObject *Dtool_DepthOffsetAttrib_get_class_slot_1524(PyObject *, PyObject *) {
  // 1-static int DepthOffsetAttrib::get_class_slot(void)
  int return_value = (DepthOffsetAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DepthOffsetAttrib_get_class_slot_1524_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_DepthOffsetAttrib_get_class_slot_1524_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DepthOffsetAttrib::get_class_type(void)
 */
static PyObject *Dtool_DepthOffsetAttrib_get_class_type_1526(PyObject *, PyObject *) {
  // 1-static TypeHandle DepthOffsetAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DepthOffsetAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DepthOffsetAttrib_get_class_type_1526_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DepthOffsetAttrib_get_class_type_1526_comment = nullptr;
#endif

static PyObject *Dtool_DepthOffsetAttrib_offset_Getter(PyObject *self, void *) {
  const DepthOffsetAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DepthOffsetAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int DepthOffsetAttrib::get_offset(void) const
  int return_value = ((*(const DepthOffsetAttrib*)local_this).get_offset)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_DepthOffsetAttrib_min_value_Getter(PyObject *self, void *) {
  const DepthOffsetAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DepthOffsetAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat DepthOffsetAttrib::get_min_value(void) const
  PN_stdfloat return_value = ((*(const DepthOffsetAttrib*)local_this).get_min_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_DepthOffsetAttrib_max_value_Getter(PyObject *self, void *) {
  const DepthOffsetAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DepthOffsetAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat DepthOffsetAttrib::get_max_value(void) const
  PN_stdfloat return_value = ((*(const DepthOffsetAttrib*)local_this).get_max_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_DepthOffsetAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int DepthOffsetAttrib::get_class_slot(void)
  int return_value = (DepthOffsetAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_DepthOffsetAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_DepthOffsetAttrib(PyObject *args, CPT(DepthOffsetAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_DepthOffsetAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > DepthOffsetAttrib::make(int offset)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (DepthOffsetAttrib::make)((int)arg_val);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((DepthOffsetAttrib const *) return_value.p());
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-static ConstPointerTo< RenderAttrib > DepthOffsetAttrib::make(int offset, PN_stdfloat min_value, PN_stdfloat max_value)
      int param0;
      float param1;
      float param2;
      if (PyArg_ParseTuple(args, "iff:make", &param0, &param1, &param2)) {
        ConstPointerTo< RenderAttrib > return_value = (DepthOffsetAttrib::make)((int)param0, (PN_stdfloat)param1, (PN_stdfloat)param2);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move((DepthOffsetAttrib const *) return_value.p());
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_DepthOffsetAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DepthOffsetAttrib) {
    printf("DepthOffsetAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DepthOffsetAttrib *local_this = (DepthOffsetAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DepthOffsetAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DepthOffsetAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DepthOffsetAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DepthOffsetAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (DepthOffsetAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DepthOffsetAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (DepthOffsetAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (DepthOffsetAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DepthTestAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > DepthTestAttrib::make(RenderAttrib::PandaCompareFunc mode)
 */
static PyObject *Dtool_DepthTestAttrib_make_1529(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > DepthTestAttrib::make(RenderAttrib::PandaCompareFunc mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (DepthTestAttrib::make)((RenderAttrib::PandaCompareFunc)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DepthTestAttrib_make_1529_comment =
  "C++ Interface:\n"
  "make(int mode)\n"
  "\n"
  "/**\n"
  " * Constructs a new DepthTestAttrib object.\n"
  " */";
#else
static const char *Dtool_DepthTestAttrib_make_1529_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > DepthTestAttrib::make_default(void)
 */
static PyObject *Dtool_DepthTestAttrib_make_default_1530(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > DepthTestAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (DepthTestAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DepthTestAttrib_make_default_1530_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_DepthTestAttrib_make_default_1530_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderAttrib::PandaCompareFunc DepthTestAttrib::get_mode(void) const
 */
static PyObject *Dtool_DepthTestAttrib_get_mode_1531(PyObject *self, PyObject *) {
  DepthTestAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DepthTestAttrib)) {
    return nullptr;
  }
  // 1-inline RenderAttrib::PandaCompareFunc DepthTestAttrib::get_mode(void) const
  RenderAttrib::PandaCompareFunc return_value = ((*(const DepthTestAttrib*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DepthTestAttrib_get_mode_1531_comment =
  "C++ Interface:\n"
  "get_mode(DepthTestAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the depth write mode.\n"
  " */";
#else
static const char *Dtool_DepthTestAttrib_get_mode_1531_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int DepthTestAttrib::get_class_slot(void)
 */
static PyObject *Dtool_DepthTestAttrib_get_class_slot_1533(PyObject *, PyObject *) {
  // 1-static int DepthTestAttrib::get_class_slot(void)
  int return_value = (DepthTestAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DepthTestAttrib_get_class_slot_1533_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_DepthTestAttrib_get_class_slot_1533_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DepthTestAttrib::get_class_type(void)
 */
static PyObject *Dtool_DepthTestAttrib_get_class_type_1535(PyObject *, PyObject *) {
  // 1-static TypeHandle DepthTestAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DepthTestAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DepthTestAttrib_get_class_type_1535_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DepthTestAttrib_get_class_type_1535_comment = nullptr;
#endif

static PyObject *Dtool_DepthTestAttrib_mode_Getter(PyObject *self, void *) {
  const DepthTestAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DepthTestAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline RenderAttrib::PandaCompareFunc DepthTestAttrib::get_mode(void) const
  RenderAttrib::PandaCompareFunc return_value = ((*(const DepthTestAttrib*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_DepthTestAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int DepthTestAttrib::get_class_slot(void)
  int return_value = (DepthTestAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_DepthTestAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_DepthTestAttrib(PyObject *args, CPT(DepthTestAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_DepthTestAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > DepthTestAttrib::make(RenderAttrib::PandaCompareFunc mode)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (DepthTestAttrib::make)((RenderAttrib::PandaCompareFunc)arg_val);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((DepthTestAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_DepthTestAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DepthTestAttrib) {
    printf("DepthTestAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DepthTestAttrib *local_this = (DepthTestAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DepthTestAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DepthTestAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DepthTestAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DepthTestAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (DepthTestAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DepthTestAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (DepthTestAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (DepthTestAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DepthWriteAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > DepthWriteAttrib::make(DepthWriteAttrib::Mode mode)
 */
static PyObject *Dtool_DepthWriteAttrib_make_1539(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > DepthWriteAttrib::make(DepthWriteAttrib::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (DepthWriteAttrib::make)((DepthWriteAttrib::Mode)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DepthWriteAttrib_make_1539_comment =
  "C++ Interface:\n"
  "make(int mode)\n"
  "\n"
  "/**\n"
  " * Constructs a new DepthWriteAttrib object.\n"
  " */";
#else
static const char *Dtool_DepthWriteAttrib_make_1539_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > DepthWriteAttrib::make_default(void)
 */
static PyObject *Dtool_DepthWriteAttrib_make_default_1540(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > DepthWriteAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (DepthWriteAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DepthWriteAttrib_make_default_1540_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_DepthWriteAttrib_make_default_1540_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DepthWriteAttrib::Mode DepthWriteAttrib::get_mode(void) const
 */
static PyObject *Dtool_DepthWriteAttrib_get_mode_1541(PyObject *self, PyObject *) {
  DepthWriteAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DepthWriteAttrib)) {
    return nullptr;
  }
  // 1-inline DepthWriteAttrib::Mode DepthWriteAttrib::get_mode(void) const
  DepthWriteAttrib::Mode return_value = ((*(const DepthWriteAttrib*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DepthWriteAttrib_get_mode_1541_comment =
  "C++ Interface:\n"
  "get_mode(DepthWriteAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the depth write mode.\n"
  " */";
#else
static const char *Dtool_DepthWriteAttrib_get_mode_1541_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int DepthWriteAttrib::get_class_slot(void)
 */
static PyObject *Dtool_DepthWriteAttrib_get_class_slot_1543(PyObject *, PyObject *) {
  // 1-static int DepthWriteAttrib::get_class_slot(void)
  int return_value = (DepthWriteAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DepthWriteAttrib_get_class_slot_1543_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_DepthWriteAttrib_get_class_slot_1543_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DepthWriteAttrib::get_class_type(void)
 */
static PyObject *Dtool_DepthWriteAttrib_get_class_type_1545(PyObject *, PyObject *) {
  // 1-static TypeHandle DepthWriteAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DepthWriteAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DepthWriteAttrib_get_class_type_1545_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DepthWriteAttrib_get_class_type_1545_comment = nullptr;
#endif

static PyObject *Dtool_DepthWriteAttrib_mode_Getter(PyObject *self, void *) {
  const DepthWriteAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DepthWriteAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline DepthWriteAttrib::Mode DepthWriteAttrib::get_mode(void) const
  DepthWriteAttrib::Mode return_value = ((*(const DepthWriteAttrib*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_DepthWriteAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int DepthWriteAttrib::get_class_slot(void)
  int return_value = (DepthWriteAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_DepthWriteAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_DepthWriteAttrib(PyObject *args, CPT(DepthWriteAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_DepthWriteAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > DepthWriteAttrib::make(DepthWriteAttrib::Mode mode)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (DepthWriteAttrib::make)((DepthWriteAttrib::Mode)arg_val);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((DepthWriteAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_DepthWriteAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DepthWriteAttrib) {
    printf("DepthWriteAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DepthWriteAttrib *local_this = (DepthWriteAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DepthWriteAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DepthWriteAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DepthWriteAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DepthWriteAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (DepthWriteAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DepthWriteAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (DepthWriteAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (DepthWriteAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Light
 */
/**
 * Python function wrapper for:
 * virtual PandaNode *Light::as_node(void) = 0
 */
static PyObject *Dtool_Light_as_node_1549(PyObject *self, PyObject *) {
  Light *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Light, (void **)&local_this, "Light.as_node")) {
    return nullptr;
  }
  // 1-virtual PandaNode *Light::as_node(void) = 0
  PandaNode *return_value = ((*local_this).as_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Light_as_node_1549_comment =
  "C++ Interface:\n"
  "as_node(const Light self)\n";
#else
static const char *Dtool_Light_as_node_1549_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool Light::is_ambient_light(void) const
 */
static PyObject *Dtool_Light_is_ambient_light_1550(PyObject *self, PyObject *) {
  Light *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Light)) {
    return nullptr;
  }
  // 1-virtual bool Light::is_ambient_light(void) const
  bool return_value = ((*(const Light*)local_this).is_ambient_light)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Light_is_ambient_light_1550_comment =
  "C++ Interface:\n"
  "is_ambient_light(Light self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is an AmbientLight, false if it is some other kind of\n"
  " * light.\n"
  " */";
#else
static const char *Dtool_Light_is_ambient_light_1550_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &Light::get_color(void) const
 */
static PyObject *Dtool_Light_get_color_1551(PyObject *self, PyObject *) {
  Light *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Light)) {
    return nullptr;
  }
  // 1-inline LColor const &Light::get_color(void) const
  LColor const *return_value = &(((*(const Light*)local_this).get_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Light_get_color_1551_comment =
  "C++ Interface:\n"
  "get_color(Light self)\n"
  "\n"
  "/**\n"
  " * Returns the basic color of the light.\n"
  " */";
#else
static const char *Dtool_Light_get_color_1551_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Light::set_color(LColor const &color)
 */
static PyObject *Dtool_Light_set_color_1552(PyObject *self, PyObject *arg) {
  Light *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Light, (void **)&local_this, "Light.set_color")) {
    return nullptr;
  }
  // 1-inline void Light::set_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Light.set_color", "LVecBase4f");
  }
  ((*local_this).set_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const Light self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Light_set_color_1552_comment =
  "C++ Interface:\n"
  "set_color(const Light self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Sets the basic color of the light.\n"
  " */";
#else
static const char *Dtool_Light_set_color_1552_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Light::has_color_temperature(void) const
 */
static PyObject *Dtool_Light_has_color_temperature_1554(PyObject *self, PyObject *) {
  Light *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Light)) {
    return nullptr;
  }
  // 1-inline bool Light::has_color_temperature(void) const
  bool return_value = ((*(const Light*)local_this).has_color_temperature)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Light_has_color_temperature_1554_comment =
  "C++ Interface:\n"
  "has_color_temperature(Light self)\n"
  "\n"
  "/**\n"
  " * Returns true if the color was specified as a temperature in kelvins, and\n"
  " * get_color_temperature is defined.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_Light_has_color_temperature_1554_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Light::get_color_temperature(void) const
 */
static PyObject *Dtool_Light_get_color_temperature_1555(PyObject *self, PyObject *) {
  Light *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Light)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Light::get_color_temperature(void) const
  PN_stdfloat return_value = ((*(const Light*)local_this).get_color_temperature)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Light_get_color_temperature_1555_comment =
  "C++ Interface:\n"
  "get_color_temperature(Light self)\n"
  "\n"
  "/**\n"
  " * Returns the basic color temperature of the light, assuming\n"
  " * has_color_temperature() returns true.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_Light_get_color_temperature_1555_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Light::set_color_temperature(PN_stdfloat temperature)
 */
static PyObject *Dtool_Light_set_color_temperature_1556(PyObject *self, PyObject *arg) {
  Light *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Light, (void **)&local_this, "Light.set_color_temperature")) {
    return nullptr;
  }
  // 1-void Light::set_color_temperature(PN_stdfloat temperature)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_color_temperature)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_temperature(const Light self, float temperature)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Light_set_color_temperature_1556_comment =
  "C++ Interface:\n"
  "set_color_temperature(const Light self, float temperature)\n"
  "\n"
  "/**\n"
  " * Sets the color temperature of the light in kelvins.  This will recalculate\n"
  " * the light's color.\n"
  " *\n"
  " * The default value is 6500 K, corresponding to a perfectly white light\n"
  " * assuming a D65 white point.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_Light_set_color_temperature_1556_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat Light::get_exponent(void) const
 */
static PyObject *Dtool_Light_get_exponent_1558(PyObject *self, PyObject *) {
  Light *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Light)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat Light::get_exponent(void) const
  PN_stdfloat return_value = ((*(const Light*)local_this).get_exponent)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Light_get_exponent_1558_comment =
  "C++ Interface:\n"
  "get_exponent(Light self)\n"
  "\n"
  "/**\n"
  " * For spotlights, returns the exponent that controls the amount of light\n"
  " * falloff from the center of the spotlight.  For other kinds of lights,\n"
  " * returns 0.\n"
  " */";
#else
static const char *Dtool_Light_get_exponent_1558_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual LColor const &Light::get_specular_color(void) const
 */
static PyObject *Dtool_Light_get_specular_color_1559(PyObject *self, PyObject *) {
  Light *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Light)) {
    return nullptr;
  }
  // 1-virtual LColor const &Light::get_specular_color(void) const
  LColor const *return_value = &(((*(const Light*)local_this).get_specular_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Light_get_specular_color_1559_comment =
  "C++ Interface:\n"
  "get_specular_color(Light self)\n"
  "\n"
  "/**\n"
  " * Returns the color of specular highlights generated by the light.  This\n"
  " * value is meaningless for ambient lights.\n"
  " */";
#else
static const char *Dtool_Light_get_specular_color_1559_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual LVecBase3 const &Light::get_attenuation(void) const
 */
static PyObject *Dtool_Light_get_attenuation_1560(PyObject *self, PyObject *) {
  Light *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Light)) {
    return nullptr;
  }
  // 1-virtual LVecBase3 const &Light::get_attenuation(void) const
  LVecBase3 const *return_value = &(((*(const Light*)local_this).get_attenuation)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Light_get_attenuation_1560_comment =
  "C++ Interface:\n"
  "get_attenuation(Light self)\n"
  "\n"
  "/**\n"
  " * Returns the terms of the attenuation equation for the light.  These are, in\n"
  " * order, the constant, linear, and quadratic terms based on the distance from\n"
  " * the point to the vertex.\n"
  " */";
#else
static const char *Dtool_Light_get_attenuation_1560_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Light::set_priority(int priority)
 */
static PyObject *Dtool_Light_set_priority_1561(PyObject *self, PyObject *arg) {
  Light *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Light, (void **)&local_this, "Light.set_priority")) {
    return nullptr;
  }
  // 1-inline void Light::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_priority)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_priority(const Light self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Light_set_priority_1561_comment =
  "C++ Interface:\n"
  "set_priority(const Light self, int priority)\n"
  "\n"
  "/**\n"
  " * Changes the relative importance of this light relative to the other lights\n"
  " * that are applied simultaneously.\n"
  " *\n"
  " * The priority number is used to decide which of the requested lights are to\n"
  " * be selected for rendering when more lights are requested than the hardware\n"
  " * will support.  The highest-priority n lights are selected for rendering.\n"
  " *\n"
  " * This is similar to TextureStage::set_priority().\n"
  " */";
#else
static const char *Dtool_Light_set_priority_1561_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Light::get_priority(void) const
 */
static PyObject *Dtool_Light_get_priority_1562(PyObject *self, PyObject *) {
  Light *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Light)) {
    return nullptr;
  }
  // 1-inline int Light::get_priority(void) const
  int return_value = ((*(const Light*)local_this).get_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Light_get_priority_1562_comment =
  "C++ Interface:\n"
  "get_priority(Light self)\n"
  "\n"
  "/**\n"
  " * Returns the priority associated with this light.  See set_priority().\n"
  " */";
#else
static const char *Dtool_Light_get_priority_1562_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int Light::get_class_priority(void) const = 0
 */
static PyObject *Dtool_Light_get_class_priority_1563(PyObject *self, PyObject *) {
  Light *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Light)) {
    return nullptr;
  }
  // 1-virtual int Light::get_class_priority(void) const = 0
  int return_value = ((*(const Light*)local_this).get_class_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Light_get_class_priority_1563_comment =
  "C++ Interface:\n"
  "get_class_priority(Light self)\n";
#else
static const char *Dtool_Light_get_class_priority_1563_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Light::get_class_type(void)
 */
static PyObject *Dtool_Light_get_class_type_1565(PyObject *, PyObject *) {
  // 1-static TypeHandle Light::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Light::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Light_get_class_type_1565_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Light_get_class_type_1565_comment = nullptr;
#endif

static PyObject *Dtool_Light_color_Getter(PyObject *self, void *) {
  const Light *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Light, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor const &Light::get_color(void) const
  LColor const *return_value = &(((*(const Light*)local_this).get_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_Light_color_Setter(PyObject *self, PyObject *arg, void *) {
  Light *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Light, (void **)&local_this, "Light.color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete color attribute");
    return -1;
  }
  // 1-inline void Light::set_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Light.set_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_color(const Light self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_Light_color_temperature_Getter(PyObject *self, void *) {
  const Light *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Light, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Light::get_color_temperature(void) const
  PN_stdfloat return_value = ((*(const Light*)local_this).get_color_temperature)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Light_color_temperature_Setter(PyObject *self, PyObject *arg, void *) {
  Light *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Light, (void **)&local_this, "Light.color_temperature")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete color_temperature attribute");
    return -1;
  }
  // 1-void Light::set_color_temperature(PN_stdfloat temperature)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_color_temperature)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_color_temperature(const Light self, float temperature)\n");
  }
  return -1;
}

static PyObject *Dtool_Light_priority_Getter(PyObject *self, void *) {
  const Light *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Light, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Light::get_priority(void) const
  int return_value = ((*(const Light*)local_this).get_priority)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Light_priority_Setter(PyObject *self, PyObject *arg, void *) {
  Light *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Light, (void **)&local_this, "Light.priority")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete priority attribute");
    return -1;
  }
  // 1-inline void Light::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_priority)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_priority(const Light self, int priority)\n");
  }
  return -1;
}

static int Dtool_Init_Light(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_Light(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Light) {
    printf("Light ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Light *local_this = (Light *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Light) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Light(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Light) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LightAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LightAttrib::make(void)
 * static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light)
 * static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2)
 * static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2, Light *light3)
 * static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2, Light *light3, Light *light4)
 */
static PyObject *Dtool_LightAttrib_make_1568(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-static ConstPointerTo< RenderAttrib > LightAttrib::make(void)
      ConstPointerTo< RenderAttrib > return_value = (LightAttrib::make)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 2:
    {
      // 1-static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light)
      int param0;
      PyObject *param1;
      static const char *keyword_list[] = {"op", "light", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:make", (char **)keyword_list, &param0, &param1)) {
        Light *param1_this = (Light *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Light, 1, "LightAttrib.make", false, true);
        if (param1_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (LightAttrib::make)((LightAttrib::Operation)param0, param1_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 3:
    {
      // 1-static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2)
      int param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"op", "light1", "light2", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iOO:make", (char **)keyword_list, &param0, &param1, &param2)) {
        Light *param1_this = (Light *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Light, 1, "LightAttrib.make", false, true);
        Light *param2_this = (Light *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Light, 2, "LightAttrib.make", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (LightAttrib::make)((LightAttrib::Operation)param0, param1_this, param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 4:
    {
      // 1-static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2, Light *light3)
      int param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"op", "light1", "light2", "light3", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iOOO:make", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        Light *param1_this = (Light *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Light, 1, "LightAttrib.make", false, true);
        Light *param2_this = (Light *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Light, 2, "LightAttrib.make", false, true);
        Light *param3_this = (Light *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Light, 3, "LightAttrib.make", false, true);
        if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (LightAttrib::make)((LightAttrib::Operation)param0, param1_this, param2_this, param3_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 5:
    {
      // 1-static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2, Light *light3, Light *light4)
      int param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"op", "light1", "light2", "light3", "light4", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iOOOO:make", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        Light *param1_this = (Light *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Light, 1, "LightAttrib.make", false, true);
        Light *param2_this = (Light *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Light, 2, "LightAttrib.make", false, true);
        Light *param3_this = (Light *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Light, 3, "LightAttrib.make", false, true);
        Light *param4_this = (Light *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_Light, 4, "LightAttrib.make", false, true);
        if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr && param4_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (LightAttrib::make)((LightAttrib::Operation)param0, param1_this, param2_this, param3_this, param4_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 0, 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make()\n"
      "make(int op, Light light)\n"
      "make(int op, Light light1, Light light2)\n"
      "make(int op, Light light1, Light light2, Light light3)\n"
      "make(int op, Light light1, Light light2, Light light3, Light light4)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_make_1568_comment =
  "C++ Interface:\n"
  "make()\n"
  "make(int op, Light light)\n"
  "make(int op, Light light1, Light light2)\n"
  "make(int op, Light light1, Light light2, Light light3)\n"
  "make(int op, Light light1, Light light2, Light light3, Light light4)\n"
  "\n"
  "// The following is the new, more general interface to the LightAttrib.\n"
  "\n"
  "/**\n"
  " * Constructs a new LightAttrib object that turns on (or off, according to op)\n"
  " * the indicated light(s).\n"
  " *\n"
  " * @deprecated Use add_on_light() or add_off_light() instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new LightAttrib object that turns on (or off, according to op)\n"
  " * the indicate light(s).\n"
  " *\n"
  " * @deprecated Use add_on_light() or add_off_light() instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new LightAttrib object that turns on (or off, according to op)\n"
  " * the indicate light(s).\n"
  " *\n"
  " * @deprecated Use add_on_light() or add_off_light() instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new LightAttrib object that turns on (or off, according to op)\n"
  " * the indicate light(s).\n"
  " *\n"
  " * @deprecated Use add_on_light() or add_off_light() instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new LightAttrib object that does nothing.\n"
  " */";
#else
static const char *Dtool_LightAttrib_make_1568_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LightAttrib::make_default(void)
 */
static PyObject *Dtool_LightAttrib_make_default_1569(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > LightAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (LightAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_make_default_1569_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_LightAttrib_make_default_1569_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LightAttrib::Operation LightAttrib::get_operation(void) const
 */
static PyObject *Dtool_LightAttrib_get_operation_1570(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-LightAttrib::Operation LightAttrib::get_operation(void) const
  LightAttrib::Operation return_value = ((*(const LightAttrib*)local_this).get_operation)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_operation_1570_comment =
  "C++ Interface:\n"
  "get_operation(LightAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the basic operation type of the LightAttrib.  If this is O_set, the\n"
  " * lights listed here completely replace any lights that were already on.  If\n"
  " * this is O_add, the lights here are added to the set of lights that were\n"
  " * already on, and if O_remove, the lights here are removed from the set of\n"
  " * lights that were on.\n"
  " *\n"
  " * @deprecated LightAttribs nowadays have a separate list of on_lights and\n"
  " * off_lights, so this method no longer makes sense.  Query the lists\n"
  " * independently.\n"
  " */";
#else
static const char *Dtool_LightAttrib_get_operation_1570_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int LightAttrib::get_num_lights(void) const
 */
static PyObject *Dtool_LightAttrib_get_num_lights_1571(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-int LightAttrib::get_num_lights(void) const
  int return_value = ((*(const LightAttrib*)local_this).get_num_lights)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_num_lights_1571_comment =
  "C++ Interface:\n"
  "get_num_lights(LightAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of lights listed in the attribute.\n"
  " *\n"
  " * @deprecated LightAttribs nowadays have a separate list of on_lights and\n"
  " * off_lights, so this method no longer makes sense.  Query the lists\n"
  " * independently.\n"
  " */";
#else
static const char *Dtool_LightAttrib_get_num_lights_1571_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Light *LightAttrib::get_light(int n) const
 */
static PyObject *Dtool_LightAttrib_get_light_1572(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-Light *LightAttrib::get_light(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Light *return_value = ((*(const LightAttrib*)local_this).get_light)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Light, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_light(LightAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_light_1572_comment =
  "C++ Interface:\n"
  "get_light(LightAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth light listed in the attribute.\n"
  " *\n"
  " * @deprecated LightAttribs nowadays have a separate list of on_lights and\n"
  " * off_lights, so this method no longer makes sense.  Query the lists\n"
  " * independently.\n"
  " */";
#else
static const char *Dtool_LightAttrib_get_light_1572_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool LightAttrib::has_light(Light *light) const
 */
static PyObject *Dtool_LightAttrib_has_light_1573(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-bool LightAttrib::has_light(Light *light) const
  Light *arg_this = (Light *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Light, 1, "LightAttrib.has_light", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const LightAttrib*)local_this).has_light)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_light(LightAttrib self, Light light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_has_light_1573_comment =
  "C++ Interface:\n"
  "has_light(LightAttrib self, Light light)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated light is listed in the attrib, false\n"
  " * otherwise.\n"
  " *\n"
  " * @deprecated LightAttribs nowadays have a separate list of on_lights and\n"
  " * off_lights, so this method no longer makes sense.  Query the lists\n"
  " * independently.\n"
  " */";
#else
static const char *Dtool_LightAttrib_has_light_1573_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > LightAttrib::add_light(Light *light) const
 */
static PyObject *Dtool_LightAttrib_add_light_1574(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > LightAttrib::add_light(Light *light) const
  Light *arg_this = (Light *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Light, 1, "LightAttrib.add_light", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const LightAttrib*)local_this).add_light)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_light(LightAttrib self, Light light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_add_light_1574_comment =
  "C++ Interface:\n"
  "add_light(LightAttrib self, Light light)\n"
  "\n"
  "/**\n"
  " * Returns a new LightAttrib, just like this one, but with the indicated light\n"
  " * added to the list of lights.\n"
  " *\n"
  " * @deprecated Use add_on_light() or add_off_light() instead.\n"
  " */";
#else
static const char *Dtool_LightAttrib_add_light_1574_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > LightAttrib::remove_light(Light *light) const
 */
static PyObject *Dtool_LightAttrib_remove_light_1575(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > LightAttrib::remove_light(Light *light) const
  Light *arg_this = (Light *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Light, 1, "LightAttrib.remove_light", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const LightAttrib*)local_this).remove_light)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_light(LightAttrib self, Light light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_remove_light_1575_comment =
  "C++ Interface:\n"
  "remove_light(LightAttrib self, Light light)\n"
  "\n"
  "/**\n"
  " * Returns a new LightAttrib, just like this one, but with the indicated light\n"
  " * removed from the list of lights.\n"
  " *\n"
  " * @deprecated Use remove_on_light() or remove_off_light() instead.\n"
  " */";
#else
static const char *Dtool_LightAttrib_remove_light_1575_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LightAttrib::make_all_off(void)
 */
static PyObject *Dtool_LightAttrib_make_all_off_1576(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > LightAttrib::make_all_off(void)
  ConstPointerTo< RenderAttrib > return_value = (LightAttrib::make_all_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_make_all_off_1576_comment =
  "C++ Interface:\n"
  "make_all_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new LightAttrib object that turns off all lights (and hence\n"
  " * disables lighting).\n"
  " */";
#else
static const char *Dtool_LightAttrib_make_all_off_1576_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LightAttrib::get_num_on_lights(void) const
 */
static PyObject *Dtool_LightAttrib_get_num_on_lights_1577(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-inline std::size_t LightAttrib::get_num_on_lights(void) const
  std::size_t return_value = ((*(const LightAttrib*)local_this).get_num_on_lights)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_num_on_lights_1577_comment =
  "C++ Interface:\n"
  "get_num_on_lights(LightAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of lights that are turned on by the attribute.\n"
  " */";
#else
static const char *Dtool_LightAttrib_get_num_on_lights_1577_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LightAttrib::get_num_non_ambient_lights(void) const
 */
static PyObject *Dtool_LightAttrib_get_num_non_ambient_lights_1578(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-inline std::size_t LightAttrib::get_num_non_ambient_lights(void) const
  std::size_t return_value = ((*(const LightAttrib*)local_this).get_num_non_ambient_lights)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_num_non_ambient_lights_1578_comment =
  "C++ Interface:\n"
  "get_num_non_ambient_lights(LightAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of non-ambient lights that are turned on by this\n"
  " * attribute.\n"
  " */";
#else
static const char *Dtool_LightAttrib_get_num_non_ambient_lights_1578_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath LightAttrib::get_on_light(std::size_t n) const
 */
static PyObject *Dtool_LightAttrib_get_on_light_1579(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-inline NodePath LightAttrib::get_on_light(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    NodePath *return_value = new NodePath(((*(const LightAttrib*)local_this).get_on_light)(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_light(LightAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_on_light_1579_comment =
  "C++ Interface:\n"
  "get_on_light(LightAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth light turned on by the attribute, sorted in render order.\n"
  " */";
#else
static const char *Dtool_LightAttrib_get_on_light_1579_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LightAttrib::has_on_light(NodePath const &light) const
 */
static PyObject *Dtool_LightAttrib_has_on_light_1581(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-inline bool LightAttrib::has_on_light(NodePath const &light) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "LightAttrib.has_on_light", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const LightAttrib*)local_this).has_on_light)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_on_light(LightAttrib self, const NodePath light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_has_on_light_1581_comment =
  "C++ Interface:\n"
  "has_on_light(LightAttrib self, const NodePath light)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated light is turned on by the attrib, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LightAttrib_has_on_light_1581_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LightAttrib::has_any_on_light(void) const
 */
static PyObject *Dtool_LightAttrib_has_any_on_light_1582(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-inline bool LightAttrib::has_any_on_light(void) const
  bool return_value = ((*(const LightAttrib*)local_this).has_any_on_light)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_has_any_on_light_1582_comment =
  "C++ Interface:\n"
  "has_any_on_light(LightAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if any light is turned on by the attrib, false otherwise.\n"
  " */";
#else
static const char *Dtool_LightAttrib_has_any_on_light_1582_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LightAttrib::get_num_off_lights(void) const
 */
static PyObject *Dtool_LightAttrib_get_num_off_lights_1583(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-inline std::size_t LightAttrib::get_num_off_lights(void) const
  std::size_t return_value = ((*(const LightAttrib*)local_this).get_num_off_lights)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_num_off_lights_1583_comment =
  "C++ Interface:\n"
  "get_num_off_lights(LightAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of lights that are turned off by the attribute.\n"
  " */";
#else
static const char *Dtool_LightAttrib_get_num_off_lights_1583_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath LightAttrib::get_off_light(std::size_t n) const
 */
static PyObject *Dtool_LightAttrib_get_off_light_1584(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-inline NodePath LightAttrib::get_off_light(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    NodePath *return_value = new NodePath(((*(const LightAttrib*)local_this).get_off_light)(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_off_light(LightAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_off_light_1584_comment =
  "C++ Interface:\n"
  "get_off_light(LightAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth light turned off by the attribute, sorted in arbitrary\n"
  " * (pointer) order.\n"
  " */";
#else
static const char *Dtool_LightAttrib_get_off_light_1584_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LightAttrib::has_off_light(NodePath const &light) const
 */
static PyObject *Dtool_LightAttrib_has_off_light_1586(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-inline bool LightAttrib::has_off_light(NodePath const &light) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "LightAttrib.has_off_light", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const LightAttrib*)local_this).has_off_light)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_off_light(LightAttrib self, const NodePath light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_has_off_light_1586_comment =
  "C++ Interface:\n"
  "has_off_light(LightAttrib self, const NodePath light)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated light is turned off by the attrib, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LightAttrib_has_off_light_1586_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LightAttrib::has_all_off(void) const
 */
static PyObject *Dtool_LightAttrib_has_all_off_1587(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-inline bool LightAttrib::has_all_off(void) const
  bool return_value = ((*(const LightAttrib*)local_this).has_all_off)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_has_all_off_1587_comment =
  "C++ Interface:\n"
  "has_all_off(LightAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if this attrib turns off all lights (although it may also turn\n"
  " * some on).\n"
  " */";
#else
static const char *Dtool_LightAttrib_has_all_off_1587_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LightAttrib::is_identity(void) const
 */
static PyObject *Dtool_LightAttrib_is_identity_1588(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-inline bool LightAttrib::is_identity(void) const
  bool return_value = ((*(const LightAttrib*)local_this).is_identity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_is_identity_1588_comment =
  "C++ Interface:\n"
  "is_identity(LightAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is an identity attrib: it does not change the set of\n"
  " * lights in use.\n"
  " */";
#else
static const char *Dtool_LightAttrib_is_identity_1588_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > LightAttrib::add_on_light(NodePath const &light) const
 */
static PyObject *Dtool_LightAttrib_add_on_light_1589(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > LightAttrib::add_on_light(NodePath const &light) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "LightAttrib.add_on_light", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const LightAttrib*)local_this).add_on_light)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_on_light(LightAttrib self, const NodePath light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_add_on_light_1589_comment =
  "C++ Interface:\n"
  "add_on_light(LightAttrib self, const NodePath light)\n"
  "\n"
  "/**\n"
  " * Returns a new LightAttrib, just like this one, but with the indicated light\n"
  " * added to the list of lights turned on by this attrib.\n"
  " */";
#else
static const char *Dtool_LightAttrib_add_on_light_1589_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > LightAttrib::remove_on_light(NodePath const &light) const
 */
static PyObject *Dtool_LightAttrib_remove_on_light_1590(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > LightAttrib::remove_on_light(NodePath const &light) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "LightAttrib.remove_on_light", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const LightAttrib*)local_this).remove_on_light)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_on_light(LightAttrib self, const NodePath light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_remove_on_light_1590_comment =
  "C++ Interface:\n"
  "remove_on_light(LightAttrib self, const NodePath light)\n"
  "\n"
  "/**\n"
  " * Returns a new LightAttrib, just like this one, but with the indicated light\n"
  " * removed from the list of lights turned on by this attrib.\n"
  " */";
#else
static const char *Dtool_LightAttrib_remove_on_light_1590_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > LightAttrib::add_off_light(NodePath const &light) const
 */
static PyObject *Dtool_LightAttrib_add_off_light_1591(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > LightAttrib::add_off_light(NodePath const &light) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "LightAttrib.add_off_light", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const LightAttrib*)local_this).add_off_light)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_off_light(LightAttrib self, const NodePath light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_add_off_light_1591_comment =
  "C++ Interface:\n"
  "add_off_light(LightAttrib self, const NodePath light)\n"
  "\n"
  "/**\n"
  " * Returns a new LightAttrib, just like this one, but with the indicated light\n"
  " * added to the list of lights turned off by this attrib.\n"
  " */";
#else
static const char *Dtool_LightAttrib_add_off_light_1591_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > LightAttrib::remove_off_light(NodePath const &light) const
 */
static PyObject *Dtool_LightAttrib_remove_off_light_1592(PyObject *self, PyObject *arg) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > LightAttrib::remove_off_light(NodePath const &light) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "LightAttrib.remove_off_light", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const LightAttrib*)local_this).remove_off_light)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_off_light(LightAttrib self, const NodePath light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_remove_off_light_1592_comment =
  "C++ Interface:\n"
  "remove_off_light(LightAttrib self, const NodePath light)\n"
  "\n"
  "/**\n"
  " * Returns a new LightAttrib, just like this one, but with the indicated light\n"
  " * removed from the list of lights turned off by this attrib.\n"
  " */";
#else
static const char *Dtool_LightAttrib_remove_off_light_1592_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath LightAttrib::get_most_important_light(void) const
 */
static PyObject *Dtool_LightAttrib_get_most_important_light_1593(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-NodePath LightAttrib::get_most_important_light(void) const
  NodePath *return_value = new NodePath(((*(const LightAttrib*)local_this).get_most_important_light)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_most_important_light_1593_comment =
  "C++ Interface:\n"
  "get_most_important_light(LightAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the most important light (that is, the light with the highest\n"
  " * priority) in the LightAttrib, excluding any ambient lights.  Returns an\n"
  " * empty NodePath if no non-ambient lights are found.\n"
  " */";
#else
static const char *Dtool_LightAttrib_get_most_important_light_1593_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LColor LightAttrib::get_ambient_contribution(void) const
 */
static PyObject *Dtool_LightAttrib_get_ambient_contribution_1594(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightAttrib)) {
    return nullptr;
  }
  // 1-LColor LightAttrib::get_ambient_contribution(void) const
  LColor *return_value = new LColor(((*(const LightAttrib*)local_this).get_ambient_contribution)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_ambient_contribution_1594_comment =
  "C++ Interface:\n"
  "get_ambient_contribution(LightAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the total contribution of all the ambient lights.\n"
  " */";
#else
static const char *Dtool_LightAttrib_get_ambient_contribution_1594_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int LightAttrib::get_class_slot(void)
 */
static PyObject *Dtool_LightAttrib_get_class_slot_1597(PyObject *, PyObject *) {
  // 1-static int LightAttrib::get_class_slot(void)
  int return_value = (LightAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_class_slot_1597_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_LightAttrib_get_class_slot_1597_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LightAttrib::get_class_type(void)
 */
static PyObject *Dtool_LightAttrib_get_class_type_1599(PyObject *, PyObject *) {
  // 1-static TypeHandle LightAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LightAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightAttrib_get_class_type_1599_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LightAttrib_get_class_type_1599_comment = nullptr;
#endif

/**
 * sequence length function for property LightAttrib::on_lights
 */
static Py_ssize_t Dtool_LightAttrib_on_lights_Len(PyObject *self) {
  LightAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightAttrib, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_on_lights)();
}

/**
 * sequence getter for property LightAttrib::on_lights
 */
static PyObject *Dtool_LightAttrib_on_lights_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  LightAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightAttrib, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_on_lights)()) {
    PyErr_SetString(PyExc_IndexError, "LightAttrib.on_lights[] index out of range");
    return nullptr;
  }
  // 1-inline NodePath LightAttrib::get_on_light(std::size_t n) const
  NodePath *return_value = new NodePath(((*(const LightAttrib*)local_this).get_on_light)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_light(LightAttrib self, index)\n");
  }
}

static PyObject *Dtool_LightAttrib_on_lights_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "LightAttrib.on_lights");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_LightAttrib_on_lights_Len;
    wrap->_getitem_func = &Dtool_LightAttrib_on_lights_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property LightAttrib::off_lights
 */
static Py_ssize_t Dtool_LightAttrib_off_lights_Len(PyObject *self) {
  LightAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightAttrib, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_off_lights)();
}

/**
 * sequence getter for property LightAttrib::off_lights
 */
static PyObject *Dtool_LightAttrib_off_lights_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  LightAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightAttrib, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_off_lights)()) {
    PyErr_SetString(PyExc_IndexError, "LightAttrib.off_lights[] index out of range");
    return nullptr;
  }
  // 1-inline NodePath LightAttrib::get_off_light(std::size_t n) const
  NodePath *return_value = new NodePath(((*(const LightAttrib*)local_this).get_off_light)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_off_light(LightAttrib self, index)\n");
  }
}

static PyObject *Dtool_LightAttrib_off_lights_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "LightAttrib.off_lights");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_LightAttrib_off_lights_Len;
    wrap->_getitem_func = &Dtool_LightAttrib_off_lights_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_LightAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int LightAttrib::get_class_slot(void)
  int return_value = (LightAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_LightAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_LightAttrib(PyObject *args, CPT(LightAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LightAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light)
        int param0;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "iO:make", &param0, &param1)) {
          Light *param1_this = (Light *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Light, 1, "LightAttrib.make", false, false);
          if (param1_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = (LightAttrib::make)((LightAttrib::Operation)param0, param1_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((LightAttrib const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2)
        int param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_ParseTuple(args, "iOO:make", &param0, &param1, &param2)) {
          Light *param1_this = (Light *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Light, 1, "LightAttrib.make", false, false);
          Light *param2_this = (Light *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Light, 2, "LightAttrib.make", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = (LightAttrib::make)((LightAttrib::Operation)param0, param1_this, param2_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((LightAttrib const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2, Light *light3)
        int param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        if (PyArg_ParseTuple(args, "iOOO:make", &param0, &param1, &param2, &param3)) {
          Light *param1_this = (Light *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Light, 1, "LightAttrib.make", false, false);
          Light *param2_this = (Light *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Light, 2, "LightAttrib.make", false, false);
          Light *param3_this = (Light *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Light, 3, "LightAttrib.make", false, false);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = (LightAttrib::make)((LightAttrib::Operation)param0, param1_this, param2_this, param3_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((LightAttrib const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 5: {
        // 1-static ConstPointerTo< RenderAttrib > LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2, Light *light3, Light *light4)
        int param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        if (PyArg_ParseTuple(args, "iOOOO:make", &param0, &param1, &param2, &param3, &param4)) {
          Light *param1_this = (Light *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Light, 1, "LightAttrib.make", false, false);
          Light *param2_this = (Light *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Light, 2, "LightAttrib.make", false, false);
          Light *param3_this = (Light *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Light, 3, "LightAttrib.make", false, false);
          Light *param4_this = (Light *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_Light, 4, "LightAttrib.make", false, false);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr && param4_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = (LightAttrib::make)((LightAttrib::Operation)param0, param1_this, param2_this, param3_this, param4_this);
            if (_PyErr_OCCURRED()) {
              return false;
            } else {
              coerced = std::move((LightAttrib const *) return_value.p());
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LightAttrib_get_on_lights(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightAttrib, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_on_lights)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LightAttrib_get_on_light_1579(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LightAttrib_get_off_lights(PyObject *self, PyObject *) {
  LightAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightAttrib, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_off_lights)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LightAttrib_get_off_light_1584(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_LightAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LightAttrib) {
    printf("LightAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LightAttrib *local_this = (LightAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LightAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LightAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LightAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LightAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (LightAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LightAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LightAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LightAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LightRampAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LightRampAttrib::make_default(void)
 */
static PyObject *Dtool_LightRampAttrib_make_default_1602(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > LightRampAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (LightRampAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_make_default_1602_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Constructs a new LightRampAttrib object.  This is the standard OpenGL\n"
  " * lighting ramp, which clamps the final light total to the 0-1 range.\n"
  " */";
#else
static const char *Dtool_LightRampAttrib_make_default_1602_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LightRampAttrib::make_identity(void)
 */
static PyObject *Dtool_LightRampAttrib_make_identity_1603(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > LightRampAttrib::make_identity(void)
  ConstPointerTo< RenderAttrib > return_value = (LightRampAttrib::make_identity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_make_identity_1603_comment =
  "C++ Interface:\n"
  "make_identity()\n"
  "\n"
  "/**\n"
  " * Constructs a new LightRampAttrib object.  This differs from the usual\n"
  " * OpenGL lighting model in that it does not clamp the final lighting total to\n"
  " * (0,1).\n"
  " */";
#else
static const char *Dtool_LightRampAttrib_make_identity_1603_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LightRampAttrib::make_single_threshold(PN_stdfloat thresh0, PN_stdfloat lev0)
 */
static PyObject *Dtool_LightRampAttrib_make_single_threshold_1604(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > LightRampAttrib::make_single_threshold(PN_stdfloat thresh0, PN_stdfloat lev0)
  float param0;
  float param1;
  static const char *keyword_list[] = {"thresh0", "lev0", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:make_single_threshold", (char **)keyword_list, &param0, &param1)) {
    ConstPointerTo< RenderAttrib > return_value = (LightRampAttrib::make_single_threshold)((PN_stdfloat)param0, (PN_stdfloat)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_single_threshold(float thresh0, float lev0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_make_single_threshold_1604_comment =
  "C++ Interface:\n"
  "make_single_threshold(float thresh0, float lev0)\n"
  "\n"
  "/**\n"
  " * Constructs a new LightRampAttrib object.  This causes the luminance of the\n"
  " * diffuse lighting contribution to be quantized using a single threshold:\n"
  " *\n"
  " * @code\n"
  " * if (original_luminance > threshold0) {\n"
  " *   luminance = level0;\n"
  " * } else {\n"
  " *   luminance = 0.0;\n"
  " * }\n"
  " * @endcode\n"
  " */";
#else
static const char *Dtool_LightRampAttrib_make_single_threshold_1604_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LightRampAttrib::make_double_threshold(PN_stdfloat thresh0, PN_stdfloat lev0, PN_stdfloat thresh1, PN_stdfloat lev1)
 */
static PyObject *Dtool_LightRampAttrib_make_double_threshold_1605(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > LightRampAttrib::make_double_threshold(PN_stdfloat thresh0, PN_stdfloat lev0, PN_stdfloat thresh1, PN_stdfloat lev1)
  float param0;
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"thresh0", "lev0", "thresh1", "lev1", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_double_threshold", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    ConstPointerTo< RenderAttrib > return_value = (LightRampAttrib::make_double_threshold)((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_double_threshold(float thresh0, float lev0, float thresh1, float lev1)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_make_double_threshold_1605_comment =
  "C++ Interface:\n"
  "make_double_threshold(float thresh0, float lev0, float thresh1, float lev1)\n"
  "\n"
  "/**\n"
  " * Constructs a new LightRampAttrib object.  This causes the luminance of the\n"
  " * diffuse lighting contribution to be quantized using two thresholds:\n"
  " *\n"
  " * @code\n"
  " * if (original_luminance > threshold1) {\n"
  " *   luminance = level1;\n"
  " * } else if (original_luminance > threshold0) {\n"
  " *   luminance = level0;\n"
  " * } else {\n"
  " *   luminance = 0.0;\n"
  " * }\n"
  " * @endcode\n"
  " */";
#else
static const char *Dtool_LightRampAttrib_make_double_threshold_1605_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LightRampAttrib::make_hdr0(void)
 */
static PyObject *Dtool_LightRampAttrib_make_hdr0_1606(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > LightRampAttrib::make_hdr0(void)
  ConstPointerTo< RenderAttrib > return_value = (LightRampAttrib::make_hdr0)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_make_hdr0_1606_comment =
  "C++ Interface:\n"
  "make_hdr0()\n"
  "\n"
  "/**\n"
  " * Constructs a new LightRampAttrib object.  This causes an HDR tone mapping\n"
  " * operation to be applied.\n"
  " *\n"
  " * Normally, brightness values greater than 1 cannot be distinguished from\n"
  " * each other, causing very brightly lit objects to wash out white and all\n"
  " * detail to be erased.  HDR tone mapping remaps brightness values in the\n"
  " * range 0-infinity into the range (0,1), making it possible to distinguish\n"
  " * detail in scenes whose brightness exceeds 1.\n"
  " *\n"
  " * However, the monitor has finite contrast.  Normally, all of that contrast\n"
  " * is used to represent brightnesses in the range 0-1.  The HDR0 tone mapping\n"
  " * operator 'steals' one quarter of that contrast to represent brightnesses in\n"
  " * the range 1-infinity.\n"
  " *\n"
  " * @code\n"
  " * FINAL_RGB = (RGB^3 + RGB^2 + RGB) / (RGB^3 + RGB^2 + RGB + 1)\n"
  " * @endcode\n"
  " */";
#else
static const char *Dtool_LightRampAttrib_make_hdr0_1606_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LightRampAttrib::make_hdr1(void)
 */
static PyObject *Dtool_LightRampAttrib_make_hdr1_1607(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > LightRampAttrib::make_hdr1(void)
  ConstPointerTo< RenderAttrib > return_value = (LightRampAttrib::make_hdr1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_make_hdr1_1607_comment =
  "C++ Interface:\n"
  "make_hdr1()\n"
  "\n"
  "/**\n"
  " * Constructs a new LightRampAttrib object.  This causes an HDR tone mapping\n"
  " * operation to be applied.\n"
  " *\n"
  " * Normally, brightness values greater than 1 cannot be distinguished from\n"
  " * each other, causing very brightly lit objects to wash out white and all\n"
  " * detail to be erased.  HDR tone mapping remaps brightness values in the\n"
  " * range 0-infinity into the range (0,1), making it possible to distinguish\n"
  " * detail in scenes whose brightness exceeds 1.\n"
  " *\n"
  " * However, the monitor has finite contrast.  Normally, all of that contrast\n"
  " * is used to represent brightnesses in the range 0-1.  The HDR1 tone mapping\n"
  " * operator 'steals' one third of that contrast to represent brightnesses in\n"
  " * the range 1-infinity.\n"
  " *\n"
  " * @code\n"
  " * FINAL_RGB = (RGB^2 + RGB) / (RGB^2 + RGB + 1)\n"
  " * @endcode\n"
  " */";
#else
static const char *Dtool_LightRampAttrib_make_hdr1_1607_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > LightRampAttrib::make_hdr2(void)
 */
static PyObject *Dtool_LightRampAttrib_make_hdr2_1608(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > LightRampAttrib::make_hdr2(void)
  ConstPointerTo< RenderAttrib > return_value = (LightRampAttrib::make_hdr2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_make_hdr2_1608_comment =
  "C++ Interface:\n"
  "make_hdr2()\n"
  "\n"
  "/**\n"
  " * Constructs a new LightRampAttrib object.  This causes an HDR tone mapping\n"
  " * operation to be applied.\n"
  " *\n"
  " * Normally, brightness values greater than 1 cannot be distinguished from\n"
  " * each other, causing very brightly lit objects to wash out white and all\n"
  " * detail to be erased.  HDR tone mapping remaps brightness values in the\n"
  " * range 0-infinity into the range (0,1), making it possible to distinguish\n"
  " * detail in scenes whose brightness exceeds 1.\n"
  " *\n"
  " * However, the monitor has finite contrast.  Normally, all of that contrast\n"
  " * is used to represent brightnesses in the range 0-1.  The HDR2 tone mapping\n"
  " * operator 'steals' one half of that contrast to represent brightnesses in\n"
  " * the range 1-infinity.\n"
  " *\n"
  " * @code\n"
  " * FINAL_RGB = (RGB) / (RGB + 1)\n"
  " * @endcode\n"
  " */";
#else
static const char *Dtool_LightRampAttrib_make_hdr2_1608_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LightRampAttrib::LightRampMode LightRampAttrib::get_mode(void) const
 */
static PyObject *Dtool_LightRampAttrib_get_mode_1609(PyObject *self, PyObject *) {
  LightRampAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightRampAttrib)) {
    return nullptr;
  }
  // 1-inline LightRampAttrib::LightRampMode LightRampAttrib::get_mode(void) const
  LightRampAttrib::LightRampMode return_value = ((*(const LightRampAttrib*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_get_mode_1609_comment =
  "C++ Interface:\n"
  "get_mode(LightRampAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the LightRampAttrib mode.\n"
  " */";
#else
static const char *Dtool_LightRampAttrib_get_mode_1609_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LightRampAttrib::get_level(int n) const
 */
static PyObject *Dtool_LightRampAttrib_get_level_1610(PyObject *self, PyObject *arg) {
  LightRampAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightRampAttrib)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LightRampAttrib::get_level(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const LightRampAttrib*)local_this).get_level)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_level(LightRampAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_get_level_1610_comment =
  "C++ Interface:\n"
  "get_level(LightRampAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth lighting level.\n"
  " */";
#else
static const char *Dtool_LightRampAttrib_get_level_1610_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LightRampAttrib::get_threshold(int n) const
 */
static PyObject *Dtool_LightRampAttrib_get_threshold_1611(PyObject *self, PyObject *arg) {
  LightRampAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightRampAttrib)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LightRampAttrib::get_threshold(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const LightRampAttrib*)local_this).get_threshold)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_threshold(LightRampAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_get_threshold_1611_comment =
  "C++ Interface:\n"
  "get_threshold(LightRampAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth threshold level.\n"
  " */";
#else
static const char *Dtool_LightRampAttrib_get_threshold_1611_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int LightRampAttrib::get_class_slot(void)
 */
static PyObject *Dtool_LightRampAttrib_get_class_slot_1613(PyObject *, PyObject *) {
  // 1-static int LightRampAttrib::get_class_slot(void)
  int return_value = (LightRampAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_get_class_slot_1613_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_LightRampAttrib_get_class_slot_1613_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LightRampAttrib::get_class_type(void)
 */
static PyObject *Dtool_LightRampAttrib_get_class_type_1615(PyObject *, PyObject *) {
  // 1-static TypeHandle LightRampAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LightRampAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightRampAttrib_get_class_type_1615_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LightRampAttrib_get_class_type_1615_comment = nullptr;
#endif

static PyObject *Dtool_LightRampAttrib_mode_Getter(PyObject *self, void *) {
  const LightRampAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightRampAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LightRampAttrib::LightRampMode LightRampAttrib::get_mode(void) const
  LightRampAttrib::LightRampMode return_value = ((*(const LightRampAttrib*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LightRampAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int LightRampAttrib::get_class_slot(void)
  int return_value = (LightRampAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_LightRampAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LightRampAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LightRampAttrib) {
    printf("LightRampAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LightRampAttrib *local_this = (LightRampAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LightRampAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LightRampAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LightRampAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LightRampAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (LightRampAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LightRampAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LightRampAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LightRampAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Loader
 */
/**
 * Python function wrapper for:
 * inline void Loader::set_task_manager(AsyncTaskManager *task_manager)
 */
static PyObject *Dtool_Loader_set_task_manager_1633(PyObject *self, PyObject *arg) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader, (void **)&local_this, "Loader.set_task_manager")) {
    return nullptr;
  }
  // 1-inline void Loader::set_task_manager(AsyncTaskManager *task_manager)
  AsyncTaskManager *arg_this = (AsyncTaskManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskManager, 1, "Loader.set_task_manager", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_task_manager)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_task_manager(const Loader self, AsyncTaskManager task_manager)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_set_task_manager_1633_comment =
  "C++ Interface:\n"
  "set_task_manager(const Loader self, AsyncTaskManager task_manager)\n"
  "\n"
  "/**\n"
  " * Specifies the task manager that is used for asynchronous loads.  The\n"
  " * default is the global task manager.\n"
  " */";
#else
static const char *Dtool_Loader_set_task_manager_1633_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AsyncTaskManager *Loader::get_task_manager(void) const
 */
static PyObject *Dtool_Loader_get_task_manager_1634(PyObject *self, PyObject *) {
  Loader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Loader)) {
    return nullptr;
  }
  // 1-inline AsyncTaskManager *Loader::get_task_manager(void) const
  AsyncTaskManager *return_value = ((*(const Loader*)local_this).get_task_manager)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskManager, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Loader_get_task_manager_1634_comment =
  "C++ Interface:\n"
  "get_task_manager(Loader self)\n"
  "\n"
  "/**\n"
  " * Returns the task manager that is used for asynchronous loads.\n"
  " */";
#else
static const char *Dtool_Loader_get_task_manager_1634_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Loader::set_task_chain(std::string const &task_chain)
 */
static PyObject *Dtool_Loader_set_task_chain_1635(PyObject *self, PyObject *arg) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader, (void **)&local_this, "Loader.set_task_chain")) {
    return nullptr;
  }
  // 1-inline void Loader::set_task_chain(std::string const &task_chain)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_task_chain)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_task_chain(const Loader self, str task_chain)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_set_task_chain_1635_comment =
  "C++ Interface:\n"
  "set_task_chain(const Loader self, str task_chain)\n"
  "\n"
  "/**\n"
  " * Specifies the task chain that is used for asynchronous loads.  The default\n"
  " * is the initial name of the Loader object.\n"
  " */";
#else
static const char *Dtool_Loader_set_task_chain_1635_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Loader::get_task_chain(void) const
 */
static PyObject *Dtool_Loader_get_task_chain_1636(PyObject *self, PyObject *) {
  Loader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Loader)) {
    return nullptr;
  }
  // 1-inline std::string const &Loader::get_task_chain(void) const
  std::string const &return_value = ((*(const Loader*)local_this).get_task_chain)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Loader_get_task_chain_1636_comment =
  "C++ Interface:\n"
  "get_task_chain(Loader self)\n"
  "\n"
  "/**\n"
  " * Returns the task chain that is used for asynchronous loads.\n"
  " */";
#else
static const char *Dtool_Loader_get_task_chain_1636_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Loader::stop_threads(void)
 */
static PyObject *Dtool_Loader_stop_threads_1637(PyObject *self, PyObject *) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader, (void **)&local_this, "Loader.stop_threads")) {
    return nullptr;
  }
  // 1-inline void Loader::stop_threads(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).stop_threads)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Loader_stop_threads_1637_comment =
  "C++ Interface:\n"
  "stop_threads(const Loader self)\n"
  "\n"
  "/**\n"
  " * Stop any threads used for asynchronous loads.\n"
  " */";
#else
static const char *Dtool_Loader_stop_threads_1637_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Loader::remove(AsyncTask *task)
 */
static PyObject *Dtool_Loader_remove_1638(PyObject *self, PyObject *arg) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader, (void **)&local_this, "Loader.remove")) {
    return nullptr;
  }
  // 1-inline bool Loader::remove(AsyncTask *task)
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "Loader.remove", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove(const Loader self, AsyncTask task)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_remove_1638_comment =
  "C++ Interface:\n"
  "remove(const Loader self, AsyncTask task)\n"
  "\n"
  "/**\n"
  " * Removes a pending asynchronous load request.  Returns true if successful,\n"
  " * false otherwise.\n"
  " * @deprecated use task.cancel() to cancel the request instead.\n"
  " */";
#else
static const char *Dtool_Loader_remove_1638_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< PandaNode > Loader::load_sync(Filename const &filename, LoaderOptions const &options = LoaderOptions()) const
 */
static PyObject *Dtool_Loader_load_sync_1639(PyObject *self, PyObject *args, PyObject *kwds) {
  Loader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Loader)) {
    return nullptr;
  }
  // 1-inline PointerTo< PandaNode > Loader::load_sync(Filename const &filename, LoaderOptions const &options = LoaderOptions()) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"filename", "options", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:load_sync", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Loader.load_sync", "Filename");
    }
    LoaderOptions param2_local;
    LoaderOptions const *param2_this;
    if (param2 != nullptr) {
      param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
    } else {
      param2_local = LoaderOptions();
      param2_this = &param2_local;
    }
    if (param2 != nullptr && !(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Loader.load_sync", "LoaderOptions");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PointerTo< PandaNode > return_value = ((*(const Loader*)local_this).load_sync)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    PandaNode *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_sync(Loader self, const Filename filename, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_load_sync_1639_comment =
  "C++ Interface:\n"
  "load_sync(Loader self, const Filename filename, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Loads the file immediately, waiting for it to complete.\n"
  " *\n"
  " * If search is true, the file is searched for along the model path;\n"
  " * otherwise, only the exact filename is loaded.\n"
  " */";
#else
static const char *Dtool_Loader_load_sync_1639_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< AsyncTask > Loader::make_async_request(Filename const &filename, LoaderOptions const &options = LoaderOptions())
 */
static PyObject *Dtool_Loader_make_async_request_1640(PyObject *self, PyObject *args, PyObject *kwds) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader, (void **)&local_this, "Loader.make_async_request")) {
    return nullptr;
  }
  // 1-PointerTo< AsyncTask > Loader::make_async_request(Filename const &filename, LoaderOptions const &options = LoaderOptions())
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"filename", "options", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:make_async_request", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Loader.make_async_request", "Filename");
    }
    LoaderOptions param2_local;
    LoaderOptions const *param2_this;
    if (param2 != nullptr) {
      param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
    } else {
      param2_local = LoaderOptions();
      param2_this = &param2_local;
    }
    if (param2 != nullptr && !(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Loader.make_async_request", "LoaderOptions");
    }
    PointerTo< AsyncTask > return_value = ((*local_this).make_async_request)(*param1_this, *param2_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    AsyncTask *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AsyncTask, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_async_request(const Loader self, const Filename filename, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_make_async_request_1640_comment =
  "C++ Interface:\n"
  "make_async_request(const Loader self, const Filename filename, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Returns a new AsyncTask object suitable for adding to load_async() to start\n"
  " * an asynchronous model load.\n"
  " */";
#else
static const char *Dtool_Loader_make_async_request_1640_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Loader::load_async(AsyncTask *request)
 */
static PyObject *Dtool_Loader_load_async_1641(PyObject *self, PyObject *arg) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader, (void **)&local_this, "Loader.load_async")) {
    return nullptr;
  }
  // 1-inline void Loader::load_async(AsyncTask *request)
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "Loader.load_async", false, true);
  if (arg_this != nullptr) {
    ((*local_this).load_async)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_async(const Loader self, AsyncTask request)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_load_async_1641_comment =
  "C++ Interface:\n"
  "load_async(const Loader self, AsyncTask request)\n"
  "\n"
  "/**\n"
  " * Begins an asynchronous load request.  To use this call, first call\n"
  " * make_async_request() to create a new ModelLoadRequest object with the\n"
  " * filename you wish to load, and then add that object to the Loader with\n"
  " * load_async.  This function will return immediately, and the model will be\n"
  " * loaded in the background.\n"
  " *\n"
  " * To determine when the model has completely loaded, you may poll\n"
  " * request->is_ready() from time to time, or set the done_event on the request\n"
  " * object and listen for that event.  When the model is ready, you may\n"
  " * retrieve it via request->get_model().\n"
  " */";
#else
static const char *Dtool_Loader_load_async_1641_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Loader::save_sync(Filename const &filename, LoaderOptions const &options, PandaNode *node) const
 */
static PyObject *Dtool_Loader_save_sync_1642(PyObject *self, PyObject *args, PyObject *kwds) {
  Loader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Loader)) {
    return nullptr;
  }
  // 1-inline bool Loader::save_sync(Filename const &filename, LoaderOptions const &options, PandaNode *node) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"filename", "options", "node", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:save_sync", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Loader.save_sync", "Filename");
    }
    LoaderOptions param2_local;
    LoaderOptions const *param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Loader.save_sync", "LoaderOptions");
    }
    PandaNode *param3_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PandaNode, 3, "Loader.save_sync", false, true);
    if (param3_this != nullptr) {
      bool return_value = ((*(const Loader*)local_this).save_sync)(*param1_this, *param2_this, param3_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "save_sync(Loader self, const Filename filename, const LoaderOptions options, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_save_sync_1642_comment =
  "C++ Interface:\n"
  "save_sync(Loader self, const Filename filename, const LoaderOptions options, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Saves the file immediately, waiting for it to complete.\n"
  " */";
#else
static const char *Dtool_Loader_save_sync_1642_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< AsyncTask > Loader::make_async_save_request(Filename const &filename, LoaderOptions const &options, PandaNode *node)
 */
static PyObject *Dtool_Loader_make_async_save_request_1643(PyObject *self, PyObject *args, PyObject *kwds) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader, (void **)&local_this, "Loader.make_async_save_request")) {
    return nullptr;
  }
  // 1-PointerTo< AsyncTask > Loader::make_async_save_request(Filename const &filename, LoaderOptions const &options, PandaNode *node)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"filename", "options", "node", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:make_async_save_request", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Loader.make_async_save_request", "Filename");
    }
    LoaderOptions param2_local;
    LoaderOptions const *param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Loader.make_async_save_request", "LoaderOptions");
    }
    PandaNode *param3_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PandaNode, 3, "Loader.make_async_save_request", false, true);
    if (param3_this != nullptr) {
      PointerTo< AsyncTask > return_value = ((*local_this).make_async_save_request)(*param1_this, *param2_this, param3_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      AsyncTask *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AsyncTask, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_async_save_request(const Loader self, const Filename filename, const LoaderOptions options, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_make_async_save_request_1643_comment =
  "C++ Interface:\n"
  "make_async_save_request(const Loader self, const Filename filename, const LoaderOptions options, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Returns a new AsyncTask object suitable for adding to save_async() to start\n"
  " * an asynchronous model save.\n"
  " */";
#else
static const char *Dtool_Loader_make_async_save_request_1643_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Loader::save_async(AsyncTask *request)
 */
static PyObject *Dtool_Loader_save_async_1644(PyObject *self, PyObject *arg) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader, (void **)&local_this, "Loader.save_async")) {
    return nullptr;
  }
  // 1-inline void Loader::save_async(AsyncTask *request)
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "Loader.save_async", false, true);
  if (arg_this != nullptr) {
    ((*local_this).save_async)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "save_async(const Loader self, AsyncTask request)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_save_async_1644_comment =
  "C++ Interface:\n"
  "save_async(const Loader self, AsyncTask request)\n"
  "\n"
  "/**\n"
  " * Begins an asynchronous save request.  To use this call, first call\n"
  " * make_async_save_request() to create a new ModelSaveRequest object with the\n"
  " * filename you wish to load, and then add that object to the Loader with\n"
  " * save_async.  This function will return immediately, and the model will be\n"
  " * loaded in the background.\n"
  " *\n"
  " * To determine when the model has completely loaded, you may poll\n"
  " * request->is_ready() from time to time, or set the done_event on the request\n"
  " * object and listen for that event.  When the request is ready, you may\n"
  " * retrieve the success or failure via request->get_success().\n"
  " */";
#else
static const char *Dtool_Loader_save_async_1644_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > Loader::load_bam_stream(std::istream &in)
 */
static PyObject *Dtool_Loader_load_bam_stream_1645(PyObject *self, PyObject *arg) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader, (void **)&local_this, "Loader.load_bam_stream")) {
    return nullptr;
  }
  // 1-PointerTo< PandaNode > Loader::load_bam_stream(std::istream &in)
  std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 1, "Loader.load_bam_stream", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PointerTo< PandaNode > return_value = ((*local_this).load_bam_stream)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    PandaNode *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_bam_stream(const Loader self, istream in)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_load_bam_stream_1645_comment =
  "C++ Interface:\n"
  "load_bam_stream(const Loader self, istream in)\n"
  "\n"
  "/**\n"
  " * Attempts to read a bam file from the indicated stream and return the scene\n"
  " * graph defined there.\n"
  " */";
#else
static const char *Dtool_Loader_load_bam_stream_1645_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Loader::output(std::ostream &out) const
 */
static PyObject *Dtool_Loader_output_1646(PyObject *self, PyObject *arg) {
  Loader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Loader)) {
    return nullptr;
  }
  // 1-virtual void Loader::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Loader.output", false, true);
  if (arg_this != nullptr) {
    ((*(const Loader*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Loader self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_output_1646_comment =
  "C++ Interface:\n"
  "output(Loader self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Loader_output_1646_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Loader *Loader::get_global_ptr(void)
 */
static PyObject *Dtool_Loader_get_global_ptr_1647(PyObject *, PyObject *) {
  // 1-static inline Loader *Loader::get_global_ptr(void)
  Loader *return_value = (Loader::get_global_ptr)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Loader, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Loader_get_global_ptr_1647_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global Loader.  This is the Loader that most code\n"
  " * should use for loading models.\n"
  " */";
#else
static const char *Dtool_Loader_get_global_ptr_1647_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Loader::get_class_type(void)
 */
static PyObject *Dtool_Loader_get_class_type_1648(PyObject *, PyObject *) {
  // 1-static TypeHandle Loader::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Loader::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Loader_get_class_type_1648_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Loader_get_class_type_1648_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *Loader::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_Loader_upcast_to_TypedReferenceCount_1618(PyObject *self, PyObject *) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader, (void **)&local_this, "Loader.upcast_to_TypedReferenceCount")) {
    return nullptr;
  }
  // 1-TypedReferenceCount *Loader::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Loader_upcast_to_TypedReferenceCount_1618_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const Loader self)\n"
  "\n"
  "upcast from Loader to TypedReferenceCount";
#else
static const char *Dtool_Loader_upcast_to_TypedReferenceCount_1618_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *Loader::upcast_to_Namable(void)
 */
static PyObject *Dtool_Loader_upcast_to_Namable_1620(PyObject *self, PyObject *) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader, (void **)&local_this, "Loader.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *Loader::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Loader_upcast_to_Namable_1620_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const Loader self)\n"
  "\n"
  "upcast from Loader to Namable";
#else
static const char *Dtool_Loader_upcast_to_Namable_1620_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Loader::Loader(Loader const &) = default
 * explicit Loader::Loader(std::string const &name = "loader")
 */
static int Dtool_Init_Loader(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit Loader::Loader(std::string const &name)
      Loader *return_value = new Loader();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Loader, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Loader::Loader(Loader const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          Loader const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Loader);
          if (param0_this != nullptr) {
            Loader *return_value = new Loader(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Loader, true, false);
          }
        }
      }

      {
        // -2 explicit Loader::Loader(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Loader", (char **)keyword_list, &param0_str, &param0_len)) {
          Loader *return_value = new Loader(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Loader, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline Loader::Loader(Loader const &) = default
      // No coercion possible: explicit Loader::Loader(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Loader() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Loader()\n"
      "Loader(const Loader param0)\n"
      "Loader(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Loader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Loader) {
    printf("Loader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Loader *local_this = (Loader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Loader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Loader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Loader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Loader*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Loader*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Loader*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (Loader*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Loader::Results
 */
/**
 * Python function wrapper for:
 * inline void Loader::Results::operator =(Loader::Results const &copy)
 */
static PyObject *Dtool_Loader_Results_operator_1624(PyObject *self, PyObject *arg) {
  Loader::Results *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader_Results, (void **)&local_this, "Loader::Results.assign")) {
    return nullptr;
  }
  // 1-inline void Loader::Results::operator =(Loader::Results const &copy)
  Loader::Results const *arg_this = (Loader::Results *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Loader_Results, 1, "Results.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    Loader::Results *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Loader_Results, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Results self, const Results copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_Results_operator_1624_comment =
  "C++ Interface:\n"
  "assign(const Results self, const Results copy)\n";
#else
static const char *Dtool_Loader_Results_operator_1624_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Loader::Results::clear(void)
 */
static PyObject *Dtool_Loader_Results_clear_1626(PyObject *self, PyObject *) {
  Loader::Results *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Loader_Results, (void **)&local_this, "Loader::Results.clear")) {
    return nullptr;
  }
  // 1-inline void Loader::Results::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Loader_Results_clear_1626_comment =
  "C++ Interface:\n"
  "clear(const Results self)\n"
  "\n"
  "/**\n"
  " * Removes all the files from the list.\n"
  " */";
#else
static const char *Dtool_Loader_Results_clear_1626_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Loader::Results::get_num_files(void) const
 */
static PyObject *Dtool_Loader_Results_get_num_files_1627(PyObject *self, PyObject *) {
  Loader::Results *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Loader_Results)) {
    return nullptr;
  }
  // 1-inline int Loader::Results::get_num_files(void) const
  int return_value = ((*(const Loader::Results*)local_this).get_num_files)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Loader_Results_get_num_files_1627_comment =
  "C++ Interface:\n"
  "get_num_files(Results self)\n"
  "\n"
  "/**\n"
  " * Returns the number of files on the result list.\n"
  " */";
#else
static const char *Dtool_Loader_Results_get_num_files_1627_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &Loader::Results::get_file(int n) const
 */
static PyObject *Dtool_Loader_Results_get_file_1628(PyObject *self, PyObject *arg) {
  Loader::Results *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Loader_Results)) {
    return nullptr;
  }
  // 1-inline Filename const &Loader::Results::get_file(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Filename const *return_value = &(((*(const Loader::Results*)local_this).get_file)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_file(Results self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_Results_get_file_1628_comment =
  "C++ Interface:\n"
  "get_file(Results self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth file on the result list.\n"
  " */";
#else
static const char *Dtool_Loader_Results_get_file_1628_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LoaderFileType *Loader::Results::get_file_type(int n) const
 */
static PyObject *Dtool_Loader_Results_get_file_type_1630(PyObject *self, PyObject *arg) {
  Loader::Results *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Loader_Results)) {
    return nullptr;
  }
  // 1-inline LoaderFileType *Loader::Results::get_file_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LoaderFileType *return_value = ((*(const Loader::Results*)local_this).get_file_type)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LoaderFileType, false, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_file_type(Results self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Loader_Results_get_file_type_1630_comment =
  "C++ Interface:\n"
  "get_file_type(Results self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the file type of the nth file on the result list.\n"
  " */";
#else
static const char *Dtool_Loader_Results_get_file_type_1630_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Loader::Results::Results(void)
 * inline Loader::Results::Results(Loader::Results const &copy)
 */
static int Dtool_Init_Loader_Results(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Loader::Results::Results(void)
      Loader::Results *return_value = new Loader::Results();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Loader_Results, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline Loader::Results::Results(Loader::Results const &copy)
        Loader::Results const *arg_this = (Loader::Results *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Loader_Results, 0, "Results.Results", true, true);
        if (arg_this != nullptr) {
          Loader::Results *return_value = new Loader::Results(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Loader_Results, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Results() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Results()\n"
      "Results(const Results copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Loader_Results_get_files(PyObject *self, PyObject *) {
  Loader::Results *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Loader_Results, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_files)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Loader_Results_get_file_1628(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Loader_Results_get_file_types(PyObject *self, PyObject *) {
  Loader::Results *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Loader_Results, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_files)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Loader_Results_get_file_type_1630(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Loader_Results(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Loader_Results) {
    printf("Loader_Results ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Loader::Results *local_this = (Loader::Results *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Loader_Results) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Loader_Results(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Loader_Results) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LoaderFileType
 */
/**
 * Python function wrapper for:
 * virtual std::string LoaderFileType::get_name(void) const = 0
 */
static PyObject *Dtool_LoaderFileType_get_name_1652(PyObject *self, PyObject *) {
  LoaderFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderFileType)) {
    return nullptr;
  }
  // 1-virtual std::string LoaderFileType::get_name(void) const = 0
  std::string return_value = ((*(const LoaderFileType*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileType_get_name_1652_comment =
  "C++ Interface:\n"
  "get_name(LoaderFileType self)\n";
#else
static const char *Dtool_LoaderFileType_get_name_1652_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string LoaderFileType::get_extension(void) const = 0
 */
static PyObject *Dtool_LoaderFileType_get_extension_1653(PyObject *self, PyObject *) {
  LoaderFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderFileType)) {
    return nullptr;
  }
  // 1-virtual std::string LoaderFileType::get_extension(void) const = 0
  std::string return_value = ((*(const LoaderFileType*)local_this).get_extension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileType_get_extension_1653_comment =
  "C++ Interface:\n"
  "get_extension(LoaderFileType self)\n";
#else
static const char *Dtool_LoaderFileType_get_extension_1653_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string LoaderFileType::get_additional_extensions(void) const
 */
static PyObject *Dtool_LoaderFileType_get_additional_extensions_1654(PyObject *self, PyObject *) {
  LoaderFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderFileType)) {
    return nullptr;
  }
  // 1-virtual std::string LoaderFileType::get_additional_extensions(void) const
  std::string return_value = ((*(const LoaderFileType*)local_this).get_additional_extensions)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileType_get_additional_extensions_1654_comment =
  "C++ Interface:\n"
  "get_additional_extensions(LoaderFileType self)\n"
  "\n"
  "/**\n"
  " * Returns a space-separated list of extension, in addition to the one\n"
  " * returned by get_extension(), that are recognized by this loader.\n"
  " */";
#else
static const char *Dtool_LoaderFileType_get_additional_extensions_1654_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool LoaderFileType::supports_compressed(void) const
 */
static PyObject *Dtool_LoaderFileType_supports_compressed_1655(PyObject *self, PyObject *) {
  LoaderFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderFileType)) {
    return nullptr;
  }
  // 1-virtual bool LoaderFileType::supports_compressed(void) const
  bool return_value = ((*(const LoaderFileType*)local_this).supports_compressed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileType_supports_compressed_1655_comment =
  "C++ Interface:\n"
  "supports_compressed(LoaderFileType self)\n"
  "\n"
  "/**\n"
  " * Returns true if this file type can transparently load compressed files\n"
  " * (with a .pz or .gz extension), false otherwise.\n"
  " */";
#else
static const char *Dtool_LoaderFileType_supports_compressed_1655_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool LoaderFileType::get_allow_disk_cache(LoaderOptions const &options) const
 */
static PyObject *Dtool_LoaderFileType_get_allow_disk_cache_1656(PyObject *self, PyObject *arg) {
  LoaderFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderFileType)) {
    return nullptr;
  }
  // 1-virtual bool LoaderFileType::get_allow_disk_cache(LoaderOptions const &options) const
  LoaderOptions arg_local;
  LoaderOptions const *arg_this = Dtool_Coerce_LoaderOptions(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LoaderFileType.get_allow_disk_cache", "LoaderOptions");
  }
  bool return_value = ((*(const LoaderFileType*)local_this).get_allow_disk_cache)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_allow_disk_cache(LoaderFileType self, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileType_get_allow_disk_cache_1656_comment =
  "C++ Interface:\n"
  "get_allow_disk_cache(LoaderFileType self, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Returns true if the loader flags allow retrieving the model from the on-\n"
  " * disk bam cache (if it is enabled), false otherwise.\n"
  " */";
#else
static const char *Dtool_LoaderFileType_get_allow_disk_cache_1656_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool LoaderFileType::get_allow_ram_cache(LoaderOptions const &options) const
 */
static PyObject *Dtool_LoaderFileType_get_allow_ram_cache_1657(PyObject *self, PyObject *arg) {
  LoaderFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderFileType)) {
    return nullptr;
  }
  // 1-virtual bool LoaderFileType::get_allow_ram_cache(LoaderOptions const &options) const
  LoaderOptions arg_local;
  LoaderOptions const *arg_this = Dtool_Coerce_LoaderOptions(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LoaderFileType.get_allow_ram_cache", "LoaderOptions");
  }
  bool return_value = ((*(const LoaderFileType*)local_this).get_allow_ram_cache)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_allow_ram_cache(LoaderFileType self, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileType_get_allow_ram_cache_1657_comment =
  "C++ Interface:\n"
  "get_allow_ram_cache(LoaderFileType self, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Returns true if the loader flags allow retrieving the model from the in-\n"
  " * memory ModelPool cache, false otherwise.\n"
  " */";
#else
static const char *Dtool_LoaderFileType_get_allow_ram_cache_1657_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool LoaderFileType::supports_load(void) const
 */
static PyObject *Dtool_LoaderFileType_supports_load_1658(PyObject *self, PyObject *) {
  LoaderFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderFileType)) {
    return nullptr;
  }
  // 1-virtual bool LoaderFileType::supports_load(void) const
  bool return_value = ((*(const LoaderFileType*)local_this).supports_load)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileType_supports_load_1658_comment =
  "C++ Interface:\n"
  "supports_load(LoaderFileType self)\n"
  "\n"
  "/**\n"
  " * Returns true if the file type can be used to load files, and load_file() is\n"
  " * supported.  Returns false if load_file() is unimplemented and will always\n"
  " * fail.\n"
  " */";
#else
static const char *Dtool_LoaderFileType_supports_load_1658_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool LoaderFileType::supports_save(void) const
 */
static PyObject *Dtool_LoaderFileType_supports_save_1659(PyObject *self, PyObject *) {
  LoaderFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderFileType)) {
    return nullptr;
  }
  // 1-virtual bool LoaderFileType::supports_save(void) const
  bool return_value = ((*(const LoaderFileType*)local_this).supports_save)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileType_supports_save_1659_comment =
  "C++ Interface:\n"
  "supports_save(LoaderFileType self)\n"
  "\n"
  "/**\n"
  " * Returns true if the file type can be used to save files, and save_file() is\n"
  " * supported.  Returns false if save_file() is unimplemented and will always\n"
  " * fail.\n"
  " */";
#else
static const char *Dtool_LoaderFileType_supports_save_1659_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LoaderFileType::get_class_type(void)
 */
static PyObject *Dtool_LoaderFileType_get_class_type_1660(PyObject *, PyObject *) {
  // 1-static TypeHandle LoaderFileType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LoaderFileType::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileType_get_class_type_1660_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LoaderFileType_get_class_type_1660_comment = nullptr;
#endif

static int Dtool_Init_LoaderFileType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LoaderFileType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LoaderFileType) {
    printf("LoaderFileType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LoaderFileType *local_this = (LoaderFileType *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LoaderFileType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LoaderFileType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LoaderFileType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LoaderFileType*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LoaderFileTypeRegistry
 */
/**
 * Python function wrapper for:
 * void LoaderFileTypeRegistry::register_type(PyObject *type)
 */
static PyObject *Dtool_LoaderFileTypeRegistry_register_type_1663(PyObject *self, PyObject *arg) {
  LoaderFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderFileTypeRegistry, (void **)&local_this, "LoaderFileTypeRegistry.register_type")) {
    return nullptr;
  }
  // 1-void LoaderFileTypeRegistry::register_type(PyObject *type)
  invoke_extension(local_this).register_type(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_type(const LoaderFileTypeRegistry self, object type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileTypeRegistry_register_type_1663_comment =
  "C++ Interface:\n"
  "register_type(const LoaderFileTypeRegistry self, object type)\n"
  "\n"
  "/**\n"
  " * Defines a new LoaderFileType in the universe.\n"
  " */";
#else
static const char *Dtool_LoaderFileTypeRegistry_register_type_1663_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LoaderFileTypeRegistry::register_deferred_type(PyObject *entry_point)
 */
static PyObject *Dtool_LoaderFileTypeRegistry_register_deferred_type_1664(PyObject *self, PyObject *arg) {
  LoaderFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderFileTypeRegistry, (void **)&local_this, "LoaderFileTypeRegistry.register_deferred_type")) {
    return nullptr;
  }
  // 1-void LoaderFileTypeRegistry::register_deferred_type(PyObject *entry_point)
  invoke_extension(local_this).register_deferred_type(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_deferred_type(const LoaderFileTypeRegistry self, object entry_point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileTypeRegistry_register_deferred_type_1664_comment =
  "C++ Interface:\n"
  "register_deferred_type(const LoaderFileTypeRegistry self, object entry_point)\n"
  "\n"
  "/**\n"
  " * Records a type associated with a particular extension to be loaded in the\n"
  " * future.  The named library will be dynamically loaded the first time files\n"
  " * of this extension are loaded; presumably this library will call\n"
  " * register_type() when it initializes, thus making the extension loadable.\n"
  " */";
#else
static const char *Dtool_LoaderFileTypeRegistry_register_deferred_type_1664_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LoaderFileTypeRegistry::unregister_type(PyObject *type)
 */
static PyObject *Dtool_LoaderFileTypeRegistry_unregister_type_1665(PyObject *self, PyObject *arg) {
  LoaderFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderFileTypeRegistry, (void **)&local_this, "LoaderFileTypeRegistry.unregister_type")) {
    return nullptr;
  }
  // 1-void LoaderFileTypeRegistry::unregister_type(PyObject *type)
  invoke_extension(local_this).unregister_type(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unregister_type(const LoaderFileTypeRegistry self, object type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileTypeRegistry_unregister_type_1665_comment =
  "C++ Interface:\n"
  "unregister_type(const LoaderFileTypeRegistry self, object type)\n"
  "\n"
  "/**\n"
  " * Removes a type previously registered using register_type.\n"
  " */";
#else
static const char *Dtool_LoaderFileTypeRegistry_unregister_type_1665_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int LoaderFileTypeRegistry::get_num_types(void) const
 */
static PyObject *Dtool_LoaderFileTypeRegistry_get_num_types_1666(PyObject *self, PyObject *) {
  LoaderFileTypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderFileTypeRegistry)) {
    return nullptr;
  }
  // 1-int LoaderFileTypeRegistry::get_num_types(void) const
  int return_value = ((*(const LoaderFileTypeRegistry*)local_this).get_num_types)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileTypeRegistry_get_num_types_1666_comment =
  "C++ Interface:\n"
  "get_num_types(LoaderFileTypeRegistry self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of types registered.\n"
  " */";
#else
static const char *Dtool_LoaderFileTypeRegistry_get_num_types_1666_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LoaderFileType *LoaderFileTypeRegistry::get_type(int n) const
 */
static PyObject *Dtool_LoaderFileTypeRegistry_get_type_1667(PyObject *self, PyObject *arg) {
  LoaderFileTypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderFileTypeRegistry)) {
    return nullptr;
  }
  // 1-LoaderFileType *LoaderFileTypeRegistry::get_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LoaderFileType *return_value = ((*(const LoaderFileTypeRegistry*)local_this).get_type)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LoaderFileType, false, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type(LoaderFileTypeRegistry self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileTypeRegistry_get_type_1667_comment =
  "C++ Interface:\n"
  "get_type(LoaderFileTypeRegistry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth type registered.\n"
  " */";
#else
static const char *Dtool_LoaderFileTypeRegistry_get_type_1667_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LoaderFileType *LoaderFileTypeRegistry::get_type_from_extension(std::string const &extension)
 */
static PyObject *Dtool_LoaderFileTypeRegistry_get_type_from_extension_1671(PyObject *self, PyObject *arg) {
  LoaderFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderFileTypeRegistry, (void **)&local_this, "LoaderFileTypeRegistry.get_type_from_extension")) {
    return nullptr;
  }
  // 1-LoaderFileType *LoaderFileTypeRegistry::get_type_from_extension(std::string const &extension)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    LoaderFileType *return_value = ((*local_this).get_type_from_extension)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LoaderFileType, false, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type_from_extension(const LoaderFileTypeRegistry self, str extension)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileTypeRegistry_get_type_from_extension_1671_comment =
  "C++ Interface:\n"
  "get_type_from_extension(const LoaderFileTypeRegistry self, str extension)\n"
  "\n"
  "/**\n"
  " * Determines the type of the file based on the indicated extension (without a\n"
  " * leading dot).  Returns NULL if the extension matches no known file types.\n"
  " */";
#else
static const char *Dtool_LoaderFileTypeRegistry_get_type_from_extension_1671_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LoaderFileTypeRegistry::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LoaderFileTypeRegistry_write_1672(PyObject *self, PyObject *args, PyObject *kwds) {
  LoaderFileTypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderFileTypeRegistry)) {
    return nullptr;
  }
  // 1-void LoaderFileTypeRegistry::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "LoaderFileTypeRegistry.write", false, true);
    if (param1_this != nullptr) {
      ((*(const LoaderFileTypeRegistry*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LoaderFileTypeRegistry self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileTypeRegistry_write_1672_comment =
  "C++ Interface:\n"
  "write(LoaderFileTypeRegistry self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a list of supported file types to the indicated output stream, one\n"
  " * per line.\n"
  " */";
#else
static const char *Dtool_LoaderFileTypeRegistry_write_1672_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static LoaderFileTypeRegistry *LoaderFileTypeRegistry::get_global_ptr(void)
 */
static PyObject *Dtool_LoaderFileTypeRegistry_get_global_ptr_1673(PyObject *, PyObject *) {
  // 1-static LoaderFileTypeRegistry *LoaderFileTypeRegistry::get_global_ptr(void)
  LoaderFileTypeRegistry *return_value = (LoaderFileTypeRegistry::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LoaderFileTypeRegistry, false, false);
}

#ifndef NDEBUG
static const char *Dtool_LoaderFileTypeRegistry_get_global_ptr_1673_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global LoaderFileTypeRegistry object.\n"
  " */";
#else
static const char *Dtool_LoaderFileTypeRegistry_get_global_ptr_1673_comment = nullptr;
#endif

/**
 * sequence length function for property LoaderFileTypeRegistry::types
 */
static Py_ssize_t Dtool_LoaderFileTypeRegistry_types_Len(PyObject *self) {
  LoaderFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderFileTypeRegistry, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_types)();
}

/**
 * sequence getter for property LoaderFileTypeRegistry::types
 */
static PyObject *Dtool_LoaderFileTypeRegistry_types_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  LoaderFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderFileTypeRegistry, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_types)()) {
    PyErr_SetString(PyExc_IndexError, "LoaderFileTypeRegistry.types[] index out of range");
    return nullptr;
  }
  // 1-LoaderFileType *LoaderFileTypeRegistry::get_type(int n) const
  LoaderFileType *return_value = ((*(const LoaderFileTypeRegistry*)local_this).get_type)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LoaderFileType, false, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type(LoaderFileTypeRegistry self, index)\n");
  }
}

static PyObject *Dtool_LoaderFileTypeRegistry_types_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "LoaderFileTypeRegistry.types");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_LoaderFileTypeRegistry_types_Len;
    wrap->_getitem_func = &Dtool_LoaderFileTypeRegistry_types_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline LoaderFileTypeRegistry::LoaderFileTypeRegistry(LoaderFileTypeRegistry const &) = default
 */
static int Dtool_Init_LoaderFileTypeRegistry(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("LoaderFileTypeRegistry() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline LoaderFileTypeRegistry::LoaderFileTypeRegistry(LoaderFileTypeRegistry const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    LoaderFileTypeRegistry const *param0_this = (LoaderFileTypeRegistry *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LoaderFileTypeRegistry, 0, "LoaderFileTypeRegistry.LoaderFileTypeRegistry", true, true);
    if (param0_this != nullptr) {
      LoaderFileTypeRegistry *return_value = new LoaderFileTypeRegistry(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LoaderFileTypeRegistry, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LoaderFileTypeRegistry(const LoaderFileTypeRegistry param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LoaderFileTypeRegistry_get_types(PyObject *self, PyObject *) {
  LoaderFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderFileTypeRegistry, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_types)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LoaderFileTypeRegistry_get_type_1667(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_LoaderFileTypeRegistry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LoaderFileTypeRegistry) {
    printf("LoaderFileTypeRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LoaderFileTypeRegistry *local_this = (LoaderFileTypeRegistry *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LoaderFileTypeRegistry) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LoaderFileTypeRegistry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LoaderFileTypeRegistry) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MaterialAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > MaterialAttrib::make(Material *material)
 */
static PyObject *Dtool_MaterialAttrib_make_1676(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > MaterialAttrib::make(Material *material)
  Material *arg_this = (Material *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Material, 0, "MaterialAttrib.make", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = (MaterialAttrib::make)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(Material material)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialAttrib_make_1676_comment =
  "C++ Interface:\n"
  "make(Material material)\n"
  "\n"
  "/**\n"
  " * Constructs a new MaterialAttrib object suitable for rendering the indicated\n"
  " * material onto geometry.\n"
  " */";
#else
static const char *Dtool_MaterialAttrib_make_1676_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > MaterialAttrib::make_off(void)
 */
static PyObject *Dtool_MaterialAttrib_make_off_1677(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > MaterialAttrib::make_off(void)
  ConstPointerTo< RenderAttrib > return_value = (MaterialAttrib::make_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MaterialAttrib_make_off_1677_comment =
  "C++ Interface:\n"
  "make_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new MaterialAttrib object suitable for rendering unmateriald\n"
  " * geometry.\n"
  " */";
#else
static const char *Dtool_MaterialAttrib_make_off_1677_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > MaterialAttrib::make_default(void)
 */
static PyObject *Dtool_MaterialAttrib_make_default_1678(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > MaterialAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (MaterialAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MaterialAttrib_make_default_1678_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_MaterialAttrib_make_default_1678_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MaterialAttrib::is_off(void) const
 */
static PyObject *Dtool_MaterialAttrib_is_off_1679(PyObject *self, PyObject *) {
  MaterialAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MaterialAttrib)) {
    return nullptr;
  }
  // 1-inline bool MaterialAttrib::is_off(void) const
  bool return_value = ((*(const MaterialAttrib*)local_this).is_off)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MaterialAttrib_is_off_1679_comment =
  "C++ Interface:\n"
  "is_off(MaterialAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if the MaterialAttrib is an 'off' MaterialAttrib, indicating\n"
  " * that it should disable the use of materials.\n"
  " */";
#else
static const char *Dtool_MaterialAttrib_is_off_1679_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Material *MaterialAttrib::get_material(void) const
 */
static PyObject *Dtool_MaterialAttrib_get_material_1680(PyObject *self, PyObject *) {
  MaterialAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MaterialAttrib)) {
    return nullptr;
  }
  // 1-inline Material *MaterialAttrib::get_material(void) const
  Material *return_value = ((*(const MaterialAttrib*)local_this).get_material)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Material, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MaterialAttrib_get_material_1680_comment =
  "C++ Interface:\n"
  "get_material(MaterialAttrib self)\n"
  "\n"
  "/**\n"
  " * If the MaterialAttrib is not an 'off' MaterialAttrib, returns the material\n"
  " * that is associated.  Otherwise, return NULL.\n"
  " */";
#else
static const char *Dtool_MaterialAttrib_get_material_1680_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int MaterialAttrib::get_class_slot(void)
 */
static PyObject *Dtool_MaterialAttrib_get_class_slot_1684(PyObject *, PyObject *) {
  // 1-static int MaterialAttrib::get_class_slot(void)
  int return_value = (MaterialAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MaterialAttrib_get_class_slot_1684_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_MaterialAttrib_get_class_slot_1684_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MaterialAttrib::get_class_type(void)
 */
static PyObject *Dtool_MaterialAttrib_get_class_type_1686(PyObject *, PyObject *) {
  // 1-static TypeHandle MaterialAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MaterialAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MaterialAttrib_get_class_type_1686_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MaterialAttrib_get_class_type_1686_comment = nullptr;
#endif

static PyObject *Dtool_MaterialAttrib_material_Getter(PyObject *self, void *) {
  const MaterialAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MaterialAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Material *MaterialAttrib::get_material(void) const
  Material *return_value = ((*(const MaterialAttrib*)local_this).get_material)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Material, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_MaterialAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int MaterialAttrib::get_class_slot(void)
  int return_value = (MaterialAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_MaterialAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_MaterialAttrib(PyObject *args, CPT(MaterialAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_MaterialAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > MaterialAttrib::make(Material *material)
    Material *arg_this = (Material *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Material, 0, "MaterialAttrib.make", false, false);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = (MaterialAttrib::make)(arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((MaterialAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_MaterialAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MaterialAttrib) {
    printf("MaterialAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MaterialAttrib *local_this = (MaterialAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MaterialAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MaterialAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MaterialAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (MaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MaterialAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ModelFlattenRequest
 */
/**
 * Python function wrapper for:
 * inline PandaNode *ModelFlattenRequest::get_orig(void) const
 */
static PyObject *Dtool_ModelFlattenRequest_get_orig_1691(PyObject *self, PyObject *) {
  ModelFlattenRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelFlattenRequest)) {
    return nullptr;
  }
  // 1-inline PandaNode *ModelFlattenRequest::get_orig(void) const
  PandaNode *return_value = ((*(const ModelFlattenRequest*)local_this).get_orig)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ModelFlattenRequest_get_orig_1691_comment =
  "C++ Interface:\n"
  "get_orig(ModelFlattenRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the original, unflattened node.\n"
  " */";
#else
static const char *Dtool_ModelFlattenRequest_get_orig_1691_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ModelFlattenRequest::is_ready(void) const
 */
static PyObject *Dtool_ModelFlattenRequest_is_ready_1692(PyObject *self, PyObject *) {
  ModelFlattenRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelFlattenRequest)) {
    return nullptr;
  }
  // 1-inline bool ModelFlattenRequest::is_ready(void) const
  bool return_value = ((*(const ModelFlattenRequest*)local_this).is_ready)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModelFlattenRequest_is_ready_1692_comment =
  "C++ Interface:\n"
  "is_ready(ModelFlattenRequest self)\n"
  "\n"
  "/**\n"
  " * Returns true if this request has completed, false if it is still pending.\n"
  " * When this returns true, you may retrieve the model loaded by calling\n"
  " * result().\n"
  " * Equivalent to `req.done() and not req.cancelled()`.\n"
  " * @see done()\n"
  " */";
#else
static const char *Dtool_ModelFlattenRequest_is_ready_1692_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *ModelFlattenRequest::get_model(void) const
 */
static PyObject *Dtool_ModelFlattenRequest_get_model_1693(PyObject *self, PyObject *) {
  ModelFlattenRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelFlattenRequest)) {
    return nullptr;
  }
  // 1-inline PandaNode *ModelFlattenRequest::get_model(void) const
  PandaNode *return_value = ((*(const ModelFlattenRequest*)local_this).get_model)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ModelFlattenRequest_get_model_1693_comment =
  "C++ Interface:\n"
  "get_model(ModelFlattenRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the flattened copy of the model.  It is an error to call this\n"
  " * unless done() returns true.\n"
  " * @deprecated Use result() instead.\n"
  " */";
#else
static const char *Dtool_ModelFlattenRequest_get_model_1693_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ModelFlattenRequest::get_class_type(void)
 */
static PyObject *Dtool_ModelFlattenRequest_get_class_type_1695(PyObject *, PyObject *) {
  // 1-static TypeHandle ModelFlattenRequest::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ModelFlattenRequest::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ModelFlattenRequest_get_class_type_1695_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ModelFlattenRequest_get_class_type_1695_comment = nullptr;
#endif

static PyObject *Dtool_ModelFlattenRequest_orig_Getter(PyObject *self, void *) {
  const ModelFlattenRequest *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelFlattenRequest, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PandaNode *ModelFlattenRequest::get_orig(void) const
  PandaNode *return_value = ((*(const ModelFlattenRequest*)local_this).get_orig)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * inline ModelFlattenRequest::ModelFlattenRequest(ModelFlattenRequest const &) = default
 * inline explicit ModelFlattenRequest::ModelFlattenRequest(PandaNode *orig)
 */
static int Dtool_Init_ModelFlattenRequest(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ModelFlattenRequest() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ModelFlattenRequest::ModelFlattenRequest(ModelFlattenRequest const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      ModelFlattenRequest const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ModelFlattenRequest);
      if (param0_this != nullptr) {
        ModelFlattenRequest *return_value = new ModelFlattenRequest(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModelFlattenRequest, true, false);
      }
    }
  }

  {
    // -2 inline explicit ModelFlattenRequest::ModelFlattenRequest(PandaNode *orig)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "orig")) {
      PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "ModelFlattenRequest.ModelFlattenRequest", false, false);
      if (param0_this != nullptr) {
        ModelFlattenRequest *return_value = new ModelFlattenRequest(param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModelFlattenRequest, true, false);
      }
    }
  }

  // No coercion possible: inline ModelFlattenRequest::ModelFlattenRequest(ModelFlattenRequest const &) = default
  // No coercion possible: inline explicit ModelFlattenRequest::ModelFlattenRequest(PandaNode *orig)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ModelFlattenRequest(const ModelFlattenRequest param0)\n"
      "ModelFlattenRequest(PandaNode orig)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ModelFlattenRequest(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ModelFlattenRequest) {
    printf("ModelFlattenRequest ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ModelFlattenRequest *local_this = (ModelFlattenRequest *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ModelFlattenRequest) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncFuture) {
    return (AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ModelFlattenRequest(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ModelFlattenRequest) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    AsyncFuture* other_this = (AsyncFuture*)from_this;
    return (ModelFlattenRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (ModelFlattenRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ModelFlattenRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ModelFlattenRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ModelFlattenRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ModelFlattenRequest*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ModelLoadRequest
 */
/**
 * Python function wrapper for:
 * inline Filename const &ModelLoadRequest::get_filename(void) const
 */
static PyObject *Dtool_ModelLoadRequest_get_filename_1699(PyObject *self, PyObject *) {
  ModelLoadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelLoadRequest)) {
    return nullptr;
  }
  // 1-inline Filename const &ModelLoadRequest::get_filename(void) const
  Filename const *return_value = &(((*(const ModelLoadRequest*)local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ModelLoadRequest_get_filename_1699_comment =
  "C++ Interface:\n"
  "get_filename(ModelLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the filename associated with this asynchronous ModelLoadRequest.\n"
  " */";
#else
static const char *Dtool_ModelLoadRequest_get_filename_1699_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LoaderOptions const &ModelLoadRequest::get_options(void) const
 */
static PyObject *Dtool_ModelLoadRequest_get_options_1700(PyObject *self, PyObject *) {
  ModelLoadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelLoadRequest)) {
    return nullptr;
  }
  // 1-inline LoaderOptions const &ModelLoadRequest::get_options(void) const
  LoaderOptions const *return_value = &(((*(const ModelLoadRequest*)local_this).get_options)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LoaderOptions, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ModelLoadRequest_get_options_1700_comment =
  "C++ Interface:\n"
  "get_options(ModelLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the LoaderOptions associated with this asynchronous\n"
  " * ModelLoadRequest.\n"
  " */";
#else
static const char *Dtool_ModelLoadRequest_get_options_1700_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Loader *ModelLoadRequest::get_loader(void) const
 */
static PyObject *Dtool_ModelLoadRequest_get_loader_1701(PyObject *self, PyObject *) {
  ModelLoadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelLoadRequest)) {
    return nullptr;
  }
  // 1-inline Loader *ModelLoadRequest::get_loader(void) const
  Loader *return_value = ((*(const ModelLoadRequest*)local_this).get_loader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Loader, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ModelLoadRequest_get_loader_1701_comment =
  "C++ Interface:\n"
  "get_loader(ModelLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the Loader object associated with this asynchronous\n"
  " * ModelLoadRequest.\n"
  " */";
#else
static const char *Dtool_ModelLoadRequest_get_loader_1701_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ModelLoadRequest::is_ready(void) const
 */
static PyObject *Dtool_ModelLoadRequest_is_ready_1702(PyObject *self, PyObject *) {
  ModelLoadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelLoadRequest)) {
    return nullptr;
  }
  // 1-inline bool ModelLoadRequest::is_ready(void) const
  bool return_value = ((*(const ModelLoadRequest*)local_this).is_ready)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModelLoadRequest_is_ready_1702_comment =
  "C++ Interface:\n"
  "is_ready(ModelLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns true if this request has completed, false if it is still pending or\n"
  " * if it has been cancelled.  When this returns true, you may retrieve the\n"
  " * model loaded by calling get_model().\n"
  " * Equivalent to `req.done() and not req.cancelled()`.\n"
  " * @see done()\n"
  " */";
#else
static const char *Dtool_ModelLoadRequest_is_ready_1702_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *ModelLoadRequest::get_model(void) const
 */
static PyObject *Dtool_ModelLoadRequest_get_model_1703(PyObject *self, PyObject *) {
  ModelLoadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelLoadRequest)) {
    return nullptr;
  }
  // 1-inline PandaNode *ModelLoadRequest::get_model(void) const
  PandaNode *return_value = ((*(const ModelLoadRequest*)local_this).get_model)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ModelLoadRequest_get_model_1703_comment =
  "C++ Interface:\n"
  "get_model(ModelLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the model that was loaded asynchronously, if any, or null if there\n"
  " * was an error.  It is an error to call this unless done() returns true.\n"
  " * @deprecated Use result() instead.\n"
  " */";
#else
static const char *Dtool_ModelLoadRequest_get_model_1703_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ModelLoadRequest::get_class_type(void)
 */
static PyObject *Dtool_ModelLoadRequest_get_class_type_1712(PyObject *, PyObject *) {
  // 1-static TypeHandle ModelLoadRequest::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ModelLoadRequest::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ModelLoadRequest_get_class_type_1712_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ModelLoadRequest_get_class_type_1712_comment = nullptr;
#endif

static PyObject *Dtool_ModelLoadRequest_filename_Getter(PyObject *self, void *) {
  const ModelLoadRequest *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelLoadRequest, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename const &ModelLoadRequest::get_filename(void) const
  Filename const *return_value = &(((*(const ModelLoadRequest*)local_this).get_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_ModelLoadRequest_options_Getter(PyObject *self, void *) {
  const ModelLoadRequest *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelLoadRequest, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LoaderOptions const &ModelLoadRequest::get_options(void) const
  LoaderOptions const *return_value = &(((*(const ModelLoadRequest*)local_this).get_options)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LoaderOptions, false, true);
}

static PyObject *Dtool_ModelLoadRequest_loader_Getter(PyObject *self, void *) {
  const ModelLoadRequest *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelLoadRequest, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Loader *ModelLoadRequest::get_loader(void) const
  Loader *return_value = ((*(const ModelLoadRequest*)local_this).get_loader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Loader, true, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * inline ModelLoadRequest::ModelLoadRequest(ModelLoadRequest const &) = default
 * explicit ModelLoadRequest::ModelLoadRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, Loader *loader)
 */
static int Dtool_Init_ModelLoadRequest(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline ModelLoadRequest::ModelLoadRequest(ModelLoadRequest const &) = default
      ModelLoadRequest const *arg_this = (ModelLoadRequest *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModelLoadRequest, 0, "ModelLoadRequest.ModelLoadRequest", true, true);
      if (arg_this != nullptr) {
        ModelLoadRequest *return_value = new ModelLoadRequest(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModelLoadRequest, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-explicit ModelLoadRequest::ModelLoadRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, Loader *loader)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"name", "filename", "options", "loader", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#OOO:ModelLoadRequest", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "ModelLoadRequest.ModelLoadRequest", "Filename");
          return -1;
        }
        LoaderOptions param2_local;
        LoaderOptions const *param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "ModelLoadRequest.ModelLoadRequest", "LoaderOptions");
          return -1;
        }
        Loader *param3_this = (Loader *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Loader, 3, "ModelLoadRequest.ModelLoadRequest", false, true);
        if (param3_this != nullptr) {
          ModelLoadRequest *return_value = new ModelLoadRequest(std::string(param0_str, param0_len), *param1_this, *param2_this, param3_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModelLoadRequest, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ModelLoadRequest() takes 1 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ModelLoadRequest(const ModelLoadRequest param0)\n"
      "ModelLoadRequest(str name, const Filename filename, const LoaderOptions options, Loader loader)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ModelLoadRequest(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ModelLoadRequest) {
    printf("ModelLoadRequest ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ModelLoadRequest *local_this = (ModelLoadRequest *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ModelLoadRequest) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncFuture) {
    return (AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ModelLoadRequest(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ModelLoadRequest) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    AsyncFuture* other_this = (AsyncFuture*)from_this;
    return (ModelLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (ModelLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ModelLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ModelLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ModelLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ModelLoadRequest*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ModelNode
 */
/**
 * Python function wrapper for:
 * inline void ModelNode::set_preserve_transform(ModelNode::PreserveTransform preserve_transform)
 */
static PyObject *Dtool_ModelNode_set_preserve_transform_1717(PyObject *self, PyObject *arg) {
  ModelNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModelNode, (void **)&local_this, "ModelNode.set_preserve_transform")) {
    return nullptr;
  }
  // 1-inline void ModelNode::set_preserve_transform(ModelNode::PreserveTransform preserve_transform)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_preserve_transform)((ModelNode::PreserveTransform)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_preserve_transform(const ModelNode self, int preserve_transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelNode_set_preserve_transform_1717_comment =
  "C++ Interface:\n"
  "set_preserve_transform(const ModelNode self, int preserve_transform)\n"
  "\n"
  "/**\n"
  " * Sets the preserve_transform flag.  This restricts the ability of a flatten\n"
  " * operation to affect the transform stored on this node, and/or the node\n"
  " * itself.  In the order from weakest to strongest restrictions, the possible\n"
  " * flags are:\n"
  " *\n"
  " * PT_drop_node - This node should be removed at the next flatten call.\n"
  " *\n"
  " * PT_none - The transform may be adjusted at will.  The node itself will not\n"
  " * be removed.  This is the default.\n"
  " *\n"
  " * PT_net - Preserve the net transform from the root, but it's acceptable to\n"
  " * modify the local transform stored on this particular node if necessary, so\n"
  " * long as the net transform is not changed.  This eliminates the need to drop\n"
  " * an extra transform on the node above.\n"
  " *\n"
  " * PT_local - The local (and net) transform should not be changed in any way.\n"
  " * If necessary, an extra transform will be left on the node above to\n"
  " * guarantee this.  This is a stronger restriction than PT_net.\n"
  " *\n"
  " * PT_no_touch - The local transform will not be changed, the node will not be\n"
  " * removed, and furthermore any flatten operation will not continue below this\n"
  " * node--this node and all descendents are protected from the effects of\n"
  " * flatten.\n"
  " */";
#else
static const char *Dtool_ModelNode_set_preserve_transform_1717_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ModelNode::PreserveTransform ModelNode::get_preserve_transform(void) const
 */
static PyObject *Dtool_ModelNode_get_preserve_transform_1718(PyObject *self, PyObject *) {
  ModelNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelNode)) {
    return nullptr;
  }
  // 1-inline ModelNode::PreserveTransform ModelNode::get_preserve_transform(void) const
  ModelNode::PreserveTransform return_value = ((*(const ModelNode*)local_this).get_preserve_transform)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModelNode_get_preserve_transform_1718_comment =
  "C++ Interface:\n"
  "get_preserve_transform(ModelNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the preserve_transform flag.  See\n"
  " * set_preserve_transform().\n"
  " */";
#else
static const char *Dtool_ModelNode_get_preserve_transform_1718_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ModelNode::set_preserve_attributes(int attrib_mask)
 */
static PyObject *Dtool_ModelNode_set_preserve_attributes_1719(PyObject *self, PyObject *arg) {
  ModelNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModelNode, (void **)&local_this, "ModelNode.set_preserve_attributes")) {
    return nullptr;
  }
  // 1-inline void ModelNode::set_preserve_attributes(int attrib_mask)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_preserve_attributes)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_preserve_attributes(const ModelNode self, int attrib_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelNode_set_preserve_attributes_1719_comment =
  "C++ Interface:\n"
  "set_preserve_attributes(const ModelNode self, int attrib_mask)\n"
  "\n"
  "/**\n"
  " * Sets the preserve_attributes flag.  This restricts the ability of a flatten\n"
  " * operation to affect the render attributes stored on this node.\n"
  " *\n"
  " * The value should be the union of bits from SceneGraphReducer::AttribTypes\n"
  " * that represent the attributes that should *not* be changed.\n"
  " */";
#else
static const char *Dtool_ModelNode_set_preserve_attributes_1719_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ModelNode::get_preserve_attributes(void) const
 */
static PyObject *Dtool_ModelNode_get_preserve_attributes_1720(PyObject *self, PyObject *) {
  ModelNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelNode)) {
    return nullptr;
  }
  // 1-inline int ModelNode::get_preserve_attributes(void) const
  int return_value = ((*(const ModelNode*)local_this).get_preserve_attributes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModelNode_get_preserve_attributes_1720_comment =
  "C++ Interface:\n"
  "get_preserve_attributes(ModelNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the preserve_attributes flag.  See\n"
  " * set_preserve_attributes().\n"
  " */";
#else
static const char *Dtool_ModelNode_get_preserve_attributes_1720_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ModelNode::set_transform_limit(PN_stdfloat limit)
 */
static PyObject *Dtool_ModelNode_set_transform_limit_1721(PyObject *self, PyObject *arg) {
  ModelNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModelNode, (void **)&local_this, "ModelNode.set_transform_limit")) {
    return nullptr;
  }
  // 1-void ModelNode::set_transform_limit(PN_stdfloat limit)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_transform_limit)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform_limit(const ModelNode self, float limit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelNode_set_transform_limit_1721_comment =
  "C++ Interface:\n"
  "set_transform_limit(const ModelNode self, float limit)\n";
#else
static const char *Dtool_ModelNode_set_transform_limit_1721_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ModelNode::get_class_type(void)
 */
static PyObject *Dtool_ModelNode_get_class_type_1722(PyObject *, PyObject *) {
  // 1-static TypeHandle ModelNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ModelNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ModelNode_get_class_type_1722_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ModelNode_get_class_type_1722_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline explicit ModelNode::ModelNode(std::string const &name)
 */
static int Dtool_Init_ModelNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ModelNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-inline explicit ModelNode::ModelNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      ModelNode *return_value = new ModelNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModelNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ModelNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ModelNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ModelNode) {
    printf("ModelNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ModelNode *local_this = (ModelNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ModelNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ModelNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ModelNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ModelNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ModelNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ModelNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ModelNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ModelNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ModelNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ModelRoot
 */
/**
 * Python function wrapper for:
 * inline int ModelRoot::get_model_ref_count(void) const
 */
static PyObject *Dtool_ModelRoot_get_model_ref_count_1726(PyObject *self, PyObject *) {
  ModelRoot *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelRoot)) {
    return nullptr;
  }
  // 1-inline int ModelRoot::get_model_ref_count(void) const
  int return_value = ((*(const ModelRoot*)local_this).get_model_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModelRoot_get_model_ref_count_1726_comment =
  "C++ Interface:\n"
  "get_model_ref_count(ModelRoot self)\n"
  "\n"
  "/**\n"
  " * Returns the number of copies that exist of this particular ModelRoot node.\n"
  " * Each time ModelRoot::copy_subgraph() or make_copy() is called (or some\n"
  " * other copying mechanism, such as NodePath.copy_to(), is used), this count\n"
  " * will increment by one in all copies; when one of the copies is destructed,\n"
  " * this count will decrement.\n"
  " */";
#else
static const char *Dtool_ModelRoot_get_model_ref_count_1726_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &ModelRoot::get_fullpath(void) const
 */
static PyObject *Dtool_ModelRoot_get_fullpath_1728(PyObject *self, PyObject *) {
  ModelRoot *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelRoot)) {
    return nullptr;
  }
  // 1-inline Filename const &ModelRoot::get_fullpath(void) const
  Filename const *return_value = &(((*(const ModelRoot*)local_this).get_fullpath)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ModelRoot_get_fullpath_1728_comment =
  "C++ Interface:\n"
  "get_fullpath(ModelRoot self)\n"
  "\n"
  "/**\n"
  " * Returns the full pathname of the model represented by this node, as found\n"
  " * on disk.  This is mainly useful for reference purposes, but is also used to\n"
  " * index the ModelRoot into the ModelPool.\n"
  " */";
#else
static const char *Dtool_ModelRoot_get_fullpath_1728_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ModelRoot::set_fullpath(Filename const &fullpath)
 */
static PyObject *Dtool_ModelRoot_set_fullpath_1729(PyObject *self, PyObject *arg) {
  ModelRoot *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModelRoot, (void **)&local_this, "ModelRoot.set_fullpath")) {
    return nullptr;
  }
  // 1-inline void ModelRoot::set_fullpath(Filename const &fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ModelRoot.set_fullpath", "Filename");
  }
  ((*local_this).set_fullpath)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fullpath(const ModelRoot self, const Filename fullpath)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelRoot_set_fullpath_1729_comment =
  "C++ Interface:\n"
  "set_fullpath(const ModelRoot self, const Filename fullpath)\n"
  "\n"
  "/**\n"
  " * Sets the full pathname of the model represented by this node, as found on\n"
  " * disk.  This is mainly useful for reference purposes, but is also used to\n"
  " * index the ModelRoot into the ModelPool.\n"
  " *\n"
  " * This is normally set automatically when a model is loaded, and should not\n"
  " * be set directly by the user.  If you change this on a loaded model, then\n"
  " * ModelPool::release_model() may fail.\n"
  " */";
#else
static const char *Dtool_ModelRoot_set_fullpath_1729_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline time_t ModelRoot::get_timestamp(void) const
 */
static PyObject *Dtool_ModelRoot_get_timestamp_1731(PyObject *self, PyObject *) {
  ModelRoot *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelRoot)) {
    return nullptr;
  }
  // 1-inline time_t ModelRoot::get_timestamp(void) const
  time_t return_value = ((*(const ModelRoot*)local_this).get_timestamp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModelRoot_get_timestamp_1731_comment =
  "C++ Interface:\n"
  "get_timestamp(ModelRoot self)\n"
  "\n"
  "/**\n"
  " * Returns the timestamp of the file on disk that was read for this model, at\n"
  " * the time it was read, if it is known.  Returns 0 if the timestamp is not\n"
  " * known or could not be provided.  This can be used as a quick (but fallible)\n"
  " * check to verify whether the file might have changed since the model was\n"
  " * read.\n"
  " */";
#else
static const char *Dtool_ModelRoot_get_timestamp_1731_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ModelRoot::set_timestamp(time_t timestamp)
 */
static PyObject *Dtool_ModelRoot_set_timestamp_1732(PyObject *self, PyObject *arg) {
  ModelRoot *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModelRoot, (void **)&local_this, "ModelRoot.set_timestamp")) {
    return nullptr;
  }
  // 1-inline void ModelRoot::set_timestamp(time_t timestamp)
  if (PyLongOrInt_Check(arg)) {
    ((*local_this).set_timestamp)(PyLongOrInt_AS_LONG(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_timestamp(const ModelRoot self, int timestamp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelRoot_set_timestamp_1732_comment =
  "C++ Interface:\n"
  "set_timestamp(const ModelRoot self, int timestamp)\n"
  "\n"
  "/**\n"
  " * Sets the timestamp of the file on disk that was read for this model.  This\n"
  " * is normally set automatically when a model is loaded, and should not be set\n"
  " * directly by the user.\n"
  " */";
#else
static const char *Dtool_ModelRoot_set_timestamp_1732_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ModelRoot::ModelReference *ModelRoot::get_reference(void) const
 */
static PyObject *Dtool_ModelRoot_get_reference_1739(PyObject *self, PyObject *) {
  ModelRoot *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelRoot)) {
    return nullptr;
  }
  // 1-inline ModelRoot::ModelReference *ModelRoot::get_reference(void) const
  ModelRoot::ModelReference *return_value = ((*(const ModelRoot*)local_this).get_reference)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModelRoot_ModelReference, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ModelRoot_get_reference_1739_comment =
  "C++ Interface:\n"
  "get_reference(ModelRoot self)\n"
  "\n"
  "/**\n"
  " * Returns the pointer that represents the object shared between all copies of\n"
  " * this ModelRoot.  Since there's not much associated with this object other\n"
  " * than a reference count, normally there's not much reason to get the pointer\n"
  " * (though it may be compared pointerwise with other ModelRoot objects).\n"
  " */";
#else
static const char *Dtool_ModelRoot_get_reference_1739_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ModelRoot::set_reference(ModelRoot::ModelReference *ref)
 */
static PyObject *Dtool_ModelRoot_set_reference_1740(PyObject *self, PyObject *arg) {
  ModelRoot *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModelRoot, (void **)&local_this, "ModelRoot.set_reference")) {
    return nullptr;
  }
  // 1-void ModelRoot::set_reference(ModelRoot::ModelReference *ref)
  ModelRoot::ModelReference *arg_this = (ModelRoot::ModelReference *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModelRoot_ModelReference, 1, "ModelRoot.set_reference", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_reference)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_reference(const ModelRoot self, ModelReference ref)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelRoot_set_reference_1740_comment =
  "C++ Interface:\n"
  "set_reference(const ModelRoot self, ModelReference ref)\n"
  "\n"
  "/**\n"
  " * Changes the pointer that represents the object shared between all copies of\n"
  " * this ModelRoot.  This will disassociate this ModelRoot from all of its\n"
  " * copies.  Normally, there's no reason to do this.\n"
  " */";
#else
static const char *Dtool_ModelRoot_set_reference_1740_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ModelRoot::get_class_type(void)
 */
static PyObject *Dtool_ModelRoot_get_class_type_1743(PyObject *, PyObject *) {
  // 1-static TypeHandle ModelRoot::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ModelRoot::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ModelRoot_get_class_type_1743_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ModelRoot_get_class_type_1743_comment = nullptr;
#endif

static PyObject *Dtool_ModelRoot_model_ref_count_Getter(PyObject *self, void *) {
  const ModelRoot *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelRoot, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ModelRoot::get_model_ref_count(void) const
  int return_value = ((*(const ModelRoot*)local_this).get_model_ref_count)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ModelRoot_fullpath_Getter(PyObject *self, void *) {
  const ModelRoot *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelRoot, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename const &ModelRoot::get_fullpath(void) const
  Filename const *return_value = &(((*(const ModelRoot*)local_this).get_fullpath)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_ModelRoot_fullpath_Setter(PyObject *self, PyObject *arg, void *) {
  ModelRoot *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModelRoot, (void **)&local_this, "ModelRoot.fullpath")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete fullpath attribute");
    return -1;
  }
  // 1-inline void ModelRoot::set_fullpath(Filename const &fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ModelRoot.set_fullpath", "Filename");
    return -1;
  }
  ((*local_this).set_fullpath)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fullpath(const ModelRoot self, const Filename fullpath)\n");
  }
  return -1;
}

static PyObject *Dtool_ModelRoot_timestamp_Getter(PyObject *self, void *) {
  const ModelRoot *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelRoot, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline time_t ModelRoot::get_timestamp(void) const
  time_t return_value = ((*(const ModelRoot*)local_this).get_timestamp)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ModelRoot_timestamp_Setter(PyObject *self, PyObject *arg, void *) {
  ModelRoot *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModelRoot, (void **)&local_this, "ModelRoot.timestamp")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete timestamp attribute");
    return -1;
  }
  // 1-inline void ModelRoot::set_timestamp(time_t timestamp)
  if (PyLongOrInt_Check(arg)) {
    ((*local_this).set_timestamp)(PyLongOrInt_AS_LONG(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_timestamp(const ModelRoot self, int timestamp)\n");
  }
  return -1;
}

static PyObject *Dtool_ModelRoot_reference_Getter(PyObject *self, void *) {
  const ModelRoot *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelRoot, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ModelRoot::ModelReference *ModelRoot::get_reference(void) const
  ModelRoot::ModelReference *return_value = ((*(const ModelRoot*)local_this).get_reference)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModelRoot_ModelReference, true, false);
}

static int Dtool_ModelRoot_reference_Setter(PyObject *self, PyObject *arg, void *) {
  ModelRoot *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModelRoot, (void **)&local_this, "ModelRoot.reference")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete reference attribute");
    return -1;
  }
  // 1-void ModelRoot::set_reference(ModelRoot::ModelReference *ref)
  ModelRoot::ModelReference *arg_this = (ModelRoot::ModelReference *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModelRoot_ModelReference, 1, "ModelRoot.set_reference", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_reference)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_reference(const ModelRoot self, ModelReference ref)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline explicit ModelRoot::ModelRoot(Filename const &fullpath, time_t timestamp)
 * inline explicit ModelRoot::ModelRoot(std::string const &name)
 */
static int Dtool_Init_ModelRoot(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
        // 1-inline explicit ModelRoot::ModelRoot(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          ModelRoot *return_value = new ModelRoot(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModelRoot, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline explicit ModelRoot::ModelRoot(Filename const &fullpath, time_t timestamp)
      PyObject *param0;
      long param1;
      static const char *keyword_list[] = {"fullpath", "timestamp", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Ol:ModelRoot", (char **)keyword_list, &param0, &param1)) {
        Filename param0_local;
        Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "ModelRoot.ModelRoot", "Filename");
          return -1;
        }
        ModelRoot *return_value = new ModelRoot(*param0_this, (time_t)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModelRoot, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ModelRoot() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ModelRoot(str name)\n"
      "ModelRoot(const Filename fullpath, int timestamp)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ModelRoot(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ModelRoot) {
    printf("ModelRoot ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ModelRoot *local_this = (ModelRoot *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ModelRoot) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ModelNode) {
    return (ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ModelRoot(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ModelRoot) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ModelNode) {
    ModelNode* other_this = (ModelNode*)from_this;
    return (ModelRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ModelRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ModelRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ModelRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ModelRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ModelRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ModelRoot*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ModelRoot::ModelReference
 */
/**
 * Python function wrapper for:
 * inline ModelRoot::ModelReference::ModelReference(void)
 * inline ModelRoot::ModelReference::ModelReference(ModelRoot::ModelReference const &) = default
 */
static int Dtool_Init_ModelRoot_ModelReference(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ModelReference() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ModelRoot::ModelReference::ModelReference(void)
      ModelRoot::ModelReference *return_value = new ModelRoot::ModelReference();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModelRoot_ModelReference, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline ModelRoot::ModelReference::ModelReference(ModelRoot::ModelReference const &) = default
      ModelRoot::ModelReference const *arg_this = (ModelRoot::ModelReference *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModelRoot_ModelReference, 0, "ModelReference.ModelReference", true, true);
      if (arg_this != nullptr) {
        ModelRoot::ModelReference *return_value = new ModelRoot::ModelReference(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModelRoot_ModelReference, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ModelReference() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ModelReference()\n"
      "ModelReference(const ModelReference param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ModelRoot_ModelReference(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ModelRoot_ModelReference) {
    printf("ModelRoot_ModelReference ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ModelRoot::ModelReference *local_this = (ModelRoot::ModelReference *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ModelRoot_ModelReference) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ModelRoot_ModelReference(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ModelRoot_ModelReference) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ModelRoot::ModelReference*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ModelPool
 */
/**
 * Python function wrapper for:
 * static inline bool ModelPool::has_model(Filename const &filename)
 */
static PyObject *Dtool_ModelPool_has_model_1746(PyObject *, PyObject *arg) {
  // 1-static inline bool ModelPool::has_model(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "ModelPool.has_model", "Filename");
  }
  bool return_value = (ModelPool::has_model)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_model(const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelPool_has_model_1746_comment =
  "C++ Interface:\n"
  "has_model(const Filename filename)\n"
  "\n"
  "/**\n"
  " * Returns true if the model has ever been loaded, false otherwise.  Note that\n"
  " * this does not guarantee that the model is still up-to-date.\n"
  " */";
#else
static const char *Dtool_ModelPool_has_model_1746_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool ModelPool::verify_model(Filename const &filename)
 */
static PyObject *Dtool_ModelPool_verify_model_1747(PyObject *, PyObject *arg) {
  // 1-static inline bool ModelPool::verify_model(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "ModelPool.verify_model", "Filename");
  }
  bool return_value = (ModelPool::verify_model)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "verify_model(const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelPool_verify_model_1747_comment =
  "C++ Interface:\n"
  "verify_model(const Filename filename)\n"
  "\n"
  "/**\n"
  " * Loads the given filename up as a model, if it has not already been loaded,\n"
  " * and returns true to indicate success, or false to indicate failure.  If\n"
  " * this returns true, it is probable that a subsequent call to load_model()\n"
  " * with the same model name will return a valid PandaNode.\n"
  " *\n"
  " * However, even if this returns true, it is still possible for a subsequent\n"
  " * call to load_model() to fail.  This can happen if cache-check-timestamps is\n"
  " * true, and the on-disk file is subsequently modified to replace it with an\n"
  " * invalid model.\n"
  " */";
#else
static const char *Dtool_ModelPool_verify_model_1747_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ModelRoot *ModelPool::get_model(Filename const &filename, bool verify)
 */
static PyObject *Dtool_ModelPool_get_model_1748(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline ModelRoot *ModelPool::get_model(Filename const &filename, bool verify)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"filename", "verify", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_model", (char **)keyword_list, &param0, &param1)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "ModelPool.get_model", "Filename");
    }
    ModelRoot *return_value = (ModelPool::get_model)(*param0_this, (PyObject_IsTrue(param1) != 0));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ModelRoot, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_model(const Filename filename, bool verify)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelPool_get_model_1748_comment =
  "C++ Interface:\n"
  "get_model(const Filename filename, bool verify)\n"
  "\n"
  "/**\n"
  " * Returns the model that has already been previously loaded, or NULL\n"
  " * otherwise.  If verify is true, it will check if the file is still up-to-\n"
  " * date (and hasn't been modified in the meantime), and if not, will still\n"
  " * return NULL.\n"
  " */";
#else
static const char *Dtool_ModelPool_get_model_1748_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ModelRoot *ModelPool::load_model(Filename const &filename, LoaderOptions const &options = LoaderOptions())
 */
static PyObject *Dtool_ModelPool_load_model_1749(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline ModelRoot *ModelPool::load_model(Filename const &filename, LoaderOptions const &options = LoaderOptions())
  PyObject *param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"filename", "options", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:load_model", (char **)keyword_list, &param0, &param1)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "ModelPool.load_model", "Filename");
    }
    LoaderOptions param1_local;
    LoaderOptions const *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_LoaderOptions(param1, param1_local);
    } else {
      param1_local = LoaderOptions();
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ModelPool.load_model", "LoaderOptions");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ModelRoot *return_value = (ModelPool::load_model)(*param0_this, *param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ModelRoot, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_model(const Filename filename, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelPool_load_model_1749_comment =
  "C++ Interface:\n"
  "load_model(const Filename filename, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Loads the given filename up as a model, if it has not already been loaded,\n"
  " * and returns the new model.  If a model with the same filename was\n"
  " * previously loaded, returns that one instead (unless cache-check-timestamps\n"
  " * is true and the file has recently changed).  If the model file cannot be\n"
  " * found, or cannot be loaded for some reason, returns NULL.\n"
  " */";
#else
static const char *Dtool_ModelPool_load_model_1749_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ModelPool::add_model(Filename const &filename, ModelRoot *model)
 * static inline void ModelPool::add_model(ModelRoot *model)
 */
static PyObject *Dtool_ModelPool_add_model_1750(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "model")) {
        // 1-static inline void ModelPool::add_model(ModelRoot *model)
        ModelRoot *arg_this = (ModelRoot *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModelRoot, 0, "ModelPool.add_model", false, true);
        if (arg_this != nullptr) {
          (ModelPool::add_model)(arg_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-static inline void ModelPool::add_model(Filename const &filename, ModelRoot *model)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"filename", "model", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_model", (char **)keyword_list, &param0, &param1)) {
        Filename param0_local;
        Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
        if (!(param0_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "ModelPool.add_model", "Filename");
        }
        ModelRoot *param1_this = (ModelRoot *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ModelRoot, 1, "ModelPool.add_model", false, true);
        if (param1_this != nullptr) {
          (ModelPool::add_model)(*param0_this, param1_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_model() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_model(ModelRoot model)\n"
      "add_model(const Filename filename, ModelRoot model)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelPool_add_model_1750_comment =
  "C++ Interface:\n"
  "add_model(ModelRoot model)\n"
  "add_model(const Filename filename, ModelRoot model)\n"
  "\n"
  "/**\n"
  " * Adds the indicated already-loaded model to the pool.  The model will\n"
  " * replace any previously-loaded model in the pool that had the same filename.\n"
  " *\n"
  " * @deprecated Use the one-parameter add_model(model) instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the indicated already-loaded model to the pool.  The model will\n"
  " * replace any previously-loaded model in the pool that had the same filename.\n"
  " */";
#else
static const char *Dtool_ModelPool_add_model_1750_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ModelPool::release_model(Filename const &filename)
 * static inline void ModelPool::release_model(ModelRoot *model)
 */
static PyObject *Dtool_ModelPool_release_model_1751(PyObject *, PyObject *arg) {
  {
    // -2 static inline void ModelPool::release_model(ModelRoot *model)
    ModelRoot *arg_this = (ModelRoot *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModelRoot, 0, "ModelPool.release_model", false, false);
    if (arg_this != nullptr) {
      (ModelPool::release_model)(arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: static inline void ModelPool::release_model(ModelRoot *model)
  {
    // -2 static inline void ModelPool::release_model(Filename const &filename)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != nullptr)) {
      (ModelPool::release_model)(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_model(ModelRoot model)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelPool_release_model_1751_comment =
  "C++ Interface:\n"
  "release_model(ModelRoot model)\n"
  "\n"
  "/**\n"
  " * Removes the indicated model from the pool, indicating it will never be\n"
  " * loaded again; the model may then be freed.  If this function is never\n"
  " * called, a reference count will be maintained on every model every loaded,\n"
  " * and models will never be freed.\n"
  " *\n"
  " * @deprecated Use release_model(model) instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the indicated model from the pool, indicating it will never be\n"
  " * loaded again; the model may then be freed.  If this function (and\n"
  " * garbage_collect()) is never called, a reference count will be maintained on\n"
  " * every model every loaded, and models will never be freed.\n"
  " *\n"
  " * The model's get_fullpath() value should not have been changed during its\n"
  " * lifetime, or this function may fail to locate it in the pool.\n"
  " */";
#else
static const char *Dtool_ModelPool_release_model_1751_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ModelPool::release_all_models(void)
 */
static PyObject *Dtool_ModelPool_release_all_models_1752(PyObject *, PyObject *) {
  // 1-static inline void ModelPool::release_all_models(void)
  (ModelPool::release_all_models)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ModelPool_release_all_models_1752_comment =
  "C++ Interface:\n"
  "release_all_models()\n"
  "\n"
  "/**\n"
  " * Releases all models in the pool and restores the pool to the empty state.\n"
  " */";
#else
static const char *Dtool_ModelPool_release_all_models_1752_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int ModelPool::garbage_collect(void)
 */
static PyObject *Dtool_ModelPool_garbage_collect_1753(PyObject *, PyObject *) {
  // 1-static inline int ModelPool::garbage_collect(void)
  int return_value = (ModelPool::garbage_collect)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModelPool_garbage_collect_1753_comment =
  "C++ Interface:\n"
  "garbage_collect()\n"
  "\n"
  "/**\n"
  " * Releases only those models in the pool that have a reference count of\n"
  " * exactly 1; i.e.  only those models that are not being used outside of the\n"
  " * pool.  Returns the number of models released.\n"
  " */";
#else
static const char *Dtool_ModelPool_garbage_collect_1753_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ModelPool::list_contents(void)
 * static inline void ModelPool::list_contents(std::ostream &out)
 */
static PyObject *Dtool_ModelPool_list_contents_1754(PyObject *, PyObject *args) {
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-static inline void ModelPool::list_contents(void)
      (ModelPool::list_contents)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-static inline void ModelPool::list_contents(std::ostream &out)
      std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "ModelPool.list_contents", false, true);
      if (arg_this != nullptr) {
        (ModelPool::list_contents)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "list_contents() takes 0 or 1 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_contents()\n"
      "list_contents(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelPool_list_contents_1754_comment =
  "C++ Interface:\n"
  "list_contents()\n"
  "list_contents(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the model pool to the indicated output stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Lists the contents of the model pool to cout.\n"
  " */";
#else
static const char *Dtool_ModelPool_list_contents_1754_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void ModelPool::write(std::ostream &out)
 */
static PyObject *Dtool_ModelPool_write_1755(PyObject *, PyObject *arg) {
  // 1-static void ModelPool::write(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "ModelPool.write", false, true);
  if (arg_this != nullptr) {
    (ModelPool::write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModelPool_write_1755_comment =
  "C++ Interface:\n"
  "write(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the model pool to the indicated output stream.  Helps\n"
  " * with debugging.\n"
  " */";
#else
static const char *Dtool_ModelPool_write_1755_comment = nullptr;
#endif

static int Dtool_Init_ModelPool(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ModelPool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ModelPool) {
    printf("ModelPool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ModelPool *local_this = (ModelPool *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ModelPool) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ModelPool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ModelPool) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ModelSaveRequest
 */
/**
 * Python function wrapper for:
 * inline Filename const &ModelSaveRequest::get_filename(void) const
 */
static PyObject *Dtool_ModelSaveRequest_get_filename_1759(PyObject *self, PyObject *) {
  ModelSaveRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelSaveRequest)) {
    return nullptr;
  }
  // 1-inline Filename const &ModelSaveRequest::get_filename(void) const
  Filename const *return_value = &(((*(const ModelSaveRequest*)local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ModelSaveRequest_get_filename_1759_comment =
  "C++ Interface:\n"
  "get_filename(ModelSaveRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the filename associated with this asynchronous ModelSaveRequest.\n"
  " */";
#else
static const char *Dtool_ModelSaveRequest_get_filename_1759_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LoaderOptions const &ModelSaveRequest::get_options(void) const
 */
static PyObject *Dtool_ModelSaveRequest_get_options_1760(PyObject *self, PyObject *) {
  ModelSaveRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelSaveRequest)) {
    return nullptr;
  }
  // 1-inline LoaderOptions const &ModelSaveRequest::get_options(void) const
  LoaderOptions const *return_value = &(((*(const ModelSaveRequest*)local_this).get_options)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LoaderOptions, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ModelSaveRequest_get_options_1760_comment =
  "C++ Interface:\n"
  "get_options(ModelSaveRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the LoaderOptions associated with this asynchronous\n"
  " * ModelSaveRequest.\n"
  " */";
#else
static const char *Dtool_ModelSaveRequest_get_options_1760_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *ModelSaveRequest::get_node(void) const
 */
static PyObject *Dtool_ModelSaveRequest_get_node_1761(PyObject *self, PyObject *) {
  ModelSaveRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelSaveRequest)) {
    return nullptr;
  }
  // 1-inline PandaNode *ModelSaveRequest::get_node(void) const
  PandaNode *return_value = ((*(const ModelSaveRequest*)local_this).get_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ModelSaveRequest_get_node_1761_comment =
  "C++ Interface:\n"
  "get_node(ModelSaveRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the node that was passed to the constructor.\n"
  " */";
#else
static const char *Dtool_ModelSaveRequest_get_node_1761_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Loader *ModelSaveRequest::get_loader(void) const
 */
static PyObject *Dtool_ModelSaveRequest_get_loader_1762(PyObject *self, PyObject *) {
  ModelSaveRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelSaveRequest)) {
    return nullptr;
  }
  // 1-inline Loader *ModelSaveRequest::get_loader(void) const
  Loader *return_value = ((*(const ModelSaveRequest*)local_this).get_loader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Loader, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ModelSaveRequest_get_loader_1762_comment =
  "C++ Interface:\n"
  "get_loader(ModelSaveRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the Loader object associated with this asynchronous\n"
  " * ModelSaveRequest.\n"
  " */";
#else
static const char *Dtool_ModelSaveRequest_get_loader_1762_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ModelSaveRequest::is_ready(void) const
 */
static PyObject *Dtool_ModelSaveRequest_is_ready_1763(PyObject *self, PyObject *) {
  ModelSaveRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelSaveRequest)) {
    return nullptr;
  }
  // 1-inline bool ModelSaveRequest::is_ready(void) const
  bool return_value = ((*(const ModelSaveRequest*)local_this).is_ready)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModelSaveRequest_is_ready_1763_comment =
  "C++ Interface:\n"
  "is_ready(ModelSaveRequest self)\n"
  "\n"
  "/**\n"
  " * Returns true if this request has completed, false if it is still pending.\n"
  " * When this returns true, you may retrieve the success flag with\n"
  " * get_success().\n"
  " * Equivalent to `req.done() and not req.cancelled()`.\n"
  " * @see done()\n"
  " */";
#else
static const char *Dtool_ModelSaveRequest_is_ready_1763_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ModelSaveRequest::get_success(void) const
 */
static PyObject *Dtool_ModelSaveRequest_get_success_1764(PyObject *self, PyObject *) {
  ModelSaveRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModelSaveRequest)) {
    return nullptr;
  }
  // 1-inline bool ModelSaveRequest::get_success(void) const
  bool return_value = ((*(const ModelSaveRequest*)local_this).get_success)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModelSaveRequest_get_success_1764_comment =
  "C++ Interface:\n"
  "get_success(ModelSaveRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the true if the model was saved successfully, false otherwise.  It\n"
  " * is an error to call this unless done() returns true.\n"
  " */";
#else
static const char *Dtool_ModelSaveRequest_get_success_1764_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ModelSaveRequest::get_class_type(void)
 */
static PyObject *Dtool_ModelSaveRequest_get_class_type_1769(PyObject *, PyObject *) {
  // 1-static TypeHandle ModelSaveRequest::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ModelSaveRequest::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ModelSaveRequest_get_class_type_1769_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ModelSaveRequest_get_class_type_1769_comment = nullptr;
#endif

static PyObject *Dtool_ModelSaveRequest_filename_Getter(PyObject *self, void *) {
  const ModelSaveRequest *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelSaveRequest, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename const &ModelSaveRequest::get_filename(void) const
  Filename const *return_value = &(((*(const ModelSaveRequest*)local_this).get_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_ModelSaveRequest_options_Getter(PyObject *self, void *) {
  const ModelSaveRequest *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelSaveRequest, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LoaderOptions const &ModelSaveRequest::get_options(void) const
  LoaderOptions const *return_value = &(((*(const ModelSaveRequest*)local_this).get_options)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LoaderOptions, false, true);
}

static PyObject *Dtool_ModelSaveRequest_node_Getter(PyObject *self, void *) {
  const ModelSaveRequest *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelSaveRequest, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PandaNode *ModelSaveRequest::get_node(void) const
  PandaNode *return_value = ((*(const ModelSaveRequest*)local_this).get_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_ModelSaveRequest_loader_Getter(PyObject *self, void *) {
  const ModelSaveRequest *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelSaveRequest, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Loader *ModelSaveRequest::get_loader(void) const
  Loader *return_value = ((*(const ModelSaveRequest*)local_this).get_loader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Loader, true, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * inline ModelSaveRequest::ModelSaveRequest(ModelSaveRequest const &) = default
 * explicit ModelSaveRequest::ModelSaveRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, PandaNode *node, Loader *loader)
 */
static int Dtool_Init_ModelSaveRequest(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline ModelSaveRequest::ModelSaveRequest(ModelSaveRequest const &) = default
      ModelSaveRequest const *arg_this = (ModelSaveRequest *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModelSaveRequest, 0, "ModelSaveRequest.ModelSaveRequest", true, true);
      if (arg_this != nullptr) {
        ModelSaveRequest *return_value = new ModelSaveRequest(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModelSaveRequest, true, false);
      }
    }
    break;
  case 5:
    {
      // 1-explicit ModelSaveRequest::ModelSaveRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, PandaNode *node, Loader *loader)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"name", "filename", "options", "node", "loader", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#OOOO:ModelSaveRequest", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "ModelSaveRequest.ModelSaveRequest", "Filename");
          return -1;
        }
        LoaderOptions param2_local;
        LoaderOptions const *param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "ModelSaveRequest.ModelSaveRequest", "LoaderOptions");
          return -1;
        }
        PandaNode *param3_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PandaNode, 3, "ModelSaveRequest.ModelSaveRequest", false, true);
        Loader *param4_this = (Loader *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_Loader, 4, "ModelSaveRequest.ModelSaveRequest", false, true);
        if (param3_this != nullptr && param4_this != nullptr) {
          ModelSaveRequest *return_value = new ModelSaveRequest(std::string(param0_str, param0_len), *param1_this, *param2_this, param3_this, param4_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModelSaveRequest, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ModelSaveRequest() takes 1 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ModelSaveRequest(const ModelSaveRequest param0)\n"
      "ModelSaveRequest(str name, const Filename filename, const LoaderOptions options, PandaNode node, Loader loader)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ModelSaveRequest(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ModelSaveRequest) {
    printf("ModelSaveRequest ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ModelSaveRequest *local_this = (ModelSaveRequest *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ModelSaveRequest) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncFuture) {
    return (AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ModelSaveRequest(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ModelSaveRequest) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    AsyncFuture* other_this = (AsyncFuture*)from_this;
    return (ModelSaveRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (ModelSaveRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ModelSaveRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ModelSaveRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ModelSaveRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ModelSaveRequest*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextureAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > TextureAttrib::make(void)
 * static ConstPointerTo< RenderAttrib > TextureAttrib::make(Texture *tex)
 */
static PyObject *Dtool_TextureAttrib_make_1772(PyObject *, PyObject *args) {
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-static ConstPointerTo< RenderAttrib > TextureAttrib::make(void)
      ConstPointerTo< RenderAttrib > return_value = (TextureAttrib::make)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-static ConstPointerTo< RenderAttrib > TextureAttrib::make(Texture *tex)
      Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 0, "TextureAttrib.make", false, true);
      if (arg_this != nullptr) {
        ConstPointerTo< RenderAttrib > return_value = (TextureAttrib::make)(arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderAttrib const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 0 or 1 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make()\n"
      "make(Texture tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_make_1772_comment =
  "C++ Interface:\n"
  "make()\n"
  "make(Texture tex)\n"
  "\n"
  "// These methods are used to create a simple, single-textured layer.  For\n"
  "// multitexture, use the multitexture interfaces, further below.\n"
  "\n"
  "// The following methods define the new multitexture mode for TextureAttrib.\n"
  "// Each TextureAttrib can add or remove individual texture stages from the\n"
  "// complete set of textures that are to be applied; this is similar to the\n"
  "// mechanism of LightAttrib.\n"
  "\n"
  "/**\n"
  " * Constructs a new TextureAttrib object suitable for rendering the indicated\n"
  " * texture onto geometry, using the default TextureStage.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new TextureAttrib object that does nothing.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_make_1772_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > TextureAttrib::make_off(void)
 */
static PyObject *Dtool_TextureAttrib_make_off_1773(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > TextureAttrib::make_off(void)
  ConstPointerTo< RenderAttrib > return_value = (TextureAttrib::make_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_make_off_1773_comment =
  "C++ Interface:\n"
  "make_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new TextureAttrib object suitable for rendering untextured\n"
  " * geometry.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_make_off_1773_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > TextureAttrib::make_default(void)
 */
static PyObject *Dtool_TextureAttrib_make_default_1774(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > TextureAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (TextureAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_make_default_1774_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_make_default_1774_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureAttrib::is_off(void) const
 */
static PyObject *Dtool_TextureAttrib_is_off_1775(PyObject *self, PyObject *) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline bool TextureAttrib::is_off(void) const
  bool return_value = ((*(const TextureAttrib*)local_this).is_off)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_is_off_1775_comment =
  "C++ Interface:\n"
  "is_off(TextureAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if the TextureAttrib is an 'off' TextureAttrib, indicating\n"
  " * that it should disable texturing.\n"
  " *\n"
  " * If multitexture is in effect, a TextureAttrib may not be strictly \"on\" or\n"
  " * \"off\"; therefore, to get a more precise answer to this question, you should\n"
  " * consider using has_all_off() or get_num_off_stages() or has_off_stage()\n"
  " * instead.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_is_off_1775_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *TextureAttrib::get_texture(void) const
 */
static PyObject *Dtool_TextureAttrib_get_texture_1776(PyObject *self, PyObject *) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline Texture *TextureAttrib::get_texture(void) const
  Texture *return_value = ((*(const TextureAttrib*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_texture_1776_comment =
  "C++ Interface:\n"
  "get_texture(TextureAttrib self)\n"
  "\n"
  "/**\n"
  " * If the TextureAttrib is not an 'off' TextureAttrib, returns the base-level\n"
  " * texture that is associated.  Otherwise, return NULL.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_get_texture_1776_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > TextureAttrib::make_all_off(void)
 */
static PyObject *Dtool_TextureAttrib_make_all_off_1777(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > TextureAttrib::make_all_off(void)
  ConstPointerTo< RenderAttrib > return_value = (TextureAttrib::make_all_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_make_all_off_1777_comment =
  "C++ Interface:\n"
  "make_all_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new TextureAttrib object that turns off all stages (and hence\n"
  " * disables texturing).\n"
  " */";
#else
static const char *Dtool_TextureAttrib_make_all_off_1777_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureAttrib::get_num_on_stages(void) const
 */
static PyObject *Dtool_TextureAttrib_get_num_on_stages_1778(PyObject *self, PyObject *) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline int TextureAttrib::get_num_on_stages(void) const
  int return_value = ((*(const TextureAttrib*)local_this).get_num_on_stages)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_num_on_stages_1778_comment =
  "C++ Interface:\n"
  "get_num_on_stages(TextureAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of stages that are turned on by the attribute.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_get_num_on_stages_1778_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage *TextureAttrib::get_on_stage(int n) const
 */
static PyObject *Dtool_TextureAttrib_get_on_stage_1779(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline TextureStage *TextureAttrib::get_on_stage(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TextureStage *return_value = ((*(const TextureAttrib*)local_this).get_on_stage)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_stage(TextureAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_on_stage_1779_comment =
  "C++ Interface:\n"
  "get_on_stage(TextureAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth stage turned on by the attribute, sorted in render order.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_get_on_stage_1779_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureAttrib::get_num_on_ff_stages(void) const
 */
static PyObject *Dtool_TextureAttrib_get_num_on_ff_stages_1781(PyObject *self, PyObject *) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline int TextureAttrib::get_num_on_ff_stages(void) const
  int return_value = ((*(const TextureAttrib*)local_this).get_num_on_ff_stages)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_num_on_ff_stages_1781_comment =
  "C++ Interface:\n"
  "get_num_on_ff_stages(TextureAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of on-stages that are relevant to the classic fixed\n"
  " * function pipeline.  This excludes texture stages such as normal maps.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_get_num_on_ff_stages_1781_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage *TextureAttrib::get_on_ff_stage(int n) const
 */
static PyObject *Dtool_TextureAttrib_get_on_ff_stage_1782(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline TextureStage *TextureAttrib::get_on_ff_stage(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TextureStage *return_value = ((*(const TextureAttrib*)local_this).get_on_ff_stage)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_ff_stage(TextureAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_on_ff_stage_1782_comment =
  "C++ Interface:\n"
  "get_on_ff_stage(TextureAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth stage turned on by the attribute, sorted in render order,\n"
  " * including only those relevant to the classic fixed function pipeline.  This\n"
  " * excludes texture stages such as normal maps.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_get_on_ff_stage_1782_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureAttrib::get_ff_tc_index(int n) const
 */
static PyObject *Dtool_TextureAttrib_get_ff_tc_index_1784(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline int TextureAttrib::get_ff_tc_index(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const TextureAttrib*)local_this).get_ff_tc_index)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ff_tc_index(TextureAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_ff_tc_index_1784_comment =
  "C++ Interface:\n"
  "get_ff_tc_index(TextureAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * For each TextureStage listed in get_on_ff_stage(), this returns a unique\n"
  " * index number for the texture coordinate name used by that TextureStage.  It\n"
  " * is guaranteed to remain the same index number for each texcoord name (for a\n"
  " * given set of TextureStages), even if the texture render order changes.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_get_ff_tc_index_1784_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureAttrib::has_on_stage(TextureStage *stage) const
 */
static PyObject *Dtool_TextureAttrib_has_on_stage_1785(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline bool TextureAttrib::has_on_stage(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.has_on_stage", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const TextureAttrib*)local_this).has_on_stage)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_on_stage(TextureAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_has_on_stage_1785_comment =
  "C++ Interface:\n"
  "has_on_stage(TextureAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated stage is turned on by the attrib, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_has_on_stage_1785_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *TextureAttrib::get_on_texture(TextureStage *stage) const
 */
static PyObject *Dtool_TextureAttrib_get_on_texture_1786(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline Texture *TextureAttrib::get_on_texture(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.get_on_texture", false, true);
  if (arg_this != nullptr) {
    Texture *return_value = ((*(const TextureAttrib*)local_this).get_on_texture)(arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_texture(TextureAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_on_texture_1786_comment =
  "C++ Interface:\n"
  "get_on_texture(TextureAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the texture associated with the indicated stage, or NULL if no\n"
  " * texture is associated.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_get_on_texture_1786_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState const &TextureAttrib::get_on_sampler(TextureStage *stage) const
 */
static PyObject *Dtool_TextureAttrib_get_on_sampler_1787(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline SamplerState const &TextureAttrib::get_on_sampler(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.get_on_sampler", false, true);
  if (arg_this != nullptr) {
    SamplerState const *return_value = &(((*(const TextureAttrib*)local_this).get_on_sampler)(arg_this));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SamplerState, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_sampler(TextureAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_on_sampler_1787_comment =
  "C++ Interface:\n"
  "get_on_sampler(TextureAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the sampler associated with the indicated stage, or the one\n"
  " * associated with its texture if no custom stage has been specified.  It is\n"
  " * an error to call this if the stage does not exist.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_get_on_sampler_1787_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureAttrib::get_on_stage_override(TextureStage *stage) const
 */
static PyObject *Dtool_TextureAttrib_get_on_stage_override_1788(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline int TextureAttrib::get_on_stage_override(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.get_on_stage_override", false, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const TextureAttrib*)local_this).get_on_stage_override)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_stage_override(TextureAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_on_stage_override_1788_comment =
  "C++ Interface:\n"
  "get_on_stage_override(TextureAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the override value associated with the indicated stage.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_get_on_stage_override_1788_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TextureAttrib::find_on_stage(TextureStage const *stage) const
 */
static PyObject *Dtool_TextureAttrib_find_on_stage_1789(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-int TextureAttrib::find_on_stage(TextureStage const *stage) const
  TextureStage const *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.find_on_stage", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const TextureAttrib*)local_this).find_on_stage)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_on_stage(TextureAttrib self, const TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_find_on_stage_1789_comment =
  "C++ Interface:\n"
  "find_on_stage(TextureAttrib self, const TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the indicated TextureStage within the list of\n"
  " * on_stages, or -1 if the indicated stage is not listed.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_find_on_stage_1789_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureAttrib::get_num_off_stages(void) const
 */
static PyObject *Dtool_TextureAttrib_get_num_off_stages_1799(PyObject *self, PyObject *) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline int TextureAttrib::get_num_off_stages(void) const
  int return_value = ((*(const TextureAttrib*)local_this).get_num_off_stages)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_num_off_stages_1799_comment =
  "C++ Interface:\n"
  "get_num_off_stages(TextureAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of stages that are turned off by the attribute.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_get_num_off_stages_1799_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage *TextureAttrib::get_off_stage(int n) const
 */
static PyObject *Dtool_TextureAttrib_get_off_stage_1800(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline TextureStage *TextureAttrib::get_off_stage(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TextureStage *return_value = ((*(const TextureAttrib*)local_this).get_off_stage)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_off_stage(TextureAttrib self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_off_stage_1800_comment =
  "C++ Interface:\n"
  "get_off_stage(TextureAttrib self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth stage turned off by the attribute, sorted in arbitrary\n"
  " * (pointer) order.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_get_off_stage_1800_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureAttrib::has_off_stage(TextureStage *stage) const
 */
static PyObject *Dtool_TextureAttrib_has_off_stage_1802(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline bool TextureAttrib::has_off_stage(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.has_off_stage", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const TextureAttrib*)local_this).has_off_stage)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_off_stage(TextureAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_has_off_stage_1802_comment =
  "C++ Interface:\n"
  "has_off_stage(TextureAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated stage is turned off by the attrib, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_has_off_stage_1802_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureAttrib::has_all_off(void) const
 */
static PyObject *Dtool_TextureAttrib_has_all_off_1803(PyObject *self, PyObject *) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline bool TextureAttrib::has_all_off(void) const
  bool return_value = ((*(const TextureAttrib*)local_this).has_all_off)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_has_all_off_1803_comment =
  "C++ Interface:\n"
  "has_all_off(TextureAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if this attrib turns off all stages (although it may also turn\n"
  " * some on).\n"
  " */";
#else
static const char *Dtool_TextureAttrib_has_all_off_1803_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureAttrib::is_identity(void) const
 */
static PyObject *Dtool_TextureAttrib_is_identity_1805(PyObject *self, PyObject *) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-inline bool TextureAttrib::is_identity(void) const
  bool return_value = ((*(const TextureAttrib*)local_this).is_identity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_is_identity_1805_comment =
  "C++ Interface:\n"
  "is_identity(TextureAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is an identity attrib: it does not change the set of\n"
  " * stages in use.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_is_identity_1805_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > TextureAttrib::add_on_stage(TextureStage *stage, Texture *tex, SamplerState const &sampler, int override = 0) const
 * ConstPointerTo< RenderAttrib > TextureAttrib::add_on_stage(TextureStage *stage, Texture *tex, int override = 0) const
 */
static PyObject *Dtool_TextureAttrib_add_on_stage_1806(PyObject *self, PyObject *args, PyObject *kwds) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-ConstPointerTo< RenderAttrib > TextureAttrib::add_on_stage(TextureStage *stage, Texture *tex, int override) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"stage", "tex", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_on_stage", (char **)keyword_list, &param1, &param2)) {
        TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "TextureAttrib.add_on_stage", false, true);
        Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "TextureAttrib.add_on_stage", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = ((*(const TextureAttrib*)local_this).add_on_stage)(param1_this, param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 ConstPointerTo< RenderAttrib > TextureAttrib::add_on_stage(TextureStage *stage, Texture *tex, SamplerState const &sampler, int override = 0) const
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4 = 0;
        static const char *keyword_list[] = {"stage", "tex", "sampler", "override", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:add_on_stage", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "TextureAttrib.add_on_stage", false, false);
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "TextureAttrib.add_on_stage", false, false);
          SamplerState const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_SamplerState);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = ((*(const TextureAttrib*)local_this).add_on_stage)(param1_this, param2_this, *param3_this, (int)param4);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderAttrib const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 ConstPointerTo< RenderAttrib > TextureAttrib::add_on_stage(TextureStage *stage, Texture *tex, int override = 0) const
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"stage", "tex", "override", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:add_on_stage", (char **)keyword_list, &param1, &param2, &param3)) {
          TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "TextureAttrib.add_on_stage", false, false);
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "TextureAttrib.add_on_stage", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = ((*(const TextureAttrib*)local_this).add_on_stage)(param1_this, param2_this, (int)param3);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderAttrib const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: ConstPointerTo< RenderAttrib > TextureAttrib::add_on_stage(TextureStage *stage, Texture *tex, SamplerState const &sampler, int override = 0) const
      // No coercion possible: ConstPointerTo< RenderAttrib > TextureAttrib::add_on_stage(TextureStage *stage, Texture *tex, int override = 0) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_on_stage() takes 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_on_stage(TextureAttrib self, TextureStage stage, Texture tex)\n"
      "add_on_stage(TextureAttrib self, TextureStage stage, Texture tex, const SamplerState sampler, int override)\n"
      "add_on_stage(TextureAttrib self, TextureStage stage, Texture tex, int override)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_add_on_stage_1806_comment =
  "C++ Interface:\n"
  "add_on_stage(TextureAttrib self, TextureStage stage, Texture tex)\n"
  "add_on_stage(TextureAttrib self, TextureStage stage, Texture tex, const SamplerState sampler, int override)\n"
  "add_on_stage(TextureAttrib self, TextureStage stage, Texture tex, int override)\n"
  "\n"
  "/**\n"
  " * Returns a new TextureAttrib, just like this one, but with the indicated\n"
  " * stage added to the list of stages turned on by this attrib.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a new TextureAttrib, just like this one, but with the indicated\n"
  " * stage added to the list of stages turned on by this attrib.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_add_on_stage_1806_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > TextureAttrib::remove_on_stage(TextureStage *stage) const
 */
static PyObject *Dtool_TextureAttrib_remove_on_stage_1807(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > TextureAttrib::remove_on_stage(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.remove_on_stage", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const TextureAttrib*)local_this).remove_on_stage)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_on_stage(TextureAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_remove_on_stage_1807_comment =
  "C++ Interface:\n"
  "remove_on_stage(TextureAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns a new TextureAttrib, just like this one, but with the indicated\n"
  " * stage removed from the list of stages turned on by this attrib.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_remove_on_stage_1807_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > TextureAttrib::add_off_stage(TextureStage *stage, int override = 0) const
 */
static PyObject *Dtool_TextureAttrib_add_off_stage_1808(PyObject *self, PyObject *args, PyObject *kwds) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > TextureAttrib::add_off_stage(TextureStage *stage, int override = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"stage", "override", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:add_off_stage", (char **)keyword_list, &param1, &param2)) {
    TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "TextureAttrib.add_off_stage", false, true);
    if (param1_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = ((*(const TextureAttrib*)local_this).add_off_stage)(param1_this, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_off_stage(TextureAttrib self, TextureStage stage, int override)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_add_off_stage_1808_comment =
  "C++ Interface:\n"
  "add_off_stage(TextureAttrib self, TextureStage stage, int override)\n"
  "\n"
  "/**\n"
  " * Returns a new TextureAttrib, just like this one, but with the indicated\n"
  " * stage added to the list of stages turned off by this attrib.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_add_off_stage_1808_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > TextureAttrib::remove_off_stage(TextureStage *stage) const
 */
static PyObject *Dtool_TextureAttrib_remove_off_stage_1809(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > TextureAttrib::remove_off_stage(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.remove_off_stage", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const TextureAttrib*)local_this).remove_off_stage)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_off_stage(TextureAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_remove_off_stage_1809_comment =
  "C++ Interface:\n"
  "remove_off_stage(TextureAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns a new TextureAttrib, just like this one, but with the indicated\n"
  " * stage removed from the list of stages turned off by this attrib.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_remove_off_stage_1809_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > TextureAttrib::unify_texture_stages(TextureStage *stage) const
 */
static PyObject *Dtool_TextureAttrib_unify_texture_stages_1810(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > TextureAttrib::unify_texture_stages(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.unify_texture_stages", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const TextureAttrib*)local_this).unify_texture_stages)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unify_texture_stages(TextureAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_unify_texture_stages_1810_comment =
  "C++ Interface:\n"
  "unify_texture_stages(TextureAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns a new TextureAttrib, just like this one, but with any included\n"
  " * TextureAttribs that happen to have the same name as the given object\n"
  " * replaced with the object.\n"
  " */";
#else
static const char *Dtool_TextureAttrib_unify_texture_stages_1810_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > TextureAttrib::replace_texture(Texture *tex, Texture *new_tex) const
 */
static PyObject *Dtool_TextureAttrib_replace_texture_1811(PyObject *self, PyObject *args, PyObject *kwds) {
  TextureAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > TextureAttrib::replace_texture(Texture *tex, Texture *new_tex) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"tex", "new_tex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:replace_texture", (char **)keyword_list, &param1, &param2)) {
    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "TextureAttrib.replace_texture", false, true);
    Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "TextureAttrib.replace_texture", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = ((*(const TextureAttrib*)local_this).replace_texture)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "replace_texture(TextureAttrib self, Texture tex, Texture new_tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_replace_texture_1811_comment =
  "C++ Interface:\n"
  "replace_texture(TextureAttrib self, Texture tex, Texture new_tex)\n"
  "\n"
  "/**\n"
  " * Returns a new TextureAttrib, just like this one, but with all references to\n"
  " * the given texture replaced with the new texture.\n"
  " *\n"
  " * @since 1.10.4\n"
  " */";
#else
static const char *Dtool_TextureAttrib_replace_texture_1811_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int TextureAttrib::get_class_slot(void)
 */
static PyObject *Dtool_TextureAttrib_get_class_slot_1812(PyObject *, PyObject *) {
  // 1-static int TextureAttrib::get_class_slot(void)
  int return_value = (TextureAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_class_slot_1812_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_TextureAttrib_get_class_slot_1812_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextureAttrib::get_class_type(void)
 */
static PyObject *Dtool_TextureAttrib_get_class_type_1814(PyObject *, PyObject *) {
  // 1-static TypeHandle TextureAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TextureAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureAttrib_get_class_type_1814_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextureAttrib_get_class_type_1814_comment = nullptr;
#endif

/**
 * sequence length function for property TextureAttrib::on_stages
 */
static Py_ssize_t Dtool_TextureAttrib_on_stages_Len(PyObject *self) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_on_stages)();
}

/**
 * sequence getter for property TextureAttrib::on_stages
 */
static PyObject *Dtool_TextureAttrib_on_stages_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_on_stages)()) {
    PyErr_SetString(PyExc_IndexError, "TextureAttrib.on_stages[] index out of range");
    return nullptr;
  }
  // 1-inline TextureStage *TextureAttrib::get_on_stage(int n) const
  TextureStage *return_value = ((*(const TextureAttrib*)local_this).get_on_stage)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_stage(TextureAttrib self, index)\n");
  }
}

static PyObject *Dtool_TextureAttrib_on_stages_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "TextureAttrib.on_stages");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_TextureAttrib_on_stages_Len;
    wrap->_getitem_func = &Dtool_TextureAttrib_on_stages_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property TextureAttrib::textures
 */
static Py_ssize_t Dtool_TextureAttrib_textures_Len(PyObject *self) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_on_stages)();
}

/**
 * mapping getitem for property TextureAttrib::textures
 */
static PyObject *Dtool_TextureAttrib_textures_Mapping_Getitem(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return nullptr;
  }
  {
    // 1-inline bool TextureAttrib::has_on_stage(TextureStage *stage) const
    TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.has_on_stage", false, true);
    if (arg_this != nullptr) {
      bool return_value = ((*(const TextureAttrib*)local_this).has_on_stage)(arg_this);
      if (!return_value) {
        PyErr_SetObject(PyExc_KeyError, arg);
        return nullptr;
      }
    }
  }
  // 1-inline Texture *TextureAttrib::get_on_texture(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.get_on_texture", false, true);
  if (arg_this != nullptr) {
    Texture *return_value = ((*(const TextureAttrib*)local_this).get_on_texture)(arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return Dtool_Raise_AssertionError();
    }
#endif
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_texture(TextureAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

/**
 * mapping key-getter for property TextureAttrib::textures
 */
static PyObject *Dtool_TextureAttrib_textures_Mapping_Getkey(PyObject *self, Py_ssize_t index) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_on_stages)()) {
    PyErr_SetString(PyExc_IndexError, "TextureAttrib.textures[] index out of range");
    return nullptr;
  }
  // 1-inline TextureStage *TextureAttrib::get_on_stage(int n) const
  TextureStage *return_value = ((*(const TextureAttrib*)local_this).get_on_stage)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_stage(TextureAttrib self, index)\n");
  }
}

static PyObject *Dtool_TextureAttrib_textures_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MappingWrapper *wrap = Dtool_NewMappingWrapper(self, "TextureAttrib.textures");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_TextureAttrib_textures_Mapping_Getitem;
    wrap->_keys._len_func = &Dtool_TextureAttrib_textures_Len;
    wrap->_keys._getitem_func = &Dtool_TextureAttrib_textures_Mapping_Getkey;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property TextureAttrib::samplers
 */
static Py_ssize_t Dtool_TextureAttrib_samplers_Len(PyObject *self) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_on_stages)();
}

/**
 * mapping getitem for property TextureAttrib::samplers
 */
static PyObject *Dtool_TextureAttrib_samplers_Mapping_Getitem(PyObject *self, PyObject *arg) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return nullptr;
  }
  {
    // 1-inline bool TextureAttrib::has_on_stage(TextureStage *stage) const
    TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.has_on_stage", false, true);
    if (arg_this != nullptr) {
      bool return_value = ((*(const TextureAttrib*)local_this).has_on_stage)(arg_this);
      if (!return_value) {
        PyErr_SetObject(PyExc_KeyError, arg);
        return nullptr;
      }
    }
  }
  // 1-inline SamplerState const &TextureAttrib::get_on_sampler(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureAttrib.get_on_sampler", false, true);
  if (arg_this != nullptr) {
    SamplerState const *return_value = &(((*(const TextureAttrib*)local_this).get_on_sampler)(arg_this));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SamplerState, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_sampler(TextureAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

/**
 * mapping key-getter for property TextureAttrib::samplers
 */
static PyObject *Dtool_TextureAttrib_samplers_Mapping_Getkey(PyObject *self, Py_ssize_t index) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_on_stages)()) {
    PyErr_SetString(PyExc_IndexError, "TextureAttrib.samplers[] index out of range");
    return nullptr;
  }
  // 1-inline TextureStage *TextureAttrib::get_on_stage(int n) const
  TextureStage *return_value = ((*(const TextureAttrib*)local_this).get_on_stage)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_stage(TextureAttrib self, index)\n");
  }
}

static PyObject *Dtool_TextureAttrib_samplers_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MappingWrapper *wrap = Dtool_NewMappingWrapper(self, "TextureAttrib.samplers");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_TextureAttrib_samplers_Mapping_Getitem;
    wrap->_keys._len_func = &Dtool_TextureAttrib_samplers_Len;
    wrap->_keys._getitem_func = &Dtool_TextureAttrib_samplers_Mapping_Getkey;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property TextureAttrib::off_stages
 */
static Py_ssize_t Dtool_TextureAttrib_off_stages_Len(PyObject *self) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_off_stages)();
}

/**
 * sequence getter for property TextureAttrib::off_stages
 */
static PyObject *Dtool_TextureAttrib_off_stages_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_off_stages)()) {
    PyErr_SetString(PyExc_IndexError, "TextureAttrib.off_stages[] index out of range");
    return nullptr;
  }
  // 1-inline TextureStage *TextureAttrib::get_off_stage(int n) const
  TextureStage *return_value = ((*(const TextureAttrib*)local_this).get_off_stage)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_off_stage(TextureAttrib self, index)\n");
  }
}

static PyObject *Dtool_TextureAttrib_off_stages_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "TextureAttrib.off_stages");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_TextureAttrib_off_stages_Len;
    wrap->_getitem_func = &Dtool_TextureAttrib_off_stages_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_TextureAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int TextureAttrib::get_class_slot(void)
  int return_value = (TextureAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_TextureAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_TextureAttrib(PyObject *args, CPT(TextureAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_TextureAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > TextureAttrib::make(Texture *tex)
    Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 0, "TextureAttrib.make", false, false);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = (TextureAttrib::make)(arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((TextureAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TextureAttrib_get_on_stages(PyObject *self, PyObject *) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_on_stages)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TextureAttrib_get_on_stage_1779(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TextureAttrib_get_on_ff_stages(PyObject *self, PyObject *) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_on_ff_stages)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TextureAttrib_get_on_ff_stage_1782(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TextureAttrib_get_off_stages(PyObject *self, PyObject *) {
  TextureAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureAttrib, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_off_stages)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TextureAttrib_get_off_stage_1800(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_TextureAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextureAttrib) {
    printf("TextureAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextureAttrib *local_this = (TextureAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextureAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextureAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextureAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TextureAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (TextureAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TextureAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TextureAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TextureAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TexGenAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > TexGenAttrib::make(void)
 * static ConstPointerTo< RenderAttrib > TexGenAttrib::make(TextureStage *stage, TexGenAttrib::Mode mode)
 */
static PyObject *Dtool_TexGenAttrib_make_1817(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-static ConstPointerTo< RenderAttrib > TexGenAttrib::make(void)
      ConstPointerTo< RenderAttrib > return_value = (TexGenAttrib::make)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 2:
    {
      // 1-static ConstPointerTo< RenderAttrib > TexGenAttrib::make(TextureStage *stage, TexGenAttrib::Mode mode)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"stage", "mode", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:make", (char **)keyword_list, &param0, &param1)) {
        TextureStage *param0_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TextureStage, 0, "TexGenAttrib.make", false, true);
        if (param0_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (TexGenAttrib::make)(param0_this, (TexGenAttrib::Mode)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 0 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make()\n"
      "make(TextureStage stage, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_make_1817_comment =
  "C++ Interface:\n"
  "make()\n"
  "make(TextureStage stage, int mode)\n"
  "\n"
  "/**\n"
  " * Constructs a TexGenAttrib that generates no stages at all.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a TexGenAttrib that generates just the indicated stage.\n"
  " */";
#else
static const char *Dtool_TexGenAttrib_make_1817_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > TexGenAttrib::make_default(void)
 */
static PyObject *Dtool_TexGenAttrib_make_default_1818(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > TexGenAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (TexGenAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_make_default_1818_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_TexGenAttrib_make_default_1818_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > TexGenAttrib::add_stage(TextureStage *stage, TexGenAttrib::Mode mode) const
 * ConstPointerTo< RenderAttrib > TexGenAttrib::add_stage(TextureStage *stage, TexGenAttrib::Mode mode, LTexCoord3 const &constant_value) const
 */
static PyObject *Dtool_TexGenAttrib_add_stage_1819(PyObject *self, PyObject *args, PyObject *kwds) {
  TexGenAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexGenAttrib)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-ConstPointerTo< RenderAttrib > TexGenAttrib::add_stage(TextureStage *stage, TexGenAttrib::Mode mode) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"stage", "mode", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:add_stage", (char **)keyword_list, &param1, &param2)) {
        TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "TexGenAttrib.add_stage", false, true);
        if (param1_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = ((*(const TexGenAttrib*)local_this).add_stage)(param1_this, (TexGenAttrib::Mode)param2);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 3:
    {
      // 1-ConstPointerTo< RenderAttrib > TexGenAttrib::add_stage(TextureStage *stage, TexGenAttrib::Mode mode, LTexCoord3 const &constant_value) const
      PyObject *param1;
      int param2;
      PyObject *param3;
      static const char *keyword_list[] = {"stage", "mode", "constant_value", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO:add_stage", (char **)keyword_list, &param1, &param2, &param3)) {
        TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "TexGenAttrib.add_stage", false, true);
        LPoint3f param3_local;
        LTexCoord3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "TexGenAttrib.add_stage", "LPoint3f");
        }
        if (param1_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = ((*(const TexGenAttrib*)local_this).add_stage)(param1_this, (TexGenAttrib::Mode)param2, *param3_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_stage() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_stage(TexGenAttrib self, TextureStage stage, int mode)\n"
      "add_stage(TexGenAttrib self, TextureStage stage, int mode, const LPoint3f constant_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_add_stage_1819_comment =
  "C++ Interface:\n"
  "add_stage(TexGenAttrib self, TextureStage stage, int mode)\n"
  "add_stage(TexGenAttrib self, TextureStage stage, int mode, const LPoint3f constant_value)\n"
  "\n"
  "/**\n"
  " * Returns a new TexGenAttrib just like this one, with the indicated\n"
  " * generation mode for the given stage.  If this stage already exists, its\n"
  " * mode is replaced.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a new TexGenAttrib just like this one, with the indicated\n"
  " * generation mode for the given stage.  If this stage already exists, its\n"
  " * mode is replaced.\n"
  " *\n"
  " * This variant also accepts constant_value, which is only meaningful if mode\n"
  " * is M_constant.\n"
  " */";
#else
static const char *Dtool_TexGenAttrib_add_stage_1819_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > TexGenAttrib::remove_stage(TextureStage *stage) const
 */
static PyObject *Dtool_TexGenAttrib_remove_stage_1820(PyObject *self, PyObject *arg) {
  TexGenAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexGenAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > TexGenAttrib::remove_stage(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexGenAttrib.remove_stage", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const TexGenAttrib*)local_this).remove_stage)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_stage(TexGenAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_remove_stage_1820_comment =
  "C++ Interface:\n"
  "remove_stage(TexGenAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns a new TexGenAttrib just like this one, with the indicated stage\n"
  " * removed.\n"
  " */";
#else
static const char *Dtool_TexGenAttrib_remove_stage_1820_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TexGenAttrib::is_empty(void) const
 */
static PyObject *Dtool_TexGenAttrib_is_empty_1821(PyObject *self, PyObject *) {
  TexGenAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexGenAttrib)) {
    return nullptr;
  }
  // 1-bool TexGenAttrib::is_empty(void) const
  bool return_value = ((*(const TexGenAttrib*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_is_empty_1821_comment =
  "C++ Interface:\n"
  "is_empty(TexGenAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if no stages are defined in the TexGenAttrib, false if at\n"
  " * least one is.\n"
  " */";
#else
static const char *Dtool_TexGenAttrib_is_empty_1821_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TexGenAttrib::has_stage(TextureStage *stage) const
 */
static PyObject *Dtool_TexGenAttrib_has_stage_1822(PyObject *self, PyObject *arg) {
  TexGenAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexGenAttrib)) {
    return nullptr;
  }
  // 1-bool TexGenAttrib::has_stage(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexGenAttrib.has_stage", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const TexGenAttrib*)local_this).has_stage)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_stage(TexGenAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_has_stage_1822_comment =
  "C++ Interface:\n"
  "has_stage(TexGenAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a mode associated with the indicated stage, or\n"
  " * false otherwise (in which case get_transform(stage) will return M_off).\n"
  " */";
#else
static const char *Dtool_TexGenAttrib_has_stage_1822_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TexGenAttrib::Mode TexGenAttrib::get_mode(TextureStage *stage) const
 */
static PyObject *Dtool_TexGenAttrib_get_mode_1823(PyObject *self, PyObject *arg) {
  TexGenAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexGenAttrib)) {
    return nullptr;
  }
  // 1-TexGenAttrib::Mode TexGenAttrib::get_mode(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexGenAttrib.get_mode", false, true);
  if (arg_this != nullptr) {
    TexGenAttrib::Mode return_value = ((*(const TexGenAttrib*)local_this).get_mode)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mode(TexGenAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_get_mode_1823_comment =
  "C++ Interface:\n"
  "get_mode(TexGenAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the generation mode associated with the named texture stage, or\n"
  " * M_off if nothing is associated with the indicated stage.\n"
  " */";
#else
static const char *Dtool_TexGenAttrib_get_mode_1823_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TexGenAttrib::has_gen_texcoord_stage(TextureStage *stage) const
 */
static PyObject *Dtool_TexGenAttrib_has_gen_texcoord_stage_1824(PyObject *self, PyObject *arg) {
  TexGenAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexGenAttrib)) {
    return nullptr;
  }
  // 1-bool TexGenAttrib::has_gen_texcoord_stage(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexGenAttrib.has_gen_texcoord_stage", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const TexGenAttrib*)local_this).has_gen_texcoord_stage)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_gen_texcoord_stage(TexGenAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_has_gen_texcoord_stage_1824_comment =
  "C++ Interface:\n"
  "has_gen_texcoord_stage(TexGenAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated TextureStage will have texture coordinates\n"
  " * generated for it automatically (and thus there is no need to upload the\n"
  " * texture coordinates encoded in the vertices).\n"
  " */";
#else
static const char *Dtool_TexGenAttrib_has_gen_texcoord_stage_1824_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LTexCoord3 const &TexGenAttrib::get_constant_value(TextureStage *stage) const
 */
static PyObject *Dtool_TexGenAttrib_get_constant_value_1825(PyObject *self, PyObject *arg) {
  TexGenAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexGenAttrib)) {
    return nullptr;
  }
  // 1-LTexCoord3 const &TexGenAttrib::get_constant_value(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexGenAttrib.get_constant_value", false, true);
  if (arg_this != nullptr) {
    LTexCoord3 const *return_value = &(((*(const TexGenAttrib*)local_this).get_constant_value)(arg_this));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_constant_value(TexGenAttrib self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_get_constant_value_1825_comment =
  "C++ Interface:\n"
  "get_constant_value(TexGenAttrib self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the constant value associated with the named texture stage.  This\n"
  " * is only meaningful if the mode is M_constant.\n"
  " */";
#else
static const char *Dtool_TexGenAttrib_get_constant_value_1825_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TexGenAttrib::get_geom_rendering(int geom_rendering) const
 */
static PyObject *Dtool_TexGenAttrib_get_geom_rendering_1826(PyObject *self, PyObject *arg) {
  TexGenAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexGenAttrib)) {
    return nullptr;
  }
  // 1-inline int TexGenAttrib::get_geom_rendering(int geom_rendering) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const TexGenAttrib*)local_this).get_geom_rendering)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geom_rendering(TexGenAttrib self, int geom_rendering)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_get_geom_rendering_1826_comment =
  "C++ Interface:\n"
  "get_geom_rendering(TexGenAttrib self, int geom_rendering)\n"
  "\n"
  "/**\n"
  " * Returns the union of the Geom::GeomRendering bits that will be required\n"
  " * once this TexGenAttrib is applied to a geom which includes the indicated\n"
  " * geom_rendering bits.\n"
  " */";
#else
static const char *Dtool_TexGenAttrib_get_geom_rendering_1826_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int TexGenAttrib::get_class_slot(void)
 */
static PyObject *Dtool_TexGenAttrib_get_class_slot_1827(PyObject *, PyObject *) {
  // 1-static int TexGenAttrib::get_class_slot(void)
  int return_value = (TexGenAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_get_class_slot_1827_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_TexGenAttrib_get_class_slot_1827_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TexGenAttrib::get_class_type(void)
 */
static PyObject *Dtool_TexGenAttrib_get_class_type_1829(PyObject *, PyObject *) {
  // 1-static TypeHandle TexGenAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TexGenAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TexGenAttrib_get_class_type_1829_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TexGenAttrib_get_class_type_1829_comment = nullptr;
#endif

static PyObject *Dtool_TexGenAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int TexGenAttrib::get_class_slot(void)
  int return_value = (TexGenAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_TexGenAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_TexGenAttrib(PyObject *args, CPT(TexGenAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_TexGenAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-static ConstPointerTo< RenderAttrib > TexGenAttrib::make(TextureStage *stage, TexGenAttrib::Mode mode)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:make", &param0, &param1)) {
        TextureStage *param0_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TextureStage, 0, "TexGenAttrib.make", false, false);
        if (param0_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (TexGenAttrib::make)(param0_this, (TexGenAttrib::Mode)param1);
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move((TexGenAttrib const *) return_value.p());
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_TexGenAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TexGenAttrib) {
    printf("TexGenAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TexGenAttrib *local_this = (TexGenAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TexGenAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TexGenAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TexGenAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TexGenAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (TexGenAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TexGenAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TexGenAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TexGenAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OccluderNode
 */
/**
 * Python function wrapper for:
 * inline void OccluderNode::set_double_sided(bool value)
 */
static PyObject *Dtool_OccluderNode_set_double_sided_1832(PyObject *self, PyObject *arg) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OccluderNode, (void **)&local_this, "OccluderNode.set_double_sided")) {
    return nullptr;
  }
  // 1-inline void OccluderNode::set_double_sided(bool value)
  ((*local_this).set_double_sided)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_double_sided(const OccluderNode self, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OccluderNode_set_double_sided_1832_comment =
  "C++ Interface:\n"
  "set_double_sided(const OccluderNode self, bool value)\n"
  "\n"
  "/**\n"
  " * If true, the back-face will also be used to occlude\n"
  " */";
#else
static const char *Dtool_OccluderNode_set_double_sided_1832_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool OccluderNode::is_double_sided(void)
 */
static PyObject *Dtool_OccluderNode_is_double_sided_1833(PyObject *self, PyObject *) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OccluderNode, (void **)&local_this, "OccluderNode.is_double_sided")) {
    return nullptr;
  }
  // 1-inline bool OccluderNode::is_double_sided(void)
  bool return_value = ((*local_this).is_double_sided)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OccluderNode_is_double_sided_1833_comment =
  "C++ Interface:\n"
  "is_double_sided(const OccluderNode self)\n"
  "\n"
  "/**\n"
  " * Is this occluder double-sided\n"
  " */";
#else
static const char *Dtool_OccluderNode_is_double_sided_1833_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OccluderNode::set_min_coverage(PN_stdfloat value)
 */
static PyObject *Dtool_OccluderNode_set_min_coverage_1834(PyObject *self, PyObject *arg) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OccluderNode, (void **)&local_this, "OccluderNode.set_min_coverage")) {
    return nullptr;
  }
  // 1-inline void OccluderNode::set_min_coverage(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_min_coverage)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_coverage(const OccluderNode self, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OccluderNode_set_min_coverage_1834_comment =
  "C++ Interface:\n"
  "set_min_coverage(const OccluderNode self, float value)\n"
  "\n"
  "/**\n"
  " * Minimum screen coverage needed before occluder used.  Range should be 0 to\n"
  " * 1. For example, setting to 0.2 would mean that the occluder needs to cover\n"
  " * 20% of the screen to be considered.\n"
  " */";
#else
static const char *Dtool_OccluderNode_set_min_coverage_1834_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat OccluderNode::get_min_coverage(void)
 */
static PyObject *Dtool_OccluderNode_get_min_coverage_1835(PyObject *self, PyObject *) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OccluderNode, (void **)&local_this, "OccluderNode.get_min_coverage")) {
    return nullptr;
  }
  // 1-inline PN_stdfloat OccluderNode::get_min_coverage(void)
  PN_stdfloat return_value = ((*local_this).get_min_coverage)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OccluderNode_get_min_coverage_1835_comment =
  "C++ Interface:\n"
  "get_min_coverage(const OccluderNode self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum screen coverage.\n"
  " */";
#else
static const char *Dtool_OccluderNode_get_min_coverage_1835_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OccluderNode::set_vertices(LPoint3 const &v0, LPoint3 const &v1, LPoint3 const &v2, LPoint3 const &v3)
 */
static PyObject *Dtool_OccluderNode_set_vertices_1836(PyObject *self, PyObject *args, PyObject *kwds) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OccluderNode, (void **)&local_this, "OccluderNode.set_vertices")) {
    return nullptr;
  }
  // 1-inline void OccluderNode::set_vertices(LPoint3 const &v0, LPoint3 const &v1, LPoint3 const &v2, LPoint3 const &v3)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  PyObject *param4;
  static const char *keyword_list[] = {"v0", "v1", "v2", "v3", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_vertices", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OccluderNode.set_vertices", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OccluderNode.set_vertices", "LPoint3f");
    }
    LPoint3f param3_local;
    LPoint3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "OccluderNode.set_vertices", "LPoint3f");
    }
    LPoint3f param4_local;
    LPoint3 const *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
    if (!(param4_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "OccluderNode.set_vertices", "LPoint3f");
    }
    ((*local_this).set_vertices)(*param1_this, *param2_this, *param3_this, *param4_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertices(const OccluderNode self, const LPoint3f v0, const LPoint3f v1, const LPoint3f v2, const LPoint3f v3)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OccluderNode_set_vertices_1836_comment =
  "C++ Interface:\n"
  "set_vertices(const OccluderNode self, const LPoint3f v0, const LPoint3f v1, const LPoint3f v2, const LPoint3f v3)\n"
  "\n"
  "/**\n"
  " * Replaces the four vertices of the occluder polygon.  The vertices should be\n"
  " * defined in a counterclockwise orientation when looking at the face of the\n"
  " * occluder.\n"
  " */";
#else
static const char *Dtool_OccluderNode_set_vertices_1836_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t OccluderNode::get_num_vertices(void) const
 */
static PyObject *Dtool_OccluderNode_get_num_vertices_1837(PyObject *self, PyObject *) {
  OccluderNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OccluderNode)) {
    return nullptr;
  }
  // 1-inline std::size_t OccluderNode::get_num_vertices(void) const
  std::size_t return_value = ((*(const OccluderNode*)local_this).get_num_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OccluderNode_get_num_vertices_1837_comment =
  "C++ Interface:\n"
  "get_num_vertices(OccluderNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices in the occluder polygon.  This should always\n"
  " * return 4.\n"
  " */";
#else
static const char *Dtool_OccluderNode_get_num_vertices_1837_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &OccluderNode::get_vertex(std::size_t n) const
 */
static PyObject *Dtool_OccluderNode_get_vertex_1838(PyObject *self, PyObject *arg) {
  OccluderNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OccluderNode)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &OccluderNode::get_vertex(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    LPoint3 const *return_value = &(((*(const OccluderNode*)local_this).get_vertex)(arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(OccluderNode self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OccluderNode_get_vertex_1838_comment =
  "C++ Interface:\n"
  "get_vertex(OccluderNode self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the occluder polygon.\n"
  " */";
#else
static const char *Dtool_OccluderNode_get_vertex_1838_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OccluderNode::set_vertex(std::size_t n, LPoint3 const &v)
 */
static PyObject *Dtool_OccluderNode_set_vertex_1839(PyObject *self, PyObject *args, PyObject *kwds) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OccluderNode, (void **)&local_this, "OccluderNode.set_vertex")) {
    return nullptr;
  }
  // 1-inline void OccluderNode::set_vertex(std::size_t n, LPoint3 const &v)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "v", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_vertex", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    LPoint3f param2_local;
    LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OccluderNode.set_vertex", "LPoint3f");
    }
    ((*local_this).set_vertex)((std::size_t)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex(const OccluderNode self, int n, const LPoint3f v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OccluderNode_set_vertex_1839_comment =
  "C++ Interface:\n"
  "set_vertex(const OccluderNode self, int n, const LPoint3f v)\n"
  "\n"
  "/**\n"
  " * Sets the nth vertex of the occluder polygon.\n"
  " */";
#else
static const char *Dtool_OccluderNode_set_vertex_1839_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OccluderNode::get_class_type(void)
 */
static PyObject *Dtool_OccluderNode_get_class_type_1844(PyObject *, PyObject *) {
  // 1-static TypeHandle OccluderNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OccluderNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OccluderNode_get_class_type_1844_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OccluderNode_get_class_type_1844_comment = nullptr;
#endif

static PyObject *Dtool_OccluderNode_double_sided_Getter(PyObject *self, void *) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OccluderNode, (void **)&local_this, "OccluderNode.double_sided")) {
    return nullptr;
  }

  // 1-inline bool OccluderNode::is_double_sided(void)
  bool return_value = ((*local_this).is_double_sided)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_OccluderNode_double_sided_Setter(PyObject *self, PyObject *arg, void *) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OccluderNode, (void **)&local_this, "OccluderNode.double_sided")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete double_sided attribute");
    return -1;
  }
  // 1-inline void OccluderNode::set_double_sided(bool value)
  ((*local_this).set_double_sided)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_double_sided(const OccluderNode self, bool value)\n");
  }
  return -1;
}

static PyObject *Dtool_OccluderNode_min_coverage_Getter(PyObject *self, void *) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OccluderNode, (void **)&local_this, "OccluderNode.min_coverage")) {
    return nullptr;
  }

  // 1-inline PN_stdfloat OccluderNode::get_min_coverage(void)
  PN_stdfloat return_value = ((*local_this).get_min_coverage)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_OccluderNode_min_coverage_Setter(PyObject *self, PyObject *arg, void *) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OccluderNode, (void **)&local_this, "OccluderNode.min_coverage")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete min_coverage attribute");
    return -1;
  }
  // 1-inline void OccluderNode::set_min_coverage(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_min_coverage)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_min_coverage(const OccluderNode self, float value)\n");
  }
  return -1;
}

/**
 * sequence length function for property OccluderNode::vertices
 */
static Py_ssize_t Dtool_OccluderNode_vertices_Len(PyObject *self) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OccluderNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_vertices)();
}

/**
 * sequence getter for property OccluderNode::vertices
 */
static PyObject *Dtool_OccluderNode_vertices_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OccluderNode, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_vertices)()) {
    PyErr_SetString(PyExc_IndexError, "OccluderNode.vertices[] index out of range");
    return nullptr;
  }
  // 1-inline LPoint3 const &OccluderNode::get_vertex(std::size_t n) const
  LPoint3 const *return_value = &(((*(const OccluderNode*)local_this).get_vertex)(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(OccluderNode self, index)\n");
  }
}

static int Dtool_OccluderNode_vertices_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OccluderNode, (void **)&local_this, "OccluderNode.vertices")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_vertices)()) {
    PyErr_SetString(PyExc_IndexError, "OccluderNode.vertices[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete vertices[] attribute");
    return -1;
  }
  // 1-inline void OccluderNode::set_vertex(std::size_t n, LPoint3 const &v)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 2, "OccluderNode.set_vertex", "LPoint3f");
    return -1;
  }
  ((*local_this).set_vertex)(index, *arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_vertex(const OccluderNode self, index, const LPoint3f v)\n");
  }
  return -1;
}

static PyObject *Dtool_OccluderNode_vertices_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "OccluderNode.vertices");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_OccluderNode_vertices_Len;
    wrap->_getitem_func = &Dtool_OccluderNode_vertices_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_OccluderNode_vertices_Sequence_Setitem;
    }
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * explicit OccluderNode::OccluderNode(std::string const &name)
 */
static int Dtool_Init_OccluderNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OccluderNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit OccluderNode::OccluderNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      OccluderNode *return_value = new OccluderNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OccluderNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OccluderNode(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OccluderNode_get_vertices(PyObject *self, PyObject *) {
  OccluderNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OccluderNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_vertices)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OccluderNode_get_vertex_1838(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OccluderNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OccluderNode) {
    printf("OccluderNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OccluderNode *local_this = (OccluderNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OccluderNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OccluderNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OccluderNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (OccluderNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (OccluderNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OccluderNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OccluderNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (OccluderNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (OccluderNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OccluderEffect
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > OccluderEffect::make(void)
 */
static PyObject *Dtool_OccluderEffect_make_1846(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderEffect > OccluderEffect::make(void)
  ConstPointerTo< RenderEffect > return_value = (OccluderEffect::make)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffect const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OccluderEffect_make_1846_comment =
  "C++ Interface:\n"
  "make()\n"
  "\n"
  "/**\n"
  " * Constructs a new OccluderEffect object that does nothing.\n"
  " */";
#else
static const char *Dtool_OccluderEffect_make_1846_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OccluderEffect::get_num_on_occluders(void) const
 */
static PyObject *Dtool_OccluderEffect_get_num_on_occluders_1847(PyObject *self, PyObject *) {
  OccluderEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OccluderEffect)) {
    return nullptr;
  }
  // 1-inline int OccluderEffect::get_num_on_occluders(void) const
  int return_value = ((*(const OccluderEffect*)local_this).get_num_on_occluders)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OccluderEffect_get_num_on_occluders_1847_comment =
  "C++ Interface:\n"
  "get_num_on_occluders(OccluderEffect self)\n"
  "\n"
  "/**\n"
  " * Returns the number of occluders that are enabled by the effectute.\n"
  " */";
#else
static const char *Dtool_OccluderEffect_get_num_on_occluders_1847_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath OccluderEffect::get_on_occluder(int n) const
 */
static PyObject *Dtool_OccluderEffect_get_on_occluder_1848(PyObject *self, PyObject *arg) {
  OccluderEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OccluderEffect)) {
    return nullptr;
  }
  // 1-inline NodePath OccluderEffect::get_on_occluder(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath(((*(const OccluderEffect*)local_this).get_on_occluder)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_on_occluder(OccluderEffect self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OccluderEffect_get_on_occluder_1848_comment =
  "C++ Interface:\n"
  "get_on_occluder(OccluderEffect self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth occluder enabled by the effectute, sorted in render order.\n"
  " */";
#else
static const char *Dtool_OccluderEffect_get_on_occluder_1848_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool OccluderEffect::has_on_occluder(NodePath const &occluder) const
 */
static PyObject *Dtool_OccluderEffect_has_on_occluder_1850(PyObject *self, PyObject *arg) {
  OccluderEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OccluderEffect)) {
    return nullptr;
  }
  // 1-inline bool OccluderEffect::has_on_occluder(NodePath const &occluder) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "OccluderEffect.has_on_occluder", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const OccluderEffect*)local_this).has_on_occluder)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_on_occluder(OccluderEffect self, const NodePath occluder)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OccluderEffect_has_on_occluder_1850_comment =
  "C++ Interface:\n"
  "has_on_occluder(OccluderEffect self, const NodePath occluder)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated occluder is enabled by the effect, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_OccluderEffect_has_on_occluder_1850_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool OccluderEffect::is_identity(void) const
 */
static PyObject *Dtool_OccluderEffect_is_identity_1851(PyObject *self, PyObject *) {
  OccluderEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OccluderEffect)) {
    return nullptr;
  }
  // 1-inline bool OccluderEffect::is_identity(void) const
  bool return_value = ((*(const OccluderEffect*)local_this).is_identity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OccluderEffect_is_identity_1851_comment =
  "C++ Interface:\n"
  "is_identity(OccluderEffect self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is an identity effect: it does not change the set of\n"
  " * occluders in use.\n"
  " */";
#else
static const char *Dtool_OccluderEffect_is_identity_1851_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffect > OccluderEffect::add_on_occluder(NodePath const &occluder) const
 */
static PyObject *Dtool_OccluderEffect_add_on_occluder_1852(PyObject *self, PyObject *arg) {
  OccluderEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OccluderEffect)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffect > OccluderEffect::add_on_occluder(NodePath const &occluder) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "OccluderEffect.add_on_occluder", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderEffect > return_value = ((*(const OccluderEffect*)local_this).add_on_occluder)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderEffect const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_on_occluder(OccluderEffect self, const NodePath occluder)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OccluderEffect_add_on_occluder_1852_comment =
  "C++ Interface:\n"
  "add_on_occluder(OccluderEffect self, const NodePath occluder)\n"
  "\n"
  "/**\n"
  " * Returns a new OccluderEffect, just like this one, but with the indicated\n"
  " * occluder added to the list of occluders enabled by this effect.\n"
  " */";
#else
static const char *Dtool_OccluderEffect_add_on_occluder_1852_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffect > OccluderEffect::remove_on_occluder(NodePath const &occluder) const
 */
static PyObject *Dtool_OccluderEffect_remove_on_occluder_1853(PyObject *self, PyObject *arg) {
  OccluderEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OccluderEffect)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffect > OccluderEffect::remove_on_occluder(NodePath const &occluder) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "OccluderEffect.remove_on_occluder", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderEffect > return_value = ((*(const OccluderEffect*)local_this).remove_on_occluder)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderEffect const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_on_occluder(OccluderEffect self, const NodePath occluder)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OccluderEffect_remove_on_occluder_1853_comment =
  "C++ Interface:\n"
  "remove_on_occluder(OccluderEffect self, const NodePath occluder)\n"
  "\n"
  "/**\n"
  " * Returns a new OccluderEffect, just like this one, but with the indicated\n"
  " * occluder removed from the list of occluders enabled by this effect.\n"
  " */";
#else
static const char *Dtool_OccluderEffect_remove_on_occluder_1853_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OccluderEffect::get_class_type(void)
 */
static PyObject *Dtool_OccluderEffect_get_class_type_1854(PyObject *, PyObject *) {
  // 1-static TypeHandle OccluderEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OccluderEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OccluderEffect_get_class_type_1854_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OccluderEffect_get_class_type_1854_comment = nullptr;
#endif

static int Dtool_Init_OccluderEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OccluderEffect_get_on_occluders(PyObject *self, PyObject *) {
  OccluderEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OccluderEffect, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_on_occluders)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OccluderEffect_get_on_occluder_1848(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OccluderEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OccluderEffect) {
    printf("OccluderEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OccluderEffect *local_this = (OccluderEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OccluderEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OccluderEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OccluderEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OccluderEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (OccluderEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OccluderEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (OccluderEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (OccluderEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PolylightNode
 */
/**
 * Python function wrapper for:
 * inline void PolylightNode::enable(void)
 */
static PyObject *Dtool_PolylightNode_enable_1860(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.enable")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::enable(void)
  ((*local_this).enable)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_enable_1860_comment =
  "C++ Interface:\n"
  "enable(const PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Enable this light\n"
  " */";
#else
static const char *Dtool_PolylightNode_enable_1860_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::disable(void)
 */
static PyObject *Dtool_PolylightNode_disable_1861(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.disable")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::disable(void)
  ((*local_this).disable)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_disable_1861_comment =
  "C++ Interface:\n"
  "disable(const PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Disable this light\n"
  " */";
#else
static const char *Dtool_PolylightNode_disable_1861_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::set_pos(LPoint3 const &position)
 * inline void PolylightNode::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_PolylightNode_set_pos_1862(PyObject *self, PyObject *args, PyObject *kwds) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_pos")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "position")) {
        // 1-inline void PolylightNode::set_pos(LPoint3 const &position)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "PolylightNode.set_pos", "LPoint3f");
        }
        ((*local_this).set_pos)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void PolylightNode::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_pos)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const PolylightNode self, const LPoint3f position)\n"
      "set_pos(const PolylightNode self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_pos_1862_comment =
  "C++ Interface:\n"
  "set_pos(const PolylightNode self, const LPoint3f position)\n"
  "set_pos(const PolylightNode self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Set this light's position\n"
  " */\n"
  "\n"
  "/**\n"
  " * Set this light's position\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_pos_1862_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 PolylightNode::get_pos(void) const
 */
static PyObject *Dtool_PolylightNode_get_pos_1863(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline LPoint3 PolylightNode::get_pos(void) const
  LPoint3 *return_value = new LPoint3(((*(const PolylightNode*)local_this).get_pos)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_pos_1863_comment =
  "C++ Interface:\n"
  "get_pos(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Returns position as a LPoint3\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_pos_1863_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::set_color(LColor const &color)
 * inline void PolylightNode::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b)
 */
static PyObject *Dtool_PolylightNode_set_color_1864(PyObject *self, PyObject *args, PyObject *kwds) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "color")) {
        // 1-inline void PolylightNode::set_color(LColor const &color)
        LVecBase4f arg_local;
        LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "PolylightNode.set_color", "LVecBase4f");
        }
        ((*local_this).set_color)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void PolylightNode::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"r", "g", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_color", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_color)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const PolylightNode self, const LVecBase4f color)\n"
      "set_color(const PolylightNode self, float r, float g, float b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_color_1864_comment =
  "C++ Interface:\n"
  "set_color(const PolylightNode self, const LVecBase4f color)\n"
  "set_color(const PolylightNode self, float r, float g, float b)\n"
  "\n"
  "/**\n"
  " * Set the light's color...\n"
  " */\n"
  "\n"
  "/**\n"
  " * Set the light's color... 3 floats between 0 and 1\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_color_1864_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor PolylightNode::get_color(void) const
 */
static PyObject *Dtool_PolylightNode_get_color_1865(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline LColor PolylightNode::get_color(void) const
  LColor *return_value = new LColor(((*(const PolylightNode*)local_this).get_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_color_1865_comment =
  "C++ Interface:\n"
  "get_color(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Returns the light's color as LColor\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_color_1865_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor PolylightNode::get_color_scenegraph(void) const
 */
static PyObject *Dtool_PolylightNode_get_color_scenegraph_1866(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline LColor PolylightNode::get_color_scenegraph(void) const
  LColor *return_value = new LColor(((*(const PolylightNode*)local_this).get_color_scenegraph)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_color_scenegraph_1866_comment =
  "C++ Interface:\n"
  "get_color_scenegraph(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * This differs from get_color in that when applying the light color we need\n"
  " * to make sure that a color flattening external to the PolylightNode is not\n"
  " * ignored.\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_color_scenegraph_1866_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::set_radius(PN_stdfloat r)
 */
static PyObject *Dtool_PolylightNode_set_radius_1867(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_radius")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::set_radius(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const PolylightNode self, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_radius_1867_comment =
  "C++ Interface:\n"
  "set_radius(const PolylightNode self, float r)\n"
  "\n"
  "/**\n"
  " * Set radius of the spherical light volume\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_radius_1867_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PolylightNode::get_radius(void) const
 */
static PyObject *Dtool_PolylightNode_get_radius_1868(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PolylightNode::get_radius(void) const
  PN_stdfloat return_value = ((*(const PolylightNode*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_radius_1868_comment =
  "C++ Interface:\n"
  "get_radius(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Get radius of the spherical light volume\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_radius_1868_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PolylightNode::set_attenuation(PolylightNode::Attenuation_Type type)
 */
static PyObject *Dtool_PolylightNode_set_attenuation_1869(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_attenuation")) {
    return nullptr;
  }
  // 1-inline bool PolylightNode::set_attenuation(PolylightNode::Attenuation_Type type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).set_attenuation)((PolylightNode::Attenuation_Type)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_attenuation(const PolylightNode self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_attenuation_1869_comment =
  "C++ Interface:\n"
  "set_attenuation(const PolylightNode self, int type)\n"
  "\n"
  "/**\n"
  " * Set ALINEAR or AQUADRATIC attenuation\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_attenuation_1869_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PolylightNode::Attenuation_Type PolylightNode::get_attenuation(void) const
 */
static PyObject *Dtool_PolylightNode_get_attenuation_1870(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline PolylightNode::Attenuation_Type PolylightNode::get_attenuation(void) const
  PolylightNode::Attenuation_Type return_value = ((*(const PolylightNode*)local_this).get_attenuation)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_attenuation_1870_comment =
  "C++ Interface:\n"
  "get_attenuation(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Get \"linear\" or \"quadratic\" attenuation type\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_attenuation_1870_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::set_a0(PN_stdfloat a0)
 */
static PyObject *Dtool_PolylightNode_set_a0_1871(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_a0")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::set_a0(PN_stdfloat a0)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_a0)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_a0(const PolylightNode self, float a0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_a0_1871_comment =
  "C++ Interface:\n"
  "set_a0(const PolylightNode self, float a0)\n"
  "\n"
  "/**\n"
  " * Set the quadratic attenuation factor a0 fd = 1 / ( a0 + a1*distance +\n"
  " * a2*distance*distance)\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_a0_1871_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::set_a1(PN_stdfloat a1)
 */
static PyObject *Dtool_PolylightNode_set_a1_1872(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_a1")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::set_a1(PN_stdfloat a1)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_a1)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_a1(const PolylightNode self, float a1)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_a1_1872_comment =
  "C++ Interface:\n"
  "set_a1(const PolylightNode self, float a1)\n"
  "\n"
  "/**\n"
  " * Set the quadratic attenuation factor a1 fd = 1 / ( a0 + a1*distance +\n"
  " * a2*distance*distance)\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_a1_1872_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::set_a2(PN_stdfloat a2)
 */
static PyObject *Dtool_PolylightNode_set_a2_1873(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_a2")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::set_a2(PN_stdfloat a2)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_a2)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_a2(const PolylightNode self, float a2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_a2_1873_comment =
  "C++ Interface:\n"
  "set_a2(const PolylightNode self, float a2)\n"
  "\n"
  "/**\n"
  " * Set the quadratic attenuation factor a2 fd = 1 / ( a0 + a1*distance +\n"
  " * a2*distance*distance)\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_a2_1873_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PolylightNode::get_a0(void) const
 */
static PyObject *Dtool_PolylightNode_get_a0_1874(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PolylightNode::get_a0(void) const
  PN_stdfloat return_value = ((*(const PolylightNode*)local_this).get_a0)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_a0_1874_comment =
  "C++ Interface:\n"
  "get_a0(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Get the quadratic attenuation factor a0 fd = 1 / ( a0 + a1*distance +\n"
  " * a2*distance*distance)\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_a0_1874_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PolylightNode::get_a1(void) const
 */
static PyObject *Dtool_PolylightNode_get_a1_1875(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PolylightNode::get_a1(void) const
  PN_stdfloat return_value = ((*(const PolylightNode*)local_this).get_a1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_a1_1875_comment =
  "C++ Interface:\n"
  "get_a1(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Get the quadratic attenuation factor a1 fd = 1 / ( a0 + a1*distance +\n"
  " * a2*distance*distance)\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_a1_1875_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PolylightNode::get_a2(void) const
 */
static PyObject *Dtool_PolylightNode_get_a2_1876(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PolylightNode::get_a2(void) const
  PN_stdfloat return_value = ((*(const PolylightNode*)local_this).get_a2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_a2_1876_comment =
  "C++ Interface:\n"
  "get_a2(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Get the quadratic attenuation factor a2 fd = 1 / ( a0 + a1*distance +\n"
  " * a2*distance*distance)\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_a2_1876_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::flicker_on(void)
 */
static PyObject *Dtool_PolylightNode_flicker_on_1877(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.flicker_on")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::flicker_on(void)
  ((*local_this).flicker_on)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_flicker_on_1877_comment =
  "C++ Interface:\n"
  "flicker_on(const PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Set flickering to true so at every loop this light's color is varied based\n"
  " * on flicker_type\n"
  " */";
#else
static const char *Dtool_PolylightNode_flicker_on_1877_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::flicker_off(void)
 */
static PyObject *Dtool_PolylightNode_flicker_off_1878(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.flicker_off")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::flicker_off(void)
  ((*local_this).flicker_off)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_flicker_off_1878_comment =
  "C++ Interface:\n"
  "flicker_off(const PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Turn flickering off\n"
  " */";
#else
static const char *Dtool_PolylightNode_flicker_off_1878_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PolylightNode::is_flickering(void) const
 */
static PyObject *Dtool_PolylightNode_is_flickering_1879(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline bool PolylightNode::is_flickering(void) const
  bool return_value = ((*(const PolylightNode*)local_this).is_flickering)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_is_flickering_1879_comment =
  "C++ Interface:\n"
  "is_flickering(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Check is this light is flickering\n"
  " */";
#else
static const char *Dtool_PolylightNode_is_flickering_1879_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PolylightNode::set_flicker_type(PolylightNode::Flicker_Type type)
 */
static PyObject *Dtool_PolylightNode_set_flicker_type_1880(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_flicker_type")) {
    return nullptr;
  }
  // 1-inline bool PolylightNode::set_flicker_type(PolylightNode::Flicker_Type type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).set_flicker_type)((PolylightNode::Flicker_Type)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flicker_type(const PolylightNode self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_flicker_type_1880_comment =
  "C++ Interface:\n"
  "set_flicker_type(const PolylightNode self, int type)\n"
  "\n"
  "/**\n"
  " * Flicker type can be FRANDOM or FSIN At a later point there might be a\n"
  " * FCUSTOM Custom flicker will be a set of fix points recorded by animating\n"
  " * the light's intensity\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_flicker_type_1880_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PolylightNode::Flicker_Type PolylightNode::get_flicker_type(void) const
 */
static PyObject *Dtool_PolylightNode_get_flicker_type_1881(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline PolylightNode::Flicker_Type PolylightNode::get_flicker_type(void) const
  PolylightNode::Flicker_Type return_value = ((*(const PolylightNode*)local_this).get_flicker_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_flicker_type_1881_comment =
  "C++ Interface:\n"
  "get_flicker_type(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Returns FRANDOM or FSIN\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_flicker_type_1881_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::set_offset(PN_stdfloat offset)
 */
static PyObject *Dtool_PolylightNode_set_offset_1882(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_offset")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::set_offset(PN_stdfloat offset)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_offset)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset(const PolylightNode self, float offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_offset_1882_comment =
  "C++ Interface:\n"
  "set_offset(const PolylightNode self, float offset)\n"
  "\n"
  "/**\n"
  " * Set the offset value for the random and sin flicker variations... used to\n"
  " * tweak the flicker This value is added to the variation\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_offset_1882_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PolylightNode::get_offset(void) const
 */
static PyObject *Dtool_PolylightNode_get_offset_1883(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PolylightNode::get_offset(void) const
  PN_stdfloat return_value = ((*(const PolylightNode*)local_this).get_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_offset_1883_comment =
  "C++ Interface:\n"
  "get_offset(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Get the offset value for the random and sin flicker variations\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_offset_1883_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::set_scale(PN_stdfloat scale)
 */
static PyObject *Dtool_PolylightNode_set_scale_1884(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_scale")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::set_scale(PN_stdfloat scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale(const PolylightNode self, float scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_scale_1884_comment =
  "C++ Interface:\n"
  "set_scale(const PolylightNode self, float scale)\n"
  "\n"
  "/**\n"
  " * Set the scale value for the random and sin flicker variations... used to\n"
  " * tweak the flicker This value is multiplied with the variation\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_scale_1884_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PolylightNode::get_scale(void) const
 */
static PyObject *Dtool_PolylightNode_get_scale_1885(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PolylightNode::get_scale(void) const
  PN_stdfloat return_value = ((*(const PolylightNode*)local_this).get_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_scale_1885_comment =
  "C++ Interface:\n"
  "get_scale(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Get the scale value for the random and sin flicker variations\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_scale_1885_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::set_step_size(PN_stdfloat step)
 */
static PyObject *Dtool_PolylightNode_set_step_size_1886(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_step_size")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::set_step_size(PN_stdfloat step)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_step_size)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_step_size(const PolylightNode self, float step)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_step_size_1886_comment =
  "C++ Interface:\n"
  "set_step_size(const PolylightNode self, float step)\n"
  "\n"
  "/**\n"
  " * Set the step size for the sin function in flicker This is the increment\n"
  " * size for the value supplied to the sin function\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_step_size_1886_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PolylightNode::get_step_size(void) const
 */
static PyObject *Dtool_PolylightNode_get_step_size_1887(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PolylightNode::get_step_size(void) const
  PN_stdfloat return_value = ((*(const PolylightNode*)local_this).get_step_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_step_size_1887_comment =
  "C++ Interface:\n"
  "get_step_size(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Get the step size for the sin function in flicker This is the increment\n"
  " * size for the value supplied to the sin function\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_step_size_1887_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PolylightNode::set_freq(PN_stdfloat f)
 */
static PyObject *Dtool_PolylightNode_set_freq_1888(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PolylightNode, (void **)&local_this, "PolylightNode.set_freq")) {
    return nullptr;
  }
  // 1-inline void PolylightNode::set_freq(PN_stdfloat f)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_freq)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_freq(const PolylightNode self, float f)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_set_freq_1888_comment =
  "C++ Interface:\n"
  "set_freq(const PolylightNode self, float f)\n"
  "\n"
  "/**\n"
  " * Set frequency of sin flicker\n"
  " */";
#else
static const char *Dtool_PolylightNode_set_freq_1888_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PolylightNode::get_freq(void) const
 */
static PyObject *Dtool_PolylightNode_get_freq_1889(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PolylightNode::get_freq(void) const
  PN_stdfloat return_value = ((*(const PolylightNode*)local_this).get_freq)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_freq_1889_comment =
  "C++ Interface:\n"
  "get_freq(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Get frequency of sin flicker\n"
  " */";
#else
static const char *Dtool_PolylightNode_get_freq_1889_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PolylightNode::compare_to(PolylightNode const &other) const
 */
static PyObject *Dtool_PolylightNode_compare_to_1893(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-int PolylightNode::compare_to(PolylightNode const &other) const
  PolylightNode const *arg_this = (PolylightNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PolylightNode, 1, "PolylightNode.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const PolylightNode*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(PolylightNode self, const PolylightNode other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_compare_to_1893_comment =
  "C++ Interface:\n"
  "compare_to(PolylightNode self, const PolylightNode other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this PolylightNode sorts before the\n"
  " * other one, greater than zero if it sorts after, or zero if they are\n"
  " * equivalent.\n"
  " *\n"
  " * Two PolylightNodes are considered equivalent if they consist of exactly the\n"
  " * same properties Otherwise, they are different; different PolylightNodes\n"
  " * will be ranked in a consistent but undefined ordering; the ordering is\n"
  " * useful only for placing the PolylightNodes in a sorted container like an\n"
  " * STL set.\n"
  " */";
#else
static const char *Dtool_PolylightNode_compare_to_1893_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PolylightNode::is_enabled(void) const
 */
static PyObject *Dtool_PolylightNode_is_enabled_1894(PyObject *self, PyObject *) {
  PolylightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightNode)) {
    return nullptr;
  }
  // 1-inline bool PolylightNode::is_enabled(void) const
  bool return_value = ((*(const PolylightNode*)local_this).is_enabled)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_is_enabled_1894_comment =
  "C++ Interface:\n"
  "is_enabled(PolylightNode self)\n"
  "\n"
  "/**\n"
  " * Is this light is enabled/disabled?\n"
  " */";
#else
static const char *Dtool_PolylightNode_is_enabled_1894_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PolylightNode::get_class_type(void)
 */
static PyObject *Dtool_PolylightNode_get_class_type_1895(PyObject *, PyObject *) {
  // 1-static TypeHandle PolylightNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PolylightNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PolylightNode_get_class_type_1895_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PolylightNode_get_class_type_1895_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PolylightNode::PolylightNode(PolylightNode const &) = default
 * explicit PolylightNode::PolylightNode(std::string const &name)
 */
static int Dtool_Init_PolylightNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PolylightNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline PolylightNode::PolylightNode(PolylightNode const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      PolylightNode const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PolylightNode);
      if (param0_this != nullptr) {
        PolylightNode *return_value = new PolylightNode(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PolylightNode, true, false);
      }
    }
  }

  {
    // -2 explicit PolylightNode::PolylightNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:PolylightNode", (char **)keyword_list, &param0_str, &param0_len)) {
      PolylightNode *return_value = new PolylightNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PolylightNode, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline PolylightNode::PolylightNode(PolylightNode const &) = default
  // No coercion possible: explicit PolylightNode::PolylightNode(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PolylightNode(const PolylightNode param0)\n"
      "PolylightNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PolylightNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PolylightNode) {
    printf("PolylightNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PolylightNode *local_this = (PolylightNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PolylightNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PolylightNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PolylightNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PolylightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PolylightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PolylightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PolylightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PolylightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PolylightNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PolylightEffect
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > PolylightEffect::make(void)
 * static ConstPointerTo< RenderEffect > PolylightEffect::make(PN_stdfloat weight, PolylightEffect::ContribType contrib, LPoint3 const &effect_center)
 * Rejected Remap [static ConstPointerTo< RenderEffect > PolylightEffect::make(PN_stdfloat weight, PolylightEffect::ContribType contrib, LPoint3 const &effect_center, PolylightEffect::LightGroup const &lights)]
 */
static PyObject *Dtool_PolylightEffect_make_1901(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-static ConstPointerTo< RenderEffect > PolylightEffect::make(void)
      ConstPointerTo< RenderEffect > return_value = (PolylightEffect::make)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderEffect const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 3:
    {
      // 1-static ConstPointerTo< RenderEffect > PolylightEffect::make(PN_stdfloat weight, PolylightEffect::ContribType contrib, LPoint3 const &effect_center)
      float param0;
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"weight", "contrib", "effect_center", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fiO:make", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "PolylightEffect.make", "LPoint3f");
        }
        ConstPointerTo< RenderEffect > return_value = (PolylightEffect::make)((PN_stdfloat)param0, (PolylightEffect::ContribType)param1, *param2_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderEffect const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 0 or 3 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make()\n"
      "make(float weight, int contrib, const LPoint3f effect_center)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightEffect_make_1901_comment =
  "C++ Interface:\n"
  "make()\n"
  "make(float weight, int contrib, const LPoint3f effect_center)\n"
  "\n"
  "/**\n"
  " * Constructs a new PolylightEffect object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new PolylightEffect object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new PolylightEffect object.\n"
  " */";
#else
static const char *Dtool_PolylightEffect_make_1901_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffect > PolylightEffect::add_light(NodePath const &newlight) const
 */
static PyObject *Dtool_PolylightEffect_add_light_1902(PyObject *self, PyObject *arg) {
  PolylightEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightEffect)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffect > PolylightEffect::add_light(NodePath const &newlight) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PolylightEffect.add_light", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderEffect > return_value = ((*(const PolylightEffect*)local_this).add_light)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderEffect const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_light(PolylightEffect self, const NodePath newlight)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightEffect_add_light_1902_comment =
  "C++ Interface:\n"
  "add_light(PolylightEffect self, const NodePath newlight)\n"
  "\n"
  "/**\n"
  " * Add a PolylightNode object to this effect and return a new effect\n"
  " */";
#else
static const char *Dtool_PolylightEffect_add_light_1902_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffect > PolylightEffect::remove_light(NodePath const &newlight) const
 */
static PyObject *Dtool_PolylightEffect_remove_light_1903(PyObject *self, PyObject *arg) {
  PolylightEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightEffect)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffect > PolylightEffect::remove_light(NodePath const &newlight) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PolylightEffect.remove_light", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderEffect > return_value = ((*(const PolylightEffect*)local_this).remove_light)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderEffect const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_light(PolylightEffect self, const NodePath newlight)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightEffect_remove_light_1903_comment =
  "C++ Interface:\n"
  "remove_light(PolylightEffect self, const NodePath newlight)\n"
  "\n"
  "/**\n"
  " * Remove a light from this effect.  Return the new updated effect\n"
  " */";
#else
static const char *Dtool_PolylightEffect_remove_light_1903_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffect > PolylightEffect::set_weight(PN_stdfloat w) const
 */
static PyObject *Dtool_PolylightEffect_set_weight_1904(PyObject *self, PyObject *arg) {
  PolylightEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightEffect)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffect > PolylightEffect::set_weight(PN_stdfloat w) const
  if (PyNumber_Check(arg)) {
    ConstPointerTo< RenderEffect > return_value = ((*(const PolylightEffect*)local_this).set_weight)((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderEffect const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_weight(PolylightEffect self, float w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightEffect_set_weight_1904_comment =
  "C++ Interface:\n"
  "set_weight(PolylightEffect self, float w)\n"
  "\n"
  "/**\n"
  " * Set weight and return a new effect... the reason this couldnt be done\n"
  " * through make was because that would return a new effect without the\n"
  " * lightgroup which is static and cant be accessed Here, we just pass that to\n"
  " * the make\n"
  " */";
#else
static const char *Dtool_PolylightEffect_set_weight_1904_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffect > PolylightEffect::set_contrib(PolylightEffect::ContribType c) const
 */
static PyObject *Dtool_PolylightEffect_set_contrib_1905(PyObject *self, PyObject *arg) {
  PolylightEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightEffect)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffect > PolylightEffect::set_contrib(PolylightEffect::ContribType c) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< RenderEffect > return_value = ((*(const PolylightEffect*)local_this).set_contrib)((PolylightEffect::ContribType)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderEffect const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contrib(PolylightEffect self, int c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightEffect_set_contrib_1905_comment =
  "C++ Interface:\n"
  "set_contrib(PolylightEffect self, int c)\n"
  "\n"
  "/**\n"
  " * Set Contrib Type and return a new effect... the reason this couldnt be done\n"
  " * through make was because that would return a new effect without the\n"
  " * lightgroup which is static and cant be accessed Here, we just pass that to\n"
  " * the make\n"
  " */";
#else
static const char *Dtool_PolylightEffect_set_contrib_1905_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffect > PolylightEffect::set_effect_center(LPoint3 const &ec) const
 */
static PyObject *Dtool_PolylightEffect_set_effect_center_1906(PyObject *self, PyObject *arg) {
  PolylightEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightEffect)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffect > PolylightEffect::set_effect_center(LPoint3 const &ec) const
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PolylightEffect.set_effect_center", "LPoint3f");
  }
  ConstPointerTo< RenderEffect > return_value = ((*(const PolylightEffect*)local_this).set_effect_center)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffect const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_effect_center(PolylightEffect self, const LPoint3f ec)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightEffect_set_effect_center_1906_comment =
  "C++ Interface:\n"
  "set_effect_center(PolylightEffect self, const LPoint3f ec)\n"
  "\n"
  "/**\n"
  " * Set weight and return a new effect... the reason this couldnt be done\n"
  " * through make was because that would return a new effect without the\n"
  " * lightgroup which is static and cant be accessed Here, we just pass that to\n"
  " * the make\n"
  " */";
#else
static const char *Dtool_PolylightEffect_set_effect_center_1906_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PolylightEffect::get_weight(void) const
 */
static PyObject *Dtool_PolylightEffect_get_weight_1907(PyObject *self, PyObject *) {
  PolylightEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightEffect)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PolylightEffect::get_weight(void) const
  PN_stdfloat return_value = ((*(const PolylightEffect*)local_this).get_weight)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightEffect_get_weight_1907_comment =
  "C++ Interface:\n"
  "get_weight(PolylightEffect self)\n"
  "\n"
  "/**\n"
  " * Get the weight value\n"
  " */";
#else
static const char *Dtool_PolylightEffect_get_weight_1907_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PolylightEffect::ContribType PolylightEffect::get_contrib(void) const
 */
static PyObject *Dtool_PolylightEffect_get_contrib_1908(PyObject *self, PyObject *) {
  PolylightEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightEffect)) {
    return nullptr;
  }
  // 1-inline PolylightEffect::ContribType PolylightEffect::get_contrib(void) const
  PolylightEffect::ContribType return_value = ((*(const PolylightEffect*)local_this).get_contrib)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PolylightEffect_get_contrib_1908_comment =
  "C++ Interface:\n"
  "get_contrib(PolylightEffect self)\n"
  "\n"
  "/**\n"
  " * Returns CT_all or CT_proximal\n"
  " */";
#else
static const char *Dtool_PolylightEffect_get_contrib_1908_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 PolylightEffect::get_effect_center(void) const
 */
static PyObject *Dtool_PolylightEffect_get_effect_center_1909(PyObject *self, PyObject *) {
  PolylightEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightEffect)) {
    return nullptr;
  }
  // 1-inline LPoint3 PolylightEffect::get_effect_center(void) const
  LPoint3 *return_value = new LPoint3(((*(const PolylightEffect*)local_this).get_effect_center)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PolylightEffect_get_effect_center_1909_comment =
  "C++ Interface:\n"
  "get_effect_center(PolylightEffect self)\n"
  "\n"
  "/**\n"
  " * Return the value of the _effect_center\n"
  " */";
#else
static const char *Dtool_PolylightEffect_get_effect_center_1909_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PolylightEffect::has_light(NodePath const &light) const
 */
static PyObject *Dtool_PolylightEffect_has_light_1910(PyObject *self, PyObject *arg) {
  PolylightEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PolylightEffect)) {
    return nullptr;
  }
  // 1-bool PolylightEffect::has_light(NodePath const &light) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PolylightEffect.has_light", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PolylightEffect*)local_this).has_light)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_light(PolylightEffect self, const NodePath light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PolylightEffect_has_light_1910_comment =
  "C++ Interface:\n"
  "has_light(PolylightEffect self, const NodePath light)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated light is listed in the PolylightEffect, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PolylightEffect_has_light_1910_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PolylightEffect::get_class_type(void)
 */
static PyObject *Dtool_PolylightEffect_get_class_type_1911(PyObject *, PyObject *) {
  // 1-static TypeHandle PolylightEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PolylightEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PolylightEffect_get_class_type_1911_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PolylightEffect_get_class_type_1911_comment = nullptr;
#endif

static int Dtool_Init_PolylightEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_PolylightEffect(PyObject *args, CPT(PolylightEffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PolylightEffect)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-static ConstPointerTo< RenderEffect > PolylightEffect::make(PN_stdfloat weight, PolylightEffect::ContribType contrib, LPoint3 const &effect_center)
      float param0;
      int param1;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "fiO:make", &param0, &param1, &param2)) {
        LPoint3 const *param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LPoint3f);
        if (param2_this != nullptr) {
          ConstPointerTo< RenderEffect > return_value = (PolylightEffect::make)((PN_stdfloat)param0, (PolylightEffect::ContribType)param1, *param2_this);
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move((PolylightEffect const *) return_value.p());
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PolylightEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PolylightEffect) {
    printf("PolylightEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PolylightEffect *local_this = (PolylightEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PolylightEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PolylightEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PolylightEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PolylightEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (PolylightEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PolylightEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PolylightEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PolylightEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShaderAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ShaderAttrib::make(Shader const *shader = nullptr, int priority = 0)
 */
static PyObject *Dtool_ShaderAttrib_make_1914(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > ShaderAttrib::make(Shader const *shader = nullptr, int priority = 0)
  PyObject *param0 = nullptr;
  int param1 = 0;
  static const char *keyword_list[] = {"shader", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|Oi:make", (char **)keyword_list, &param0, &param1)) {
    CPT(Shader) param0_this;
    if (param0 != nullptr && param0 != Py_None && !Dtool_ConstCoerce_Shader(param0, param0_this)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "ShaderAttrib.make", "Shader");
    }
    ConstPointerTo< RenderAttrib > return_value = (ShaderAttrib::make)(std::move(param0_this), (int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const Shader shader, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_make_1914_comment =
  "C++ Interface:\n"
  "make(const Shader shader, int priority)\n"
  "\n"
  "/**\n"
  " * Constructs a new ShaderAttrib object with nothing set.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_make_1914_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ShaderAttrib::make_off(void)
 */
static PyObject *Dtool_ShaderAttrib_make_off_1915(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ShaderAttrib::make_off(void)
  ConstPointerTo< RenderAttrib > return_value = (ShaderAttrib::make_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_make_off_1915_comment =
  "C++ Interface:\n"
  "make_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new ShaderAttrib object that disables the use of shaders (it\n"
  " * does not clear out all shader data, however.)\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_make_off_1915_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ShaderAttrib::make_default(void)
 */
static PyObject *Dtool_ShaderAttrib_make_default_1916(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ShaderAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (ShaderAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_make_default_1916_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_make_default_1916_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ShaderAttrib::has_shader(void) const
 */
static PyObject *Dtool_ShaderAttrib_has_shader_1918(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-inline bool ShaderAttrib::has_shader(void) const
  bool return_value = ((*(const ShaderAttrib*)local_this).has_shader)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_has_shader_1918_comment =
  "C++ Interface:\n"
  "has_shader(ShaderAttrib self)\n"
  "\n"
  "/**\n"
  " * If true, the shader field of this attribute overrides the shader field of\n"
  " * the parent attribute.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_has_shader_1918_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ShaderAttrib::auto_shader(void) const
 */
static PyObject *Dtool_ShaderAttrib_auto_shader_1919(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-inline bool ShaderAttrib::auto_shader(void) const
  bool return_value = ((*(const ShaderAttrib*)local_this).auto_shader)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_auto_shader_1919_comment =
  "C++ Interface:\n"
  "auto_shader(ShaderAttrib self)\n"
  "\n"
  "/**\n"
  " * If true, then this ShaderAttrib does not contain an explicit shader -\n"
  " * instead, it requests the automatic generation of a shader.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_auto_shader_1919_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ShaderAttrib::get_shader_priority(void) const
 */
static PyObject *Dtool_ShaderAttrib_get_shader_priority_1920(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-inline int ShaderAttrib::get_shader_priority(void) const
  int return_value = ((*(const ShaderAttrib*)local_this).get_shader_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_shader_priority_1920_comment =
  "C++ Interface:\n"
  "get_shader_priority(ShaderAttrib self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_get_shader_priority_1920_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ShaderAttrib::get_instance_count(void) const
 */
static PyObject *Dtool_ShaderAttrib_get_instance_count_1921(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-inline int ShaderAttrib::get_instance_count(void) const
  int return_value = ((*(const ShaderAttrib*)local_this).get_instance_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_instance_count_1921_comment =
  "C++ Interface:\n"
  "get_instance_count(ShaderAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the number of geometry instances.  A value of 0 means not to use\n"
  " * instancing at all.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_get_instance_count_1921_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ShaderAttrib::auto_normal_on(void) const
 */
static PyObject *Dtool_ShaderAttrib_auto_normal_on_1922(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-inline bool ShaderAttrib::auto_normal_on(void) const
  bool return_value = ((*(const ShaderAttrib*)local_this).auto_normal_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_auto_normal_on_1922_comment =
  "C++ Interface:\n"
  "auto_normal_on(ShaderAttrib self)\n";
#else
static const char *Dtool_ShaderAttrib_auto_normal_on_1922_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ShaderAttrib::auto_glow_on(void) const
 */
static PyObject *Dtool_ShaderAttrib_auto_glow_on_1923(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-inline bool ShaderAttrib::auto_glow_on(void) const
  bool return_value = ((*(const ShaderAttrib*)local_this).auto_glow_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_auto_glow_on_1923_comment =
  "C++ Interface:\n"
  "auto_glow_on(ShaderAttrib self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_auto_glow_on_1923_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ShaderAttrib::auto_gloss_on(void) const
 */
static PyObject *Dtool_ShaderAttrib_auto_gloss_on_1924(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-inline bool ShaderAttrib::auto_gloss_on(void) const
  bool return_value = ((*(const ShaderAttrib*)local_this).auto_gloss_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_auto_gloss_on_1924_comment =
  "C++ Interface:\n"
  "auto_gloss_on(ShaderAttrib self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_auto_gloss_on_1924_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ShaderAttrib::auto_ramp_on(void) const
 */
static PyObject *Dtool_ShaderAttrib_auto_ramp_on_1925(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-inline bool ShaderAttrib::auto_ramp_on(void) const
  bool return_value = ((*(const ShaderAttrib*)local_this).auto_ramp_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_auto_ramp_on_1925_comment =
  "C++ Interface:\n"
  "auto_ramp_on(ShaderAttrib self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_auto_ramp_on_1925_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ShaderAttrib::auto_shadow_on(void) const
 */
static PyObject *Dtool_ShaderAttrib_auto_shadow_on_1926(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-inline bool ShaderAttrib::auto_shadow_on(void) const
  bool return_value = ((*(const ShaderAttrib*)local_this).auto_shadow_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_auto_shadow_on_1926_comment =
  "C++ Interface:\n"
  "auto_shadow_on(ShaderAttrib self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_auto_shadow_on_1926_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader(Shader const *s, int priority = 0) const
 */
static PyObject *Dtool_ShaderAttrib_set_shader_1927(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader(Shader const *s, int priority = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"s", "priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_shader", (char **)keyword_list, &param1, &param2)) {
    CPT(Shader) param1_this;
    if (!Dtool_ConstCoerce_Shader(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ShaderAttrib.set_shader", "Shader");
    }
    ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).set_shader)(std::move(param1_this), (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader(ShaderAttrib self, const Shader s, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_set_shader_1927_comment =
  "C++ Interface:\n"
  "set_shader(ShaderAttrib self, const Shader s, int priority)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_set_shader_1927_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_off(int priority = 0) const
 */
static PyObject *Dtool_ShaderAttrib_set_shader_off_1928(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_off(int priority = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"priority", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:set_shader_off", (char **)keyword_list, &param1)) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).set_shader_off)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader_off(ShaderAttrib self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_set_shader_off_1928_comment =
  "C++ Interface:\n"
  "set_shader_off(ShaderAttrib self, int priority)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_set_shader_off_1928_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_auto(BitMask32 shader_switch, int priority = 0) const
 * ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_auto(int priority = 0) const
 */
static PyObject *Dtool_ShaderAttrib_set_shader_auto_1929(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_auto(int priority) const
      ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).set_shader_auto)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_auto(BitMask32 shader_switch, int priority = 0) const
        PyObject *param1;
        int param2 = 0;
        static const char *keyword_list[] = {"shader_switch", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_shader_auto", (char **)keyword_list, &param1, &param2)) {
          BitMask32 *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_BitMask_uint32_t_32);
          if (param1_this != nullptr) {
            ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).set_shader_auto)(*param1_this, (int)param2);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderAttrib const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_auto(int priority = 0) const
        int param1;
        static const char *keyword_list[] = {"priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:set_shader_auto", (char **)keyword_list, &param1)) {
          ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).set_shader_auto)((int)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
        PyErr_Clear();
      }

      {
        // -2 ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_auto(BitMask32 shader_switch, int priority = 0) const
        PyObject *param1;
        int param2 = 0;
        static const char *keyword_list[] = {"shader_switch", "priority", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_shader_auto", (char **)keyword_list, &param1, &param2)) {
          BitMask< uint32_t, 32 > param1_local;
          BitMask32 *param1_this = Dtool_Coerce_BitMask_uint32_t_32(param1, param1_local);
          if ((param1_this != nullptr)) {
            ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).set_shader_auto)(*param1_this, (int)param2);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            RenderAttrib const *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            if (return_ptr == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_auto(int priority = 0) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shader_auto() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader_auto(ShaderAttrib self)\n"
      "set_shader_auto(ShaderAttrib self, BitMask shader_switch, int priority)\n"
      "set_shader_auto(ShaderAttrib self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_set_shader_auto_1929_comment =
  "C++ Interface:\n"
  "set_shader_auto(ShaderAttrib self)\n"
  "set_shader_auto(ShaderAttrib self, BitMask shader_switch, int priority)\n"
  "set_shader_auto(ShaderAttrib self, int priority)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " * Set auto shader with bitmask to customize use, e.g., to keep normal, glow,\n"
  " * etc., on or off\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_set_shader_auto_1929_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ShaderAttrib::clear_shader(void) const
 */
static PyObject *Dtool_ShaderAttrib_clear_shader_1930(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ShaderAttrib::clear_shader(void) const
  ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).clear_shader)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_clear_shader_1930_comment =
  "C++ Interface:\n"
  "clear_shader(ShaderAttrib self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_clear_shader_1930_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_input(CPT_InternalName , PyObject *, int priority = 0) const
 * Rejected Remap [ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_input(ShaderInput &&input) const]
 * ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_input(ShaderInput const &input) const
 */
static PyObject *Dtool_ShaderAttrib_set_shader_input_1931(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "input")) {
        // 1-ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_input(ShaderInput const &input) const
        ShaderInput const *arg_this = (ShaderInput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShaderInput, 1, "ShaderAttrib.set_shader_input", true, true);
        if (arg_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).set_shader_input)(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderAttrib const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 2:
  case 3:
    {
      // 1-ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_input(CPT_InternalName , PyObject *, int priority = 0) const
      PyObject *param1;
      PyObject *param2;
      int param3 = 0;
      static const char *keyword_list[] = {"param0", "param1", "priority", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:set_shader_input", (char **)keyword_list, &param1, &param2, &param3)) {
        CPT(InternalName) param1_this;
        if (!Dtool_ConstCoerce_InternalName(param1, param1_this)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ShaderAttrib.set_shader_input", "InternalName");
        }
        ConstPointerTo< RenderAttrib > return_value = invoke_extension((const ShaderAttrib*)local_this).set_shader_input(std::move(param1_this), param2, (int)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderAttrib const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shader_input() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader_input(ShaderAttrib self, const ShaderInput input)\n"
      "set_shader_input(ShaderAttrib self, const InternalName param0, object param1, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_set_shader_input_1931_comment =
  "C++ Interface:\n"
  "set_shader_input(ShaderAttrib self, const ShaderInput input)\n"
  "set_shader_input(ShaderAttrib self, const InternalName param0, object param1, int priority)\n"
  "\n"
  "// Shader Inputs\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_set_shader_input_1931_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ShaderAttrib::set_shader_inputs(PyObject *args, PyObject *kwargs) const
 */
static PyObject *Dtool_ShaderAttrib_set_shader_inputs_1932(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  ConstPointerTo< RenderAttrib > return_value = invoke_extension((const ShaderAttrib*)local_this).set_shader_inputs(args, kwds);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_set_shader_inputs_1932_comment =
  "/**\n"
  " * Returns a new ShaderAttrib with the given shader inputs set.  This is a\n"
  " * more efficient way to set multiple shader inputs than calling\n"
  " * set_shader_input multiple times.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_set_shader_inputs_1932_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ShaderAttrib::set_instance_count(int instance_count) const
 */
static PyObject *Dtool_ShaderAttrib_set_instance_count_1933(PyObject *self, PyObject *arg) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ShaderAttrib::set_instance_count(int instance_count) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).set_instance_count)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_instance_count(ShaderAttrib self, int instance_count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_set_instance_count_1933_comment =
  "C++ Interface:\n"
  "set_instance_count(ShaderAttrib self, int instance_count)\n"
  "\n"
  "/**\n"
  " * Sets the geometry instance count.  Do not confuse this with instanceTo,\n"
  " * which is used for animation instancing, and has nothing to do with this.  A\n"
  " * value of 0 means not to use instancing at all.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_set_instance_count_1933_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ShaderAttrib::set_flag(int flag, bool value) const
 */
static PyObject *Dtool_ShaderAttrib_set_flag_1934(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ShaderAttrib::set_flag(int flag, bool value) const
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"flag", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_flag", (char **)keyword_list, &param1, &param2)) {
    ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).set_flag)((int)param1, (PyObject_IsTrue(param2) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flag(ShaderAttrib self, int flag, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_set_flag_1934_comment =
  "C++ Interface:\n"
  "set_flag(ShaderAttrib self, int flag, bool value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_set_flag_1934_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ShaderAttrib::clear_flag(int flag) const
 */
static PyObject *Dtool_ShaderAttrib_clear_flag_1935(PyObject *self, PyObject *arg) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ShaderAttrib::clear_flag(int flag) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).clear_flag)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_flag(ShaderAttrib self, int flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_clear_flag_1935_comment =
  "C++ Interface:\n"
  "clear_flag(ShaderAttrib self, int flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_clear_flag_1935_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ShaderAttrib::clear_shader_input(InternalName const *id) const
 * ConstPointerTo< RenderAttrib > ShaderAttrib::clear_shader_input(std::string const &id) const
 */
static PyObject *Dtool_ShaderAttrib_clear_shader_input_1936(PyObject *self, PyObject *arg) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  {
    // -2 ConstPointerTo< RenderAttrib > ShaderAttrib::clear_shader_input(InternalName const *id) const
    InternalName const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_InternalName);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).clear_shader_input)(arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 ConstPointerTo< RenderAttrib > ShaderAttrib::clear_shader_input(std::string const &id) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).clear_shader_input)(std::string(param1_str, param1_len));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerTo< RenderAttrib > ShaderAttrib::clear_shader_input(InternalName const *id) const
    CPT(InternalName) arg_this;
    if (Dtool_ConstCoerce_InternalName(arg, arg_this)) {
      ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).clear_shader_input)(std::move(arg_this));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }

  // No coercion possible: ConstPointerTo< RenderAttrib > ShaderAttrib::clear_shader_input(std::string const &id) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_shader_input(ShaderAttrib self, const InternalName id)\n"
      "clear_shader_input(ShaderAttrib self, str id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_clear_shader_input_1936_comment =
  "C++ Interface:\n"
  "clear_shader_input(ShaderAttrib self, const InternalName id)\n"
  "clear_shader_input(ShaderAttrib self, str id)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_clear_shader_input_1936_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderAttrib > ShaderAttrib::clear_all_shader_inputs(void) const
 */
static PyObject *Dtool_ShaderAttrib_clear_all_shader_inputs_1937(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderAttrib > ShaderAttrib::clear_all_shader_inputs(void) const
  ConstPointerTo< RenderAttrib > return_value = ((*(const ShaderAttrib*)local_this).clear_all_shader_inputs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_clear_all_shader_inputs_1937_comment =
  "C++ Interface:\n"
  "clear_all_shader_inputs(ShaderAttrib self)\n"
  "\n"
  "/**\n"
  " * Clears all the shader inputs on the attrib.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_clear_all_shader_inputs_1937_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ShaderAttrib::get_flag(int flag) const
 */
static PyObject *Dtool_ShaderAttrib_get_flag_1938(PyObject *self, PyObject *arg) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-inline bool ShaderAttrib::get_flag(int flag) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const ShaderAttrib*)local_this).get_flag)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_flag(ShaderAttrib self, int flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_flag_1938_comment =
  "C++ Interface:\n"
  "get_flag(ShaderAttrib self, int flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_get_flag_1938_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ShaderAttrib::has_shader_input(CPT_InternalName id) const
 */
static PyObject *Dtool_ShaderAttrib_has_shader_input_1939(PyObject *self, PyObject *arg) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-inline bool ShaderAttrib::has_shader_input(CPT_InternalName id) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ShaderAttrib.has_shader_input", "InternalName");
  }
  bool return_value = ((*(const ShaderAttrib*)local_this).has_shader_input)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_shader_input(ShaderAttrib self, const InternalName id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_has_shader_input_1939_comment =
  "C++ Interface:\n"
  "has_shader_input(ShaderAttrib self, const InternalName id)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a ShaderInput of the given name.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_has_shader_input_1939_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Shader const *ShaderAttrib::get_shader(void) const
 */
static PyObject *Dtool_ShaderAttrib_get_shader_1940(PyObject *self, PyObject *) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-Shader const *ShaderAttrib::get_shader(void) const
  Shader const *return_value = ((*(const ShaderAttrib*)local_this).get_shader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Shader, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_shader_1940_comment =
  "C++ Interface:\n"
  "get_shader(ShaderAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the shader object associated with the node.  If get_override\n"
  " * returns true, but get_shader returns NULL, that means that this attribute\n"
  " * should disable the shader.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_get_shader_1940_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ShaderInput const &ShaderAttrib::get_shader_input(InternalName const *id) const
 * ShaderInput const &ShaderAttrib::get_shader_input(std::string const &id) const
 */
static PyObject *Dtool_ShaderAttrib_get_shader_input_1941(PyObject *self, PyObject *arg) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  {
    // -2 ShaderInput const &ShaderAttrib::get_shader_input(InternalName const *id) const
    InternalName const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_InternalName);
    if (arg_this != nullptr) {
      ShaderInput const *return_value = &(((*(const ShaderAttrib*)local_this).get_shader_input)(arg_this));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ShaderInput, false, true);
    }
  }

  {
    // -2 ShaderInput const &ShaderAttrib::get_shader_input(std::string const &id) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ShaderInput const *return_value = &(((*(const ShaderAttrib*)local_this).get_shader_input)(std::string(param1_str, param1_len)));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ShaderInput, false, true);
    }
    PyErr_Clear();
  }

  {
    // -2 ShaderInput const &ShaderAttrib::get_shader_input(InternalName const *id) const
    CPT(InternalName) arg_this;
    if (Dtool_ConstCoerce_InternalName(arg, arg_this)) {
      ShaderInput const *return_value = &(((*(const ShaderAttrib*)local_this).get_shader_input)(std::move(arg_this)));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ShaderInput, false, true);
    }
  }

  // No coercion possible: ShaderInput const &ShaderAttrib::get_shader_input(std::string const &id) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shader_input(ShaderAttrib self, const InternalName id)\n"
      "get_shader_input(ShaderAttrib self, str id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_shader_input_1941_comment =
  "C++ Interface:\n"
  "get_shader_input(ShaderAttrib self, const InternalName id)\n"
  "get_shader_input(ShaderAttrib self, str id)\n"
  "\n"
  "/**\n"
  " * Returns the ShaderInput of the given name.  If no such name is found, this\n"
  " * function does not return NULL --- it returns the \"blank\" ShaderInput.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the ShaderInput of the given name.  If no such name is found, this\n"
  " * function does not return NULL --- it returns the \"blank\" ShaderInput.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_get_shader_input_1941_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath ShaderAttrib::get_shader_input_nodepath(InternalName const *id) const
 */
static PyObject *Dtool_ShaderAttrib_get_shader_input_nodepath_1942(PyObject *self, PyObject *arg) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-NodePath ShaderAttrib::get_shader_input_nodepath(InternalName const *id) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ShaderAttrib.get_shader_input_nodepath", "InternalName");
  }
  NodePath *return_value = new NodePath(((*(const ShaderAttrib*)local_this).get_shader_input_nodepath)(std::move(arg_this)));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shader_input_nodepath(ShaderAttrib self, const InternalName id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_shader_input_nodepath_1942_comment =
  "C++ Interface:\n"
  "get_shader_input_nodepath(ShaderAttrib self, const InternalName id)\n"
  "\n"
  "/**\n"
  " * Returns the ShaderInput as a nodepath.  Assertion fails if there is none,\n"
  " * or if it is not a nodepath.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_get_shader_input_nodepath_1942_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase4 ShaderAttrib::get_shader_input_vector(InternalName *id) const
 */
static PyObject *Dtool_ShaderAttrib_get_shader_input_vector_1943(PyObject *self, PyObject *arg) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-LVecBase4 ShaderAttrib::get_shader_input_vector(InternalName *id) const
  PT(InternalName) arg_this;
  if (!Dtool_Coerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ShaderAttrib.get_shader_input_vector", "InternalName");
  }
  LVecBase4 *return_value = new LVecBase4(((*(const ShaderAttrib*)local_this).get_shader_input_vector)(std::move(arg_this)));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shader_input_vector(ShaderAttrib self, InternalName id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_shader_input_vector_1943_comment =
  "C++ Interface:\n"
  "get_shader_input_vector(ShaderAttrib self, InternalName id)\n"
  "\n"
  "/**\n"
  " * Returns the ShaderInput as a vector.  Assertion fails if there is none, or\n"
  " * if it is not a vector.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_get_shader_input_vector_1943_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *ShaderAttrib::get_shader_input_texture(InternalName const *id, SamplerState *sampler = nullptr) const
 */
static PyObject *Dtool_ShaderAttrib_get_shader_input_texture_1944(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-Texture *ShaderAttrib::get_shader_input_texture(InternalName const *id, SamplerState *sampler = nullptr) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"id", "sampler", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:get_shader_input_texture", (char **)keyword_list, &param1, &param2)) {
    CPT(InternalName) param1_this;
    if (!Dtool_ConstCoerce_InternalName(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ShaderAttrib.get_shader_input_texture", "InternalName");
    }
    SamplerState *param2_this = nullptr;
    if (param2 != nullptr && param2 != Py_None) {
      param2_this = (SamplerState *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_SamplerState, 2, "ShaderAttrib.get_shader_input_texture", false, true);
    }
    if ((param2 == nullptr || param2 == Py_None || param2_this != nullptr)) {
      Texture *return_value = ((*(const ShaderAttrib*)local_this).get_shader_input_texture)(std::move(param1_this), param2_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shader_input_texture(ShaderAttrib self, const InternalName id, SamplerState sampler)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_shader_input_texture_1944_comment =
  "C++ Interface:\n"
  "get_shader_input_texture(ShaderAttrib self, const InternalName id, SamplerState sampler)\n"
  "\n"
  "/**\n"
  " * Returns the ShaderInput as a texture.  Assertion fails if there is none, or\n"
  " * if it is not a texture.\n"
  " *\n"
  " * If sampler is not NULL, the sampler state to use for this texture is\n"
  " * assigned to it.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_get_shader_input_texture_1944_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LMatrix4 const &ShaderAttrib::get_shader_input_matrix(InternalName const *id, LMatrix4 &matrix) const
 */
static PyObject *Dtool_ShaderAttrib_get_shader_input_matrix_1946(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-LMatrix4 const &ShaderAttrib::get_shader_input_matrix(InternalName const *id, LMatrix4 &matrix) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"id", "matrix", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_shader_input_matrix", (char **)keyword_list, &param1, &param2)) {
    CPT(InternalName) param1_this;
    if (!Dtool_ConstCoerce_InternalName(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ShaderAttrib.get_shader_input_matrix", "InternalName");
    }
    LMatrix4f param2_local;
    LMatrix4 *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ShaderAttrib.get_shader_input_matrix", "LMatrix4f");
    }
    LMatrix4 const *return_value = &(((*(const ShaderAttrib*)local_this).get_shader_input_matrix)(std::move(param1_this), *param2_this));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shader_input_matrix(ShaderAttrib self, const InternalName id, LMatrix4f matrix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_shader_input_matrix_1946_comment =
  "C++ Interface:\n"
  "get_shader_input_matrix(ShaderAttrib self, const InternalName id, LMatrix4f matrix)\n"
  "\n"
  "/**\n"
  " * Returns the ShaderInput as a matrix.  Assertion fails if there is none, or\n"
  " * if it is not a matrix or NodePath.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_get_shader_input_matrix_1946_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ShaderBuffer *ShaderAttrib::get_shader_input_buffer(InternalName const *id) const
 */
static PyObject *Dtool_ShaderAttrib_get_shader_input_buffer_1947(PyObject *self, PyObject *arg) {
  ShaderAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderAttrib)) {
    return nullptr;
  }
  // 1-ShaderBuffer *ShaderAttrib::get_shader_input_buffer(InternalName const *id) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ShaderAttrib.get_shader_input_buffer", "InternalName");
  }
  ShaderBuffer *return_value = ((*(const ShaderAttrib*)local_this).get_shader_input_buffer)(std::move(arg_this));
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ShaderBuffer, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shader_input_buffer(ShaderAttrib self, const InternalName id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_shader_input_buffer_1947_comment =
  "C++ Interface:\n"
  "get_shader_input_buffer(ShaderAttrib self, const InternalName id)\n"
  "\n"
  "/**\n"
  " * Returns the ShaderInput as a ShaderBuffer.  Assertion fails if there is\n"
  " * none, or if it is not a ShaderBuffer.\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_get_shader_input_buffer_1947_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void ShaderAttrib::register_with_read_factory(void)
 */
static PyObject *Dtool_ShaderAttrib_register_with_read_factory_1948(PyObject *, PyObject *) {
  // 1-static void ShaderAttrib::register_with_read_factory(void)
  (ShaderAttrib::register_with_read_factory)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_register_with_read_factory_1948_comment =
  "C++ Interface:\n"
  "register_with_read_factory()\n"
  "\n"
  "/**\n"
  " * Factory method to generate a Shader object\n"
  " */";
#else
static const char *Dtool_ShaderAttrib_register_with_read_factory_1948_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int ShaderAttrib::get_class_slot(void)
 */
static PyObject *Dtool_ShaderAttrib_get_class_slot_1954(PyObject *, PyObject *) {
  // 1-static int ShaderAttrib::get_class_slot(void)
  int return_value = (ShaderAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_class_slot_1954_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_ShaderAttrib_get_class_slot_1954_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ShaderAttrib::get_class_type(void)
 */
static PyObject *Dtool_ShaderAttrib_get_class_type_1956(PyObject *, PyObject *) {
  // 1-static TypeHandle ShaderAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ShaderAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderAttrib_get_class_type_1956_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShaderAttrib_get_class_type_1956_comment = nullptr;
#endif

static PyObject *Dtool_ShaderAttrib_shader_Getter(PyObject *self, void *) {
  const ShaderAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-Shader const *ShaderAttrib::get_shader(void) const
  Shader const *return_value = ((*(const ShaderAttrib*)local_this).get_shader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Shader, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_ShaderAttrib_instance_count_Getter(PyObject *self, void *) {
  const ShaderAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ShaderAttrib::get_instance_count(void) const
  int return_value = ((*(const ShaderAttrib*)local_this).get_instance_count)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ShaderAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int ShaderAttrib::get_class_slot(void)
  int return_value = (ShaderAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ShaderAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ShaderAttrib(PyObject *args, CPT(ShaderAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ShaderAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > ShaderAttrib::make(Shader const *shader, int priority)
    Shader const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Shader);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = (ShaderAttrib::make)(arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((ShaderAttrib const *) return_value.p());
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-static ConstPointerTo< RenderAttrib > ShaderAttrib::make(Shader const *shader, int priority)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:make", &param0, &param1)) {
        Shader const *param0_this = nullptr;
        DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Shader);
        if (param0_this != nullptr) {
          ConstPointerTo< RenderAttrib > return_value = (ShaderAttrib::make)(param0_this, (int)param1);
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move((ShaderAttrib const *) return_value.p());
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ShaderAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShaderAttrib) {
    printf("ShaderAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShaderAttrib *local_this = (ShaderAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShaderAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShaderAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShaderAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShaderAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (ShaderAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ShaderAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ShaderAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ShaderAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShowBoundsEffect
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > ShowBoundsEffect::make(bool tight = false)
 */
static PyObject *Dtool_ShowBoundsEffect_make_1959(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderEffect > ShowBoundsEffect::make(bool tight = false)
  PyObject *param0 = Py_False;
  if (Dtool_ExtractOptionalArg(&param0, args, kwds, "tight")) {
    ConstPointerTo< RenderEffect > return_value = (ShowBoundsEffect::make)((PyObject_IsTrue(param0) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderEffect const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(bool tight)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShowBoundsEffect_make_1959_comment =
  "C++ Interface:\n"
  "make(bool tight)\n"
  "\n"
  "/**\n"
  " * Constructs a new ShowBoundsEffect object.\n"
  " */";
#else
static const char *Dtool_ShowBoundsEffect_make_1959_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ShowBoundsEffect::get_tight(void) const
 */
static PyObject *Dtool_ShowBoundsEffect_get_tight_1960(PyObject *self, PyObject *) {
  ShowBoundsEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShowBoundsEffect)) {
    return nullptr;
  }
  // 1-inline bool ShowBoundsEffect::get_tight(void) const
  bool return_value = ((*(const ShowBoundsEffect*)local_this).get_tight)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShowBoundsEffect_get_tight_1960_comment =
  "C++ Interface:\n"
  "get_tight(ShowBoundsEffect self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"tight\" flag was set, meaning the effect should compute\n"
  " * and draw the tight bounding-box of the node's vertices every frame.\n"
  " */";
#else
static const char *Dtool_ShowBoundsEffect_get_tight_1960_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ShowBoundsEffect::get_class_type(void)
 */
static PyObject *Dtool_ShowBoundsEffect_get_class_type_1961(PyObject *, PyObject *) {
  // 1-static TypeHandle ShowBoundsEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ShowBoundsEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShowBoundsEffect_get_class_type_1961_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShowBoundsEffect_get_class_type_1961_comment = nullptr;
#endif

static int Dtool_Init_ShowBoundsEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ShowBoundsEffect(PyObject *args, CPT(ShowBoundsEffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ShowBoundsEffect)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderEffect > ShowBoundsEffect::make(bool tight)
    ConstPointerTo< RenderEffect > return_value = (ShowBoundsEffect::make)((PyObject_IsTrue(arg) != 0));
    if (_PyErr_OCCURRED()) {
      return false;
    } else {
      coerced = std::move((ShowBoundsEffect const *) return_value.p());
      return true;
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ShowBoundsEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShowBoundsEffect) {
    printf("ShowBoundsEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShowBoundsEffect *local_this = (ShowBoundsEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShowBoundsEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShowBoundsEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShowBoundsEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShowBoundsEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (ShowBoundsEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ShowBoundsEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ShowBoundsEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ShowBoundsEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TexProjectorEffect
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > TexProjectorEffect::make(void)
 */
static PyObject *Dtool_TexProjectorEffect_make_1964(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderEffect > TexProjectorEffect::make(void)
  ConstPointerTo< RenderEffect > return_value = (TexProjectorEffect::make)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffect const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TexProjectorEffect_make_1964_comment =
  "C++ Interface:\n"
  "make()\n"
  "\n"
  "/**\n"
  " * Constructs a TexProjectorEffect that modifies no stages at all.\n"
  " */";
#else
static const char *Dtool_TexProjectorEffect_make_1964_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffect > TexProjectorEffect::add_stage(TextureStage *stage, NodePath const &from, NodePath const &to, int lens_index = 0) const
 */
static PyObject *Dtool_TexProjectorEffect_add_stage_1965(PyObject *self, PyObject *args, PyObject *kwds) {
  TexProjectorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexProjectorEffect)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffect > TexProjectorEffect::add_stage(TextureStage *stage, NodePath const &from, NodePath const &to, int lens_index = 0) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  int param4 = 0;
  static const char *keyword_list[] = {"stage", "from", "to", "lens_index", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:add_stage", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextureStage, 1, "TexProjectorEffect.add_stage", false, true);
    NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "TexProjectorEffect.add_stage", true, true);
    NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "TexProjectorEffect.add_stage", true, true);
    if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
      ConstPointerTo< RenderEffect > return_value = ((*(const TexProjectorEffect*)local_this).add_stage)(param1_this, *param2_this, *param3_this, (int)param4);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderEffect const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_stage(TexProjectorEffect self, TextureStage stage, const NodePath from, const NodePath to, int lens_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexProjectorEffect_add_stage_1965_comment =
  "C++ Interface:\n"
  "add_stage(TexProjectorEffect self, TextureStage stage, const NodePath from, const NodePath to, int lens_index)\n"
  "\n"
  "/**\n"
  " * Returns a new TexProjectorEffect just like this one, with the indicated\n"
  " * projection for the given stage.  If this stage already exists, its\n"
  " * projection definition is replaced.\n"
  " *\n"
  " * The relative transform between the \"from\" and the \"to\" nodes is\n"
  " * automatically applied to the texture transform each frame.\n"
  " *\n"
  " * Furthermore, if the \"to\" node is a LensNode, its projection matrix is also\n"
  " * applied to the texture transform.  In this case, the lens_index may be used\n"
  " * to select the particular lens that should be used.\n"
  " */";
#else
static const char *Dtool_TexProjectorEffect_add_stage_1965_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffect > TexProjectorEffect::remove_stage(TextureStage *stage) const
 */
static PyObject *Dtool_TexProjectorEffect_remove_stage_1966(PyObject *self, PyObject *arg) {
  TexProjectorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexProjectorEffect)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffect > TexProjectorEffect::remove_stage(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexProjectorEffect.remove_stage", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderEffect > return_value = ((*(const TexProjectorEffect*)local_this).remove_stage)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderEffect const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_stage(TexProjectorEffect self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexProjectorEffect_remove_stage_1966_comment =
  "C++ Interface:\n"
  "remove_stage(TexProjectorEffect self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns a new TexProjectorEffect just like this one, with the indicated\n"
  " * stage removed.\n"
  " */";
#else
static const char *Dtool_TexProjectorEffect_remove_stage_1966_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TexProjectorEffect::is_empty(void) const
 */
static PyObject *Dtool_TexProjectorEffect_is_empty_1967(PyObject *self, PyObject *) {
  TexProjectorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexProjectorEffect)) {
    return nullptr;
  }
  // 1-bool TexProjectorEffect::is_empty(void) const
  bool return_value = ((*(const TexProjectorEffect*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexProjectorEffect_is_empty_1967_comment =
  "C++ Interface:\n"
  "is_empty(TexProjectorEffect self)\n"
  "\n"
  "/**\n"
  " * Returns true if no stages are defined in the TexProjectorEffect, false if\n"
  " * at least one is.\n"
  " */";
#else
static const char *Dtool_TexProjectorEffect_is_empty_1967_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TexProjectorEffect::has_stage(TextureStage *stage) const
 */
static PyObject *Dtool_TexProjectorEffect_has_stage_1968(PyObject *self, PyObject *arg) {
  TexProjectorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexProjectorEffect)) {
    return nullptr;
  }
  // 1-bool TexProjectorEffect::has_stage(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexProjectorEffect.has_stage", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const TexProjectorEffect*)local_this).has_stage)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_stage(TexProjectorEffect self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexProjectorEffect_has_stage_1968_comment =
  "C++ Interface:\n"
  "has_stage(TexProjectorEffect self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a transform associated with the indicated stage,\n"
  " * or false otherwise (in which case get_transform(stage) will return the\n"
  " * identity transform).\n"
  " */";
#else
static const char *Dtool_TexProjectorEffect_has_stage_1968_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath TexProjectorEffect::get_from(TextureStage *stage) const
 */
static PyObject *Dtool_TexProjectorEffect_get_from_1969(PyObject *self, PyObject *arg) {
  TexProjectorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexProjectorEffect)) {
    return nullptr;
  }
  // 1-NodePath TexProjectorEffect::get_from(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexProjectorEffect.get_from", false, true);
  if (arg_this != nullptr) {
    NodePath *return_value = new NodePath(((*(const TexProjectorEffect*)local_this).get_from)(arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_from(TexProjectorEffect self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexProjectorEffect_get_from_1969_comment =
  "C++ Interface:\n"
  "get_from(TexProjectorEffect self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the \"from\" node associated with the TexProjectorEffect on the\n"
  " * indicated stage.  The relative transform between the \"from\" and the \"to\"\n"
  " * nodes is automatically applied to the texture transform each frame.\n"
  " */";
#else
static const char *Dtool_TexProjectorEffect_get_from_1969_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath TexProjectorEffect::get_to(TextureStage *stage) const
 */
static PyObject *Dtool_TexProjectorEffect_get_to_1970(PyObject *self, PyObject *arg) {
  TexProjectorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexProjectorEffect)) {
    return nullptr;
  }
  // 1-NodePath TexProjectorEffect::get_to(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexProjectorEffect.get_to", false, true);
  if (arg_this != nullptr) {
    NodePath *return_value = new NodePath(((*(const TexProjectorEffect*)local_this).get_to)(arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_to(TexProjectorEffect self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexProjectorEffect_get_to_1970_comment =
  "C++ Interface:\n"
  "get_to(TexProjectorEffect self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the \"to\" node associated with the TexProjectorEffect on the\n"
  " * indicated stage.  The relative transform between the \"from\" and the \"to\"\n"
  " * nodes is automatically applied to the texture transform each frame.\n"
  " *\n"
  " * Furthermore, if the \"to\" node is a LensNode, its projection matrix is also\n"
  " * applied to the texture transform.\n"
  " */";
#else
static const char *Dtool_TexProjectorEffect_get_to_1970_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TexProjectorEffect::get_lens_index(TextureStage *stage) const
 */
static PyObject *Dtool_TexProjectorEffect_get_lens_index_1971(PyObject *self, PyObject *arg) {
  TexProjectorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexProjectorEffect)) {
    return nullptr;
  }
  // 1-int TexProjectorEffect::get_lens_index(TextureStage *stage) const
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TexProjectorEffect.get_lens_index", false, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const TexProjectorEffect*)local_this).get_lens_index)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_lens_index(TexProjectorEffect self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexProjectorEffect_get_lens_index_1971_comment =
  "C++ Interface:\n"
  "get_lens_index(TexProjectorEffect self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Returns the lens_index associated with the TexProjectorEffect on the\n"
  " * indicated stage.  This is only used if the \"to\" node is a LensNode, in\n"
  " * which case it specifies the particular lens that should be used.\n"
  " */";
#else
static const char *Dtool_TexProjectorEffect_get_lens_index_1971_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TexProjectorEffect::get_class_type(void)
 */
static PyObject *Dtool_TexProjectorEffect_get_class_type_1972(PyObject *, PyObject *) {
  // 1-static TypeHandle TexProjectorEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TexProjectorEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TexProjectorEffect_get_class_type_1972_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TexProjectorEffect_get_class_type_1972_comment = nullptr;
#endif

static int Dtool_Init_TexProjectorEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TexProjectorEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TexProjectorEffect) {
    printf("TexProjectorEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TexProjectorEffect *local_this = (TexProjectorEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TexProjectorEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TexProjectorEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TexProjectorEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TexProjectorEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (TexProjectorEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TexProjectorEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TexProjectorEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TexProjectorEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ScissorEffect
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > ScissorEffect::make_screen(LVecBase4 const &frame, bool clip = true)
 */
static PyObject *Dtool_ScissorEffect_make_screen_1974(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderEffect > ScissorEffect::make_screen(LVecBase4 const &frame, bool clip = true)
  PyObject *param0;
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"frame", "clip", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:make_screen", (char **)keyword_list, &param0, &param1)) {
    LVecBase4f param0_local;
    LVecBase4 const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "ScissorEffect.make_screen", "LVecBase4f");
    }
    ConstPointerTo< RenderEffect > return_value = (ScissorEffect::make_screen)(*param0_this, (PyObject_IsTrue(param1) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderEffect const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_screen(const LVecBase4f frame, bool clip)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ScissorEffect_make_screen_1974_comment =
  "C++ Interface:\n"
  "make_screen(const LVecBase4f frame, bool clip)\n"
  "\n"
  "/**\n"
  " * Constructs a new screen-relative ScissorEffect.  The frame defines a left,\n"
  " * right, bottom, top region, relative to the DisplayRegion.  See\n"
  " * ScissorAttrib.\n"
  " */";
#else
static const char *Dtool_ScissorEffect_make_screen_1974_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > ScissorEffect::make_node(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d, NodePath const &node = NodePath())
 * static ConstPointerTo< RenderEffect > ScissorEffect::make_node(LPoint3 const &a, LPoint3 const &b, NodePath const &node = NodePath())
 * static ConstPointerTo< RenderEffect > ScissorEffect::make_node(bool clip = true)
 */
static PyObject *Dtool_ScissorEffect_make_node_1975(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-static ConstPointerTo< RenderEffect > ScissorEffect::make_node(bool clip)
      ConstPointerTo< RenderEffect > return_value = (ScissorEffect::make_node)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderEffect const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "clip")) {
        // 1-static ConstPointerTo< RenderEffect > ScissorEffect::make_node(bool clip)
        ConstPointerTo< RenderEffect > return_value = (ScissorEffect::make_node)((PyObject_IsTrue(arg) != 0));
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderEffect const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 2:
    {
      // 1-static ConstPointerTo< RenderEffect > ScissorEffect::make_node(LPoint3 const &a, LPoint3 const &b, NodePath const &node)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"a", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_node", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "ScissorEffect.make_node", "LPoint3f");
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ScissorEffect.make_node", "LPoint3f");
        }
        ConstPointerTo< RenderEffect > return_value = (ScissorEffect::make_node)(*param0_this, *param1_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderEffect const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 3:
    {
      // 1-static ConstPointerTo< RenderEffect > ScissorEffect::make_node(LPoint3 const &a, LPoint3 const &b, NodePath const &node)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "node", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:make_node", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "ScissorEffect.make_node", "LPoint3f");
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ScissorEffect.make_node", "LPoint3f");
        }
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "ScissorEffect.make_node", true, true);
        if (param2_this != nullptr) {
          ConstPointerTo< RenderEffect > return_value = (ScissorEffect::make_node)(*param0_this, *param1_this, *param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderEffect const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 4:
  case 5:
    {
      // 1-static ConstPointerTo< RenderEffect > ScissorEffect::make_node(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d, NodePath const &node = NodePath())
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4 = nullptr;
      static const char *keyword_list[] = {"a", "b", "c", "d", "node", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO|O:make_node", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "ScissorEffect.make_node", "LPoint3f");
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ScissorEffect.make_node", "LPoint3f");
        }
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ScissorEffect.make_node", "LPoint3f");
        }
        LPoint3f param3_local;
        LPoint3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "ScissorEffect.make_node", "LPoint3f");
        }
        NodePath const *param4_this;
        const NodePath &param4_ref = NodePath();
        if (param4 == nullptr) {
          param4_this = &param4_ref;
        } else {
          param4_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_NodePath, 4, "ScissorEffect.make_node", true, true);
        }
        if ((param4 == nullptr || param4_this != nullptr)) {
          ConstPointerTo< RenderEffect > return_value = (ScissorEffect::make_node)(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          RenderEffect const *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_node() takes 0, 1, 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_node()\n"
      "make_node(bool clip)\n"
      "make_node(const LPoint3f a, const LPoint3f b)\n"
      "make_node(const LPoint3f a, const LPoint3f b, const NodePath node)\n"
      "make_node(const LPoint3f a, const LPoint3f b, const LPoint3f c, const LPoint3f d, const NodePath node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ScissorEffect_make_node_1975_comment =
  "C++ Interface:\n"
  "make_node()\n"
  "make_node(bool clip)\n"
  "make_node(const LPoint3f a, const LPoint3f b)\n"
  "make_node(const LPoint3f a, const LPoint3f b, const NodePath node)\n"
  "make_node(const LPoint3f a, const LPoint3f b, const LPoint3f c, const LPoint3f d, const NodePath node)\n"
  "\n"
  "/**\n"
  " * Constructs a new node-relative ScissorEffect, with no points.  This empty\n"
  " * ScissorEffect does nothing.  You must then call add_point a number of times\n"
  " * to add the points you require.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new node-relative ScissorEffect.  The two points are\n"
  " * understood to be relative to the indicated node, or the current node if the\n"
  " * NodePath is empty, and determine the diagonally opposite corners of the\n"
  " * scissor region.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a new node-relative ScissorEffect.  The four points are\n"
  " * understood to be relative to the indicated node, or the current node if the\n"
  " * indicated NodePath is empty, and determine four points surrounding the\n"
  " * scissor region.\n"
  " */";
#else
static const char *Dtool_ScissorEffect_make_node_1975_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< RenderEffect > ScissorEffect::add_point(LPoint3 const &point, NodePath const &node = NodePath()) const
 */
static PyObject *Dtool_ScissorEffect_add_point_1976(PyObject *self, PyObject *args, PyObject *kwds) {
  ScissorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ScissorEffect)) {
    return nullptr;
  }
  // 1-ConstPointerTo< RenderEffect > ScissorEffect::add_point(LPoint3 const &point, NodePath const &node = NodePath()) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"point", "node", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:add_point", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ScissorEffect.add_point", "LPoint3f");
    }
    NodePath const *param2_this;
    const NodePath &param2_ref = NodePath();
    if (param2 == nullptr) {
      param2_this = &param2_ref;
    } else {
      param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "ScissorEffect.add_point", true, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      ConstPointerTo< RenderEffect > return_value = ((*(const ScissorEffect*)local_this).add_point)(*param1_this, *param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      RenderEffect const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_point(ScissorEffect self, const LPoint3f point, const NodePath node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ScissorEffect_add_point_1976_comment =
  "C++ Interface:\n"
  "add_point(ScissorEffect self, const LPoint3f point, const NodePath node)\n"
  "\n"
  "/**\n"
  " * Returns a new ScissorEffect with the indicated point added.  It is only\n"
  " * valid to call this on a \"node\" type ScissorEffect.  The full set of points,\n"
  " * projected into screen space, defines the bounding volume of the rectangular\n"
  " * scissor region.\n"
  " *\n"
  " * Each point may be relative to a different node, if desired.\n"
  " */";
#else
static const char *Dtool_ScissorEffect_add_point_1976_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ScissorEffect::is_screen(void) const
 */
static PyObject *Dtool_ScissorEffect_is_screen_1977(PyObject *self, PyObject *) {
  ScissorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ScissorEffect)) {
    return nullptr;
  }
  // 1-inline bool ScissorEffect::is_screen(void) const
  bool return_value = ((*(const ScissorEffect*)local_this).is_screen)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ScissorEffect_is_screen_1977_comment =
  "C++ Interface:\n"
  "is_screen(ScissorEffect self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ScissorEffect is a screen-based effect, meaning\n"
  " * get_frame() has a meaningful value, but get_a() and get_b() do not.\n"
  " */";
#else
static const char *Dtool_ScissorEffect_is_screen_1977_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &ScissorEffect::get_frame(void) const
 */
static PyObject *Dtool_ScissorEffect_get_frame_1978(PyObject *self, PyObject *) {
  ScissorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ScissorEffect)) {
    return nullptr;
  }
  // 1-inline LVecBase4 const &ScissorEffect::get_frame(void) const
  LVecBase4 const *return_value = &(((*(const ScissorEffect*)local_this).get_frame)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ScissorEffect_get_frame_1978_comment =
  "C++ Interface:\n"
  "get_frame(ScissorEffect self)\n"
  "\n"
  "/**\n"
  " * If is_screen() returns true, this method may be called to query the screen-\n"
  " * based scissor frame.  This is a series of left, right, bottom, top,\n"
  " * representing the scissor frame relative to the current DisplayRegion.  See\n"
  " * ScissorAttrib.\n"
  " */";
#else
static const char *Dtool_ScissorEffect_get_frame_1978_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ScissorEffect::get_num_points(void) const
 */
static PyObject *Dtool_ScissorEffect_get_num_points_1979(PyObject *self, PyObject *) {
  ScissorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ScissorEffect)) {
    return nullptr;
  }
  // 1-inline int ScissorEffect::get_num_points(void) const
  int return_value = ((*(const ScissorEffect*)local_this).get_num_points)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ScissorEffect_get_num_points_1979_comment =
  "C++ Interface:\n"
  "get_num_points(ScissorEffect self)\n"
  "\n"
  "/**\n"
  " * Returns the number of node-based scissor points.  See get_point().\n"
  " */";
#else
static const char *Dtool_ScissorEffect_get_num_points_1979_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &ScissorEffect::get_point(int n) const
 */
static PyObject *Dtool_ScissorEffect_get_point_1980(PyObject *self, PyObject *arg) {
  ScissorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ScissorEffect)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &ScissorEffect::get_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 const *return_value = &(((*(const ScissorEffect*)local_this).get_point)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(ScissorEffect self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ScissorEffect_get_point_1980_comment =
  "C++ Interface:\n"
  "get_point(ScissorEffect self, int n)\n"
  "\n"
  "/**\n"
  " * If is_screen() returns false, then get_num_points() and get_point() may be\n"
  " * called to query the node-based scissor frame.  These return n points (at\n"
  " * least two), which are understood to be in the space of this node, and which\n"
  " * define any opposite corners of the scissor frame.\n"
  " */";
#else
static const char *Dtool_ScissorEffect_get_point_1980_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath ScissorEffect::get_node(int n) const
 */
static PyObject *Dtool_ScissorEffect_get_node_1982(PyObject *self, PyObject *arg) {
  ScissorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ScissorEffect)) {
    return nullptr;
  }
  // 1-inline NodePath ScissorEffect::get_node(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath(((*(const ScissorEffect*)local_this).get_node)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(ScissorEffect self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ScissorEffect_get_node_1982_comment =
  "C++ Interface:\n"
  "get_node(ScissorEffect self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the node to which the nth point is relative, or empty NodePath to\n"
  " * indicate the current node.\n"
  " */";
#else
static const char *Dtool_ScissorEffect_get_node_1982_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ScissorEffect::get_clip(void) const
 */
static PyObject *Dtool_ScissorEffect_get_clip_1984(PyObject *self, PyObject *) {
  ScissorEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ScissorEffect)) {
    return nullptr;
  }
  // 1-inline bool ScissorEffect::get_clip(void) const
  bool return_value = ((*(const ScissorEffect*)local_this).get_clip)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ScissorEffect_get_clip_1984_comment =
  "C++ Interface:\n"
  "get_clip(ScissorEffect self)\n"
  "\n"
  "/**\n"
  " * Returns true if this ScissorEffect actually enables scissoring, or false if\n"
  " * it culls only.\n"
  " */";
#else
static const char *Dtool_ScissorEffect_get_clip_1984_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ScissorEffect::get_class_type(void)
 */
static PyObject *Dtool_ScissorEffect_get_class_type_1985(PyObject *, PyObject *) {
  // 1-static TypeHandle ScissorEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ScissorEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ScissorEffect_get_class_type_1985_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ScissorEffect_get_class_type_1985_comment = nullptr;
#endif

static int Dtool_Init_ScissorEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ScissorEffect_get_points(PyObject *self, PyObject *) {
  ScissorEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ScissorEffect, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_points)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ScissorEffect_get_point_1980(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ScissorEffect_get_nodes(PyObject *self, PyObject *) {
  ScissorEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ScissorEffect, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_points)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ScissorEffect_get_node_1982(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ScissorEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ScissorEffect) {
    printf("ScissorEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ScissorEffect *local_this = (ScissorEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ScissorEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ScissorEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ScissorEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ScissorEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (ScissorEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ScissorEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ScissorEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ScissorEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SceneGraphReducer
 */
/**
 * Python function wrapper for:
 * void SceneGraphReducer::set_gsg(GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_SceneGraphReducer_set_gsg_1994(PyObject *self, PyObject *arg) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.set_gsg")) {
    return nullptr;
  }
  // 1-void SceneGraphReducer::set_gsg(GraphicsStateGuardianBase *gsg)
  GraphicsStateGuardianBase *arg_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsStateGuardianBase, 1, "SceneGraphReducer.set_gsg", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_gsg)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gsg(const SceneGraphReducer self, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_set_gsg_1994_comment =
  "C++ Interface:\n"
  "set_gsg(const SceneGraphReducer self, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Specifies the particular GraphicsStateGuardian that this object will\n"
  " * attempt to optimize to.  The GSG may specify parameters such as maximum\n"
  " * number of vertices per vertex data, max number of vertices per primitive,\n"
  " * and whether triangle strips are preferred.  It also affects the types of\n"
  " * vertex column data that is created by premunge().\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_set_gsg_1994_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SceneGraphReducer::clear_gsg(void)
 */
static PyObject *Dtool_SceneGraphReducer_clear_gsg_1995(PyObject *self, PyObject *) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.clear_gsg")) {
    return nullptr;
  }
  // 1-void SceneGraphReducer::clear_gsg(void)
  ((*local_this).clear_gsg)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_clear_gsg_1995_comment =
  "C++ Interface:\n"
  "clear_gsg(const SceneGraphReducer self)\n"
  "\n"
  "/**\n"
  " * Specifies that no particular GraphicsStateGuardian will be used to guide\n"
  " * the optimization.  The SceneGraphReducer will instead use config variables\n"
  " * such as max-collect-vertices and max-collect-indices.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_clear_gsg_1995_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsStateGuardianBase *SceneGraphReducer::get_gsg(void) const
 */
static PyObject *Dtool_SceneGraphReducer_get_gsg_1996(PyObject *self, PyObject *) {
  SceneGraphReducer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphReducer)) {
    return nullptr;
  }
  // 1-inline GraphicsStateGuardianBase *SceneGraphReducer::get_gsg(void) const
  GraphicsStateGuardianBase *return_value = ((*(const SceneGraphReducer*)local_this).get_gsg)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsStateGuardianBase, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_get_gsg_1996_comment =
  "C++ Interface:\n"
  "get_gsg(SceneGraphReducer self)\n"
  "\n"
  "/**\n"
  " * Returns the particular GraphicsStateGuardian that this object will attempt\n"
  " * to optimize to.  See set_gsg().\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_get_gsg_1996_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneGraphReducer::set_combine_radius(PN_stdfloat combine_radius)
 */
static PyObject *Dtool_SceneGraphReducer_set_combine_radius_1997(PyObject *self, PyObject *arg) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.set_combine_radius")) {
    return nullptr;
  }
  // 1-inline void SceneGraphReducer::set_combine_radius(PN_stdfloat combine_radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_combine_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_combine_radius(const SceneGraphReducer self, float combine_radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_set_combine_radius_1997_comment =
  "C++ Interface:\n"
  "set_combine_radius(const SceneGraphReducer self, float combine_radius)\n"
  "\n"
  "/**\n"
  " * Specifies the radius that is used in conjunction with CS_within_radius to\n"
  " * decide whether a subgraph's siblings should be combined into a single node\n"
  " * or not.\n"
  " *\n"
  " * If the CS_within_radius bit is included in the combine_siblings_bits\n"
  " * parameter passed to flatten, than any nodes whose bounding volume is\n"
  " * smaller than the indicated radius will be combined together (as if CS_other\n"
  " * were set).\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_set_combine_radius_1997_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SceneGraphReducer::get_combine_radius(void) const
 */
static PyObject *Dtool_SceneGraphReducer_get_combine_radius_1998(PyObject *self, PyObject *) {
  SceneGraphReducer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphReducer)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat SceneGraphReducer::get_combine_radius(void) const
  PN_stdfloat return_value = ((*(const SceneGraphReducer*)local_this).get_combine_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_get_combine_radius_1998_comment =
  "C++ Interface:\n"
  "get_combine_radius(SceneGraphReducer self)\n"
  "\n"
  "/**\n"
  " * Returns the radius that is used in conjunction with CS_within_radius.  See\n"
  " * set_combine_radius().\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_get_combine_radius_1998_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Rejected Remap [inline void SceneGraphReducer::apply_attribs(PandaNode *node, AccumulatedAttribs const &attribs, int attrib_types, GeomTransformer &transformer)]
 * inline void SceneGraphReducer::apply_attribs(PandaNode *node, int attrib_types = (~ ((::SceneGraphReducer::TT_clip_plane | ::SceneGraphReducer::TT_cull_face) | ::SceneGraphReducer::TT_apply_texture_color)))
 */
static PyObject *Dtool_SceneGraphReducer_apply_attribs_1999(PyObject *self, PyObject *args, PyObject *kwds) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.apply_attribs")) {
    return nullptr;
  }
  // 1-inline void SceneGraphReducer::apply_attribs(PandaNode *node, int attrib_types = (~ ((::SceneGraphReducer::TT_clip_plane | ::SceneGraphReducer::TT_cull_face) | ::SceneGraphReducer::TT_apply_texture_color)))
  PyObject *param1;
  int param2 = (~ ((SceneGraphReducer::TT_clip_plane | SceneGraphReducer::TT_cull_face) | SceneGraphReducer::TT_apply_texture_color));
  static const char *keyword_list[] = {"node", "attrib_types", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:apply_attribs", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.apply_attribs", false, true);
    if (param1_this != nullptr) {
      ((*local_this).apply_attribs)(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_attribs(const SceneGraphReducer self, PandaNode node, int attrib_types)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_apply_attribs_1999_comment =
  "C++ Interface:\n"
  "apply_attribs(const SceneGraphReducer self, PandaNode node, int attrib_types)\n"
  "\n"
  "/**\n"
  " * Walks the scene graph, accumulating attribs of the indicated types,\n"
  " * applying them to the vertices, and removing them from the scene graph.\n"
  " * This has a performance optimization benefit in itself, but is especially\n"
  " * useful to pave the way for a call to flatten() and greatly improve the\n"
  " * effectiveness of the flattening operation.\n"
  " *\n"
  " * Multiply instanced geometry is duplicated before the attribs are applied.\n"
  " *\n"
  " * Of course, this operation does make certain dynamic operations impossible.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of apply_attribs() can be called recursively from within\n"
  " * another flatten process (e.g.  from\n"
  " * PandaNode::apply_attribs_to_vertices()). The parameters were presumably\n"
  " * received from a parent SceneGraphReducer object.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_apply_attribs_1999_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int SceneGraphReducer::flatten(PandaNode *root, int combine_siblings_bits)
 */
static PyObject *Dtool_SceneGraphReducer_flatten_2000(PyObject *self, PyObject *args, PyObject *kwds) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.flatten")) {
    return nullptr;
  }
  // 1-int SceneGraphReducer::flatten(PandaNode *root, int combine_siblings_bits)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"root", "combine_siblings_bits", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:flatten", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.flatten", false, true);
    if (param1_this != nullptr) {
      int return_value = ((*local_this).flatten)(param1_this, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flatten(const SceneGraphReducer self, PandaNode root, int combine_siblings_bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_flatten_2000_comment =
  "C++ Interface:\n"
  "flatten(const SceneGraphReducer self, PandaNode root, int combine_siblings_bits)\n"
  "\n"
  "/**\n"
  " * Simplifies the graph by removing unnecessary nodes and nodes.\n"
  " *\n"
  " * In general, a node (and its parent node) is a candidate for removal if the\n"
  " * node has no siblings and the node has no special properties.\n"
  " *\n"
  " * If combine_siblings_bits is nonzero, some sibling nodes (according to the\n"
  " * bits set in combine_siblings_bits) may also be collapsed into a single\n"
  " * node.  This will further reduce scene graph complexity, sometimes\n"
  " * substantially, at the cost of reduced spatial separation.\n"
  " *\n"
  " * Returns the number of nodes removed from the graph.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_flatten_2000_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int SceneGraphReducer::remove_column(PandaNode *root, InternalName const *column)
 */
static PyObject *Dtool_SceneGraphReducer_remove_column_2001(PyObject *self, PyObject *args, PyObject *kwds) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.remove_column")) {
    return nullptr;
  }
  // 1-int SceneGraphReducer::remove_column(PandaNode *root, InternalName const *column)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"root", "column", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:remove_column", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.remove_column", false, true);
    CPT(InternalName) param2_this;
    if (!Dtool_ConstCoerce_InternalName(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "SceneGraphReducer.remove_column", "InternalName");
    }
    if (param1_this != nullptr) {
      int return_value = ((*local_this).remove_column)(param1_this, std::move(param2_this));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_column(const SceneGraphReducer self, PandaNode root, const InternalName column)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_remove_column_2001_comment =
  "C++ Interface:\n"
  "remove_column(const SceneGraphReducer self, PandaNode root, const InternalName column)\n"
  "\n"
  "/**\n"
  " * Removes the indicated data column from any GeomVertexDatas found at the\n"
  " * indicated root and below.  Returns the number of GeomNodes modified.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_remove_column_2001_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int SceneGraphReducer::make_compatible_state(PandaNode *root)
 */
static PyObject *Dtool_SceneGraphReducer_make_compatible_state_2002(PyObject *self, PyObject *arg) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.make_compatible_state")) {
    return nullptr;
  }
  // 1-int SceneGraphReducer::make_compatible_state(PandaNode *root)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.make_compatible_state", false, true);
  if (arg_this != nullptr) {
    int return_value = ((*local_this).make_compatible_state)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_compatible_state(const SceneGraphReducer self, PandaNode root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_make_compatible_state_2002_comment =
  "C++ Interface:\n"
  "make_compatible_state(const SceneGraphReducer self, PandaNode root)\n"
  "\n"
  "/**\n"
  " * Searches for GeomNodes that contain multiple Geoms that differ only in\n"
  " * their ColorAttribs.  If such a GeomNode is found, then all the colors are\n"
  " * pushed down into the vertices.  This makes it feasible for the geoms to be\n"
  " * unified later.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_make_compatible_state_2002_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphReducer::make_compatible_format(PandaNode *root, int collect_bits = (~ 0))
 */
static PyObject *Dtool_SceneGraphReducer_make_compatible_format_2003(PyObject *self, PyObject *args, PyObject *kwds) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.make_compatible_format")) {
    return nullptr;
  }
  // 1-inline int SceneGraphReducer::make_compatible_format(PandaNode *root, int collect_bits = (~ 0))
  PyObject *param1;
  int param2 = (~ 0);
  static const char *keyword_list[] = {"root", "collect_bits", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:make_compatible_format", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.make_compatible_format", false, true);
    if (param1_this != nullptr) {
      int return_value = ((*local_this).make_compatible_format)(param1_this, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_compatible_format(const SceneGraphReducer self, PandaNode root, int collect_bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_make_compatible_format_2003_comment =
  "C++ Interface:\n"
  "make_compatible_format(const SceneGraphReducer self, PandaNode root, int collect_bits)\n"
  "\n"
  "/**\n"
  " * Walks through the tree at this node and below and unifies the\n"
  " * GeomVertexFormat for any GeomVertexData objects that are found, so that all\n"
  " * eligible vdatas (according to collect_bits; see collect_vertex_data) will\n"
  " * share the same vertex format.\n"
  " *\n"
  " * This will add unused columns where necessary to match formats.  It can\n"
  " * result in suboptimal performance if used needlessly.\n"
  " *\n"
  " * There is usually no reason to call this explicitly, since\n"
  " * collect_vertex_data() will do this anyway if it has not been done already.\n"
  " * However, calling it ahead of time can make that future call to\n"
  " * collect_vertex_data() run a little bit faster.\n"
  " *\n"
  " * The return value is the number of vertex datas modified.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_make_compatible_format_2003_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SceneGraphReducer::decompose(PandaNode *root)
 */
static PyObject *Dtool_SceneGraphReducer_decompose_2004(PyObject *self, PyObject *arg) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.decompose")) {
    return nullptr;
  }
  // 1-void SceneGraphReducer::decompose(PandaNode *root)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.decompose", false, true);
  if (arg_this != nullptr) {
    ((*local_this).decompose)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decompose(const SceneGraphReducer self, PandaNode root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_decompose_2004_comment =
  "C++ Interface:\n"
  "decompose(const SceneGraphReducer self, PandaNode root)\n"
  "\n"
  "/**\n"
  " * Calls decompose() on every GeomNode at this level and below.\n"
  " *\n"
  " * There is usually no reason to call this explicitly, since unify() will do\n"
  " * this anyway if it needs to be done.  However, calling it ahead of time can\n"
  " * make that future call to unify() run a little bit faster.\n"
  " *\n"
  " * This operation has no effect if the config variable preserve-triangle-\n"
  " * strips has been set true.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_decompose_2004_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphReducer::collect_vertex_data(PandaNode *root, int collect_bits = (~ 0))
 */
static PyObject *Dtool_SceneGraphReducer_collect_vertex_data_2005(PyObject *self, PyObject *args, PyObject *kwds) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.collect_vertex_data")) {
    return nullptr;
  }
  // 1-inline int SceneGraphReducer::collect_vertex_data(PandaNode *root, int collect_bits = (~ 0))
  PyObject *param1;
  int param2 = (~ 0);
  static const char *keyword_list[] = {"root", "collect_bits", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:collect_vertex_data", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.collect_vertex_data", false, true);
    if (param1_this != nullptr) {
      int return_value = ((*local_this).collect_vertex_data)(param1_this, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collect_vertex_data(const SceneGraphReducer self, PandaNode root, int collect_bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_collect_vertex_data_2005_comment =
  "C++ Interface:\n"
  "collect_vertex_data(const SceneGraphReducer self, PandaNode root, int collect_bits)\n"
  "\n"
  "/**\n"
  " * Collects all different GeomVertexData blocks that have compatible formats\n"
  " * at this node and below into a single, unified block (or at least multiple\n"
  " * larger blocks).  This is intended to reduce rendering overhead incurred by\n"
  " * switching vertex buffers.  It can also make a subsequent call to unify()\n"
  " * much more effective than it would have been otherwise.\n"
  " *\n"
  " * The set of bits passed in collect_bits indicates which properties are used\n"
  " * to differentiate GeomVertexData blocks.  If it is 0, then more blocks will\n"
  " * be combined together than if it is nonzero.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_collect_vertex_data_2005_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphReducer::make_nonindexed(PandaNode *root, int nonindexed_bits = (~ 0))
 */
static PyObject *Dtool_SceneGraphReducer_make_nonindexed_2006(PyObject *self, PyObject *args, PyObject *kwds) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.make_nonindexed")) {
    return nullptr;
  }
  // 1-inline int SceneGraphReducer::make_nonindexed(PandaNode *root, int nonindexed_bits = (~ 0))
  PyObject *param1;
  int param2 = (~ 0);
  static const char *keyword_list[] = {"root", "nonindexed_bits", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:make_nonindexed", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.make_nonindexed", false, true);
    if (param1_this != nullptr) {
      int return_value = ((*local_this).make_nonindexed)(param1_this, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_nonindexed(const SceneGraphReducer self, PandaNode root, int nonindexed_bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_make_nonindexed_2006_comment =
  "C++ Interface:\n"
  "make_nonindexed(const SceneGraphReducer self, PandaNode root, int nonindexed_bits)\n"
  "\n"
  "/**\n"
  " * Converts indexed geometry to nonindexed geometry at the indicated node and\n"
  " * below, by duplicating vertices where necessary.  The parameter\n"
  " * nonindexed_bits is a union of bits defined in\n"
  " * SceneGraphReducer::MakeNonindexed, which specifes which types of geometry\n"
  " * to avoid making nonindexed.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_make_nonindexed_2006_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SceneGraphReducer::unify(PandaNode *root, bool preserve_order)
 */
static PyObject *Dtool_SceneGraphReducer_unify_2007(PyObject *self, PyObject *args, PyObject *kwds) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.unify")) {
    return nullptr;
  }
  // 1-void SceneGraphReducer::unify(PandaNode *root, bool preserve_order)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"root", "preserve_order", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:unify", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.unify", false, true);
    if (param1_this != nullptr) {
      ((*local_this).unify)(param1_this, (PyObject_IsTrue(param2) != 0));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unify(const SceneGraphReducer self, PandaNode root, bool preserve_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_unify_2007_comment =
  "C++ Interface:\n"
  "unify(const SceneGraphReducer self, PandaNode root, bool preserve_order)\n"
  "\n"
  "/**\n"
  " * Calls unify() on every GeomNode at this level and below.  This attempts to\n"
  " * reduce the total number of individual Geoms and GeomPrimitives by combining\n"
  " * these objects wherever possible.  See GeomNode::unify().\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_unify_2007_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SceneGraphReducer::remove_unused_vertices(PandaNode *root)
 */
static PyObject *Dtool_SceneGraphReducer_remove_unused_vertices_2008(PyObject *self, PyObject *arg) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.remove_unused_vertices")) {
    return nullptr;
  }
  // 1-void SceneGraphReducer::remove_unused_vertices(PandaNode *root)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.remove_unused_vertices", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_unused_vertices)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_unused_vertices(const SceneGraphReducer self, PandaNode root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_remove_unused_vertices_2008_comment =
  "C++ Interface:\n"
  "remove_unused_vertices(const SceneGraphReducer self, PandaNode root)\n"
  "\n"
  "/**\n"
  " * Removes any vertices in GeomVertexDatas that are no longer used at this\n"
  " * level and below.  This requires remapping vertex indices in all of the\n"
  " * GeomPrimitives, to remove holes in the GeomVertexDatas.  It is normally not\n"
  " * necessary to call this explicitly.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_remove_unused_vertices_2008_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SceneGraphReducer::premunge(PandaNode *root, RenderState const *initial_state)
 */
static PyObject *Dtool_SceneGraphReducer_premunge_2009(PyObject *self, PyObject *args, PyObject *kwds) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.premunge")) {
    return nullptr;
  }
  // 1-inline void SceneGraphReducer::premunge(PandaNode *root, RenderState const *initial_state)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"root", "initial_state", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:premunge", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.premunge", false, true);
    CPT(RenderState) param2_this;
    if (!Dtool_ConstCoerce_RenderState(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "SceneGraphReducer.premunge", "RenderState");
    }
    if (param1_this != nullptr) {
      ((*local_this).premunge)(param1_this, std::move(param2_this));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "premunge(const SceneGraphReducer self, PandaNode root, const RenderState initial_state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_premunge_2009_comment =
  "C++ Interface:\n"
  "premunge(const SceneGraphReducer self, PandaNode root, const RenderState initial_state)\n"
  "\n"
  "/**\n"
  " * Walks the scene graph rooted at this node and below, and uses the indicated\n"
  " * GSG to premunge every Geom found to optimize it for eventual rendering on\n"
  " * the indicated GSG.  If there is no GSG indicated for the SceneGraphReducer,\n"
  " * this is a no-op.\n"
  " *\n"
  " * This operation will also apply to stashed children.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_premunge_2009_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool SceneGraphReducer::check_live_flatten(PandaNode *node)
 */
static PyObject *Dtool_SceneGraphReducer_check_live_flatten_2010(PyObject *self, PyObject *arg) {
  SceneGraphReducer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphReducer, (void **)&local_this, "SceneGraphReducer.check_live_flatten")) {
    return nullptr;
  }
  // 1-bool SceneGraphReducer::check_live_flatten(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "SceneGraphReducer.check_live_flatten", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).check_live_flatten)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "check_live_flatten(const SceneGraphReducer self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphReducer_check_live_flatten_2010_comment =
  "C++ Interface:\n"
  "check_live_flatten(const SceneGraphReducer self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * In a non-release build, returns false if the node is correctly not in a\n"
  " * live scene graph.  (Calling flatten on a node that is part of a live scene\n"
  " * graph, for instance, a node somewhere under render, can cause problems in a\n"
  " * multithreaded environment.)\n"
  " *\n"
  " * If allow_live_flatten is true, or in a release build, this always returns\n"
  " * true.\n"
  " */";
#else
static const char *Dtool_SceneGraphReducer_check_live_flatten_2010_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline explicit SceneGraphReducer::SceneGraphReducer(GraphicsStateGuardianBase *gsg = nullptr)
 * inline SceneGraphReducer::SceneGraphReducer(SceneGraphReducer const &) = default
 */
static int Dtool_Init_SceneGraphReducer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit SceneGraphReducer::SceneGraphReducer(GraphicsStateGuardianBase *gsg)
      SceneGraphReducer *return_value = new SceneGraphReducer();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SceneGraphReducer, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline explicit SceneGraphReducer::SceneGraphReducer(GraphicsStateGuardianBase *gsg)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "gsg")) {
          GraphicsStateGuardianBase *param0_this = nullptr;
          if (param0 != Py_None) {
            param0_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsStateGuardianBase, 0, "SceneGraphReducer.SceneGraphReducer", false, false);
          }
          if ((param0 == Py_None || param0_this != nullptr)) {
            SceneGraphReducer *return_value = new SceneGraphReducer(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SceneGraphReducer, true, false);
          }
        }
      }

      {
        // -2 inline SceneGraphReducer::SceneGraphReducer(SceneGraphReducer const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          SceneGraphReducer const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_SceneGraphReducer);
          if (param0_this != nullptr) {
            SceneGraphReducer *return_value = new SceneGraphReducer(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SceneGraphReducer, true, false);
          }
        }
      }

      // No coercion possible: inline explicit SceneGraphReducer::SceneGraphReducer(GraphicsStateGuardianBase *gsg)
      // No coercion possible: inline SceneGraphReducer::SceneGraphReducer(SceneGraphReducer const &) = default
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SceneGraphReducer() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SceneGraphReducer()\n"
      "SceneGraphReducer(GraphicsStateGuardianBase gsg)\n"
      "SceneGraphReducer(const SceneGraphReducer param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SceneGraphReducer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SceneGraphReducer) {
    printf("SceneGraphReducer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SceneGraphReducer *local_this = (SceneGraphReducer *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SceneGraphReducer) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SceneGraphReducer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SceneGraphReducer) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamNodePath
 */
/**
 * Python function wrapper for:
 * inline NodePath ParamNodePath::get_value(void) const
 */
static PyObject *Dtool_ParamNodePath_get_value_2016(PyObject *self, PyObject *) {
  ParamNodePath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamNodePath)) {
    return nullptr;
  }
  // 1-inline NodePath ParamNodePath::get_value(void) const
  NodePath *return_value = new NodePath(((*(const ParamNodePath*)local_this).get_value)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamNodePath_get_value_2016_comment =
  "C++ Interface:\n"
  "get_value(ParamNodePath self)\n"
  "\n"
  "/**\n"
  " * Retrieves the NodePath stored in the parameter.\n"
  " */";
#else
static const char *Dtool_ParamNodePath_get_value_2016_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamNodePath::get_class_type(void)
 */
static PyObject *Dtool_ParamNodePath_get_class_type_2017(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamNodePath::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamNodePath::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamNodePath_get_class_type_2017_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamNodePath_get_class_type_2017_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ParamNodePath::ParamNodePath(NodePath node_path)
 */
static int Dtool_Init_ParamNodePath(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamNodePath() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "node_path")) {
    // 1-ParamNodePath::ParamNodePath(NodePath node_path)
    NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 0, "ParamNodePath.ParamNodePath", true, true);
    if (arg_this != nullptr) {
      ParamNodePath *return_value = new ParamNodePath(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamNodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamNodePath(NodePath node_path)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamNodePath(PyObject *args, CPT(ParamNodePath) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamNodePath)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ParamNodePath::ParamNodePath(NodePath node_path)
    NodePath *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      ParamNodePath *return_value = new ParamNodePath(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamNodePath(PyObject *args, PT(ParamNodePath) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamNodePath)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ParamNodePath::ParamNodePath(NodePath node_path)
    NodePath *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      ParamNodePath *return_value = new ParamNodePath(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamNodePath(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamNodePath) {
    printf("ParamNodePath ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamNodePath *local_this = (ParamNodePath *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamNodePath) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamNodePath(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamNodePath) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamNodePath*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamNodePath*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamNodePath*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamNodePath*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamNodePath*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PortalNode
 */
/**
 * Python function wrapper for:
 * inline void PortalNode::set_portal_mask(PortalMask mask)
 */
static PyObject *Dtool_PortalNode_set_portal_mask_2020(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.set_portal_mask")) {
    return nullptr;
  }
  // 1-inline void PortalNode::set_portal_mask(PortalMask mask)
  BitMask< uint32_t, 32 > arg_local;
  PortalMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PortalNode.set_portal_mask", "BitMask");
  }
  ((*local_this).set_portal_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_portal_mask(const PortalNode self, BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_set_portal_mask_2020_comment =
  "C++ Interface:\n"
  "set_portal_mask(const PortalNode self, BitMask mask)\n"
  "\n"
  "/**\n"
  " * Simultaneously sets both the \"from\" and \"into\" PortalMask values to the\n"
  " * same thing.\n"
  " */";
#else
static const char *Dtool_PortalNode_set_portal_mask_2020_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PortalNode::set_from_portal_mask(PortalMask mask)
 */
static PyObject *Dtool_PortalNode_set_from_portal_mask_2021(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.set_from_portal_mask")) {
    return nullptr;
  }
  // 1-inline void PortalNode::set_from_portal_mask(PortalMask mask)
  BitMask< uint32_t, 32 > arg_local;
  PortalMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PortalNode.set_from_portal_mask", "BitMask");
  }
  ((*local_this).set_from_portal_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_portal_mask(const PortalNode self, BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_set_from_portal_mask_2021_comment =
  "C++ Interface:\n"
  "set_from_portal_mask(const PortalNode self, BitMask mask)\n"
  "\n"
  "/**\n"
  " * Sets the \"from\" PortalMask.  In order for a portal to be detected from this\n"
  " * object into another object, the intersection of this object's \"from\" mask\n"
  " * and the other object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_PortalNode_set_from_portal_mask_2021_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PortalNode::set_into_portal_mask(PortalMask mask)
 */
static PyObject *Dtool_PortalNode_set_into_portal_mask_2022(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.set_into_portal_mask")) {
    return nullptr;
  }
  // 1-inline void PortalNode::set_into_portal_mask(PortalMask mask)
  BitMask< uint32_t, 32 > arg_local;
  PortalMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PortalNode.set_into_portal_mask", "BitMask");
  }
  ((*local_this).set_into_portal_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_into_portal_mask(const PortalNode self, BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_set_into_portal_mask_2022_comment =
  "C++ Interface:\n"
  "set_into_portal_mask(const PortalNode self, BitMask mask)\n"
  "\n"
  "/**\n"
  " * Sets the \"into\" PortalMask.  In order for a portal to be detected from\n"
  " * another object into this object, the intersection of the other object's\n"
  " * \"from\" mask and this object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_PortalNode_set_into_portal_mask_2022_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PortalMask PortalNode::get_from_portal_mask(void) const
 */
static PyObject *Dtool_PortalNode_get_from_portal_mask_2023(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PortalNode)) {
    return nullptr;
  }
  // 1-inline PortalMask PortalNode::get_from_portal_mask(void) const
  PortalMask *return_value = new PortalMask(((*(const PortalNode*)local_this).get_from_portal_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_get_from_portal_mask_2023_comment =
  "C++ Interface:\n"
  "get_from_portal_mask(PortalNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current \"from\" PortalMask.  In order for a portal to be\n"
  " * detected from this object into another object, the intersection of this\n"
  " * object's \"from\" mask and the other object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_PortalNode_get_from_portal_mask_2023_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PortalMask PortalNode::get_into_portal_mask(void) const
 */
static PyObject *Dtool_PortalNode_get_into_portal_mask_2024(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PortalNode)) {
    return nullptr;
  }
  // 1-inline PortalMask PortalNode::get_into_portal_mask(void) const
  PortalMask *return_value = new PortalMask(((*(const PortalNode*)local_this).get_into_portal_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_get_into_portal_mask_2024_comment =
  "C++ Interface:\n"
  "get_into_portal_mask(PortalNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current \"into\" PortalMask.  In order for a portal to be\n"
  " * detected from another object into this object, the intersection of the\n"
  " * other object's \"from\" mask and this object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_PortalNode_get_into_portal_mask_2024_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PortalNode::set_portal_geom(bool flag)
 */
static PyObject *Dtool_PortalNode_set_portal_geom_2025(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.set_portal_geom")) {
    return nullptr;
  }
  // 1-inline void PortalNode::set_portal_geom(bool flag)
  ((*local_this).set_portal_geom)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_portal_geom(const PortalNode self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_set_portal_geom_2025_comment =
  "C++ Interface:\n"
  "set_portal_geom(const PortalNode self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the state of the \"portal geom\" flag for this PortalNode.  Normally,\n"
  " * this is false; when this is set true, the PortalSolids in this node will\n"
  " * test for portals with actual renderable geometry, in addition to whatever\n"
  " * PortalSolids may be indicated by the from_portal_mask.\n"
  " *\n"
  " * Setting this to true causes this to test *all* GeomNodes for portals.  It\n"
  " * is an all-or-none thing; there is no way to portal with only some\n"
  " * GeomNodes, as GeomNodes have no into_portal_mask.\n"
  " */";
#else
static const char *Dtool_PortalNode_set_portal_geom_2025_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PortalNode::get_portal_geom(void) const
 */
static PyObject *Dtool_PortalNode_get_portal_geom_2026(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PortalNode)) {
    return nullptr;
  }
  // 1-inline bool PortalNode::get_portal_geom(void) const
  bool return_value = ((*(const PortalNode*)local_this).get_portal_geom)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_get_portal_geom_2026_comment =
  "C++ Interface:\n"
  "get_portal_geom(PortalNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current state of the portal_geom flag.  See set_portal_geom().\n"
  " */";
#else
static const char *Dtool_PortalNode_get_portal_geom_2026_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PortalNode::clear_vertices(void)
 */
static PyObject *Dtool_PortalNode_clear_vertices_2027(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.clear_vertices")) {
    return nullptr;
  }
  // 1-inline void PortalNode::clear_vertices(void)
  ((*local_this).clear_vertices)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_clear_vertices_2027_comment =
  "C++ Interface:\n"
  "clear_vertices(const PortalNode self)\n"
  "\n"
  "/**\n"
  " * Resets the vertices of the portal to the empty list.\n"
  " */";
#else
static const char *Dtool_PortalNode_clear_vertices_2027_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PortalNode::add_vertex(LPoint3 const &vertex)
 */
static PyObject *Dtool_PortalNode_add_vertex_2028(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.add_vertex")) {
    return nullptr;
  }
  // 1-inline void PortalNode::add_vertex(LPoint3 const &vertex)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PortalNode.add_vertex", "LPoint3f");
  }
  ((*local_this).add_vertex)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const PortalNode self, const LPoint3f vertex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_add_vertex_2028_comment =
  "C++ Interface:\n"
  "add_vertex(const PortalNode self, const LPoint3f vertex)\n"
  "\n"
  "/**\n"
  " * Adds a new vertex to the portal polygon.  The vertices should be defined in\n"
  " * a counterclockwise orientation when viewing through the portal.\n"
  " */";
#else
static const char *Dtool_PortalNode_add_vertex_2028_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PortalNode::get_num_vertices(void) const
 */
static PyObject *Dtool_PortalNode_get_num_vertices_2029(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PortalNode)) {
    return nullptr;
  }
  // 1-inline int PortalNode::get_num_vertices(void) const
  int return_value = ((*(const PortalNode*)local_this).get_num_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_get_num_vertices_2029_comment =
  "C++ Interface:\n"
  "get_num_vertices(PortalNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices in the portal polygon.\n"
  " */";
#else
static const char *Dtool_PortalNode_get_num_vertices_2029_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &PortalNode::get_vertex(int n) const
 */
static PyObject *Dtool_PortalNode_get_vertex_2030(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PortalNode)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &PortalNode::get_vertex(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 const *return_value = &(((*(const PortalNode*)local_this).get_vertex)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(PortalNode self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_get_vertex_2030_comment =
  "C++ Interface:\n"
  "get_vertex(PortalNode self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the portal polygon.\n"
  " */";
#else
static const char *Dtool_PortalNode_get_vertex_2030_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PortalNode::set_cell_in(NodePath const &cell)
 */
static PyObject *Dtool_PortalNode_set_cell_in_2032(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.set_cell_in")) {
    return nullptr;
  }
  // 1-inline void PortalNode::set_cell_in(NodePath const &cell)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PortalNode.set_cell_in", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cell_in)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell_in(const PortalNode self, const NodePath cell)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_set_cell_in_2032_comment =
  "C++ Interface:\n"
  "set_cell_in(const PortalNode self, const NodePath cell)\n"
  "\n"
  "/**\n"
  " * Sets the cell that this portal belongs to\n"
  " */";
#else
static const char *Dtool_PortalNode_set_cell_in_2032_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PortalNode::get_cell_in(void) const
 */
static PyObject *Dtool_PortalNode_get_cell_in_2033(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PortalNode)) {
    return nullptr;
  }
  // 1-inline NodePath PortalNode::get_cell_in(void) const
  NodePath *return_value = new NodePath(((*(const PortalNode*)local_this).get_cell_in)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_get_cell_in_2033_comment =
  "C++ Interface:\n"
  "get_cell_in(PortalNode self)\n"
  "\n"
  "/**\n"
  " * Sets the cell that this portal belongs to\n"
  " */";
#else
static const char *Dtool_PortalNode_get_cell_in_2033_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PortalNode::set_cell_out(NodePath const &cell)
 */
static PyObject *Dtool_PortalNode_set_cell_out_2034(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.set_cell_out")) {
    return nullptr;
  }
  // 1-inline void PortalNode::set_cell_out(NodePath const &cell)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PortalNode.set_cell_out", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cell_out)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell_out(const PortalNode self, const NodePath cell)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_set_cell_out_2034_comment =
  "C++ Interface:\n"
  "set_cell_out(const PortalNode self, const NodePath cell)\n"
  "\n"
  "/**\n"
  " * Sets the cell that this portal leads out to\n"
  " */";
#else
static const char *Dtool_PortalNode_set_cell_out_2034_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PortalNode::get_cell_out(void) const
 */
static PyObject *Dtool_PortalNode_get_cell_out_2035(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PortalNode)) {
    return nullptr;
  }
  // 1-inline NodePath PortalNode::get_cell_out(void) const
  NodePath *return_value = new NodePath(((*(const PortalNode*)local_this).get_cell_out)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_get_cell_out_2035_comment =
  "C++ Interface:\n"
  "get_cell_out(PortalNode self)\n"
  "\n"
  "/**\n"
  " * Sets the cell that this portal leads out to\n"
  " */";
#else
static const char *Dtool_PortalNode_get_cell_out_2035_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PortalNode::set_clip_plane(bool value)
 */
static PyObject *Dtool_PortalNode_set_clip_plane_2036(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.set_clip_plane")) {
    return nullptr;
  }
  // 1-inline void PortalNode::set_clip_plane(bool value)
  ((*local_this).set_clip_plane)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clip_plane(const PortalNode self, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_set_clip_plane_2036_comment =
  "C++ Interface:\n"
  "set_clip_plane(const PortalNode self, bool value)\n"
  "\n"
  "/**\n"
  " * this is set if the portal will clip against its left and right planes\n"
  " */";
#else
static const char *Dtool_PortalNode_set_clip_plane_2036_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PortalNode::is_clip_plane(void)
 */
static PyObject *Dtool_PortalNode_is_clip_plane_2037(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.is_clip_plane")) {
    return nullptr;
  }
  // 1-inline bool PortalNode::is_clip_plane(void)
  bool return_value = ((*local_this).is_clip_plane)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_is_clip_plane_2037_comment =
  "C++ Interface:\n"
  "is_clip_plane(const PortalNode self)\n"
  "\n"
  "/**\n"
  " * Is this portal clipping against its left-right planes\n"
  " */";
#else
static const char *Dtool_PortalNode_is_clip_plane_2037_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PortalNode::set_visible(bool value)
 */
static PyObject *Dtool_PortalNode_set_visible_2038(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.set_visible")) {
    return nullptr;
  }
  // 1-inline void PortalNode::set_visible(bool value)
  ((*local_this).set_visible)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_visible(const PortalNode self, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_set_visible_2038_comment =
  "C++ Interface:\n"
  "set_visible(const PortalNode self, bool value)\n"
  "\n"
  "/**\n"
  " * this is set if the portal is facing camera\n"
  " */";
#else
static const char *Dtool_PortalNode_set_visible_2038_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PortalNode::is_visible(void)
 */
static PyObject *Dtool_PortalNode_is_visible_2039(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.is_visible")) {
    return nullptr;
  }
  // 1-inline bool PortalNode::is_visible(void)
  bool return_value = ((*local_this).is_visible)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_is_visible_2039_comment =
  "C++ Interface:\n"
  "is_visible(const PortalNode self)\n"
  "\n"
  "/**\n"
  " * Is this portal facing the camera\n"
  " */";
#else
static const char *Dtool_PortalNode_is_visible_2039_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PortalNode::set_max_depth(int value)
 */
static PyObject *Dtool_PortalNode_set_max_depth_2040(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.set_max_depth")) {
    return nullptr;
  }
  // 1-inline void PortalNode::set_max_depth(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_max_depth)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_depth(const PortalNode self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_set_max_depth_2040_comment =
  "C++ Interface:\n"
  "set_max_depth(const PortalNode self, int value)\n"
  "\n"
  "/**\n"
  " * Set the maximum depth this portal will be visible at\n"
  " */";
#else
static const char *Dtool_PortalNode_set_max_depth_2040_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PortalNode::get_max_depth(void)
 */
static PyObject *Dtool_PortalNode_get_max_depth_2041(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.get_max_depth")) {
    return nullptr;
  }
  // 1-inline int PortalNode::get_max_depth(void)
  int return_value = ((*local_this).get_max_depth)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_get_max_depth_2041_comment =
  "C++ Interface:\n"
  "get_max_depth(const PortalNode self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum depth this portal will be visible at\n"
  " */";
#else
static const char *Dtool_PortalNode_get_max_depth_2041_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PortalNode::set_open(bool value)
 */
static PyObject *Dtool_PortalNode_set_open_2042(PyObject *self, PyObject *arg) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.set_open")) {
    return nullptr;
  }
  // 1-inline void PortalNode::set_open(bool value)
  ((*local_this).set_open)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_open(const PortalNode self, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_set_open_2042_comment =
  "C++ Interface:\n"
  "set_open(const PortalNode self, bool value)\n"
  "\n"
  "/**\n"
  " * Python sets this based on curent camera zone\n"
  " */";
#else
static const char *Dtool_PortalNode_set_open_2042_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PortalNode::is_open(void)
 */
static PyObject *Dtool_PortalNode_is_open_2043(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.is_open")) {
    return nullptr;
  }
  // 1-inline bool PortalNode::is_open(void)
  bool return_value = ((*local_this).is_open)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_is_open_2043_comment =
  "C++ Interface:\n"
  "is_open(const PortalNode self)\n"
  "\n"
  "/**\n"
  " * Is this portal open from current camera zone\n"
  " */";
#else
static const char *Dtool_PortalNode_is_open_2043_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PortalNode::get_class_type(void)
 */
static PyObject *Dtool_PortalNode_get_class_type_2055(PyObject *, PyObject *) {
  // 1-static TypeHandle PortalNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PortalNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PortalNode_get_class_type_2055_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PortalNode_get_class_type_2055_comment = nullptr;
#endif

static PyObject *Dtool_PortalNode_into_portal_mask_Getter(PyObject *self, void *) {
  const PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PortalNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PortalMask PortalNode::get_into_portal_mask(void) const
  PortalMask *return_value = new PortalMask(((*(const PortalNode*)local_this).get_into_portal_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_PortalNode_into_portal_mask_Setter(PyObject *self, PyObject *arg, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.into_portal_mask")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete into_portal_mask attribute");
    return -1;
  }
  // 1-inline void PortalNode::set_into_portal_mask(PortalMask mask)
  BitMask< uint32_t, 32 > arg_local;
  PortalMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PortalNode.set_into_portal_mask", "BitMask");
    return -1;
  }
  ((*local_this).set_into_portal_mask)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_into_portal_mask(const PortalNode self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_PortalNode_from_portal_mask_Getter(PyObject *self, void *) {
  const PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PortalNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PortalMask PortalNode::get_from_portal_mask(void) const
  PortalMask *return_value = new PortalMask(((*(const PortalNode*)local_this).get_from_portal_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_PortalNode_from_portal_mask_Setter(PyObject *self, PyObject *arg, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.from_portal_mask")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete from_portal_mask attribute");
    return -1;
  }
  // 1-inline void PortalNode::set_from_portal_mask(PortalMask mask)
  BitMask< uint32_t, 32 > arg_local;
  PortalMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PortalNode.set_from_portal_mask", "BitMask");
    return -1;
  }
  ((*local_this).set_from_portal_mask)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_from_portal_mask(const PortalNode self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_PortalNode_portal_geom_Getter(PyObject *self, void *) {
  const PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PortalNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool PortalNode::get_portal_geom(void) const
  bool return_value = ((*(const PortalNode*)local_this).get_portal_geom)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PortalNode_portal_geom_Setter(PyObject *self, PyObject *arg, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.portal_geom")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete portal_geom attribute");
    return -1;
  }
  // 1-inline void PortalNode::set_portal_geom(bool flag)
  ((*local_this).set_portal_geom)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_portal_geom(const PortalNode self, bool flag)\n");
  }
  return -1;
}

/**
 * sequence length function for property PortalNode::vertices
 */
static Py_ssize_t Dtool_PortalNode_vertices_Len(PyObject *self) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PortalNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_vertices)();
}

/**
 * sequence getter for property PortalNode::vertices
 */
static PyObject *Dtool_PortalNode_vertices_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PortalNode, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_vertices)()) {
    PyErr_SetString(PyExc_IndexError, "PortalNode.vertices[] index out of range");
    return nullptr;
  }
  // 1-inline LPoint3 const &PortalNode::get_vertex(int n) const
  LPoint3 const *return_value = &(((*(const PortalNode*)local_this).get_vertex)(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(PortalNode self, index)\n");
  }
}

static PyObject *Dtool_PortalNode_vertices_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "PortalNode.vertices");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_PortalNode_vertices_Len;
    wrap->_getitem_func = &Dtool_PortalNode_vertices_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_PortalNode_cell_in_Getter(PyObject *self, void *) {
  const PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PortalNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath PortalNode::get_cell_in(void) const
  NodePath *return_value = new NodePath(((*(const PortalNode*)local_this).get_cell_in)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

static int Dtool_PortalNode_cell_in_Setter(PyObject *self, PyObject *arg, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.cell_in")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cell_in attribute");
    return -1;
  }
  // 1-inline void PortalNode::set_cell_in(NodePath const &cell)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PortalNode.set_cell_in", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cell_in)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cell_in(const PortalNode self, const NodePath cell)\n");
  }
  return -1;
}

static PyObject *Dtool_PortalNode_cell_out_Getter(PyObject *self, void *) {
  const PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PortalNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath PortalNode::get_cell_out(void) const
  NodePath *return_value = new NodePath(((*(const PortalNode*)local_this).get_cell_out)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

static int Dtool_PortalNode_cell_out_Setter(PyObject *self, PyObject *arg, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.cell_out")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cell_out attribute");
    return -1;
  }
  // 1-inline void PortalNode::set_cell_out(NodePath const &cell)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PortalNode.set_cell_out", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cell_out)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cell_out(const PortalNode self, const NodePath cell)\n");
  }
  return -1;
}

static PyObject *Dtool_PortalNode_clip_plane_Getter(PyObject *self, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.clip_plane")) {
    return nullptr;
  }

  // 1-inline bool PortalNode::is_clip_plane(void)
  bool return_value = ((*local_this).is_clip_plane)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PortalNode_clip_plane_Setter(PyObject *self, PyObject *arg, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.clip_plane")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete clip_plane attribute");
    return -1;
  }
  // 1-inline void PortalNode::set_clip_plane(bool value)
  ((*local_this).set_clip_plane)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_clip_plane(const PortalNode self, bool value)\n");
  }
  return -1;
}

static PyObject *Dtool_PortalNode_visible_Getter(PyObject *self, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.visible")) {
    return nullptr;
  }

  // 1-inline bool PortalNode::is_visible(void)
  bool return_value = ((*local_this).is_visible)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PortalNode_visible_Setter(PyObject *self, PyObject *arg, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.visible")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete visible attribute");
    return -1;
  }
  // 1-inline void PortalNode::set_visible(bool value)
  ((*local_this).set_visible)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_visible(const PortalNode self, bool value)\n");
  }
  return -1;
}

static PyObject *Dtool_PortalNode_max_depth_Getter(PyObject *self, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.max_depth")) {
    return nullptr;
  }

  // 1-inline int PortalNode::get_max_depth(void)
  int return_value = ((*local_this).get_max_depth)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PortalNode_max_depth_Setter(PyObject *self, PyObject *arg, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.max_depth")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_depth attribute");
    return -1;
  }
  // 1-inline void PortalNode::set_max_depth(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_max_depth)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_depth(const PortalNode self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_PortalNode_open_Getter(PyObject *self, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.open")) {
    return nullptr;
  }

  // 1-inline bool PortalNode::is_open(void)
  bool return_value = ((*local_this).is_open)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PortalNode_open_Setter(PyObject *self, PyObject *arg, void *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PortalNode, (void **)&local_this, "PortalNode.open")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete open attribute");
    return -1;
  }
  // 1-inline void PortalNode::set_open(bool value)
  ((*local_this).set_open)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_open(const PortalNode self, bool value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit PortalNode::PortalNode(std::string const &name)
 * explicit PortalNode::PortalNode(std::string const &name, LPoint3 pos, PN_stdfloat scale = 10.0)
 */
static int Dtool_Init_PortalNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
        // 1-explicit PortalNode::PortalNode(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          PortalNode *return_value = new PortalNode(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PortalNode, true, false);
        }
      }
    }
    break;
  case 2:
  case 3:
    {
      // 1-explicit PortalNode::PortalNode(std::string const &name, LPoint3 pos, PN_stdfloat scale = 10.0)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      float param2 = 10.0;
      static const char *keyword_list[] = {"name", "pos", "scale", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O|f:PortalNode", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2)) {
        LPoint3f param1_local;
        LPoint3 *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "PortalNode.PortalNode", "LPoint3f");
          return -1;
        }
        PortalNode *return_value = new PortalNode(std::string(param0_str, param0_len), *param1_this, (PN_stdfloat)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PortalNode, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PortalNode() takes 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PortalNode(str name)\n"
      "PortalNode(str name, LPoint3f pos, float scale)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PortalNode_get_vertices(PyObject *self, PyObject *) {
  PortalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PortalNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_vertices)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PortalNode_get_vertex_2030(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PortalNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PortalNode) {
    printf("PortalNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PortalNode *local_this = (PortalNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PortalNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PortalNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PortalNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PortalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PortalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PortalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PortalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PortalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PortalNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ScissorAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ScissorAttrib::make_off(void)
 */
static PyObject *Dtool_ScissorAttrib_make_off_2057(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ScissorAttrib::make_off(void)
  ConstPointerTo< RenderAttrib > return_value = (ScissorAttrib::make_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ScissorAttrib_make_off_2057_comment =
  "C++ Interface:\n"
  "make_off()\n"
  "\n"
  "/**\n"
  " * Constructs a new ScissorAttrib object that removes the scissor region and\n"
  " * fills the DisplayRegion.\n"
  " */";
#else
static const char *Dtool_ScissorAttrib_make_off_2057_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ScissorAttrib::make(LVecBase4 const &frame)
 * static inline ConstPointerTo< RenderAttrib > ScissorAttrib::make(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_ScissorAttrib_make_2058(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "frame")) {
        // 1-static ConstPointerTo< RenderAttrib > ScissorAttrib::make(LVecBase4 const &frame)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 0, "ScissorAttrib.make", "LVecBase4f");
        }
        ConstPointerTo< RenderAttrib > return_value = (ScissorAttrib::make)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderAttrib const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 4:
    {
      // 1-static inline ConstPointerTo< RenderAttrib > ScissorAttrib::make(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"left", "right", "bottom", "top", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        ConstPointerTo< RenderAttrib > return_value = (ScissorAttrib::make)((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        RenderAttrib const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 1 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const LVecBase4f frame)\n"
      "make(float left, float right, float bottom, float top)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ScissorAttrib_make_2058_comment =
  "C++ Interface:\n"
  "make(const LVecBase4f frame)\n"
  "make(float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Constructs a ScissorAttrib that restricts rendering to the indicated frame\n"
  " * within the current DisplayRegion.  (0,0) is the lower-left corner of the\n"
  " * DisplayRegion, and (1,1) is the upper-right corner.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Constructs a ScissorAttrib that restricts rendering to the indicated frame\n"
  " * within the current DisplayRegion.  (0,0) is the lower-left corner of the\n"
  " * DisplayRegion, and (1,1) is the upper-right corner.\n"
  " */";
#else
static const char *Dtool_ScissorAttrib_make_2058_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ScissorAttrib::make_default(void)
 */
static PyObject *Dtool_ScissorAttrib_make_default_2059(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ScissorAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (ScissorAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ScissorAttrib_make_default_2059_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_ScissorAttrib_make_default_2059_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ScissorAttrib::is_off(void) const
 */
static PyObject *Dtool_ScissorAttrib_is_off_2060(PyObject *self, PyObject *) {
  ScissorAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ScissorAttrib)) {
    return nullptr;
  }
  // 1-inline bool ScissorAttrib::is_off(void) const
  bool return_value = ((*(const ScissorAttrib*)local_this).is_off)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ScissorAttrib_is_off_2060_comment =
  "C++ Interface:\n"
  "is_off(ScissorAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ScissorAttrib is an 'off' ScissorAttrib, indicating\n"
  " * that scissor testing is disabled.\n"
  " */";
#else
static const char *Dtool_ScissorAttrib_is_off_2060_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &ScissorAttrib::get_frame(void) const
 */
static PyObject *Dtool_ScissorAttrib_get_frame_2061(PyObject *self, PyObject *) {
  ScissorAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ScissorAttrib)) {
    return nullptr;
  }
  // 1-inline LVecBase4 const &ScissorAttrib::get_frame(void) const
  LVecBase4 const *return_value = &(((*(const ScissorAttrib*)local_this).get_frame)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ScissorAttrib_get_frame_2061_comment =
  "C++ Interface:\n"
  "get_frame(ScissorAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the left, right, bottom, top coordinates of the scissor frame.\n"
  " * This defines a frame within the current DisplayRegion, where 0,0 is the\n"
  " * lower-left corner of the DisplayRegion, and 1,1 is the upper-right corner.\n"
  " */";
#else
static const char *Dtool_ScissorAttrib_get_frame_2061_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int ScissorAttrib::get_class_slot(void)
 */
static PyObject *Dtool_ScissorAttrib_get_class_slot_2063(PyObject *, PyObject *) {
  // 1-static int ScissorAttrib::get_class_slot(void)
  int return_value = (ScissorAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ScissorAttrib_get_class_slot_2063_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_ScissorAttrib_get_class_slot_2063_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ScissorAttrib::get_class_type(void)
 */
static PyObject *Dtool_ScissorAttrib_get_class_type_2065(PyObject *, PyObject *) {
  // 1-static TypeHandle ScissorAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ScissorAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ScissorAttrib_get_class_type_2065_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ScissorAttrib_get_class_type_2065_comment = nullptr;
#endif

static PyObject *Dtool_ScissorAttrib_frame_Getter(PyObject *self, void *) {
  const ScissorAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ScissorAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase4 const &ScissorAttrib::get_frame(void) const
  LVecBase4 const *return_value = &(((*(const ScissorAttrib*)local_this).get_frame)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static PyObject *Dtool_ScissorAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int ScissorAttrib::get_class_slot(void)
  int return_value = (ScissorAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ScissorAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ScissorAttrib(PyObject *args, CPT(ScissorAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ScissorAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > ScissorAttrib::make(LVecBase4 const &frame)
    LVecBase4 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4f);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = (ScissorAttrib::make)(*arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((ScissorAttrib const *) return_value.p());
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 4) {
      // 1-static inline ConstPointerTo< RenderAttrib > ScissorAttrib::make(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      float param0;
      float param1;
      float param2;
      float param3;
      if (PyArg_ParseTuple(args, "ffff:make", &param0, &param1, &param2, &param3)) {
        ConstPointerTo< RenderAttrib > return_value = (ScissorAttrib::make)((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move((ScissorAttrib const *) return_value.p());
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ScissorAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ScissorAttrib) {
    printf("ScissorAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ScissorAttrib *local_this = (ScissorAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ScissorAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ScissorAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ScissorAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ScissorAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (ScissorAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ScissorAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ScissorAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ScissorAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShadeModelAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ShadeModelAttrib::make(ShadeModelAttrib::Mode mode)
 */
static PyObject *Dtool_ShadeModelAttrib_make_2069(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > ShadeModelAttrib::make(ShadeModelAttrib::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (ShadeModelAttrib::make)((ShadeModelAttrib::Mode)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShadeModelAttrib_make_2069_comment =
  "C++ Interface:\n"
  "make(int mode)\n"
  "\n"
  "/**\n"
  " * Constructs a new ShadeModelAttrib object that specifies whether to draw\n"
  " * polygons with flat shading or with per-vertex (smooth) shading.\n"
  " */";
#else
static const char *Dtool_ShadeModelAttrib_make_2069_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > ShadeModelAttrib::make_default(void)
 */
static PyObject *Dtool_ShadeModelAttrib_make_default_2070(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > ShadeModelAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (ShadeModelAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ShadeModelAttrib_make_default_2070_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_ShadeModelAttrib_make_default_2070_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ShadeModelAttrib::Mode ShadeModelAttrib::get_mode(void) const
 */
static PyObject *Dtool_ShadeModelAttrib_get_mode_2071(PyObject *self, PyObject *) {
  ShadeModelAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShadeModelAttrib)) {
    return nullptr;
  }
  // 1-inline ShadeModelAttrib::Mode ShadeModelAttrib::get_mode(void) const
  ShadeModelAttrib::Mode return_value = ((*(const ShadeModelAttrib*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShadeModelAttrib_get_mode_2071_comment =
  "C++ Interface:\n"
  "get_mode(ShadeModelAttrib self)\n"
  "\n"
  "/**\n"
  " * Returns the shade mode.\n"
  " */";
#else
static const char *Dtool_ShadeModelAttrib_get_mode_2071_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int ShadeModelAttrib::get_class_slot(void)
 */
static PyObject *Dtool_ShadeModelAttrib_get_class_slot_2073(PyObject *, PyObject *) {
  // 1-static int ShadeModelAttrib::get_class_slot(void)
  int return_value = (ShadeModelAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShadeModelAttrib_get_class_slot_2073_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_ShadeModelAttrib_get_class_slot_2073_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ShadeModelAttrib::get_class_type(void)
 */
static PyObject *Dtool_ShadeModelAttrib_get_class_type_2075(PyObject *, PyObject *) {
  // 1-static TypeHandle ShadeModelAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ShadeModelAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShadeModelAttrib_get_class_type_2075_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShadeModelAttrib_get_class_type_2075_comment = nullptr;
#endif

static PyObject *Dtool_ShadeModelAttrib_mode_Getter(PyObject *self, void *) {
  const ShadeModelAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShadeModelAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ShadeModelAttrib::Mode ShadeModelAttrib::get_mode(void) const
  ShadeModelAttrib::Mode return_value = ((*(const ShadeModelAttrib*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ShadeModelAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int ShadeModelAttrib::get_class_slot(void)
  int return_value = (ShadeModelAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ShadeModelAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ShadeModelAttrib(PyObject *args, CPT(ShadeModelAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ShadeModelAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > ShadeModelAttrib::make(ShadeModelAttrib::Mode mode)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ConstPointerTo< RenderAttrib > return_value = (ShadeModelAttrib::make)((ShadeModelAttrib::Mode)arg_val);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((ShadeModelAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ShadeModelAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShadeModelAttrib) {
    printf("ShadeModelAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShadeModelAttrib *local_this = (ShadeModelAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShadeModelAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShadeModelAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShadeModelAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShadeModelAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (ShadeModelAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ShadeModelAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ShadeModelAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ShadeModelAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class StencilAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > StencilAttrib::make_off(void)
 */
static PyObject *Dtool_StencilAttrib_make_off_2081(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > StencilAttrib::make_off(void)
  ConstPointerTo< RenderAttrib > return_value = (StencilAttrib::make_off)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_StencilAttrib_make_off_2081_comment =
  "C++ Interface:\n"
  "make_off()\n"
  "\n"
  "/**\n"
  " * Constructs a StencilAttrib that has stenciling turned off.\n"
  " */";
#else
static const char *Dtool_StencilAttrib_make_off_2081_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > StencilAttrib::make_default(void)
 */
static PyObject *Dtool_StencilAttrib_make_default_2082(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > StencilAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (StencilAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_StencilAttrib_make_default_2082_comment =
  "C++ Interface:\n"
  "make_default()\n"
  "\n"
  "/**\n"
  " * Returns a RenderAttrib that corresponds to whatever the standard default\n"
  " * properties for render attributes of this type ought to be.\n"
  " */";
#else
static const char *Dtool_StencilAttrib_make_default_2082_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > StencilAttrib::make(bool front_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask = (~ (unsigned int)(0)))
 */
static PyObject *Dtool_StencilAttrib_make_2083(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > StencilAttrib::make(bool front_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask = (~ (unsigned int)(0)))
  PyObject *param0;
  int param1;
  int param2;
  int param3;
  int param4;
  unsigned long param5;
  unsigned long param6;
  unsigned long param7 = (~ (unsigned int)(0));
  static const char *keyword_list[] = {"front_enable", "front_comparison_function", "stencil_fail_operation", "stencil_pass_z_fail_operation", "front_stencil_pass_z_pass_operation", "reference", "read_mask", "write_mask", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiiiikk|k:make", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param5 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param5);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param6 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param6);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param7 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param7);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (StencilAttrib::make)((PyObject_IsTrue(param0) != 0), (RenderAttrib::PandaCompareFunc)param1, (StencilAttrib::StencilOperation)param2, (StencilAttrib::StencilOperation)param3, (StencilAttrib::StencilOperation)param4, (unsigned int)param5, (unsigned int)param6, (unsigned int)param7);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(bool front_enable, int front_comparison_function, int stencil_fail_operation, int stencil_pass_z_fail_operation, int front_stencil_pass_z_pass_operation, int reference, int read_mask, int write_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StencilAttrib_make_2083_comment =
  "C++ Interface:\n"
  "make(bool front_enable, int front_comparison_function, int stencil_fail_operation, int stencil_pass_z_fail_operation, int front_stencil_pass_z_pass_operation, int reference, int read_mask, int write_mask)\n"
  "\n"
  "/**\n"
  " * Constructs a front face StencilAttrib.\n"
  " */";
#else
static const char *Dtool_StencilAttrib_make_2083_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > StencilAttrib::make_2_sided(bool front_enable, bool back_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask, RenderAttrib::PandaCompareFunc back_comparison_function, StencilAttrib::StencilOperation back_stencil_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_pass_operation)
 */
static PyObject *Dtool_StencilAttrib_make_2_sided_2084(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > StencilAttrib::make_2_sided(bool front_enable, bool back_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask, RenderAttrib::PandaCompareFunc back_comparison_function, StencilAttrib::StencilOperation back_stencil_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_pass_operation)
  PyObject *param0;
  PyObject *param1;
  int param2;
  int param3;
  int param4;
  int param5;
  unsigned long param6;
  unsigned long param7;
  unsigned long param8;
  int param9;
  int param10;
  int param11;
  int param12;
  static const char *keyword_list[] = {"front_enable", "back_enable", "front_comparison_function", "stencil_fail_operation", "stencil_pass_z_fail_operation", "front_stencil_pass_z_pass_operation", "reference", "read_mask", "write_mask", "back_comparison_function", "back_stencil_fail_operation", "back_stencil_pass_z_fail_operation", "back_stencil_pass_z_pass_operation", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOiiiikkkiiii:make_2_sided", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param6 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param6);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param7 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param7);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param8 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param8);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (StencilAttrib::make_2_sided)((PyObject_IsTrue(param0) != 0), (PyObject_IsTrue(param1) != 0), (RenderAttrib::PandaCompareFunc)param2, (StencilAttrib::StencilOperation)param3, (StencilAttrib::StencilOperation)param4, (StencilAttrib::StencilOperation)param5, (unsigned int)param6, (unsigned int)param7, (unsigned int)param8, (RenderAttrib::PandaCompareFunc)param9, (StencilAttrib::StencilOperation)param10, (StencilAttrib::StencilOperation)param11, (StencilAttrib::StencilOperation)param12);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_2_sided(bool front_enable, bool back_enable, int front_comparison_function, int stencil_fail_operation, int stencil_pass_z_fail_operation, int front_stencil_pass_z_pass_operation, int reference, int read_mask, int write_mask, int back_comparison_function, int back_stencil_fail_operation, int back_stencil_pass_z_fail_operation, int back_stencil_pass_z_pass_operation)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StencilAttrib_make_2_sided_2084_comment =
  "C++ Interface:\n"
  "make_2_sided(bool front_enable, bool back_enable, int front_comparison_function, int stencil_fail_operation, int stencil_pass_z_fail_operation, int front_stencil_pass_z_pass_operation, int reference, int read_mask, int write_mask, int back_comparison_function, int back_stencil_fail_operation, int back_stencil_pass_z_fail_operation, int back_stencil_pass_z_pass_operation)\n"
  "\n"
  "/**\n"
  " * Constructs a two-sided StencilAttrib.\n"
  " */";
#else
static const char *Dtool_StencilAttrib_make_2_sided_2084_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > StencilAttrib::make_with_clear(bool front_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask, bool clear, unsigned int clear_value)
 */
static PyObject *Dtool_StencilAttrib_make_with_clear_2085(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > StencilAttrib::make_with_clear(bool front_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask, bool clear, unsigned int clear_value)
  PyObject *param0;
  int param1;
  int param2;
  int param3;
  int param4;
  unsigned long param5;
  unsigned long param6;
  unsigned long param7;
  PyObject *param8;
  unsigned long param9;
  static const char *keyword_list[] = {"front_enable", "front_comparison_function", "stencil_fail_operation", "stencil_pass_z_fail_operation", "front_stencil_pass_z_pass_operation", "reference", "read_mask", "write_mask", "clear", "clear_value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OiiiikkkOk:make_with_clear", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param5 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param5);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param6 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param6);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param7 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param7);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param9 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param9);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (StencilAttrib::make_with_clear)((PyObject_IsTrue(param0) != 0), (RenderAttrib::PandaCompareFunc)param1, (StencilAttrib::StencilOperation)param2, (StencilAttrib::StencilOperation)param3, (StencilAttrib::StencilOperation)param4, (unsigned int)param5, (unsigned int)param6, (unsigned int)param7, (PyObject_IsTrue(param8) != 0), (unsigned int)param9);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_with_clear(bool front_enable, int front_comparison_function, int stencil_fail_operation, int stencil_pass_z_fail_operation, int front_stencil_pass_z_pass_operation, int reference, int read_mask, int write_mask, bool clear, int clear_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StencilAttrib_make_with_clear_2085_comment =
  "C++ Interface:\n"
  "make_with_clear(bool front_enable, int front_comparison_function, int stencil_fail_operation, int stencil_pass_z_fail_operation, int front_stencil_pass_z_pass_operation, int reference, int read_mask, int write_mask, bool clear, int clear_value)\n"
  "\n"
  "/**\n"
  " * Constructs a front face StencilAttrib.\n"
  " */";
#else
static const char *Dtool_StencilAttrib_make_with_clear_2085_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > StencilAttrib::make_2_sided_with_clear(bool front_enable, bool back_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask, RenderAttrib::PandaCompareFunc back_comparison_function, StencilAttrib::StencilOperation back_stencil_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_pass_operation, bool clear, unsigned int clear_value)
 */
static PyObject *Dtool_StencilAttrib_make_2_sided_with_clear_2086(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > StencilAttrib::make_2_sided_with_clear(bool front_enable, bool back_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask, RenderAttrib::PandaCompareFunc back_comparison_function, StencilAttrib::StencilOperation back_stencil_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_pass_operation, bool clear, unsigned int clear_value)
  PyObject *param0;
  PyObject *param1;
  int param2;
  int param3;
  int param4;
  int param5;
  unsigned long param6;
  unsigned long param7;
  unsigned long param8;
  int param9;
  int param10;
  int param11;
  int param12;
  PyObject *param13;
  unsigned long param14;
  static const char *keyword_list[] = {"front_enable", "back_enable", "front_comparison_function", "stencil_fail_operation", "stencil_pass_z_fail_operation", "front_stencil_pass_z_pass_operation", "reference", "read_mask", "write_mask", "back_comparison_function", "back_stencil_fail_operation", "back_stencil_pass_z_fail_operation", "back_stencil_pass_z_pass_operation", "clear", "clear_value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOiiiikkkiiiiOk:make_2_sided_with_clear", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param6 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param6);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param7 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param7);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param8 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param8);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param14 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param14);
    }
#endif
    ConstPointerTo< RenderAttrib > return_value = (StencilAttrib::make_2_sided_with_clear)((PyObject_IsTrue(param0) != 0), (PyObject_IsTrue(param1) != 0), (RenderAttrib::PandaCompareFunc)param2, (StencilAttrib::StencilOperation)param3, (StencilAttrib::StencilOperation)param4, (StencilAttrib::StencilOperation)param5, (unsigned int)param6, (unsigned int)param7, (unsigned int)param8, (RenderAttrib::PandaCompareFunc)param9, (StencilAttrib::StencilOperation)param10, (StencilAttrib::StencilOperation)param11, (StencilAttrib::StencilOperation)param12, (PyObject_IsTrue(param13) != 0), (unsigned int)param14);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_2_sided_with_clear(bool front_enable, bool back_enable, int front_comparison_function, int stencil_fail_operation, int stencil_pass_z_fail_operation, int front_stencil_pass_z_pass_operation, int reference, int read_mask, int write_mask, int back_comparison_function, int back_stencil_fail_operation, int back_stencil_pass_z_fail_operation, int back_stencil_pass_z_pass_operation, bool clear, int clear_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StencilAttrib_make_2_sided_with_clear_2086_comment =
  "C++ Interface:\n"
  "make_2_sided_with_clear(bool front_enable, bool back_enable, int front_comparison_function, int stencil_fail_operation, int stencil_pass_z_fail_operation, int front_stencil_pass_z_pass_operation, int reference, int read_mask, int write_mask, int back_comparison_function, int back_stencil_fail_operation, int back_stencil_pass_z_fail_operation, int back_stencil_pass_z_pass_operation, bool clear, int clear_value)\n"
  "\n"
  "/**\n"
  " * Constructs a two-sided StencilAttrib.\n"
  " */";
#else
static const char *Dtool_StencilAttrib_make_2_sided_with_clear_2086_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int StencilAttrib::get_render_state(StencilAttrib::StencilRenderState render_state_identifier) const
 */
static PyObject *Dtool_StencilAttrib_get_render_state_2087(PyObject *self, PyObject *arg) {
  StencilAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_StencilAttrib)) {
    return nullptr;
  }
  // 1-inline unsigned int StencilAttrib::get_render_state(StencilAttrib::StencilRenderState render_state_identifier) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    unsigned int return_value = ((*(const StencilAttrib*)local_this).get_render_state)((StencilAttrib::StencilRenderState)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_render_state(StencilAttrib self, int render_state_identifier)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StencilAttrib_get_render_state_2087_comment =
  "C++ Interface:\n"
  "get_render_state(StencilAttrib self, int render_state_identifier)\n"
  "\n"
  "/**\n"
  " * Returns render state.\n"
  " */";
#else
static const char *Dtool_StencilAttrib_get_render_state_2087_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int StencilAttrib::get_class_slot(void)
 */
static PyObject *Dtool_StencilAttrib_get_class_slot_2088(PyObject *, PyObject *) {
  // 1-static int StencilAttrib::get_class_slot(void)
  int return_value = (StencilAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StencilAttrib_get_class_slot_2088_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_StencilAttrib_get_class_slot_2088_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle StencilAttrib::get_class_type(void)
 */
static PyObject *Dtool_StencilAttrib_get_class_type_2090(PyObject *, PyObject *) {
  // 1-static TypeHandle StencilAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((StencilAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_StencilAttrib_get_class_type_2090_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_StencilAttrib_get_class_type_2090_comment = nullptr;
#endif

static PyObject *Dtool_StencilAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int StencilAttrib::get_class_slot(void)
  int return_value = (StencilAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_StencilAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_StencilAttrib(PyObject *args, CPT(StencilAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_StencilAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 7 && size <= 8) {
      // 1-static ConstPointerTo< RenderAttrib > StencilAttrib::make(bool front_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask = (~ (unsigned int)(0)))
      PyObject *param0;
      int param1;
      int param2;
      int param3;
      int param4;
      unsigned long param5;
      unsigned long param6;
      unsigned long param7 = (~ (unsigned int)(0));
      if (PyArg_ParseTuple(args, "Oiiiikk|k:make", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param5 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param5);
          return false;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param6 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param6);
          return false;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param7 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param7);
          return false;
        }
#endif
        ConstPointerTo< RenderAttrib > return_value = (StencilAttrib::make)((PyObject_IsTrue(param0) != 0), (RenderAttrib::PandaCompareFunc)param1, (StencilAttrib::StencilOperation)param2, (StencilAttrib::StencilOperation)param3, (StencilAttrib::StencilOperation)param4, (unsigned int)param5, (unsigned int)param6, (unsigned int)param7);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move((StencilAttrib const *) return_value.p());
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_StencilAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_StencilAttrib) {
    printf("StencilAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  StencilAttrib *local_this = (StencilAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_StencilAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_StencilAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_StencilAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (StencilAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (StencilAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (StencilAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (StencilAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (StencilAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShaderPool
 */
/**
 * Python function wrapper for:
 * static inline bool ShaderPool::has_shader(Filename const &filename)
 */
static PyObject *Dtool_ShaderPool_has_shader_2093(PyObject *, PyObject *arg) {
  // 1-static inline bool ShaderPool::has_shader(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "ShaderPool.has_shader", "Filename");
  }
  bool return_value = (ShaderPool::has_shader)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_shader(const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPool_has_shader_2093_comment =
  "C++ Interface:\n"
  "has_shader(const Filename filename)\n"
  "\n"
  "/**\n"
  " * Returns true if the shader has ever been loaded, false otherwise.\n"
  " */";
#else
static const char *Dtool_ShaderPool_has_shader_2093_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool ShaderPool::verify_shader(Filename const &filename)
 */
static PyObject *Dtool_ShaderPool_verify_shader_2094(PyObject *, PyObject *arg) {
  // 1-static inline bool ShaderPool::verify_shader(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "ShaderPool.verify_shader", "Filename");
  }
  bool return_value = (ShaderPool::verify_shader)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "verify_shader(const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPool_verify_shader_2094_comment =
  "C++ Interface:\n"
  "verify_shader(const Filename filename)\n"
  "\n"
  "/**\n"
  " * Loads the given filename up into a shader, if it has not already been\n"
  " * loaded, and returns true to indicate success, or false to indicate failure.\n"
  " * If this returns true, it is guaranteed that a subsequent call to\n"
  " * load_shader() with the same shader name will return a valid Shader pointer.\n"
  " */";
#else
static const char *Dtool_ShaderPool_verify_shader_2094_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< Shader > ShaderPool::load_shader(Filename const &filename)
 */
static PyObject *Dtool_ShaderPool_load_shader_2095(PyObject *, PyObject *arg) {
  // 1-static inline ConstPointerTo< Shader > ShaderPool::load_shader(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "ShaderPool.load_shader", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ConstPointerTo< Shader > return_value = (ShaderPool::load_shader)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Shader const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Shader, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_shader(const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPool_load_shader_2095_comment =
  "C++ Interface:\n"
  "load_shader(const Filename filename)\n"
  "\n"
  "/**\n"
  " * Loads the given filename up into a shader, if it has not already been\n"
  " * loaded, and returns the new shader.  If a shader with the same filename was\n"
  " * previously loaded, returns that one instead.  If the shader file cannot be\n"
  " * found, returns NULL.\n"
  " */";
#else
static const char *Dtool_ShaderPool_load_shader_2095_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ShaderPool::add_shader(Filename const &filename, Shader *shader)
 */
static PyObject *Dtool_ShaderPool_add_shader_2096(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline void ShaderPool::add_shader(Filename const &filename, Shader *shader)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"filename", "shader", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_shader", (char **)keyword_list, &param0, &param1)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "ShaderPool.add_shader", "Filename");
    }
    PT(Shader) param1_this;
    if (!Dtool_Coerce_Shader(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ShaderPool.add_shader", "Shader");
    }
    (ShaderPool::add_shader)(*param0_this, std::move(param1_this));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_shader(const Filename filename, Shader shader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPool_add_shader_2096_comment =
  "C++ Interface:\n"
  "add_shader(const Filename filename, Shader shader)\n"
  "\n"
  "/**\n"
  " * Adds the indicated already-loaded shader to the pool.  The shader will\n"
  " * always replace any previously-loaded shader in the pool that had the same\n"
  " * filename.\n"
  " */";
#else
static const char *Dtool_ShaderPool_add_shader_2096_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ShaderPool::release_shader(Filename const &filename)
 */
static PyObject *Dtool_ShaderPool_release_shader_2097(PyObject *, PyObject *arg) {
  // 1-static inline void ShaderPool::release_shader(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "ShaderPool.release_shader", "Filename");
  }
  (ShaderPool::release_shader)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_shader(const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPool_release_shader_2097_comment =
  "C++ Interface:\n"
  "release_shader(const Filename filename)\n"
  "\n"
  "/**\n"
  " * Removes the indicated shader from the pool, indicating it will never be\n"
  " * loaded again; the shader may then be freed.  If this function is never\n"
  " * called, a reference count will be maintained on every shader every loaded,\n"
  " * and shaders will never be freed.\n"
  " */";
#else
static const char *Dtool_ShaderPool_release_shader_2097_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ShaderPool::release_all_shaders(void)
 */
static PyObject *Dtool_ShaderPool_release_all_shaders_2098(PyObject *, PyObject *) {
  // 1-static inline void ShaderPool::release_all_shaders(void)
  (ShaderPool::release_all_shaders)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ShaderPool_release_all_shaders_2098_comment =
  "C++ Interface:\n"
  "release_all_shaders()\n"
  "\n"
  "/**\n"
  " * Releases all shaders in the pool and restores the pool to the empty state.\n"
  " */";
#else
static const char *Dtool_ShaderPool_release_all_shaders_2098_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int ShaderPool::garbage_collect(void)
 */
static PyObject *Dtool_ShaderPool_garbage_collect_2099(PyObject *, PyObject *) {
  // 1-static inline int ShaderPool::garbage_collect(void)
  int return_value = (ShaderPool::garbage_collect)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderPool_garbage_collect_2099_comment =
  "C++ Interface:\n"
  "garbage_collect()\n"
  "\n"
  "/**\n"
  " * Releases only those shaders in the pool that have a reference count of\n"
  " * exactly 1; i.e.  only those shaders that are not being used outside of the\n"
  " * pool.  Returns the number of shaders released.\n"
  " */";
#else
static const char *Dtool_ShaderPool_garbage_collect_2099_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ShaderPool::list_contents(std::ostream &out)
 */
static PyObject *Dtool_ShaderPool_list_contents_2100(PyObject *, PyObject *arg) {
  // 1-static inline void ShaderPool::list_contents(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "ShaderPool.list_contents", false, true);
  if (arg_this != nullptr) {
    (ShaderPool::list_contents)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_contents(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPool_list_contents_2100_comment =
  "C++ Interface:\n"
  "list_contents(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the shader pool to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_ShaderPool_list_contents_2100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void ShaderPool::write(std::ostream &out)
 */
static PyObject *Dtool_ShaderPool_write_2101(PyObject *, PyObject *arg) {
  // 1-static void ShaderPool::write(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "ShaderPool.write", false, true);
  if (arg_this != nullptr) {
    (ShaderPool::write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPool_write_2101_comment =
  "C++ Interface:\n"
  "write(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the shader pool to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_ShaderPool_write_2101_comment = nullptr;
#endif

static int Dtool_Init_ShaderPool(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ShaderPool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShaderPool) {
    printf("ShaderPool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShaderPool *local_this = (ShaderPool *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShaderPool) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShaderPool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShaderPool) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for TransformState (TransformState)
 */
static PyMethodDef Dtool_Methods_TransformState[] = {
  {"compare_to", &Dtool_TransformState_compare_to_4, METH_VARARGS, (const char *)Dtool_TransformState_compare_to_4_comment},
  {"compareTo", &Dtool_TransformState_compare_to_4, METH_VARARGS, (const char *)Dtool_TransformState_compare_to_4_comment},
  {"get_hash", &Dtool_TransformState_get_hash_6, METH_NOARGS, (const char *)Dtool_TransformState_get_hash_6_comment},
  {"getHash", &Dtool_TransformState_get_hash_6, METH_NOARGS, (const char *)Dtool_TransformState_get_hash_6_comment},
  {"make_identity", &Dtool_TransformState_make_identity_7, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_make_identity_7_comment},
  {"makeIdentity", &Dtool_TransformState_make_identity_7, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_make_identity_7_comment},
  {"make_invalid", &Dtool_TransformState_make_invalid_8, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_make_invalid_8_comment},
  {"makeInvalid", &Dtool_TransformState_make_invalid_8, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_make_invalid_8_comment},
  {"make_pos", &Dtool_TransformState_make_pos_9, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_pos_9_comment},
  {"makePos", &Dtool_TransformState_make_pos_9, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_pos_9_comment},
  {"make_hpr", &Dtool_TransformState_make_hpr_10, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_hpr_10_comment},
  {"makeHpr", &Dtool_TransformState_make_hpr_10, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_hpr_10_comment},
  {"make_quat", &Dtool_TransformState_make_quat_11, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_quat_11_comment},
  {"makeQuat", &Dtool_TransformState_make_quat_11, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_quat_11_comment},
  {"make_pos_hpr", (PyCFunction) &Dtool_TransformState_make_pos_hpr_12, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_hpr_12_comment},
  {"makePosHpr", (PyCFunction) &Dtool_TransformState_make_pos_hpr_12, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_hpr_12_comment},
  {"make_scale", &Dtool_TransformState_make_scale_13, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_scale_13_comment},
  {"makeScale", &Dtool_TransformState_make_scale_13, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_scale_13_comment},
  {"make_shear", &Dtool_TransformState_make_shear_14, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_shear_14_comment},
  {"makeShear", &Dtool_TransformState_make_shear_14, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_shear_14_comment},
  {"make_pos_hpr_scale", (PyCFunction) &Dtool_TransformState_make_pos_hpr_scale_15, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_hpr_scale_15_comment},
  {"makePosHprScale", (PyCFunction) &Dtool_TransformState_make_pos_hpr_scale_15, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_hpr_scale_15_comment},
  {"make_pos_quat_scale", (PyCFunction) &Dtool_TransformState_make_pos_quat_scale_16, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_quat_scale_16_comment},
  {"makePosQuatScale", (PyCFunction) &Dtool_TransformState_make_pos_quat_scale_16, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_quat_scale_16_comment},
  {"make_pos_hpr_scale_shear", (PyCFunction) &Dtool_TransformState_make_pos_hpr_scale_shear_17, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_hpr_scale_shear_17_comment},
  {"makePosHprScaleShear", (PyCFunction) &Dtool_TransformState_make_pos_hpr_scale_shear_17, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_hpr_scale_shear_17_comment},
  {"make_pos_quat_scale_shear", (PyCFunction) &Dtool_TransformState_make_pos_quat_scale_shear_18, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_quat_scale_shear_18_comment},
  {"makePosQuatScaleShear", (PyCFunction) &Dtool_TransformState_make_pos_quat_scale_shear_18, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_quat_scale_shear_18_comment},
  {"make_mat", &Dtool_TransformState_make_mat_19, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_mat_19_comment},
  {"makeMat", &Dtool_TransformState_make_mat_19, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_mat_19_comment},
  {"make_pos2d", &Dtool_TransformState_make_pos2d_20, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_pos2d_20_comment},
  {"makePos2d", &Dtool_TransformState_make_pos2d_20, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_pos2d_20_comment},
  {"make_rotate2d", &Dtool_TransformState_make_rotate2d_21, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_rotate2d_21_comment},
  {"makeRotate2d", &Dtool_TransformState_make_rotate2d_21, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_rotate2d_21_comment},
  {"make_pos_rotate2d", (PyCFunction) &Dtool_TransformState_make_pos_rotate2d_22, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_rotate2d_22_comment},
  {"makePosRotate2d", (PyCFunction) &Dtool_TransformState_make_pos_rotate2d_22, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_rotate2d_22_comment},
  {"make_scale2d", &Dtool_TransformState_make_scale2d_23, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_scale2d_23_comment},
  {"makeScale2d", &Dtool_TransformState_make_scale2d_23, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_scale2d_23_comment},
  {"make_shear2d", &Dtool_TransformState_make_shear2d_24, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_shear2d_24_comment},
  {"makeShear2d", &Dtool_TransformState_make_shear2d_24, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_shear2d_24_comment},
  {"make_pos_rotate_scale2d", (PyCFunction) &Dtool_TransformState_make_pos_rotate_scale2d_25, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_rotate_scale2d_25_comment},
  {"makePosRotateScale2d", (PyCFunction) &Dtool_TransformState_make_pos_rotate_scale2d_25, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_rotate_scale2d_25_comment},
  {"make_pos_rotate_scale_shear2d", (PyCFunction) &Dtool_TransformState_make_pos_rotate_scale_shear2d_26, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_rotate_scale_shear2d_26_comment},
  {"makePosRotateScaleShear2d", (PyCFunction) &Dtool_TransformState_make_pos_rotate_scale_shear2d_26, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TransformState_make_pos_rotate_scale_shear2d_26_comment},
  {"make_mat3", &Dtool_TransformState_make_mat3_27, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_mat3_27_comment},
  {"makeMat3", &Dtool_TransformState_make_mat3_27, METH_O | METH_STATIC, (const char *)Dtool_TransformState_make_mat3_27_comment},
  {"is_identity", &Dtool_TransformState_is_identity_28, METH_NOARGS, (const char *)Dtool_TransformState_is_identity_28_comment},
  {"isIdentity", &Dtool_TransformState_is_identity_28, METH_NOARGS, (const char *)Dtool_TransformState_is_identity_28_comment},
  {"is_invalid", &Dtool_TransformState_is_invalid_29, METH_NOARGS, (const char *)Dtool_TransformState_is_invalid_29_comment},
  {"isInvalid", &Dtool_TransformState_is_invalid_29, METH_NOARGS, (const char *)Dtool_TransformState_is_invalid_29_comment},
  {"is_singular", &Dtool_TransformState_is_singular_30, METH_NOARGS, (const char *)Dtool_TransformState_is_singular_30_comment},
  {"isSingular", &Dtool_TransformState_is_singular_30, METH_NOARGS, (const char *)Dtool_TransformState_is_singular_30_comment},
  {"is_2d", &Dtool_TransformState_is_2d_31, METH_NOARGS, (const char *)Dtool_TransformState_is_2d_31_comment},
  {"is2d", &Dtool_TransformState_is_2d_31, METH_NOARGS, (const char *)Dtool_TransformState_is_2d_31_comment},
  {"has_components", &Dtool_TransformState_has_components_32, METH_NOARGS, (const char *)Dtool_TransformState_has_components_32_comment},
  {"hasComponents", &Dtool_TransformState_has_components_32, METH_NOARGS, (const char *)Dtool_TransformState_has_components_32_comment},
  {"components_given", &Dtool_TransformState_components_given_33, METH_NOARGS, (const char *)Dtool_TransformState_components_given_33_comment},
  {"componentsGiven", &Dtool_TransformState_components_given_33, METH_NOARGS, (const char *)Dtool_TransformState_components_given_33_comment},
  {"hpr_given", &Dtool_TransformState_hpr_given_34, METH_NOARGS, (const char *)Dtool_TransformState_hpr_given_34_comment},
  {"hprGiven", &Dtool_TransformState_hpr_given_34, METH_NOARGS, (const char *)Dtool_TransformState_hpr_given_34_comment},
  {"quat_given", &Dtool_TransformState_quat_given_35, METH_NOARGS, (const char *)Dtool_TransformState_quat_given_35_comment},
  {"quatGiven", &Dtool_TransformState_quat_given_35, METH_NOARGS, (const char *)Dtool_TransformState_quat_given_35_comment},
  {"has_pos", &Dtool_TransformState_has_pos_36, METH_NOARGS, (const char *)Dtool_TransformState_has_pos_36_comment},
  {"hasPos", &Dtool_TransformState_has_pos_36, METH_NOARGS, (const char *)Dtool_TransformState_has_pos_36_comment},
  {"has_hpr", &Dtool_TransformState_has_hpr_37, METH_NOARGS, (const char *)Dtool_TransformState_has_hpr_37_comment},
  {"hasHpr", &Dtool_TransformState_has_hpr_37, METH_NOARGS, (const char *)Dtool_TransformState_has_hpr_37_comment},
  {"has_quat", &Dtool_TransformState_has_quat_38, METH_NOARGS, (const char *)Dtool_TransformState_has_quat_38_comment},
  {"hasQuat", &Dtool_TransformState_has_quat_38, METH_NOARGS, (const char *)Dtool_TransformState_has_quat_38_comment},
  {"has_scale", &Dtool_TransformState_has_scale_39, METH_NOARGS, (const char *)Dtool_TransformState_has_scale_39_comment},
  {"hasScale", &Dtool_TransformState_has_scale_39, METH_NOARGS, (const char *)Dtool_TransformState_has_scale_39_comment},
  {"has_identity_scale", &Dtool_TransformState_has_identity_scale_40, METH_NOARGS, (const char *)Dtool_TransformState_has_identity_scale_40_comment},
  {"hasIdentityScale", &Dtool_TransformState_has_identity_scale_40, METH_NOARGS, (const char *)Dtool_TransformState_has_identity_scale_40_comment},
  {"has_uniform_scale", &Dtool_TransformState_has_uniform_scale_41, METH_NOARGS, (const char *)Dtool_TransformState_has_uniform_scale_41_comment},
  {"hasUniformScale", &Dtool_TransformState_has_uniform_scale_41, METH_NOARGS, (const char *)Dtool_TransformState_has_uniform_scale_41_comment},
  {"has_shear", &Dtool_TransformState_has_shear_42, METH_NOARGS, (const char *)Dtool_TransformState_has_shear_42_comment},
  {"hasShear", &Dtool_TransformState_has_shear_42, METH_NOARGS, (const char *)Dtool_TransformState_has_shear_42_comment},
  {"has_nonzero_shear", &Dtool_TransformState_has_nonzero_shear_43, METH_NOARGS, (const char *)Dtool_TransformState_has_nonzero_shear_43_comment},
  {"hasNonzeroShear", &Dtool_TransformState_has_nonzero_shear_43, METH_NOARGS, (const char *)Dtool_TransformState_has_nonzero_shear_43_comment},
  {"has_mat", &Dtool_TransformState_has_mat_44, METH_NOARGS, (const char *)Dtool_TransformState_has_mat_44_comment},
  {"hasMat", &Dtool_TransformState_has_mat_44, METH_NOARGS, (const char *)Dtool_TransformState_has_mat_44_comment},
  {"get_pos", &Dtool_TransformState_get_pos_45, METH_NOARGS, (const char *)Dtool_TransformState_get_pos_45_comment},
  {"getPos", &Dtool_TransformState_get_pos_45, METH_NOARGS, (const char *)Dtool_TransformState_get_pos_45_comment},
  {"get_hpr", &Dtool_TransformState_get_hpr_46, METH_NOARGS, (const char *)Dtool_TransformState_get_hpr_46_comment},
  {"getHpr", &Dtool_TransformState_get_hpr_46, METH_NOARGS, (const char *)Dtool_TransformState_get_hpr_46_comment},
  {"get_quat", &Dtool_TransformState_get_quat_47, METH_NOARGS, (const char *)Dtool_TransformState_get_quat_47_comment},
  {"getQuat", &Dtool_TransformState_get_quat_47, METH_NOARGS, (const char *)Dtool_TransformState_get_quat_47_comment},
  {"get_norm_quat", &Dtool_TransformState_get_norm_quat_48, METH_NOARGS, (const char *)Dtool_TransformState_get_norm_quat_48_comment},
  {"getNormQuat", &Dtool_TransformState_get_norm_quat_48, METH_NOARGS, (const char *)Dtool_TransformState_get_norm_quat_48_comment},
  {"get_scale", &Dtool_TransformState_get_scale_49, METH_NOARGS, (const char *)Dtool_TransformState_get_scale_49_comment},
  {"getScale", &Dtool_TransformState_get_scale_49, METH_NOARGS, (const char *)Dtool_TransformState_get_scale_49_comment},
  {"get_uniform_scale", &Dtool_TransformState_get_uniform_scale_50, METH_NOARGS, (const char *)Dtool_TransformState_get_uniform_scale_50_comment},
  {"getUniformScale", &Dtool_TransformState_get_uniform_scale_50, METH_NOARGS, (const char *)Dtool_TransformState_get_uniform_scale_50_comment},
  {"get_shear", &Dtool_TransformState_get_shear_51, METH_NOARGS, (const char *)Dtool_TransformState_get_shear_51_comment},
  {"getShear", &Dtool_TransformState_get_shear_51, METH_NOARGS, (const char *)Dtool_TransformState_get_shear_51_comment},
  {"get_mat", &Dtool_TransformState_get_mat_52, METH_NOARGS, (const char *)Dtool_TransformState_get_mat_52_comment},
  {"getMat", &Dtool_TransformState_get_mat_52, METH_NOARGS, (const char *)Dtool_TransformState_get_mat_52_comment},
  {"get_pos2d", &Dtool_TransformState_get_pos2d_53, METH_NOARGS, (const char *)Dtool_TransformState_get_pos2d_53_comment},
  {"getPos2d", &Dtool_TransformState_get_pos2d_53, METH_NOARGS, (const char *)Dtool_TransformState_get_pos2d_53_comment},
  {"get_rotate2d", &Dtool_TransformState_get_rotate2d_54, METH_NOARGS, (const char *)Dtool_TransformState_get_rotate2d_54_comment},
  {"getRotate2d", &Dtool_TransformState_get_rotate2d_54, METH_NOARGS, (const char *)Dtool_TransformState_get_rotate2d_54_comment},
  {"get_scale2d", &Dtool_TransformState_get_scale2d_55, METH_NOARGS, (const char *)Dtool_TransformState_get_scale2d_55_comment},
  {"getScale2d", &Dtool_TransformState_get_scale2d_55, METH_NOARGS, (const char *)Dtool_TransformState_get_scale2d_55_comment},
  {"get_shear2d", &Dtool_TransformState_get_shear2d_56, METH_NOARGS, (const char *)Dtool_TransformState_get_shear2d_56_comment},
  {"getShear2d", &Dtool_TransformState_get_shear2d_56, METH_NOARGS, (const char *)Dtool_TransformState_get_shear2d_56_comment},
  {"get_mat3", &Dtool_TransformState_get_mat3_57, METH_NOARGS, (const char *)Dtool_TransformState_get_mat3_57_comment},
  {"getMat3", &Dtool_TransformState_get_mat3_57, METH_NOARGS, (const char *)Dtool_TransformState_get_mat3_57_comment},
  {"set_pos", &Dtool_TransformState_set_pos_77, METH_O, (const char *)Dtool_TransformState_set_pos_77_comment},
  {"setPos", &Dtool_TransformState_set_pos_77, METH_O, (const char *)Dtool_TransformState_set_pos_77_comment},
  {"set_hpr", &Dtool_TransformState_set_hpr_78, METH_O, (const char *)Dtool_TransformState_set_hpr_78_comment},
  {"setHpr", &Dtool_TransformState_set_hpr_78, METH_O, (const char *)Dtool_TransformState_set_hpr_78_comment},
  {"set_quat", &Dtool_TransformState_set_quat_79, METH_O, (const char *)Dtool_TransformState_set_quat_79_comment},
  {"setQuat", &Dtool_TransformState_set_quat_79, METH_O, (const char *)Dtool_TransformState_set_quat_79_comment},
  {"set_scale", &Dtool_TransformState_set_scale_80, METH_O, (const char *)Dtool_TransformState_set_scale_80_comment},
  {"setScale", &Dtool_TransformState_set_scale_80, METH_O, (const char *)Dtool_TransformState_set_scale_80_comment},
  {"set_shear", &Dtool_TransformState_set_shear_81, METH_O, (const char *)Dtool_TransformState_set_shear_81_comment},
  {"setShear", &Dtool_TransformState_set_shear_81, METH_O, (const char *)Dtool_TransformState_set_shear_81_comment},
  {"set_pos2d", &Dtool_TransformState_set_pos2d_82, METH_O, (const char *)Dtool_TransformState_set_pos2d_82_comment},
  {"setPos2d", &Dtool_TransformState_set_pos2d_82, METH_O, (const char *)Dtool_TransformState_set_pos2d_82_comment},
  {"set_rotate2d", &Dtool_TransformState_set_rotate2d_83, METH_O, (const char *)Dtool_TransformState_set_rotate2d_83_comment},
  {"setRotate2d", &Dtool_TransformState_set_rotate2d_83, METH_O, (const char *)Dtool_TransformState_set_rotate2d_83_comment},
  {"set_scale2d", &Dtool_TransformState_set_scale2d_84, METH_O, (const char *)Dtool_TransformState_set_scale2d_84_comment},
  {"setScale2d", &Dtool_TransformState_set_scale2d_84, METH_O, (const char *)Dtool_TransformState_set_scale2d_84_comment},
  {"set_shear2d", &Dtool_TransformState_set_shear2d_85, METH_O, (const char *)Dtool_TransformState_set_shear2d_85_comment},
  {"setShear2d", &Dtool_TransformState_set_shear2d_85, METH_O, (const char *)Dtool_TransformState_set_shear2d_85_comment},
  {"compose", &Dtool_TransformState_compose_86, METH_O, (const char *)Dtool_TransformState_compose_86_comment},
  {"invert_compose", &Dtool_TransformState_invert_compose_87, METH_O, (const char *)Dtool_TransformState_invert_compose_87_comment},
  {"invertCompose", &Dtool_TransformState_invert_compose_87, METH_O, (const char *)Dtool_TransformState_invert_compose_87_comment},
  {"get_inverse", &Dtool_TransformState_get_inverse_88, METH_NOARGS, (const char *)Dtool_TransformState_get_inverse_88_comment},
  {"getInverse", &Dtool_TransformState_get_inverse_88, METH_NOARGS, (const char *)Dtool_TransformState_get_inverse_88_comment},
  {"get_unique", &Dtool_TransformState_get_unique_89, METH_NOARGS, (const char *)Dtool_TransformState_get_unique_89_comment},
  {"getUnique", &Dtool_TransformState_get_unique_89, METH_NOARGS, (const char *)Dtool_TransformState_get_unique_89_comment},
  {"get_geom_rendering", &Dtool_TransformState_get_geom_rendering_90, METH_O, (const char *)Dtool_TransformState_get_geom_rendering_90_comment},
  {"getGeomRendering", &Dtool_TransformState_get_geom_rendering_90, METH_O, (const char *)Dtool_TransformState_get_geom_rendering_90_comment},
  {"cache_ref", &Dtool_TransformState_cache_ref_91, METH_NOARGS, (const char *)Dtool_TransformState_cache_ref_91_comment},
  {"cacheRef", &Dtool_TransformState_cache_ref_91, METH_NOARGS, (const char *)Dtool_TransformState_cache_ref_91_comment},
  {"cache_unref", &Dtool_TransformState_cache_unref_92, METH_NOARGS, (const char *)Dtool_TransformState_cache_unref_92_comment},
  {"cacheUnref", &Dtool_TransformState_cache_unref_92, METH_NOARGS, (const char *)Dtool_TransformState_cache_unref_92_comment},
  {"node_ref", &Dtool_TransformState_node_ref_93, METH_NOARGS, (const char *)Dtool_TransformState_node_ref_93_comment},
  {"nodeRef", &Dtool_TransformState_node_ref_93, METH_NOARGS, (const char *)Dtool_TransformState_node_ref_93_comment},
  {"node_unref", &Dtool_TransformState_node_unref_94, METH_NOARGS, (const char *)Dtool_TransformState_node_unref_94_comment},
  {"nodeUnref", &Dtool_TransformState_node_unref_94, METH_NOARGS, (const char *)Dtool_TransformState_node_unref_94_comment},
  {"get_composition_cache_num_entries", &Dtool_TransformState_get_composition_cache_num_entries_95, METH_NOARGS, (const char *)Dtool_TransformState_get_composition_cache_num_entries_95_comment},
  {"getCompositionCacheNumEntries", &Dtool_TransformState_get_composition_cache_num_entries_95, METH_NOARGS, (const char *)Dtool_TransformState_get_composition_cache_num_entries_95_comment},
  {"get_invert_composition_cache_num_entries", &Dtool_TransformState_get_invert_composition_cache_num_entries_96, METH_NOARGS, (const char *)Dtool_TransformState_get_invert_composition_cache_num_entries_96_comment},
  {"getInvertCompositionCacheNumEntries", &Dtool_TransformState_get_invert_composition_cache_num_entries_96, METH_NOARGS, (const char *)Dtool_TransformState_get_invert_composition_cache_num_entries_96_comment},
  {"get_composition_cache_size", &Dtool_TransformState_get_composition_cache_size_97, METH_NOARGS, (const char *)Dtool_TransformState_get_composition_cache_size_97_comment},
  {"getCompositionCacheSize", &Dtool_TransformState_get_composition_cache_size_97, METH_NOARGS, (const char *)Dtool_TransformState_get_composition_cache_size_97_comment},
  {"get_composition_cache_source", &Dtool_TransformState_get_composition_cache_source_98, METH_O, (const char *)Dtool_TransformState_get_composition_cache_source_98_comment},
  {"getCompositionCacheSource", &Dtool_TransformState_get_composition_cache_source_98, METH_O, (const char *)Dtool_TransformState_get_composition_cache_source_98_comment},
  {"get_composition_cache_result", &Dtool_TransformState_get_composition_cache_result_99, METH_O, (const char *)Dtool_TransformState_get_composition_cache_result_99_comment},
  {"getCompositionCacheResult", &Dtool_TransformState_get_composition_cache_result_99, METH_O, (const char *)Dtool_TransformState_get_composition_cache_result_99_comment},
  {"get_invert_composition_cache_size", &Dtool_TransformState_get_invert_composition_cache_size_100, METH_NOARGS, (const char *)Dtool_TransformState_get_invert_composition_cache_size_100_comment},
  {"getInvertCompositionCacheSize", &Dtool_TransformState_get_invert_composition_cache_size_100, METH_NOARGS, (const char *)Dtool_TransformState_get_invert_composition_cache_size_100_comment},
  {"get_invert_composition_cache_source", &Dtool_TransformState_get_invert_composition_cache_source_101, METH_O, (const char *)Dtool_TransformState_get_invert_composition_cache_source_101_comment},
  {"getInvertCompositionCacheSource", &Dtool_TransformState_get_invert_composition_cache_source_101, METH_O, (const char *)Dtool_TransformState_get_invert_composition_cache_source_101_comment},
  {"get_invert_composition_cache_result", &Dtool_TransformState_get_invert_composition_cache_result_102, METH_O, (const char *)Dtool_TransformState_get_invert_composition_cache_result_102_comment},
  {"getInvertCompositionCacheResult", &Dtool_TransformState_get_invert_composition_cache_result_102, METH_O, (const char *)Dtool_TransformState_get_invert_composition_cache_result_102_comment},
  {"validate_composition_cache", &Dtool_TransformState_validate_composition_cache_103, METH_NOARGS, (const char *)Dtool_TransformState_validate_composition_cache_103_comment},
  {"validateCompositionCache", &Dtool_TransformState_validate_composition_cache_103, METH_NOARGS, (const char *)Dtool_TransformState_validate_composition_cache_103_comment},
  {"get_composition_cache", &Dtool_TransformState_get_composition_cache_104, METH_NOARGS, (const char *)Dtool_TransformState_get_composition_cache_104_comment},
  {"getCompositionCache", &Dtool_TransformState_get_composition_cache_104, METH_NOARGS, (const char *)Dtool_TransformState_get_composition_cache_104_comment},
  {"get_invert_composition_cache", &Dtool_TransformState_get_invert_composition_cache_105, METH_NOARGS, (const char *)Dtool_TransformState_get_invert_composition_cache_105_comment},
  {"getInvertCompositionCache", &Dtool_TransformState_get_invert_composition_cache_105, METH_NOARGS, (const char *)Dtool_TransformState_get_invert_composition_cache_105_comment},
  {"output", &Dtool_TransformState_output_106, METH_O, (const char *)Dtool_TransformState_output_106_comment},
  {"write", (PyCFunction) &Dtool_TransformState_write_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformState_write_107_comment},
  {"write_composition_cache", (PyCFunction) &Dtool_TransformState_write_composition_cache_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformState_write_composition_cache_108_comment},
  {"writeCompositionCache", (PyCFunction) &Dtool_TransformState_write_composition_cache_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformState_write_composition_cache_108_comment},
  {"get_num_states", &Dtool_TransformState_get_num_states_109, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_get_num_states_109_comment},
  {"getNumStates", &Dtool_TransformState_get_num_states_109, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_get_num_states_109_comment},
  {"get_num_unused_states", &Dtool_TransformState_get_num_unused_states_110, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_get_num_unused_states_110_comment},
  {"getNumUnusedStates", &Dtool_TransformState_get_num_unused_states_110, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_get_num_unused_states_110_comment},
  {"clear_cache", &Dtool_TransformState_clear_cache_111, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_clear_cache_111_comment},
  {"clearCache", &Dtool_TransformState_clear_cache_111, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_clear_cache_111_comment},
  {"garbage_collect", &Dtool_TransformState_garbage_collect_112, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_garbage_collect_112_comment},
  {"garbageCollect", &Dtool_TransformState_garbage_collect_112, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_garbage_collect_112_comment},
  {"list_cycles", &Dtool_TransformState_list_cycles_113, METH_O | METH_STATIC, (const char *)Dtool_TransformState_list_cycles_113_comment},
  {"listCycles", &Dtool_TransformState_list_cycles_113, METH_O | METH_STATIC, (const char *)Dtool_TransformState_list_cycles_113_comment},
  {"list_states", &Dtool_TransformState_list_states_114, METH_O | METH_STATIC, (const char *)Dtool_TransformState_list_states_114_comment},
  {"listStates", &Dtool_TransformState_list_states_114, METH_O | METH_STATIC, (const char *)Dtool_TransformState_list_states_114_comment},
  {"validate_states", &Dtool_TransformState_validate_states_115, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_validate_states_115_comment},
  {"validateStates", &Dtool_TransformState_validate_states_115, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_validate_states_115_comment},
  {"get_states", &Dtool_TransformState_get_states_116, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_get_states_116_comment},
  {"getStates", &Dtool_TransformState_get_states_116, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_get_states_116_comment},
  {"get_unused_states", &Dtool_TransformState_get_unused_states_117, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_get_unused_states_117_comment},
  {"getUnusedStates", &Dtool_TransformState_get_unused_states_117, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_get_unused_states_117_comment},
  {"get_class_type", &Dtool_TransformState_get_class_type_118, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_get_class_type_118_comment},
  {"getClassType", &Dtool_TransformState_get_class_type_118, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformState_get_class_type_118_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TransformState slot tp_compare -> compare_to
//////////////////
static int Dtool_TransformState_compare_to_4_tp_compare(PyObject *self, PyObject *arg) {
  TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int TransformState::compare_to(TransformState const &other) const
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "TransformState.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const TransformState*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(TransformState self, const TransformState other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TransformState slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_TransformState_get_hash_6_tp_hash(PyObject *self) {
  TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_hash)();
}

//////////////////
//  A __repr__ function
//     TransformState
//////////////////
static PyObject *Dtool_Repr_TransformState(PyObject *self) {
  TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     TransformState
//////////////////
static PyObject *Dtool_Str_TransformState(PyObject *self) {
  TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     TransformState
//////////////////
static PyObject *Dtool_RichCompare_TransformState(PyObject *self, PyObject *arg, int op) {
  TransformState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformState, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_NE:
    {
      // 1-inline bool TransformState::operator !=(TransformState const &other) const
      TransformState const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TransformState);
      if (arg_this != nullptr) {
        bool return_value = ((*(const TransformState*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-bool TransformState::operator ==(TransformState const &other) const
      TransformState const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TransformState);
      if (arg_this != nullptr) {
        bool return_value = ((*(const TransformState*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_TransformState_compare_to_4_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_TransformState[] = {
  {(char *)"pos", &Dtool_TransformState_pos_Getter, nullptr, nullptr, nullptr},
  {(char *)"hpr", &Dtool_TransformState_hpr_Getter, nullptr, nullptr, nullptr},
  {(char *)"quat", &Dtool_TransformState_quat_Getter, nullptr, nullptr, nullptr},
  {(char *)"norm_quat", &Dtool_TransformState_norm_quat_Getter, nullptr, nullptr, nullptr},
  {(char *)"scale", &Dtool_TransformState_scale_Getter, nullptr, nullptr, nullptr},
  {(char *)"shear", &Dtool_TransformState_shear_Getter, nullptr, nullptr, nullptr},
  {(char *)"mat", &Dtool_TransformState_mat_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TransformState = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TransformState = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TransformState = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TransformState = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TransformState = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TransformState = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TransformState",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TransformState,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TransformState,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_TransformState_compare_to_4_tp_compare,
#endif
    &Dtool_Repr_TransformState,
    &Dtool_NumberMethods_TransformState,
    &Dtool_SequenceMethods_TransformState,
    &Dtool_MappingMethods_TransformState,
    &Dtool_TransformState_get_hash_6_tp_hash,
    nullptr,
    &Dtool_Str_TransformState,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TransformState,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Indicates a coordinate-system transform on vertices.  TransformStates are\n"
    " * the primary means for storing transformations on the scene graph.\n"
    " *\n"
    " * Transforms may be specified in one of two ways: componentwise, with a pos-\n"
    " * hpr-scale, or with an arbitrary transform matrix.  If you specify a\n"
    " * transform componentwise, it will remember its original components.\n"
    " *\n"
    " * TransformState objects are managed very much like RenderState objects.\n"
    " * They are immutable and reference-counted automatically.\n"
    " *\n"
    " * You should not attempt to create or modify a TransformState object\n"
    " * directly.  Instead, call one of the make() functions to create one for you.\n"
    " * And instead of modifying a TransformState object, create a new one.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_TransformState,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TransformState,
    nullptr, // tp_members
    Dtool_Properties_TransformState,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TransformState,
    PyType_GenericAlloc,
    Dtool_new_TransformState,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TransformState,
  Dtool_UpcastInterface_TransformState,
  Dtool_DowncastInterface_TransformState,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TransformState(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_NodeCachedReferenceCount != nullptr);
    assert(Dtool_Ptr_NodeCachedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_NodeCachedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_TransformState._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_NodeCachedReferenceCount);
    Dtool_TransformState._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TransformState._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TransformState) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TransformState)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TransformState);
  }
}

/**
 * Python method tables for RenderAttribRegistry (RenderAttribRegistry)
 */
static PyMethodDef Dtool_Methods_RenderAttribRegistry[] = {
  {"get_slot", &Dtool_RenderAttribRegistry_get_slot_120, METH_O, (const char *)Dtool_RenderAttribRegistry_get_slot_120_comment},
  {"getSlot", &Dtool_RenderAttribRegistry_get_slot_120, METH_O, (const char *)Dtool_RenderAttribRegistry_get_slot_120_comment},
  {"get_max_slots", &Dtool_RenderAttribRegistry_get_max_slots_121, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttribRegistry_get_max_slots_121_comment},
  {"getMaxSlots", &Dtool_RenderAttribRegistry_get_max_slots_121, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttribRegistry_get_max_slots_121_comment},
  {"get_num_slots", &Dtool_RenderAttribRegistry_get_num_slots_122, METH_NOARGS, (const char *)Dtool_RenderAttribRegistry_get_num_slots_122_comment},
  {"getNumSlots", &Dtool_RenderAttribRegistry_get_num_slots_122, METH_NOARGS, (const char *)Dtool_RenderAttribRegistry_get_num_slots_122_comment},
  {"get_slot_type", &Dtool_RenderAttribRegistry_get_slot_type_123, METH_O, (const char *)Dtool_RenderAttribRegistry_get_slot_type_123_comment},
  {"getSlotType", &Dtool_RenderAttribRegistry_get_slot_type_123, METH_O, (const char *)Dtool_RenderAttribRegistry_get_slot_type_123_comment},
  {"get_slot_sort", &Dtool_RenderAttribRegistry_get_slot_sort_124, METH_O, (const char *)Dtool_RenderAttribRegistry_get_slot_sort_124_comment},
  {"getSlotSort", &Dtool_RenderAttribRegistry_get_slot_sort_124, METH_O, (const char *)Dtool_RenderAttribRegistry_get_slot_sort_124_comment},
  {"set_slot_sort", (PyCFunction) &Dtool_RenderAttribRegistry_set_slot_sort_125, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderAttribRegistry_set_slot_sort_125_comment},
  {"setSlotSort", (PyCFunction) &Dtool_RenderAttribRegistry_set_slot_sort_125, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderAttribRegistry_set_slot_sort_125_comment},
  {"get_slot_default", &Dtool_RenderAttribRegistry_get_slot_default_126, METH_O, (const char *)Dtool_RenderAttribRegistry_get_slot_default_126_comment},
  {"getSlotDefault", &Dtool_RenderAttribRegistry_get_slot_default_126, METH_O, (const char *)Dtool_RenderAttribRegistry_get_slot_default_126_comment},
  {"get_num_sorted_slots", &Dtool_RenderAttribRegistry_get_num_sorted_slots_127, METH_NOARGS, (const char *)Dtool_RenderAttribRegistry_get_num_sorted_slots_127_comment},
  {"getNumSortedSlots", &Dtool_RenderAttribRegistry_get_num_sorted_slots_127, METH_NOARGS, (const char *)Dtool_RenderAttribRegistry_get_num_sorted_slots_127_comment},
  {"get_sorted_slot", &Dtool_RenderAttribRegistry_get_sorted_slot_128, METH_O, (const char *)Dtool_RenderAttribRegistry_get_sorted_slot_128_comment},
  {"getSortedSlot", &Dtool_RenderAttribRegistry_get_sorted_slot_128, METH_O, (const char *)Dtool_RenderAttribRegistry_get_sorted_slot_128_comment},
  {"get_global_ptr", &Dtool_RenderAttribRegistry_get_global_ptr_129, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttribRegistry_get_global_ptr_129_comment},
  {"getGlobalPtr", &Dtool_RenderAttribRegistry_get_global_ptr_129, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttribRegistry_get_global_ptr_129_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_RenderAttribRegistry = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_RenderAttribRegistry = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RenderAttribRegistry",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RenderAttribRegistry,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RenderAttribRegistry,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to associate each RenderAttrib with a different slot\n"
    " * index at runtime, so we can store a list of RenderAttribs in the\n"
    " * RenderState object, and very quickly look them up by type.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RenderAttribRegistry,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RenderAttribRegistry,
    PyType_GenericAlloc,
    Dtool_new_RenderAttribRegistry,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RenderAttribRegistry,
  Dtool_UpcastInterface_RenderAttribRegistry,
  Dtool_DowncastInterface_RenderAttribRegistry,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RenderAttribRegistry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_RenderAttribRegistry._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RenderAttribRegistry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RenderAttribRegistry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RenderAttribRegistry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RenderAttribRegistry);
  }
}

/**
 * Python method tables for RenderAttrib (RenderAttrib)
 */
static PyMethodDef Dtool_Methods_RenderAttrib[] = {
  {"compose", &Dtool_RenderAttrib_compose_132, METH_O, (const char *)Dtool_RenderAttrib_compose_132_comment},
  {"invert_compose", &Dtool_RenderAttrib_invert_compose_133, METH_O, (const char *)Dtool_RenderAttrib_invert_compose_133_comment},
  {"invertCompose", &Dtool_RenderAttrib_invert_compose_133, METH_O, (const char *)Dtool_RenderAttrib_invert_compose_133_comment},
  {"lower_attrib_can_override", &Dtool_RenderAttrib_lower_attrib_can_override_134, METH_NOARGS, (const char *)Dtool_RenderAttrib_lower_attrib_can_override_134_comment},
  {"lowerAttribCanOverride", &Dtool_RenderAttrib_lower_attrib_can_override_134, METH_NOARGS, (const char *)Dtool_RenderAttrib_lower_attrib_can_override_134_comment},
  {"compare_to", &Dtool_RenderAttrib_compare_to_135, METH_O, (const char *)Dtool_RenderAttrib_compare_to_135_comment},
  {"compareTo", &Dtool_RenderAttrib_compare_to_135, METH_O, (const char *)Dtool_RenderAttrib_compare_to_135_comment},
  {"get_hash", &Dtool_RenderAttrib_get_hash_136, METH_NOARGS, (const char *)Dtool_RenderAttrib_get_hash_136_comment},
  {"getHash", &Dtool_RenderAttrib_get_hash_136, METH_NOARGS, (const char *)Dtool_RenderAttrib_get_hash_136_comment},
  {"get_unique", &Dtool_RenderAttrib_get_unique_137, METH_NOARGS, (const char *)Dtool_RenderAttrib_get_unique_137_comment},
  {"getUnique", &Dtool_RenderAttrib_get_unique_137, METH_NOARGS, (const char *)Dtool_RenderAttrib_get_unique_137_comment},
  {"output", &Dtool_RenderAttrib_output_138, METH_O, (const char *)Dtool_RenderAttrib_output_138_comment},
  {"write", (PyCFunction) &Dtool_RenderAttrib_write_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderAttrib_write_139_comment},
  {"get_num_attribs", &Dtool_RenderAttrib_get_num_attribs_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttrib_get_num_attribs_140_comment},
  {"getNumAttribs", &Dtool_RenderAttrib_get_num_attribs_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttrib_get_num_attribs_140_comment},
  {"list_attribs", &Dtool_RenderAttrib_list_attribs_141, METH_O | METH_STATIC, (const char *)Dtool_RenderAttrib_list_attribs_141_comment},
  {"listAttribs", &Dtool_RenderAttrib_list_attribs_141, METH_O | METH_STATIC, (const char *)Dtool_RenderAttrib_list_attribs_141_comment},
  {"garbage_collect", &Dtool_RenderAttrib_garbage_collect_142, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttrib_garbage_collect_142_comment},
  {"garbageCollect", &Dtool_RenderAttrib_garbage_collect_142, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttrib_garbage_collect_142_comment},
  {"validate_attribs", &Dtool_RenderAttrib_validate_attribs_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttrib_validate_attribs_143_comment},
  {"validateAttribs", &Dtool_RenderAttrib_validate_attribs_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttrib_validate_attribs_143_comment},
  {"get_slot", &Dtool_RenderAttrib_get_slot_144, METH_NOARGS, (const char *)Dtool_RenderAttrib_get_slot_144_comment},
  {"getSlot", &Dtool_RenderAttrib_get_slot_144, METH_NOARGS, (const char *)Dtool_RenderAttrib_get_slot_144_comment},
  {"get_class_type", &Dtool_RenderAttrib_get_class_type_149, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttrib_get_class_type_149_comment},
  {"getClassType", &Dtool_RenderAttrib_get_class_type_149, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderAttrib_get_class_type_149_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// RenderAttrib slot tp_compare -> compare_to
//////////////////
static int Dtool_RenderAttrib_compare_to_135_tp_compare(PyObject *self, PyObject *arg) {
  RenderAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderAttrib, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int RenderAttrib::compare_to(RenderAttrib const &other) const
  RenderAttrib const *arg_this = (RenderAttrib *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderAttrib, 1, "RenderAttrib.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const RenderAttrib*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(RenderAttrib self, const RenderAttrib other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// RenderAttrib slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_RenderAttrib_get_hash_136_tp_hash(PyObject *self) {
  RenderAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderAttrib, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_hash)();
}

//////////////////
//  A __repr__ function
//     RenderAttrib
//////////////////
static PyObject *Dtool_Repr_RenderAttrib(PyObject *self) {
  RenderAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderAttrib, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     RenderAttrib
//////////////////
static PyObject *Dtool_Str_RenderAttrib(PyObject *self) {
  RenderAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderAttrib, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     RenderAttrib
//////////////////
static PyObject *Dtool_RichCompare_RenderAttrib(PyObject *self, PyObject *arg, int op) {
  RenderAttrib *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderAttrib, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_RenderAttrib_compare_to_135_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_RenderAttrib[] = {
  {(char *)"slot", &Dtool_RenderAttrib_slot_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_RenderAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RenderAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RenderAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RenderAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RenderAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RenderAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RenderAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RenderAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RenderAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_RenderAttrib_compare_to_135_tp_compare,
#endif
    &Dtool_Repr_RenderAttrib,
    &Dtool_NumberMethods_RenderAttrib,
    &Dtool_SequenceMethods_RenderAttrib,
    &Dtool_MappingMethods_RenderAttrib,
    &Dtool_RenderAttrib_get_hash_136_tp_hash,
    nullptr,
    &Dtool_Str_RenderAttrib,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RenderAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for a number of render attributes (other than\n"
    " * transform) that may be set on scene graph nodes to control the appearance\n"
    " * of geometry.  This includes TextureAttrib, ColorAttrib, etc.\n"
    " *\n"
    " * RenderAttrib represents render attributes that always propagate down to the\n"
    " * leaves without regard to the particular node they are assigned to.  A\n"
    " * RenderAttrib will have the same effect on a leaf node whether it is\n"
    " * assigned to the graph at the leaf or several nodes above.  This is\n"
    " * different from RenderEffect, which represents a particular render property\n"
    " * that is applied immediately to the node on which it is encountered, like\n"
    " * billboarding or decaling.\n"
    " *\n"
    " * You should not attempt to create or modify a RenderAttrib directly;\n"
    " * instead, use the make() method of the appropriate kind of attrib you want.\n"
    " * This will allocate and return a new RenderAttrib of the appropriate type,\n"
    " * and it may share pointers if possible.  Do not modify the new RenderAttrib\n"
    " * if you wish to change its properties; instead, create a new one.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_RenderAttrib,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RenderAttrib,
    nullptr, // tp_members
    Dtool_Properties_RenderAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RenderAttrib,
    PyType_GenericAlloc,
    Dtool_new_RenderAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RenderAttrib,
  Dtool_UpcastInterface_RenderAttrib,
  Dtool_DowncastInterface_RenderAttrib,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RenderAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_RenderAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_RenderAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(43);
    Dtool_RenderAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum RenderAttrib::PandaCompareFunc;
    PyDict_SetItemString(dict, "M_none", Dtool_WrapValue(RenderAttrib::M_none));
    PyDict_SetItemString(dict, "MNone", Dtool_WrapValue(RenderAttrib::M_none));
    PyDict_SetItemString(dict, "M_never", Dtool_WrapValue(RenderAttrib::M_never));
    PyDict_SetItemString(dict, "MNever", Dtool_WrapValue(RenderAttrib::M_never));
    PyDict_SetItemString(dict, "M_less", Dtool_WrapValue(RenderAttrib::M_less));
    PyDict_SetItemString(dict, "MLess", Dtool_WrapValue(RenderAttrib::M_less));
    PyDict_SetItemString(dict, "M_equal", Dtool_WrapValue(RenderAttrib::M_equal));
    PyDict_SetItemString(dict, "MEqual", Dtool_WrapValue(RenderAttrib::M_equal));
    PyDict_SetItemString(dict, "M_less_equal", Dtool_WrapValue(RenderAttrib::M_less_equal));
    PyDict_SetItemString(dict, "MLessEqual", Dtool_WrapValue(RenderAttrib::M_less_equal));
    PyDict_SetItemString(dict, "M_greater", Dtool_WrapValue(RenderAttrib::M_greater));
    PyDict_SetItemString(dict, "MGreater", Dtool_WrapValue(RenderAttrib::M_greater));
    PyDict_SetItemString(dict, "M_not_equal", Dtool_WrapValue(RenderAttrib::M_not_equal));
    PyDict_SetItemString(dict, "MNotEqual", Dtool_WrapValue(RenderAttrib::M_not_equal));
    PyDict_SetItemString(dict, "M_greater_equal", Dtool_WrapValue(RenderAttrib::M_greater_equal));
    PyDict_SetItemString(dict, "MGreaterEqual", Dtool_WrapValue(RenderAttrib::M_greater_equal));
    PyDict_SetItemString(dict, "M_always", Dtool_WrapValue(RenderAttrib::M_always));
    PyDict_SetItemString(dict, "MAlways", Dtool_WrapValue(RenderAttrib::M_always));
    // enum RenderAttrib::TexGenMode;
    PyDict_SetItemString(dict, "M_off", Dtool_WrapValue(RenderAttrib::M_off));
    PyDict_SetItemString(dict, "MOff", Dtool_WrapValue(RenderAttrib::M_off));
    PyDict_SetItemString(dict, "M_eye_sphere_map", Dtool_WrapValue(RenderAttrib::M_eye_sphere_map));
    PyDict_SetItemString(dict, "MEyeSphereMap", Dtool_WrapValue(RenderAttrib::M_eye_sphere_map));
    PyDict_SetItemString(dict, "M_world_cube_map", Dtool_WrapValue(RenderAttrib::M_world_cube_map));
    PyDict_SetItemString(dict, "MWorldCubeMap", Dtool_WrapValue(RenderAttrib::M_world_cube_map));
    PyDict_SetItemString(dict, "M_eye_cube_map", Dtool_WrapValue(RenderAttrib::M_eye_cube_map));
    PyDict_SetItemString(dict, "MEyeCubeMap", Dtool_WrapValue(RenderAttrib::M_eye_cube_map));
    PyDict_SetItemString(dict, "M_world_normal", Dtool_WrapValue(RenderAttrib::M_world_normal));
    PyDict_SetItemString(dict, "MWorldNormal", Dtool_WrapValue(RenderAttrib::M_world_normal));
    PyDict_SetItemString(dict, "M_eye_normal", Dtool_WrapValue(RenderAttrib::M_eye_normal));
    PyDict_SetItemString(dict, "MEyeNormal", Dtool_WrapValue(RenderAttrib::M_eye_normal));
    PyDict_SetItemString(dict, "M_world_position", Dtool_WrapValue(RenderAttrib::M_world_position));
    PyDict_SetItemString(dict, "MWorldPosition", Dtool_WrapValue(RenderAttrib::M_world_position));
    PyDict_SetItemString(dict, "M_unused", Dtool_WrapValue(RenderAttrib::M_unused));
    PyDict_SetItemString(dict, "MUnused", Dtool_WrapValue(RenderAttrib::M_unused));
    PyDict_SetItemString(dict, "M_eye_position", Dtool_WrapValue(RenderAttrib::M_eye_position));
    PyDict_SetItemString(dict, "MEyePosition", Dtool_WrapValue(RenderAttrib::M_eye_position));
    PyDict_SetItemString(dict, "M_point_sprite", Dtool_WrapValue(RenderAttrib::M_point_sprite));
    PyDict_SetItemString(dict, "MPointSprite", Dtool_WrapValue(RenderAttrib::M_point_sprite));
    PyDict_SetItemString(dict, "M_unused2", Dtool_WrapValue(RenderAttrib::M_unused2));
    PyDict_SetItemString(dict, "MUnused2", Dtool_WrapValue(RenderAttrib::M_unused2));
    PyDict_SetItemString(dict, "M_constant", Dtool_WrapValue(RenderAttrib::M_constant));
    PyDict_SetItemString(dict, "MConstant", Dtool_WrapValue(RenderAttrib::M_constant));
    if (PyType_Ready((PyTypeObject *)&Dtool_RenderAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RenderAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RenderAttrib);
  }
}

/**
 * Python method tables for RenderModeAttrib (RenderModeAttrib)
 */
static PyMethodDef Dtool_Methods_RenderModeAttrib[] = {
  {"make", (PyCFunction) &Dtool_RenderModeAttrib_make_152, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_RenderModeAttrib_make_152_comment},
  {"make_default", &Dtool_RenderModeAttrib_make_default_153, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderModeAttrib_make_default_153_comment},
  {"makeDefault", &Dtool_RenderModeAttrib_make_default_153, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderModeAttrib_make_default_153_comment},
  {"get_mode", &Dtool_RenderModeAttrib_get_mode_154, METH_NOARGS, (const char *)Dtool_RenderModeAttrib_get_mode_154_comment},
  {"getMode", &Dtool_RenderModeAttrib_get_mode_154, METH_NOARGS, (const char *)Dtool_RenderModeAttrib_get_mode_154_comment},
  {"get_thickness", &Dtool_RenderModeAttrib_get_thickness_155, METH_NOARGS, (const char *)Dtool_RenderModeAttrib_get_thickness_155_comment},
  {"getThickness", &Dtool_RenderModeAttrib_get_thickness_155, METH_NOARGS, (const char *)Dtool_RenderModeAttrib_get_thickness_155_comment},
  {"get_perspective", &Dtool_RenderModeAttrib_get_perspective_156, METH_NOARGS, (const char *)Dtool_RenderModeAttrib_get_perspective_156_comment},
  {"getPerspective", &Dtool_RenderModeAttrib_get_perspective_156, METH_NOARGS, (const char *)Dtool_RenderModeAttrib_get_perspective_156_comment},
  {"get_wireframe_color", &Dtool_RenderModeAttrib_get_wireframe_color_157, METH_NOARGS, (const char *)Dtool_RenderModeAttrib_get_wireframe_color_157_comment},
  {"getWireframeColor", &Dtool_RenderModeAttrib_get_wireframe_color_157, METH_NOARGS, (const char *)Dtool_RenderModeAttrib_get_wireframe_color_157_comment},
  {"get_geom_rendering", &Dtool_RenderModeAttrib_get_geom_rendering_158, METH_O, (const char *)Dtool_RenderModeAttrib_get_geom_rendering_158_comment},
  {"getGeomRendering", &Dtool_RenderModeAttrib_get_geom_rendering_158, METH_O, (const char *)Dtool_RenderModeAttrib_get_geom_rendering_158_comment},
  {"get_class_slot", &Dtool_RenderModeAttrib_get_class_slot_170, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderModeAttrib_get_class_slot_170_comment},
  {"getClassSlot", &Dtool_RenderModeAttrib_get_class_slot_170, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderModeAttrib_get_class_slot_170_comment},
  {"get_class_type", &Dtool_RenderModeAttrib_get_class_type_172, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderModeAttrib_get_class_type_172_comment},
  {"getClassType", &Dtool_RenderModeAttrib_get_class_type_172, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderModeAttrib_get_class_type_172_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_RenderModeAttrib[] = {
  {(char *)"mode", &Dtool_RenderModeAttrib_mode_Getter, nullptr, nullptr, nullptr},
  {(char *)"thickness", &Dtool_RenderModeAttrib_thickness_Getter, nullptr, nullptr, nullptr},
  {(char *)"perspective", &Dtool_RenderModeAttrib_perspective_Getter, nullptr, nullptr, nullptr},
  {(char *)"wireframe_color", &Dtool_RenderModeAttrib_wireframe_color_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_RenderModeAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RenderModeAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RenderModeAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RenderModeAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RenderModeAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RenderModeAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RenderModeAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RenderModeAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RenderModeAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RenderModeAttrib,
    &Dtool_SequenceMethods_RenderModeAttrib,
    &Dtool_MappingMethods_RenderModeAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RenderModeAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Specifies how polygons are to be drawn.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RenderModeAttrib,
    nullptr, // tp_members
    Dtool_Properties_RenderModeAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RenderModeAttrib,
    PyType_GenericAlloc,
    Dtool_new_RenderModeAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RenderModeAttrib,
  Dtool_UpcastInterface_RenderModeAttrib,
  Dtool_DowncastInterface_RenderModeAttrib,
  (CoerceFunction)Dtool_ConstCoerce_RenderModeAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_RenderModeAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_RenderModeAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_RenderModeAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(13);
    Dtool_RenderModeAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum RenderModeAttrib::Mode;
    PyDict_SetItemString(dict, "M_unchanged", Dtool_WrapValue(RenderModeAttrib::M_unchanged));
    PyDict_SetItemString(dict, "MUnchanged", Dtool_WrapValue(RenderModeAttrib::M_unchanged));
    PyDict_SetItemString(dict, "M_filled", Dtool_WrapValue(RenderModeAttrib::M_filled));
    PyDict_SetItemString(dict, "MFilled", Dtool_WrapValue(RenderModeAttrib::M_filled));
    PyDict_SetItemString(dict, "M_wireframe", Dtool_WrapValue(RenderModeAttrib::M_wireframe));
    PyDict_SetItemString(dict, "MWireframe", Dtool_WrapValue(RenderModeAttrib::M_wireframe));
    PyDict_SetItemString(dict, "M_point", Dtool_WrapValue(RenderModeAttrib::M_point));
    PyDict_SetItemString(dict, "MPoint", Dtool_WrapValue(RenderModeAttrib::M_point));
    PyDict_SetItemString(dict, "M_filled_flat", Dtool_WrapValue(RenderModeAttrib::M_filled_flat));
    PyDict_SetItemString(dict, "MFilledFlat", Dtool_WrapValue(RenderModeAttrib::M_filled_flat));
    PyDict_SetItemString(dict, "M_filled_wireframe", Dtool_WrapValue(RenderModeAttrib::M_filled_wireframe));
    PyDict_SetItemString(dict, "MFilledWireframe", Dtool_WrapValue(RenderModeAttrib::M_filled_wireframe));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_RenderModeAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_RenderModeAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_RenderModeAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RenderModeAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RenderModeAttrib);
  }
}

/**
 * Python method tables for TexMatrixAttrib (TexMatrixAttrib)
 */
static PyMethodDef Dtool_Methods_TexMatrixAttrib[] = {
  {"make", (PyCFunction) &Dtool_TexMatrixAttrib_make_175, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexMatrixAttrib_make_175_comment},
  {"make_default", &Dtool_TexMatrixAttrib_make_default_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexMatrixAttrib_make_default_176_comment},
  {"makeDefault", &Dtool_TexMatrixAttrib_make_default_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexMatrixAttrib_make_default_176_comment},
  {"add_stage", (PyCFunction) &Dtool_TexMatrixAttrib_add_stage_177, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexMatrixAttrib_add_stage_177_comment},
  {"addStage", (PyCFunction) &Dtool_TexMatrixAttrib_add_stage_177, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexMatrixAttrib_add_stage_177_comment},
  {"remove_stage", &Dtool_TexMatrixAttrib_remove_stage_178, METH_O, (const char *)Dtool_TexMatrixAttrib_remove_stage_178_comment},
  {"removeStage", &Dtool_TexMatrixAttrib_remove_stage_178, METH_O, (const char *)Dtool_TexMatrixAttrib_remove_stage_178_comment},
  {"is_empty", &Dtool_TexMatrixAttrib_is_empty_179, METH_NOARGS, (const char *)Dtool_TexMatrixAttrib_is_empty_179_comment},
  {"isEmpty", &Dtool_TexMatrixAttrib_is_empty_179, METH_NOARGS, (const char *)Dtool_TexMatrixAttrib_is_empty_179_comment},
  {"has_stage", &Dtool_TexMatrixAttrib_has_stage_180, METH_O, (const char *)Dtool_TexMatrixAttrib_has_stage_180_comment},
  {"hasStage", &Dtool_TexMatrixAttrib_has_stage_180, METH_O, (const char *)Dtool_TexMatrixAttrib_has_stage_180_comment},
  {"get_num_stages", &Dtool_TexMatrixAttrib_get_num_stages_181, METH_NOARGS, (const char *)Dtool_TexMatrixAttrib_get_num_stages_181_comment},
  {"getNumStages", &Dtool_TexMatrixAttrib_get_num_stages_181, METH_NOARGS, (const char *)Dtool_TexMatrixAttrib_get_num_stages_181_comment},
  {"get_stage", &Dtool_TexMatrixAttrib_get_stage_182, METH_O, (const char *)Dtool_TexMatrixAttrib_get_stage_182_comment},
  {"getStage", &Dtool_TexMatrixAttrib_get_stage_182, METH_O, (const char *)Dtool_TexMatrixAttrib_get_stage_182_comment},
  {"get_mat", &Dtool_TexMatrixAttrib_get_mat_184, METH_VARARGS, (const char *)Dtool_TexMatrixAttrib_get_mat_184_comment},
  {"getMat", &Dtool_TexMatrixAttrib_get_mat_184, METH_VARARGS, (const char *)Dtool_TexMatrixAttrib_get_mat_184_comment},
  {"get_transform", &Dtool_TexMatrixAttrib_get_transform_185, METH_O, (const char *)Dtool_TexMatrixAttrib_get_transform_185_comment},
  {"getTransform", &Dtool_TexMatrixAttrib_get_transform_185, METH_O, (const char *)Dtool_TexMatrixAttrib_get_transform_185_comment},
  {"get_override", &Dtool_TexMatrixAttrib_get_override_186, METH_O, (const char *)Dtool_TexMatrixAttrib_get_override_186_comment},
  {"getOverride", &Dtool_TexMatrixAttrib_get_override_186, METH_O, (const char *)Dtool_TexMatrixAttrib_get_override_186_comment},
  {"get_geom_rendering", &Dtool_TexMatrixAttrib_get_geom_rendering_187, METH_O, (const char *)Dtool_TexMatrixAttrib_get_geom_rendering_187_comment},
  {"getGeomRendering", &Dtool_TexMatrixAttrib_get_geom_rendering_187, METH_O, (const char *)Dtool_TexMatrixAttrib_get_geom_rendering_187_comment},
  {"get_class_slot", &Dtool_TexMatrixAttrib_get_class_slot_188, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexMatrixAttrib_get_class_slot_188_comment},
  {"getClassSlot", &Dtool_TexMatrixAttrib_get_class_slot_188, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexMatrixAttrib_get_class_slot_188_comment},
  {"get_class_type", &Dtool_TexMatrixAttrib_get_class_type_190, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexMatrixAttrib_get_class_type_190_comment},
  {"getClassType", &Dtool_TexMatrixAttrib_get_class_type_190, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexMatrixAttrib_get_class_type_190_comment},
  {"get_stages", (PyCFunction) &MakeSeq_TexMatrixAttrib_get_stages, METH_NOARGS, nullptr},
  { "getStages", (PyCFunction) &MakeSeq_TexMatrixAttrib_get_stages, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TexMatrixAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TexMatrixAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TexMatrixAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TexMatrixAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TexMatrixAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TexMatrixAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TexMatrixAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TexMatrixAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TexMatrixAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TexMatrixAttrib,
    &Dtool_SequenceMethods_TexMatrixAttrib,
    &Dtool_MappingMethods_TexMatrixAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TexMatrixAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Applies a transform matrix to UV's before they are rendered.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TexMatrixAttrib,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TexMatrixAttrib,
    PyType_GenericAlloc,
    Dtool_new_TexMatrixAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TexMatrixAttrib,
  Dtool_UpcastInterface_TexMatrixAttrib,
  Dtool_DowncastInterface_TexMatrixAttrib,
  (CoerceFunction)Dtool_ConstCoerce_TexMatrixAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_TexMatrixAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_TexMatrixAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_TexMatrixAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TexMatrixAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_TexMatrixAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_TexMatrixAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_TexMatrixAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TexMatrixAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TexMatrixAttrib);
  }
}

/**
 * Python method tables for RenderState (RenderState)
 */
static PyMethodDef Dtool_Methods_RenderState[] = {
  {"compare_to", &Dtool_RenderState_compare_to_192, METH_O, (const char *)Dtool_RenderState_compare_to_192_comment},
  {"compareTo", &Dtool_RenderState_compare_to_192, METH_O, (const char *)Dtool_RenderState_compare_to_192_comment},
  {"compare_sort", &Dtool_RenderState_compare_sort_193, METH_O, (const char *)Dtool_RenderState_compare_sort_193_comment},
  {"compareSort", &Dtool_RenderState_compare_sort_193, METH_O, (const char *)Dtool_RenderState_compare_sort_193_comment},
  {"compare_mask", (PyCFunction) &Dtool_RenderState_compare_mask_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderState_compare_mask_194_comment},
  {"compareMask", (PyCFunction) &Dtool_RenderState_compare_mask_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderState_compare_mask_194_comment},
  {"get_hash", &Dtool_RenderState_get_hash_195, METH_NOARGS, (const char *)Dtool_RenderState_get_hash_195_comment},
  {"getHash", &Dtool_RenderState_get_hash_195, METH_NOARGS, (const char *)Dtool_RenderState_get_hash_195_comment},
  {"is_empty", &Dtool_RenderState_is_empty_196, METH_NOARGS, (const char *)Dtool_RenderState_is_empty_196_comment},
  {"isEmpty", &Dtool_RenderState_is_empty_196, METH_NOARGS, (const char *)Dtool_RenderState_is_empty_196_comment},
  {"has_cull_callback", &Dtool_RenderState_has_cull_callback_197, METH_NOARGS, (const char *)Dtool_RenderState_has_cull_callback_197_comment},
  {"hasCullCallback", &Dtool_RenderState_has_cull_callback_197, METH_NOARGS, (const char *)Dtool_RenderState_has_cull_callback_197_comment},
  {"cull_callback", (PyCFunction) &Dtool_RenderState_cull_callback_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderState_cull_callback_198_comment},
  {"cullCallback", (PyCFunction) &Dtool_RenderState_cull_callback_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderState_cull_callback_198_comment},
  {"make_empty", &Dtool_RenderState_make_empty_199, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_make_empty_199_comment},
  {"makeEmpty", &Dtool_RenderState_make_empty_199, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_make_empty_199_comment},
  {"make", (PyCFunction) &Dtool_RenderState_make_200, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_RenderState_make_200_comment},
  {"compose", &Dtool_RenderState_compose_201, METH_O, (const char *)Dtool_RenderState_compose_201_comment},
  {"invert_compose", &Dtool_RenderState_invert_compose_202, METH_O, (const char *)Dtool_RenderState_invert_compose_202_comment},
  {"invertCompose", &Dtool_RenderState_invert_compose_202, METH_O, (const char *)Dtool_RenderState_invert_compose_202_comment},
  {"add_attrib", (PyCFunction) &Dtool_RenderState_add_attrib_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderState_add_attrib_203_comment},
  {"addAttrib", (PyCFunction) &Dtool_RenderState_add_attrib_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderState_add_attrib_203_comment},
  {"set_attrib", (PyCFunction) &Dtool_RenderState_set_attrib_204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderState_set_attrib_204_comment},
  {"setAttrib", (PyCFunction) &Dtool_RenderState_set_attrib_204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderState_set_attrib_204_comment},
  {"remove_attrib", &Dtool_RenderState_remove_attrib_205, METH_O, (const char *)Dtool_RenderState_remove_attrib_205_comment},
  {"removeAttrib", &Dtool_RenderState_remove_attrib_205, METH_O, (const char *)Dtool_RenderState_remove_attrib_205_comment},
  {"adjust_all_priorities", &Dtool_RenderState_adjust_all_priorities_206, METH_O, (const char *)Dtool_RenderState_adjust_all_priorities_206_comment},
  {"adjustAllPriorities", &Dtool_RenderState_adjust_all_priorities_206, METH_O, (const char *)Dtool_RenderState_adjust_all_priorities_206_comment},
  {"has_attrib", &Dtool_RenderState_has_attrib_207, METH_O, (const char *)Dtool_RenderState_has_attrib_207_comment},
  {"hasAttrib", &Dtool_RenderState_has_attrib_207, METH_O, (const char *)Dtool_RenderState_has_attrib_207_comment},
  {"get_attrib", &Dtool_RenderState_get_attrib_208, METH_O, (const char *)Dtool_RenderState_get_attrib_208_comment},
  {"getAttrib", &Dtool_RenderState_get_attrib_208, METH_O, (const char *)Dtool_RenderState_get_attrib_208_comment},
  {"get_attrib_def", &Dtool_RenderState_get_attrib_def_209, METH_O, (const char *)Dtool_RenderState_get_attrib_def_209_comment},
  {"getAttribDef", &Dtool_RenderState_get_attrib_def_209, METH_O, (const char *)Dtool_RenderState_get_attrib_def_209_comment},
  {"get_override", &Dtool_RenderState_get_override_210, METH_O, (const char *)Dtool_RenderState_get_override_210_comment},
  {"getOverride", &Dtool_RenderState_get_override_210, METH_O, (const char *)Dtool_RenderState_get_override_210_comment},
  {"get_unique", &Dtool_RenderState_get_unique_214, METH_NOARGS, (const char *)Dtool_RenderState_get_unique_214_comment},
  {"getUnique", &Dtool_RenderState_get_unique_214, METH_NOARGS, (const char *)Dtool_RenderState_get_unique_214_comment},
  {"cache_ref", &Dtool_RenderState_cache_ref_215, METH_NOARGS, (const char *)Dtool_RenderState_cache_ref_215_comment},
  {"cacheRef", &Dtool_RenderState_cache_ref_215, METH_NOARGS, (const char *)Dtool_RenderState_cache_ref_215_comment},
  {"cache_unref", &Dtool_RenderState_cache_unref_216, METH_NOARGS, (const char *)Dtool_RenderState_cache_unref_216_comment},
  {"cacheUnref", &Dtool_RenderState_cache_unref_216, METH_NOARGS, (const char *)Dtool_RenderState_cache_unref_216_comment},
  {"node_ref", &Dtool_RenderState_node_ref_217, METH_NOARGS, (const char *)Dtool_RenderState_node_ref_217_comment},
  {"nodeRef", &Dtool_RenderState_node_ref_217, METH_NOARGS, (const char *)Dtool_RenderState_node_ref_217_comment},
  {"node_unref", &Dtool_RenderState_node_unref_218, METH_NOARGS, (const char *)Dtool_RenderState_node_unref_218_comment},
  {"nodeUnref", &Dtool_RenderState_node_unref_218, METH_NOARGS, (const char *)Dtool_RenderState_node_unref_218_comment},
  {"get_composition_cache_num_entries", &Dtool_RenderState_get_composition_cache_num_entries_219, METH_NOARGS, (const char *)Dtool_RenderState_get_composition_cache_num_entries_219_comment},
  {"getCompositionCacheNumEntries", &Dtool_RenderState_get_composition_cache_num_entries_219, METH_NOARGS, (const char *)Dtool_RenderState_get_composition_cache_num_entries_219_comment},
  {"get_invert_composition_cache_num_entries", &Dtool_RenderState_get_invert_composition_cache_num_entries_220, METH_NOARGS, (const char *)Dtool_RenderState_get_invert_composition_cache_num_entries_220_comment},
  {"getInvertCompositionCacheNumEntries", &Dtool_RenderState_get_invert_composition_cache_num_entries_220, METH_NOARGS, (const char *)Dtool_RenderState_get_invert_composition_cache_num_entries_220_comment},
  {"get_composition_cache_size", &Dtool_RenderState_get_composition_cache_size_221, METH_NOARGS, (const char *)Dtool_RenderState_get_composition_cache_size_221_comment},
  {"getCompositionCacheSize", &Dtool_RenderState_get_composition_cache_size_221, METH_NOARGS, (const char *)Dtool_RenderState_get_composition_cache_size_221_comment},
  {"get_composition_cache_source", &Dtool_RenderState_get_composition_cache_source_222, METH_O, (const char *)Dtool_RenderState_get_composition_cache_source_222_comment},
  {"getCompositionCacheSource", &Dtool_RenderState_get_composition_cache_source_222, METH_O, (const char *)Dtool_RenderState_get_composition_cache_source_222_comment},
  {"get_composition_cache_result", &Dtool_RenderState_get_composition_cache_result_223, METH_O, (const char *)Dtool_RenderState_get_composition_cache_result_223_comment},
  {"getCompositionCacheResult", &Dtool_RenderState_get_composition_cache_result_223, METH_O, (const char *)Dtool_RenderState_get_composition_cache_result_223_comment},
  {"get_invert_composition_cache_size", &Dtool_RenderState_get_invert_composition_cache_size_224, METH_NOARGS, (const char *)Dtool_RenderState_get_invert_composition_cache_size_224_comment},
  {"getInvertCompositionCacheSize", &Dtool_RenderState_get_invert_composition_cache_size_224, METH_NOARGS, (const char *)Dtool_RenderState_get_invert_composition_cache_size_224_comment},
  {"get_invert_composition_cache_source", &Dtool_RenderState_get_invert_composition_cache_source_225, METH_O, (const char *)Dtool_RenderState_get_invert_composition_cache_source_225_comment},
  {"getInvertCompositionCacheSource", &Dtool_RenderState_get_invert_composition_cache_source_225, METH_O, (const char *)Dtool_RenderState_get_invert_composition_cache_source_225_comment},
  {"get_invert_composition_cache_result", &Dtool_RenderState_get_invert_composition_cache_result_226, METH_O, (const char *)Dtool_RenderState_get_invert_composition_cache_result_226_comment},
  {"getInvertCompositionCacheResult", &Dtool_RenderState_get_invert_composition_cache_result_226, METH_O, (const char *)Dtool_RenderState_get_invert_composition_cache_result_226_comment},
  {"get_composition_cache", &Dtool_RenderState_get_composition_cache_227, METH_NOARGS, (const char *)Dtool_RenderState_get_composition_cache_227_comment},
  {"getCompositionCache", &Dtool_RenderState_get_composition_cache_227, METH_NOARGS, (const char *)Dtool_RenderState_get_composition_cache_227_comment},
  {"get_invert_composition_cache", &Dtool_RenderState_get_invert_composition_cache_228, METH_NOARGS, (const char *)Dtool_RenderState_get_invert_composition_cache_228_comment},
  {"getInvertCompositionCache", &Dtool_RenderState_get_invert_composition_cache_228, METH_NOARGS, (const char *)Dtool_RenderState_get_invert_composition_cache_228_comment},
  {"output", &Dtool_RenderState_output_229, METH_O, (const char *)Dtool_RenderState_output_229_comment},
  {"write", (PyCFunction) &Dtool_RenderState_write_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderState_write_230_comment},
  {"get_max_priority", &Dtool_RenderState_get_max_priority_231, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_get_max_priority_231_comment},
  {"getMaxPriority", &Dtool_RenderState_get_max_priority_231, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_get_max_priority_231_comment},
  {"get_num_states", &Dtool_RenderState_get_num_states_232, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_get_num_states_232_comment},
  {"getNumStates", &Dtool_RenderState_get_num_states_232, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_get_num_states_232_comment},
  {"get_num_unused_states", &Dtool_RenderState_get_num_unused_states_233, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_get_num_unused_states_233_comment},
  {"getNumUnusedStates", &Dtool_RenderState_get_num_unused_states_233, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_get_num_unused_states_233_comment},
  {"clear_cache", &Dtool_RenderState_clear_cache_234, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_clear_cache_234_comment},
  {"clearCache", &Dtool_RenderState_clear_cache_234, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_clear_cache_234_comment},
  {"clear_munger_cache", &Dtool_RenderState_clear_munger_cache_235, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_clear_munger_cache_235_comment},
  {"clearMungerCache", &Dtool_RenderState_clear_munger_cache_235, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_clear_munger_cache_235_comment},
  {"garbage_collect", &Dtool_RenderState_garbage_collect_236, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_garbage_collect_236_comment},
  {"garbageCollect", &Dtool_RenderState_garbage_collect_236, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_garbage_collect_236_comment},
  {"list_cycles", &Dtool_RenderState_list_cycles_237, METH_O | METH_STATIC, (const char *)Dtool_RenderState_list_cycles_237_comment},
  {"listCycles", &Dtool_RenderState_list_cycles_237, METH_O | METH_STATIC, (const char *)Dtool_RenderState_list_cycles_237_comment},
  {"list_states", &Dtool_RenderState_list_states_238, METH_O | METH_STATIC, (const char *)Dtool_RenderState_list_states_238_comment},
  {"listStates", &Dtool_RenderState_list_states_238, METH_O | METH_STATIC, (const char *)Dtool_RenderState_list_states_238_comment},
  {"validate_states", &Dtool_RenderState_validate_states_239, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_validate_states_239_comment},
  {"validateStates", &Dtool_RenderState_validate_states_239, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_validate_states_239_comment},
  {"get_states", &Dtool_RenderState_get_states_240, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_get_states_240_comment},
  {"getStates", &Dtool_RenderState_get_states_240, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_get_states_240_comment},
  {"get_draw_order", &Dtool_RenderState_get_draw_order_241, METH_NOARGS, (const char *)Dtool_RenderState_get_draw_order_241_comment},
  {"getDrawOrder", &Dtool_RenderState_get_draw_order_241, METH_NOARGS, (const char *)Dtool_RenderState_get_draw_order_241_comment},
  {"get_bin_index", &Dtool_RenderState_get_bin_index_242, METH_NOARGS, (const char *)Dtool_RenderState_get_bin_index_242_comment},
  {"getBinIndex", &Dtool_RenderState_get_bin_index_242, METH_NOARGS, (const char *)Dtool_RenderState_get_bin_index_242_comment},
  {"get_geom_rendering", &Dtool_RenderState_get_geom_rendering_243, METH_O, (const char *)Dtool_RenderState_get_geom_rendering_243_comment},
  {"getGeomRendering", &Dtool_RenderState_get_geom_rendering_243, METH_O, (const char *)Dtool_RenderState_get_geom_rendering_243_comment},
  {"get_class_type", &Dtool_RenderState_get_class_type_244, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_get_class_type_244_comment},
  {"getClassType", &Dtool_RenderState_get_class_type_244, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderState_get_class_type_244_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// RenderState slot tp_compare -> compare_to
//////////////////
static int Dtool_RenderState_compare_to_192_tp_compare(PyObject *self, PyObject *arg) {
  RenderState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderState, (void **)&local_this)) {
    return -1;
  }

  // 1-int RenderState::compare_to(RenderState const &other) const
  CPT(RenderState) arg_this;
  if (!Dtool_ConstCoerce_RenderState(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "RenderState.compare_to", "RenderState");
    return -1;
  }
  int return_value = ((*(const RenderState*)local_this).compare_to)(*std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(RenderState self, const RenderState other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// RenderState slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_RenderState_get_hash_195_tp_hash(PyObject *self) {
  RenderState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderState, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_hash)();
}

//////////////////
//  A __repr__ function
//     RenderState
//////////////////
static PyObject *Dtool_Repr_RenderState(PyObject *self) {
  RenderState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderState, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     RenderState
//////////////////
static PyObject *Dtool_Str_RenderState(PyObject *self) {
  RenderState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderState, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     RenderState
//////////////////
static PyObject *Dtool_RichCompare_RenderState(PyObject *self, PyObject *arg, int op) {
  RenderState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderState, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_RenderState_compare_to_192_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_RenderState[] = {
  {(char *)"attribs", &Dtool_RenderState_attribs_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_RenderState = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RenderState = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RenderState = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RenderState = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RenderState = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RenderState = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RenderState",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RenderState,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RenderState,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_RenderState_compare_to_192_tp_compare,
#endif
    &Dtool_Repr_RenderState,
    &Dtool_NumberMethods_RenderState,
    &Dtool_SequenceMethods_RenderState,
    &Dtool_MappingMethods_RenderState,
    &Dtool_RenderState_get_hash_195_tp_hash,
    nullptr,
    &Dtool_Str_RenderState,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RenderState,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a unique collection of RenderAttrib objects that correspond\n"
    " * to a particular renderable state.\n"
    " *\n"
    " * You should not attempt to create or modify a RenderState object directly.\n"
    " * Instead, call one of the make() functions to create one for you.  And\n"
    " * instead of modifying a RenderState object, create a new one.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_RenderState,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RenderState,
    nullptr, // tp_members
    Dtool_Properties_RenderState,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RenderState,
    PyType_GenericAlloc,
    Dtool_new_RenderState,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RenderState,
  Dtool_UpcastInterface_RenderState,
  Dtool_DowncastInterface_RenderState,
  (CoerceFunction)Dtool_ConstCoerce_RenderState,
  nullptr,
};

static void Dtool_PyModuleClassInit_RenderState(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_NodeCachedReferenceCount != nullptr);
    assert(Dtool_Ptr_NodeCachedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_NodeCachedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_RenderState._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_NodeCachedReferenceCount);
    Dtool_RenderState._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RenderState._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RenderState) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RenderState)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RenderState);
  }
}

/**
 * Python method tables for AlphaTestAttrib (AlphaTestAttrib)
 */
static PyMethodDef Dtool_Methods_AlphaTestAttrib[] = {
  {"make", (PyCFunction) &Dtool_AlphaTestAttrib_make_246, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_AlphaTestAttrib_make_246_comment},
  {"make_default", &Dtool_AlphaTestAttrib_make_default_247, METH_NOARGS | METH_STATIC, (const char *)Dtool_AlphaTestAttrib_make_default_247_comment},
  {"makeDefault", &Dtool_AlphaTestAttrib_make_default_247, METH_NOARGS | METH_STATIC, (const char *)Dtool_AlphaTestAttrib_make_default_247_comment},
  {"get_reference_alpha", &Dtool_AlphaTestAttrib_get_reference_alpha_248, METH_NOARGS, (const char *)Dtool_AlphaTestAttrib_get_reference_alpha_248_comment},
  {"getReferenceAlpha", &Dtool_AlphaTestAttrib_get_reference_alpha_248, METH_NOARGS, (const char *)Dtool_AlphaTestAttrib_get_reference_alpha_248_comment},
  {"get_mode", &Dtool_AlphaTestAttrib_get_mode_249, METH_NOARGS, (const char *)Dtool_AlphaTestAttrib_get_mode_249_comment},
  {"getMode", &Dtool_AlphaTestAttrib_get_mode_249, METH_NOARGS, (const char *)Dtool_AlphaTestAttrib_get_mode_249_comment},
  {"get_class_slot", &Dtool_AlphaTestAttrib_get_class_slot_252, METH_NOARGS | METH_STATIC, (const char *)Dtool_AlphaTestAttrib_get_class_slot_252_comment},
  {"getClassSlot", &Dtool_AlphaTestAttrib_get_class_slot_252, METH_NOARGS | METH_STATIC, (const char *)Dtool_AlphaTestAttrib_get_class_slot_252_comment},
  {"get_class_type", &Dtool_AlphaTestAttrib_get_class_type_254, METH_NOARGS | METH_STATIC, (const char *)Dtool_AlphaTestAttrib_get_class_type_254_comment},
  {"getClassType", &Dtool_AlphaTestAttrib_get_class_type_254, METH_NOARGS | METH_STATIC, (const char *)Dtool_AlphaTestAttrib_get_class_type_254_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_AlphaTestAttrib[] = {
  {(char *)"reference_alpha", &Dtool_AlphaTestAttrib_reference_alpha_Getter, nullptr, nullptr, nullptr},
  {(char *)"mode", &Dtool_AlphaTestAttrib_mode_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AlphaTestAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AlphaTestAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AlphaTestAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AlphaTestAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AlphaTestAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AlphaTestAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AlphaTestAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AlphaTestAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AlphaTestAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AlphaTestAttrib,
    &Dtool_SequenceMethods_AlphaTestAttrib,
    &Dtool_MappingMethods_AlphaTestAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AlphaTestAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Enables or disables writing of pixel to framebuffer based on its alpha\n"
    " * value relative to a reference alpha value\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AlphaTestAttrib,
    nullptr, // tp_members
    Dtool_Properties_AlphaTestAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AlphaTestAttrib,
    PyType_GenericAlloc,
    Dtool_new_AlphaTestAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AlphaTestAttrib,
  Dtool_UpcastInterface_AlphaTestAttrib,
  Dtool_DowncastInterface_AlphaTestAttrib,
  (CoerceFunction)Dtool_ConstCoerce_AlphaTestAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_AlphaTestAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_AlphaTestAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_AlphaTestAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AlphaTestAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_AlphaTestAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_AlphaTestAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_AlphaTestAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AlphaTestAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AlphaTestAttrib);
  }
}

/**
 * Python method tables for AntialiasAttrib (AntialiasAttrib)
 */
static PyMethodDef Dtool_Methods_AntialiasAttrib[] = {
  {"make", &Dtool_AntialiasAttrib_make_258, METH_O | METH_STATIC, (const char *)Dtool_AntialiasAttrib_make_258_comment},
  {"make_default", &Dtool_AntialiasAttrib_make_default_259, METH_NOARGS | METH_STATIC, (const char *)Dtool_AntialiasAttrib_make_default_259_comment},
  {"makeDefault", &Dtool_AntialiasAttrib_make_default_259, METH_NOARGS | METH_STATIC, (const char *)Dtool_AntialiasAttrib_make_default_259_comment},
  {"get_mode", &Dtool_AntialiasAttrib_get_mode_260, METH_NOARGS, (const char *)Dtool_AntialiasAttrib_get_mode_260_comment},
  {"getMode", &Dtool_AntialiasAttrib_get_mode_260, METH_NOARGS, (const char *)Dtool_AntialiasAttrib_get_mode_260_comment},
  {"get_mode_type", &Dtool_AntialiasAttrib_get_mode_type_261, METH_NOARGS, (const char *)Dtool_AntialiasAttrib_get_mode_type_261_comment},
  {"getModeType", &Dtool_AntialiasAttrib_get_mode_type_261, METH_NOARGS, (const char *)Dtool_AntialiasAttrib_get_mode_type_261_comment},
  {"get_mode_quality", &Dtool_AntialiasAttrib_get_mode_quality_262, METH_NOARGS, (const char *)Dtool_AntialiasAttrib_get_mode_quality_262_comment},
  {"getModeQuality", &Dtool_AntialiasAttrib_get_mode_quality_262, METH_NOARGS, (const char *)Dtool_AntialiasAttrib_get_mode_quality_262_comment},
  {"get_class_slot", &Dtool_AntialiasAttrib_get_class_slot_267, METH_NOARGS | METH_STATIC, (const char *)Dtool_AntialiasAttrib_get_class_slot_267_comment},
  {"getClassSlot", &Dtool_AntialiasAttrib_get_class_slot_267, METH_NOARGS | METH_STATIC, (const char *)Dtool_AntialiasAttrib_get_class_slot_267_comment},
  {"get_class_type", &Dtool_AntialiasAttrib_get_class_type_269, METH_NOARGS | METH_STATIC, (const char *)Dtool_AntialiasAttrib_get_class_type_269_comment},
  {"getClassType", &Dtool_AntialiasAttrib_get_class_type_269, METH_NOARGS | METH_STATIC, (const char *)Dtool_AntialiasAttrib_get_class_type_269_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_AntialiasAttrib[] = {
  {(char *)"mode", &Dtool_AntialiasAttrib_mode_Getter, nullptr, nullptr, nullptr},
  {(char *)"mode_type", &Dtool_AntialiasAttrib_mode_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"mode_quality", &Dtool_AntialiasAttrib_mode_quality_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AntialiasAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AntialiasAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AntialiasAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AntialiasAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AntialiasAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AntialiasAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AntialiasAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AntialiasAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AntialiasAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AntialiasAttrib,
    &Dtool_SequenceMethods_AntialiasAttrib,
    &Dtool_MappingMethods_AntialiasAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AntialiasAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Specifies whether or how to enable antialiasing, if supported by the\n"
    " * backend renderer.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AntialiasAttrib,
    nullptr, // tp_members
    Dtool_Properties_AntialiasAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AntialiasAttrib,
    PyType_GenericAlloc,
    Dtool_new_AntialiasAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AntialiasAttrib,
  Dtool_UpcastInterface_AntialiasAttrib,
  Dtool_DowncastInterface_AntialiasAttrib,
  (CoerceFunction)Dtool_ConstCoerce_AntialiasAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_AntialiasAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_AntialiasAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_AntialiasAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(21);
    Dtool_AntialiasAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum AntialiasAttrib::Mode;
    PyDict_SetItemString(dict, "M_none", Dtool_WrapValue(AntialiasAttrib::M_none));
    PyDict_SetItemString(dict, "MNone", Dtool_WrapValue(AntialiasAttrib::M_none));
    PyDict_SetItemString(dict, "M_point", Dtool_WrapValue(AntialiasAttrib::M_point));
    PyDict_SetItemString(dict, "MPoint", Dtool_WrapValue(AntialiasAttrib::M_point));
    PyDict_SetItemString(dict, "M_line", Dtool_WrapValue(AntialiasAttrib::M_line));
    PyDict_SetItemString(dict, "MLine", Dtool_WrapValue(AntialiasAttrib::M_line));
    PyDict_SetItemString(dict, "M_polygon", Dtool_WrapValue(AntialiasAttrib::M_polygon));
    PyDict_SetItemString(dict, "MPolygon", Dtool_WrapValue(AntialiasAttrib::M_polygon));
    PyDict_SetItemString(dict, "M_multisample", Dtool_WrapValue(AntialiasAttrib::M_multisample));
    PyDict_SetItemString(dict, "MMultisample", Dtool_WrapValue(AntialiasAttrib::M_multisample));
    PyDict_SetItemString(dict, "M_auto", Dtool_WrapValue(AntialiasAttrib::M_auto));
    PyDict_SetItemString(dict, "MAuto", Dtool_WrapValue(AntialiasAttrib::M_auto));
    PyDict_SetItemString(dict, "M_type_mask", Dtool_WrapValue(AntialiasAttrib::M_type_mask));
    PyDict_SetItemString(dict, "MTypeMask", Dtool_WrapValue(AntialiasAttrib::M_type_mask));
    PyDict_SetItemString(dict, "M_faster", Dtool_WrapValue(AntialiasAttrib::M_faster));
    PyDict_SetItemString(dict, "MFaster", Dtool_WrapValue(AntialiasAttrib::M_faster));
    PyDict_SetItemString(dict, "M_better", Dtool_WrapValue(AntialiasAttrib::M_better));
    PyDict_SetItemString(dict, "MBetter", Dtool_WrapValue(AntialiasAttrib::M_better));
    PyDict_SetItemString(dict, "M_dont_care", Dtool_WrapValue(AntialiasAttrib::M_dont_care));
    PyDict_SetItemString(dict, "MDontCare", Dtool_WrapValue(AntialiasAttrib::M_dont_care));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_AntialiasAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_AntialiasAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_AntialiasAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AntialiasAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AntialiasAttrib);
  }
}

/**
 * Python method tables for RenderEffect (RenderEffect)
 */
static PyMethodDef Dtool_Methods_RenderEffect[] = {
  {"compare_to", &Dtool_RenderEffect_compare_to_272, METH_O, (const char *)Dtool_RenderEffect_compare_to_272_comment},
  {"compareTo", &Dtool_RenderEffect_compare_to_272, METH_O, (const char *)Dtool_RenderEffect_compare_to_272_comment},
  {"output", &Dtool_RenderEffect_output_273, METH_O, (const char *)Dtool_RenderEffect_output_273_comment},
  {"write", (PyCFunction) &Dtool_RenderEffect_write_274, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderEffect_write_274_comment},
  {"get_num_effects", &Dtool_RenderEffect_get_num_effects_275, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffect_get_num_effects_275_comment},
  {"getNumEffects", &Dtool_RenderEffect_get_num_effects_275, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffect_get_num_effects_275_comment},
  {"list_effects", &Dtool_RenderEffect_list_effects_276, METH_O | METH_STATIC, (const char *)Dtool_RenderEffect_list_effects_276_comment},
  {"listEffects", &Dtool_RenderEffect_list_effects_276, METH_O | METH_STATIC, (const char *)Dtool_RenderEffect_list_effects_276_comment},
  {"validate_effects", &Dtool_RenderEffect_validate_effects_277, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffect_validate_effects_277_comment},
  {"validateEffects", &Dtool_RenderEffect_validate_effects_277, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffect_validate_effects_277_comment},
  {"get_class_type", &Dtool_RenderEffect_get_class_type_278, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffect_get_class_type_278_comment},
  {"getClassType", &Dtool_RenderEffect_get_class_type_278, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffect_get_class_type_278_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// RenderEffect slot tp_compare -> compare_to
//////////////////
static int Dtool_RenderEffect_compare_to_272_tp_compare(PyObject *self, PyObject *arg) {
  RenderEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderEffect, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int RenderEffect::compare_to(RenderEffect const &other) const
  RenderEffect const *arg_this = (RenderEffect *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RenderEffect, 1, "RenderEffect.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const RenderEffect*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(RenderEffect self, const RenderEffect other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     RenderEffect
//////////////////
static PyObject *Dtool_Repr_RenderEffect(PyObject *self) {
  RenderEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderEffect, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     RenderEffect
//////////////////
static PyObject *Dtool_Str_RenderEffect(PyObject *self) {
  RenderEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderEffect, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     RenderEffect
//////////////////
static PyObject *Dtool_RichCompare_RenderEffect(PyObject *self, PyObject *arg, int op) {
  RenderEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderEffect, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_RenderEffect_compare_to_272_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_RenderEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RenderEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RenderEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RenderEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RenderEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RenderEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RenderEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RenderEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RenderEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_RenderEffect_compare_to_272_tp_compare,
#endif
    &Dtool_Repr_RenderEffect,
    &Dtool_NumberMethods_RenderEffect,
    &Dtool_SequenceMethods_RenderEffect,
    &Dtool_MappingMethods_RenderEffect,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_RenderEffect,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RenderEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for a number of special render effects that may be\n"
    " * set on scene graph nodes to change the way they render.  This includes\n"
    " * BillboardEffect, DecalEffect, etc.\n"
    " *\n"
    " * RenderEffect represents render properties that must be applied as soon as\n"
    " * they are encountered in the scene graph, rather than propagating down to\n"
    " * the leaves.  This is different from RenderAttrib, which represents\n"
    " * properties like color and texture that don't do anything until they\n"
    " * propagate down to a GeomNode.\n"
    " *\n"
    " * You should not attempt to create or modify a RenderEffect directly;\n"
    " * instead, use the make() method of the appropriate kind of effect you want.\n"
    " * This will allocate and return a new RenderEffect of the appropriate type,\n"
    " * and it may share pointers if possible.  Do not modify the new RenderEffect\n"
    " * if you wish to change its properties; instead, create a new one.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_RenderEffect,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RenderEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RenderEffect,
    PyType_GenericAlloc,
    Dtool_new_RenderEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RenderEffect,
  Dtool_UpcastInterface_RenderEffect,
  Dtool_DowncastInterface_RenderEffect,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RenderEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_RenderEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_RenderEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RenderEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RenderEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RenderEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RenderEffect);
  }
}

/**
 * Python method tables for RenderEffects (RenderEffects)
 */
static PyMethodDef Dtool_Methods_RenderEffects[] = {
  {"is_empty", &Dtool_RenderEffects_is_empty_281, METH_NOARGS, (const char *)Dtool_RenderEffects_is_empty_281_comment},
  {"isEmpty", &Dtool_RenderEffects_is_empty_281, METH_NOARGS, (const char *)Dtool_RenderEffects_is_empty_281_comment},
  {"get_num_effects", &Dtool_RenderEffects_get_num_effects_282, METH_NOARGS, (const char *)Dtool_RenderEffects_get_num_effects_282_comment},
  {"getNumEffects", &Dtool_RenderEffects_get_num_effects_282, METH_NOARGS, (const char *)Dtool_RenderEffects_get_num_effects_282_comment},
  {"get_effect", &Dtool_RenderEffects_get_effect_283, METH_O, (const char *)Dtool_RenderEffects_get_effect_283_comment},
  {"getEffect", &Dtool_RenderEffects_get_effect_283, METH_O, (const char *)Dtool_RenderEffects_get_effect_283_comment},
  {"__getitem__", &Dtool_RenderEffects_operator_285, METH_O, (const char *)Dtool_RenderEffects_operator_285_comment},
  {"find_effect", &Dtool_RenderEffects_find_effect_286, METH_O, (const char *)Dtool_RenderEffects_find_effect_286_comment},
  {"findEffect", &Dtool_RenderEffects_find_effect_286, METH_O, (const char *)Dtool_RenderEffects_find_effect_286_comment},
  {"make_empty", &Dtool_RenderEffects_make_empty_287, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffects_make_empty_287_comment},
  {"makeEmpty", &Dtool_RenderEffects_make_empty_287, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffects_make_empty_287_comment},
  {"make", (PyCFunction) &Dtool_RenderEffects_make_288, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_RenderEffects_make_288_comment},
  {"add_effect", &Dtool_RenderEffects_add_effect_289, METH_O, (const char *)Dtool_RenderEffects_add_effect_289_comment},
  {"addEffect", &Dtool_RenderEffects_add_effect_289, METH_O, (const char *)Dtool_RenderEffects_add_effect_289_comment},
  {"remove_effect", &Dtool_RenderEffects_remove_effect_290, METH_O, (const char *)Dtool_RenderEffects_remove_effect_290_comment},
  {"removeEffect", &Dtool_RenderEffects_remove_effect_290, METH_O, (const char *)Dtool_RenderEffects_remove_effect_290_comment},
  {"output", &Dtool_RenderEffects_output_291, METH_O, (const char *)Dtool_RenderEffects_output_291_comment},
  {"write", (PyCFunction) &Dtool_RenderEffects_write_292, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RenderEffects_write_292_comment},
  {"get_num_states", &Dtool_RenderEffects_get_num_states_293, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffects_get_num_states_293_comment},
  {"getNumStates", &Dtool_RenderEffects_get_num_states_293, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffects_get_num_states_293_comment},
  {"list_states", &Dtool_RenderEffects_list_states_294, METH_O | METH_STATIC, (const char *)Dtool_RenderEffects_list_states_294_comment},
  {"listStates", &Dtool_RenderEffects_list_states_294, METH_O | METH_STATIC, (const char *)Dtool_RenderEffects_list_states_294_comment},
  {"validate_states", &Dtool_RenderEffects_validate_states_295, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffects_validate_states_295_comment},
  {"validateStates", &Dtool_RenderEffects_validate_states_295, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffects_validate_states_295_comment},
  {"get_class_type", &Dtool_RenderEffects_get_class_type_296, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffects_get_class_type_296_comment},
  {"getClassType", &Dtool_RenderEffects_get_class_type_296, METH_NOARGS | METH_STATIC, (const char *)Dtool_RenderEffects_get_class_type_296_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// RenderEffects slot sq_item -> operator []
//////////////////
static PyObject *Dtool_RenderEffects_operator_285_sq_item(PyObject *self, Py_ssize_t index) {
  RenderEffects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderEffects, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "RenderEffects index out of range");
    return nullptr;
  }
  // 1-inline RenderEffect const *RenderEffects::operator [](std::size_t n) const
  RenderEffect const *return_value = ((*(const RenderEffects*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderEffect, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(RenderEffects self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// RenderEffects slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_RenderEffects_size_284_sq_length(PyObject *self) {
  RenderEffects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderEffects, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     RenderEffects
//////////////////
static PyObject *Dtool_Repr_RenderEffects(PyObject *self) {
  RenderEffects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderEffects, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     RenderEffects
//////////////////
static PyObject *Dtool_Str_RenderEffects(PyObject *self) {
  RenderEffects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderEffects, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     RenderEffects
//////////////////
static PyObject *Dtool_RichCompare_RenderEffects(PyObject *self, PyObject *arg, int op) {
  RenderEffects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RenderEffects, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-bool RenderEffects::operator <(RenderEffects const &other) const
      CPT(RenderEffects) arg_this;
      if (Dtool_ConstCoerce_RenderEffects(arg, arg_this)) {
        bool return_value = ((*(const RenderEffects*)local_this).operator <)(*std::move(arg_this));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_RenderEffects = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RenderEffects = {
  &Dtool_RenderEffects_size_284_sq_length,
  nullptr,
  nullptr,
  &Dtool_RenderEffects_operator_285_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RenderEffects = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RenderEffects = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RenderEffects = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RenderEffects = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RenderEffects",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RenderEffects,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RenderEffects,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    &Dtool_Repr_RenderEffects,
    &Dtool_NumberMethods_RenderEffects,
    &Dtool_SequenceMethods_RenderEffects,
    &Dtool_MappingMethods_RenderEffects,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_RenderEffects,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RenderEffects,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a unique collection of RenderEffect objects that correspond\n"
    " * to a particular renderable state.\n"
    " *\n"
    " * You should not attempt to create or modify a RenderEffects object directly.\n"
    " * Instead, call one of the make() functions to create one for you.  And\n"
    " * instead of modifying a RenderEffects object, create a new one.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_RenderEffects,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RenderEffects,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RenderEffects,
    PyType_GenericAlloc,
    Dtool_new_RenderEffects,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RenderEffects,
  Dtool_UpcastInterface_RenderEffects,
  Dtool_DowncastInterface_RenderEffects,
  (CoerceFunction)Dtool_ConstCoerce_RenderEffects,
  nullptr,
};

static void Dtool_PyModuleClassInit_RenderEffects(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_RenderEffects._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_RenderEffects._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RenderEffects._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RenderEffects) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RenderEffects)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RenderEffects);
  }
}

/**
 * Python method tables for PandaNode_Children (Children)
 */
static PyMethodDef Dtool_Methods_PandaNode_Children[] = {
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PandaNode_Children slot sq_item -> operator []
//////////////////
static PyObject *Dtool_PandaNode_Children_operator_461_sq_item(PyObject *self, Py_ssize_t index) {
  PandaNode::Children *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode_Children, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PandaNode_Children index out of range");
    return nullptr;
  }
  // 1-inline PandaNode *PandaNode::Children::operator [](std::size_t n) const
  PandaNode *return_value = ((*(const PandaNode::Children*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Children self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PandaNode_Children slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PandaNode_Children_size_462_sq_length(PyObject *self) {
  PandaNode::Children *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode_Children, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PandaNode_Children = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PandaNode_Children = {
  &Dtool_PandaNode_Children_size_462_sq_length,
  nullptr,
  nullptr,
  &Dtool_PandaNode_Children_operator_461_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_PandaNode_Children = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Children",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PandaNode_Children,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PandaNode_Children,
    &Dtool_SequenceMethods_PandaNode_Children,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// This class is returned from get_children().  Use it to walk through the\n"
    "// list of children.  This is faster, and safer, than walking through the\n"
    "// children one at a time via get_num_children()/get_child(), since the list\n"
    "// of children is saved out ahead of time, rather than having to reacquire\n"
    "// the lock with each iteration, or to keep the lock held for the entire\n"
    "// pass.",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PandaNode_Children,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PandaNode_Children,
    PyType_GenericAlloc,
    Dtool_new_PandaNode_Children,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PandaNode_Children,
  Dtool_UpcastInterface_PandaNode_Children,
  Dtool_DowncastInterface_PandaNode_Children,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PandaNode_Children(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PandaNode_Children._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PandaNode_Children._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PandaNode_Children) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PandaNode_Children)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PandaNode_Children);
  }
}

/**
 * Python method tables for PandaNode_Stashed (Stashed)
 */
static PyMethodDef Dtool_Methods_PandaNode_Stashed[] = {
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PandaNode_Stashed slot sq_item -> operator []
//////////////////
static PyObject *Dtool_PandaNode_Stashed_operator_465_sq_item(PyObject *self, Py_ssize_t index) {
  PandaNode::Stashed *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode_Stashed, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PandaNode_Stashed index out of range");
    return nullptr;
  }
  // 1-inline PandaNode *PandaNode::Stashed::operator [](std::size_t n) const
  PandaNode *return_value = ((*(const PandaNode::Stashed*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Stashed self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PandaNode_Stashed slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PandaNode_Stashed_size_466_sq_length(PyObject *self) {
  PandaNode::Stashed *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode_Stashed, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PandaNode_Stashed = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PandaNode_Stashed = {
  &Dtool_PandaNode_Stashed_size_466_sq_length,
  nullptr,
  nullptr,
  &Dtool_PandaNode_Stashed_operator_465_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_PandaNode_Stashed = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Stashed",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PandaNode_Stashed,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PandaNode_Stashed,
    &Dtool_SequenceMethods_PandaNode_Stashed,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Similarly for stashed children.",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PandaNode_Stashed,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PandaNode_Stashed,
    PyType_GenericAlloc,
    Dtool_new_PandaNode_Stashed,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PandaNode_Stashed,
  Dtool_UpcastInterface_PandaNode_Stashed,
  Dtool_DowncastInterface_PandaNode_Stashed,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PandaNode_Stashed(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PandaNode_Stashed._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PandaNode_Stashed._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PandaNode_Stashed) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PandaNode_Stashed)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PandaNode_Stashed);
  }
}

/**
 * Python method tables for PandaNode_Parents (Parents)
 */
static PyMethodDef Dtool_Methods_PandaNode_Parents[] = {
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PandaNode_Parents slot sq_item -> operator []
//////////////////
static PyObject *Dtool_PandaNode_Parents_operator_469_sq_item(PyObject *self, Py_ssize_t index) {
  PandaNode::Parents *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode_Parents, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PandaNode_Parents index out of range");
    return nullptr;
  }
  // 1-inline PandaNode *PandaNode::Parents::operator [](std::size_t n) const
  PandaNode *return_value = ((*(const PandaNode::Parents*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Parents self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PandaNode_Parents slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PandaNode_Parents_size_470_sq_length(PyObject *self) {
  PandaNode::Parents *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode_Parents, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PandaNode_Parents = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PandaNode_Parents = {
  &Dtool_PandaNode_Parents_size_470_sq_length,
  nullptr,
  nullptr,
  &Dtool_PandaNode_Parents_operator_469_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_PandaNode_Parents = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Parents",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PandaNode_Parents,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PandaNode_Parents,
    &Dtool_SequenceMethods_PandaNode_Parents,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// This class is returned from get_parents().",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PandaNode_Parents,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PandaNode_Parents,
    PyType_GenericAlloc,
    Dtool_new_PandaNode_Parents,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PandaNode_Parents,
  Dtool_UpcastInterface_PandaNode_Parents,
  Dtool_DowncastInterface_PandaNode_Parents,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PandaNode_Parents(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PandaNode_Parents._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PandaNode_Parents._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PandaNode_Parents) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PandaNode_Parents)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PandaNode_Parents);
  }
}

/**
 * Python method tables for PandaNode (PandaNode)
 */
static PyMethodDef Dtool_Methods_PandaNode[] = {
  {"combine_with", &Dtool_PandaNode_combine_with_308, METH_O, (const char *)Dtool_PandaNode_combine_with_308_comment},
  {"combineWith", &Dtool_PandaNode_combine_with_308, METH_O, (const char *)Dtool_PandaNode_combine_with_308_comment},
  {"make_copy", &Dtool_PandaNode_make_copy_309, METH_NOARGS, (const char *)Dtool_PandaNode_make_copy_309_comment},
  {"makeCopy", &Dtool_PandaNode_make_copy_309, METH_NOARGS, (const char *)Dtool_PandaNode_make_copy_309_comment},
  {"copy_subgraph", (PyCFunction) &Dtool_PandaNode_copy_subgraph_310, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_copy_subgraph_310_comment},
  {"copySubgraph", (PyCFunction) &Dtool_PandaNode_copy_subgraph_310, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_copy_subgraph_310_comment},
  {"__copy__", &Dtool_PandaNode_copy_311, METH_NOARGS, (const char *)Dtool_PandaNode_copy_311_comment},
  {"__deepcopy__", &Dtool_PandaNode_deepcopy_312, METH_O, (const char *)Dtool_PandaNode_deepcopy_312_comment},
  {"get_num_parents", (PyCFunction) &Dtool_PandaNode_get_num_parents_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_num_parents_313_comment},
  {"getNumParents", (PyCFunction) &Dtool_PandaNode_get_num_parents_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_num_parents_313_comment},
  {"get_parent", (PyCFunction) &Dtool_PandaNode_get_parent_314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_parent_314_comment},
  {"getParent", (PyCFunction) &Dtool_PandaNode_get_parent_314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_parent_314_comment},
  {"find_parent", (PyCFunction) &Dtool_PandaNode_find_parent_315, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_find_parent_315_comment},
  {"findParent", (PyCFunction) &Dtool_PandaNode_find_parent_315, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_find_parent_315_comment},
  {"get_num_children", (PyCFunction) &Dtool_PandaNode_get_num_children_317, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_num_children_317_comment},
  {"getNumChildren", (PyCFunction) &Dtool_PandaNode_get_num_children_317, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_num_children_317_comment},
  {"get_child", (PyCFunction) &Dtool_PandaNode_get_child_318, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_child_318_comment},
  {"getChild", (PyCFunction) &Dtool_PandaNode_get_child_318, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_child_318_comment},
  {"get_child_sort", (PyCFunction) &Dtool_PandaNode_get_child_sort_319, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_child_sort_319_comment},
  {"getChildSort", (PyCFunction) &Dtool_PandaNode_get_child_sort_319, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_child_sort_319_comment},
  {"find_child", (PyCFunction) &Dtool_PandaNode_find_child_320, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_find_child_320_comment},
  {"findChild", (PyCFunction) &Dtool_PandaNode_find_child_320, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_find_child_320_comment},
  {"count_num_descendants", &Dtool_PandaNode_count_num_descendants_322, METH_NOARGS, (const char *)Dtool_PandaNode_count_num_descendants_322_comment},
  {"countNumDescendants", &Dtool_PandaNode_count_num_descendants_322, METH_NOARGS, (const char *)Dtool_PandaNode_count_num_descendants_322_comment},
  {"add_child", (PyCFunction) &Dtool_PandaNode_add_child_323, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_add_child_323_comment},
  {"addChild", (PyCFunction) &Dtool_PandaNode_add_child_323, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_add_child_323_comment},
  {"remove_child", (PyCFunction) &Dtool_PandaNode_remove_child_324, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_remove_child_324_comment},
  {"removeChild", (PyCFunction) &Dtool_PandaNode_remove_child_324, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_remove_child_324_comment},
  {"replace_child", (PyCFunction) &Dtool_PandaNode_replace_child_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_replace_child_325_comment},
  {"replaceChild", (PyCFunction) &Dtool_PandaNode_replace_child_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_replace_child_325_comment},
  {"stash_child", (PyCFunction) &Dtool_PandaNode_stash_child_326, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_stash_child_326_comment},
  {"stashChild", (PyCFunction) &Dtool_PandaNode_stash_child_326, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_stash_child_326_comment},
  {"unstash_child", (PyCFunction) &Dtool_PandaNode_unstash_child_327, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_unstash_child_327_comment},
  {"unstashChild", (PyCFunction) &Dtool_PandaNode_unstash_child_327, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_unstash_child_327_comment},
  {"get_num_stashed", (PyCFunction) &Dtool_PandaNode_get_num_stashed_328, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_num_stashed_328_comment},
  {"getNumStashed", (PyCFunction) &Dtool_PandaNode_get_num_stashed_328, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_num_stashed_328_comment},
  {"get_stashed", (PyCFunction) &Dtool_PandaNode_get_stashed_329, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_stashed_329_comment},
  {"getStashed", (PyCFunction) &Dtool_PandaNode_get_stashed_329, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_stashed_329_comment},
  {"get_stashed_sort", (PyCFunction) &Dtool_PandaNode_get_stashed_sort_330, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_stashed_sort_330_comment},
  {"getStashedSort", (PyCFunction) &Dtool_PandaNode_get_stashed_sort_330, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_stashed_sort_330_comment},
  {"find_stashed", (PyCFunction) &Dtool_PandaNode_find_stashed_331, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_find_stashed_331_comment},
  {"findStashed", (PyCFunction) &Dtool_PandaNode_find_stashed_331, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_find_stashed_331_comment},
  {"add_stashed", (PyCFunction) &Dtool_PandaNode_add_stashed_333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_add_stashed_333_comment},
  {"addStashed", (PyCFunction) &Dtool_PandaNode_add_stashed_333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_add_stashed_333_comment},
  {"remove_stashed", (PyCFunction) &Dtool_PandaNode_remove_stashed_334, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_remove_stashed_334_comment},
  {"removeStashed", (PyCFunction) &Dtool_PandaNode_remove_stashed_334, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_remove_stashed_334_comment},
  {"remove_all_children", (PyCFunction) &Dtool_PandaNode_remove_all_children_335, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_remove_all_children_335_comment},
  {"removeAllChildren", (PyCFunction) &Dtool_PandaNode_remove_all_children_335, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_remove_all_children_335_comment},
  {"steal_children", (PyCFunction) &Dtool_PandaNode_steal_children_336, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_steal_children_336_comment},
  {"stealChildren", (PyCFunction) &Dtool_PandaNode_steal_children_336, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_steal_children_336_comment},
  {"copy_children", (PyCFunction) &Dtool_PandaNode_copy_children_337, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_copy_children_337_comment},
  {"copyChildren", (PyCFunction) &Dtool_PandaNode_copy_children_337, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_copy_children_337_comment},
  {"set_attrib", (PyCFunction) &Dtool_PandaNode_set_attrib_338, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_attrib_338_comment},
  {"setAttrib", (PyCFunction) &Dtool_PandaNode_set_attrib_338, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_attrib_338_comment},
  {"get_attrib", &Dtool_PandaNode_get_attrib_339, METH_O, (const char *)Dtool_PandaNode_get_attrib_339_comment},
  {"getAttrib", &Dtool_PandaNode_get_attrib_339, METH_O, (const char *)Dtool_PandaNode_get_attrib_339_comment},
  {"has_attrib", &Dtool_PandaNode_has_attrib_340, METH_O, (const char *)Dtool_PandaNode_has_attrib_340_comment},
  {"hasAttrib", &Dtool_PandaNode_has_attrib_340, METH_O, (const char *)Dtool_PandaNode_has_attrib_340_comment},
  {"clear_attrib", &Dtool_PandaNode_clear_attrib_341, METH_O, (const char *)Dtool_PandaNode_clear_attrib_341_comment},
  {"clearAttrib", &Dtool_PandaNode_clear_attrib_341, METH_O, (const char *)Dtool_PandaNode_clear_attrib_341_comment},
  {"set_effect", &Dtool_PandaNode_set_effect_342, METH_O, (const char *)Dtool_PandaNode_set_effect_342_comment},
  {"setEffect", &Dtool_PandaNode_set_effect_342, METH_O, (const char *)Dtool_PandaNode_set_effect_342_comment},
  {"get_effect", &Dtool_PandaNode_get_effect_343, METH_O, (const char *)Dtool_PandaNode_get_effect_343_comment},
  {"getEffect", &Dtool_PandaNode_get_effect_343, METH_O, (const char *)Dtool_PandaNode_get_effect_343_comment},
  {"has_effect", &Dtool_PandaNode_has_effect_344, METH_O, (const char *)Dtool_PandaNode_has_effect_344_comment},
  {"hasEffect", &Dtool_PandaNode_has_effect_344, METH_O, (const char *)Dtool_PandaNode_has_effect_344_comment},
  {"clear_effect", &Dtool_PandaNode_clear_effect_345, METH_O, (const char *)Dtool_PandaNode_clear_effect_345_comment},
  {"clearEffect", &Dtool_PandaNode_clear_effect_345, METH_O, (const char *)Dtool_PandaNode_clear_effect_345_comment},
  {"set_state", (PyCFunction) &Dtool_PandaNode_set_state_346, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_state_346_comment},
  {"setState", (PyCFunction) &Dtool_PandaNode_set_state_346, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_state_346_comment},
  {"get_state", (PyCFunction) &Dtool_PandaNode_get_state_347, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_state_347_comment},
  {"getState", (PyCFunction) &Dtool_PandaNode_get_state_347, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_state_347_comment},
  {"clear_state", (PyCFunction) &Dtool_PandaNode_clear_state_348, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_clear_state_348_comment},
  {"clearState", (PyCFunction) &Dtool_PandaNode_clear_state_348, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_clear_state_348_comment},
  {"set_effects", (PyCFunction) &Dtool_PandaNode_set_effects_351, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_effects_351_comment},
  {"setEffects", (PyCFunction) &Dtool_PandaNode_set_effects_351, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_effects_351_comment},
  {"get_effects", (PyCFunction) &Dtool_PandaNode_get_effects_352, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_effects_352_comment},
  {"getEffects", (PyCFunction) &Dtool_PandaNode_get_effects_352, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_effects_352_comment},
  {"clear_effects", (PyCFunction) &Dtool_PandaNode_clear_effects_353, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_clear_effects_353_comment},
  {"clearEffects", (PyCFunction) &Dtool_PandaNode_clear_effects_353, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_clear_effects_353_comment},
  {"set_transform", (PyCFunction) &Dtool_PandaNode_set_transform_356, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_transform_356_comment},
  {"setTransform", (PyCFunction) &Dtool_PandaNode_set_transform_356, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_transform_356_comment},
  {"get_transform", (PyCFunction) &Dtool_PandaNode_get_transform_357, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_transform_357_comment},
  {"getTransform", (PyCFunction) &Dtool_PandaNode_get_transform_357, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_transform_357_comment},
  {"clear_transform", (PyCFunction) &Dtool_PandaNode_clear_transform_358, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_clear_transform_358_comment},
  {"clearTransform", (PyCFunction) &Dtool_PandaNode_clear_transform_358, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_clear_transform_358_comment},
  {"set_prev_transform", (PyCFunction) &Dtool_PandaNode_set_prev_transform_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_prev_transform_361_comment},
  {"setPrevTransform", (PyCFunction) &Dtool_PandaNode_set_prev_transform_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_prev_transform_361_comment},
  {"get_prev_transform", (PyCFunction) &Dtool_PandaNode_get_prev_transform_362, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_prev_transform_362_comment},
  {"getPrevTransform", (PyCFunction) &Dtool_PandaNode_get_prev_transform_362, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_prev_transform_362_comment},
  {"reset_prev_transform", (PyCFunction) &Dtool_PandaNode_reset_prev_transform_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_reset_prev_transform_363_comment},
  {"resetPrevTransform", (PyCFunction) &Dtool_PandaNode_reset_prev_transform_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_reset_prev_transform_363_comment},
  {"has_dirty_prev_transform", &Dtool_PandaNode_has_dirty_prev_transform_364, METH_NOARGS, (const char *)Dtool_PandaNode_has_dirty_prev_transform_364_comment},
  {"hasDirtyPrevTransform", &Dtool_PandaNode_has_dirty_prev_transform_364, METH_NOARGS, (const char *)Dtool_PandaNode_has_dirty_prev_transform_364_comment},
  {"reset_all_prev_transform", (PyCFunction) &Dtool_PandaNode_reset_all_prev_transform_365, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PandaNode_reset_all_prev_transform_365_comment},
  {"resetAllPrevTransform", (PyCFunction) &Dtool_PandaNode_reset_all_prev_transform_365, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PandaNode_reset_all_prev_transform_365_comment},
  {"set_tag", (PyCFunction) &Dtool_PandaNode_set_tag_367, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_tag_367_comment},
  {"setTag", (PyCFunction) &Dtool_PandaNode_set_tag_367, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_tag_367_comment},
  {"get_tag", (PyCFunction) &Dtool_PandaNode_get_tag_368, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_tag_368_comment},
  {"getTag", (PyCFunction) &Dtool_PandaNode_get_tag_368, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_tag_368_comment},
  {"has_tag", (PyCFunction) &Dtool_PandaNode_has_tag_369, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_has_tag_369_comment},
  {"hasTag", (PyCFunction) &Dtool_PandaNode_has_tag_369, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_has_tag_369_comment},
  {"clear_tag", (PyCFunction) &Dtool_PandaNode_clear_tag_370, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_clear_tag_370_comment},
  {"clearTag", (PyCFunction) &Dtool_PandaNode_clear_tag_370, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_clear_tag_370_comment},
  {"get_tag_keys", &Dtool_PandaNode_get_tag_keys_376, METH_NOARGS, (const char *)Dtool_PandaNode_get_tag_keys_376_comment},
  {"getTagKeys", &Dtool_PandaNode_get_tag_keys_376, METH_NOARGS, (const char *)Dtool_PandaNode_get_tag_keys_376_comment},
  {"get_python_tags", &Dtool_PandaNode_get_python_tags_377, METH_NOARGS, (const char *)Dtool_PandaNode_get_python_tags_377_comment},
  {"getPythonTags", &Dtool_PandaNode_get_python_tags_377, METH_NOARGS, (const char *)Dtool_PandaNode_get_python_tags_377_comment},
  {"set_python_tag", (PyCFunction) &Dtool_PandaNode_set_python_tag_378, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_python_tag_378_comment},
  {"setPythonTag", (PyCFunction) &Dtool_PandaNode_set_python_tag_378, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_set_python_tag_378_comment},
  {"get_python_tag", &Dtool_PandaNode_get_python_tag_379, METH_O, (const char *)Dtool_PandaNode_get_python_tag_379_comment},
  {"getPythonTag", &Dtool_PandaNode_get_python_tag_379, METH_O, (const char *)Dtool_PandaNode_get_python_tag_379_comment},
  {"has_python_tag", &Dtool_PandaNode_has_python_tag_380, METH_O, (const char *)Dtool_PandaNode_has_python_tag_380_comment},
  {"hasPythonTag", &Dtool_PandaNode_has_python_tag_380, METH_O, (const char *)Dtool_PandaNode_has_python_tag_380_comment},
  {"clear_python_tag", &Dtool_PandaNode_clear_python_tag_381, METH_O, (const char *)Dtool_PandaNode_clear_python_tag_381_comment},
  {"clearPythonTag", &Dtool_PandaNode_clear_python_tag_381, METH_O, (const char *)Dtool_PandaNode_clear_python_tag_381_comment},
  {"get_python_tag_keys", &Dtool_PandaNode_get_python_tag_keys_382, METH_NOARGS, (const char *)Dtool_PandaNode_get_python_tag_keys_382_comment},
  {"getPythonTagKeys", &Dtool_PandaNode_get_python_tag_keys_382, METH_NOARGS, (const char *)Dtool_PandaNode_get_python_tag_keys_382_comment},
  {"has_tags", &Dtool_PandaNode_has_tags_388, METH_NOARGS, (const char *)Dtool_PandaNode_has_tags_388_comment},
  {"hasTags", &Dtool_PandaNode_has_tags_388, METH_NOARGS, (const char *)Dtool_PandaNode_has_tags_388_comment},
  {"copy_tags", &Dtool_PandaNode_copy_tags_389, METH_O, (const char *)Dtool_PandaNode_copy_tags_389_comment},
  {"copyTags", &Dtool_PandaNode_copy_tags_389, METH_O, (const char *)Dtool_PandaNode_copy_tags_389_comment},
  {"list_tags", (PyCFunction) &Dtool_PandaNode_list_tags_390, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_list_tags_390_comment},
  {"listTags", (PyCFunction) &Dtool_PandaNode_list_tags_390, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_list_tags_390_comment},
  {"compare_tags", &Dtool_PandaNode_compare_tags_391, METH_O, (const char *)Dtool_PandaNode_compare_tags_391_comment},
  {"compareTags", &Dtool_PandaNode_compare_tags_391, METH_O, (const char *)Dtool_PandaNode_compare_tags_391_comment},
  {"copy_all_properties", &Dtool_PandaNode_copy_all_properties_392, METH_O, (const char *)Dtool_PandaNode_copy_all_properties_392_comment},
  {"copyAllProperties", &Dtool_PandaNode_copy_all_properties_392, METH_O, (const char *)Dtool_PandaNode_copy_all_properties_392_comment},
  {"replace_node", &Dtool_PandaNode_replace_node_393, METH_O, (const char *)Dtool_PandaNode_replace_node_393_comment},
  {"replaceNode", &Dtool_PandaNode_replace_node_393, METH_O, (const char *)Dtool_PandaNode_replace_node_393_comment},
  {"set_unexpected_change", &Dtool_PandaNode_set_unexpected_change_395, METH_O, (const char *)Dtool_PandaNode_set_unexpected_change_395_comment},
  {"setUnexpectedChange", &Dtool_PandaNode_set_unexpected_change_395, METH_O, (const char *)Dtool_PandaNode_set_unexpected_change_395_comment},
  {"get_unexpected_change", &Dtool_PandaNode_get_unexpected_change_396, METH_O, (const char *)Dtool_PandaNode_get_unexpected_change_396_comment},
  {"getUnexpectedChange", &Dtool_PandaNode_get_unexpected_change_396, METH_O, (const char *)Dtool_PandaNode_get_unexpected_change_396_comment},
  {"clear_unexpected_change", &Dtool_PandaNode_clear_unexpected_change_397, METH_O, (const char *)Dtool_PandaNode_clear_unexpected_change_397_comment},
  {"clearUnexpectedChange", &Dtool_PandaNode_clear_unexpected_change_397, METH_O, (const char *)Dtool_PandaNode_clear_unexpected_change_397_comment},
  {"get_overall_bit", &Dtool_PandaNode_get_overall_bit_398, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaNode_get_overall_bit_398_comment},
  {"getOverallBit", &Dtool_PandaNode_get_overall_bit_398, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaNode_get_overall_bit_398_comment},
  {"get_all_camera_mask", &Dtool_PandaNode_get_all_camera_mask_399, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaNode_get_all_camera_mask_399_comment},
  {"getAllCameraMask", &Dtool_PandaNode_get_all_camera_mask_399, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaNode_get_all_camera_mask_399_comment},
  {"is_overall_hidden", &Dtool_PandaNode_is_overall_hidden_400, METH_NOARGS, (const char *)Dtool_PandaNode_is_overall_hidden_400_comment},
  {"isOverallHidden", &Dtool_PandaNode_is_overall_hidden_400, METH_NOARGS, (const char *)Dtool_PandaNode_is_overall_hidden_400_comment},
  {"set_overall_hidden", &Dtool_PandaNode_set_overall_hidden_401, METH_O, (const char *)Dtool_PandaNode_set_overall_hidden_401_comment},
  {"setOverallHidden", &Dtool_PandaNode_set_overall_hidden_401, METH_O, (const char *)Dtool_PandaNode_set_overall_hidden_401_comment},
  {"adjust_draw_mask", (PyCFunction) &Dtool_PandaNode_adjust_draw_mask_408, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_adjust_draw_mask_408_comment},
  {"adjustDrawMask", (PyCFunction) &Dtool_PandaNode_adjust_draw_mask_408, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_adjust_draw_mask_408_comment},
  {"get_draw_control_mask", &Dtool_PandaNode_get_draw_control_mask_409, METH_NOARGS, (const char *)Dtool_PandaNode_get_draw_control_mask_409_comment},
  {"getDrawControlMask", &Dtool_PandaNode_get_draw_control_mask_409, METH_NOARGS, (const char *)Dtool_PandaNode_get_draw_control_mask_409_comment},
  {"get_draw_show_mask", &Dtool_PandaNode_get_draw_show_mask_410, METH_NOARGS, (const char *)Dtool_PandaNode_get_draw_show_mask_410_comment},
  {"getDrawShowMask", &Dtool_PandaNode_get_draw_show_mask_410, METH_NOARGS, (const char *)Dtool_PandaNode_get_draw_show_mask_410_comment},
  {"get_net_draw_control_mask", &Dtool_PandaNode_get_net_draw_control_mask_413, METH_NOARGS, (const char *)Dtool_PandaNode_get_net_draw_control_mask_413_comment},
  {"getNetDrawControlMask", &Dtool_PandaNode_get_net_draw_control_mask_413, METH_NOARGS, (const char *)Dtool_PandaNode_get_net_draw_control_mask_413_comment},
  {"get_net_draw_show_mask", &Dtool_PandaNode_get_net_draw_show_mask_414, METH_NOARGS, (const char *)Dtool_PandaNode_get_net_draw_show_mask_414_comment},
  {"getNetDrawShowMask", &Dtool_PandaNode_get_net_draw_show_mask_414, METH_NOARGS, (const char *)Dtool_PandaNode_get_net_draw_show_mask_414_comment},
  {"set_into_collide_mask", &Dtool_PandaNode_set_into_collide_mask_415, METH_O, (const char *)Dtool_PandaNode_set_into_collide_mask_415_comment},
  {"setIntoCollideMask", &Dtool_PandaNode_set_into_collide_mask_415, METH_O, (const char *)Dtool_PandaNode_set_into_collide_mask_415_comment},
  {"get_into_collide_mask", &Dtool_PandaNode_get_into_collide_mask_416, METH_NOARGS, (const char *)Dtool_PandaNode_get_into_collide_mask_416_comment},
  {"getIntoCollideMask", &Dtool_PandaNode_get_into_collide_mask_416, METH_NOARGS, (const char *)Dtool_PandaNode_get_into_collide_mask_416_comment},
  {"get_legal_collide_mask", &Dtool_PandaNode_get_legal_collide_mask_417, METH_NOARGS, (const char *)Dtool_PandaNode_get_legal_collide_mask_417_comment},
  {"getLegalCollideMask", &Dtool_PandaNode_get_legal_collide_mask_417, METH_NOARGS, (const char *)Dtool_PandaNode_get_legal_collide_mask_417_comment},
  {"get_net_collide_mask", (PyCFunction) &Dtool_PandaNode_get_net_collide_mask_421, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_net_collide_mask_421_comment},
  {"getNetCollideMask", (PyCFunction) &Dtool_PandaNode_get_net_collide_mask_421, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_net_collide_mask_421_comment},
  {"get_off_clip_planes", (PyCFunction) &Dtool_PandaNode_get_off_clip_planes_422, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_off_clip_planes_422_comment},
  {"getOffClipPlanes", (PyCFunction) &Dtool_PandaNode_get_off_clip_planes_422, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_off_clip_planes_422_comment},
  {"prepare_scene", (PyCFunction) &Dtool_PandaNode_prepare_scene_423, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_prepare_scene_423_comment},
  {"prepareScene", (PyCFunction) &Dtool_PandaNode_prepare_scene_423, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_prepare_scene_423_comment},
  {"is_scene_root", &Dtool_PandaNode_is_scene_root_424, METH_NOARGS, (const char *)Dtool_PandaNode_is_scene_root_424_comment},
  {"isSceneRoot", &Dtool_PandaNode_is_scene_root_424, METH_NOARGS, (const char *)Dtool_PandaNode_is_scene_root_424_comment},
  {"is_under_scene_root", &Dtool_PandaNode_is_under_scene_root_425, METH_NOARGS, (const char *)Dtool_PandaNode_is_under_scene_root_425_comment},
  {"isUnderSceneRoot", &Dtool_PandaNode_is_under_scene_root_425, METH_NOARGS, (const char *)Dtool_PandaNode_is_under_scene_root_425_comment},
  {"output", &Dtool_PandaNode_output_426, METH_O, (const char *)Dtool_PandaNode_output_426_comment},
  {"write", (PyCFunction) &Dtool_PandaNode_write_427, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_write_427_comment},
  {"ls", (PyCFunction) &Dtool_PandaNode_ls_428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_ls_428_comment},
  {"set_bounds_type", &Dtool_PandaNode_set_bounds_type_429, METH_O, (const char *)Dtool_PandaNode_set_bounds_type_429_comment},
  {"setBoundsType", &Dtool_PandaNode_set_bounds_type_429, METH_O, (const char *)Dtool_PandaNode_set_bounds_type_429_comment},
  {"get_bounds_type", &Dtool_PandaNode_get_bounds_type_430, METH_NOARGS, (const char *)Dtool_PandaNode_get_bounds_type_430_comment},
  {"getBoundsType", &Dtool_PandaNode_get_bounds_type_430, METH_NOARGS, (const char *)Dtool_PandaNode_get_bounds_type_430_comment},
  {"set_bounds", &Dtool_PandaNode_set_bounds_434, METH_O, (const char *)Dtool_PandaNode_set_bounds_434_comment},
  {"setBounds", &Dtool_PandaNode_set_bounds_434, METH_O, (const char *)Dtool_PandaNode_set_bounds_434_comment},
  {"set_bound", &Dtool_PandaNode_set_bound_435, METH_O, (const char *)Dtool_PandaNode_set_bound_435_comment},
  {"setBound", &Dtool_PandaNode_set_bound_435, METH_O, (const char *)Dtool_PandaNode_set_bound_435_comment},
  {"clear_bounds", &Dtool_PandaNode_clear_bounds_436, METH_NOARGS, (const char *)Dtool_PandaNode_clear_bounds_436_comment},
  {"clearBounds", &Dtool_PandaNode_clear_bounds_436, METH_NOARGS, (const char *)Dtool_PandaNode_clear_bounds_436_comment},
  {"get_bounds", (PyCFunction) &Dtool_PandaNode_get_bounds_437, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_bounds_437_comment},
  {"getBounds", (PyCFunction) &Dtool_PandaNode_get_bounds_437, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_bounds_437_comment},
  {"get_nested_vertices", (PyCFunction) &Dtool_PandaNode_get_nested_vertices_438, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_nested_vertices_438_comment},
  {"getNestedVertices", (PyCFunction) &Dtool_PandaNode_get_nested_vertices_438, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_nested_vertices_438_comment},
  {"get_internal_bounds", (PyCFunction) &Dtool_PandaNode_get_internal_bounds_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_internal_bounds_439_comment},
  {"getInternalBounds", (PyCFunction) &Dtool_PandaNode_get_internal_bounds_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_internal_bounds_439_comment},
  {"get_internal_vertices", (PyCFunction) &Dtool_PandaNode_get_internal_vertices_440, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_internal_vertices_440_comment},
  {"getInternalVertices", (PyCFunction) &Dtool_PandaNode_get_internal_vertices_440, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_internal_vertices_440_comment},
  {"mark_bounds_stale", (PyCFunction) &Dtool_PandaNode_mark_bounds_stale_445, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_mark_bounds_stale_445_comment},
  {"markBoundsStale", (PyCFunction) &Dtool_PandaNode_mark_bounds_stale_445, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_mark_bounds_stale_445_comment},
  {"mark_internal_bounds_stale", (PyCFunction) &Dtool_PandaNode_mark_internal_bounds_stale_446, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_mark_internal_bounds_stale_446_comment},
  {"markInternalBoundsStale", (PyCFunction) &Dtool_PandaNode_mark_internal_bounds_stale_446, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_mark_internal_bounds_stale_446_comment},
  {"is_bounds_stale", &Dtool_PandaNode_is_bounds_stale_447, METH_NOARGS, (const char *)Dtool_PandaNode_is_bounds_stale_447_comment},
  {"isBoundsStale", &Dtool_PandaNode_is_bounds_stale_447, METH_NOARGS, (const char *)Dtool_PandaNode_is_bounds_stale_447_comment},
  {"set_final", &Dtool_PandaNode_set_final_449, METH_O, (const char *)Dtool_PandaNode_set_final_449_comment},
  {"setFinal", &Dtool_PandaNode_set_final_449, METH_O, (const char *)Dtool_PandaNode_set_final_449_comment},
  {"is_final", (PyCFunction) &Dtool_PandaNode_is_final_450, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_is_final_450_comment},
  {"isFinal", (PyCFunction) &Dtool_PandaNode_is_final_450, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_is_final_450_comment},
  {"is_geom_node", &Dtool_PandaNode_is_geom_node_452, METH_NOARGS, (const char *)Dtool_PandaNode_is_geom_node_452_comment},
  {"isGeomNode", &Dtool_PandaNode_is_geom_node_452, METH_NOARGS, (const char *)Dtool_PandaNode_is_geom_node_452_comment},
  {"is_lod_node", &Dtool_PandaNode_is_lod_node_453, METH_NOARGS, (const char *)Dtool_PandaNode_is_lod_node_453_comment},
  {"isLodNode", &Dtool_PandaNode_is_lod_node_453, METH_NOARGS, (const char *)Dtool_PandaNode_is_lod_node_453_comment},
  {"is_collision_node", &Dtool_PandaNode_is_collision_node_454, METH_NOARGS, (const char *)Dtool_PandaNode_is_collision_node_454_comment},
  {"isCollisionNode", &Dtool_PandaNode_is_collision_node_454, METH_NOARGS, (const char *)Dtool_PandaNode_is_collision_node_454_comment},
  {"as_light", &Dtool_PandaNode_as_light_455, METH_NOARGS, (const char *)Dtool_PandaNode_as_light_455_comment},
  {"asLight", &Dtool_PandaNode_as_light_455, METH_NOARGS, (const char *)Dtool_PandaNode_as_light_455_comment},
  {"is_ambient_light", &Dtool_PandaNode_is_ambient_light_456, METH_NOARGS, (const char *)Dtool_PandaNode_is_ambient_light_456_comment},
  {"isAmbientLight", &Dtool_PandaNode_is_ambient_light_456, METH_NOARGS, (const char *)Dtool_PandaNode_is_ambient_light_456_comment},
  {"get_fancy_bits", (PyCFunction) &Dtool_PandaNode_get_fancy_bits_458, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_fancy_bits_458_comment},
  {"getFancyBits", (PyCFunction) &Dtool_PandaNode_get_fancy_bits_458, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaNode_get_fancy_bits_458_comment},
  {"decode_from_bam_stream", (PyCFunction) &Dtool_PandaNode_decode_from_bam_stream_459, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PandaNode_decode_from_bam_stream_459_comment},
  {"decodeFromBamStream", (PyCFunction) &Dtool_PandaNode_decode_from_bam_stream_459, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PandaNode_decode_from_bam_stream_459_comment},
  {"get_class_type", &Dtool_PandaNode_get_class_type_477, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaNode_get_class_type_477_comment},
  {"getClassType", &Dtool_PandaNode_get_class_type_477, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaNode_get_class_type_477_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_PandaNode_upcast_to_TypedWritableReferenceCount_298, METH_NOARGS, (const char *)Dtool_PandaNode_upcast_to_TypedWritableReferenceCount_298_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_PandaNode_upcast_to_TypedWritableReferenceCount_298, METH_NOARGS, (const char *)Dtool_PandaNode_upcast_to_TypedWritableReferenceCount_298_comment},
  {"upcast_to_Namable", &Dtool_PandaNode_upcast_to_Namable_301, METH_NOARGS, (const char *)Dtool_PandaNode_upcast_to_Namable_301_comment},
  {"upcastToNamable", &Dtool_PandaNode_upcast_to_Namable_301, METH_NOARGS, (const char *)Dtool_PandaNode_upcast_to_Namable_301_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_parents", (PyCFunction) &MakeSeq_PandaNode_get_parents, METH_NOARGS, nullptr},
  { "getParents", (PyCFunction) &MakeSeq_PandaNode_get_parents, METH_NOARGS, nullptr},
  {"get_children", (PyCFunction) &MakeSeq_PandaNode_get_children, METH_NOARGS, nullptr},
  { "getChildren", (PyCFunction) &MakeSeq_PandaNode_get_children, METH_NOARGS, nullptr},
  {"get_stashed", (PyCFunction) &MakeSeq_PandaNode_get_stashed, METH_NOARGS, nullptr},
  { "getStashed", (PyCFunction) &MakeSeq_PandaNode_get_stashed, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PandaNode slot tp_traverse -> __traverse__
//////////////////
static int Dtool_PandaNode_traverse_387_tp_traverse(PyObject *self, visitproc visit, void *arg) {
  PandaNode *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PandaNode, (void **) &local_this);
  if (local_this == nullptr) {
    return 0;
  }

  return invoke_extension(local_this).__traverse__(visit, arg);
}

//////////////////
//  A __repr__ function
//     PandaNode
//////////////////
static PyObject *Dtool_Repr_PandaNode(PyObject *self) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     PandaNode
//////////////////
static PyObject *Dtool_Str_PandaNode(PyObject *self) {
  PandaNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaNode, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PandaNode[] = {
  {(char *)"state", &Dtool_PandaNode_state_Getter, &Dtool_PandaNode_state_Setter, nullptr, nullptr},
  {(char *)"effects", &Dtool_PandaNode_effects_Getter, &Dtool_PandaNode_effects_Setter, nullptr, nullptr},
  {(char *)"transform", &Dtool_PandaNode_transform_Getter, &Dtool_PandaNode_transform_Setter, nullptr, nullptr},
  {(char *)"prev_transform", &Dtool_PandaNode_prev_transform_Getter, nullptr, nullptr, nullptr},
  {(char *)"tags", &Dtool_PandaNode_tags_Getter, nullptr, nullptr, nullptr},
  {(char *)"python_tags", &Dtool_PandaNode_python_tags_Getter, nullptr, nullptr, nullptr},
  {(char *)"overall_hidden", &Dtool_PandaNode_overall_hidden_Getter, &Dtool_PandaNode_overall_hidden_Setter, nullptr, nullptr},
  {(char *)"draw_control_mask", &Dtool_PandaNode_draw_control_mask_Getter, nullptr, nullptr, nullptr},
  {(char *)"draw_show_mask", &Dtool_PandaNode_draw_show_mask_Getter, nullptr, nullptr, nullptr},
  {(char *)"into_collide_mask", &Dtool_PandaNode_into_collide_mask_Getter, &Dtool_PandaNode_into_collide_mask_Setter, nullptr, nullptr},
  {(char *)"legal_collide_mask", &Dtool_PandaNode_legal_collide_mask_Getter, nullptr, nullptr, nullptr},
  {(char *)"bounds_type", &Dtool_PandaNode_bounds_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"nested_vertices", &Dtool_PandaNode_nested_vertices_Getter, nullptr, nullptr, nullptr},
  {(char *)"internal_bounds", &Dtool_PandaNode_internal_bounds_Getter, nullptr, nullptr, nullptr},
  {(char *)"internal_vertices", &Dtool_PandaNode_internal_vertices_Getter, nullptr, nullptr, nullptr},
  {(char *)"bounds_stale", &Dtool_PandaNode_bounds_stale_Getter, nullptr, nullptr, nullptr},
  {(char *)"final", &Dtool_PandaNode_final_Getter, &Dtool_PandaNode_final_Setter, nullptr, nullptr},
  {(char *)"children", &Dtool_PandaNode_children_Getter, nullptr, nullptr, nullptr},
  {(char *)"stashed", &Dtool_PandaNode_stashed_Getter, nullptr, nullptr, nullptr},
  {(char *)"parents", &Dtool_PandaNode_parents_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PandaNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PandaNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PandaNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PandaNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PandaNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PandaNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PandaNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PandaNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PandaNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PandaNode,
    &Dtool_NumberMethods_PandaNode,
    &Dtool_SequenceMethods_PandaNode,
    &Dtool_MappingMethods_PandaNode,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_PandaNode,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PandaNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A basic node of the scene graph or data graph.  This is the base class of\n"
    " * all specialized nodes, and also serves as a generic node with no special\n"
    " * properties.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PandaNode,
    nullptr, // tp_members
    Dtool_Properties_PandaNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PandaNode,
    PyType_GenericAlloc,
    Dtool_new_PandaNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PandaNode,
  Dtool_UpcastInterface_PandaNode,
  Dtool_DowncastInterface_PandaNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PandaNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_PandaNode._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_PandaNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(29);
    Dtool_PandaNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PandaNode::UnexpectedChange;
    PyDict_SetItemString(dict, "UC_parents", Dtool_WrapValue(PandaNode::UC_parents));
    PyDict_SetItemString(dict, "UCParents", Dtool_WrapValue(PandaNode::UC_parents));
    PyDict_SetItemString(dict, "UC_children", Dtool_WrapValue(PandaNode::UC_children));
    PyDict_SetItemString(dict, "UCChildren", Dtool_WrapValue(PandaNode::UC_children));
    PyDict_SetItemString(dict, "UC_transform", Dtool_WrapValue(PandaNode::UC_transform));
    PyDict_SetItemString(dict, "UCTransform", Dtool_WrapValue(PandaNode::UC_transform));
    PyDict_SetItemString(dict, "UC_state", Dtool_WrapValue(PandaNode::UC_state));
    PyDict_SetItemString(dict, "UCState", Dtool_WrapValue(PandaNode::UC_state));
    PyDict_SetItemString(dict, "UC_draw_mask", Dtool_WrapValue(PandaNode::UC_draw_mask));
    PyDict_SetItemString(dict, "UCDrawMask", Dtool_WrapValue(PandaNode::UC_draw_mask));
    // enum PandaNode::FancyBits;
    PyDict_SetItemString(dict, "FB_transform", Dtool_WrapValue(PandaNode::FB_transform));
    PyDict_SetItemString(dict, "FBTransform", Dtool_WrapValue(PandaNode::FB_transform));
    PyDict_SetItemString(dict, "FB_state", Dtool_WrapValue(PandaNode::FB_state));
    PyDict_SetItemString(dict, "FBState", Dtool_WrapValue(PandaNode::FB_state));
    PyDict_SetItemString(dict, "FB_effects", Dtool_WrapValue(PandaNode::FB_effects));
    PyDict_SetItemString(dict, "FBEffects", Dtool_WrapValue(PandaNode::FB_effects));
    PyDict_SetItemString(dict, "FB_tag", Dtool_WrapValue(PandaNode::FB_tag));
    PyDict_SetItemString(dict, "FBTag", Dtool_WrapValue(PandaNode::FB_tag));
    PyDict_SetItemString(dict, "FB_draw_mask", Dtool_WrapValue(PandaNode::FB_draw_mask));
    PyDict_SetItemString(dict, "FBDrawMask", Dtool_WrapValue(PandaNode::FB_draw_mask));
    PyDict_SetItemString(dict, "FB_cull_callback", Dtool_WrapValue(PandaNode::FB_cull_callback));
    PyDict_SetItemString(dict, "FBCullCallback", Dtool_WrapValue(PandaNode::FB_cull_callback));
    // Nested Object   PandaNode_Children;
    Dtool_PyModuleClassInit_PandaNode_Children(nullptr);
    PyDict_SetItemString(dict, "Children", (PyObject *)&Dtool_PandaNode_Children);
    // Nested Object   PandaNode_Stashed;
    Dtool_PyModuleClassInit_PandaNode_Stashed(nullptr);
    PyDict_SetItemString(dict, "Stashed", (PyObject *)&Dtool_PandaNode_Stashed);
    // Nested Object   PandaNode_Parents;
    Dtool_PyModuleClassInit_PandaNode_Parents(nullptr);
    PyDict_SetItemString(dict, "Parents", (PyObject *)&Dtool_PandaNode_Parents);
    static const PyGetSetDef def_overall_bit = {(char *)"overall_bit", &Dtool_PandaNode_overall_bit_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "overall_bit", Dtool_NewStaticProperty(&Dtool_PandaNode._PyType, &def_overall_bit));
    static const PyGetSetDef def_all_camera_mask = {(char *)"all_camera_mask", &Dtool_PandaNode_all_camera_mask_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "all_camera_mask", Dtool_NewStaticProperty(&Dtool_PandaNode._PyType, &def_all_camera_mask));
    if (PyType_Ready((PyTypeObject *)&Dtool_PandaNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PandaNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PandaNode);
  }
}

/**
 * Python method tables for TransparencyAttrib (TransparencyAttrib)
 */
static PyMethodDef Dtool_Methods_TransparencyAttrib[] = {
  {"make", &Dtool_TransparencyAttrib_make_480, METH_O | METH_STATIC, (const char *)Dtool_TransparencyAttrib_make_480_comment},
  {"make_default", &Dtool_TransparencyAttrib_make_default_481, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransparencyAttrib_make_default_481_comment},
  {"makeDefault", &Dtool_TransparencyAttrib_make_default_481, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransparencyAttrib_make_default_481_comment},
  {"get_mode", &Dtool_TransparencyAttrib_get_mode_482, METH_NOARGS, (const char *)Dtool_TransparencyAttrib_get_mode_482_comment},
  {"getMode", &Dtool_TransparencyAttrib_get_mode_482, METH_NOARGS, (const char *)Dtool_TransparencyAttrib_get_mode_482_comment},
  {"get_class_slot", &Dtool_TransparencyAttrib_get_class_slot_484, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransparencyAttrib_get_class_slot_484_comment},
  {"getClassSlot", &Dtool_TransparencyAttrib_get_class_slot_484, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransparencyAttrib_get_class_slot_484_comment},
  {"get_class_type", &Dtool_TransparencyAttrib_get_class_type_486, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransparencyAttrib_get_class_type_486_comment},
  {"getClassType", &Dtool_TransparencyAttrib_get_class_type_486, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransparencyAttrib_get_class_type_486_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_TransparencyAttrib[] = {
  {(char *)"mode", &Dtool_TransparencyAttrib_mode_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TransparencyAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TransparencyAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TransparencyAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TransparencyAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TransparencyAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TransparencyAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TransparencyAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TransparencyAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TransparencyAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TransparencyAttrib,
    &Dtool_SequenceMethods_TransparencyAttrib,
    &Dtool_MappingMethods_TransparencyAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TransparencyAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This controls the enabling of transparency.  Simply setting an alpha\n"
    " * component to non-1 does not in itself make an object transparent; you must\n"
    " * also enable transparency mode with a suitable TransparencyAttrib.\n"
    " * Similarly, it is wasteful to render an object with a TransparencyAttrib in\n"
    " * effect unless you actually want it to be at least partially transparent\n"
    " * (and it has alpha components less than 1).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TransparencyAttrib,
    nullptr, // tp_members
    Dtool_Properties_TransparencyAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TransparencyAttrib,
    PyType_GenericAlloc,
    Dtool_new_TransparencyAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TransparencyAttrib,
  Dtool_UpcastInterface_TransparencyAttrib,
  Dtool_DowncastInterface_TransparencyAttrib,
  (CoerceFunction)Dtool_ConstCoerce_TransparencyAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_TransparencyAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_TransparencyAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_TransparencyAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(15);
    Dtool_TransparencyAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TransparencyAttrib::Mode;
    PyDict_SetItemString(dict, "M_none", Dtool_WrapValue(TransparencyAttrib::M_none));
    PyDict_SetItemString(dict, "MNone", Dtool_WrapValue(TransparencyAttrib::M_none));
    PyDict_SetItemString(dict, "M_alpha", Dtool_WrapValue(TransparencyAttrib::M_alpha));
    PyDict_SetItemString(dict, "MAlpha", Dtool_WrapValue(TransparencyAttrib::M_alpha));
    PyDict_SetItemString(dict, "M_premultiplied_alpha", Dtool_WrapValue(TransparencyAttrib::M_premultiplied_alpha));
    PyDict_SetItemString(dict, "MPremultipliedAlpha", Dtool_WrapValue(TransparencyAttrib::M_premultiplied_alpha));
    PyDict_SetItemString(dict, "M_multisample", Dtool_WrapValue(TransparencyAttrib::M_multisample));
    PyDict_SetItemString(dict, "MMultisample", Dtool_WrapValue(TransparencyAttrib::M_multisample));
    PyDict_SetItemString(dict, "M_multisample_mask", Dtool_WrapValue(TransparencyAttrib::M_multisample_mask));
    PyDict_SetItemString(dict, "MMultisampleMask", Dtool_WrapValue(TransparencyAttrib::M_multisample_mask));
    PyDict_SetItemString(dict, "M_binary", Dtool_WrapValue(TransparencyAttrib::M_binary));
    PyDict_SetItemString(dict, "MBinary", Dtool_WrapValue(TransparencyAttrib::M_binary));
    PyDict_SetItemString(dict, "M_dual", Dtool_WrapValue(TransparencyAttrib::M_dual));
    PyDict_SetItemString(dict, "MDual", Dtool_WrapValue(TransparencyAttrib::M_dual));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_TransparencyAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_TransparencyAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_TransparencyAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TransparencyAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TransparencyAttrib);
  }
}

/**
 * Python method tables for LogicOpAttrib (LogicOpAttrib)
 */
static PyMethodDef Dtool_Methods_LogicOpAttrib[] = {
  {"make_off", &Dtool_LogicOpAttrib_make_off_490, METH_NOARGS | METH_STATIC, (const char *)Dtool_LogicOpAttrib_make_off_490_comment},
  {"makeOff", &Dtool_LogicOpAttrib_make_off_490, METH_NOARGS | METH_STATIC, (const char *)Dtool_LogicOpAttrib_make_off_490_comment},
  {"make", &Dtool_LogicOpAttrib_make_491, METH_O | METH_STATIC, (const char *)Dtool_LogicOpAttrib_make_491_comment},
  {"make_default", &Dtool_LogicOpAttrib_make_default_492, METH_NOARGS | METH_STATIC, (const char *)Dtool_LogicOpAttrib_make_default_492_comment},
  {"makeDefault", &Dtool_LogicOpAttrib_make_default_492, METH_NOARGS | METH_STATIC, (const char *)Dtool_LogicOpAttrib_make_default_492_comment},
  {"get_operation", &Dtool_LogicOpAttrib_get_operation_493, METH_NOARGS, (const char *)Dtool_LogicOpAttrib_get_operation_493_comment},
  {"getOperation", &Dtool_LogicOpAttrib_get_operation_493, METH_NOARGS, (const char *)Dtool_LogicOpAttrib_get_operation_493_comment},
  {"get_class_slot", &Dtool_LogicOpAttrib_get_class_slot_495, METH_NOARGS | METH_STATIC, (const char *)Dtool_LogicOpAttrib_get_class_slot_495_comment},
  {"getClassSlot", &Dtool_LogicOpAttrib_get_class_slot_495, METH_NOARGS | METH_STATIC, (const char *)Dtool_LogicOpAttrib_get_class_slot_495_comment},
  {"get_class_type", &Dtool_LogicOpAttrib_get_class_type_497, METH_NOARGS | METH_STATIC, (const char *)Dtool_LogicOpAttrib_get_class_type_497_comment},
  {"getClassType", &Dtool_LogicOpAttrib_get_class_type_497, METH_NOARGS | METH_STATIC, (const char *)Dtool_LogicOpAttrib_get_class_type_497_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LogicOpAttrib[] = {
  {(char *)"operation", &Dtool_LogicOpAttrib_operation_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LogicOpAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LogicOpAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LogicOpAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LogicOpAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LogicOpAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LogicOpAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LogicOpAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LogicOpAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LogicOpAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LogicOpAttrib,
    &Dtool_SequenceMethods_LogicOpAttrib,
    &Dtool_MappingMethods_LogicOpAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LogicOpAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * If enabled, specifies that a custom logical operation be performed instead\n"
    " * of any color blending.  Setting it to a value other than M_none will cause\n"
    " * color blending to be disabled and the given logic operation to be performed.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LogicOpAttrib,
    nullptr, // tp_members
    Dtool_Properties_LogicOpAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LogicOpAttrib,
    PyType_GenericAlloc,
    Dtool_new_LogicOpAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LogicOpAttrib,
  Dtool_UpcastInterface_LogicOpAttrib,
  Dtool_DowncastInterface_LogicOpAttrib,
  (CoerceFunction)Dtool_ConstCoerce_LogicOpAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_LogicOpAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_LogicOpAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_LogicOpAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(35);
    Dtool_LogicOpAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LogicOpAttrib::Operation;
    PyDict_SetItemString(dict, "O_none", Dtool_WrapValue(LogicOpAttrib::O_none));
    PyDict_SetItemString(dict, "ONone", Dtool_WrapValue(LogicOpAttrib::O_none));
    PyDict_SetItemString(dict, "O_clear", Dtool_WrapValue(LogicOpAttrib::O_clear));
    PyDict_SetItemString(dict, "OClear", Dtool_WrapValue(LogicOpAttrib::O_clear));
    PyDict_SetItemString(dict, "O_and", Dtool_WrapValue(LogicOpAttrib::O_and));
    PyDict_SetItemString(dict, "OAnd", Dtool_WrapValue(LogicOpAttrib::O_and));
    PyDict_SetItemString(dict, "O_and_reverse", Dtool_WrapValue(LogicOpAttrib::O_and_reverse));
    PyDict_SetItemString(dict, "OAndReverse", Dtool_WrapValue(LogicOpAttrib::O_and_reverse));
    PyDict_SetItemString(dict, "O_copy", Dtool_WrapValue(LogicOpAttrib::O_copy));
    PyDict_SetItemString(dict, "OCopy", Dtool_WrapValue(LogicOpAttrib::O_copy));
    PyDict_SetItemString(dict, "O_and_inverted", Dtool_WrapValue(LogicOpAttrib::O_and_inverted));
    PyDict_SetItemString(dict, "OAndInverted", Dtool_WrapValue(LogicOpAttrib::O_and_inverted));
    PyDict_SetItemString(dict, "O_noop", Dtool_WrapValue(LogicOpAttrib::O_noop));
    PyDict_SetItemString(dict, "ONoop", Dtool_WrapValue(LogicOpAttrib::O_noop));
    PyDict_SetItemString(dict, "O_xor", Dtool_WrapValue(LogicOpAttrib::O_xor));
    PyDict_SetItemString(dict, "OXor", Dtool_WrapValue(LogicOpAttrib::O_xor));
    PyDict_SetItemString(dict, "O_or", Dtool_WrapValue(LogicOpAttrib::O_or));
    PyDict_SetItemString(dict, "OOr", Dtool_WrapValue(LogicOpAttrib::O_or));
    PyDict_SetItemString(dict, "O_nor", Dtool_WrapValue(LogicOpAttrib::O_nor));
    PyDict_SetItemString(dict, "ONor", Dtool_WrapValue(LogicOpAttrib::O_nor));
    PyDict_SetItemString(dict, "O_equivalent", Dtool_WrapValue(LogicOpAttrib::O_equivalent));
    PyDict_SetItemString(dict, "OEquivalent", Dtool_WrapValue(LogicOpAttrib::O_equivalent));
    PyDict_SetItemString(dict, "O_invert", Dtool_WrapValue(LogicOpAttrib::O_invert));
    PyDict_SetItemString(dict, "OInvert", Dtool_WrapValue(LogicOpAttrib::O_invert));
    PyDict_SetItemString(dict, "O_or_reverse", Dtool_WrapValue(LogicOpAttrib::O_or_reverse));
    PyDict_SetItemString(dict, "OOrReverse", Dtool_WrapValue(LogicOpAttrib::O_or_reverse));
    PyDict_SetItemString(dict, "O_copy_inverted", Dtool_WrapValue(LogicOpAttrib::O_copy_inverted));
    PyDict_SetItemString(dict, "OCopyInverted", Dtool_WrapValue(LogicOpAttrib::O_copy_inverted));
    PyDict_SetItemString(dict, "O_or_inverted", Dtool_WrapValue(LogicOpAttrib::O_or_inverted));
    PyDict_SetItemString(dict, "OOrInverted", Dtool_WrapValue(LogicOpAttrib::O_or_inverted));
    PyDict_SetItemString(dict, "O_nand", Dtool_WrapValue(LogicOpAttrib::O_nand));
    PyDict_SetItemString(dict, "ONand", Dtool_WrapValue(LogicOpAttrib::O_nand));
    PyDict_SetItemString(dict, "O_set", Dtool_WrapValue(LogicOpAttrib::O_set));
    PyDict_SetItemString(dict, "OSet", Dtool_WrapValue(LogicOpAttrib::O_set));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_LogicOpAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_LogicOpAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_LogicOpAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LogicOpAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LogicOpAttrib);
  }
}

/**
 * Python method tables for ShaderInput (ShaderInput)
 */
static PyMethodDef Dtool_Methods_ShaderInput[] = {
  {"get_blank", &Dtool_ShaderInput_get_blank_501, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderInput_get_blank_501_comment},
  {"getBlank", &Dtool_ShaderInput_get_blank_501, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderInput_get_blank_501_comment},
  {"add_hash", &Dtool_ShaderInput_add_hash_508, METH_O, (const char *)Dtool_ShaderInput_add_hash_508_comment},
  {"addHash", &Dtool_ShaderInput_add_hash_508, METH_O, (const char *)Dtool_ShaderInput_add_hash_508_comment},
  {"get_name", &Dtool_ShaderInput_get_name_509, METH_NOARGS, (const char *)Dtool_ShaderInput_get_name_509_comment},
  {"getName", &Dtool_ShaderInput_get_name_509, METH_NOARGS, (const char *)Dtool_ShaderInput_get_name_509_comment},
  {"get_value_type", &Dtool_ShaderInput_get_value_type_510, METH_NOARGS, (const char *)Dtool_ShaderInput_get_value_type_510_comment},
  {"getValueType", &Dtool_ShaderInput_get_value_type_510, METH_NOARGS, (const char *)Dtool_ShaderInput_get_value_type_510_comment},
  {"get_priority", &Dtool_ShaderInput_get_priority_511, METH_NOARGS, (const char *)Dtool_ShaderInput_get_priority_511_comment},
  {"getPriority", &Dtool_ShaderInput_get_priority_511, METH_NOARGS, (const char *)Dtool_ShaderInput_get_priority_511_comment},
  {"get_vector", &Dtool_ShaderInput_get_vector_512, METH_NOARGS, (const char *)Dtool_ShaderInput_get_vector_512_comment},
  {"getVector", &Dtool_ShaderInput_get_vector_512, METH_NOARGS, (const char *)Dtool_ShaderInput_get_vector_512_comment},
  {"get_nodepath", &Dtool_ShaderInput_get_nodepath_514, METH_NOARGS, (const char *)Dtool_ShaderInput_get_nodepath_514_comment},
  {"getNodepath", &Dtool_ShaderInput_get_nodepath_514, METH_NOARGS, (const char *)Dtool_ShaderInput_get_nodepath_514_comment},
  {"get_texture", &Dtool_ShaderInput_get_texture_515, METH_NOARGS, (const char *)Dtool_ShaderInput_get_texture_515_comment},
  {"getTexture", &Dtool_ShaderInput_get_texture_515, METH_NOARGS, (const char *)Dtool_ShaderInput_get_texture_515_comment},
  {"get_sampler", &Dtool_ShaderInput_get_sampler_516, METH_NOARGS, (const char *)Dtool_ShaderInput_get_sampler_516_comment},
  {"getSampler", &Dtool_ShaderInput_get_sampler_516, METH_NOARGS, (const char *)Dtool_ShaderInput_get_sampler_516_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ShaderInput slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_ShaderInput_operator_typecast_bool_504_nb_bool(PyObject *self) {
  ShaderInput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderInput, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
//  A rich comparison function
//     ShaderInput
//////////////////
static PyObject *Dtool_RichCompare_ShaderInput(PyObject *self, PyObject *arg, int op) {
  ShaderInput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderInput, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool ShaderInput::operator ==(ShaderInput const &other) const
      ShaderInput const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ShaderInput);
      if (arg_this != nullptr) {
        bool return_value = ((*(const ShaderInput*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool ShaderInput::operator !=(ShaderInput const &other) const
      ShaderInput const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ShaderInput);
      if (arg_this != nullptr) {
        bool return_value = ((*(const ShaderInput*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool ShaderInput::operator <(ShaderInput const &other) const
      ShaderInput const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ShaderInput);
      if (arg_this != nullptr) {
        bool return_value = ((*(const ShaderInput*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_ShaderInput = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_ShaderInput_operator_typecast_bool_504_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ShaderInput = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ShaderInput",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderInput,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_ShaderInput,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a small container class that can hold any one of the value types\n"
    " * that can be passed as input to a shader.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_ShaderInput,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShaderInput,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShaderInput,
    PyType_GenericAlloc,
    Dtool_new_ShaderInput,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderInput,
  Dtool_UpcastInterface_ShaderInput,
  Dtool_DowncastInterface_ShaderInput,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShaderInput(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ShaderInput._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(25);
    Dtool_ShaderInput._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ShaderInput::AccessFlags;
    PyDict_SetItemString(dict, "A_read", Dtool_WrapValue(ShaderInput::A_read));
    PyDict_SetItemString(dict, "ARead", Dtool_WrapValue(ShaderInput::A_read));
    PyDict_SetItemString(dict, "A_write", Dtool_WrapValue(ShaderInput::A_write));
    PyDict_SetItemString(dict, "AWrite", Dtool_WrapValue(ShaderInput::A_write));
    PyDict_SetItemString(dict, "A_layered", Dtool_WrapValue(ShaderInput::A_layered));
    PyDict_SetItemString(dict, "ALayered", Dtool_WrapValue(ShaderInput::A_layered));
    // enum ShaderInput::ShaderInputType;
    PyDict_SetItemString(dict, "M_invalid", Dtool_WrapValue(ShaderInput::M_invalid));
    PyDict_SetItemString(dict, "MInvalid", Dtool_WrapValue(ShaderInput::M_invalid));
    PyDict_SetItemString(dict, "M_texture", Dtool_WrapValue(ShaderInput::M_texture));
    PyDict_SetItemString(dict, "MTexture", Dtool_WrapValue(ShaderInput::M_texture));
    PyDict_SetItemString(dict, "M_nodepath", Dtool_WrapValue(ShaderInput::M_nodepath));
    PyDict_SetItemString(dict, "MNodepath", Dtool_WrapValue(ShaderInput::M_nodepath));
    PyDict_SetItemString(dict, "M_vector", Dtool_WrapValue(ShaderInput::M_vector));
    PyDict_SetItemString(dict, "MVector", Dtool_WrapValue(ShaderInput::M_vector));
    PyDict_SetItemString(dict, "M_numeric", Dtool_WrapValue(ShaderInput::M_numeric));
    PyDict_SetItemString(dict, "MNumeric", Dtool_WrapValue(ShaderInput::M_numeric));
    PyDict_SetItemString(dict, "M_texture_sampler", Dtool_WrapValue(ShaderInput::M_texture_sampler));
    PyDict_SetItemString(dict, "MTextureSampler", Dtool_WrapValue(ShaderInput::M_texture_sampler));
    PyDict_SetItemString(dict, "M_param", Dtool_WrapValue(ShaderInput::M_param));
    PyDict_SetItemString(dict, "MParam", Dtool_WrapValue(ShaderInput::M_param));
    PyDict_SetItemString(dict, "M_texture_image", Dtool_WrapValue(ShaderInput::M_texture_image));
    PyDict_SetItemString(dict, "MTextureImage", Dtool_WrapValue(ShaderInput::M_texture_image));
    PyDict_SetItemString(dict, "M_buffer", Dtool_WrapValue(ShaderInput::M_buffer));
    PyDict_SetItemString(dict, "MBuffer", Dtool_WrapValue(ShaderInput::M_buffer));
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderInput) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderInput)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderInput);
  }
}

/**
 * Python method tables for InternalNameCollection (InternalNameCollection)
 */
static PyMethodDef Dtool_Methods_InternalNameCollection[] = {
  {"assign", &Dtool_InternalNameCollection_operator_520, METH_O, (const char *)Dtool_InternalNameCollection_operator_520_comment},
  {"add_name", &Dtool_InternalNameCollection_add_name_522, METH_O, (const char *)Dtool_InternalNameCollection_add_name_522_comment},
  {"addName", &Dtool_InternalNameCollection_add_name_522, METH_O, (const char *)Dtool_InternalNameCollection_add_name_522_comment},
  {"remove_name", &Dtool_InternalNameCollection_remove_name_523, METH_O, (const char *)Dtool_InternalNameCollection_remove_name_523_comment},
  {"removeName", &Dtool_InternalNameCollection_remove_name_523, METH_O, (const char *)Dtool_InternalNameCollection_remove_name_523_comment},
  {"add_names_from", &Dtool_InternalNameCollection_add_names_from_524, METH_O, (const char *)Dtool_InternalNameCollection_add_names_from_524_comment},
  {"addNamesFrom", &Dtool_InternalNameCollection_add_names_from_524, METH_O, (const char *)Dtool_InternalNameCollection_add_names_from_524_comment},
  {"remove_names_from", &Dtool_InternalNameCollection_remove_names_from_525, METH_O, (const char *)Dtool_InternalNameCollection_remove_names_from_525_comment},
  {"removeNamesFrom", &Dtool_InternalNameCollection_remove_names_from_525, METH_O, (const char *)Dtool_InternalNameCollection_remove_names_from_525_comment},
  {"remove_duplicate_names", &Dtool_InternalNameCollection_remove_duplicate_names_526, METH_NOARGS, (const char *)Dtool_InternalNameCollection_remove_duplicate_names_526_comment},
  {"removeDuplicateNames", &Dtool_InternalNameCollection_remove_duplicate_names_526, METH_NOARGS, (const char *)Dtool_InternalNameCollection_remove_duplicate_names_526_comment},
  {"has_name", &Dtool_InternalNameCollection_has_name_527, METH_O, (const char *)Dtool_InternalNameCollection_has_name_527_comment},
  {"hasName", &Dtool_InternalNameCollection_has_name_527, METH_O, (const char *)Dtool_InternalNameCollection_has_name_527_comment},
  {"clear", &Dtool_InternalNameCollection_clear_528, METH_NOARGS, (const char *)Dtool_InternalNameCollection_clear_528_comment},
  {"get_num_names", &Dtool_InternalNameCollection_get_num_names_529, METH_NOARGS, (const char *)Dtool_InternalNameCollection_get_num_names_529_comment},
  {"getNumNames", &Dtool_InternalNameCollection_get_num_names_529, METH_NOARGS, (const char *)Dtool_InternalNameCollection_get_num_names_529_comment},
  {"get_name", &Dtool_InternalNameCollection_get_name_530, METH_O, (const char *)Dtool_InternalNameCollection_get_name_530_comment},
  {"getName", &Dtool_InternalNameCollection_get_name_530, METH_O, (const char *)Dtool_InternalNameCollection_get_name_530_comment},
  {"output", &Dtool_InternalNameCollection_output_536, METH_O, (const char *)Dtool_InternalNameCollection_output_536_comment},
  {"write", (PyCFunction) &Dtool_InternalNameCollection_write_537, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_InternalNameCollection_write_537_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_names", (PyCFunction) &MakeSeq_InternalNameCollection_get_names, METH_NOARGS, nullptr},
  { "getNames", (PyCFunction) &MakeSeq_InternalNameCollection_get_names, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// InternalNameCollection slot nb_add -> operator +
//////////////////
static PyObject *Dtool_InternalNameCollection_operator_535_nb_add(PyObject *self, PyObject *arg) {
  InternalNameCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_InternalNameCollection, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline InternalNameCollection InternalNameCollection::operator +(InternalNameCollection const &other) const
  InternalNameCollection const *arg_this = (InternalNameCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InternalNameCollection, 1, "InternalNameCollection.__add__", true, true);
  if (arg_this != nullptr) {
    InternalNameCollection *return_value = new InternalNameCollection(((*(const InternalNameCollection*)local_this).operator +)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalNameCollection, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// InternalNameCollection slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_InternalNameCollection_operator_534_nb_inplace_add(PyObject *self, PyObject *arg) {
  InternalNameCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_InternalNameCollection, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void InternalNameCollection::operator +=(InternalNameCollection const &other)
  InternalNameCollection const *arg_this = (InternalNameCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InternalNameCollection, 1, "InternalNameCollection.__iadd__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// InternalNameCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_InternalNameCollection_operator_532_sq_item(PyObject *self, Py_ssize_t index) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalNameCollection, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "InternalNameCollection index out of range");
    return nullptr;
  }
  // 1-InternalName const *InternalNameCollection::operator [](int index) const
  InternalName const *return_value = ((*(const InternalNameCollection*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(InternalNameCollection self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// InternalNameCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_InternalNameCollection_size_533_sq_length(PyObject *self) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalNameCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     InternalNameCollection
//////////////////
static PyObject *Dtool_Repr_InternalNameCollection(PyObject *self) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalNameCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     InternalNameCollection
//////////////////
static PyObject *Dtool_Str_InternalNameCollection(PyObject *self) {
  InternalNameCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalNameCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_InternalNameCollection = {
  &Dtool_InternalNameCollection_operator_535_nb_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_InternalNameCollection_operator_534_nb_inplace_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_InternalNameCollection = {
  &Dtool_InternalNameCollection_size_533_sq_length,
  nullptr,
  nullptr,
  &Dtool_InternalNameCollection_operator_532_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_InternalNameCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.InternalNameCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InternalNameCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_InternalNameCollection,
    &Dtool_NumberMethods_InternalNameCollection,
    &Dtool_SequenceMethods_InternalNameCollection,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_InternalNameCollection,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InternalNameCollection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InternalNameCollection,
    PyType_GenericAlloc,
    Dtool_new_InternalNameCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InternalNameCollection,
  Dtool_UpcastInterface_InternalNameCollection,
  Dtool_DowncastInterface_InternalNameCollection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_InternalNameCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_InternalNameCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_InternalNameCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InternalNameCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InternalNameCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InternalNameCollection);
  }
}

/**
 * Python method tables for MaterialCollection (MaterialCollection)
 */
static PyMethodDef Dtool_Methods_MaterialCollection[] = {
  {"assign", &Dtool_MaterialCollection_operator_540, METH_O, (const char *)Dtool_MaterialCollection_operator_540_comment},
  {"add_material", &Dtool_MaterialCollection_add_material_542, METH_O, (const char *)Dtool_MaterialCollection_add_material_542_comment},
  {"addMaterial", &Dtool_MaterialCollection_add_material_542, METH_O, (const char *)Dtool_MaterialCollection_add_material_542_comment},
  {"remove_material", &Dtool_MaterialCollection_remove_material_543, METH_O, (const char *)Dtool_MaterialCollection_remove_material_543_comment},
  {"removeMaterial", &Dtool_MaterialCollection_remove_material_543, METH_O, (const char *)Dtool_MaterialCollection_remove_material_543_comment},
  {"add_materials_from", &Dtool_MaterialCollection_add_materials_from_544, METH_O, (const char *)Dtool_MaterialCollection_add_materials_from_544_comment},
  {"addMaterialsFrom", &Dtool_MaterialCollection_add_materials_from_544, METH_O, (const char *)Dtool_MaterialCollection_add_materials_from_544_comment},
  {"remove_materials_from", &Dtool_MaterialCollection_remove_materials_from_545, METH_O, (const char *)Dtool_MaterialCollection_remove_materials_from_545_comment},
  {"removeMaterialsFrom", &Dtool_MaterialCollection_remove_materials_from_545, METH_O, (const char *)Dtool_MaterialCollection_remove_materials_from_545_comment},
  {"remove_duplicate_materials", &Dtool_MaterialCollection_remove_duplicate_materials_546, METH_NOARGS, (const char *)Dtool_MaterialCollection_remove_duplicate_materials_546_comment},
  {"removeDuplicateMaterials", &Dtool_MaterialCollection_remove_duplicate_materials_546, METH_NOARGS, (const char *)Dtool_MaterialCollection_remove_duplicate_materials_546_comment},
  {"has_material", &Dtool_MaterialCollection_has_material_547, METH_O, (const char *)Dtool_MaterialCollection_has_material_547_comment},
  {"hasMaterial", &Dtool_MaterialCollection_has_material_547, METH_O, (const char *)Dtool_MaterialCollection_has_material_547_comment},
  {"clear", &Dtool_MaterialCollection_clear_548, METH_NOARGS, (const char *)Dtool_MaterialCollection_clear_548_comment},
  {"find_material", &Dtool_MaterialCollection_find_material_549, METH_O, (const char *)Dtool_MaterialCollection_find_material_549_comment},
  {"findMaterial", &Dtool_MaterialCollection_find_material_549, METH_O, (const char *)Dtool_MaterialCollection_find_material_549_comment},
  {"get_num_materials", &Dtool_MaterialCollection_get_num_materials_550, METH_NOARGS, (const char *)Dtool_MaterialCollection_get_num_materials_550_comment},
  {"getNumMaterials", &Dtool_MaterialCollection_get_num_materials_550, METH_NOARGS, (const char *)Dtool_MaterialCollection_get_num_materials_550_comment},
  {"get_material", &Dtool_MaterialCollection_get_material_551, METH_O, (const char *)Dtool_MaterialCollection_get_material_551_comment},
  {"getMaterial", &Dtool_MaterialCollection_get_material_551, METH_O, (const char *)Dtool_MaterialCollection_get_material_551_comment},
  {"output", &Dtool_MaterialCollection_output_556, METH_O, (const char *)Dtool_MaterialCollection_output_556_comment},
  {"write", (PyCFunction) &Dtool_MaterialCollection_write_557, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MaterialCollection_write_557_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// MaterialCollection slot nb_add -> operator +
//////////////////
static PyObject *Dtool_MaterialCollection_operator_555_nb_add(PyObject *self, PyObject *arg) {
  MaterialCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_MaterialCollection, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline MaterialCollection MaterialCollection::operator +(MaterialCollection const &other) const
  MaterialCollection const *arg_this = (MaterialCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MaterialCollection, 1, "MaterialCollection.__add__", true, true);
  if (arg_this != nullptr) {
    MaterialCollection *return_value = new MaterialCollection(((*(const MaterialCollection*)local_this).operator +)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MaterialCollection, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// MaterialCollection slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_MaterialCollection_operator_554_nb_inplace_add(PyObject *self, PyObject *arg) {
  MaterialCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_MaterialCollection, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void MaterialCollection::operator +=(MaterialCollection const &other)
  MaterialCollection const *arg_this = (MaterialCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MaterialCollection, 1, "MaterialCollection.__iadd__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// MaterialCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_MaterialCollection_operator_552_sq_item(PyObject *self, Py_ssize_t index) {
  MaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MaterialCollection, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "MaterialCollection index out of range");
    return nullptr;
  }
  // 1-Material *MaterialCollection::operator [](int index) const
  Material *return_value = ((*(const MaterialCollection*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Material, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(MaterialCollection self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// MaterialCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_MaterialCollection_size_553_sq_length(PyObject *self) {
  MaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MaterialCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     MaterialCollection
//////////////////
static PyObject *Dtool_Repr_MaterialCollection(PyObject *self) {
  MaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MaterialCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     MaterialCollection
//////////////////
static PyObject *Dtool_Str_MaterialCollection(PyObject *self) {
  MaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MaterialCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_MaterialCollection = {
  &Dtool_MaterialCollection_operator_555_nb_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_MaterialCollection_operator_554_nb_inplace_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MaterialCollection = {
  &Dtool_MaterialCollection_size_553_sq_length,
  nullptr,
  nullptr,
  &Dtool_MaterialCollection_operator_552_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_MaterialCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MaterialCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MaterialCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_MaterialCollection,
    &Dtool_NumberMethods_MaterialCollection,
    &Dtool_SequenceMethods_MaterialCollection,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_MaterialCollection,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MaterialCollection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MaterialCollection,
    PyType_GenericAlloc,
    Dtool_new_MaterialCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MaterialCollection,
  Dtool_UpcastInterface_MaterialCollection,
  Dtool_DowncastInterface_MaterialCollection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MaterialCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MaterialCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MaterialCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MaterialCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MaterialCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MaterialCollection);
  }
}

/**
 * Python method tables for TextureStageCollection (TextureStageCollection)
 */
static PyMethodDef Dtool_Methods_TextureStageCollection[] = {
  {"assign", &Dtool_TextureStageCollection_operator_560, METH_O, (const char *)Dtool_TextureStageCollection_operator_560_comment},
  {"add_texture_stage", &Dtool_TextureStageCollection_add_texture_stage_562, METH_O, (const char *)Dtool_TextureStageCollection_add_texture_stage_562_comment},
  {"addTextureStage", &Dtool_TextureStageCollection_add_texture_stage_562, METH_O, (const char *)Dtool_TextureStageCollection_add_texture_stage_562_comment},
  {"remove_texture_stage", &Dtool_TextureStageCollection_remove_texture_stage_563, METH_O, (const char *)Dtool_TextureStageCollection_remove_texture_stage_563_comment},
  {"removeTextureStage", &Dtool_TextureStageCollection_remove_texture_stage_563, METH_O, (const char *)Dtool_TextureStageCollection_remove_texture_stage_563_comment},
  {"add_texture_stages_from", &Dtool_TextureStageCollection_add_texture_stages_from_564, METH_O, (const char *)Dtool_TextureStageCollection_add_texture_stages_from_564_comment},
  {"addTextureStagesFrom", &Dtool_TextureStageCollection_add_texture_stages_from_564, METH_O, (const char *)Dtool_TextureStageCollection_add_texture_stages_from_564_comment},
  {"remove_texture_stages_from", &Dtool_TextureStageCollection_remove_texture_stages_from_565, METH_O, (const char *)Dtool_TextureStageCollection_remove_texture_stages_from_565_comment},
  {"removeTextureStagesFrom", &Dtool_TextureStageCollection_remove_texture_stages_from_565, METH_O, (const char *)Dtool_TextureStageCollection_remove_texture_stages_from_565_comment},
  {"remove_duplicate_texture_stages", &Dtool_TextureStageCollection_remove_duplicate_texture_stages_566, METH_NOARGS, (const char *)Dtool_TextureStageCollection_remove_duplicate_texture_stages_566_comment},
  {"removeDuplicateTextureStages", &Dtool_TextureStageCollection_remove_duplicate_texture_stages_566, METH_NOARGS, (const char *)Dtool_TextureStageCollection_remove_duplicate_texture_stages_566_comment},
  {"has_texture_stage", &Dtool_TextureStageCollection_has_texture_stage_567, METH_O, (const char *)Dtool_TextureStageCollection_has_texture_stage_567_comment},
  {"hasTextureStage", &Dtool_TextureStageCollection_has_texture_stage_567, METH_O, (const char *)Dtool_TextureStageCollection_has_texture_stage_567_comment},
  {"clear", &Dtool_TextureStageCollection_clear_568, METH_NOARGS, (const char *)Dtool_TextureStageCollection_clear_568_comment},
  {"find_texture_stage", &Dtool_TextureStageCollection_find_texture_stage_569, METH_O, (const char *)Dtool_TextureStageCollection_find_texture_stage_569_comment},
  {"findTextureStage", &Dtool_TextureStageCollection_find_texture_stage_569, METH_O, (const char *)Dtool_TextureStageCollection_find_texture_stage_569_comment},
  {"get_num_texture_stages", &Dtool_TextureStageCollection_get_num_texture_stages_570, METH_NOARGS, (const char *)Dtool_TextureStageCollection_get_num_texture_stages_570_comment},
  {"getNumTextureStages", &Dtool_TextureStageCollection_get_num_texture_stages_570, METH_NOARGS, (const char *)Dtool_TextureStageCollection_get_num_texture_stages_570_comment},
  {"get_texture_stage", &Dtool_TextureStageCollection_get_texture_stage_571, METH_O, (const char *)Dtool_TextureStageCollection_get_texture_stage_571_comment},
  {"getTextureStage", &Dtool_TextureStageCollection_get_texture_stage_571, METH_O, (const char *)Dtool_TextureStageCollection_get_texture_stage_571_comment},
  {"sort", &Dtool_TextureStageCollection_sort_577, METH_NOARGS, (const char *)Dtool_TextureStageCollection_sort_577_comment},
  {"output", &Dtool_TextureStageCollection_output_578, METH_O, (const char *)Dtool_TextureStageCollection_output_578_comment},
  {"write", (PyCFunction) &Dtool_TextureStageCollection_write_579, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureStageCollection_write_579_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_texture_stages", (PyCFunction) &MakeSeq_TextureStageCollection_get_texture_stages, METH_NOARGS, nullptr},
  { "getTextureStages", (PyCFunction) &MakeSeq_TextureStageCollection_get_texture_stages, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TextureStageCollection slot nb_add -> operator +
//////////////////
static PyObject *Dtool_TextureStageCollection_operator_576_nb_add(PyObject *self, PyObject *arg) {
  TextureStageCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_TextureStageCollection, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline TextureStageCollection TextureStageCollection::operator +(TextureStageCollection const &other) const
  TextureStageCollection const *arg_this = (TextureStageCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStageCollection, 1, "TextureStageCollection.__add__", true, true);
  if (arg_this != nullptr) {
    TextureStageCollection *return_value = new TextureStageCollection(((*(const TextureStageCollection*)local_this).operator +)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureStageCollection, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TextureStageCollection slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_TextureStageCollection_operator_575_nb_inplace_add(PyObject *self, PyObject *arg) {
  TextureStageCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_TextureStageCollection, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void TextureStageCollection::operator +=(TextureStageCollection const &other)
  TextureStageCollection const *arg_this = (TextureStageCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStageCollection, 1, "TextureStageCollection.__iadd__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TextureStageCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_TextureStageCollection_operator_573_sq_item(PyObject *self, Py_ssize_t index) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStageCollection, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "TextureStageCollection index out of range");
    return nullptr;
  }
  // 1-TextureStage *TextureStageCollection::operator [](int index) const
  TextureStage *return_value = ((*(const TextureStageCollection*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(TextureStageCollection self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TextureStageCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_TextureStageCollection_size_574_sq_length(PyObject *self) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStageCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     TextureStageCollection
//////////////////
static PyObject *Dtool_Repr_TextureStageCollection(PyObject *self) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStageCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     TextureStageCollection
//////////////////
static PyObject *Dtool_Str_TextureStageCollection(PyObject *self) {
  TextureStageCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStageCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_TextureStageCollection = {
  &Dtool_TextureStageCollection_operator_576_nb_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_TextureStageCollection_operator_575_nb_inplace_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextureStageCollection = {
  &Dtool_TextureStageCollection_size_574_sq_length,
  nullptr,
  nullptr,
  &Dtool_TextureStageCollection_operator_573_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_TextureStageCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextureStageCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextureStageCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_TextureStageCollection,
    &Dtool_NumberMethods_TextureStageCollection,
    &Dtool_SequenceMethods_TextureStageCollection,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_TextureStageCollection,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextureStageCollection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextureStageCollection,
    PyType_GenericAlloc,
    Dtool_new_TextureStageCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextureStageCollection,
  Dtool_UpcastInterface_TextureStageCollection,
  Dtool_DowncastInterface_TextureStageCollection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextureStageCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextureStageCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextureStageCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextureStageCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextureStageCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextureStageCollection);
  }
}

/**
 * Python method tables for NodePath (NodePath)
 */
static PyMethodDef Dtool_Methods_NodePath[] = {
  {"any_path", (PyCFunction) &Dtool_NodePath_any_path_583, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_NodePath_any_path_583_comment},
  {"anyPath", (PyCFunction) &Dtool_NodePath_any_path_583, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_NodePath_any_path_583_comment},
  {"assign", &Dtool_NodePath_operator_584, METH_O, (const char *)Dtool_NodePath_operator_584_comment},
  {"clear", &Dtool_NodePath_clear_585, METH_NOARGS, (const char *)Dtool_NodePath_clear_585_comment},
  {"__copy__", &Dtool_NodePath_copy_586, METH_NOARGS, (const char *)Dtool_NodePath_copy_586_comment},
  {"__deepcopy__", &Dtool_NodePath_deepcopy_587, METH_O, (const char *)Dtool_NodePath_deepcopy_587_comment},
  {"__reduce__", &Dtool_NodePath_reduce_588, METH_NOARGS, (const char *)Dtool_NodePath_reduce_588_comment},
  {"__reduce_persist__", &Dtool_NodePath_reduce_persist_589, METH_O, (const char *)Dtool_NodePath_reduce_persist_589_comment},
  {"not_found", &Dtool_NodePath_not_found_590, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodePath_not_found_590_comment},
  {"notFound", &Dtool_NodePath_not_found_590, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodePath_not_found_590_comment},
  {"removed", &Dtool_NodePath_removed_591, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodePath_removed_591_comment},
  {"fail", &Dtool_NodePath_fail_592, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodePath_fail_592_comment},
  {"set_max_search_depth", &Dtool_NodePath_set_max_search_depth_593, METH_O | METH_STATIC, (const char *)Dtool_NodePath_set_max_search_depth_593_comment},
  {"setMaxSearchDepth", &Dtool_NodePath_set_max_search_depth_593, METH_O | METH_STATIC, (const char *)Dtool_NodePath_set_max_search_depth_593_comment},
  {"get_max_search_depth", &Dtool_NodePath_get_max_search_depth_594, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodePath_get_max_search_depth_594_comment},
  {"getMaxSearchDepth", &Dtool_NodePath_get_max_search_depth_594, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodePath_get_max_search_depth_594_comment},
  {"is_empty", &Dtool_NodePath_is_empty_595, METH_NOARGS, (const char *)Dtool_NodePath_is_empty_595_comment},
  {"isEmpty", &Dtool_NodePath_is_empty_595, METH_NOARGS, (const char *)Dtool_NodePath_is_empty_595_comment},
  {"is_singleton", (PyCFunction) &Dtool_NodePath_is_singleton_597, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_is_singleton_597_comment},
  {"isSingleton", (PyCFunction) &Dtool_NodePath_is_singleton_597, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_is_singleton_597_comment},
  {"get_num_nodes", (PyCFunction) &Dtool_NodePath_get_num_nodes_598, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_num_nodes_598_comment},
  {"getNumNodes", (PyCFunction) &Dtool_NodePath_get_num_nodes_598, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_num_nodes_598_comment},
  {"get_node", (PyCFunction) &Dtool_NodePath_get_node_599, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_node_599_comment},
  {"getNode", (PyCFunction) &Dtool_NodePath_get_node_599, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_node_599_comment},
  {"get_ancestor", (PyCFunction) &Dtool_NodePath_get_ancestor_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_ancestor_603_comment},
  {"getAncestor", (PyCFunction) &Dtool_NodePath_get_ancestor_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_ancestor_603_comment},
  {"get_error_type", &Dtool_NodePath_get_error_type_606, METH_NOARGS, (const char *)Dtool_NodePath_get_error_type_606_comment},
  {"getErrorType", &Dtool_NodePath_get_error_type_606, METH_NOARGS, (const char *)Dtool_NodePath_get_error_type_606_comment},
  {"get_top_node", (PyCFunction) &Dtool_NodePath_get_top_node_608, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_top_node_608_comment},
  {"getTopNode", (PyCFunction) &Dtool_NodePath_get_top_node_608, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_top_node_608_comment},
  {"get_top", (PyCFunction) &Dtool_NodePath_get_top_609, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_top_609_comment},
  {"getTop", (PyCFunction) &Dtool_NodePath_get_top_609, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_top_609_comment},
  {"node", &Dtool_NodePath_node_610, METH_NOARGS, (const char *)Dtool_NodePath_node_610_comment},
  {"get_key", &Dtool_NodePath_get_key_611, METH_NOARGS, (const char *)Dtool_NodePath_get_key_611_comment},
  {"getKey", &Dtool_NodePath_get_key_611, METH_NOARGS, (const char *)Dtool_NodePath_get_key_611_comment},
  {"add_hash", &Dtool_NodePath_add_hash_612, METH_O, (const char *)Dtool_NodePath_add_hash_612_comment},
  {"addHash", &Dtool_NodePath_add_hash_612, METH_O, (const char *)Dtool_NodePath_add_hash_612_comment},
  {"is_same_graph", (PyCFunction) &Dtool_NodePath_is_same_graph_613, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_is_same_graph_613_comment},
  {"isSameGraph", (PyCFunction) &Dtool_NodePath_is_same_graph_613, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_is_same_graph_613_comment},
  {"is_ancestor_of", (PyCFunction) &Dtool_NodePath_is_ancestor_of_614, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_is_ancestor_of_614_comment},
  {"isAncestorOf", (PyCFunction) &Dtool_NodePath_is_ancestor_of_614, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_is_ancestor_of_614_comment},
  {"get_common_ancestor", (PyCFunction) &Dtool_NodePath_get_common_ancestor_615, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_common_ancestor_615_comment},
  {"getCommonAncestor", (PyCFunction) &Dtool_NodePath_get_common_ancestor_615, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_common_ancestor_615_comment},
  {"get_children", (PyCFunction) &Dtool_NodePath_get_children_616, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_children_616_comment},
  {"getChildren", (PyCFunction) &Dtool_NodePath_get_children_616, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_children_616_comment},
  {"get_num_children", (PyCFunction) &Dtool_NodePath_get_num_children_617, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_num_children_617_comment},
  {"getNumChildren", (PyCFunction) &Dtool_NodePath_get_num_children_617, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_num_children_617_comment},
  {"get_child", (PyCFunction) &Dtool_NodePath_get_child_618, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_child_618_comment},
  {"getChild", (PyCFunction) &Dtool_NodePath_get_child_618, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_child_618_comment},
  {"get_stashed_children", (PyCFunction) &Dtool_NodePath_get_stashed_children_619, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_stashed_children_619_comment},
  {"getStashedChildren", (PyCFunction) &Dtool_NodePath_get_stashed_children_619, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_stashed_children_619_comment},
  {"count_num_descendants", &Dtool_NodePath_count_num_descendants_665, METH_NOARGS, (const char *)Dtool_NodePath_count_num_descendants_665_comment},
  {"countNumDescendants", &Dtool_NodePath_count_num_descendants_665, METH_NOARGS, (const char *)Dtool_NodePath_count_num_descendants_665_comment},
  {"has_parent", (PyCFunction) &Dtool_NodePath_has_parent_666, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_has_parent_666_comment},
  {"hasParent", (PyCFunction) &Dtool_NodePath_has_parent_666, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_has_parent_666_comment},
  {"get_parent", (PyCFunction) &Dtool_NodePath_get_parent_667, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_parent_667_comment},
  {"getParent", (PyCFunction) &Dtool_NodePath_get_parent_667, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_parent_667_comment},
  {"get_sort", (PyCFunction) &Dtool_NodePath_get_sort_668, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_sort_668_comment},
  {"getSort", (PyCFunction) &Dtool_NodePath_get_sort_668, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_sort_668_comment},
  {"find", &Dtool_NodePath_find_671, METH_O, (const char *)Dtool_NodePath_find_671_comment},
  {"find_path_to", &Dtool_NodePath_find_path_to_672, METH_O, (const char *)Dtool_NodePath_find_path_to_672_comment},
  {"findPathTo", &Dtool_NodePath_find_path_to_672, METH_O, (const char *)Dtool_NodePath_find_path_to_672_comment},
  {"find_all_matches", &Dtool_NodePath_find_all_matches_673, METH_O, (const char *)Dtool_NodePath_find_all_matches_673_comment},
  {"findAllMatches", &Dtool_NodePath_find_all_matches_673, METH_O, (const char *)Dtool_NodePath_find_all_matches_673_comment},
  {"find_all_paths_to", &Dtool_NodePath_find_all_paths_to_674, METH_O, (const char *)Dtool_NodePath_find_all_paths_to_674_comment},
  {"findAllPathsTo", &Dtool_NodePath_find_all_paths_to_674, METH_O, (const char *)Dtool_NodePath_find_all_paths_to_674_comment},
  {"reparent_to", (PyCFunction) &Dtool_NodePath_reparent_to_675, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_reparent_to_675_comment},
  {"reparentTo", (PyCFunction) &Dtool_NodePath_reparent_to_675, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_reparent_to_675_comment},
  {"stash_to", (PyCFunction) &Dtool_NodePath_stash_to_676, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_stash_to_676_comment},
  {"stashTo", (PyCFunction) &Dtool_NodePath_stash_to_676, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_stash_to_676_comment},
  {"wrt_reparent_to", (PyCFunction) &Dtool_NodePath_wrt_reparent_to_677, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_wrt_reparent_to_677_comment},
  {"wrtReparentTo", (PyCFunction) &Dtool_NodePath_wrt_reparent_to_677, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_wrt_reparent_to_677_comment},
  {"instance_to", (PyCFunction) &Dtool_NodePath_instance_to_678, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_instance_to_678_comment},
  {"instanceTo", (PyCFunction) &Dtool_NodePath_instance_to_678, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_instance_to_678_comment},
  {"instance_under_node", (PyCFunction) &Dtool_NodePath_instance_under_node_679, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_instance_under_node_679_comment},
  {"instanceUnderNode", (PyCFunction) &Dtool_NodePath_instance_under_node_679, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_instance_under_node_679_comment},
  {"copy_to", (PyCFunction) &Dtool_NodePath_copy_to_680, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_copy_to_680_comment},
  {"copyTo", (PyCFunction) &Dtool_NodePath_copy_to_680, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_copy_to_680_comment},
  {"attach_new_node", (PyCFunction) &Dtool_NodePath_attach_new_node_681, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_attach_new_node_681_comment},
  {"attachNewNode", (PyCFunction) &Dtool_NodePath_attach_new_node_681, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_attach_new_node_681_comment},
  {"remove_node", (PyCFunction) &Dtool_NodePath_remove_node_682, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_remove_node_682_comment},
  {"removeNode", (PyCFunction) &Dtool_NodePath_remove_node_682, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_remove_node_682_comment},
  {"detach_node", (PyCFunction) &Dtool_NodePath_detach_node_683, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_detach_node_683_comment},
  {"detachNode", (PyCFunction) &Dtool_NodePath_detach_node_683, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_detach_node_683_comment},
  {"output", &Dtool_NodePath_output_684, METH_O, (const char *)Dtool_NodePath_output_684_comment},
  {"ls", (PyCFunction) &Dtool_NodePath_ls_685, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_ls_685_comment},
  {"reverse_ls", (PyCFunction) &Dtool_NodePath_reverse_ls_686, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_reverse_ls_686_comment},
  {"reverseLs", (PyCFunction) &Dtool_NodePath_reverse_ls_686, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_reverse_ls_686_comment},
  {"get_state", (PyCFunction) &Dtool_NodePath_get_state_687, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_state_687_comment},
  {"getState", (PyCFunction) &Dtool_NodePath_get_state_687, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_state_687_comment},
  {"set_state", (PyCFunction) &Dtool_NodePath_set_state_688, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_state_688_comment},
  {"setState", (PyCFunction) &Dtool_NodePath_set_state_688, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_state_688_comment},
  {"get_net_state", (PyCFunction) &Dtool_NodePath_get_net_state_689, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_net_state_689_comment},
  {"getNetState", (PyCFunction) &Dtool_NodePath_get_net_state_689, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_net_state_689_comment},
  {"set_attrib", (PyCFunction) &Dtool_NodePath_set_attrib_690, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_attrib_690_comment},
  {"setAttrib", (PyCFunction) &Dtool_NodePath_set_attrib_690, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_attrib_690_comment},
  {"get_attrib", &Dtool_NodePath_get_attrib_691, METH_O, (const char *)Dtool_NodePath_get_attrib_691_comment},
  {"getAttrib", &Dtool_NodePath_get_attrib_691, METH_O, (const char *)Dtool_NodePath_get_attrib_691_comment},
  {"has_attrib", &Dtool_NodePath_has_attrib_692, METH_O, (const char *)Dtool_NodePath_has_attrib_692_comment},
  {"hasAttrib", &Dtool_NodePath_has_attrib_692, METH_O, (const char *)Dtool_NodePath_has_attrib_692_comment},
  {"clear_attrib", &Dtool_NodePath_clear_attrib_693, METH_O, (const char *)Dtool_NodePath_clear_attrib_693_comment},
  {"clearAttrib", &Dtool_NodePath_clear_attrib_693, METH_O, (const char *)Dtool_NodePath_clear_attrib_693_comment},
  {"set_effect", &Dtool_NodePath_set_effect_694, METH_O, (const char *)Dtool_NodePath_set_effect_694_comment},
  {"setEffect", &Dtool_NodePath_set_effect_694, METH_O, (const char *)Dtool_NodePath_set_effect_694_comment},
  {"get_effect", &Dtool_NodePath_get_effect_695, METH_O, (const char *)Dtool_NodePath_get_effect_695_comment},
  {"getEffect", &Dtool_NodePath_get_effect_695, METH_O, (const char *)Dtool_NodePath_get_effect_695_comment},
  {"has_effect", &Dtool_NodePath_has_effect_696, METH_O, (const char *)Dtool_NodePath_has_effect_696_comment},
  {"hasEffect", &Dtool_NodePath_has_effect_696, METH_O, (const char *)Dtool_NodePath_has_effect_696_comment},
  {"clear_effect", &Dtool_NodePath_clear_effect_697, METH_O, (const char *)Dtool_NodePath_clear_effect_697_comment},
  {"clearEffect", &Dtool_NodePath_clear_effect_697, METH_O, (const char *)Dtool_NodePath_clear_effect_697_comment},
  {"set_effects", &Dtool_NodePath_set_effects_698, METH_O, (const char *)Dtool_NodePath_set_effects_698_comment},
  {"setEffects", &Dtool_NodePath_set_effects_698, METH_O, (const char *)Dtool_NodePath_set_effects_698_comment},
  {"get_effects", &Dtool_NodePath_get_effects_699, METH_NOARGS, (const char *)Dtool_NodePath_get_effects_699_comment},
  {"getEffects", &Dtool_NodePath_get_effects_699, METH_NOARGS, (const char *)Dtool_NodePath_get_effects_699_comment},
  {"clear_effects", &Dtool_NodePath_clear_effects_700, METH_NOARGS, (const char *)Dtool_NodePath_clear_effects_700_comment},
  {"clearEffects", &Dtool_NodePath_clear_effects_700, METH_NOARGS, (const char *)Dtool_NodePath_clear_effects_700_comment},
  {"get_transform", (PyCFunction) &Dtool_NodePath_get_transform_701, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_transform_701_comment},
  {"getTransform", (PyCFunction) &Dtool_NodePath_get_transform_701, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_transform_701_comment},
  {"clear_transform", (PyCFunction) &Dtool_NodePath_clear_transform_702, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_clear_transform_702_comment},
  {"clearTransform", (PyCFunction) &Dtool_NodePath_clear_transform_702, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_clear_transform_702_comment},
  {"set_transform", (PyCFunction) &Dtool_NodePath_set_transform_703, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_transform_703_comment},
  {"setTransform", (PyCFunction) &Dtool_NodePath_set_transform_703, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_transform_703_comment},
  {"get_net_transform", (PyCFunction) &Dtool_NodePath_get_net_transform_704, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_net_transform_704_comment},
  {"getNetTransform", (PyCFunction) &Dtool_NodePath_get_net_transform_704, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_net_transform_704_comment},
  {"get_prev_transform", (PyCFunction) &Dtool_NodePath_get_prev_transform_705, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_prev_transform_705_comment},
  {"getPrevTransform", (PyCFunction) &Dtool_NodePath_get_prev_transform_705, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_prev_transform_705_comment},
  {"set_prev_transform", (PyCFunction) &Dtool_NodePath_set_prev_transform_706, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_prev_transform_706_comment},
  {"setPrevTransform", (PyCFunction) &Dtool_NodePath_set_prev_transform_706, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_prev_transform_706_comment},
  {"get_net_prev_transform", (PyCFunction) &Dtool_NodePath_get_net_prev_transform_707, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_net_prev_transform_707_comment},
  {"getNetPrevTransform", (PyCFunction) &Dtool_NodePath_get_net_prev_transform_707, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_net_prev_transform_707_comment},
  {"set_pos", (PyCFunction) &Dtool_NodePath_set_pos_708, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_708_comment},
  {"setPos", (PyCFunction) &Dtool_NodePath_set_pos_708, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_708_comment},
  {"set_x", (PyCFunction) &Dtool_NodePath_set_x_709, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_x_709_comment},
  {"setX", (PyCFunction) &Dtool_NodePath_set_x_709, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_x_709_comment},
  {"set_y", (PyCFunction) &Dtool_NodePath_set_y_710, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_y_710_comment},
  {"setY", (PyCFunction) &Dtool_NodePath_set_y_710, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_y_710_comment},
  {"set_z", (PyCFunction) &Dtool_NodePath_set_z_711, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_z_711_comment},
  {"setZ", (PyCFunction) &Dtool_NodePath_set_z_711, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_z_711_comment},
  {"set_fluid_pos", (PyCFunction) &Dtool_NodePath_set_fluid_pos_712, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fluid_pos_712_comment},
  {"setFluidPos", (PyCFunction) &Dtool_NodePath_set_fluid_pos_712, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fluid_pos_712_comment},
  {"set_fluid_x", (PyCFunction) &Dtool_NodePath_set_fluid_x_713, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fluid_x_713_comment},
  {"setFluidX", (PyCFunction) &Dtool_NodePath_set_fluid_x_713, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fluid_x_713_comment},
  {"set_fluid_y", (PyCFunction) &Dtool_NodePath_set_fluid_y_714, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fluid_y_714_comment},
  {"setFluidY", (PyCFunction) &Dtool_NodePath_set_fluid_y_714, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fluid_y_714_comment},
  {"set_fluid_z", (PyCFunction) &Dtool_NodePath_set_fluid_z_715, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fluid_z_715_comment},
  {"setFluidZ", (PyCFunction) &Dtool_NodePath_set_fluid_z_715, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fluid_z_715_comment},
  {"get_pos", &Dtool_NodePath_get_pos_716, METH_VARARGS, (const char *)Dtool_NodePath_get_pos_716_comment},
  {"getPos", &Dtool_NodePath_get_pos_716, METH_VARARGS, (const char *)Dtool_NodePath_get_pos_716_comment},
  {"get_x", &Dtool_NodePath_get_x_717, METH_VARARGS, (const char *)Dtool_NodePath_get_x_717_comment},
  {"getX", &Dtool_NodePath_get_x_717, METH_VARARGS, (const char *)Dtool_NodePath_get_x_717_comment},
  {"get_y", &Dtool_NodePath_get_y_718, METH_VARARGS, (const char *)Dtool_NodePath_get_y_718_comment},
  {"getY", &Dtool_NodePath_get_y_718, METH_VARARGS, (const char *)Dtool_NodePath_get_y_718_comment},
  {"get_z", &Dtool_NodePath_get_z_719, METH_VARARGS, (const char *)Dtool_NodePath_get_z_719_comment},
  {"getZ", &Dtool_NodePath_get_z_719, METH_VARARGS, (const char *)Dtool_NodePath_get_z_719_comment},
  {"get_pos_delta", &Dtool_NodePath_get_pos_delta_720, METH_VARARGS, (const char *)Dtool_NodePath_get_pos_delta_720_comment},
  {"getPosDelta", &Dtool_NodePath_get_pos_delta_720, METH_VARARGS, (const char *)Dtool_NodePath_get_pos_delta_720_comment},
  {"set_hpr", (PyCFunction) &Dtool_NodePath_set_hpr_721, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_hpr_721_comment},
  {"setHpr", (PyCFunction) &Dtool_NodePath_set_hpr_721, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_hpr_721_comment},
  {"set_h", (PyCFunction) &Dtool_NodePath_set_h_722, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_h_722_comment},
  {"setH", (PyCFunction) &Dtool_NodePath_set_h_722, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_h_722_comment},
  {"set_p", (PyCFunction) &Dtool_NodePath_set_p_723, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_p_723_comment},
  {"setP", (PyCFunction) &Dtool_NodePath_set_p_723, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_p_723_comment},
  {"set_r", (PyCFunction) &Dtool_NodePath_set_r_724, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_r_724_comment},
  {"setR", (PyCFunction) &Dtool_NodePath_set_r_724, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_r_724_comment},
  {"get_hpr", &Dtool_NodePath_get_hpr_725, METH_VARARGS, (const char *)Dtool_NodePath_get_hpr_725_comment},
  {"getHpr", &Dtool_NodePath_get_hpr_725, METH_VARARGS, (const char *)Dtool_NodePath_get_hpr_725_comment},
  {"get_h", &Dtool_NodePath_get_h_726, METH_VARARGS, (const char *)Dtool_NodePath_get_h_726_comment},
  {"getH", &Dtool_NodePath_get_h_726, METH_VARARGS, (const char *)Dtool_NodePath_get_h_726_comment},
  {"get_p", &Dtool_NodePath_get_p_727, METH_VARARGS, (const char *)Dtool_NodePath_get_p_727_comment},
  {"getP", &Dtool_NodePath_get_p_727, METH_VARARGS, (const char *)Dtool_NodePath_get_p_727_comment},
  {"get_r", &Dtool_NodePath_get_r_728, METH_VARARGS, (const char *)Dtool_NodePath_get_r_728_comment},
  {"getR", &Dtool_NodePath_get_r_728, METH_VARARGS, (const char *)Dtool_NodePath_get_r_728_comment},
  {"set_quat", (PyCFunction) &Dtool_NodePath_set_quat_729, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_quat_729_comment},
  {"setQuat", (PyCFunction) &Dtool_NodePath_set_quat_729, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_quat_729_comment},
  {"get_quat", &Dtool_NodePath_get_quat_730, METH_VARARGS, (const char *)Dtool_NodePath_get_quat_730_comment},
  {"getQuat", &Dtool_NodePath_get_quat_730, METH_VARARGS, (const char *)Dtool_NodePath_get_quat_730_comment},
  {"set_scale", (PyCFunction) &Dtool_NodePath_set_scale_731, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_scale_731_comment},
  {"setScale", (PyCFunction) &Dtool_NodePath_set_scale_731, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_scale_731_comment},
  {"set_sx", (PyCFunction) &Dtool_NodePath_set_sx_732, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_sx_732_comment},
  {"setSx", (PyCFunction) &Dtool_NodePath_set_sx_732, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_sx_732_comment},
  {"set_sy", (PyCFunction) &Dtool_NodePath_set_sy_733, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_sy_733_comment},
  {"setSy", (PyCFunction) &Dtool_NodePath_set_sy_733, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_sy_733_comment},
  {"set_sz", (PyCFunction) &Dtool_NodePath_set_sz_734, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_sz_734_comment},
  {"setSz", (PyCFunction) &Dtool_NodePath_set_sz_734, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_sz_734_comment},
  {"get_scale", &Dtool_NodePath_get_scale_735, METH_VARARGS, (const char *)Dtool_NodePath_get_scale_735_comment},
  {"getScale", &Dtool_NodePath_get_scale_735, METH_VARARGS, (const char *)Dtool_NodePath_get_scale_735_comment},
  {"get_sx", &Dtool_NodePath_get_sx_736, METH_VARARGS, (const char *)Dtool_NodePath_get_sx_736_comment},
  {"getSx", &Dtool_NodePath_get_sx_736, METH_VARARGS, (const char *)Dtool_NodePath_get_sx_736_comment},
  {"get_sy", &Dtool_NodePath_get_sy_737, METH_VARARGS, (const char *)Dtool_NodePath_get_sy_737_comment},
  {"getSy", &Dtool_NodePath_get_sy_737, METH_VARARGS, (const char *)Dtool_NodePath_get_sy_737_comment},
  {"get_sz", &Dtool_NodePath_get_sz_738, METH_VARARGS, (const char *)Dtool_NodePath_get_sz_738_comment},
  {"getSz", &Dtool_NodePath_get_sz_738, METH_VARARGS, (const char *)Dtool_NodePath_get_sz_738_comment},
  {"set_shear", (PyCFunction) &Dtool_NodePath_set_shear_739, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shear_739_comment},
  {"setShear", (PyCFunction) &Dtool_NodePath_set_shear_739, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shear_739_comment},
  {"set_shxy", (PyCFunction) &Dtool_NodePath_set_shxy_740, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shxy_740_comment},
  {"setShxy", (PyCFunction) &Dtool_NodePath_set_shxy_740, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shxy_740_comment},
  {"set_shxz", (PyCFunction) &Dtool_NodePath_set_shxz_741, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shxz_741_comment},
  {"setShxz", (PyCFunction) &Dtool_NodePath_set_shxz_741, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shxz_741_comment},
  {"set_shyz", (PyCFunction) &Dtool_NodePath_set_shyz_742, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shyz_742_comment},
  {"setShyz", (PyCFunction) &Dtool_NodePath_set_shyz_742, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shyz_742_comment},
  {"get_shear", &Dtool_NodePath_get_shear_743, METH_VARARGS, (const char *)Dtool_NodePath_get_shear_743_comment},
  {"getShear", &Dtool_NodePath_get_shear_743, METH_VARARGS, (const char *)Dtool_NodePath_get_shear_743_comment},
  {"get_shxy", &Dtool_NodePath_get_shxy_744, METH_VARARGS, (const char *)Dtool_NodePath_get_shxy_744_comment},
  {"getShxy", &Dtool_NodePath_get_shxy_744, METH_VARARGS, (const char *)Dtool_NodePath_get_shxy_744_comment},
  {"get_shxz", &Dtool_NodePath_get_shxz_745, METH_VARARGS, (const char *)Dtool_NodePath_get_shxz_745_comment},
  {"getShxz", &Dtool_NodePath_get_shxz_745, METH_VARARGS, (const char *)Dtool_NodePath_get_shxz_745_comment},
  {"get_shyz", &Dtool_NodePath_get_shyz_746, METH_VARARGS, (const char *)Dtool_NodePath_get_shyz_746_comment},
  {"getShyz", &Dtool_NodePath_get_shyz_746, METH_VARARGS, (const char *)Dtool_NodePath_get_shyz_746_comment},
  {"set_pos_hpr", (PyCFunction) &Dtool_NodePath_set_pos_hpr_747, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_hpr_747_comment},
  {"setPosHpr", (PyCFunction) &Dtool_NodePath_set_pos_hpr_747, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_hpr_747_comment},
  {"set_pos_quat", (PyCFunction) &Dtool_NodePath_set_pos_quat_748, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_quat_748_comment},
  {"setPosQuat", (PyCFunction) &Dtool_NodePath_set_pos_quat_748, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_quat_748_comment},
  {"set_hpr_scale", (PyCFunction) &Dtool_NodePath_set_hpr_scale_749, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_hpr_scale_749_comment},
  {"setHprScale", (PyCFunction) &Dtool_NodePath_set_hpr_scale_749, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_hpr_scale_749_comment},
  {"set_quat_scale", (PyCFunction) &Dtool_NodePath_set_quat_scale_750, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_quat_scale_750_comment},
  {"setQuatScale", (PyCFunction) &Dtool_NodePath_set_quat_scale_750, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_quat_scale_750_comment},
  {"set_pos_hpr_scale", (PyCFunction) &Dtool_NodePath_set_pos_hpr_scale_751, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_hpr_scale_751_comment},
  {"setPosHprScale", (PyCFunction) &Dtool_NodePath_set_pos_hpr_scale_751, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_hpr_scale_751_comment},
  {"set_pos_quat_scale", (PyCFunction) &Dtool_NodePath_set_pos_quat_scale_752, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_quat_scale_752_comment},
  {"setPosQuatScale", (PyCFunction) &Dtool_NodePath_set_pos_quat_scale_752, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_quat_scale_752_comment},
  {"set_pos_hpr_scale_shear", (PyCFunction) &Dtool_NodePath_set_pos_hpr_scale_shear_753, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_hpr_scale_shear_753_comment},
  {"setPosHprScaleShear", (PyCFunction) &Dtool_NodePath_set_pos_hpr_scale_shear_753, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_hpr_scale_shear_753_comment},
  {"set_pos_quat_scale_shear", (PyCFunction) &Dtool_NodePath_set_pos_quat_scale_shear_754, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_quat_scale_shear_754_comment},
  {"setPosQuatScaleShear", (PyCFunction) &Dtool_NodePath_set_pos_quat_scale_shear_754, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_pos_quat_scale_shear_754_comment},
  {"set_mat", (PyCFunction) &Dtool_NodePath_set_mat_755, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_mat_755_comment},
  {"setMat", (PyCFunction) &Dtool_NodePath_set_mat_755, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_mat_755_comment},
  {"clear_mat", &Dtool_NodePath_clear_mat_756, METH_NOARGS, (const char *)Dtool_NodePath_clear_mat_756_comment},
  {"clearMat", &Dtool_NodePath_clear_mat_756, METH_NOARGS, (const char *)Dtool_NodePath_clear_mat_756_comment},
  {"has_mat", &Dtool_NodePath_has_mat_757, METH_NOARGS, (const char *)Dtool_NodePath_has_mat_757_comment},
  {"hasMat", &Dtool_NodePath_has_mat_757, METH_NOARGS, (const char *)Dtool_NodePath_has_mat_757_comment},
  {"get_mat", &Dtool_NodePath_get_mat_758, METH_VARARGS, (const char *)Dtool_NodePath_get_mat_758_comment},
  {"getMat", &Dtool_NodePath_get_mat_758, METH_VARARGS, (const char *)Dtool_NodePath_get_mat_758_comment},
  {"look_at", (PyCFunction) &Dtool_NodePath_look_at_759, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_look_at_759_comment},
  {"lookAt", (PyCFunction) &Dtool_NodePath_look_at_759, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_look_at_759_comment},
  {"heads_up", (PyCFunction) &Dtool_NodePath_heads_up_760, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_heads_up_760_comment},
  {"headsUp", (PyCFunction) &Dtool_NodePath_heads_up_760, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_heads_up_760_comment},
  {"get_relative_point", (PyCFunction) &Dtool_NodePath_get_relative_point_761, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_relative_point_761_comment},
  {"getRelativePoint", (PyCFunction) &Dtool_NodePath_get_relative_point_761, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_relative_point_761_comment},
  {"get_relative_vector", (PyCFunction) &Dtool_NodePath_get_relative_vector_762, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_relative_vector_762_comment},
  {"getRelativeVector", (PyCFunction) &Dtool_NodePath_get_relative_vector_762, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_relative_vector_762_comment},
  {"get_distance", &Dtool_NodePath_get_distance_763, METH_O, (const char *)Dtool_NodePath_get_distance_763_comment},
  {"getDistance", &Dtool_NodePath_get_distance_763, METH_O, (const char *)Dtool_NodePath_get_distance_763_comment},
  {"set_color", (PyCFunction) &Dtool_NodePath_set_color_764, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_color_764_comment},
  {"setColor", (PyCFunction) &Dtool_NodePath_set_color_764, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_color_764_comment},
  {"set_color_off", (PyCFunction) &Dtool_NodePath_set_color_off_765, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_color_off_765_comment},
  {"setColorOff", (PyCFunction) &Dtool_NodePath_set_color_off_765, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_color_off_765_comment},
  {"clear_color", &Dtool_NodePath_clear_color_766, METH_NOARGS, (const char *)Dtool_NodePath_clear_color_766_comment},
  {"clearColor", &Dtool_NodePath_clear_color_766, METH_NOARGS, (const char *)Dtool_NodePath_clear_color_766_comment},
  {"has_color", &Dtool_NodePath_has_color_767, METH_NOARGS, (const char *)Dtool_NodePath_has_color_767_comment},
  {"hasColor", &Dtool_NodePath_has_color_767, METH_NOARGS, (const char *)Dtool_NodePath_has_color_767_comment},
  {"get_color", &Dtool_NodePath_get_color_768, METH_NOARGS, (const char *)Dtool_NodePath_get_color_768_comment},
  {"getColor", &Dtool_NodePath_get_color_768, METH_NOARGS, (const char *)Dtool_NodePath_get_color_768_comment},
  {"has_color_scale", &Dtool_NodePath_has_color_scale_769, METH_NOARGS, (const char *)Dtool_NodePath_has_color_scale_769_comment},
  {"hasColorScale", &Dtool_NodePath_has_color_scale_769, METH_NOARGS, (const char *)Dtool_NodePath_has_color_scale_769_comment},
  {"clear_color_scale", &Dtool_NodePath_clear_color_scale_770, METH_NOARGS, (const char *)Dtool_NodePath_clear_color_scale_770_comment},
  {"clearColorScale", &Dtool_NodePath_clear_color_scale_770, METH_NOARGS, (const char *)Dtool_NodePath_clear_color_scale_770_comment},
  {"set_color_scale", (PyCFunction) &Dtool_NodePath_set_color_scale_771, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_color_scale_771_comment},
  {"setColorScale", (PyCFunction) &Dtool_NodePath_set_color_scale_771, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_color_scale_771_comment},
  {"compose_color_scale", (PyCFunction) &Dtool_NodePath_compose_color_scale_772, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_compose_color_scale_772_comment},
  {"composeColorScale", (PyCFunction) &Dtool_NodePath_compose_color_scale_772, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_compose_color_scale_772_comment},
  {"set_color_scale_off", (PyCFunction) &Dtool_NodePath_set_color_scale_off_773, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_color_scale_off_773_comment},
  {"setColorScaleOff", (PyCFunction) &Dtool_NodePath_set_color_scale_off_773, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_color_scale_off_773_comment},
  {"set_alpha_scale", (PyCFunction) &Dtool_NodePath_set_alpha_scale_774, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_alpha_scale_774_comment},
  {"setAlphaScale", (PyCFunction) &Dtool_NodePath_set_alpha_scale_774, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_alpha_scale_774_comment},
  {"set_all_color_scale", (PyCFunction) &Dtool_NodePath_set_all_color_scale_775, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_all_color_scale_775_comment},
  {"setAllColorScale", (PyCFunction) &Dtool_NodePath_set_all_color_scale_775, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_all_color_scale_775_comment},
  {"set_sr", &Dtool_NodePath_set_sr_776, METH_O, (const char *)Dtool_NodePath_set_sr_776_comment},
  {"setSr", &Dtool_NodePath_set_sr_776, METH_O, (const char *)Dtool_NodePath_set_sr_776_comment},
  {"set_sg", &Dtool_NodePath_set_sg_777, METH_O, (const char *)Dtool_NodePath_set_sg_777_comment},
  {"setSg", &Dtool_NodePath_set_sg_777, METH_O, (const char *)Dtool_NodePath_set_sg_777_comment},
  {"set_sb", &Dtool_NodePath_set_sb_778, METH_O, (const char *)Dtool_NodePath_set_sb_778_comment},
  {"setSb", &Dtool_NodePath_set_sb_778, METH_O, (const char *)Dtool_NodePath_set_sb_778_comment},
  {"set_sa", &Dtool_NodePath_set_sa_779, METH_O, (const char *)Dtool_NodePath_set_sa_779_comment},
  {"setSa", &Dtool_NodePath_set_sa_779, METH_O, (const char *)Dtool_NodePath_set_sa_779_comment},
  {"get_color_scale", &Dtool_NodePath_get_color_scale_780, METH_NOARGS, (const char *)Dtool_NodePath_get_color_scale_780_comment},
  {"getColorScale", &Dtool_NodePath_get_color_scale_780, METH_NOARGS, (const char *)Dtool_NodePath_get_color_scale_780_comment},
  {"get_sr", &Dtool_NodePath_get_sr_781, METH_NOARGS, (const char *)Dtool_NodePath_get_sr_781_comment},
  {"getSr", &Dtool_NodePath_get_sr_781, METH_NOARGS, (const char *)Dtool_NodePath_get_sr_781_comment},
  {"get_sg", &Dtool_NodePath_get_sg_782, METH_NOARGS, (const char *)Dtool_NodePath_get_sg_782_comment},
  {"getSg", &Dtool_NodePath_get_sg_782, METH_NOARGS, (const char *)Dtool_NodePath_get_sg_782_comment},
  {"get_sb", &Dtool_NodePath_get_sb_783, METH_NOARGS, (const char *)Dtool_NodePath_get_sb_783_comment},
  {"getSb", &Dtool_NodePath_get_sb_783, METH_NOARGS, (const char *)Dtool_NodePath_get_sb_783_comment},
  {"get_sa", &Dtool_NodePath_get_sa_784, METH_NOARGS, (const char *)Dtool_NodePath_get_sa_784_comment},
  {"getSa", &Dtool_NodePath_get_sa_784, METH_NOARGS, (const char *)Dtool_NodePath_get_sa_784_comment},
  {"set_light", (PyCFunction) &Dtool_NodePath_set_light_785, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_light_785_comment},
  {"setLight", (PyCFunction) &Dtool_NodePath_set_light_785, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_light_785_comment},
  {"set_light_off", (PyCFunction) &Dtool_NodePath_set_light_off_786, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_light_off_786_comment},
  {"setLightOff", (PyCFunction) &Dtool_NodePath_set_light_off_786, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_light_off_786_comment},
  {"clear_light", &Dtool_NodePath_clear_light_787, METH_VARARGS, (const char *)Dtool_NodePath_clear_light_787_comment},
  {"clearLight", &Dtool_NodePath_clear_light_787, METH_VARARGS, (const char *)Dtool_NodePath_clear_light_787_comment},
  {"has_light", &Dtool_NodePath_has_light_788, METH_O, (const char *)Dtool_NodePath_has_light_788_comment},
  {"hasLight", &Dtool_NodePath_has_light_788, METH_O, (const char *)Dtool_NodePath_has_light_788_comment},
  {"has_light_off", &Dtool_NodePath_has_light_off_789, METH_VARARGS, (const char *)Dtool_NodePath_has_light_off_789_comment},
  {"hasLightOff", &Dtool_NodePath_has_light_off_789, METH_VARARGS, (const char *)Dtool_NodePath_has_light_off_789_comment},
  {"set_clip_plane", (PyCFunction) &Dtool_NodePath_set_clip_plane_790, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_clip_plane_790_comment},
  {"setClipPlane", (PyCFunction) &Dtool_NodePath_set_clip_plane_790, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_clip_plane_790_comment},
  {"set_clip_plane_off", (PyCFunction) &Dtool_NodePath_set_clip_plane_off_791, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_clip_plane_off_791_comment},
  {"setClipPlaneOff", (PyCFunction) &Dtool_NodePath_set_clip_plane_off_791, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_clip_plane_off_791_comment},
  {"clear_clip_plane", &Dtool_NodePath_clear_clip_plane_792, METH_VARARGS, (const char *)Dtool_NodePath_clear_clip_plane_792_comment},
  {"clearClipPlane", &Dtool_NodePath_clear_clip_plane_792, METH_VARARGS, (const char *)Dtool_NodePath_clear_clip_plane_792_comment},
  {"has_clip_plane", &Dtool_NodePath_has_clip_plane_793, METH_O, (const char *)Dtool_NodePath_has_clip_plane_793_comment},
  {"hasClipPlane", &Dtool_NodePath_has_clip_plane_793, METH_O, (const char *)Dtool_NodePath_has_clip_plane_793_comment},
  {"has_clip_plane_off", &Dtool_NodePath_has_clip_plane_off_794, METH_VARARGS, (const char *)Dtool_NodePath_has_clip_plane_off_794_comment},
  {"hasClipPlaneOff", &Dtool_NodePath_has_clip_plane_off_794, METH_VARARGS, (const char *)Dtool_NodePath_has_clip_plane_off_794_comment},
  {"set_scissor", (PyCFunction) &Dtool_NodePath_set_scissor_795, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_scissor_795_comment},
  {"setScissor", (PyCFunction) &Dtool_NodePath_set_scissor_795, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_scissor_795_comment},
  {"clear_scissor", &Dtool_NodePath_clear_scissor_796, METH_NOARGS, (const char *)Dtool_NodePath_clear_scissor_796_comment},
  {"clearScissor", &Dtool_NodePath_clear_scissor_796, METH_NOARGS, (const char *)Dtool_NodePath_clear_scissor_796_comment},
  {"has_scissor", &Dtool_NodePath_has_scissor_797, METH_NOARGS, (const char *)Dtool_NodePath_has_scissor_797_comment},
  {"hasScissor", &Dtool_NodePath_has_scissor_797, METH_NOARGS, (const char *)Dtool_NodePath_has_scissor_797_comment},
  {"set_occluder", &Dtool_NodePath_set_occluder_798, METH_O, (const char *)Dtool_NodePath_set_occluder_798_comment},
  {"setOccluder", &Dtool_NodePath_set_occluder_798, METH_O, (const char *)Dtool_NodePath_set_occluder_798_comment},
  {"clear_occluder", &Dtool_NodePath_clear_occluder_799, METH_VARARGS, (const char *)Dtool_NodePath_clear_occluder_799_comment},
  {"clearOccluder", &Dtool_NodePath_clear_occluder_799, METH_VARARGS, (const char *)Dtool_NodePath_clear_occluder_799_comment},
  {"has_occluder", &Dtool_NodePath_has_occluder_800, METH_O, (const char *)Dtool_NodePath_has_occluder_800_comment},
  {"hasOccluder", &Dtool_NodePath_has_occluder_800, METH_O, (const char *)Dtool_NodePath_has_occluder_800_comment},
  {"set_bin", (PyCFunction) &Dtool_NodePath_set_bin_801, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_bin_801_comment},
  {"setBin", (PyCFunction) &Dtool_NodePath_set_bin_801, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_bin_801_comment},
  {"clear_bin", &Dtool_NodePath_clear_bin_802, METH_NOARGS, (const char *)Dtool_NodePath_clear_bin_802_comment},
  {"clearBin", &Dtool_NodePath_clear_bin_802, METH_NOARGS, (const char *)Dtool_NodePath_clear_bin_802_comment},
  {"has_bin", &Dtool_NodePath_has_bin_803, METH_NOARGS, (const char *)Dtool_NodePath_has_bin_803_comment},
  {"hasBin", &Dtool_NodePath_has_bin_803, METH_NOARGS, (const char *)Dtool_NodePath_has_bin_803_comment},
  {"get_bin_name", &Dtool_NodePath_get_bin_name_804, METH_NOARGS, (const char *)Dtool_NodePath_get_bin_name_804_comment},
  {"getBinName", &Dtool_NodePath_get_bin_name_804, METH_NOARGS, (const char *)Dtool_NodePath_get_bin_name_804_comment},
  {"get_bin_draw_order", &Dtool_NodePath_get_bin_draw_order_805, METH_NOARGS, (const char *)Dtool_NodePath_get_bin_draw_order_805_comment},
  {"getBinDrawOrder", &Dtool_NodePath_get_bin_draw_order_805, METH_NOARGS, (const char *)Dtool_NodePath_get_bin_draw_order_805_comment},
  {"set_texture", (PyCFunction) &Dtool_NodePath_set_texture_806, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_texture_806_comment},
  {"setTexture", (PyCFunction) &Dtool_NodePath_set_texture_806, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_texture_806_comment},
  {"set_texture_off", (PyCFunction) &Dtool_NodePath_set_texture_off_807, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_texture_off_807_comment},
  {"setTextureOff", (PyCFunction) &Dtool_NodePath_set_texture_off_807, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_texture_off_807_comment},
  {"clear_texture", &Dtool_NodePath_clear_texture_808, METH_VARARGS, (const char *)Dtool_NodePath_clear_texture_808_comment},
  {"clearTexture", &Dtool_NodePath_clear_texture_808, METH_VARARGS, (const char *)Dtool_NodePath_clear_texture_808_comment},
  {"has_texture", &Dtool_NodePath_has_texture_809, METH_VARARGS, (const char *)Dtool_NodePath_has_texture_809_comment},
  {"hasTexture", &Dtool_NodePath_has_texture_809, METH_VARARGS, (const char *)Dtool_NodePath_has_texture_809_comment},
  {"has_texture_off", &Dtool_NodePath_has_texture_off_810, METH_VARARGS, (const char *)Dtool_NodePath_has_texture_off_810_comment},
  {"hasTextureOff", &Dtool_NodePath_has_texture_off_810, METH_VARARGS, (const char *)Dtool_NodePath_has_texture_off_810_comment},
  {"get_texture", &Dtool_NodePath_get_texture_811, METH_VARARGS, (const char *)Dtool_NodePath_get_texture_811_comment},
  {"getTexture", &Dtool_NodePath_get_texture_811, METH_VARARGS, (const char *)Dtool_NodePath_get_texture_811_comment},
  {"replace_texture", (PyCFunction) &Dtool_NodePath_replace_texture_812, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_replace_texture_812_comment},
  {"replaceTexture", (PyCFunction) &Dtool_NodePath_replace_texture_812, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_replace_texture_812_comment},
  {"get_texture_sampler", &Dtool_NodePath_get_texture_sampler_813, METH_VARARGS, (const char *)Dtool_NodePath_get_texture_sampler_813_comment},
  {"getTextureSampler", &Dtool_NodePath_get_texture_sampler_813, METH_VARARGS, (const char *)Dtool_NodePath_get_texture_sampler_813_comment},
  {"set_shader", (PyCFunction) &Dtool_NodePath_set_shader_814, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shader_814_comment},
  {"setShader", (PyCFunction) &Dtool_NodePath_set_shader_814, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shader_814_comment},
  {"set_shader_off", (PyCFunction) &Dtool_NodePath_set_shader_off_815, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shader_off_815_comment},
  {"setShaderOff", (PyCFunction) &Dtool_NodePath_set_shader_off_815, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shader_off_815_comment},
  {"set_shader_auto", (PyCFunction) &Dtool_NodePath_set_shader_auto_816, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shader_auto_816_comment},
  {"setShaderAuto", (PyCFunction) &Dtool_NodePath_set_shader_auto_816, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shader_auto_816_comment},
  {"clear_shader", &Dtool_NodePath_clear_shader_817, METH_NOARGS, (const char *)Dtool_NodePath_clear_shader_817_comment},
  {"clearShader", &Dtool_NodePath_clear_shader_817, METH_NOARGS, (const char *)Dtool_NodePath_clear_shader_817_comment},
  {"set_shader_input", (PyCFunction) &Dtool_NodePath_set_shader_input_818, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shader_input_818_comment},
  {"setShaderInput", (PyCFunction) &Dtool_NodePath_set_shader_input_818, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shader_input_818_comment},
  {"set_shader_inputs", (PyCFunction) &Dtool_NodePath_set_shader_inputs_819, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shader_inputs_819_comment},
  {"setShaderInputs", (PyCFunction) &Dtool_NodePath_set_shader_inputs_819, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_shader_inputs_819_comment},
  {"clear_shader_input", &Dtool_NodePath_clear_shader_input_820, METH_O, (const char *)Dtool_NodePath_clear_shader_input_820_comment},
  {"clearShaderInput", &Dtool_NodePath_clear_shader_input_820, METH_O, (const char *)Dtool_NodePath_clear_shader_input_820_comment},
  {"set_instance_count", &Dtool_NodePath_set_instance_count_821, METH_O, (const char *)Dtool_NodePath_set_instance_count_821_comment},
  {"setInstanceCount", &Dtool_NodePath_set_instance_count_821, METH_O, (const char *)Dtool_NodePath_set_instance_count_821_comment},
  {"get_shader", &Dtool_NodePath_get_shader_822, METH_NOARGS, (const char *)Dtool_NodePath_get_shader_822_comment},
  {"getShader", &Dtool_NodePath_get_shader_822, METH_NOARGS, (const char *)Dtool_NodePath_get_shader_822_comment},
  {"get_shader_input", &Dtool_NodePath_get_shader_input_823, METH_O, (const char *)Dtool_NodePath_get_shader_input_823_comment},
  {"getShaderInput", &Dtool_NodePath_get_shader_input_823, METH_O, (const char *)Dtool_NodePath_get_shader_input_823_comment},
  {"get_instance_count", &Dtool_NodePath_get_instance_count_824, METH_NOARGS, (const char *)Dtool_NodePath_get_instance_count_824_comment},
  {"getInstanceCount", &Dtool_NodePath_get_instance_count_824, METH_NOARGS, (const char *)Dtool_NodePath_get_instance_count_824_comment},
  {"set_tex_transform", (PyCFunction) &Dtool_NodePath_set_tex_transform_825, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_transform_825_comment},
  {"setTexTransform", (PyCFunction) &Dtool_NodePath_set_tex_transform_825, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_transform_825_comment},
  {"clear_tex_transform", &Dtool_NodePath_clear_tex_transform_826, METH_VARARGS, (const char *)Dtool_NodePath_clear_tex_transform_826_comment},
  {"clearTexTransform", &Dtool_NodePath_clear_tex_transform_826, METH_VARARGS, (const char *)Dtool_NodePath_clear_tex_transform_826_comment},
  {"has_tex_transform", &Dtool_NodePath_has_tex_transform_827, METH_O, (const char *)Dtool_NodePath_has_tex_transform_827_comment},
  {"hasTexTransform", &Dtool_NodePath_has_tex_transform_827, METH_O, (const char *)Dtool_NodePath_has_tex_transform_827_comment},
  {"get_tex_transform", (PyCFunction) &Dtool_NodePath_get_tex_transform_828, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_transform_828_comment},
  {"getTexTransform", (PyCFunction) &Dtool_NodePath_get_tex_transform_828, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_transform_828_comment},
  {"set_tex_offset", (PyCFunction) &Dtool_NodePath_set_tex_offset_829, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_offset_829_comment},
  {"setTexOffset", (PyCFunction) &Dtool_NodePath_set_tex_offset_829, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_offset_829_comment},
  {"set_tex_rotate", (PyCFunction) &Dtool_NodePath_set_tex_rotate_830, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_rotate_830_comment},
  {"setTexRotate", (PyCFunction) &Dtool_NodePath_set_tex_rotate_830, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_rotate_830_comment},
  {"set_tex_scale", (PyCFunction) &Dtool_NodePath_set_tex_scale_831, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_scale_831_comment},
  {"setTexScale", (PyCFunction) &Dtool_NodePath_set_tex_scale_831, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_scale_831_comment},
  {"get_tex_offset", (PyCFunction) &Dtool_NodePath_get_tex_offset_832, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_offset_832_comment},
  {"getTexOffset", (PyCFunction) &Dtool_NodePath_get_tex_offset_832, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_offset_832_comment},
  {"get_tex_rotate", (PyCFunction) &Dtool_NodePath_get_tex_rotate_833, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_rotate_833_comment},
  {"getTexRotate", (PyCFunction) &Dtool_NodePath_get_tex_rotate_833, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_rotate_833_comment},
  {"get_tex_scale", (PyCFunction) &Dtool_NodePath_get_tex_scale_834, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_scale_834_comment},
  {"getTexScale", (PyCFunction) &Dtool_NodePath_get_tex_scale_834, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_scale_834_comment},
  {"set_tex_pos", (PyCFunction) &Dtool_NodePath_set_tex_pos_835, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_pos_835_comment},
  {"setTexPos", (PyCFunction) &Dtool_NodePath_set_tex_pos_835, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_pos_835_comment},
  {"set_tex_hpr", (PyCFunction) &Dtool_NodePath_set_tex_hpr_836, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_hpr_836_comment},
  {"setTexHpr", (PyCFunction) &Dtool_NodePath_set_tex_hpr_836, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_hpr_836_comment},
  {"get_tex_pos", (PyCFunction) &Dtool_NodePath_get_tex_pos_837, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_pos_837_comment},
  {"getTexPos", (PyCFunction) &Dtool_NodePath_get_tex_pos_837, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_pos_837_comment},
  {"get_tex_hpr", (PyCFunction) &Dtool_NodePath_get_tex_hpr_838, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_hpr_838_comment},
  {"getTexHpr", (PyCFunction) &Dtool_NodePath_get_tex_hpr_838, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_hpr_838_comment},
  {"get_tex_scale_3d", (PyCFunction) &Dtool_NodePath_get_tex_scale_3d_839, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_scale_3d_839_comment},
  {"getTexScale3d", (PyCFunction) &Dtool_NodePath_get_tex_scale_3d_839, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tex_scale_3d_839_comment},
  {"set_tex_gen", (PyCFunction) &Dtool_NodePath_set_tex_gen_840, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_gen_840_comment},
  {"setTexGen", (PyCFunction) &Dtool_NodePath_set_tex_gen_840, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_gen_840_comment},
  {"clear_tex_gen", &Dtool_NodePath_clear_tex_gen_841, METH_VARARGS, (const char *)Dtool_NodePath_clear_tex_gen_841_comment},
  {"clearTexGen", &Dtool_NodePath_clear_tex_gen_841, METH_VARARGS, (const char *)Dtool_NodePath_clear_tex_gen_841_comment},
  {"has_tex_gen", &Dtool_NodePath_has_tex_gen_842, METH_O, (const char *)Dtool_NodePath_has_tex_gen_842_comment},
  {"hasTexGen", &Dtool_NodePath_has_tex_gen_842, METH_O, (const char *)Dtool_NodePath_has_tex_gen_842_comment},
  {"get_tex_gen", &Dtool_NodePath_get_tex_gen_843, METH_O, (const char *)Dtool_NodePath_get_tex_gen_843_comment},
  {"getTexGen", &Dtool_NodePath_get_tex_gen_843, METH_O, (const char *)Dtool_NodePath_get_tex_gen_843_comment},
  {"set_tex_projector", (PyCFunction) &Dtool_NodePath_set_tex_projector_844, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_projector_844_comment},
  {"setTexProjector", (PyCFunction) &Dtool_NodePath_set_tex_projector_844, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tex_projector_844_comment},
  {"clear_tex_projector", &Dtool_NodePath_clear_tex_projector_845, METH_VARARGS, (const char *)Dtool_NodePath_clear_tex_projector_845_comment},
  {"clearTexProjector", &Dtool_NodePath_clear_tex_projector_845, METH_VARARGS, (const char *)Dtool_NodePath_clear_tex_projector_845_comment},
  {"has_tex_projector", &Dtool_NodePath_has_tex_projector_846, METH_O, (const char *)Dtool_NodePath_has_tex_projector_846_comment},
  {"hasTexProjector", &Dtool_NodePath_has_tex_projector_846, METH_O, (const char *)Dtool_NodePath_has_tex_projector_846_comment},
  {"get_tex_projector_from", &Dtool_NodePath_get_tex_projector_from_847, METH_O, (const char *)Dtool_NodePath_get_tex_projector_from_847_comment},
  {"getTexProjectorFrom", &Dtool_NodePath_get_tex_projector_from_847, METH_O, (const char *)Dtool_NodePath_get_tex_projector_from_847_comment},
  {"get_tex_projector_to", &Dtool_NodePath_get_tex_projector_to_848, METH_O, (const char *)Dtool_NodePath_get_tex_projector_to_848_comment},
  {"getTexProjectorTo", &Dtool_NodePath_get_tex_projector_to_848, METH_O, (const char *)Dtool_NodePath_get_tex_projector_to_848_comment},
  {"project_texture", (PyCFunction) &Dtool_NodePath_project_texture_849, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_project_texture_849_comment},
  {"projectTexture", (PyCFunction) &Dtool_NodePath_project_texture_849, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_project_texture_849_comment},
  {"clear_project_texture", &Dtool_NodePath_clear_project_texture_850, METH_O, (const char *)Dtool_NodePath_clear_project_texture_850_comment},
  {"clearProjectTexture", &Dtool_NodePath_clear_project_texture_850, METH_O, (const char *)Dtool_NodePath_clear_project_texture_850_comment},
  {"has_texcoord", &Dtool_NodePath_has_texcoord_851, METH_O, (const char *)Dtool_NodePath_has_texcoord_851_comment},
  {"hasTexcoord", &Dtool_NodePath_has_texcoord_851, METH_O, (const char *)Dtool_NodePath_has_texcoord_851_comment},
  {"has_vertex_column", &Dtool_NodePath_has_vertex_column_852, METH_O, (const char *)Dtool_NodePath_has_vertex_column_852_comment},
  {"hasVertexColumn", &Dtool_NodePath_has_vertex_column_852, METH_O, (const char *)Dtool_NodePath_has_vertex_column_852_comment},
  {"find_all_vertex_columns", &Dtool_NodePath_find_all_vertex_columns_853, METH_VARARGS, (const char *)Dtool_NodePath_find_all_vertex_columns_853_comment},
  {"findAllVertexColumns", &Dtool_NodePath_find_all_vertex_columns_853, METH_VARARGS, (const char *)Dtool_NodePath_find_all_vertex_columns_853_comment},
  {"find_all_texcoords", &Dtool_NodePath_find_all_texcoords_854, METH_VARARGS, (const char *)Dtool_NodePath_find_all_texcoords_854_comment},
  {"findAllTexcoords", &Dtool_NodePath_find_all_texcoords_854, METH_VARARGS, (const char *)Dtool_NodePath_find_all_texcoords_854_comment},
  {"find_texture", &Dtool_NodePath_find_texture_855, METH_O, (const char *)Dtool_NodePath_find_texture_855_comment},
  {"findTexture", &Dtool_NodePath_find_texture_855, METH_O, (const char *)Dtool_NodePath_find_texture_855_comment},
  {"find_all_textures", &Dtool_NodePath_find_all_textures_856, METH_VARARGS, (const char *)Dtool_NodePath_find_all_textures_856_comment},
  {"findAllTextures", &Dtool_NodePath_find_all_textures_856, METH_VARARGS, (const char *)Dtool_NodePath_find_all_textures_856_comment},
  {"find_texture_stage", &Dtool_NodePath_find_texture_stage_857, METH_O, (const char *)Dtool_NodePath_find_texture_stage_857_comment},
  {"findTextureStage", &Dtool_NodePath_find_texture_stage_857, METH_O, (const char *)Dtool_NodePath_find_texture_stage_857_comment},
  {"find_all_texture_stages", &Dtool_NodePath_find_all_texture_stages_858, METH_VARARGS, (const char *)Dtool_NodePath_find_all_texture_stages_858_comment},
  {"findAllTextureStages", &Dtool_NodePath_find_all_texture_stages_858, METH_VARARGS, (const char *)Dtool_NodePath_find_all_texture_stages_858_comment},
  {"unify_texture_stages", &Dtool_NodePath_unify_texture_stages_859, METH_O, (const char *)Dtool_NodePath_unify_texture_stages_859_comment},
  {"unifyTextureStages", &Dtool_NodePath_unify_texture_stages_859, METH_O, (const char *)Dtool_NodePath_unify_texture_stages_859_comment},
  {"find_material", &Dtool_NodePath_find_material_860, METH_O, (const char *)Dtool_NodePath_find_material_860_comment},
  {"findMaterial", &Dtool_NodePath_find_material_860, METH_O, (const char *)Dtool_NodePath_find_material_860_comment},
  {"find_all_materials", &Dtool_NodePath_find_all_materials_861, METH_VARARGS, (const char *)Dtool_NodePath_find_all_materials_861_comment},
  {"findAllMaterials", &Dtool_NodePath_find_all_materials_861, METH_VARARGS, (const char *)Dtool_NodePath_find_all_materials_861_comment},
  {"set_material", (PyCFunction) &Dtool_NodePath_set_material_862, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_material_862_comment},
  {"setMaterial", (PyCFunction) &Dtool_NodePath_set_material_862, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_material_862_comment},
  {"set_material_off", (PyCFunction) &Dtool_NodePath_set_material_off_863, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_material_off_863_comment},
  {"setMaterialOff", (PyCFunction) &Dtool_NodePath_set_material_off_863, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_material_off_863_comment},
  {"clear_material", &Dtool_NodePath_clear_material_864, METH_NOARGS, (const char *)Dtool_NodePath_clear_material_864_comment},
  {"clearMaterial", &Dtool_NodePath_clear_material_864, METH_NOARGS, (const char *)Dtool_NodePath_clear_material_864_comment},
  {"has_material", &Dtool_NodePath_has_material_865, METH_NOARGS, (const char *)Dtool_NodePath_has_material_865_comment},
  {"hasMaterial", &Dtool_NodePath_has_material_865, METH_NOARGS, (const char *)Dtool_NodePath_has_material_865_comment},
  {"get_material", &Dtool_NodePath_get_material_866, METH_NOARGS, (const char *)Dtool_NodePath_get_material_866_comment},
  {"getMaterial", &Dtool_NodePath_get_material_866, METH_NOARGS, (const char *)Dtool_NodePath_get_material_866_comment},
  {"replace_material", (PyCFunction) &Dtool_NodePath_replace_material_867, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_replace_material_867_comment},
  {"replaceMaterial", (PyCFunction) &Dtool_NodePath_replace_material_867, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_replace_material_867_comment},
  {"set_fog", (PyCFunction) &Dtool_NodePath_set_fog_868, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fog_868_comment},
  {"setFog", (PyCFunction) &Dtool_NodePath_set_fog_868, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fog_868_comment},
  {"set_fog_off", (PyCFunction) &Dtool_NodePath_set_fog_off_869, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fog_off_869_comment},
  {"setFogOff", (PyCFunction) &Dtool_NodePath_set_fog_off_869, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_fog_off_869_comment},
  {"clear_fog", &Dtool_NodePath_clear_fog_870, METH_NOARGS, (const char *)Dtool_NodePath_clear_fog_870_comment},
  {"clearFog", &Dtool_NodePath_clear_fog_870, METH_NOARGS, (const char *)Dtool_NodePath_clear_fog_870_comment},
  {"has_fog", &Dtool_NodePath_has_fog_871, METH_NOARGS, (const char *)Dtool_NodePath_has_fog_871_comment},
  {"hasFog", &Dtool_NodePath_has_fog_871, METH_NOARGS, (const char *)Dtool_NodePath_has_fog_871_comment},
  {"has_fog_off", &Dtool_NodePath_has_fog_off_872, METH_NOARGS, (const char *)Dtool_NodePath_has_fog_off_872_comment},
  {"hasFogOff", &Dtool_NodePath_has_fog_off_872, METH_NOARGS, (const char *)Dtool_NodePath_has_fog_off_872_comment},
  {"get_fog", &Dtool_NodePath_get_fog_873, METH_NOARGS, (const char *)Dtool_NodePath_get_fog_873_comment},
  {"getFog", &Dtool_NodePath_get_fog_873, METH_NOARGS, (const char *)Dtool_NodePath_get_fog_873_comment},
  {"set_render_mode_wireframe", (PyCFunction) &Dtool_NodePath_set_render_mode_wireframe_874, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_wireframe_874_comment},
  {"setRenderModeWireframe", (PyCFunction) &Dtool_NodePath_set_render_mode_wireframe_874, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_wireframe_874_comment},
  {"set_render_mode_filled", (PyCFunction) &Dtool_NodePath_set_render_mode_filled_875, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_filled_875_comment},
  {"setRenderModeFilled", (PyCFunction) &Dtool_NodePath_set_render_mode_filled_875, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_filled_875_comment},
  {"set_render_mode_filled_wireframe", (PyCFunction) &Dtool_NodePath_set_render_mode_filled_wireframe_876, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_filled_wireframe_876_comment},
  {"setRenderModeFilledWireframe", (PyCFunction) &Dtool_NodePath_set_render_mode_filled_wireframe_876, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_filled_wireframe_876_comment},
  {"set_render_mode_thickness", (PyCFunction) &Dtool_NodePath_set_render_mode_thickness_877, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_thickness_877_comment},
  {"setRenderModeThickness", (PyCFunction) &Dtool_NodePath_set_render_mode_thickness_877, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_thickness_877_comment},
  {"set_render_mode_perspective", (PyCFunction) &Dtool_NodePath_set_render_mode_perspective_878, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_perspective_878_comment},
  {"setRenderModePerspective", (PyCFunction) &Dtool_NodePath_set_render_mode_perspective_878, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_perspective_878_comment},
  {"set_render_mode", (PyCFunction) &Dtool_NodePath_set_render_mode_879, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_879_comment},
  {"setRenderMode", (PyCFunction) &Dtool_NodePath_set_render_mode_879, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_render_mode_879_comment},
  {"clear_render_mode", &Dtool_NodePath_clear_render_mode_880, METH_NOARGS, (const char *)Dtool_NodePath_clear_render_mode_880_comment},
  {"clearRenderMode", &Dtool_NodePath_clear_render_mode_880, METH_NOARGS, (const char *)Dtool_NodePath_clear_render_mode_880_comment},
  {"has_render_mode", &Dtool_NodePath_has_render_mode_881, METH_NOARGS, (const char *)Dtool_NodePath_has_render_mode_881_comment},
  {"hasRenderMode", &Dtool_NodePath_has_render_mode_881, METH_NOARGS, (const char *)Dtool_NodePath_has_render_mode_881_comment},
  {"get_render_mode", &Dtool_NodePath_get_render_mode_882, METH_NOARGS, (const char *)Dtool_NodePath_get_render_mode_882_comment},
  {"getRenderMode", &Dtool_NodePath_get_render_mode_882, METH_NOARGS, (const char *)Dtool_NodePath_get_render_mode_882_comment},
  {"get_render_mode_thickness", &Dtool_NodePath_get_render_mode_thickness_883, METH_NOARGS, (const char *)Dtool_NodePath_get_render_mode_thickness_883_comment},
  {"getRenderModeThickness", &Dtool_NodePath_get_render_mode_thickness_883, METH_NOARGS, (const char *)Dtool_NodePath_get_render_mode_thickness_883_comment},
  {"get_render_mode_perspective", &Dtool_NodePath_get_render_mode_perspective_884, METH_NOARGS, (const char *)Dtool_NodePath_get_render_mode_perspective_884_comment},
  {"getRenderModePerspective", &Dtool_NodePath_get_render_mode_perspective_884, METH_NOARGS, (const char *)Dtool_NodePath_get_render_mode_perspective_884_comment},
  {"set_two_sided", (PyCFunction) &Dtool_NodePath_set_two_sided_885, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_two_sided_885_comment},
  {"setTwoSided", (PyCFunction) &Dtool_NodePath_set_two_sided_885, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_two_sided_885_comment},
  {"clear_two_sided", &Dtool_NodePath_clear_two_sided_886, METH_NOARGS, (const char *)Dtool_NodePath_clear_two_sided_886_comment},
  {"clearTwoSided", &Dtool_NodePath_clear_two_sided_886, METH_NOARGS, (const char *)Dtool_NodePath_clear_two_sided_886_comment},
  {"has_two_sided", &Dtool_NodePath_has_two_sided_887, METH_NOARGS, (const char *)Dtool_NodePath_has_two_sided_887_comment},
  {"hasTwoSided", &Dtool_NodePath_has_two_sided_887, METH_NOARGS, (const char *)Dtool_NodePath_has_two_sided_887_comment},
  {"get_two_sided", &Dtool_NodePath_get_two_sided_888, METH_NOARGS, (const char *)Dtool_NodePath_get_two_sided_888_comment},
  {"getTwoSided", &Dtool_NodePath_get_two_sided_888, METH_NOARGS, (const char *)Dtool_NodePath_get_two_sided_888_comment},
  {"set_depth_test", (PyCFunction) &Dtool_NodePath_set_depth_test_889, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_depth_test_889_comment},
  {"setDepthTest", (PyCFunction) &Dtool_NodePath_set_depth_test_889, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_depth_test_889_comment},
  {"clear_depth_test", &Dtool_NodePath_clear_depth_test_890, METH_NOARGS, (const char *)Dtool_NodePath_clear_depth_test_890_comment},
  {"clearDepthTest", &Dtool_NodePath_clear_depth_test_890, METH_NOARGS, (const char *)Dtool_NodePath_clear_depth_test_890_comment},
  {"has_depth_test", &Dtool_NodePath_has_depth_test_891, METH_NOARGS, (const char *)Dtool_NodePath_has_depth_test_891_comment},
  {"hasDepthTest", &Dtool_NodePath_has_depth_test_891, METH_NOARGS, (const char *)Dtool_NodePath_has_depth_test_891_comment},
  {"get_depth_test", &Dtool_NodePath_get_depth_test_892, METH_NOARGS, (const char *)Dtool_NodePath_get_depth_test_892_comment},
  {"getDepthTest", &Dtool_NodePath_get_depth_test_892, METH_NOARGS, (const char *)Dtool_NodePath_get_depth_test_892_comment},
  {"set_depth_write", (PyCFunction) &Dtool_NodePath_set_depth_write_893, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_depth_write_893_comment},
  {"setDepthWrite", (PyCFunction) &Dtool_NodePath_set_depth_write_893, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_depth_write_893_comment},
  {"clear_depth_write", &Dtool_NodePath_clear_depth_write_894, METH_NOARGS, (const char *)Dtool_NodePath_clear_depth_write_894_comment},
  {"clearDepthWrite", &Dtool_NodePath_clear_depth_write_894, METH_NOARGS, (const char *)Dtool_NodePath_clear_depth_write_894_comment},
  {"has_depth_write", &Dtool_NodePath_has_depth_write_895, METH_NOARGS, (const char *)Dtool_NodePath_has_depth_write_895_comment},
  {"hasDepthWrite", &Dtool_NodePath_has_depth_write_895, METH_NOARGS, (const char *)Dtool_NodePath_has_depth_write_895_comment},
  {"get_depth_write", &Dtool_NodePath_get_depth_write_896, METH_NOARGS, (const char *)Dtool_NodePath_get_depth_write_896_comment},
  {"getDepthWrite", &Dtool_NodePath_get_depth_write_896, METH_NOARGS, (const char *)Dtool_NodePath_get_depth_write_896_comment},
  {"set_depth_offset", (PyCFunction) &Dtool_NodePath_set_depth_offset_897, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_depth_offset_897_comment},
  {"setDepthOffset", (PyCFunction) &Dtool_NodePath_set_depth_offset_897, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_depth_offset_897_comment},
  {"clear_depth_offset", &Dtool_NodePath_clear_depth_offset_898, METH_NOARGS, (const char *)Dtool_NodePath_clear_depth_offset_898_comment},
  {"clearDepthOffset", &Dtool_NodePath_clear_depth_offset_898, METH_NOARGS, (const char *)Dtool_NodePath_clear_depth_offset_898_comment},
  {"has_depth_offset", &Dtool_NodePath_has_depth_offset_899, METH_NOARGS, (const char *)Dtool_NodePath_has_depth_offset_899_comment},
  {"hasDepthOffset", &Dtool_NodePath_has_depth_offset_899, METH_NOARGS, (const char *)Dtool_NodePath_has_depth_offset_899_comment},
  {"get_depth_offset", &Dtool_NodePath_get_depth_offset_900, METH_NOARGS, (const char *)Dtool_NodePath_get_depth_offset_900_comment},
  {"getDepthOffset", &Dtool_NodePath_get_depth_offset_900, METH_NOARGS, (const char *)Dtool_NodePath_get_depth_offset_900_comment},
  {"do_billboard_axis", (PyCFunction) &Dtool_NodePath_do_billboard_axis_901, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_do_billboard_axis_901_comment},
  {"doBillboardAxis", (PyCFunction) &Dtool_NodePath_do_billboard_axis_901, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_do_billboard_axis_901_comment},
  {"do_billboard_point_eye", (PyCFunction) &Dtool_NodePath_do_billboard_point_eye_902, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_do_billboard_point_eye_902_comment},
  {"doBillboardPointEye", (PyCFunction) &Dtool_NodePath_do_billboard_point_eye_902, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_do_billboard_point_eye_902_comment},
  {"do_billboard_point_world", (PyCFunction) &Dtool_NodePath_do_billboard_point_world_903, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_do_billboard_point_world_903_comment},
  {"doBillboardPointWorld", (PyCFunction) &Dtool_NodePath_do_billboard_point_world_903, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_do_billboard_point_world_903_comment},
  {"set_billboard_axis", (PyCFunction) &Dtool_NodePath_set_billboard_axis_904, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_billboard_axis_904_comment},
  {"setBillboardAxis", (PyCFunction) &Dtool_NodePath_set_billboard_axis_904, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_billboard_axis_904_comment},
  {"set_billboard_point_eye", (PyCFunction) &Dtool_NodePath_set_billboard_point_eye_905, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_billboard_point_eye_905_comment},
  {"setBillboardPointEye", (PyCFunction) &Dtool_NodePath_set_billboard_point_eye_905, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_billboard_point_eye_905_comment},
  {"set_billboard_point_world", (PyCFunction) &Dtool_NodePath_set_billboard_point_world_906, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_billboard_point_world_906_comment},
  {"setBillboardPointWorld", (PyCFunction) &Dtool_NodePath_set_billboard_point_world_906, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_billboard_point_world_906_comment},
  {"clear_billboard", &Dtool_NodePath_clear_billboard_907, METH_NOARGS, (const char *)Dtool_NodePath_clear_billboard_907_comment},
  {"clearBillboard", &Dtool_NodePath_clear_billboard_907, METH_NOARGS, (const char *)Dtool_NodePath_clear_billboard_907_comment},
  {"has_billboard", &Dtool_NodePath_has_billboard_908, METH_NOARGS, (const char *)Dtool_NodePath_has_billboard_908_comment},
  {"hasBillboard", &Dtool_NodePath_has_billboard_908, METH_NOARGS, (const char *)Dtool_NodePath_has_billboard_908_comment},
  {"set_compass", (PyCFunction) &Dtool_NodePath_set_compass_909, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_compass_909_comment},
  {"setCompass", (PyCFunction) &Dtool_NodePath_set_compass_909, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_compass_909_comment},
  {"clear_compass", &Dtool_NodePath_clear_compass_910, METH_NOARGS, (const char *)Dtool_NodePath_clear_compass_910_comment},
  {"clearCompass", &Dtool_NodePath_clear_compass_910, METH_NOARGS, (const char *)Dtool_NodePath_clear_compass_910_comment},
  {"has_compass", &Dtool_NodePath_has_compass_911, METH_NOARGS, (const char *)Dtool_NodePath_has_compass_911_comment},
  {"hasCompass", &Dtool_NodePath_has_compass_911, METH_NOARGS, (const char *)Dtool_NodePath_has_compass_911_comment},
  {"set_transparency", (PyCFunction) &Dtool_NodePath_set_transparency_912, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_transparency_912_comment},
  {"setTransparency", (PyCFunction) &Dtool_NodePath_set_transparency_912, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_transparency_912_comment},
  {"clear_transparency", &Dtool_NodePath_clear_transparency_913, METH_NOARGS, (const char *)Dtool_NodePath_clear_transparency_913_comment},
  {"clearTransparency", &Dtool_NodePath_clear_transparency_913, METH_NOARGS, (const char *)Dtool_NodePath_clear_transparency_913_comment},
  {"has_transparency", &Dtool_NodePath_has_transparency_914, METH_NOARGS, (const char *)Dtool_NodePath_has_transparency_914_comment},
  {"hasTransparency", &Dtool_NodePath_has_transparency_914, METH_NOARGS, (const char *)Dtool_NodePath_has_transparency_914_comment},
  {"get_transparency", &Dtool_NodePath_get_transparency_915, METH_NOARGS, (const char *)Dtool_NodePath_get_transparency_915_comment},
  {"getTransparency", &Dtool_NodePath_get_transparency_915, METH_NOARGS, (const char *)Dtool_NodePath_get_transparency_915_comment},
  {"set_logic_op", (PyCFunction) &Dtool_NodePath_set_logic_op_916, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_logic_op_916_comment},
  {"setLogicOp", (PyCFunction) &Dtool_NodePath_set_logic_op_916, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_logic_op_916_comment},
  {"clear_logic_op", &Dtool_NodePath_clear_logic_op_917, METH_NOARGS, (const char *)Dtool_NodePath_clear_logic_op_917_comment},
  {"clearLogicOp", &Dtool_NodePath_clear_logic_op_917, METH_NOARGS, (const char *)Dtool_NodePath_clear_logic_op_917_comment},
  {"has_logic_op", &Dtool_NodePath_has_logic_op_918, METH_NOARGS, (const char *)Dtool_NodePath_has_logic_op_918_comment},
  {"hasLogicOp", &Dtool_NodePath_has_logic_op_918, METH_NOARGS, (const char *)Dtool_NodePath_has_logic_op_918_comment},
  {"get_logic_op", &Dtool_NodePath_get_logic_op_919, METH_NOARGS, (const char *)Dtool_NodePath_get_logic_op_919_comment},
  {"getLogicOp", &Dtool_NodePath_get_logic_op_919, METH_NOARGS, (const char *)Dtool_NodePath_get_logic_op_919_comment},
  {"set_antialias", (PyCFunction) &Dtool_NodePath_set_antialias_920, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_antialias_920_comment},
  {"setAntialias", (PyCFunction) &Dtool_NodePath_set_antialias_920, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_antialias_920_comment},
  {"clear_antialias", &Dtool_NodePath_clear_antialias_921, METH_NOARGS, (const char *)Dtool_NodePath_clear_antialias_921_comment},
  {"clearAntialias", &Dtool_NodePath_clear_antialias_921, METH_NOARGS, (const char *)Dtool_NodePath_clear_antialias_921_comment},
  {"has_antialias", &Dtool_NodePath_has_antialias_922, METH_NOARGS, (const char *)Dtool_NodePath_has_antialias_922_comment},
  {"hasAntialias", &Dtool_NodePath_has_antialias_922, METH_NOARGS, (const char *)Dtool_NodePath_has_antialias_922_comment},
  {"get_antialias", &Dtool_NodePath_get_antialias_923, METH_NOARGS, (const char *)Dtool_NodePath_get_antialias_923_comment},
  {"getAntialias", &Dtool_NodePath_get_antialias_923, METH_NOARGS, (const char *)Dtool_NodePath_get_antialias_923_comment},
  {"has_audio_volume", &Dtool_NodePath_has_audio_volume_924, METH_NOARGS, (const char *)Dtool_NodePath_has_audio_volume_924_comment},
  {"hasAudioVolume", &Dtool_NodePath_has_audio_volume_924, METH_NOARGS, (const char *)Dtool_NodePath_has_audio_volume_924_comment},
  {"clear_audio_volume", &Dtool_NodePath_clear_audio_volume_925, METH_NOARGS, (const char *)Dtool_NodePath_clear_audio_volume_925_comment},
  {"clearAudioVolume", &Dtool_NodePath_clear_audio_volume_925, METH_NOARGS, (const char *)Dtool_NodePath_clear_audio_volume_925_comment},
  {"set_audio_volume", (PyCFunction) &Dtool_NodePath_set_audio_volume_926, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_audio_volume_926_comment},
  {"setAudioVolume", (PyCFunction) &Dtool_NodePath_set_audio_volume_926, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_audio_volume_926_comment},
  {"set_audio_volume_off", (PyCFunction) &Dtool_NodePath_set_audio_volume_off_927, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_audio_volume_off_927_comment},
  {"setAudioVolumeOff", (PyCFunction) &Dtool_NodePath_set_audio_volume_off_927, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_audio_volume_off_927_comment},
  {"get_audio_volume", &Dtool_NodePath_get_audio_volume_928, METH_NOARGS, (const char *)Dtool_NodePath_get_audio_volume_928_comment},
  {"getAudioVolume", &Dtool_NodePath_get_audio_volume_928, METH_NOARGS, (const char *)Dtool_NodePath_get_audio_volume_928_comment},
  {"get_net_audio_volume", &Dtool_NodePath_get_net_audio_volume_929, METH_NOARGS, (const char *)Dtool_NodePath_get_net_audio_volume_929_comment},
  {"getNetAudioVolume", &Dtool_NodePath_get_net_audio_volume_929, METH_NOARGS, (const char *)Dtool_NodePath_get_net_audio_volume_929_comment},
  {"adjust_all_priorities", &Dtool_NodePath_adjust_all_priorities_930, METH_O, (const char *)Dtool_NodePath_adjust_all_priorities_930_comment},
  {"adjustAllPriorities", &Dtool_NodePath_adjust_all_priorities_930, METH_O, (const char *)Dtool_NodePath_adjust_all_priorities_930_comment},
  {"show", &Dtool_NodePath_show_931, METH_VARARGS, (const char *)Dtool_NodePath_show_931_comment},
  {"show_through", &Dtool_NodePath_show_through_932, METH_VARARGS, (const char *)Dtool_NodePath_show_through_932_comment},
  {"showThrough", &Dtool_NodePath_show_through_932, METH_VARARGS, (const char *)Dtool_NodePath_show_through_932_comment},
  {"hide", &Dtool_NodePath_hide_933, METH_VARARGS, (const char *)Dtool_NodePath_hide_933_comment},
  {"is_hidden", (PyCFunction) &Dtool_NodePath_is_hidden_934, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_is_hidden_934_comment},
  {"isHidden", (PyCFunction) &Dtool_NodePath_is_hidden_934, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_is_hidden_934_comment},
  {"get_hidden_ancestor", (PyCFunction) &Dtool_NodePath_get_hidden_ancestor_935, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_hidden_ancestor_935_comment},
  {"getHiddenAncestor", (PyCFunction) &Dtool_NodePath_get_hidden_ancestor_935, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_hidden_ancestor_935_comment},
  {"stash", (PyCFunction) &Dtool_NodePath_stash_936, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_stash_936_comment},
  {"unstash", (PyCFunction) &Dtool_NodePath_unstash_937, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_unstash_937_comment},
  {"unstash_all", (PyCFunction) &Dtool_NodePath_unstash_all_938, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_unstash_all_938_comment},
  {"unstashAll", (PyCFunction) &Dtool_NodePath_unstash_all_938, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_unstash_all_938_comment},
  {"is_stashed", &Dtool_NodePath_is_stashed_939, METH_NOARGS, (const char *)Dtool_NodePath_is_stashed_939_comment},
  {"isStashed", &Dtool_NodePath_is_stashed_939, METH_NOARGS, (const char *)Dtool_NodePath_is_stashed_939_comment},
  {"get_stashed_ancestor", (PyCFunction) &Dtool_NodePath_get_stashed_ancestor_940, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_stashed_ancestor_940_comment},
  {"getStashedAncestor", (PyCFunction) &Dtool_NodePath_get_stashed_ancestor_940, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_stashed_ancestor_940_comment},
  {"get_collide_mask", &Dtool_NodePath_get_collide_mask_941, METH_NOARGS, (const char *)Dtool_NodePath_get_collide_mask_941_comment},
  {"getCollideMask", &Dtool_NodePath_get_collide_mask_941, METH_NOARGS, (const char *)Dtool_NodePath_get_collide_mask_941_comment},
  {"set_collide_mask", (PyCFunction) &Dtool_NodePath_set_collide_mask_942, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_collide_mask_942_comment},
  {"setCollideMask", (PyCFunction) &Dtool_NodePath_set_collide_mask_942, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_collide_mask_942_comment},
  {"compare_to", &Dtool_NodePath_compare_to_946, METH_O, (const char *)Dtool_NodePath_compare_to_946_comment},
  {"compareTo", &Dtool_NodePath_compare_to_946, METH_O, (const char *)Dtool_NodePath_compare_to_946_comment},
  {"verify_complete", (PyCFunction) &Dtool_NodePath_verify_complete_947, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_verify_complete_947_comment},
  {"verifyComplete", (PyCFunction) &Dtool_NodePath_verify_complete_947, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_verify_complete_947_comment},
  {"premunge_scene", (PyCFunction) &Dtool_NodePath_premunge_scene_948, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_premunge_scene_948_comment},
  {"premungeScene", (PyCFunction) &Dtool_NodePath_premunge_scene_948, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_premunge_scene_948_comment},
  {"prepare_scene", &Dtool_NodePath_prepare_scene_949, METH_O, (const char *)Dtool_NodePath_prepare_scene_949_comment},
  {"prepareScene", &Dtool_NodePath_prepare_scene_949, METH_O, (const char *)Dtool_NodePath_prepare_scene_949_comment},
  {"show_bounds", &Dtool_NodePath_show_bounds_950, METH_NOARGS, (const char *)Dtool_NodePath_show_bounds_950_comment},
  {"showBounds", &Dtool_NodePath_show_bounds_950, METH_NOARGS, (const char *)Dtool_NodePath_show_bounds_950_comment},
  {"show_tight_bounds", &Dtool_NodePath_show_tight_bounds_951, METH_NOARGS, (const char *)Dtool_NodePath_show_tight_bounds_951_comment},
  {"showTightBounds", &Dtool_NodePath_show_tight_bounds_951, METH_NOARGS, (const char *)Dtool_NodePath_show_tight_bounds_951_comment},
  {"hide_bounds", &Dtool_NodePath_hide_bounds_952, METH_NOARGS, (const char *)Dtool_NodePath_hide_bounds_952_comment},
  {"hideBounds", &Dtool_NodePath_hide_bounds_952, METH_NOARGS, (const char *)Dtool_NodePath_hide_bounds_952_comment},
  {"get_bounds", (PyCFunction) &Dtool_NodePath_get_bounds_953, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_bounds_953_comment},
  {"getBounds", (PyCFunction) &Dtool_NodePath_get_bounds_953, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_bounds_953_comment},
  {"force_recompute_bounds", &Dtool_NodePath_force_recompute_bounds_954, METH_NOARGS, (const char *)Dtool_NodePath_force_recompute_bounds_954_comment},
  {"forceRecomputeBounds", &Dtool_NodePath_force_recompute_bounds_954, METH_NOARGS, (const char *)Dtool_NodePath_force_recompute_bounds_954_comment},
  {"write_bounds", &Dtool_NodePath_write_bounds_955, METH_O, (const char *)Dtool_NodePath_write_bounds_955_comment},
  {"writeBounds", &Dtool_NodePath_write_bounds_955, METH_O, (const char *)Dtool_NodePath_write_bounds_955_comment},
  {"calc_tight_bounds", (PyCFunction) &Dtool_NodePath_calc_tight_bounds_956, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_calc_tight_bounds_956_comment},
  {"calcTightBounds", (PyCFunction) &Dtool_NodePath_calc_tight_bounds_956, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_calc_tight_bounds_956_comment},
  {"get_tight_bounds", (PyCFunction) &Dtool_NodePath_get_tight_bounds_957, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tight_bounds_957_comment},
  {"getTightBounds", (PyCFunction) &Dtool_NodePath_get_tight_bounds_957, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_get_tight_bounds_957_comment},
  {"flatten_light", &Dtool_NodePath_flatten_light_958, METH_NOARGS, (const char *)Dtool_NodePath_flatten_light_958_comment},
  {"flattenLight", &Dtool_NodePath_flatten_light_958, METH_NOARGS, (const char *)Dtool_NodePath_flatten_light_958_comment},
  {"flatten_medium", &Dtool_NodePath_flatten_medium_959, METH_NOARGS, (const char *)Dtool_NodePath_flatten_medium_959_comment},
  {"flattenMedium", &Dtool_NodePath_flatten_medium_959, METH_NOARGS, (const char *)Dtool_NodePath_flatten_medium_959_comment},
  {"flatten_strong", &Dtool_NodePath_flatten_strong_960, METH_NOARGS, (const char *)Dtool_NodePath_flatten_strong_960_comment},
  {"flattenStrong", &Dtool_NodePath_flatten_strong_960, METH_NOARGS, (const char *)Dtool_NodePath_flatten_strong_960_comment},
  {"apply_texture_colors", &Dtool_NodePath_apply_texture_colors_961, METH_NOARGS, (const char *)Dtool_NodePath_apply_texture_colors_961_comment},
  {"applyTextureColors", &Dtool_NodePath_apply_texture_colors_961, METH_NOARGS, (const char *)Dtool_NodePath_apply_texture_colors_961_comment},
  {"clear_model_nodes", &Dtool_NodePath_clear_model_nodes_962, METH_NOARGS, (const char *)Dtool_NodePath_clear_model_nodes_962_comment},
  {"clearModelNodes", &Dtool_NodePath_clear_model_nodes_962, METH_NOARGS, (const char *)Dtool_NodePath_clear_model_nodes_962_comment},
  {"set_tag", (PyCFunction) &Dtool_NodePath_set_tag_963, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tag_963_comment},
  {"setTag", (PyCFunction) &Dtool_NodePath_set_tag_963, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_tag_963_comment},
  {"get_tag", &Dtool_NodePath_get_tag_964, METH_O, (const char *)Dtool_NodePath_get_tag_964_comment},
  {"getTag", &Dtool_NodePath_get_tag_964, METH_O, (const char *)Dtool_NodePath_get_tag_964_comment},
  {"get_tag_keys", &Dtool_NodePath_get_tag_keys_965, METH_VARARGS, (const char *)Dtool_NodePath_get_tag_keys_965_comment},
  {"getTagKeys", &Dtool_NodePath_get_tag_keys_965, METH_VARARGS, (const char *)Dtool_NodePath_get_tag_keys_965_comment},
  {"has_tag", &Dtool_NodePath_has_tag_966, METH_O, (const char *)Dtool_NodePath_has_tag_966_comment},
  {"hasTag", &Dtool_NodePath_has_tag_966, METH_O, (const char *)Dtool_NodePath_has_tag_966_comment},
  {"clear_tag", &Dtool_NodePath_clear_tag_967, METH_O, (const char *)Dtool_NodePath_clear_tag_967_comment},
  {"clearTag", &Dtool_NodePath_clear_tag_967, METH_O, (const char *)Dtool_NodePath_clear_tag_967_comment},
  {"get_net_tag", &Dtool_NodePath_get_net_tag_968, METH_O, (const char *)Dtool_NodePath_get_net_tag_968_comment},
  {"getNetTag", &Dtool_NodePath_get_net_tag_968, METH_O, (const char *)Dtool_NodePath_get_net_tag_968_comment},
  {"has_net_tag", &Dtool_NodePath_has_net_tag_969, METH_O, (const char *)Dtool_NodePath_has_net_tag_969_comment},
  {"hasNetTag", &Dtool_NodePath_has_net_tag_969, METH_O, (const char *)Dtool_NodePath_has_net_tag_969_comment},
  {"find_net_tag", &Dtool_NodePath_find_net_tag_970, METH_O, (const char *)Dtool_NodePath_find_net_tag_970_comment},
  {"findNetTag", &Dtool_NodePath_find_net_tag_970, METH_O, (const char *)Dtool_NodePath_find_net_tag_970_comment},
  {"get_tags", &Dtool_NodePath_get_tags_972, METH_NOARGS, (const char *)Dtool_NodePath_get_tags_972_comment},
  {"getTags", &Dtool_NodePath_get_tags_972, METH_NOARGS, (const char *)Dtool_NodePath_get_tags_972_comment},
  {"get_python_tags", &Dtool_NodePath_get_python_tags_974, METH_NOARGS, (const char *)Dtool_NodePath_get_python_tags_974_comment},
  {"getPythonTags", &Dtool_NodePath_get_python_tags_974, METH_NOARGS, (const char *)Dtool_NodePath_get_python_tags_974_comment},
  {"set_python_tag", (PyCFunction) &Dtool_NodePath_set_python_tag_975, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_python_tag_975_comment},
  {"setPythonTag", (PyCFunction) &Dtool_NodePath_set_python_tag_975, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_set_python_tag_975_comment},
  {"get_python_tag", &Dtool_NodePath_get_python_tag_976, METH_O, (const char *)Dtool_NodePath_get_python_tag_976_comment},
  {"getPythonTag", &Dtool_NodePath_get_python_tag_976, METH_O, (const char *)Dtool_NodePath_get_python_tag_976_comment},
  {"get_python_tag_keys", &Dtool_NodePath_get_python_tag_keys_977, METH_NOARGS, (const char *)Dtool_NodePath_get_python_tag_keys_977_comment},
  {"getPythonTagKeys", &Dtool_NodePath_get_python_tag_keys_977, METH_NOARGS, (const char *)Dtool_NodePath_get_python_tag_keys_977_comment},
  {"has_python_tag", &Dtool_NodePath_has_python_tag_978, METH_O, (const char *)Dtool_NodePath_has_python_tag_978_comment},
  {"hasPythonTag", &Dtool_NodePath_has_python_tag_978, METH_O, (const char *)Dtool_NodePath_has_python_tag_978_comment},
  {"clear_python_tag", &Dtool_NodePath_clear_python_tag_979, METH_O, (const char *)Dtool_NodePath_clear_python_tag_979_comment},
  {"clearPythonTag", &Dtool_NodePath_clear_python_tag_979, METH_O, (const char *)Dtool_NodePath_clear_python_tag_979_comment},
  {"get_net_python_tag", &Dtool_NodePath_get_net_python_tag_980, METH_O, (const char *)Dtool_NodePath_get_net_python_tag_980_comment},
  {"getNetPythonTag", &Dtool_NodePath_get_net_python_tag_980, METH_O, (const char *)Dtool_NodePath_get_net_python_tag_980_comment},
  {"has_net_python_tag", &Dtool_NodePath_has_net_python_tag_981, METH_O, (const char *)Dtool_NodePath_has_net_python_tag_981_comment},
  {"hasNetPythonTag", &Dtool_NodePath_has_net_python_tag_981, METH_O, (const char *)Dtool_NodePath_has_net_python_tag_981_comment},
  {"find_net_python_tag", &Dtool_NodePath_find_net_python_tag_982, METH_O, (const char *)Dtool_NodePath_find_net_python_tag_982_comment},
  {"findNetPythonTag", &Dtool_NodePath_find_net_python_tag_982, METH_O, (const char *)Dtool_NodePath_find_net_python_tag_982_comment},
  {"list_tags", &Dtool_NodePath_list_tags_985, METH_NOARGS, (const char *)Dtool_NodePath_list_tags_985_comment},
  {"listTags", &Dtool_NodePath_list_tags_985, METH_NOARGS, (const char *)Dtool_NodePath_list_tags_985_comment},
  {"set_name", &Dtool_NodePath_set_name_986, METH_O, (const char *)Dtool_NodePath_set_name_986_comment},
  {"setName", &Dtool_NodePath_set_name_986, METH_O, (const char *)Dtool_NodePath_set_name_986_comment},
  {"get_name", &Dtool_NodePath_get_name_987, METH_NOARGS, (const char *)Dtool_NodePath_get_name_987_comment},
  {"getName", &Dtool_NodePath_get_name_987, METH_NOARGS, (const char *)Dtool_NodePath_get_name_987_comment},
  {"write_bam_file", &Dtool_NodePath_write_bam_file_989, METH_O, (const char *)Dtool_NodePath_write_bam_file_989_comment},
  {"writeBamFile", &Dtool_NodePath_write_bam_file_989, METH_O, (const char *)Dtool_NodePath_write_bam_file_989_comment},
  {"write_bam_stream", &Dtool_NodePath_write_bam_stream_990, METH_O, (const char *)Dtool_NodePath_write_bam_stream_990_comment},
  {"writeBamStream", &Dtool_NodePath_write_bam_stream_990, METH_O, (const char *)Dtool_NodePath_write_bam_stream_990_comment},
  {"encode_to_bam_stream", (PyCFunction) &Dtool_NodePath_encode_to_bam_stream_991, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_encode_to_bam_stream_991_comment},
  {"encodeToBamStream", (PyCFunction) &Dtool_NodePath_encode_to_bam_stream_991, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePath_encode_to_bam_stream_991_comment},
  {"decode_from_bam_stream", (PyCFunction) &Dtool_NodePath_decode_from_bam_stream_992, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_NodePath_decode_from_bam_stream_992_comment},
  {"decodeFromBamStream", (PyCFunction) &Dtool_NodePath_decode_from_bam_stream_992, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_NodePath_decode_from_bam_stream_992_comment},
  {"get_class_type", &Dtool_NodePath_get_class_type_993, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodePath_get_class_type_993_comment},
  {"getClassType", &Dtool_NodePath_get_class_type_993, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodePath_get_class_type_993_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_nodes", (PyCFunction) &MakeSeq_NodePath_get_nodes, METH_NOARGS, nullptr},
  { "getNodes", (PyCFunction) &MakeSeq_NodePath_get_nodes, METH_NOARGS, nullptr},
  {"get_ancestors", (PyCFunction) &MakeSeq_NodePath_get_ancestors, METH_NOARGS, nullptr},
  { "getAncestors", (PyCFunction) &MakeSeq_NodePath_get_ancestors, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// NodePath slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_NodePath_operator_typecast_bool_596_nb_bool(PyObject *self) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// NodePath slot tp_compare -> compare_to
//////////////////
static int Dtool_NodePath_compare_to_946_tp_compare(PyObject *self, PyObject *arg) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return -1;
  }

  {
    // -2 inline int NodePath::compare_to(NodePath const &other) const
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      int return_value = ((*(const NodePath*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return (int)(return_value > 0) - (int)(return_value < 0);
    }
  }

  {
    // -2 int NodePath::compare_to(WeakNodePath const &other) const
    WeakNodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_WeakNodePath);
    if (arg_this != nullptr) {
      int return_value = ((*(const NodePath*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return (int)(return_value > 0) - (int)(return_value < 0);
    }
  }

  // No coercion possible: inline int NodePath::compare_to(NodePath const &other) const
  // No coercion possible: int NodePath::compare_to(WeakNodePath const &other) const
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(NodePath self, const NodePath other)\n"
      "compare_to(NodePath self, const WeakNodePath other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// NodePath slot tp_hash -> get_key
//////////////////
static Py_hash_t Dtool_NodePath_get_key_611_tp_hash(PyObject *self) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_key)();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// NodePath slot tp_traverse -> __traverse__
//////////////////
static int Dtool_NodePath_traverse_984_tp_traverse(PyObject *self, visitproc visit, void *arg) {
  NodePath *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_NodePath, (void **) &local_this);
  if (local_this == nullptr) {
    return 0;
  }

  return invoke_extension(local_this).__traverse__(visit, arg);
}

//////////////////
//  A __repr__ function
//     NodePath
//////////////////
static PyObject *Dtool_Repr_NodePath(PyObject *self) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     NodePath
//////////////////
static PyObject *Dtool_RichCompare_NodePath(PyObject *self, PyObject *arg, int op) {
  NodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePath, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      {
        // -2 inline bool NodePath::operator ==(NodePath const &other) const
        NodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const NodePath*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 bool NodePath::operator ==(WeakNodePath const &other) const
        WeakNodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_WeakNodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const NodePath*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      // No coercion possible: inline bool NodePath::operator ==(NodePath const &other) const
      // No coercion possible: bool NodePath::operator ==(WeakNodePath const &other) const
      break;
    }
  case Py_NE:
    {
      {
        // -2 inline bool NodePath::operator !=(NodePath const &other) const
        NodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const NodePath*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 bool NodePath::operator !=(WeakNodePath const &other) const
        WeakNodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_WeakNodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const NodePath*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      // No coercion possible: inline bool NodePath::operator !=(NodePath const &other) const
      // No coercion possible: bool NodePath::operator !=(WeakNodePath const &other) const
      break;
    }
  case Py_LT:
    {
      {
        // -2 inline bool NodePath::operator <(NodePath const &other) const
        NodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const NodePath*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 bool NodePath::operator <(WeakNodePath const &other) const
        WeakNodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_WeakNodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const NodePath*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      // No coercion possible: inline bool NodePath::operator <(NodePath const &other) const
      // No coercion possible: bool NodePath::operator <(WeakNodePath const &other) const
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_NodePath_compare_to_946_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_NodePath[] = {
  {(char *)"nodes", &Dtool_NodePath_nodes_Getter, nullptr, nullptr, nullptr},
  {(char *)"ancestors", &Dtool_NodePath_ancestors_Getter, nullptr, nullptr, nullptr},
  {(char *)"error_type", &Dtool_NodePath_error_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"children", &Dtool_NodePath_children_Getter, nullptr, nullptr, nullptr},
  {(char *)"stashed_children", &Dtool_NodePath_stashed_children_Getter, nullptr, nullptr, nullptr},
  {(char *)"parent", &Dtool_NodePath_parent_Getter, nullptr, nullptr, nullptr},
  {(char *)"sort", &Dtool_NodePath_sort_Getter, nullptr, nullptr, nullptr},
  {(char *)"net_tags", &Dtool_NodePath_net_tags_Getter, nullptr, nullptr, nullptr},
  {(char *)"tags", &Dtool_NodePath_tags_Getter, nullptr, nullptr, nullptr},
  {(char *)"python_tags", &Dtool_NodePath_python_tags_Getter, nullptr, nullptr, nullptr},
  {(char *)"name", &Dtool_NodePath_name_Getter, &Dtool_NodePath_name_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_NodePath = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_NodePath_operator_typecast_bool_596_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_NodePath = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NodePath",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NodePath,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_NodePath_compare_to_946_tp_compare,
#endif
    &Dtool_Repr_NodePath,
    &Dtool_NumberMethods_NodePath,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &Dtool_NodePath_get_key_611_tp_hash,
    nullptr,
    &Dtool_Repr_NodePath,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * NodePath is the fundamental system for disambiguating instances, and also\n"
    " * provides a higher-level interface for manipulating the scene graph.\n"
    " *\n"
    " * A NodePath is a list of connected nodes from the root of the graph to any\n"
    " * sub-node.  Each NodePath therefore uniquely describes one instance of a\n"
    " * node.\n"
    " *\n"
    " * NodePaths themselves are lightweight objects that may easily be copied and\n"
    " * passed by value.  Their data is stored as a series of NodePathComponents\n"
    " * that are stored on the nodes.  Holding a NodePath will keep a reference\n"
    " * count to all the nodes in the path.  However, if any node in the path is\n"
    " * removed or reparented (perhaps through a different NodePath), the NodePath\n"
    " * will automatically be updated to reflect the changes.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_NodePath,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NodePath,
    nullptr, // tp_members
    Dtool_Properties_NodePath,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NodePath,
    PyType_GenericAlloc,
    Dtool_new_NodePath,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NodePath,
  Dtool_UpcastInterface_NodePath,
  Dtool_DowncastInterface_NodePath,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NodePath(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NodePath._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_NodePath._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum NodePath::ErrorType;
    PyDict_SetItemString(dict, "ET_ok", Dtool_WrapValue(NodePath::ET_ok));
    PyDict_SetItemString(dict, "ETOk", Dtool_WrapValue(NodePath::ET_ok));
    PyDict_SetItemString(dict, "ET_not_found", Dtool_WrapValue(NodePath::ET_not_found));
    PyDict_SetItemString(dict, "ETNotFound", Dtool_WrapValue(NodePath::ET_not_found));
    PyDict_SetItemString(dict, "ET_removed", Dtool_WrapValue(NodePath::ET_removed));
    PyDict_SetItemString(dict, "ETRemoved", Dtool_WrapValue(NodePath::ET_removed));
    PyDict_SetItemString(dict, "ET_fail", Dtool_WrapValue(NodePath::ET_fail));
    PyDict_SetItemString(dict, "ETFail", Dtool_WrapValue(NodePath::ET_fail));
    if (PyType_Ready((PyTypeObject *)&Dtool_NodePath) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NodePath)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NodePath);
  }
}

/**
 * Python method tables for NodePathCollection (NodePathCollection)
 */
static PyMethodDef Dtool_Methods_NodePathCollection[] = {
  {"__reduce__", &Dtool_NodePathCollection_reduce_623, METH_NOARGS, (const char *)Dtool_NodePathCollection_reduce_623_comment},
  {"add_path", &Dtool_NodePathCollection_add_path_624, METH_O, (const char *)Dtool_NodePathCollection_add_path_624_comment},
  {"addPath", &Dtool_NodePathCollection_add_path_624, METH_O, (const char *)Dtool_NodePathCollection_add_path_624_comment},
  {"remove_path", &Dtool_NodePathCollection_remove_path_625, METH_O, (const char *)Dtool_NodePathCollection_remove_path_625_comment},
  {"removePath", &Dtool_NodePathCollection_remove_path_625, METH_O, (const char *)Dtool_NodePathCollection_remove_path_625_comment},
  {"add_paths_from", &Dtool_NodePathCollection_add_paths_from_626, METH_O, (const char *)Dtool_NodePathCollection_add_paths_from_626_comment},
  {"addPathsFrom", &Dtool_NodePathCollection_add_paths_from_626, METH_O, (const char *)Dtool_NodePathCollection_add_paths_from_626_comment},
  {"remove_paths_from", &Dtool_NodePathCollection_remove_paths_from_627, METH_O, (const char *)Dtool_NodePathCollection_remove_paths_from_627_comment},
  {"removePathsFrom", &Dtool_NodePathCollection_remove_paths_from_627, METH_O, (const char *)Dtool_NodePathCollection_remove_paths_from_627_comment},
  {"remove_duplicate_paths", &Dtool_NodePathCollection_remove_duplicate_paths_628, METH_NOARGS, (const char *)Dtool_NodePathCollection_remove_duplicate_paths_628_comment},
  {"removeDuplicatePaths", &Dtool_NodePathCollection_remove_duplicate_paths_628, METH_NOARGS, (const char *)Dtool_NodePathCollection_remove_duplicate_paths_628_comment},
  {"has_path", &Dtool_NodePathCollection_has_path_629, METH_O, (const char *)Dtool_NodePathCollection_has_path_629_comment},
  {"hasPath", &Dtool_NodePathCollection_has_path_629, METH_O, (const char *)Dtool_NodePathCollection_has_path_629_comment},
  {"clear", &Dtool_NodePathCollection_clear_630, METH_NOARGS, (const char *)Dtool_NodePathCollection_clear_630_comment},
  {"reserve", &Dtool_NodePathCollection_reserve_631, METH_O, (const char *)Dtool_NodePathCollection_reserve_631_comment},
  {"is_empty", &Dtool_NodePathCollection_is_empty_632, METH_NOARGS, (const char *)Dtool_NodePathCollection_is_empty_632_comment},
  {"isEmpty", &Dtool_NodePathCollection_is_empty_632, METH_NOARGS, (const char *)Dtool_NodePathCollection_is_empty_632_comment},
  {"get_num_paths", &Dtool_NodePathCollection_get_num_paths_633, METH_NOARGS, (const char *)Dtool_NodePathCollection_get_num_paths_633_comment},
  {"getNumPaths", &Dtool_NodePathCollection_get_num_paths_633, METH_NOARGS, (const char *)Dtool_NodePathCollection_get_num_paths_633_comment},
  {"get_path", &Dtool_NodePathCollection_get_path_634, METH_O, (const char *)Dtool_NodePathCollection_get_path_634_comment},
  {"getPath", &Dtool_NodePathCollection_get_path_634, METH_O, (const char *)Dtool_NodePathCollection_get_path_634_comment},
  {"append", &Dtool_NodePathCollection_append_640, METH_O, (const char *)Dtool_NodePathCollection_append_640_comment},
  {"extend", &Dtool_NodePathCollection_extend_641, METH_O, (const char *)Dtool_NodePathCollection_extend_641_comment},
  {"ls", (PyCFunction) &Dtool_NodePathCollection_ls_642, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_ls_642_comment},
  {"find_all_matches", &Dtool_NodePathCollection_find_all_matches_643, METH_O, (const char *)Dtool_NodePathCollection_find_all_matches_643_comment},
  {"findAllMatches", &Dtool_NodePathCollection_find_all_matches_643, METH_O, (const char *)Dtool_NodePathCollection_find_all_matches_643_comment},
  {"reparent_to", &Dtool_NodePathCollection_reparent_to_644, METH_O, (const char *)Dtool_NodePathCollection_reparent_to_644_comment},
  {"reparentTo", &Dtool_NodePathCollection_reparent_to_644, METH_O, (const char *)Dtool_NodePathCollection_reparent_to_644_comment},
  {"wrt_reparent_to", &Dtool_NodePathCollection_wrt_reparent_to_645, METH_O, (const char *)Dtool_NodePathCollection_wrt_reparent_to_645_comment},
  {"wrtReparentTo", &Dtool_NodePathCollection_wrt_reparent_to_645, METH_O, (const char *)Dtool_NodePathCollection_wrt_reparent_to_645_comment},
  {"show", &Dtool_NodePathCollection_show_646, METH_NOARGS, (const char *)Dtool_NodePathCollection_show_646_comment},
  {"hide", &Dtool_NodePathCollection_hide_647, METH_NOARGS, (const char *)Dtool_NodePathCollection_hide_647_comment},
  {"stash", &Dtool_NodePathCollection_stash_648, METH_NOARGS, (const char *)Dtool_NodePathCollection_stash_648_comment},
  {"unstash", &Dtool_NodePathCollection_unstash_649, METH_NOARGS, (const char *)Dtool_NodePathCollection_unstash_649_comment},
  {"detach", &Dtool_NodePathCollection_detach_650, METH_NOARGS, (const char *)Dtool_NodePathCollection_detach_650_comment},
  {"get_collide_mask", &Dtool_NodePathCollection_get_collide_mask_651, METH_NOARGS, (const char *)Dtool_NodePathCollection_get_collide_mask_651_comment},
  {"getCollideMask", &Dtool_NodePathCollection_get_collide_mask_651, METH_NOARGS, (const char *)Dtool_NodePathCollection_get_collide_mask_651_comment},
  {"set_collide_mask", (PyCFunction) &Dtool_NodePathCollection_set_collide_mask_652, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_collide_mask_652_comment},
  {"setCollideMask", (PyCFunction) &Dtool_NodePathCollection_set_collide_mask_652, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_collide_mask_652_comment},
  {"calc_tight_bounds", (PyCFunction) &Dtool_NodePathCollection_calc_tight_bounds_653, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_calc_tight_bounds_653_comment},
  {"calcTightBounds", (PyCFunction) &Dtool_NodePathCollection_calc_tight_bounds_653, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_calc_tight_bounds_653_comment},
  {"get_tight_bounds", &Dtool_NodePathCollection_get_tight_bounds_654, METH_NOARGS, (const char *)Dtool_NodePathCollection_get_tight_bounds_654_comment},
  {"getTightBounds", &Dtool_NodePathCollection_get_tight_bounds_654, METH_NOARGS, (const char *)Dtool_NodePathCollection_get_tight_bounds_654_comment},
  {"set_texture", (PyCFunction) &Dtool_NodePathCollection_set_texture_655, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_texture_655_comment},
  {"setTexture", (PyCFunction) &Dtool_NodePathCollection_set_texture_655, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_texture_655_comment},
  {"set_texture_off", (PyCFunction) &Dtool_NodePathCollection_set_texture_off_656, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_texture_off_656_comment},
  {"setTextureOff", (PyCFunction) &Dtool_NodePathCollection_set_texture_off_656, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_texture_off_656_comment},
  {"set_color", (PyCFunction) &Dtool_NodePathCollection_set_color_657, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_color_657_comment},
  {"setColor", (PyCFunction) &Dtool_NodePathCollection_set_color_657, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_color_657_comment},
  {"set_color_scale", (PyCFunction) &Dtool_NodePathCollection_set_color_scale_658, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_color_scale_658_comment},
  {"setColorScale", (PyCFunction) &Dtool_NodePathCollection_set_color_scale_658, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_color_scale_658_comment},
  {"compose_color_scale", (PyCFunction) &Dtool_NodePathCollection_compose_color_scale_659, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_compose_color_scale_659_comment},
  {"composeColorScale", (PyCFunction) &Dtool_NodePathCollection_compose_color_scale_659, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_compose_color_scale_659_comment},
  {"set_attrib", (PyCFunction) &Dtool_NodePathCollection_set_attrib_660, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_attrib_660_comment},
  {"setAttrib", (PyCFunction) &Dtool_NodePathCollection_set_attrib_660, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_set_attrib_660_comment},
  {"output", &Dtool_NodePathCollection_output_661, METH_O, (const char *)Dtool_NodePathCollection_output_661_comment},
  {"write", (PyCFunction) &Dtool_NodePathCollection_write_662, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NodePathCollection_write_662_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_paths", (PyCFunction) &MakeSeq_NodePathCollection_get_paths, METH_NOARGS, nullptr},
  { "getPaths", (PyCFunction) &MakeSeq_NodePathCollection_get_paths, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// NodePathCollection slot nb_add -> operator +
//////////////////
static PyObject *Dtool_NodePathCollection_operator_639_nb_add(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_NodePathCollection, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline NodePathCollection NodePathCollection::operator +(NodePathCollection const &other) const
  NodePathCollection arg_local;
  NodePathCollection const *arg_this = Dtool_Coerce_NodePathCollection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NodePathCollection.__add__", "NodePathCollection");
  }
  NodePathCollection *return_value = new NodePathCollection(((*(const NodePathCollection*)local_this).operator +)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// NodePathCollection slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_NodePathCollection_operator_638_nb_inplace_add(PyObject *self, PyObject *arg) {
  NodePathCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_NodePathCollection, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void NodePathCollection::operator +=(NodePathCollection const &other)
  NodePathCollection arg_local;
  NodePathCollection const *arg_this = Dtool_Coerce_NodePathCollection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "NodePathCollection.__iadd__", "NodePathCollection");
    return nullptr;
  }
  ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// NodePathCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_NodePathCollection_operator_636_sq_item(PyObject *self, Py_ssize_t index) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePathCollection, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "NodePathCollection index out of range");
    return nullptr;
  }
  // 1-NodePath NodePathCollection::operator [](std::size_t index) const
  NodePath *return_value = new NodePath(((*(const NodePathCollection*)local_this).operator [])(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(NodePathCollection self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// NodePathCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_NodePathCollection_size_637_sq_length(PyObject *self) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePathCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     NodePathCollection
//////////////////
static PyObject *Dtool_Repr_NodePathCollection(PyObject *self) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePathCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     NodePathCollection
//////////////////
static PyObject *Dtool_Str_NodePathCollection(PyObject *self) {
  NodePathCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodePathCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_NodePathCollection = {
  &Dtool_NodePathCollection_operator_639_nb_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_NodePathCollection_operator_638_nb_inplace_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NodePathCollection = {
  &Dtool_NodePathCollection_size_637_sq_length,
  nullptr,
  nullptr,
  &Dtool_NodePathCollection_operator_636_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_NodePathCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NodePathCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NodePathCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_NodePathCollection,
    &Dtool_NumberMethods_NodePathCollection,
    &Dtool_SequenceMethods_NodePathCollection,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_NodePathCollection,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a set of zero or more NodePaths.  It's handy for returning from\n"
    " * functions that need to return multiple NodePaths (for instance,\n"
    " * NodePaths::get_children).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NodePathCollection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NodePathCollection,
    PyType_GenericAlloc,
    Dtool_new_NodePathCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NodePathCollection,
  Dtool_UpcastInterface_NodePathCollection,
  Dtool_DowncastInterface_NodePathCollection,
  nullptr,
  (CoerceFunction)Dtool_Coerce_NodePathCollection,
};

static void Dtool_PyModuleClassInit_NodePathCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NodePathCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NodePathCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NodePathCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NodePathCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NodePathCollection);
  }
}

/**
 * Python method tables for AttribNodeRegistry (AttribNodeRegistry)
 */
static PyMethodDef Dtool_Methods_AttribNodeRegistry[] = {
  {"add_node", &Dtool_AttribNodeRegistry_add_node_996, METH_O, (const char *)Dtool_AttribNodeRegistry_add_node_996_comment},
  {"addNode", &Dtool_AttribNodeRegistry_add_node_996, METH_O, (const char *)Dtool_AttribNodeRegistry_add_node_996_comment},
  {"remove_node", &Dtool_AttribNodeRegistry_remove_node_997, METH_O, (const char *)Dtool_AttribNodeRegistry_remove_node_997_comment},
  {"removeNode", &Dtool_AttribNodeRegistry_remove_node_997, METH_O, (const char *)Dtool_AttribNodeRegistry_remove_node_997_comment},
  {"lookup_node", &Dtool_AttribNodeRegistry_lookup_node_998, METH_O, (const char *)Dtool_AttribNodeRegistry_lookup_node_998_comment},
  {"lookupNode", &Dtool_AttribNodeRegistry_lookup_node_998, METH_O, (const char *)Dtool_AttribNodeRegistry_lookup_node_998_comment},
  {"get_num_nodes", &Dtool_AttribNodeRegistry_get_num_nodes_999, METH_NOARGS, (const char *)Dtool_AttribNodeRegistry_get_num_nodes_999_comment},
  {"getNumNodes", &Dtool_AttribNodeRegistry_get_num_nodes_999, METH_NOARGS, (const char *)Dtool_AttribNodeRegistry_get_num_nodes_999_comment},
  {"get_node", &Dtool_AttribNodeRegistry_get_node_1000, METH_O, (const char *)Dtool_AttribNodeRegistry_get_node_1000_comment},
  {"getNode", &Dtool_AttribNodeRegistry_get_node_1000, METH_O, (const char *)Dtool_AttribNodeRegistry_get_node_1000_comment},
  {"get_node_type", &Dtool_AttribNodeRegistry_get_node_type_1002, METH_O, (const char *)Dtool_AttribNodeRegistry_get_node_type_1002_comment},
  {"getNodeType", &Dtool_AttribNodeRegistry_get_node_type_1002, METH_O, (const char *)Dtool_AttribNodeRegistry_get_node_type_1002_comment},
  {"get_node_name", &Dtool_AttribNodeRegistry_get_node_name_1003, METH_O, (const char *)Dtool_AttribNodeRegistry_get_node_name_1003_comment},
  {"getNodeName", &Dtool_AttribNodeRegistry_get_node_name_1003, METH_O, (const char *)Dtool_AttribNodeRegistry_get_node_name_1003_comment},
  {"find_node", (PyCFunction) &Dtool_AttribNodeRegistry_find_node_1004, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AttribNodeRegistry_find_node_1004_comment},
  {"findNode", (PyCFunction) &Dtool_AttribNodeRegistry_find_node_1004, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AttribNodeRegistry_find_node_1004_comment},
  {"clear", &Dtool_AttribNodeRegistry_clear_1005, METH_NOARGS, (const char *)Dtool_AttribNodeRegistry_clear_1005_comment},
  {"output", &Dtool_AttribNodeRegistry_output_1006, METH_O, (const char *)Dtool_AttribNodeRegistry_output_1006_comment},
  {"write", &Dtool_AttribNodeRegistry_write_1007, METH_O, (const char *)Dtool_AttribNodeRegistry_write_1007_comment},
  {"get_global_ptr", &Dtool_AttribNodeRegistry_get_global_ptr_1008, METH_NOARGS | METH_STATIC, (const char *)Dtool_AttribNodeRegistry_get_global_ptr_1008_comment},
  {"getGlobalPtr", &Dtool_AttribNodeRegistry_get_global_ptr_1008, METH_NOARGS | METH_STATIC, (const char *)Dtool_AttribNodeRegistry_get_global_ptr_1008_comment},
  {"get_nodes", (PyCFunction) &MakeSeq_AttribNodeRegistry_get_nodes, METH_NOARGS, nullptr},
  { "getNodes", (PyCFunction) &MakeSeq_AttribNodeRegistry_get_nodes, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AttribNodeRegistry
//////////////////
static PyObject *Dtool_Repr_AttribNodeRegistry(PyObject *self) {
  AttribNodeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AttribNodeRegistry, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AttribNodeRegistry
//////////////////
static PyObject *Dtool_Str_AttribNodeRegistry(PyObject *self) {
  AttribNodeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AttribNodeRegistry, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AttribNodeRegistry = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_AttribNodeRegistry = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AttribNodeRegistry",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AttribNodeRegistry,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AttribNodeRegistry,
    &Dtool_NumberMethods_AttribNodeRegistry,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AttribNodeRegistry,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This global object records NodePaths that are referenced by scene graph\n"
    " * attribs, such as ClipPlaneAttribs and LightAttribs.\n"
    " *\n"
    " * Its primary purpose is to unify attribs that are loaded in from bam files.\n"
    " * Attrib nodes are identified by name and type; when a bam file that contains\n"
    " * references to some attrib nodes is loaded, those nodes are first looked up\n"
    " * here in the AttribNodeRegistry.  If there is a match (by name and node\n"
    " * type), the identified node is used instead of the node referenced within\n"
    " * the bam file itself.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AttribNodeRegistry,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AttribNodeRegistry,
    PyType_GenericAlloc,
    Dtool_new_AttribNodeRegistry,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AttribNodeRegistry,
  Dtool_UpcastInterface_AttribNodeRegistry,
  Dtool_DowncastInterface_AttribNodeRegistry,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AttribNodeRegistry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AttribNodeRegistry._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AttribNodeRegistry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AttribNodeRegistry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AttribNodeRegistry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AttribNodeRegistry);
  }
}

/**
 * Python method tables for AudioVolumeAttrib (AudioVolumeAttrib)
 */
static PyMethodDef Dtool_Methods_AudioVolumeAttrib[] = {
  {"make_identity", &Dtool_AudioVolumeAttrib_make_identity_1011, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioVolumeAttrib_make_identity_1011_comment},
  {"makeIdentity", &Dtool_AudioVolumeAttrib_make_identity_1011, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioVolumeAttrib_make_identity_1011_comment},
  {"make", &Dtool_AudioVolumeAttrib_make_1012, METH_O | METH_STATIC, (const char *)Dtool_AudioVolumeAttrib_make_1012_comment},
  {"make_off", &Dtool_AudioVolumeAttrib_make_off_1013, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioVolumeAttrib_make_off_1013_comment},
  {"makeOff", &Dtool_AudioVolumeAttrib_make_off_1013, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioVolumeAttrib_make_off_1013_comment},
  {"make_default", &Dtool_AudioVolumeAttrib_make_default_1014, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioVolumeAttrib_make_default_1014_comment},
  {"makeDefault", &Dtool_AudioVolumeAttrib_make_default_1014, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioVolumeAttrib_make_default_1014_comment},
  {"is_off", &Dtool_AudioVolumeAttrib_is_off_1015, METH_NOARGS, (const char *)Dtool_AudioVolumeAttrib_is_off_1015_comment},
  {"isOff", &Dtool_AudioVolumeAttrib_is_off_1015, METH_NOARGS, (const char *)Dtool_AudioVolumeAttrib_is_off_1015_comment},
  {"has_volume", &Dtool_AudioVolumeAttrib_has_volume_1016, METH_NOARGS, (const char *)Dtool_AudioVolumeAttrib_has_volume_1016_comment},
  {"hasVolume", &Dtool_AudioVolumeAttrib_has_volume_1016, METH_NOARGS, (const char *)Dtool_AudioVolumeAttrib_has_volume_1016_comment},
  {"get_volume", &Dtool_AudioVolumeAttrib_get_volume_1017, METH_NOARGS, (const char *)Dtool_AudioVolumeAttrib_get_volume_1017_comment},
  {"getVolume", &Dtool_AudioVolumeAttrib_get_volume_1017, METH_NOARGS, (const char *)Dtool_AudioVolumeAttrib_get_volume_1017_comment},
  {"set_volume", &Dtool_AudioVolumeAttrib_set_volume_1018, METH_O, (const char *)Dtool_AudioVolumeAttrib_set_volume_1018_comment},
  {"setVolume", &Dtool_AudioVolumeAttrib_set_volume_1018, METH_O, (const char *)Dtool_AudioVolumeAttrib_set_volume_1018_comment},
  {"get_class_slot", &Dtool_AudioVolumeAttrib_get_class_slot_1020, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioVolumeAttrib_get_class_slot_1020_comment},
  {"getClassSlot", &Dtool_AudioVolumeAttrib_get_class_slot_1020, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioVolumeAttrib_get_class_slot_1020_comment},
  {"get_class_type", &Dtool_AudioVolumeAttrib_get_class_type_1022, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioVolumeAttrib_get_class_type_1022_comment},
  {"getClassType", &Dtool_AudioVolumeAttrib_get_class_type_1022, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioVolumeAttrib_get_class_type_1022_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_AudioVolumeAttrib[] = {
  {(char *)"volume", &Dtool_AudioVolumeAttrib_volume_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AudioVolumeAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AudioVolumeAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AudioVolumeAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AudioVolumeAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AudioVolumeAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AudioVolumeAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AudioVolumeAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AudioVolumeAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AudioVolumeAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AudioVolumeAttrib,
    &Dtool_SequenceMethods_AudioVolumeAttrib,
    &Dtool_MappingMethods_AudioVolumeAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AudioVolumeAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Applies a scale to audio volume for positional sounds in the scene graph.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AudioVolumeAttrib,
    nullptr, // tp_members
    Dtool_Properties_AudioVolumeAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AudioVolumeAttrib,
    PyType_GenericAlloc,
    Dtool_new_AudioVolumeAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AudioVolumeAttrib,
  Dtool_UpcastInterface_AudioVolumeAttrib,
  Dtool_DowncastInterface_AudioVolumeAttrib,
  (CoerceFunction)Dtool_ConstCoerce_AudioVolumeAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_AudioVolumeAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_AudioVolumeAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_AudioVolumeAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AudioVolumeAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_AudioVolumeAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_AudioVolumeAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_AudioVolumeAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AudioVolumeAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AudioVolumeAttrib);
  }
}

/**
 * Python method tables for AuxBitplaneAttrib (AuxBitplaneAttrib)
 */
static PyMethodDef Dtool_Methods_AuxBitplaneAttrib[] = {
  {"make", &Dtool_AuxBitplaneAttrib_make_1026, METH_VARARGS | METH_STATIC, (const char *)Dtool_AuxBitplaneAttrib_make_1026_comment},
  {"make_default", &Dtool_AuxBitplaneAttrib_make_default_1027, METH_NOARGS | METH_STATIC, (const char *)Dtool_AuxBitplaneAttrib_make_default_1027_comment},
  {"makeDefault", &Dtool_AuxBitplaneAttrib_make_default_1027, METH_NOARGS | METH_STATIC, (const char *)Dtool_AuxBitplaneAttrib_make_default_1027_comment},
  {"get_outputs", &Dtool_AuxBitplaneAttrib_get_outputs_1028, METH_NOARGS, (const char *)Dtool_AuxBitplaneAttrib_get_outputs_1028_comment},
  {"getOutputs", &Dtool_AuxBitplaneAttrib_get_outputs_1028, METH_NOARGS, (const char *)Dtool_AuxBitplaneAttrib_get_outputs_1028_comment},
  {"get_class_slot", &Dtool_AuxBitplaneAttrib_get_class_slot_1030, METH_NOARGS | METH_STATIC, (const char *)Dtool_AuxBitplaneAttrib_get_class_slot_1030_comment},
  {"getClassSlot", &Dtool_AuxBitplaneAttrib_get_class_slot_1030, METH_NOARGS | METH_STATIC, (const char *)Dtool_AuxBitplaneAttrib_get_class_slot_1030_comment},
  {"get_class_type", &Dtool_AuxBitplaneAttrib_get_class_type_1032, METH_NOARGS | METH_STATIC, (const char *)Dtool_AuxBitplaneAttrib_get_class_type_1032_comment},
  {"getClassType", &Dtool_AuxBitplaneAttrib_get_class_type_1032, METH_NOARGS | METH_STATIC, (const char *)Dtool_AuxBitplaneAttrib_get_class_type_1032_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_AuxBitplaneAttrib[] = {
  {(char *)"outputs", &Dtool_AuxBitplaneAttrib_outputs_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AuxBitplaneAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AuxBitplaneAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AuxBitplaneAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AuxBitplaneAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AuxBitplaneAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AuxBitplaneAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AuxBitplaneAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AuxBitplaneAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AuxBitplaneAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AuxBitplaneAttrib,
    &Dtool_SequenceMethods_AuxBitplaneAttrib,
    &Dtool_MappingMethods_AuxBitplaneAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AuxBitplaneAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Modern frame buffers can have 'aux' bitplanes, which are additional\n"
    " * bitplanes above and beyond the standard depth and color.  This attrib\n"
    " * controls what gets rendered into those additional bitplanes.  It can also\n"
    " * affect what goes into the alpha channel of the primary color buffer.\n"
    " *\n"
    " * ABO_glow: copy the glow map into the alpha channel of the primary frame\n"
    " * buffer.  If there is no glow map, set it to zero.  Caveat: it is not\n"
    " * possible to write glow or depth values to the framebuffer alpha channel at\n"
    " * the same time as using alpha blending or alpha testing.  Any attempt to use\n"
    " * transparency, blending, or alpha testing will cause this flag to be\n"
    " * overridden.\n"
    " *\n"
    " * ABO_aux_normal: put the camera-space normal into the into the R,G\n"
    " * components of the first auxiliary bitplane.\n"
    " *\n"
    " * ABO_aux_modelz: put the clip-space Z coordinate of the center of the model\n"
    " * (after perspective divide) into the B channel of the first auxiliary\n"
    " * bitplane.\n"
    " *\n"
    " * ABO_aux_glow: put a copy of the glow map into the alpha channel of the\n"
    " * first auxiliary bitplane.  If there is no glow map, set it to zero.\n"
    " *\n"
    " * AuxBitplaneAttrib is relevant only when shader generation is enabled.\n"
    " * Otherwise, it has no effect.\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AuxBitplaneAttrib,
    nullptr, // tp_members
    Dtool_Properties_AuxBitplaneAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AuxBitplaneAttrib,
    PyType_GenericAlloc,
    Dtool_new_AuxBitplaneAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AuxBitplaneAttrib,
  Dtool_UpcastInterface_AuxBitplaneAttrib,
  Dtool_DowncastInterface_AuxBitplaneAttrib,
  (CoerceFunction)Dtool_ConstCoerce_AuxBitplaneAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_AuxBitplaneAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_AuxBitplaneAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_AuxBitplaneAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_AuxBitplaneAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum AuxBitplaneAttrib::AuxBitplaneOutput;
    PyDict_SetItemString(dict, "ABO_glow", Dtool_WrapValue(AuxBitplaneAttrib::ABO_glow));
    PyDict_SetItemString(dict, "ABOGlow", Dtool_WrapValue(AuxBitplaneAttrib::ABO_glow));
    PyDict_SetItemString(dict, "ABO_aux_normal", Dtool_WrapValue(AuxBitplaneAttrib::ABO_aux_normal));
    PyDict_SetItemString(dict, "ABOAuxNormal", Dtool_WrapValue(AuxBitplaneAttrib::ABO_aux_normal));
    PyDict_SetItemString(dict, "ABO_aux_glow", Dtool_WrapValue(AuxBitplaneAttrib::ABO_aux_glow));
    PyDict_SetItemString(dict, "ABOAuxGlow", Dtool_WrapValue(AuxBitplaneAttrib::ABO_aux_glow));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_AuxBitplaneAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_AuxBitplaneAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_AuxBitplaneAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AuxBitplaneAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AuxBitplaneAttrib);
  }
}

/**
 * Python method tables for AuxSceneData (AuxSceneData)
 */
static PyMethodDef Dtool_Methods_AuxSceneData[] = {
  {"set_duration", &Dtool_AuxSceneData_set_duration_1036, METH_O, (const char *)Dtool_AuxSceneData_set_duration_1036_comment},
  {"setDuration", &Dtool_AuxSceneData_set_duration_1036, METH_O, (const char *)Dtool_AuxSceneData_set_duration_1036_comment},
  {"get_duration", &Dtool_AuxSceneData_get_duration_1037, METH_NOARGS, (const char *)Dtool_AuxSceneData_get_duration_1037_comment},
  {"getDuration", &Dtool_AuxSceneData_get_duration_1037, METH_NOARGS, (const char *)Dtool_AuxSceneData_get_duration_1037_comment},
  {"set_last_render_time", &Dtool_AuxSceneData_set_last_render_time_1038, METH_O, (const char *)Dtool_AuxSceneData_set_last_render_time_1038_comment},
  {"setLastRenderTime", &Dtool_AuxSceneData_set_last_render_time_1038, METH_O, (const char *)Dtool_AuxSceneData_set_last_render_time_1038_comment},
  {"get_last_render_time", &Dtool_AuxSceneData_get_last_render_time_1039, METH_NOARGS, (const char *)Dtool_AuxSceneData_get_last_render_time_1039_comment},
  {"getLastRenderTime", &Dtool_AuxSceneData_get_last_render_time_1039, METH_NOARGS, (const char *)Dtool_AuxSceneData_get_last_render_time_1039_comment},
  {"get_expiration_time", &Dtool_AuxSceneData_get_expiration_time_1040, METH_NOARGS, (const char *)Dtool_AuxSceneData_get_expiration_time_1040_comment},
  {"getExpirationTime", &Dtool_AuxSceneData_get_expiration_time_1040, METH_NOARGS, (const char *)Dtool_AuxSceneData_get_expiration_time_1040_comment},
  {"output", &Dtool_AuxSceneData_output_1041, METH_O, (const char *)Dtool_AuxSceneData_output_1041_comment},
  {"write", (PyCFunction) &Dtool_AuxSceneData_write_1042, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AuxSceneData_write_1042_comment},
  {"get_class_type", &Dtool_AuxSceneData_get_class_type_1043, METH_NOARGS | METH_STATIC, (const char *)Dtool_AuxSceneData_get_class_type_1043_comment},
  {"getClassType", &Dtool_AuxSceneData_get_class_type_1043, METH_NOARGS | METH_STATIC, (const char *)Dtool_AuxSceneData_get_class_type_1043_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AuxSceneData
//////////////////
static PyObject *Dtool_Repr_AuxSceneData(PyObject *self) {
  AuxSceneData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AuxSceneData, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AuxSceneData
//////////////////
static PyObject *Dtool_Str_AuxSceneData(PyObject *self) {
  AuxSceneData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AuxSceneData, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AuxSceneData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AuxSceneData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AuxSceneData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AuxSceneData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AuxSceneData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AuxSceneData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AuxSceneData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AuxSceneData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AuxSceneData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AuxSceneData,
    &Dtool_NumberMethods_AuxSceneData,
    &Dtool_SequenceMethods_AuxSceneData,
    &Dtool_MappingMethods_AuxSceneData,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AuxSceneData,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AuxSceneData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a base class for a generic data structure that can be attached per-\n"
    " * instance to the camera, to store per-instance data that must be preserved\n"
    " * over multiple frames.\n"
    " *\n"
    " * In particular, this is used to implement the FadeLODNode, which must\n"
    " * remember during traversal at what point it is in the fade, separately for\n"
    " * each instance and for each camera.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AuxSceneData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AuxSceneData,
    PyType_GenericAlloc,
    Dtool_new_AuxSceneData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AuxSceneData,
  Dtool_UpcastInterface_AuxSceneData,
  Dtool_DowncastInterface_AuxSceneData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AuxSceneData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_AuxSceneData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_AuxSceneData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AuxSceneData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AuxSceneData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AuxSceneData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AuxSceneData);
  }
}

/**
 * Python method tables for BamFile (BamFile)
 */
static PyMethodDef Dtool_Methods_BamFile[] = {
  {"open_read", (PyCFunction) &Dtool_BamFile_open_read_1050, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamFile_open_read_1050_comment},
  {"openRead", (PyCFunction) &Dtool_BamFile_open_read_1050, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamFile_open_read_1050_comment},
  {"read_object", &Dtool_BamFile_read_object_1051, METH_NOARGS, (const char *)Dtool_BamFile_read_object_1051_comment},
  {"readObject", &Dtool_BamFile_read_object_1051, METH_NOARGS, (const char *)Dtool_BamFile_read_object_1051_comment},
  {"is_eof", &Dtool_BamFile_is_eof_1052, METH_NOARGS, (const char *)Dtool_BamFile_is_eof_1052_comment},
  {"isEof", &Dtool_BamFile_is_eof_1052, METH_NOARGS, (const char *)Dtool_BamFile_is_eof_1052_comment},
  {"resolve", &Dtool_BamFile_resolve_1053, METH_NOARGS, (const char *)Dtool_BamFile_resolve_1053_comment},
  {"read_node", (PyCFunction) &Dtool_BamFile_read_node_1054, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamFile_read_node_1054_comment},
  {"readNode", (PyCFunction) &Dtool_BamFile_read_node_1054, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamFile_read_node_1054_comment},
  {"open_write", (PyCFunction) &Dtool_BamFile_open_write_1055, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamFile_open_write_1055_comment},
  {"openWrite", (PyCFunction) &Dtool_BamFile_open_write_1055, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamFile_open_write_1055_comment},
  {"write_object", &Dtool_BamFile_write_object_1056, METH_O, (const char *)Dtool_BamFile_write_object_1056_comment},
  {"writeObject", &Dtool_BamFile_write_object_1056, METH_O, (const char *)Dtool_BamFile_write_object_1056_comment},
  {"close", &Dtool_BamFile_close_1057, METH_NOARGS, (const char *)Dtool_BamFile_close_1057_comment},
  {"is_valid_read", &Dtool_BamFile_is_valid_read_1058, METH_NOARGS, (const char *)Dtool_BamFile_is_valid_read_1058_comment},
  {"isValidRead", &Dtool_BamFile_is_valid_read_1058, METH_NOARGS, (const char *)Dtool_BamFile_is_valid_read_1058_comment},
  {"is_valid_write", &Dtool_BamFile_is_valid_write_1059, METH_NOARGS, (const char *)Dtool_BamFile_is_valid_write_1059_comment},
  {"isValidWrite", &Dtool_BamFile_is_valid_write_1059, METH_NOARGS, (const char *)Dtool_BamFile_is_valid_write_1059_comment},
  {"get_file_major_ver", &Dtool_BamFile_get_file_major_ver_1060, METH_NOARGS, (const char *)Dtool_BamFile_get_file_major_ver_1060_comment},
  {"getFileMajorVer", &Dtool_BamFile_get_file_major_ver_1060, METH_NOARGS, (const char *)Dtool_BamFile_get_file_major_ver_1060_comment},
  {"get_file_minor_ver", &Dtool_BamFile_get_file_minor_ver_1061, METH_NOARGS, (const char *)Dtool_BamFile_get_file_minor_ver_1061_comment},
  {"getFileMinorVer", &Dtool_BamFile_get_file_minor_ver_1061, METH_NOARGS, (const char *)Dtool_BamFile_get_file_minor_ver_1061_comment},
  {"get_file_endian", &Dtool_BamFile_get_file_endian_1062, METH_NOARGS, (const char *)Dtool_BamFile_get_file_endian_1062_comment},
  {"getFileEndian", &Dtool_BamFile_get_file_endian_1062, METH_NOARGS, (const char *)Dtool_BamFile_get_file_endian_1062_comment},
  {"get_file_stdfloat_double", &Dtool_BamFile_get_file_stdfloat_double_1063, METH_NOARGS, (const char *)Dtool_BamFile_get_file_stdfloat_double_1063_comment},
  {"getFileStdfloatDouble", &Dtool_BamFile_get_file_stdfloat_double_1063, METH_NOARGS, (const char *)Dtool_BamFile_get_file_stdfloat_double_1063_comment},
  {"get_current_major_ver", &Dtool_BamFile_get_current_major_ver_1064, METH_NOARGS, (const char *)Dtool_BamFile_get_current_major_ver_1064_comment},
  {"getCurrentMajorVer", &Dtool_BamFile_get_current_major_ver_1064, METH_NOARGS, (const char *)Dtool_BamFile_get_current_major_ver_1064_comment},
  {"get_current_minor_ver", &Dtool_BamFile_get_current_minor_ver_1065, METH_NOARGS, (const char *)Dtool_BamFile_get_current_minor_ver_1065_comment},
  {"getCurrentMinorVer", &Dtool_BamFile_get_current_minor_ver_1065, METH_NOARGS, (const char *)Dtool_BamFile_get_current_minor_ver_1065_comment},
  {"get_reader", &Dtool_BamFile_get_reader_1066, METH_NOARGS, (const char *)Dtool_BamFile_get_reader_1066_comment},
  {"getReader", &Dtool_BamFile_get_reader_1066, METH_NOARGS, (const char *)Dtool_BamFile_get_reader_1066_comment},
  {"get_writer", &Dtool_BamFile_get_writer_1067, METH_NOARGS, (const char *)Dtool_BamFile_get_writer_1067_comment},
  {"getWriter", &Dtool_BamFile_get_writer_1067, METH_NOARGS, (const char *)Dtool_BamFile_get_writer_1067_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_BamFile[] = {
  {(char *)"file_endian", &Dtool_BamFile_file_endian_Getter, nullptr, nullptr, nullptr},
  {(char *)"file_stdfloat_double", &Dtool_BamFile_file_stdfloat_double_Getter, nullptr, nullptr, nullptr},
  {(char *)"reader", &Dtool_BamFile_reader_Getter, nullptr, nullptr, nullptr},
  {(char *)"writer", &Dtool_BamFile_writer_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_BamFile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BamFile = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BamFile = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BamFile = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BamFile = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BamFile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BamFile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BamFile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BamFile,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BamFile,
    &Dtool_SequenceMethods_BamFile,
    &Dtool_MappingMethods_BamFile,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BamFile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The principle public interface to reading and writing Bam disk files.  See\n"
    " * also BamReader and BamWriter, the more general implementation of this\n"
    " * class.\n"
    " *\n"
    " * Bam files are most often used to store scene graphs or subgraphs, and by\n"
    " * convention they are given filenames ending in the extension \".bam\" when\n"
    " * they are used for this purpose.  However, a Bam file may store any\n"
    " * arbitrary list of TypedWritable objects; in this more general usage, they\n"
    " * are given filenames ending in \".boo\" to differentiate them from the more\n"
    " * common scene graph files.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BamFile,
    nullptr, // tp_members
    Dtool_Properties_BamFile,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BamFile,
    PyType_GenericAlloc,
    Dtool_new_BamFile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BamFile,
  Dtool_UpcastInterface_BamFile,
  Dtool_DowncastInterface_BamFile,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BamFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_BamEnums != nullptr);
    assert(Dtool_Ptr_BamEnums->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_BamEnums->_Dtool_ModuleClassInit(nullptr);
    Dtool_BamFile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_BamEnums);
    Dtool_BamFile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BamFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BamFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BamFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BamFile);
  }
}

/**
 * Python method tables for BillboardEffect (BillboardEffect)
 */
static PyMethodDef Dtool_Methods_BillboardEffect[] = {
  {"make", (PyCFunction) &Dtool_BillboardEffect_make_1078, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BillboardEffect_make_1078_comment},
  {"make_axis", &Dtool_BillboardEffect_make_axis_1079, METH_NOARGS | METH_STATIC, (const char *)Dtool_BillboardEffect_make_axis_1079_comment},
  {"makeAxis", &Dtool_BillboardEffect_make_axis_1079, METH_NOARGS | METH_STATIC, (const char *)Dtool_BillboardEffect_make_axis_1079_comment},
  {"make_point_eye", &Dtool_BillboardEffect_make_point_eye_1080, METH_NOARGS | METH_STATIC, (const char *)Dtool_BillboardEffect_make_point_eye_1080_comment},
  {"makePointEye", &Dtool_BillboardEffect_make_point_eye_1080, METH_NOARGS | METH_STATIC, (const char *)Dtool_BillboardEffect_make_point_eye_1080_comment},
  {"make_point_world", &Dtool_BillboardEffect_make_point_world_1081, METH_NOARGS | METH_STATIC, (const char *)Dtool_BillboardEffect_make_point_world_1081_comment},
  {"makePointWorld", &Dtool_BillboardEffect_make_point_world_1081, METH_NOARGS | METH_STATIC, (const char *)Dtool_BillboardEffect_make_point_world_1081_comment},
  {"is_off", &Dtool_BillboardEffect_is_off_1082, METH_NOARGS, (const char *)Dtool_BillboardEffect_is_off_1082_comment},
  {"isOff", &Dtool_BillboardEffect_is_off_1082, METH_NOARGS, (const char *)Dtool_BillboardEffect_is_off_1082_comment},
  {"get_up_vector", &Dtool_BillboardEffect_get_up_vector_1083, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_up_vector_1083_comment},
  {"getUpVector", &Dtool_BillboardEffect_get_up_vector_1083, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_up_vector_1083_comment},
  {"get_eye_relative", &Dtool_BillboardEffect_get_eye_relative_1084, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_eye_relative_1084_comment},
  {"getEyeRelative", &Dtool_BillboardEffect_get_eye_relative_1084, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_eye_relative_1084_comment},
  {"get_axial_rotate", &Dtool_BillboardEffect_get_axial_rotate_1085, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_axial_rotate_1085_comment},
  {"getAxialRotate", &Dtool_BillboardEffect_get_axial_rotate_1085, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_axial_rotate_1085_comment},
  {"get_fixed_depth", &Dtool_BillboardEffect_get_fixed_depth_1086, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_fixed_depth_1086_comment},
  {"getFixedDepth", &Dtool_BillboardEffect_get_fixed_depth_1086, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_fixed_depth_1086_comment},
  {"get_offset", &Dtool_BillboardEffect_get_offset_1087, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_offset_1087_comment},
  {"getOffset", &Dtool_BillboardEffect_get_offset_1087, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_offset_1087_comment},
  {"get_look_at", &Dtool_BillboardEffect_get_look_at_1088, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_look_at_1088_comment},
  {"getLookAt", &Dtool_BillboardEffect_get_look_at_1088, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_look_at_1088_comment},
  {"get_look_at_point", &Dtool_BillboardEffect_get_look_at_point_1089, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_look_at_point_1089_comment},
  {"getLookAtPoint", &Dtool_BillboardEffect_get_look_at_point_1089, METH_NOARGS, (const char *)Dtool_BillboardEffect_get_look_at_point_1089_comment},
  {"get_class_type", &Dtool_BillboardEffect_get_class_type_1090, METH_NOARGS | METH_STATIC, (const char *)Dtool_BillboardEffect_get_class_type_1090_comment},
  {"getClassType", &Dtool_BillboardEffect_get_class_type_1090, METH_NOARGS | METH_STATIC, (const char *)Dtool_BillboardEffect_get_class_type_1090_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BillboardEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BillboardEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BillboardEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BillboardEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BillboardEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BillboardEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BillboardEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BillboardEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BillboardEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BillboardEffect,
    &Dtool_SequenceMethods_BillboardEffect,
    &Dtool_MappingMethods_BillboardEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BillboardEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Indicates that geometry at this node should automatically rotate to face\n"
    " * the camera, or any other arbitrary node.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BillboardEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BillboardEffect,
    PyType_GenericAlloc,
    Dtool_new_BillboardEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BillboardEffect,
  Dtool_UpcastInterface_BillboardEffect,
  Dtool_DowncastInterface_BillboardEffect,
  (CoerceFunction)Dtool_ConstCoerce_BillboardEffect,
  nullptr,
};

static void Dtool_PyModuleClassInit_BillboardEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderEffect(nullptr);
    Dtool_BillboardEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderEffect);
    Dtool_BillboardEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BillboardEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BillboardEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BillboardEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BillboardEffect);
  }
}

/**
 * Python method tables for LensNode (LensNode)
 */
static PyMethodDef Dtool_Methods_LensNode[] = {
  {"copy_lens", (PyCFunction) &Dtool_LensNode_copy_lens_1094, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LensNode_copy_lens_1094_comment},
  {"copyLens", (PyCFunction) &Dtool_LensNode_copy_lens_1094, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LensNode_copy_lens_1094_comment},
  {"set_lens", (PyCFunction) &Dtool_LensNode_set_lens_1095, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LensNode_set_lens_1095_comment},
  {"setLens", (PyCFunction) &Dtool_LensNode_set_lens_1095, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LensNode_set_lens_1095_comment},
  {"get_lens", (PyCFunction) &Dtool_LensNode_get_lens_1096, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LensNode_get_lens_1096_comment},
  {"getLens", (PyCFunction) &Dtool_LensNode_get_lens_1096, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LensNode_get_lens_1096_comment},
  {"set_lens_active", (PyCFunction) &Dtool_LensNode_set_lens_active_1097, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LensNode_set_lens_active_1097_comment},
  {"setLensActive", (PyCFunction) &Dtool_LensNode_set_lens_active_1097, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LensNode_set_lens_active_1097_comment},
  {"get_lens_active", &Dtool_LensNode_get_lens_active_1098, METH_O, (const char *)Dtool_LensNode_get_lens_active_1098_comment},
  {"getLensActive", &Dtool_LensNode_get_lens_active_1098, METH_O, (const char *)Dtool_LensNode_get_lens_active_1098_comment},
  {"activate_lens", &Dtool_LensNode_activate_lens_1099, METH_O, (const char *)Dtool_LensNode_activate_lens_1099_comment},
  {"activateLens", &Dtool_LensNode_activate_lens_1099, METH_O, (const char *)Dtool_LensNode_activate_lens_1099_comment},
  {"deactivate_lens", &Dtool_LensNode_deactivate_lens_1100, METH_O, (const char *)Dtool_LensNode_deactivate_lens_1100_comment},
  {"deactivateLens", &Dtool_LensNode_deactivate_lens_1100, METH_O, (const char *)Dtool_LensNode_deactivate_lens_1100_comment},
  {"is_in_view", (PyCFunction) &Dtool_LensNode_is_in_view_1101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LensNode_is_in_view_1101_comment},
  {"isInView", (PyCFunction) &Dtool_LensNode_is_in_view_1101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LensNode_is_in_view_1101_comment},
  {"show_frustum", &Dtool_LensNode_show_frustum_1102, METH_NOARGS, (const char *)Dtool_LensNode_show_frustum_1102_comment},
  {"showFrustum", &Dtool_LensNode_show_frustum_1102, METH_NOARGS, (const char *)Dtool_LensNode_show_frustum_1102_comment},
  {"hide_frustum", &Dtool_LensNode_hide_frustum_1103, METH_NOARGS, (const char *)Dtool_LensNode_hide_frustum_1103_comment},
  {"hideFrustum", &Dtool_LensNode_hide_frustum_1103, METH_NOARGS, (const char *)Dtool_LensNode_hide_frustum_1103_comment},
  {"get_class_type", &Dtool_LensNode_get_class_type_1104, METH_NOARGS | METH_STATIC, (const char *)Dtool_LensNode_get_class_type_1104_comment},
  {"getClassType", &Dtool_LensNode_get_class_type_1104, METH_NOARGS | METH_STATIC, (const char *)Dtool_LensNode_get_class_type_1104_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LensNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LensNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LensNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LensNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LensNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LensNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LensNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LensNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LensNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LensNode,
    &Dtool_SequenceMethods_LensNode,
    &Dtool_MappingMethods_LensNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LensNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node that contains a Lens.  The most important example of this kind of\n"
    " * node is a Camera, but other kinds of nodes also contain a lens (for\n"
    " * instance, a Spotlight).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LensNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LensNode,
    PyType_GenericAlloc,
    Dtool_new_LensNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LensNode,
  Dtool_UpcastInterface_LensNode,
  Dtool_DowncastInterface_LensNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LensNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PandaNode(nullptr);
    Dtool_LensNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PandaNode);
    Dtool_LensNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LensNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LensNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LensNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LensNode);
  }
}

/**
 * Python method tables for WeakNodePath (WeakNodePath)
 */
static PyMethodDef Dtool_Methods_WeakNodePath[] = {
  {"assign", &Dtool_WeakNodePath_operator_1109, METH_O, (const char *)Dtool_WeakNodePath_operator_1109_comment},
  {"clear", &Dtool_WeakNodePath_clear_1110, METH_NOARGS, (const char *)Dtool_WeakNodePath_clear_1110_comment},
  {"is_empty", &Dtool_WeakNodePath_is_empty_1112, METH_NOARGS, (const char *)Dtool_WeakNodePath_is_empty_1112_comment},
  {"isEmpty", &Dtool_WeakNodePath_is_empty_1112, METH_NOARGS, (const char *)Dtool_WeakNodePath_is_empty_1112_comment},
  {"was_deleted", &Dtool_WeakNodePath_was_deleted_1113, METH_NOARGS, (const char *)Dtool_WeakNodePath_was_deleted_1113_comment},
  {"wasDeleted", &Dtool_WeakNodePath_was_deleted_1113, METH_NOARGS, (const char *)Dtool_WeakNodePath_was_deleted_1113_comment},
  {"get_node_path", &Dtool_WeakNodePath_get_node_path_1114, METH_NOARGS, (const char *)Dtool_WeakNodePath_get_node_path_1114_comment},
  {"getNodePath", &Dtool_WeakNodePath_get_node_path_1114, METH_NOARGS, (const char *)Dtool_WeakNodePath_get_node_path_1114_comment},
  {"node", &Dtool_WeakNodePath_node_1115, METH_NOARGS, (const char *)Dtool_WeakNodePath_node_1115_comment},
  {"compare_to", &Dtool_WeakNodePath_compare_to_1119, METH_O, (const char *)Dtool_WeakNodePath_compare_to_1119_comment},
  {"compareTo", &Dtool_WeakNodePath_compare_to_1119, METH_O, (const char *)Dtool_WeakNodePath_compare_to_1119_comment},
  {"get_key", &Dtool_WeakNodePath_get_key_1120, METH_NOARGS, (const char *)Dtool_WeakNodePath_get_key_1120_comment},
  {"getKey", &Dtool_WeakNodePath_get_key_1120, METH_NOARGS, (const char *)Dtool_WeakNodePath_get_key_1120_comment},
  {"output", &Dtool_WeakNodePath_output_1121, METH_O, (const char *)Dtool_WeakNodePath_output_1121_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// WeakNodePath slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_WeakNodePath_operator_typecast_bool_1111_nb_bool(PyObject *self) {
  WeakNodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WeakNodePath, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// WeakNodePath slot tp_compare -> compare_to
//////////////////
static int Dtool_WeakNodePath_compare_to_1119_tp_compare(PyObject *self, PyObject *arg) {
  WeakNodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WeakNodePath, (void **)&local_this)) {
    return -1;
  }

  {
    // -2 inline int WeakNodePath::compare_to(NodePath const &other) const
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      int return_value = ((*(const WeakNodePath*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return (int)(return_value > 0) - (int)(return_value < 0);
    }
  }

  {
    // -2 inline int WeakNodePath::compare_to(WeakNodePath const &other) const
    WeakNodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_WeakNodePath);
    if (arg_this != nullptr) {
      int return_value = ((*(const WeakNodePath*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return (int)(return_value > 0) - (int)(return_value < 0);
    }
  }

  // No coercion possible: inline int WeakNodePath::compare_to(NodePath const &other) const
  // No coercion possible: inline int WeakNodePath::compare_to(WeakNodePath const &other) const
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(WeakNodePath self, const NodePath other)\n"
      "compare_to(WeakNodePath self, const WeakNodePath other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// WeakNodePath slot tp_hash -> get_key
//////////////////
static Py_hash_t Dtool_WeakNodePath_get_key_1120_tp_hash(PyObject *self) {
  WeakNodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WeakNodePath, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_key)();
}

//////////////////
//  A __repr__ function
//     WeakNodePath
//////////////////
static PyObject *Dtool_Repr_WeakNodePath(PyObject *self) {
  WeakNodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WeakNodePath, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     WeakNodePath
//////////////////
static PyObject *Dtool_RichCompare_WeakNodePath(PyObject *self, PyObject *arg, int op) {
  WeakNodePath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WeakNodePath, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      {
        // -2 inline bool WeakNodePath::operator ==(NodePath const &other) const
        NodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const WeakNodePath*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline bool WeakNodePath::operator ==(WeakNodePath const &other) const
        WeakNodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_WeakNodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const WeakNodePath*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      // No coercion possible: inline bool WeakNodePath::operator ==(NodePath const &other) const
      // No coercion possible: inline bool WeakNodePath::operator ==(WeakNodePath const &other) const
      break;
    }
  case Py_NE:
    {
      {
        // -2 inline bool WeakNodePath::operator !=(NodePath const &other) const
        NodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const WeakNodePath*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline bool WeakNodePath::operator !=(WeakNodePath const &other) const
        WeakNodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_WeakNodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const WeakNodePath*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      // No coercion possible: inline bool WeakNodePath::operator !=(NodePath const &other) const
      // No coercion possible: inline bool WeakNodePath::operator !=(WeakNodePath const &other) const
      break;
    }
  case Py_LT:
    {
      {
        // -2 inline bool WeakNodePath::operator <(NodePath const &other) const
        NodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const WeakNodePath*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline bool WeakNodePath::operator <(WeakNodePath const &other) const
        WeakNodePath const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_WeakNodePath);
        if (arg_this != nullptr) {
          bool return_value = ((*(const WeakNodePath*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }

      // No coercion possible: inline bool WeakNodePath::operator <(NodePath const &other) const
      // No coercion possible: inline bool WeakNodePath::operator <(WeakNodePath const &other) const
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_WeakNodePath_compare_to_1119_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_WeakNodePath = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_WeakNodePath_operator_typecast_bool_1111_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_WeakNodePath = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.WeakNodePath",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_WeakNodePath,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_WeakNodePath_compare_to_1119_tp_compare,
#endif
    &Dtool_Repr_WeakNodePath,
    &Dtool_NumberMethods_WeakNodePath,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &Dtool_WeakNodePath_get_key_1120_tp_hash,
    nullptr,
    &Dtool_Repr_WeakNodePath,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is a wrapper around a NodePath that, unlike the actual NodePath\n"
    " * class, doesn't hold a reference count to the node.  Thus the node may be\n"
    " * detached from the scene graph and destructed at any time.\n"
    " *\n"
    " * You can call is_valid() or was_deleted() at any time to determine whether\n"
    " * the node is still around; if it is, get_node_path() will return the\n"
    " * associated NodePath.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_WeakNodePath,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_WeakNodePath,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_WeakNodePath,
    PyType_GenericAlloc,
    Dtool_new_WeakNodePath,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WeakNodePath,
  Dtool_UpcastInterface_WeakNodePath,
  Dtool_DowncastInterface_WeakNodePath,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_WeakNodePath(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_WeakNodePath._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_WeakNodePath._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WeakNodePath) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WeakNodePath)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WeakNodePath);
  }
}

/**
 * Python method tables for Camera (Camera)
 */
static PyMethodDef Dtool_Methods_Camera[] = {
  {"set_active", &Dtool_Camera_set_active_1124, METH_O, (const char *)Dtool_Camera_set_active_1124_comment},
  {"setActive", &Dtool_Camera_set_active_1124, METH_O, (const char *)Dtool_Camera_set_active_1124_comment},
  {"is_active", &Dtool_Camera_is_active_1125, METH_NOARGS, (const char *)Dtool_Camera_is_active_1125_comment},
  {"isActive", &Dtool_Camera_is_active_1125, METH_NOARGS, (const char *)Dtool_Camera_is_active_1125_comment},
  {"set_scene", &Dtool_Camera_set_scene_1127, METH_O, (const char *)Dtool_Camera_set_scene_1127_comment},
  {"setScene", &Dtool_Camera_set_scene_1127, METH_O, (const char *)Dtool_Camera_set_scene_1127_comment},
  {"get_scene", &Dtool_Camera_get_scene_1128, METH_NOARGS, (const char *)Dtool_Camera_get_scene_1128_comment},
  {"getScene", &Dtool_Camera_get_scene_1128, METH_NOARGS, (const char *)Dtool_Camera_get_scene_1128_comment},
  {"get_num_display_regions", &Dtool_Camera_get_num_display_regions_1131, METH_NOARGS, (const char *)Dtool_Camera_get_num_display_regions_1131_comment},
  {"getNumDisplayRegions", &Dtool_Camera_get_num_display_regions_1131, METH_NOARGS, (const char *)Dtool_Camera_get_num_display_regions_1131_comment},
  {"get_display_region", &Dtool_Camera_get_display_region_1132, METH_O, (const char *)Dtool_Camera_get_display_region_1132_comment},
  {"getDisplayRegion", &Dtool_Camera_get_display_region_1132, METH_O, (const char *)Dtool_Camera_get_display_region_1132_comment},
  {"set_camera_mask", &Dtool_Camera_set_camera_mask_1137, METH_O, (const char *)Dtool_Camera_set_camera_mask_1137_comment},
  {"setCameraMask", &Dtool_Camera_set_camera_mask_1137, METH_O, (const char *)Dtool_Camera_set_camera_mask_1137_comment},
  {"get_camera_mask", &Dtool_Camera_get_camera_mask_1138, METH_NOARGS, (const char *)Dtool_Camera_get_camera_mask_1138_comment},
  {"getCameraMask", &Dtool_Camera_get_camera_mask_1138, METH_NOARGS, (const char *)Dtool_Camera_get_camera_mask_1138_comment},
  {"set_cull_center", &Dtool_Camera_set_cull_center_1140, METH_O, (const char *)Dtool_Camera_set_cull_center_1140_comment},
  {"setCullCenter", &Dtool_Camera_set_cull_center_1140, METH_O, (const char *)Dtool_Camera_set_cull_center_1140_comment},
  {"get_cull_center", &Dtool_Camera_get_cull_center_1141, METH_NOARGS, (const char *)Dtool_Camera_get_cull_center_1141_comment},
  {"getCullCenter", &Dtool_Camera_get_cull_center_1141, METH_NOARGS, (const char *)Dtool_Camera_get_cull_center_1141_comment},
  {"set_cull_bounds", &Dtool_Camera_set_cull_bounds_1143, METH_O, (const char *)Dtool_Camera_set_cull_bounds_1143_comment},
  {"setCullBounds", &Dtool_Camera_set_cull_bounds_1143, METH_O, (const char *)Dtool_Camera_set_cull_bounds_1143_comment},
  {"get_cull_bounds", &Dtool_Camera_get_cull_bounds_1144, METH_NOARGS, (const char *)Dtool_Camera_get_cull_bounds_1144_comment},
  {"getCullBounds", &Dtool_Camera_get_cull_bounds_1144, METH_NOARGS, (const char *)Dtool_Camera_get_cull_bounds_1144_comment},
  {"set_lod_center", &Dtool_Camera_set_lod_center_1147, METH_O, (const char *)Dtool_Camera_set_lod_center_1147_comment},
  {"setLodCenter", &Dtool_Camera_set_lod_center_1147, METH_O, (const char *)Dtool_Camera_set_lod_center_1147_comment},
  {"get_lod_center", &Dtool_Camera_get_lod_center_1148, METH_NOARGS, (const char *)Dtool_Camera_get_lod_center_1148_comment},
  {"getLodCenter", &Dtool_Camera_get_lod_center_1148, METH_NOARGS, (const char *)Dtool_Camera_get_lod_center_1148_comment},
  {"set_initial_state", &Dtool_Camera_set_initial_state_1150, METH_O, (const char *)Dtool_Camera_set_initial_state_1150_comment},
  {"setInitialState", &Dtool_Camera_set_initial_state_1150, METH_O, (const char *)Dtool_Camera_set_initial_state_1150_comment},
  {"get_initial_state", &Dtool_Camera_get_initial_state_1151, METH_NOARGS, (const char *)Dtool_Camera_get_initial_state_1151_comment},
  {"getInitialState", &Dtool_Camera_get_initial_state_1151, METH_NOARGS, (const char *)Dtool_Camera_get_initial_state_1151_comment},
  {"set_tag_state_key", &Dtool_Camera_set_tag_state_key_1153, METH_O, (const char *)Dtool_Camera_set_tag_state_key_1153_comment},
  {"setTagStateKey", &Dtool_Camera_set_tag_state_key_1153, METH_O, (const char *)Dtool_Camera_set_tag_state_key_1153_comment},
  {"get_tag_state_key", &Dtool_Camera_get_tag_state_key_1154, METH_NOARGS, (const char *)Dtool_Camera_get_tag_state_key_1154_comment},
  {"getTagStateKey", &Dtool_Camera_get_tag_state_key_1154, METH_NOARGS, (const char *)Dtool_Camera_get_tag_state_key_1154_comment},
  {"set_lod_scale", &Dtool_Camera_set_lod_scale_1157, METH_O, (const char *)Dtool_Camera_set_lod_scale_1157_comment},
  {"setLodScale", &Dtool_Camera_set_lod_scale_1157, METH_O, (const char *)Dtool_Camera_set_lod_scale_1157_comment},
  {"get_lod_scale", &Dtool_Camera_get_lod_scale_1158, METH_NOARGS, (const char *)Dtool_Camera_get_lod_scale_1158_comment},
  {"getLodScale", &Dtool_Camera_get_lod_scale_1158, METH_NOARGS, (const char *)Dtool_Camera_get_lod_scale_1158_comment},
  {"set_tag_state", (PyCFunction) &Dtool_Camera_set_tag_state_1160, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Camera_set_tag_state_1160_comment},
  {"setTagState", (PyCFunction) &Dtool_Camera_set_tag_state_1160, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Camera_set_tag_state_1160_comment},
  {"clear_tag_state", &Dtool_Camera_clear_tag_state_1161, METH_O, (const char *)Dtool_Camera_clear_tag_state_1161_comment},
  {"clearTagState", &Dtool_Camera_clear_tag_state_1161, METH_O, (const char *)Dtool_Camera_clear_tag_state_1161_comment},
  {"clear_tag_states", &Dtool_Camera_clear_tag_states_1162, METH_NOARGS, (const char *)Dtool_Camera_clear_tag_states_1162_comment},
  {"clearTagStates", &Dtool_Camera_clear_tag_states_1162, METH_NOARGS, (const char *)Dtool_Camera_clear_tag_states_1162_comment},
  {"has_tag_state", &Dtool_Camera_has_tag_state_1163, METH_O, (const char *)Dtool_Camera_has_tag_state_1163_comment},
  {"hasTagState", &Dtool_Camera_has_tag_state_1163, METH_O, (const char *)Dtool_Camera_has_tag_state_1163_comment},
  {"get_tag_state", &Dtool_Camera_get_tag_state_1164, METH_O, (const char *)Dtool_Camera_get_tag_state_1164_comment},
  {"getTagState", &Dtool_Camera_get_tag_state_1164, METH_O, (const char *)Dtool_Camera_get_tag_state_1164_comment},
  {"set_aux_scene_data", (PyCFunction) &Dtool_Camera_set_aux_scene_data_1166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Camera_set_aux_scene_data_1166_comment},
  {"setAuxSceneData", (PyCFunction) &Dtool_Camera_set_aux_scene_data_1166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Camera_set_aux_scene_data_1166_comment},
  {"clear_aux_scene_data", &Dtool_Camera_clear_aux_scene_data_1167, METH_O, (const char *)Dtool_Camera_clear_aux_scene_data_1167_comment},
  {"clearAuxSceneData", &Dtool_Camera_clear_aux_scene_data_1167, METH_O, (const char *)Dtool_Camera_clear_aux_scene_data_1167_comment},
  {"get_aux_scene_data", &Dtool_Camera_get_aux_scene_data_1168, METH_O, (const char *)Dtool_Camera_get_aux_scene_data_1168_comment},
  {"getAuxSceneData", &Dtool_Camera_get_aux_scene_data_1168, METH_O, (const char *)Dtool_Camera_get_aux_scene_data_1168_comment},
  {"list_aux_scene_data", &Dtool_Camera_list_aux_scene_data_1169, METH_O, (const char *)Dtool_Camera_list_aux_scene_data_1169_comment},
  {"listAuxSceneData", &Dtool_Camera_list_aux_scene_data_1169, METH_O, (const char *)Dtool_Camera_list_aux_scene_data_1169_comment},
  {"cleanup_aux_scene_data", (PyCFunction) &Dtool_Camera_cleanup_aux_scene_data_1170, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Camera_cleanup_aux_scene_data_1170_comment},
  {"cleanupAuxSceneData", (PyCFunction) &Dtool_Camera_cleanup_aux_scene_data_1170, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Camera_cleanup_aux_scene_data_1170_comment},
  {"get_class_type", &Dtool_Camera_get_class_type_1173, METH_NOARGS | METH_STATIC, (const char *)Dtool_Camera_get_class_type_1173_comment},
  {"getClassType", &Dtool_Camera_get_class_type_1173, METH_NOARGS | METH_STATIC, (const char *)Dtool_Camera_get_class_type_1173_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_display_regions", (PyCFunction) &MakeSeq_Camera_get_display_regions, METH_NOARGS, nullptr},
  { "getDisplayRegions", (PyCFunction) &MakeSeq_Camera_get_display_regions, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_Camera[] = {
  {(char *)"active", &Dtool_Camera_active_Getter, &Dtool_Camera_active_Setter, nullptr, nullptr},
  {(char *)"scene", &Dtool_Camera_scene_Getter, &Dtool_Camera_scene_Setter, nullptr, nullptr},
  {(char *)"display_regions", &Dtool_Camera_display_regions_Getter, nullptr, nullptr, nullptr},
  {(char *)"camera_mask", &Dtool_Camera_camera_mask_Getter, &Dtool_Camera_camera_mask_Setter, nullptr, nullptr},
  {(char *)"cull_center", &Dtool_Camera_cull_center_Getter, &Dtool_Camera_cull_center_Setter, nullptr, nullptr},
  {(char *)"cull_bounds", &Dtool_Camera_cull_bounds_Getter, &Dtool_Camera_cull_bounds_Setter, nullptr, nullptr},
  {(char *)"lod_center", &Dtool_Camera_lod_center_Getter, &Dtool_Camera_lod_center_Setter, nullptr, nullptr},
  {(char *)"initial_state", &Dtool_Camera_initial_state_Getter, &Dtool_Camera_initial_state_Setter, nullptr, nullptr},
  {(char *)"tag_state_key", &Dtool_Camera_tag_state_key_Getter, &Dtool_Camera_tag_state_key_Setter, nullptr, nullptr},
  {(char *)"lod_scale", &Dtool_Camera_lod_scale_Getter, &Dtool_Camera_lod_scale_Setter, nullptr, nullptr},
  {(char *)"tag_states", &Dtool_Camera_tag_states_Getter, nullptr, nullptr, nullptr},
  {(char *)"aux_scene_data", &Dtool_Camera_aux_scene_data_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Camera = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Camera = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Camera = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Camera = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Camera = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Camera = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Camera",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Camera,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Camera,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Camera,
    &Dtool_SequenceMethods_Camera,
    &Dtool_MappingMethods_Camera,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Camera,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node that can be positioned around in the scene graph to represent a\n"
    " * point of view for rendering a scene.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Camera,
    nullptr, // tp_members
    Dtool_Properties_Camera,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Camera,
    PyType_GenericAlloc,
    Dtool_new_Camera,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Camera,
  Dtool_UpcastInterface_Camera,
  Dtool_DowncastInterface_Camera,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Camera(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LensNode(nullptr);
    Dtool_Camera._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LensNode);
    Dtool_Camera._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Camera._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Camera) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Camera)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Camera);
  }
}

/**
 * Python method tables for PlaneNode (PlaneNode)
 */
static PyMethodDef Dtool_Methods_PlaneNode[] = {
  {"set_plane", &Dtool_PlaneNode_set_plane_1176, METH_O, (const char *)Dtool_PlaneNode_set_plane_1176_comment},
  {"setPlane", &Dtool_PlaneNode_set_plane_1176, METH_O, (const char *)Dtool_PlaneNode_set_plane_1176_comment},
  {"get_plane", &Dtool_PlaneNode_get_plane_1177, METH_NOARGS, (const char *)Dtool_PlaneNode_get_plane_1177_comment},
  {"getPlane", &Dtool_PlaneNode_get_plane_1177, METH_NOARGS, (const char *)Dtool_PlaneNode_get_plane_1177_comment},
  {"set_viz_scale", &Dtool_PlaneNode_set_viz_scale_1178, METH_O, (const char *)Dtool_PlaneNode_set_viz_scale_1178_comment},
  {"setVizScale", &Dtool_PlaneNode_set_viz_scale_1178, METH_O, (const char *)Dtool_PlaneNode_set_viz_scale_1178_comment},
  {"get_viz_scale", &Dtool_PlaneNode_get_viz_scale_1179, METH_NOARGS, (const char *)Dtool_PlaneNode_get_viz_scale_1179_comment},
  {"getVizScale", &Dtool_PlaneNode_get_viz_scale_1179, METH_NOARGS, (const char *)Dtool_PlaneNode_get_viz_scale_1179_comment},
  {"set_priority", &Dtool_PlaneNode_set_priority_1180, METH_O, (const char *)Dtool_PlaneNode_set_priority_1180_comment},
  {"setPriority", &Dtool_PlaneNode_set_priority_1180, METH_O, (const char *)Dtool_PlaneNode_set_priority_1180_comment},
  {"get_priority", &Dtool_PlaneNode_get_priority_1181, METH_NOARGS, (const char *)Dtool_PlaneNode_get_priority_1181_comment},
  {"getPriority", &Dtool_PlaneNode_get_priority_1181, METH_NOARGS, (const char *)Dtool_PlaneNode_get_priority_1181_comment},
  {"set_clip_effect", &Dtool_PlaneNode_set_clip_effect_1183, METH_O, (const char *)Dtool_PlaneNode_set_clip_effect_1183_comment},
  {"setClipEffect", &Dtool_PlaneNode_set_clip_effect_1183, METH_O, (const char *)Dtool_PlaneNode_set_clip_effect_1183_comment},
  {"get_clip_effect", &Dtool_PlaneNode_get_clip_effect_1184, METH_NOARGS, (const char *)Dtool_PlaneNode_get_clip_effect_1184_comment},
  {"getClipEffect", &Dtool_PlaneNode_get_clip_effect_1184, METH_NOARGS, (const char *)Dtool_PlaneNode_get_clip_effect_1184_comment},
  {"get_class_type", &Dtool_PlaneNode_get_class_type_1185, METH_NOARGS | METH_STATIC, (const char *)Dtool_PlaneNode_get_class_type_1185_comment},
  {"getClassType", &Dtool_PlaneNode_get_class_type_1185, METH_NOARGS | METH_STATIC, (const char *)Dtool_PlaneNode_get_class_type_1185_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PlaneNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PlaneNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PlaneNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PlaneNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PlaneNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PlaneNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PlaneNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PlaneNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PlaneNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PlaneNode,
    &Dtool_SequenceMethods_PlaneNode,
    &Dtool_MappingMethods_PlaneNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PlaneNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node that contains a plane.  This is most often used as a clipping plane,\n"
    " * but it can serve other purposes as well; whenever a plane is needed to be\n"
    " * defined in some coordinate space in the world.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PlaneNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PlaneNode,
    PyType_GenericAlloc,
    Dtool_new_PlaneNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PlaneNode,
  Dtool_UpcastInterface_PlaneNode,
  Dtool_DowncastInterface_PlaneNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PlaneNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PandaNode(nullptr);
    Dtool_PlaneNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PandaNode);
    Dtool_PlaneNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PlaneNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PlaneNode::ClipEffect;
    PyDict_SetItemString(dict, "CE_visible", Dtool_WrapValue(PlaneNode::CE_visible));
    PyDict_SetItemString(dict, "CEVisible", Dtool_WrapValue(PlaneNode::CE_visible));
    PyDict_SetItemString(dict, "CE_collision", Dtool_WrapValue(PlaneNode::CE_collision));
    PyDict_SetItemString(dict, "CECollision", Dtool_WrapValue(PlaneNode::CE_collision));
    if (PyType_Ready((PyTypeObject *)&Dtool_PlaneNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PlaneNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PlaneNode);
  }
}

/**
 * Python method tables for ClipPlaneAttrib (ClipPlaneAttrib)
 */
static PyMethodDef Dtool_Methods_ClipPlaneAttrib[] = {
  {"make", (PyCFunction) &Dtool_ClipPlaneAttrib_make_1189, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ClipPlaneAttrib_make_1189_comment},
  {"make_default", &Dtool_ClipPlaneAttrib_make_default_1190, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClipPlaneAttrib_make_default_1190_comment},
  {"makeDefault", &Dtool_ClipPlaneAttrib_make_default_1190, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClipPlaneAttrib_make_default_1190_comment},
  {"get_operation", &Dtool_ClipPlaneAttrib_get_operation_1191, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_get_operation_1191_comment},
  {"getOperation", &Dtool_ClipPlaneAttrib_get_operation_1191, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_get_operation_1191_comment},
  {"get_num_planes", &Dtool_ClipPlaneAttrib_get_num_planes_1192, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_get_num_planes_1192_comment},
  {"getNumPlanes", &Dtool_ClipPlaneAttrib_get_num_planes_1192, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_get_num_planes_1192_comment},
  {"get_plane", &Dtool_ClipPlaneAttrib_get_plane_1193, METH_O, (const char *)Dtool_ClipPlaneAttrib_get_plane_1193_comment},
  {"getPlane", &Dtool_ClipPlaneAttrib_get_plane_1193, METH_O, (const char *)Dtool_ClipPlaneAttrib_get_plane_1193_comment},
  {"has_plane", &Dtool_ClipPlaneAttrib_has_plane_1194, METH_O, (const char *)Dtool_ClipPlaneAttrib_has_plane_1194_comment},
  {"hasPlane", &Dtool_ClipPlaneAttrib_has_plane_1194, METH_O, (const char *)Dtool_ClipPlaneAttrib_has_plane_1194_comment},
  {"add_plane", &Dtool_ClipPlaneAttrib_add_plane_1195, METH_O, (const char *)Dtool_ClipPlaneAttrib_add_plane_1195_comment},
  {"addPlane", &Dtool_ClipPlaneAttrib_add_plane_1195, METH_O, (const char *)Dtool_ClipPlaneAttrib_add_plane_1195_comment},
  {"remove_plane", &Dtool_ClipPlaneAttrib_remove_plane_1196, METH_O, (const char *)Dtool_ClipPlaneAttrib_remove_plane_1196_comment},
  {"removePlane", &Dtool_ClipPlaneAttrib_remove_plane_1196, METH_O, (const char *)Dtool_ClipPlaneAttrib_remove_plane_1196_comment},
  {"make_all_off", &Dtool_ClipPlaneAttrib_make_all_off_1197, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClipPlaneAttrib_make_all_off_1197_comment},
  {"makeAllOff", &Dtool_ClipPlaneAttrib_make_all_off_1197, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClipPlaneAttrib_make_all_off_1197_comment},
  {"get_num_on_planes", &Dtool_ClipPlaneAttrib_get_num_on_planes_1198, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_get_num_on_planes_1198_comment},
  {"getNumOnPlanes", &Dtool_ClipPlaneAttrib_get_num_on_planes_1198, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_get_num_on_planes_1198_comment},
  {"get_on_plane", &Dtool_ClipPlaneAttrib_get_on_plane_1199, METH_O, (const char *)Dtool_ClipPlaneAttrib_get_on_plane_1199_comment},
  {"getOnPlane", &Dtool_ClipPlaneAttrib_get_on_plane_1199, METH_O, (const char *)Dtool_ClipPlaneAttrib_get_on_plane_1199_comment},
  {"has_on_plane", &Dtool_ClipPlaneAttrib_has_on_plane_1201, METH_O, (const char *)Dtool_ClipPlaneAttrib_has_on_plane_1201_comment},
  {"hasOnPlane", &Dtool_ClipPlaneAttrib_has_on_plane_1201, METH_O, (const char *)Dtool_ClipPlaneAttrib_has_on_plane_1201_comment},
  {"get_num_off_planes", &Dtool_ClipPlaneAttrib_get_num_off_planes_1202, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_get_num_off_planes_1202_comment},
  {"getNumOffPlanes", &Dtool_ClipPlaneAttrib_get_num_off_planes_1202, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_get_num_off_planes_1202_comment},
  {"get_off_plane", &Dtool_ClipPlaneAttrib_get_off_plane_1203, METH_O, (const char *)Dtool_ClipPlaneAttrib_get_off_plane_1203_comment},
  {"getOffPlane", &Dtool_ClipPlaneAttrib_get_off_plane_1203, METH_O, (const char *)Dtool_ClipPlaneAttrib_get_off_plane_1203_comment},
  {"has_off_plane", &Dtool_ClipPlaneAttrib_has_off_plane_1205, METH_O, (const char *)Dtool_ClipPlaneAttrib_has_off_plane_1205_comment},
  {"hasOffPlane", &Dtool_ClipPlaneAttrib_has_off_plane_1205, METH_O, (const char *)Dtool_ClipPlaneAttrib_has_off_plane_1205_comment},
  {"has_all_off", &Dtool_ClipPlaneAttrib_has_all_off_1206, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_has_all_off_1206_comment},
  {"hasAllOff", &Dtool_ClipPlaneAttrib_has_all_off_1206, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_has_all_off_1206_comment},
  {"is_identity", &Dtool_ClipPlaneAttrib_is_identity_1207, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_is_identity_1207_comment},
  {"isIdentity", &Dtool_ClipPlaneAttrib_is_identity_1207, METH_NOARGS, (const char *)Dtool_ClipPlaneAttrib_is_identity_1207_comment},
  {"add_on_plane", &Dtool_ClipPlaneAttrib_add_on_plane_1208, METH_O, (const char *)Dtool_ClipPlaneAttrib_add_on_plane_1208_comment},
  {"addOnPlane", &Dtool_ClipPlaneAttrib_add_on_plane_1208, METH_O, (const char *)Dtool_ClipPlaneAttrib_add_on_plane_1208_comment},
  {"remove_on_plane", &Dtool_ClipPlaneAttrib_remove_on_plane_1209, METH_O, (const char *)Dtool_ClipPlaneAttrib_remove_on_plane_1209_comment},
  {"removeOnPlane", &Dtool_ClipPlaneAttrib_remove_on_plane_1209, METH_O, (const char *)Dtool_ClipPlaneAttrib_remove_on_plane_1209_comment},
  {"add_off_plane", &Dtool_ClipPlaneAttrib_add_off_plane_1210, METH_O, (const char *)Dtool_ClipPlaneAttrib_add_off_plane_1210_comment},
  {"addOffPlane", &Dtool_ClipPlaneAttrib_add_off_plane_1210, METH_O, (const char *)Dtool_ClipPlaneAttrib_add_off_plane_1210_comment},
  {"remove_off_plane", &Dtool_ClipPlaneAttrib_remove_off_plane_1211, METH_O, (const char *)Dtool_ClipPlaneAttrib_remove_off_plane_1211_comment},
  {"removeOffPlane", &Dtool_ClipPlaneAttrib_remove_off_plane_1211, METH_O, (const char *)Dtool_ClipPlaneAttrib_remove_off_plane_1211_comment},
  {"filter_to_max", &Dtool_ClipPlaneAttrib_filter_to_max_1212, METH_O, (const char *)Dtool_ClipPlaneAttrib_filter_to_max_1212_comment},
  {"filterToMax", &Dtool_ClipPlaneAttrib_filter_to_max_1212, METH_O, (const char *)Dtool_ClipPlaneAttrib_filter_to_max_1212_comment},
  {"get_class_slot", &Dtool_ClipPlaneAttrib_get_class_slot_1213, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClipPlaneAttrib_get_class_slot_1213_comment},
  {"getClassSlot", &Dtool_ClipPlaneAttrib_get_class_slot_1213, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClipPlaneAttrib_get_class_slot_1213_comment},
  {"get_class_type", &Dtool_ClipPlaneAttrib_get_class_type_1215, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClipPlaneAttrib_get_class_type_1215_comment},
  {"getClassType", &Dtool_ClipPlaneAttrib_get_class_type_1215, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClipPlaneAttrib_get_class_type_1215_comment},
  {"get_on_planes", (PyCFunction) &MakeSeq_ClipPlaneAttrib_get_on_planes, METH_NOARGS, nullptr},
  { "getOnPlanes", (PyCFunction) &MakeSeq_ClipPlaneAttrib_get_on_planes, METH_NOARGS, nullptr},
  {"get_off_planes", (PyCFunction) &MakeSeq_ClipPlaneAttrib_get_off_planes, METH_NOARGS, nullptr},
  { "getOffPlanes", (PyCFunction) &MakeSeq_ClipPlaneAttrib_get_off_planes, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ClipPlaneAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ClipPlaneAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ClipPlaneAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ClipPlaneAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ClipPlaneAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ClipPlaneAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ClipPlaneAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ClipPlaneAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ClipPlaneAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ClipPlaneAttrib,
    &Dtool_SequenceMethods_ClipPlaneAttrib,
    &Dtool_MappingMethods_ClipPlaneAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ClipPlaneAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This functions similarly to a LightAttrib.  It indicates the set of\n"
    " * clipping planes that modify the geometry at this level and below.  A\n"
    " * ClipPlaneAttrib can either add planes or remove planes from the total set\n"
    " * of clipping planes in effect.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ClipPlaneAttrib,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ClipPlaneAttrib,
    PyType_GenericAlloc,
    Dtool_new_ClipPlaneAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ClipPlaneAttrib,
  Dtool_UpcastInterface_ClipPlaneAttrib,
  Dtool_DowncastInterface_ClipPlaneAttrib,
  (CoerceFunction)Dtool_ConstCoerce_ClipPlaneAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_ClipPlaneAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_ClipPlaneAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_ClipPlaneAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_ClipPlaneAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ClipPlaneAttrib::Operation;
    PyDict_SetItemString(dict, "O_set", Dtool_WrapValue(ClipPlaneAttrib::O_set));
    PyDict_SetItemString(dict, "OSet", Dtool_WrapValue(ClipPlaneAttrib::O_set));
    PyDict_SetItemString(dict, "O_add", Dtool_WrapValue(ClipPlaneAttrib::O_add));
    PyDict_SetItemString(dict, "OAdd", Dtool_WrapValue(ClipPlaneAttrib::O_add));
    PyDict_SetItemString(dict, "O_remove", Dtool_WrapValue(ClipPlaneAttrib::O_remove));
    PyDict_SetItemString(dict, "ORemove", Dtool_WrapValue(ClipPlaneAttrib::O_remove));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_ClipPlaneAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_ClipPlaneAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_ClipPlaneAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ClipPlaneAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ClipPlaneAttrib);
  }
}

/**
 * Python method tables for ColorAttrib (ColorAttrib)
 */
static PyMethodDef Dtool_Methods_ColorAttrib[] = {
  {"make_vertex", &Dtool_ColorAttrib_make_vertex_1219, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorAttrib_make_vertex_1219_comment},
  {"makeVertex", &Dtool_ColorAttrib_make_vertex_1219, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorAttrib_make_vertex_1219_comment},
  {"make_flat", &Dtool_ColorAttrib_make_flat_1220, METH_O | METH_STATIC, (const char *)Dtool_ColorAttrib_make_flat_1220_comment},
  {"makeFlat", &Dtool_ColorAttrib_make_flat_1220, METH_O | METH_STATIC, (const char *)Dtool_ColorAttrib_make_flat_1220_comment},
  {"make_off", &Dtool_ColorAttrib_make_off_1221, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorAttrib_make_off_1221_comment},
  {"makeOff", &Dtool_ColorAttrib_make_off_1221, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorAttrib_make_off_1221_comment},
  {"make_default", &Dtool_ColorAttrib_make_default_1222, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorAttrib_make_default_1222_comment},
  {"makeDefault", &Dtool_ColorAttrib_make_default_1222, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorAttrib_make_default_1222_comment},
  {"get_color_type", &Dtool_ColorAttrib_get_color_type_1223, METH_NOARGS, (const char *)Dtool_ColorAttrib_get_color_type_1223_comment},
  {"getColorType", &Dtool_ColorAttrib_get_color_type_1223, METH_NOARGS, (const char *)Dtool_ColorAttrib_get_color_type_1223_comment},
  {"get_color", &Dtool_ColorAttrib_get_color_1224, METH_NOARGS, (const char *)Dtool_ColorAttrib_get_color_1224_comment},
  {"getColor", &Dtool_ColorAttrib_get_color_1224, METH_NOARGS, (const char *)Dtool_ColorAttrib_get_color_1224_comment},
  {"get_class_slot", &Dtool_ColorAttrib_get_class_slot_1227, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorAttrib_get_class_slot_1227_comment},
  {"getClassSlot", &Dtool_ColorAttrib_get_class_slot_1227, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorAttrib_get_class_slot_1227_comment},
  {"get_class_type", &Dtool_ColorAttrib_get_class_type_1229, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorAttrib_get_class_type_1229_comment},
  {"getClassType", &Dtool_ColorAttrib_get_class_type_1229, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorAttrib_get_class_type_1229_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ColorAttrib[] = {
  {(char *)"color_type", &Dtool_ColorAttrib_color_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"color", &Dtool_ColorAttrib_color_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ColorAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ColorAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ColorAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ColorAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ColorAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ColorAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ColorAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ColorAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ColorAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ColorAttrib,
    &Dtool_SequenceMethods_ColorAttrib,
    &Dtool_MappingMethods_ColorAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ColorAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Indicates what color should be applied to renderable geometry.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ColorAttrib,
    nullptr, // tp_members
    Dtool_Properties_ColorAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ColorAttrib,
    PyType_GenericAlloc,
    Dtool_new_ColorAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ColorAttrib,
  Dtool_UpcastInterface_ColorAttrib,
  Dtool_DowncastInterface_ColorAttrib,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ColorAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_ColorAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_ColorAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_ColorAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ColorAttrib::Type;
    PyDict_SetItemString(dict, "T_vertex", Dtool_WrapValue(ColorAttrib::T_vertex));
    PyDict_SetItemString(dict, "TVertex", Dtool_WrapValue(ColorAttrib::T_vertex));
    PyDict_SetItemString(dict, "T_flat", Dtool_WrapValue(ColorAttrib::T_flat));
    PyDict_SetItemString(dict, "TFlat", Dtool_WrapValue(ColorAttrib::T_flat));
    PyDict_SetItemString(dict, "T_off", Dtool_WrapValue(ColorAttrib::T_off));
    PyDict_SetItemString(dict, "TOff", Dtool_WrapValue(ColorAttrib::T_off));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_ColorAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_ColorAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_ColorAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ColorAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ColorAttrib);
  }
}

/**
 * Python method tables for ColorBlendAttrib (ColorBlendAttrib)
 */
static PyMethodDef Dtool_Methods_ColorBlendAttrib[] = {
  {"make_off", &Dtool_ColorBlendAttrib_make_off_1234, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorBlendAttrib_make_off_1234_comment},
  {"makeOff", &Dtool_ColorBlendAttrib_make_off_1234, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorBlendAttrib_make_off_1234_comment},
  {"make", (PyCFunction) &Dtool_ColorBlendAttrib_make_1235, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ColorBlendAttrib_make_1235_comment},
  {"make_default", &Dtool_ColorBlendAttrib_make_default_1236, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorBlendAttrib_make_default_1236_comment},
  {"makeDefault", &Dtool_ColorBlendAttrib_make_default_1236, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorBlendAttrib_make_default_1236_comment},
  {"get_mode", &Dtool_ColorBlendAttrib_get_mode_1237, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_mode_1237_comment},
  {"getMode", &Dtool_ColorBlendAttrib_get_mode_1237, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_mode_1237_comment},
  {"get_operand_a", &Dtool_ColorBlendAttrib_get_operand_a_1238, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_operand_a_1238_comment},
  {"getOperandA", &Dtool_ColorBlendAttrib_get_operand_a_1238, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_operand_a_1238_comment},
  {"get_operand_b", &Dtool_ColorBlendAttrib_get_operand_b_1239, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_operand_b_1239_comment},
  {"getOperandB", &Dtool_ColorBlendAttrib_get_operand_b_1239, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_operand_b_1239_comment},
  {"get_alpha_mode", &Dtool_ColorBlendAttrib_get_alpha_mode_1240, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_alpha_mode_1240_comment},
  {"getAlphaMode", &Dtool_ColorBlendAttrib_get_alpha_mode_1240, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_alpha_mode_1240_comment},
  {"get_alpha_operand_a", &Dtool_ColorBlendAttrib_get_alpha_operand_a_1241, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_alpha_operand_a_1241_comment},
  {"getAlphaOperandA", &Dtool_ColorBlendAttrib_get_alpha_operand_a_1241, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_alpha_operand_a_1241_comment},
  {"get_alpha_operand_b", &Dtool_ColorBlendAttrib_get_alpha_operand_b_1242, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_alpha_operand_b_1242_comment},
  {"getAlphaOperandB", &Dtool_ColorBlendAttrib_get_alpha_operand_b_1242, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_alpha_operand_b_1242_comment},
  {"get_color", &Dtool_ColorBlendAttrib_get_color_1243, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_color_1243_comment},
  {"getColor", &Dtool_ColorBlendAttrib_get_color_1243, METH_NOARGS, (const char *)Dtool_ColorBlendAttrib_get_color_1243_comment},
  {"involves_constant_color", &Dtool_ColorBlendAttrib_involves_constant_color_1244, METH_VARARGS, (const char *)Dtool_ColorBlendAttrib_involves_constant_color_1244_comment},
  {"involvesConstantColor", &Dtool_ColorBlendAttrib_involves_constant_color_1244, METH_VARARGS, (const char *)Dtool_ColorBlendAttrib_involves_constant_color_1244_comment},
  {"involves_color_scale", &Dtool_ColorBlendAttrib_involves_color_scale_1245, METH_VARARGS, (const char *)Dtool_ColorBlendAttrib_involves_color_scale_1245_comment},
  {"involvesColorScale", &Dtool_ColorBlendAttrib_involves_color_scale_1245, METH_VARARGS, (const char *)Dtool_ColorBlendAttrib_involves_color_scale_1245_comment},
  {"get_class_slot", &Dtool_ColorBlendAttrib_get_class_slot_1253, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorBlendAttrib_get_class_slot_1253_comment},
  {"getClassSlot", &Dtool_ColorBlendAttrib_get_class_slot_1253, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorBlendAttrib_get_class_slot_1253_comment},
  {"get_class_type", &Dtool_ColorBlendAttrib_get_class_type_1255, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorBlendAttrib_get_class_type_1255_comment},
  {"getClassType", &Dtool_ColorBlendAttrib_get_class_type_1255, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorBlendAttrib_get_class_type_1255_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ColorBlendAttrib[] = {
  {(char *)"rgb_mode", &Dtool_ColorBlendAttrib_rgb_mode_Getter, nullptr, nullptr, nullptr},
  {(char *)"rgb_operand_a", &Dtool_ColorBlendAttrib_rgb_operand_a_Getter, nullptr, nullptr, nullptr},
  {(char *)"rgb_operand_b", &Dtool_ColorBlendAttrib_rgb_operand_b_Getter, nullptr, nullptr, nullptr},
  {(char *)"alpha_mode", &Dtool_ColorBlendAttrib_alpha_mode_Getter, nullptr, nullptr, nullptr},
  {(char *)"alpha_operand_a", &Dtool_ColorBlendAttrib_alpha_operand_a_Getter, nullptr, nullptr, nullptr},
  {(char *)"alpha_operand_b", &Dtool_ColorBlendAttrib_alpha_operand_b_Getter, nullptr, nullptr, nullptr},
  {(char *)"color", &Dtool_ColorBlendAttrib_color_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ColorBlendAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ColorBlendAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ColorBlendAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ColorBlendAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ColorBlendAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ColorBlendAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ColorBlendAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ColorBlendAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ColorBlendAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ColorBlendAttrib,
    &Dtool_SequenceMethods_ColorBlendAttrib,
    &Dtool_MappingMethods_ColorBlendAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ColorBlendAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This specifies how colors are blended into the frame buffer, for special\n"
    " * effects.  This overrides transparency if transparency is also specified.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ColorBlendAttrib,
    nullptr, // tp_members
    Dtool_Properties_ColorBlendAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ColorBlendAttrib,
    PyType_GenericAlloc,
    Dtool_new_ColorBlendAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ColorBlendAttrib,
  Dtool_UpcastInterface_ColorBlendAttrib,
  Dtool_DowncastInterface_ColorBlendAttrib,
  (CoerceFunction)Dtool_ConstCoerce_ColorBlendAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_ColorBlendAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_ColorBlendAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_ColorBlendAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(59);
    Dtool_ColorBlendAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ColorBlendAttrib::Mode;
    PyDict_SetItemString(dict, "M_none", Dtool_WrapValue(ColorBlendAttrib::M_none));
    PyDict_SetItemString(dict, "MNone", Dtool_WrapValue(ColorBlendAttrib::M_none));
    PyDict_SetItemString(dict, "M_add", Dtool_WrapValue(ColorBlendAttrib::M_add));
    PyDict_SetItemString(dict, "MAdd", Dtool_WrapValue(ColorBlendAttrib::M_add));
    PyDict_SetItemString(dict, "M_subtract", Dtool_WrapValue(ColorBlendAttrib::M_subtract));
    PyDict_SetItemString(dict, "MSubtract", Dtool_WrapValue(ColorBlendAttrib::M_subtract));
    PyDict_SetItemString(dict, "M_inv_subtract", Dtool_WrapValue(ColorBlendAttrib::M_inv_subtract));
    PyDict_SetItemString(dict, "MInvSubtract", Dtool_WrapValue(ColorBlendAttrib::M_inv_subtract));
    PyDict_SetItemString(dict, "M_min", Dtool_WrapValue(ColorBlendAttrib::M_min));
    PyDict_SetItemString(dict, "MMin", Dtool_WrapValue(ColorBlendAttrib::M_min));
    PyDict_SetItemString(dict, "M_max", Dtool_WrapValue(ColorBlendAttrib::M_max));
    PyDict_SetItemString(dict, "MMax", Dtool_WrapValue(ColorBlendAttrib::M_max));
    // enum ColorBlendAttrib::Operand;
    PyDict_SetItemString(dict, "O_zero", Dtool_WrapValue(ColorBlendAttrib::O_zero));
    PyDict_SetItemString(dict, "OZero", Dtool_WrapValue(ColorBlendAttrib::O_zero));
    PyDict_SetItemString(dict, "O_one", Dtool_WrapValue(ColorBlendAttrib::O_one));
    PyDict_SetItemString(dict, "OOne", Dtool_WrapValue(ColorBlendAttrib::O_one));
    PyDict_SetItemString(dict, "O_incoming_color", Dtool_WrapValue(ColorBlendAttrib::O_incoming_color));
    PyDict_SetItemString(dict, "OIncomingColor", Dtool_WrapValue(ColorBlendAttrib::O_incoming_color));
    PyDict_SetItemString(dict, "O_one_minus_incoming_color", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_incoming_color));
    PyDict_SetItemString(dict, "OOneMinusIncomingColor", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_incoming_color));
    PyDict_SetItemString(dict, "O_fbuffer_color", Dtool_WrapValue(ColorBlendAttrib::O_fbuffer_color));
    PyDict_SetItemString(dict, "OFbufferColor", Dtool_WrapValue(ColorBlendAttrib::O_fbuffer_color));
    PyDict_SetItemString(dict, "O_one_minus_fbuffer_color", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_fbuffer_color));
    PyDict_SetItemString(dict, "OOneMinusFbufferColor", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_fbuffer_color));
    PyDict_SetItemString(dict, "O_incoming_alpha", Dtool_WrapValue(ColorBlendAttrib::O_incoming_alpha));
    PyDict_SetItemString(dict, "OIncomingAlpha", Dtool_WrapValue(ColorBlendAttrib::O_incoming_alpha));
    PyDict_SetItemString(dict, "O_one_minus_incoming_alpha", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_incoming_alpha));
    PyDict_SetItemString(dict, "OOneMinusIncomingAlpha", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_incoming_alpha));
    PyDict_SetItemString(dict, "O_fbuffer_alpha", Dtool_WrapValue(ColorBlendAttrib::O_fbuffer_alpha));
    PyDict_SetItemString(dict, "OFbufferAlpha", Dtool_WrapValue(ColorBlendAttrib::O_fbuffer_alpha));
    PyDict_SetItemString(dict, "O_one_minus_fbuffer_alpha", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_fbuffer_alpha));
    PyDict_SetItemString(dict, "OOneMinusFbufferAlpha", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_fbuffer_alpha));
    PyDict_SetItemString(dict, "O_constant_color", Dtool_WrapValue(ColorBlendAttrib::O_constant_color));
    PyDict_SetItemString(dict, "OConstantColor", Dtool_WrapValue(ColorBlendAttrib::O_constant_color));
    PyDict_SetItemString(dict, "O_one_minus_constant_color", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_constant_color));
    PyDict_SetItemString(dict, "OOneMinusConstantColor", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_constant_color));
    PyDict_SetItemString(dict, "O_constant_alpha", Dtool_WrapValue(ColorBlendAttrib::O_constant_alpha));
    PyDict_SetItemString(dict, "OConstantAlpha", Dtool_WrapValue(ColorBlendAttrib::O_constant_alpha));
    PyDict_SetItemString(dict, "O_one_minus_constant_alpha", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_constant_alpha));
    PyDict_SetItemString(dict, "OOneMinusConstantAlpha", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_constant_alpha));
    PyDict_SetItemString(dict, "O_incoming_color_saturate", Dtool_WrapValue(ColorBlendAttrib::O_incoming_color_saturate));
    PyDict_SetItemString(dict, "OIncomingColorSaturate", Dtool_WrapValue(ColorBlendAttrib::O_incoming_color_saturate));
    PyDict_SetItemString(dict, "O_incoming1_color", Dtool_WrapValue(ColorBlendAttrib::O_incoming1_color));
    PyDict_SetItemString(dict, "OIncoming1Color", Dtool_WrapValue(ColorBlendAttrib::O_incoming1_color));
    PyDict_SetItemString(dict, "O_one_minus_incoming1_color", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_incoming1_color));
    PyDict_SetItemString(dict, "OOneMinusIncoming1Color", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_incoming1_color));
    PyDict_SetItemString(dict, "O_incoming1_alpha", Dtool_WrapValue(ColorBlendAttrib::O_incoming1_alpha));
    PyDict_SetItemString(dict, "OIncoming1Alpha", Dtool_WrapValue(ColorBlendAttrib::O_incoming1_alpha));
    PyDict_SetItemString(dict, "O_one_minus_incoming1_alpha", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_incoming1_alpha));
    PyDict_SetItemString(dict, "OOneMinusIncoming1Alpha", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_incoming1_alpha));
    PyDict_SetItemString(dict, "O_color_scale", Dtool_WrapValue(ColorBlendAttrib::O_color_scale));
    PyDict_SetItemString(dict, "OColorScale", Dtool_WrapValue(ColorBlendAttrib::O_color_scale));
    PyDict_SetItemString(dict, "O_one_minus_color_scale", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_color_scale));
    PyDict_SetItemString(dict, "OOneMinusColorScale", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_color_scale));
    PyDict_SetItemString(dict, "O_alpha_scale", Dtool_WrapValue(ColorBlendAttrib::O_alpha_scale));
    PyDict_SetItemString(dict, "OAlphaScale", Dtool_WrapValue(ColorBlendAttrib::O_alpha_scale));
    PyDict_SetItemString(dict, "O_one_minus_alpha_scale", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_alpha_scale));
    PyDict_SetItemString(dict, "OOneMinusAlphaScale", Dtool_WrapValue(ColorBlendAttrib::O_one_minus_alpha_scale));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_ColorBlendAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_ColorBlendAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_ColorBlendAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ColorBlendAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ColorBlendAttrib);
  }
}

/**
 * Python method tables for ColorScaleAttrib (ColorScaleAttrib)
 */
static PyMethodDef Dtool_Methods_ColorScaleAttrib[] = {
  {"make_identity", &Dtool_ColorScaleAttrib_make_identity_1258, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorScaleAttrib_make_identity_1258_comment},
  {"makeIdentity", &Dtool_ColorScaleAttrib_make_identity_1258, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorScaleAttrib_make_identity_1258_comment},
  {"make", &Dtool_ColorScaleAttrib_make_1259, METH_O | METH_STATIC, (const char *)Dtool_ColorScaleAttrib_make_1259_comment},
  {"make_off", &Dtool_ColorScaleAttrib_make_off_1260, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorScaleAttrib_make_off_1260_comment},
  {"makeOff", &Dtool_ColorScaleAttrib_make_off_1260, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorScaleAttrib_make_off_1260_comment},
  {"make_default", &Dtool_ColorScaleAttrib_make_default_1261, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorScaleAttrib_make_default_1261_comment},
  {"makeDefault", &Dtool_ColorScaleAttrib_make_default_1261, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorScaleAttrib_make_default_1261_comment},
  {"is_off", &Dtool_ColorScaleAttrib_is_off_1262, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_is_off_1262_comment},
  {"isOff", &Dtool_ColorScaleAttrib_is_off_1262, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_is_off_1262_comment},
  {"is_identity", &Dtool_ColorScaleAttrib_is_identity_1263, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_is_identity_1263_comment},
  {"isIdentity", &Dtool_ColorScaleAttrib_is_identity_1263, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_is_identity_1263_comment},
  {"has_scale", &Dtool_ColorScaleAttrib_has_scale_1264, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_has_scale_1264_comment},
  {"hasScale", &Dtool_ColorScaleAttrib_has_scale_1264, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_has_scale_1264_comment},
  {"has_rgb_scale", &Dtool_ColorScaleAttrib_has_rgb_scale_1265, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_has_rgb_scale_1265_comment},
  {"hasRgbScale", &Dtool_ColorScaleAttrib_has_rgb_scale_1265, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_has_rgb_scale_1265_comment},
  {"has_alpha_scale", &Dtool_ColorScaleAttrib_has_alpha_scale_1266, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_has_alpha_scale_1266_comment},
  {"hasAlphaScale", &Dtool_ColorScaleAttrib_has_alpha_scale_1266, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_has_alpha_scale_1266_comment},
  {"get_scale", &Dtool_ColorScaleAttrib_get_scale_1267, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_get_scale_1267_comment},
  {"getScale", &Dtool_ColorScaleAttrib_get_scale_1267, METH_NOARGS, (const char *)Dtool_ColorScaleAttrib_get_scale_1267_comment},
  {"set_scale", &Dtool_ColorScaleAttrib_set_scale_1268, METH_O, (const char *)Dtool_ColorScaleAttrib_set_scale_1268_comment},
  {"setScale", &Dtool_ColorScaleAttrib_set_scale_1268, METH_O, (const char *)Dtool_ColorScaleAttrib_set_scale_1268_comment},
  {"get_class_slot", &Dtool_ColorScaleAttrib_get_class_slot_1272, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorScaleAttrib_get_class_slot_1272_comment},
  {"getClassSlot", &Dtool_ColorScaleAttrib_get_class_slot_1272, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorScaleAttrib_get_class_slot_1272_comment},
  {"get_class_type", &Dtool_ColorScaleAttrib_get_class_type_1274, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorScaleAttrib_get_class_type_1274_comment},
  {"getClassType", &Dtool_ColorScaleAttrib_get_class_type_1274, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorScaleAttrib_get_class_type_1274_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ColorScaleAttrib[] = {
  {(char *)"scale", &Dtool_ColorScaleAttrib_scale_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ColorScaleAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ColorScaleAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ColorScaleAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ColorScaleAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ColorScaleAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ColorScaleAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ColorScaleAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ColorScaleAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ColorScaleAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ColorScaleAttrib,
    &Dtool_SequenceMethods_ColorScaleAttrib,
    &Dtool_MappingMethods_ColorScaleAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ColorScaleAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Applies a scale to colors in the scene graph and on vertices.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ColorScaleAttrib,
    nullptr, // tp_members
    Dtool_Properties_ColorScaleAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ColorScaleAttrib,
    PyType_GenericAlloc,
    Dtool_new_ColorScaleAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ColorScaleAttrib,
  Dtool_UpcastInterface_ColorScaleAttrib,
  Dtool_DowncastInterface_ColorScaleAttrib,
  (CoerceFunction)Dtool_ConstCoerce_ColorScaleAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_ColorScaleAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_ColorScaleAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_ColorScaleAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ColorScaleAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_ColorScaleAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_ColorScaleAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_ColorScaleAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ColorScaleAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ColorScaleAttrib);
  }
}

/**
 * Python method tables for ColorWriteAttrib (ColorWriteAttrib)
 */
static PyMethodDef Dtool_Methods_ColorWriteAttrib[] = {
  {"make", &Dtool_ColorWriteAttrib_make_1278, METH_O | METH_STATIC, (const char *)Dtool_ColorWriteAttrib_make_1278_comment},
  {"make_default", &Dtool_ColorWriteAttrib_make_default_1279, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorWriteAttrib_make_default_1279_comment},
  {"makeDefault", &Dtool_ColorWriteAttrib_make_default_1279, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorWriteAttrib_make_default_1279_comment},
  {"get_channels", &Dtool_ColorWriteAttrib_get_channels_1280, METH_NOARGS, (const char *)Dtool_ColorWriteAttrib_get_channels_1280_comment},
  {"getChannels", &Dtool_ColorWriteAttrib_get_channels_1280, METH_NOARGS, (const char *)Dtool_ColorWriteAttrib_get_channels_1280_comment},
  {"get_class_slot", &Dtool_ColorWriteAttrib_get_class_slot_1283, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorWriteAttrib_get_class_slot_1283_comment},
  {"getClassSlot", &Dtool_ColorWriteAttrib_get_class_slot_1283, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorWriteAttrib_get_class_slot_1283_comment},
  {"get_class_type", &Dtool_ColorWriteAttrib_get_class_type_1285, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorWriteAttrib_get_class_type_1285_comment},
  {"getClassType", &Dtool_ColorWriteAttrib_get_class_type_1285, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorWriteAttrib_get_class_type_1285_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ColorWriteAttrib[] = {
  {(char *)"channels", &Dtool_ColorWriteAttrib_channels_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ColorWriteAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ColorWriteAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ColorWriteAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ColorWriteAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ColorWriteAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ColorWriteAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ColorWriteAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ColorWriteAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ColorWriteAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ColorWriteAttrib,
    &Dtool_SequenceMethods_ColorWriteAttrib,
    &Dtool_MappingMethods_ColorWriteAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ColorWriteAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Enables or disables writing to the color buffer.  This is primarily useful\n"
    " * for certain special effects in which it is important to write to the depth\n"
    " * buffer without affecting the color buffer.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ColorWriteAttrib,
    nullptr, // tp_members
    Dtool_Properties_ColorWriteAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ColorWriteAttrib,
    PyType_GenericAlloc,
    Dtool_new_ColorWriteAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ColorWriteAttrib,
  Dtool_UpcastInterface_ColorWriteAttrib,
  Dtool_DowncastInterface_ColorWriteAttrib,
  (CoerceFunction)Dtool_ConstCoerce_ColorWriteAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_ColorWriteAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_ColorWriteAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_ColorWriteAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(15);
    Dtool_ColorWriteAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ColorWriteAttrib::Channels;
    PyDict_SetItemString(dict, "C_off", Dtool_WrapValue(ColorWriteAttrib::C_off));
    PyDict_SetItemString(dict, "COff", Dtool_WrapValue(ColorWriteAttrib::C_off));
    PyDict_SetItemString(dict, "C_red", Dtool_WrapValue(ColorWriteAttrib::C_red));
    PyDict_SetItemString(dict, "CRed", Dtool_WrapValue(ColorWriteAttrib::C_red));
    PyDict_SetItemString(dict, "C_green", Dtool_WrapValue(ColorWriteAttrib::C_green));
    PyDict_SetItemString(dict, "CGreen", Dtool_WrapValue(ColorWriteAttrib::C_green));
    PyDict_SetItemString(dict, "C_blue", Dtool_WrapValue(ColorWriteAttrib::C_blue));
    PyDict_SetItemString(dict, "CBlue", Dtool_WrapValue(ColorWriteAttrib::C_blue));
    PyDict_SetItemString(dict, "C_rgb", Dtool_WrapValue(ColorWriteAttrib::C_rgb));
    PyDict_SetItemString(dict, "CRgb", Dtool_WrapValue(ColorWriteAttrib::C_rgb));
    PyDict_SetItemString(dict, "C_alpha", Dtool_WrapValue(ColorWriteAttrib::C_alpha));
    PyDict_SetItemString(dict, "CAlpha", Dtool_WrapValue(ColorWriteAttrib::C_alpha));
    PyDict_SetItemString(dict, "C_all", Dtool_WrapValue(ColorWriteAttrib::C_all));
    PyDict_SetItemString(dict, "CAll", Dtool_WrapValue(ColorWriteAttrib::C_all));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_ColorWriteAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_ColorWriteAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_ColorWriteAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ColorWriteAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ColorWriteAttrib);
  }
}

/**
 * Python method tables for CompassEffect (CompassEffect)
 */
static PyMethodDef Dtool_Methods_CompassEffect[] = {
  {"make", (PyCFunction) &Dtool_CompassEffect_make_1289, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_CompassEffect_make_1289_comment},
  {"get_reference", &Dtool_CompassEffect_get_reference_1290, METH_NOARGS, (const char *)Dtool_CompassEffect_get_reference_1290_comment},
  {"getReference", &Dtool_CompassEffect_get_reference_1290, METH_NOARGS, (const char *)Dtool_CompassEffect_get_reference_1290_comment},
  {"get_properties", &Dtool_CompassEffect_get_properties_1291, METH_NOARGS, (const char *)Dtool_CompassEffect_get_properties_1291_comment},
  {"getProperties", &Dtool_CompassEffect_get_properties_1291, METH_NOARGS, (const char *)Dtool_CompassEffect_get_properties_1291_comment},
  {"get_class_type", &Dtool_CompassEffect_get_class_type_1292, METH_NOARGS | METH_STATIC, (const char *)Dtool_CompassEffect_get_class_type_1292_comment},
  {"getClassType", &Dtool_CompassEffect_get_class_type_1292, METH_NOARGS | METH_STATIC, (const char *)Dtool_CompassEffect_get_class_type_1292_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CompassEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CompassEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CompassEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CompassEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CompassEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CompassEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CompassEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CompassEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CompassEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CompassEffect,
    &Dtool_SequenceMethods_CompassEffect,
    &Dtool_MappingMethods_CompassEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CompassEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A CompassEffect causes a node to inherit its rotation (or pos or scale, if\n"
    " * specified) from some other reference node in the graph, or more often from\n"
    " * the root.\n"
    " *\n"
    " * In its purest form, a CompassEffect is used to keep the node's rotation\n"
    " * fixed relative to the top of the scene graph, despite other transforms that\n"
    " * may exist above the node.  Hence the name: the node behaves like a magnetic\n"
    " * compass, always pointing in the same direction.\n"
    " *\n"
    " * As an couple of generalizing extensions, the CompassEffect may also be set\n"
    " * up to always orient its node according to some other reference node than\n"
    " * the root of the scene graph.  Furthermore, it may optionally adjust any of\n"
    " * pos, rotation, or scale, instead of necessarily rotation; and it may adjust\n"
    " * individual pos and scale components.  (Rotation may not be adjusted on an\n"
    " * individual component basis; that's just asking for trouble.)\n"
    " *\n"
    " * Be careful when using the pos and scale modes.  In these modes, it's\n"
    " * possible for the CompassEffect to move its node far from its normal\n"
    " * bounding volume, causing culling to fail.  If this is an issue, you may\n"
    " * need to explicitly set a large (or infinite) bounding volume on the effect\n"
    " * node.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CompassEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CompassEffect,
    PyType_GenericAlloc,
    Dtool_new_CompassEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CompassEffect,
  Dtool_UpcastInterface_CompassEffect,
  Dtool_DowncastInterface_CompassEffect,
  (CoerceFunction)Dtool_ConstCoerce_CompassEffect,
  nullptr,
};

static void Dtool_PyModuleClassInit_CompassEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderEffect(nullptr);
    Dtool_CompassEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderEffect);
    Dtool_CompassEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(21);
    Dtool_CompassEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum CompassEffect::Properties;
    PyDict_SetItemString(dict, "P_x", Dtool_WrapValue(CompassEffect::P_x));
    PyDict_SetItemString(dict, "PX", Dtool_WrapValue(CompassEffect::P_x));
    PyDict_SetItemString(dict, "P_y", Dtool_WrapValue(CompassEffect::P_y));
    PyDict_SetItemString(dict, "PY", Dtool_WrapValue(CompassEffect::P_y));
    PyDict_SetItemString(dict, "P_z", Dtool_WrapValue(CompassEffect::P_z));
    PyDict_SetItemString(dict, "PZ", Dtool_WrapValue(CompassEffect::P_z));
    PyDict_SetItemString(dict, "P_pos", Dtool_WrapValue(CompassEffect::P_pos));
    PyDict_SetItemString(dict, "PPos", Dtool_WrapValue(CompassEffect::P_pos));
    PyDict_SetItemString(dict, "P_rot", Dtool_WrapValue(CompassEffect::P_rot));
    PyDict_SetItemString(dict, "PRot", Dtool_WrapValue(CompassEffect::P_rot));
    PyDict_SetItemString(dict, "P_sx", Dtool_WrapValue(CompassEffect::P_sx));
    PyDict_SetItemString(dict, "PSx", Dtool_WrapValue(CompassEffect::P_sx));
    PyDict_SetItemString(dict, "P_sy", Dtool_WrapValue(CompassEffect::P_sy));
    PyDict_SetItemString(dict, "PSy", Dtool_WrapValue(CompassEffect::P_sy));
    PyDict_SetItemString(dict, "P_sz", Dtool_WrapValue(CompassEffect::P_sz));
    PyDict_SetItemString(dict, "PSz", Dtool_WrapValue(CompassEffect::P_sz));
    PyDict_SetItemString(dict, "P_scale", Dtool_WrapValue(CompassEffect::P_scale));
    PyDict_SetItemString(dict, "PScale", Dtool_WrapValue(CompassEffect::P_scale));
    PyDict_SetItemString(dict, "P_all", Dtool_WrapValue(CompassEffect::P_all));
    PyDict_SetItemString(dict, "PAll", Dtool_WrapValue(CompassEffect::P_all));
    if (PyType_Ready((PyTypeObject *)&Dtool_CompassEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CompassEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CompassEffect);
  }
}

/**
 * Python method tables for CullBinEnums (CullBinEnums)
 */
static PyMethodDef Dtool_Methods_CullBinEnums[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CullBinEnums = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_CullBinEnums = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CullBinEnums",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CullBinEnums,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CullBinEnums,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Provides scoping for the enumerated type shared by CullBin and\n"
    " * CullBinManager.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CullBinEnums,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CullBinEnums,
    PyType_GenericAlloc,
    Dtool_new_CullBinEnums,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CullBinEnums,
  Dtool_UpcastInterface_CullBinEnums,
  Dtool_DowncastInterface_CullBinEnums,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CullBinEnums(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CullBinEnums._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(13);
    Dtool_CullBinEnums._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum CullBinEnums::BinType;
    PyDict_SetItemString(dict, "BT_invalid", Dtool_WrapValue(CullBinEnums::BT_invalid));
    PyDict_SetItemString(dict, "BTInvalid", Dtool_WrapValue(CullBinEnums::BT_invalid));
    PyDict_SetItemString(dict, "BT_unsorted", Dtool_WrapValue(CullBinEnums::BT_unsorted));
    PyDict_SetItemString(dict, "BTUnsorted", Dtool_WrapValue(CullBinEnums::BT_unsorted));
    PyDict_SetItemString(dict, "BT_state_sorted", Dtool_WrapValue(CullBinEnums::BT_state_sorted));
    PyDict_SetItemString(dict, "BTStateSorted", Dtool_WrapValue(CullBinEnums::BT_state_sorted));
    PyDict_SetItemString(dict, "BT_back_to_front", Dtool_WrapValue(CullBinEnums::BT_back_to_front));
    PyDict_SetItemString(dict, "BTBackToFront", Dtool_WrapValue(CullBinEnums::BT_back_to_front));
    PyDict_SetItemString(dict, "BT_front_to_back", Dtool_WrapValue(CullBinEnums::BT_front_to_back));
    PyDict_SetItemString(dict, "BTFrontToBack", Dtool_WrapValue(CullBinEnums::BT_front_to_back));
    PyDict_SetItemString(dict, "BT_fixed", Dtool_WrapValue(CullBinEnums::BT_fixed));
    PyDict_SetItemString(dict, "BTFixed", Dtool_WrapValue(CullBinEnums::BT_fixed));
    if (PyType_Ready((PyTypeObject *)&Dtool_CullBinEnums) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CullBinEnums)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CullBinEnums);
  }
}

/**
 * Python method tables for GeomNode (GeomNode)
 */
static PyMethodDef Dtool_Methods_GeomNode[] = {
  {"set_preserved", &Dtool_GeomNode_set_preserved_1300, METH_O, (const char *)Dtool_GeomNode_set_preserved_1300_comment},
  {"setPreserved", &Dtool_GeomNode_set_preserved_1300, METH_O, (const char *)Dtool_GeomNode_set_preserved_1300_comment},
  {"get_preserved", &Dtool_GeomNode_get_preserved_1301, METH_NOARGS, (const char *)Dtool_GeomNode_get_preserved_1301_comment},
  {"getPreserved", &Dtool_GeomNode_get_preserved_1301, METH_NOARGS, (const char *)Dtool_GeomNode_get_preserved_1301_comment},
  {"get_num_geoms", &Dtool_GeomNode_get_num_geoms_1302, METH_NOARGS, (const char *)Dtool_GeomNode_get_num_geoms_1302_comment},
  {"getNumGeoms", &Dtool_GeomNode_get_num_geoms_1302, METH_NOARGS, (const char *)Dtool_GeomNode_get_num_geoms_1302_comment},
  {"get_geom", &Dtool_GeomNode_get_geom_1303, METH_O, (const char *)Dtool_GeomNode_get_geom_1303_comment},
  {"getGeom", &Dtool_GeomNode_get_geom_1303, METH_O, (const char *)Dtool_GeomNode_get_geom_1303_comment},
  {"modify_geom", &Dtool_GeomNode_modify_geom_1305, METH_O, (const char *)Dtool_GeomNode_modify_geom_1305_comment},
  {"modifyGeom", &Dtool_GeomNode_modify_geom_1305, METH_O, (const char *)Dtool_GeomNode_modify_geom_1305_comment},
  {"get_geom_state", &Dtool_GeomNode_get_geom_state_1307, METH_O, (const char *)Dtool_GeomNode_get_geom_state_1307_comment},
  {"getGeomState", &Dtool_GeomNode_get_geom_state_1307, METH_O, (const char *)Dtool_GeomNode_get_geom_state_1307_comment},
  {"set_geom_state", (PyCFunction) &Dtool_GeomNode_set_geom_state_1309, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomNode_set_geom_state_1309_comment},
  {"setGeomState", (PyCFunction) &Dtool_GeomNode_set_geom_state_1309, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomNode_set_geom_state_1309_comment},
  {"add_geom", (PyCFunction) &Dtool_GeomNode_add_geom_1310, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomNode_add_geom_1310_comment},
  {"addGeom", (PyCFunction) &Dtool_GeomNode_add_geom_1310, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomNode_add_geom_1310_comment},
  {"add_geoms_from", &Dtool_GeomNode_add_geoms_from_1311, METH_O, (const char *)Dtool_GeomNode_add_geoms_from_1311_comment},
  {"addGeomsFrom", &Dtool_GeomNode_add_geoms_from_1311, METH_O, (const char *)Dtool_GeomNode_add_geoms_from_1311_comment},
  {"set_geom", (PyCFunction) &Dtool_GeomNode_set_geom_1312, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomNode_set_geom_1312_comment},
  {"setGeom", (PyCFunction) &Dtool_GeomNode_set_geom_1312, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomNode_set_geom_1312_comment},
  {"remove_geom", &Dtool_GeomNode_remove_geom_1313, METH_O, (const char *)Dtool_GeomNode_remove_geom_1313_comment},
  {"removeGeom", &Dtool_GeomNode_remove_geom_1313, METH_O, (const char *)Dtool_GeomNode_remove_geom_1313_comment},
  {"remove_all_geoms", &Dtool_GeomNode_remove_all_geoms_1314, METH_NOARGS, (const char *)Dtool_GeomNode_remove_all_geoms_1314_comment},
  {"removeAllGeoms", &Dtool_GeomNode_remove_all_geoms_1314, METH_NOARGS, (const char *)Dtool_GeomNode_remove_all_geoms_1314_comment},
  {"check_valid", &Dtool_GeomNode_check_valid_1315, METH_NOARGS, (const char *)Dtool_GeomNode_check_valid_1315_comment},
  {"checkValid", &Dtool_GeomNode_check_valid_1315, METH_NOARGS, (const char *)Dtool_GeomNode_check_valid_1315_comment},
  {"decompose", &Dtool_GeomNode_decompose_1316, METH_NOARGS, (const char *)Dtool_GeomNode_decompose_1316_comment},
  {"unify", (PyCFunction) &Dtool_GeomNode_unify_1317, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomNode_unify_1317_comment},
  {"write_geoms", (PyCFunction) &Dtool_GeomNode_write_geoms_1318, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomNode_write_geoms_1318_comment},
  {"writeGeoms", (PyCFunction) &Dtool_GeomNode_write_geoms_1318, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomNode_write_geoms_1318_comment},
  {"write_verbose", (PyCFunction) &Dtool_GeomNode_write_verbose_1319, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomNode_write_verbose_1319_comment},
  {"writeVerbose", (PyCFunction) &Dtool_GeomNode_write_verbose_1319, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomNode_write_verbose_1319_comment},
  {"get_default_collide_mask", &Dtool_GeomNode_get_default_collide_mask_1320, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomNode_get_default_collide_mask_1320_comment},
  {"getDefaultCollideMask", &Dtool_GeomNode_get_default_collide_mask_1320, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomNode_get_default_collide_mask_1320_comment},
  {"get_class_type", &Dtool_GeomNode_get_class_type_1322, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomNode_get_class_type_1322_comment},
  {"getClassType", &Dtool_GeomNode_get_class_type_1322, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomNode_get_class_type_1322_comment},
  {"get_geoms", (PyCFunction) &MakeSeq_GeomNode_get_geoms, METH_NOARGS, nullptr},
  { "getGeoms", (PyCFunction) &MakeSeq_GeomNode_get_geoms, METH_NOARGS, nullptr},
  {"modify_geoms", (PyCFunction) &MakeSeq_GeomNode_modify_geoms, METH_NOARGS, nullptr},
  { "modifyGeoms", (PyCFunction) &MakeSeq_GeomNode_modify_geoms, METH_NOARGS, nullptr},
  {"get_geom_states", (PyCFunction) &MakeSeq_GeomNode_get_geom_states, METH_NOARGS, nullptr},
  { "getGeomStates", (PyCFunction) &MakeSeq_GeomNode_get_geom_states, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomNode,
    &Dtool_SequenceMethods_GeomNode,
    &Dtool_MappingMethods_GeomNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node that holds Geom objects, renderable pieces of geometry.  This is the\n"
    " * primary kind of leaf node in the scene graph; almost all visible objects\n"
    " * will be contained in a GeomNode somewhere.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomNode,
    PyType_GenericAlloc,
    Dtool_new_GeomNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomNode,
  Dtool_UpcastInterface_GeomNode,
  Dtool_DowncastInterface_GeomNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PandaNode(nullptr);
    Dtool_GeomNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PandaNode);
    Dtool_GeomNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_default_collide_mask = {(char *)"default_collide_mask", &Dtool_GeomNode_default_collide_mask_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "default_collide_mask", Dtool_NewStaticProperty(&Dtool_GeomNode._PyType, &def_default_collide_mask));
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomNode);
  }
}

/**
 * Python method tables for CullBinAttrib (CullBinAttrib)
 */
static PyMethodDef Dtool_Methods_CullBinAttrib[] = {
  {"make", (PyCFunction) &Dtool_CullBinAttrib_make_1324, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_CullBinAttrib_make_1324_comment},
  {"make_default", &Dtool_CullBinAttrib_make_default_1325, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullBinAttrib_make_default_1325_comment},
  {"makeDefault", &Dtool_CullBinAttrib_make_default_1325, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullBinAttrib_make_default_1325_comment},
  {"get_bin_name", &Dtool_CullBinAttrib_get_bin_name_1326, METH_NOARGS, (const char *)Dtool_CullBinAttrib_get_bin_name_1326_comment},
  {"getBinName", &Dtool_CullBinAttrib_get_bin_name_1326, METH_NOARGS, (const char *)Dtool_CullBinAttrib_get_bin_name_1326_comment},
  {"get_draw_order", &Dtool_CullBinAttrib_get_draw_order_1327, METH_NOARGS, (const char *)Dtool_CullBinAttrib_get_draw_order_1327_comment},
  {"getDrawOrder", &Dtool_CullBinAttrib_get_draw_order_1327, METH_NOARGS, (const char *)Dtool_CullBinAttrib_get_draw_order_1327_comment},
  {"get_class_slot", &Dtool_CullBinAttrib_get_class_slot_1330, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullBinAttrib_get_class_slot_1330_comment},
  {"getClassSlot", &Dtool_CullBinAttrib_get_class_slot_1330, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullBinAttrib_get_class_slot_1330_comment},
  {"get_class_type", &Dtool_CullBinAttrib_get_class_type_1332, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullBinAttrib_get_class_type_1332_comment},
  {"getClassType", &Dtool_CullBinAttrib_get_class_type_1332, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullBinAttrib_get_class_type_1332_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CullBinAttrib[] = {
  {(char *)"bin_name", &Dtool_CullBinAttrib_bin_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"draw_order", &Dtool_CullBinAttrib_draw_order_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CullBinAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CullBinAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CullBinAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CullBinAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CullBinAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CullBinAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CullBinAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CullBinAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CullBinAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CullBinAttrib,
    &Dtool_SequenceMethods_CullBinAttrib,
    &Dtool_MappingMethods_CullBinAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CullBinAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Assigns geometry to a particular bin by name.  The bins must be created\n"
    " * separately via the CullBinManager interface.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CullBinAttrib,
    nullptr, // tp_members
    Dtool_Properties_CullBinAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CullBinAttrib,
    PyType_GenericAlloc,
    Dtool_new_CullBinAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CullBinAttrib,
  Dtool_UpcastInterface_CullBinAttrib,
  Dtool_DowncastInterface_CullBinAttrib,
  (CoerceFunction)Dtool_ConstCoerce_CullBinAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_CullBinAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_CullBinAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_CullBinAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CullBinAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_CullBinAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_CullBinAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_CullBinAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CullBinAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CullBinAttrib);
  }
}

/**
 * Python method tables for CullBinManager (CullBinManager)
 */
static PyMethodDef Dtool_Methods_CullBinManager[] = {
  {"add_bin", (PyCFunction) &Dtool_CullBinManager_add_bin_1335, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_add_bin_1335_comment},
  {"addBin", (PyCFunction) &Dtool_CullBinManager_add_bin_1335, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_add_bin_1335_comment},
  {"remove_bin", &Dtool_CullBinManager_remove_bin_1336, METH_O, (const char *)Dtool_CullBinManager_remove_bin_1336_comment},
  {"removeBin", &Dtool_CullBinManager_remove_bin_1336, METH_O, (const char *)Dtool_CullBinManager_remove_bin_1336_comment},
  {"get_num_bins", &Dtool_CullBinManager_get_num_bins_1337, METH_NOARGS, (const char *)Dtool_CullBinManager_get_num_bins_1337_comment},
  {"getNumBins", &Dtool_CullBinManager_get_num_bins_1337, METH_NOARGS, (const char *)Dtool_CullBinManager_get_num_bins_1337_comment},
  {"get_bin", &Dtool_CullBinManager_get_bin_1338, METH_O, (const char *)Dtool_CullBinManager_get_bin_1338_comment},
  {"getBin", &Dtool_CullBinManager_get_bin_1338, METH_O, (const char *)Dtool_CullBinManager_get_bin_1338_comment},
  {"find_bin", &Dtool_CullBinManager_find_bin_1340, METH_O, (const char *)Dtool_CullBinManager_find_bin_1340_comment},
  {"findBin", &Dtool_CullBinManager_find_bin_1340, METH_O, (const char *)Dtool_CullBinManager_find_bin_1340_comment},
  {"get_bin_name", &Dtool_CullBinManager_get_bin_name_1341, METH_O, (const char *)Dtool_CullBinManager_get_bin_name_1341_comment},
  {"getBinName", &Dtool_CullBinManager_get_bin_name_1341, METH_O, (const char *)Dtool_CullBinManager_get_bin_name_1341_comment},
  {"get_bin_type", &Dtool_CullBinManager_get_bin_type_1342, METH_O, (const char *)Dtool_CullBinManager_get_bin_type_1342_comment},
  {"getBinType", &Dtool_CullBinManager_get_bin_type_1342, METH_O, (const char *)Dtool_CullBinManager_get_bin_type_1342_comment},
  {"set_bin_type", (PyCFunction) &Dtool_CullBinManager_set_bin_type_1343, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_set_bin_type_1343_comment},
  {"setBinType", (PyCFunction) &Dtool_CullBinManager_set_bin_type_1343, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_set_bin_type_1343_comment},
  {"get_bin_sort", &Dtool_CullBinManager_get_bin_sort_1344, METH_O, (const char *)Dtool_CullBinManager_get_bin_sort_1344_comment},
  {"getBinSort", &Dtool_CullBinManager_get_bin_sort_1344, METH_O, (const char *)Dtool_CullBinManager_get_bin_sort_1344_comment},
  {"set_bin_sort", (PyCFunction) &Dtool_CullBinManager_set_bin_sort_1345, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_set_bin_sort_1345_comment},
  {"setBinSort", (PyCFunction) &Dtool_CullBinManager_set_bin_sort_1345, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_set_bin_sort_1345_comment},
  {"get_bin_active", &Dtool_CullBinManager_get_bin_active_1346, METH_O, (const char *)Dtool_CullBinManager_get_bin_active_1346_comment},
  {"getBinActive", &Dtool_CullBinManager_get_bin_active_1346, METH_O, (const char *)Dtool_CullBinManager_get_bin_active_1346_comment},
  {"set_bin_active", (PyCFunction) &Dtool_CullBinManager_set_bin_active_1347, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_set_bin_active_1347_comment},
  {"setBinActive", (PyCFunction) &Dtool_CullBinManager_set_bin_active_1347, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_set_bin_active_1347_comment},
  {"get_bin_flash_active", &Dtool_CullBinManager_get_bin_flash_active_1348, METH_O, (const char *)Dtool_CullBinManager_get_bin_flash_active_1348_comment},
  {"getBinFlashActive", &Dtool_CullBinManager_get_bin_flash_active_1348, METH_O, (const char *)Dtool_CullBinManager_get_bin_flash_active_1348_comment},
  {"get_bin_flash_color", &Dtool_CullBinManager_get_bin_flash_color_1349, METH_O, (const char *)Dtool_CullBinManager_get_bin_flash_color_1349_comment},
  {"getBinFlashColor", &Dtool_CullBinManager_get_bin_flash_color_1349, METH_O, (const char *)Dtool_CullBinManager_get_bin_flash_color_1349_comment},
  {"set_bin_flash_active", (PyCFunction) &Dtool_CullBinManager_set_bin_flash_active_1350, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_set_bin_flash_active_1350_comment},
  {"setBinFlashActive", (PyCFunction) &Dtool_CullBinManager_set_bin_flash_active_1350, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_set_bin_flash_active_1350_comment},
  {"set_bin_flash_color", (PyCFunction) &Dtool_CullBinManager_set_bin_flash_color_1351, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_set_bin_flash_color_1351_comment},
  {"setBinFlashColor", (PyCFunction) &Dtool_CullBinManager_set_bin_flash_color_1351, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullBinManager_set_bin_flash_color_1351_comment},
  {"write", &Dtool_CullBinManager_write_1352, METH_O, (const char *)Dtool_CullBinManager_write_1352_comment},
  {"get_global_ptr", &Dtool_CullBinManager_get_global_ptr_1353, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullBinManager_get_global_ptr_1353_comment},
  {"getGlobalPtr", &Dtool_CullBinManager_get_global_ptr_1353, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullBinManager_get_global_ptr_1353_comment},
  {"get_bins", (PyCFunction) &MakeSeq_CullBinManager_get_bins, METH_NOARGS, nullptr},
  { "getBins", (PyCFunction) &MakeSeq_CullBinManager_get_bins, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     CullBinManager
//////////////////
static PyObject *Dtool_Str_CullBinManager(PyObject *self) {
  CullBinManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CullBinManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_CullBinManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CullBinManager = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CullBinManager = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CullBinManager = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CullBinManager = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CullBinManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CullBinManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CullBinManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CullBinManager,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CullBinManager,
    &Dtool_SequenceMethods_CullBinManager,
    &Dtool_MappingMethods_CullBinManager,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_CullBinManager,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CullBinManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a global object that maintains the collection of named CullBins in\n"
    " * the world.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CullBinManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CullBinManager,
    PyType_GenericAlloc,
    Dtool_new_CullBinManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CullBinManager,
  Dtool_UpcastInterface_CullBinManager,
  Dtool_DowncastInterface_CullBinManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CullBinManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CullBinEnums(nullptr);
    Dtool_CullBinManager._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CullBinEnums);
    Dtool_CullBinManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CullBinManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CullBinManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CullBinManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CullBinManager);
  }
}

/**
 * Python method tables for CullFaceAttrib (CullFaceAttrib)
 */
static PyMethodDef Dtool_Methods_CullFaceAttrib[] = {
  {"make", (PyCFunction) &Dtool_CullFaceAttrib_make_1356, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_CullFaceAttrib_make_1356_comment},
  {"make_reverse", &Dtool_CullFaceAttrib_make_reverse_1357, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullFaceAttrib_make_reverse_1357_comment},
  {"makeReverse", &Dtool_CullFaceAttrib_make_reverse_1357, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullFaceAttrib_make_reverse_1357_comment},
  {"make_default", &Dtool_CullFaceAttrib_make_default_1358, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullFaceAttrib_make_default_1358_comment},
  {"makeDefault", &Dtool_CullFaceAttrib_make_default_1358, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullFaceAttrib_make_default_1358_comment},
  {"get_actual_mode", &Dtool_CullFaceAttrib_get_actual_mode_1359, METH_NOARGS, (const char *)Dtool_CullFaceAttrib_get_actual_mode_1359_comment},
  {"getActualMode", &Dtool_CullFaceAttrib_get_actual_mode_1359, METH_NOARGS, (const char *)Dtool_CullFaceAttrib_get_actual_mode_1359_comment},
  {"get_reverse", &Dtool_CullFaceAttrib_get_reverse_1360, METH_NOARGS, (const char *)Dtool_CullFaceAttrib_get_reverse_1360_comment},
  {"getReverse", &Dtool_CullFaceAttrib_get_reverse_1360, METH_NOARGS, (const char *)Dtool_CullFaceAttrib_get_reverse_1360_comment},
  {"get_effective_mode", &Dtool_CullFaceAttrib_get_effective_mode_1361, METH_NOARGS, (const char *)Dtool_CullFaceAttrib_get_effective_mode_1361_comment},
  {"getEffectiveMode", &Dtool_CullFaceAttrib_get_effective_mode_1361, METH_NOARGS, (const char *)Dtool_CullFaceAttrib_get_effective_mode_1361_comment},
  {"get_class_slot", &Dtool_CullFaceAttrib_get_class_slot_1365, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullFaceAttrib_get_class_slot_1365_comment},
  {"getClassSlot", &Dtool_CullFaceAttrib_get_class_slot_1365, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullFaceAttrib_get_class_slot_1365_comment},
  {"get_class_type", &Dtool_CullFaceAttrib_get_class_type_1367, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullFaceAttrib_get_class_type_1367_comment},
  {"getClassType", &Dtool_CullFaceAttrib_get_class_type_1367, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullFaceAttrib_get_class_type_1367_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CullFaceAttrib[] = {
  {(char *)"mode", &Dtool_CullFaceAttrib_mode_Getter, nullptr, nullptr, nullptr},
  {(char *)"reverse", &Dtool_CullFaceAttrib_reverse_Getter, nullptr, nullptr, nullptr},
  {(char *)"effective_mode", &Dtool_CullFaceAttrib_effective_mode_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CullFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CullFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CullFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CullFaceAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CullFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CullFaceAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CullFaceAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CullFaceAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CullFaceAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CullFaceAttrib,
    &Dtool_SequenceMethods_CullFaceAttrib,
    &Dtool_MappingMethods_CullFaceAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CullFaceAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Indicates which faces should be culled based on their vertex ordering.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CullFaceAttrib,
    nullptr, // tp_members
    Dtool_Properties_CullFaceAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CullFaceAttrib,
    PyType_GenericAlloc,
    Dtool_new_CullFaceAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CullFaceAttrib,
  Dtool_UpcastInterface_CullFaceAttrib,
  Dtool_DowncastInterface_CullFaceAttrib,
  (CoerceFunction)Dtool_ConstCoerce_CullFaceAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_CullFaceAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_CullFaceAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_CullFaceAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_CullFaceAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum CullFaceAttrib::Mode;
    PyDict_SetItemString(dict, "M_cull_none", Dtool_WrapValue(CullFaceAttrib::M_cull_none));
    PyDict_SetItemString(dict, "MCullNone", Dtool_WrapValue(CullFaceAttrib::M_cull_none));
    PyDict_SetItemString(dict, "M_cull_clockwise", Dtool_WrapValue(CullFaceAttrib::M_cull_clockwise));
    PyDict_SetItemString(dict, "MCullClockwise", Dtool_WrapValue(CullFaceAttrib::M_cull_clockwise));
    PyDict_SetItemString(dict, "M_cull_counter_clockwise", Dtool_WrapValue(CullFaceAttrib::M_cull_counter_clockwise));
    PyDict_SetItemString(dict, "MCullCounterClockwise", Dtool_WrapValue(CullFaceAttrib::M_cull_counter_clockwise));
    PyDict_SetItemString(dict, "M_cull_unchanged", Dtool_WrapValue(CullFaceAttrib::M_cull_unchanged));
    PyDict_SetItemString(dict, "MCullUnchanged", Dtool_WrapValue(CullFaceAttrib::M_cull_unchanged));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_CullFaceAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_CullFaceAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_CullFaceAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CullFaceAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CullFaceAttrib);
  }
}

/**
 * Python method tables for WorkingNodePath (WorkingNodePath)
 */
static PyMethodDef Dtool_Methods_WorkingNodePath[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_WorkingNodePath[] = {
  {(char *)"valid", &Dtool_WorkingNodePath_valid_Getter, nullptr, nullptr, nullptr},
  {(char *)"node_path", &Dtool_WorkingNodePath_node_path_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_WorkingNodePath = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_WorkingNodePath = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.WorkingNodePath",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_WorkingNodePath,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_WorkingNodePath,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a class designed to support low-overhead traversals of the complete\n"
    " * scene graph, with a memory of the complete path through the graph at any\n"
    " * given point.\n"
    " *\n"
    " * You could just use a regular NodePath to do this, but since the NodePath\n"
    " * requires storing NodePathComponents on each node as it is constructed, and\n"
    " * then removing them when it destructs, there is considerable overhead in\n"
    " * that approach.\n"
    " *\n"
    " * The WorkingNodePath eliminates this overhead (but does not guarantee\n"
    " * consistency if the scene graph changes while the path is held).\n"
    " *\n"
    " * At any given point, you may ask the WorkingNodePath for its actual\n"
    " * NodePath, and it will construct and return a new NodePath representing the\n"
    " * complete generated chain.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_WorkingNodePath,
    nullptr, // tp_members
    Dtool_Properties_WorkingNodePath,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_WorkingNodePath,
    PyType_GenericAlloc,
    Dtool_new_WorkingNodePath,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WorkingNodePath,
  Dtool_UpcastInterface_WorkingNodePath,
  Dtool_DowncastInterface_WorkingNodePath,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_WorkingNodePath(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_WorkingNodePath._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_WorkingNodePath._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WorkingNodePath) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WorkingNodePath)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WorkingNodePath);
  }
}

/**
 * Python method tables for CullTraverserData (CullTraverserData)
 */
static PyMethodDef Dtool_Methods_CullTraverserData[] = {
  {"node", &Dtool_CullTraverserData_node_1376, METH_NOARGS, (const char *)Dtool_CullTraverserData_node_1376_comment},
  {"get_modelview_transform", &Dtool_CullTraverserData_get_modelview_transform_1377, METH_O, (const char *)Dtool_CullTraverserData_get_modelview_transform_1377_comment},
  {"getModelviewTransform", &Dtool_CullTraverserData_get_modelview_transform_1377, METH_O, (const char *)Dtool_CullTraverserData_get_modelview_transform_1377_comment},
  {"get_internal_transform", &Dtool_CullTraverserData_get_internal_transform_1378, METH_O, (const char *)Dtool_CullTraverserData_get_internal_transform_1378_comment},
  {"getInternalTransform", &Dtool_CullTraverserData_get_internal_transform_1378, METH_O, (const char *)Dtool_CullTraverserData_get_internal_transform_1378_comment},
  {"get_net_transform", &Dtool_CullTraverserData_get_net_transform_1379, METH_O, (const char *)Dtool_CullTraverserData_get_net_transform_1379_comment},
  {"getNetTransform", &Dtool_CullTraverserData_get_net_transform_1379, METH_O, (const char *)Dtool_CullTraverserData_get_net_transform_1379_comment},
  {"is_in_view", &Dtool_CullTraverserData_is_in_view_1380, METH_O, (const char *)Dtool_CullTraverserData_is_in_view_1380_comment},
  {"isInView", &Dtool_CullTraverserData_is_in_view_1380, METH_O, (const char *)Dtool_CullTraverserData_is_in_view_1380_comment},
  {"is_this_node_hidden", &Dtool_CullTraverserData_is_this_node_hidden_1381, METH_O, (const char *)Dtool_CullTraverserData_is_this_node_hidden_1381_comment},
  {"isThisNodeHidden", &Dtool_CullTraverserData_is_this_node_hidden_1381, METH_O, (const char *)Dtool_CullTraverserData_is_this_node_hidden_1381_comment},
  {"apply_transform_and_state", &Dtool_CullTraverserData_apply_transform_and_state_1382, METH_O, (const char *)Dtool_CullTraverserData_apply_transform_and_state_1382_comment},
  {"applyTransformAndState", &Dtool_CullTraverserData_apply_transform_and_state_1382, METH_O, (const char *)Dtool_CullTraverserData_apply_transform_and_state_1382_comment},
  {"apply_transform", &Dtool_CullTraverserData_apply_transform_1383, METH_O, (const char *)Dtool_CullTraverserData_apply_transform_1383_comment},
  {"applyTransform", &Dtool_CullTraverserData_apply_transform_1383, METH_O, (const char *)Dtool_CullTraverserData_apply_transform_1383_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CullTraverserData[] = {
  {(char *)"node_path", &Dtool_CullTraverserData_node_path_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CullTraverserData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_CullTraverserData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CullTraverserData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CullTraverserData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CullTraverserData,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This collects together the pieces of data that are accumulated for each\n"
    " * node while walking the scene graph during the cull traversal.\n"
    " *\n"
    " * Having this as a separate object simplifies the parameter list to\n"
    " * CullTraverser::r_traverse(), as well as to other functions like\n"
    " * PandaNode::cull_callback().  It also makes it easier to add cull\n"
    " * parameters, and provides a place to abstract out some of the cull behavior\n"
    " * (like view-frustum culling).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CullTraverserData,
    nullptr, // tp_members
    Dtool_Properties_CullTraverserData,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CullTraverserData,
    PyType_GenericAlloc,
    Dtool_new_CullTraverserData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CullTraverserData,
  Dtool_UpcastInterface_CullTraverserData,
  Dtool_DowncastInterface_CullTraverserData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CullTraverserData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CullTraverserData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CullTraverserData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CullTraverserData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CullTraverserData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CullTraverserData);
  }
}

/**
 * Python method tables for SceneSetup (SceneSetup)
 */
static PyMethodDef Dtool_Methods_SceneSetup[] = {
  {"set_display_region", &Dtool_SceneSetup_set_display_region_1389, METH_O, (const char *)Dtool_SceneSetup_set_display_region_1389_comment},
  {"setDisplayRegion", &Dtool_SceneSetup_set_display_region_1389, METH_O, (const char *)Dtool_SceneSetup_set_display_region_1389_comment},
  {"get_display_region", &Dtool_SceneSetup_get_display_region_1390, METH_NOARGS, (const char *)Dtool_SceneSetup_get_display_region_1390_comment},
  {"getDisplayRegion", &Dtool_SceneSetup_get_display_region_1390, METH_NOARGS, (const char *)Dtool_SceneSetup_get_display_region_1390_comment},
  {"set_viewport_size", (PyCFunction) &Dtool_SceneSetup_set_viewport_size_1391, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneSetup_set_viewport_size_1391_comment},
  {"setViewportSize", (PyCFunction) &Dtool_SceneSetup_set_viewport_size_1391, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneSetup_set_viewport_size_1391_comment},
  {"get_viewport_width", &Dtool_SceneSetup_get_viewport_width_1392, METH_NOARGS, (const char *)Dtool_SceneSetup_get_viewport_width_1392_comment},
  {"getViewportWidth", &Dtool_SceneSetup_get_viewport_width_1392, METH_NOARGS, (const char *)Dtool_SceneSetup_get_viewport_width_1392_comment},
  {"get_viewport_height", &Dtool_SceneSetup_get_viewport_height_1393, METH_NOARGS, (const char *)Dtool_SceneSetup_get_viewport_height_1393_comment},
  {"getViewportHeight", &Dtool_SceneSetup_get_viewport_height_1393, METH_NOARGS, (const char *)Dtool_SceneSetup_get_viewport_height_1393_comment},
  {"set_scene_root", &Dtool_SceneSetup_set_scene_root_1394, METH_O, (const char *)Dtool_SceneSetup_set_scene_root_1394_comment},
  {"setSceneRoot", &Dtool_SceneSetup_set_scene_root_1394, METH_O, (const char *)Dtool_SceneSetup_set_scene_root_1394_comment},
  {"get_scene_root", &Dtool_SceneSetup_get_scene_root_1395, METH_NOARGS, (const char *)Dtool_SceneSetup_get_scene_root_1395_comment},
  {"getSceneRoot", &Dtool_SceneSetup_get_scene_root_1395, METH_NOARGS, (const char *)Dtool_SceneSetup_get_scene_root_1395_comment},
  {"set_camera_path", &Dtool_SceneSetup_set_camera_path_1396, METH_O, (const char *)Dtool_SceneSetup_set_camera_path_1396_comment},
  {"setCameraPath", &Dtool_SceneSetup_set_camera_path_1396, METH_O, (const char *)Dtool_SceneSetup_set_camera_path_1396_comment},
  {"get_camera_path", &Dtool_SceneSetup_get_camera_path_1397, METH_NOARGS, (const char *)Dtool_SceneSetup_get_camera_path_1397_comment},
  {"getCameraPath", &Dtool_SceneSetup_get_camera_path_1397, METH_NOARGS, (const char *)Dtool_SceneSetup_get_camera_path_1397_comment},
  {"set_camera_node", &Dtool_SceneSetup_set_camera_node_1398, METH_O, (const char *)Dtool_SceneSetup_set_camera_node_1398_comment},
  {"setCameraNode", &Dtool_SceneSetup_set_camera_node_1398, METH_O, (const char *)Dtool_SceneSetup_set_camera_node_1398_comment},
  {"get_camera_node", &Dtool_SceneSetup_get_camera_node_1399, METH_NOARGS, (const char *)Dtool_SceneSetup_get_camera_node_1399_comment},
  {"getCameraNode", &Dtool_SceneSetup_get_camera_node_1399, METH_NOARGS, (const char *)Dtool_SceneSetup_get_camera_node_1399_comment},
  {"set_lens", &Dtool_SceneSetup_set_lens_1400, METH_O, (const char *)Dtool_SceneSetup_set_lens_1400_comment},
  {"setLens", &Dtool_SceneSetup_set_lens_1400, METH_O, (const char *)Dtool_SceneSetup_set_lens_1400_comment},
  {"get_lens", &Dtool_SceneSetup_get_lens_1401, METH_NOARGS, (const char *)Dtool_SceneSetup_get_lens_1401_comment},
  {"getLens", &Dtool_SceneSetup_get_lens_1401, METH_NOARGS, (const char *)Dtool_SceneSetup_get_lens_1401_comment},
  {"set_inverted", &Dtool_SceneSetup_set_inverted_1402, METH_O, (const char *)Dtool_SceneSetup_set_inverted_1402_comment},
  {"setInverted", &Dtool_SceneSetup_set_inverted_1402, METH_O, (const char *)Dtool_SceneSetup_set_inverted_1402_comment},
  {"get_inverted", &Dtool_SceneSetup_get_inverted_1403, METH_NOARGS, (const char *)Dtool_SceneSetup_get_inverted_1403_comment},
  {"getInverted", &Dtool_SceneSetup_get_inverted_1403, METH_NOARGS, (const char *)Dtool_SceneSetup_get_inverted_1403_comment},
  {"get_cull_center", &Dtool_SceneSetup_get_cull_center_1404, METH_NOARGS, (const char *)Dtool_SceneSetup_get_cull_center_1404_comment},
  {"getCullCenter", &Dtool_SceneSetup_get_cull_center_1404, METH_NOARGS, (const char *)Dtool_SceneSetup_get_cull_center_1404_comment},
  {"get_cull_bounds", &Dtool_SceneSetup_get_cull_bounds_1405, METH_NOARGS, (const char *)Dtool_SceneSetup_get_cull_bounds_1405_comment},
  {"getCullBounds", &Dtool_SceneSetup_get_cull_bounds_1405, METH_NOARGS, (const char *)Dtool_SceneSetup_get_cull_bounds_1405_comment},
  {"set_view_frustum", &Dtool_SceneSetup_set_view_frustum_1406, METH_O, (const char *)Dtool_SceneSetup_set_view_frustum_1406_comment},
  {"setViewFrustum", &Dtool_SceneSetup_set_view_frustum_1406, METH_O, (const char *)Dtool_SceneSetup_set_view_frustum_1406_comment},
  {"get_view_frustum", &Dtool_SceneSetup_get_view_frustum_1407, METH_NOARGS, (const char *)Dtool_SceneSetup_get_view_frustum_1407_comment},
  {"getViewFrustum", &Dtool_SceneSetup_get_view_frustum_1407, METH_NOARGS, (const char *)Dtool_SceneSetup_get_view_frustum_1407_comment},
  {"set_initial_state", &Dtool_SceneSetup_set_initial_state_1408, METH_O, (const char *)Dtool_SceneSetup_set_initial_state_1408_comment},
  {"setInitialState", &Dtool_SceneSetup_set_initial_state_1408, METH_O, (const char *)Dtool_SceneSetup_set_initial_state_1408_comment},
  {"get_initial_state", &Dtool_SceneSetup_get_initial_state_1409, METH_NOARGS, (const char *)Dtool_SceneSetup_get_initial_state_1409_comment},
  {"getInitialState", &Dtool_SceneSetup_get_initial_state_1409, METH_NOARGS, (const char *)Dtool_SceneSetup_get_initial_state_1409_comment},
  {"set_camera_transform", &Dtool_SceneSetup_set_camera_transform_1410, METH_O, (const char *)Dtool_SceneSetup_set_camera_transform_1410_comment},
  {"setCameraTransform", &Dtool_SceneSetup_set_camera_transform_1410, METH_O, (const char *)Dtool_SceneSetup_set_camera_transform_1410_comment},
  {"get_camera_transform", &Dtool_SceneSetup_get_camera_transform_1411, METH_NOARGS, (const char *)Dtool_SceneSetup_get_camera_transform_1411_comment},
  {"getCameraTransform", &Dtool_SceneSetup_get_camera_transform_1411, METH_NOARGS, (const char *)Dtool_SceneSetup_get_camera_transform_1411_comment},
  {"set_world_transform", &Dtool_SceneSetup_set_world_transform_1412, METH_O, (const char *)Dtool_SceneSetup_set_world_transform_1412_comment},
  {"setWorldTransform", &Dtool_SceneSetup_set_world_transform_1412, METH_O, (const char *)Dtool_SceneSetup_set_world_transform_1412_comment},
  {"get_world_transform", &Dtool_SceneSetup_get_world_transform_1413, METH_NOARGS, (const char *)Dtool_SceneSetup_get_world_transform_1413_comment},
  {"getWorldTransform", &Dtool_SceneSetup_get_world_transform_1413, METH_NOARGS, (const char *)Dtool_SceneSetup_get_world_transform_1413_comment},
  {"set_cs_transform", &Dtool_SceneSetup_set_cs_transform_1414, METH_O, (const char *)Dtool_SceneSetup_set_cs_transform_1414_comment},
  {"setCsTransform", &Dtool_SceneSetup_set_cs_transform_1414, METH_O, (const char *)Dtool_SceneSetup_set_cs_transform_1414_comment},
  {"get_cs_transform", &Dtool_SceneSetup_get_cs_transform_1415, METH_NOARGS, (const char *)Dtool_SceneSetup_get_cs_transform_1415_comment},
  {"getCsTransform", &Dtool_SceneSetup_get_cs_transform_1415, METH_NOARGS, (const char *)Dtool_SceneSetup_get_cs_transform_1415_comment},
  {"set_cs_world_transform", &Dtool_SceneSetup_set_cs_world_transform_1416, METH_O, (const char *)Dtool_SceneSetup_set_cs_world_transform_1416_comment},
  {"setCsWorldTransform", &Dtool_SceneSetup_set_cs_world_transform_1416, METH_O, (const char *)Dtool_SceneSetup_set_cs_world_transform_1416_comment},
  {"get_cs_world_transform", &Dtool_SceneSetup_get_cs_world_transform_1417, METH_NOARGS, (const char *)Dtool_SceneSetup_get_cs_world_transform_1417_comment},
  {"getCsWorldTransform", &Dtool_SceneSetup_get_cs_world_transform_1417, METH_NOARGS, (const char *)Dtool_SceneSetup_get_cs_world_transform_1417_comment},
  {"get_class_type", &Dtool_SceneSetup_get_class_type_1418, METH_NOARGS | METH_STATIC, (const char *)Dtool_SceneSetup_get_class_type_1418_comment},
  {"getClassType", &Dtool_SceneSetup_get_class_type_1418, METH_NOARGS | METH_STATIC, (const char *)Dtool_SceneSetup_get_class_type_1418_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_SceneSetup = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SceneSetup = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SceneSetup = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SceneSetup = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SceneSetup = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SceneSetup = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SceneSetup",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SceneSetup,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SceneSetup,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SceneSetup,
    &Dtool_SequenceMethods_SceneSetup,
    &Dtool_MappingMethods_SceneSetup,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SceneSetup,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object holds the camera position, etc., and other general setup\n"
    " * information for rendering a particular scene.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SceneSetup,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SceneSetup,
    PyType_GenericAlloc,
    Dtool_new_SceneSetup,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SceneSetup,
  Dtool_UpcastInterface_SceneSetup,
  Dtool_DowncastInterface_SceneSetup,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SceneSetup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_SceneSetup._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_SceneSetup._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SceneSetup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SceneSetup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SceneSetup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SceneSetup);
  }
}

/**
 * Python method tables for Fog (Fog)
 */
static PyMethodDef Dtool_Methods_Fog[] = {
  {"get_mode", &Dtool_Fog_get_mode_1424, METH_NOARGS, (const char *)Dtool_Fog_get_mode_1424_comment},
  {"getMode", &Dtool_Fog_get_mode_1424, METH_NOARGS, (const char *)Dtool_Fog_get_mode_1424_comment},
  {"set_mode", &Dtool_Fog_set_mode_1425, METH_O, (const char *)Dtool_Fog_set_mode_1425_comment},
  {"setMode", &Dtool_Fog_set_mode_1425, METH_O, (const char *)Dtool_Fog_set_mode_1425_comment},
  {"get_color", &Dtool_Fog_get_color_1427, METH_NOARGS, (const char *)Dtool_Fog_get_color_1427_comment},
  {"getColor", &Dtool_Fog_get_color_1427, METH_NOARGS, (const char *)Dtool_Fog_get_color_1427_comment},
  {"set_color", (PyCFunction) &Dtool_Fog_set_color_1428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Fog_set_color_1428_comment},
  {"setColor", (PyCFunction) &Dtool_Fog_set_color_1428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Fog_set_color_1428_comment},
  {"set_linear_range", (PyCFunction) &Dtool_Fog_set_linear_range_1430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Fog_set_linear_range_1430_comment},
  {"setLinearRange", (PyCFunction) &Dtool_Fog_set_linear_range_1430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Fog_set_linear_range_1430_comment},
  {"get_linear_onset_point", &Dtool_Fog_get_linear_onset_point_1431, METH_NOARGS, (const char *)Dtool_Fog_get_linear_onset_point_1431_comment},
  {"getLinearOnsetPoint", &Dtool_Fog_get_linear_onset_point_1431, METH_NOARGS, (const char *)Dtool_Fog_get_linear_onset_point_1431_comment},
  {"set_linear_onset_point", (PyCFunction) &Dtool_Fog_set_linear_onset_point_1432, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Fog_set_linear_onset_point_1432_comment},
  {"setLinearOnsetPoint", (PyCFunction) &Dtool_Fog_set_linear_onset_point_1432, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Fog_set_linear_onset_point_1432_comment},
  {"get_linear_opaque_point", &Dtool_Fog_get_linear_opaque_point_1434, METH_NOARGS, (const char *)Dtool_Fog_get_linear_opaque_point_1434_comment},
  {"getLinearOpaquePoint", &Dtool_Fog_get_linear_opaque_point_1434, METH_NOARGS, (const char *)Dtool_Fog_get_linear_opaque_point_1434_comment},
  {"set_linear_opaque_point", (PyCFunction) &Dtool_Fog_set_linear_opaque_point_1435, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Fog_set_linear_opaque_point_1435_comment},
  {"setLinearOpaquePoint", (PyCFunction) &Dtool_Fog_set_linear_opaque_point_1435, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Fog_set_linear_opaque_point_1435_comment},
  {"set_linear_fallback", (PyCFunction) &Dtool_Fog_set_linear_fallback_1437, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Fog_set_linear_fallback_1437_comment},
  {"setLinearFallback", (PyCFunction) &Dtool_Fog_set_linear_fallback_1437, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Fog_set_linear_fallback_1437_comment},
  {"get_exp_density", &Dtool_Fog_get_exp_density_1438, METH_NOARGS, (const char *)Dtool_Fog_get_exp_density_1438_comment},
  {"getExpDensity", &Dtool_Fog_get_exp_density_1438, METH_NOARGS, (const char *)Dtool_Fog_get_exp_density_1438_comment},
  {"set_exp_density", &Dtool_Fog_set_exp_density_1439, METH_O, (const char *)Dtool_Fog_set_exp_density_1439_comment},
  {"setExpDensity", &Dtool_Fog_set_exp_density_1439, METH_O, (const char *)Dtool_Fog_set_exp_density_1439_comment},
  {"get_class_type", &Dtool_Fog_get_class_type_1441, METH_NOARGS | METH_STATIC, (const char *)Dtool_Fog_get_class_type_1441_comment},
  {"getClassType", &Dtool_Fog_get_class_type_1441, METH_NOARGS | METH_STATIC, (const char *)Dtool_Fog_get_class_type_1441_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_Fog[] = {
  {(char *)"mode", &Dtool_Fog_mode_Getter, &Dtool_Fog_mode_Setter, nullptr, nullptr},
  {(char *)"color", &Dtool_Fog_color_Getter, &Dtool_Fog_color_Setter, nullptr, nullptr},
  {(char *)"linear_onset_point", &Dtool_Fog_linear_onset_point_Getter, &Dtool_Fog_linear_onset_point_Setter, nullptr, nullptr},
  {(char *)"linear_opaque_point", &Dtool_Fog_linear_opaque_point_Getter, &Dtool_Fog_linear_opaque_point_Setter, nullptr, nullptr},
  {(char *)"exp_density", &Dtool_Fog_exp_density_Getter, &Dtool_Fog_exp_density_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Fog = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Fog = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Fog = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Fog = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Fog = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Fog = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Fog",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Fog,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Fog,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Fog,
    &Dtool_SequenceMethods_Fog,
    &Dtool_MappingMethods_Fog,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Fog,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Specifies how atmospheric fog effects are applied to geometry.  The Fog\n"
    " * object is now a PandaNode, which means it can be used similarly to a Light\n"
    " * to define effects relative to a particular coordinate system within the\n"
    " * scene graph.\n"
    " *\n"
    " * In exponential mode, the fog effects are always camera-relative, and it\n"
    " * does not matter where the Fog node is parented.  However, in linear mode,\n"
    " * the onset and opaque distances are defined as offsets along the local\n"
    " * forward axis (e.g.  the Y axis).  This allows the fog effect to be\n"
    " * localized to a particular region in space, rather than always camera-\n"
    " * relative.  If the fog object is not parented to any node, it is used to\n"
    " * generate traditonal camera-relative fog, as if it were parented to the\n"
    " * camera.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Fog,
    nullptr, // tp_members
    Dtool_Properties_Fog,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Fog,
    PyType_GenericAlloc,
    Dtool_new_Fog,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Fog,
  Dtool_UpcastInterface_Fog,
  Dtool_DowncastInterface_Fog,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Fog(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PandaNode(nullptr);
    Dtool_Fog._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PandaNode);
    Dtool_Fog._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_Fog._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum Fog::Mode;
    PyDict_SetItemString(dict, "M_linear", Dtool_WrapValue(Fog::M_linear));
    PyDict_SetItemString(dict, "MLinear", Dtool_WrapValue(Fog::M_linear));
    PyDict_SetItemString(dict, "M_exponential", Dtool_WrapValue(Fog::M_exponential));
    PyDict_SetItemString(dict, "MExponential", Dtool_WrapValue(Fog::M_exponential));
    PyDict_SetItemString(dict, "M_exponential_squared", Dtool_WrapValue(Fog::M_exponential_squared));
    PyDict_SetItemString(dict, "MExponentialSquared", Dtool_WrapValue(Fog::M_exponential_squared));
    if (PyType_Ready((PyTypeObject *)&Dtool_Fog) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Fog)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Fog);
  }
}

/**
 * Python method tables for FogAttrib (FogAttrib)
 */
static PyMethodDef Dtool_Methods_FogAttrib[] = {
  {"make", &Dtool_FogAttrib_make_1443, METH_O | METH_STATIC, (const char *)Dtool_FogAttrib_make_1443_comment},
  {"make_off", &Dtool_FogAttrib_make_off_1444, METH_NOARGS | METH_STATIC, (const char *)Dtool_FogAttrib_make_off_1444_comment},
  {"makeOff", &Dtool_FogAttrib_make_off_1444, METH_NOARGS | METH_STATIC, (const char *)Dtool_FogAttrib_make_off_1444_comment},
  {"make_default", &Dtool_FogAttrib_make_default_1445, METH_NOARGS | METH_STATIC, (const char *)Dtool_FogAttrib_make_default_1445_comment},
  {"makeDefault", &Dtool_FogAttrib_make_default_1445, METH_NOARGS | METH_STATIC, (const char *)Dtool_FogAttrib_make_default_1445_comment},
  {"is_off", &Dtool_FogAttrib_is_off_1446, METH_NOARGS, (const char *)Dtool_FogAttrib_is_off_1446_comment},
  {"isOff", &Dtool_FogAttrib_is_off_1446, METH_NOARGS, (const char *)Dtool_FogAttrib_is_off_1446_comment},
  {"get_fog", &Dtool_FogAttrib_get_fog_1447, METH_NOARGS, (const char *)Dtool_FogAttrib_get_fog_1447_comment},
  {"getFog", &Dtool_FogAttrib_get_fog_1447, METH_NOARGS, (const char *)Dtool_FogAttrib_get_fog_1447_comment},
  {"get_class_slot", &Dtool_FogAttrib_get_class_slot_1450, METH_NOARGS | METH_STATIC, (const char *)Dtool_FogAttrib_get_class_slot_1450_comment},
  {"getClassSlot", &Dtool_FogAttrib_get_class_slot_1450, METH_NOARGS | METH_STATIC, (const char *)Dtool_FogAttrib_get_class_slot_1450_comment},
  {"get_class_type", &Dtool_FogAttrib_get_class_type_1452, METH_NOARGS | METH_STATIC, (const char *)Dtool_FogAttrib_get_class_type_1452_comment},
  {"getClassType", &Dtool_FogAttrib_get_class_type_1452, METH_NOARGS | METH_STATIC, (const char *)Dtool_FogAttrib_get_class_type_1452_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_FogAttrib[] = {
  {(char *)"fog", &Dtool_FogAttrib_fog_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_FogAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FogAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_FogAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_FogAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_FogAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_FogAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.FogAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FogAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_FogAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_FogAttrib,
    &Dtool_SequenceMethods_FogAttrib,
    &Dtool_MappingMethods_FogAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_FogAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Applies a Fog to the geometry at and below this node.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FogAttrib,
    nullptr, // tp_members
    Dtool_Properties_FogAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FogAttrib,
    PyType_GenericAlloc,
    Dtool_new_FogAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FogAttrib,
  Dtool_UpcastInterface_FogAttrib,
  Dtool_DowncastInterface_FogAttrib,
  (CoerceFunction)Dtool_ConstCoerce_FogAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_FogAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_FogAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_FogAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_FogAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_FogAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_FogAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_FogAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FogAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FogAttrib);
  }
}

/**
 * Python method tables for CullTraverser (CullTraverser)
 */
static PyMethodDef Dtool_Methods_CullTraverser[] = {
  {"get_gsg", &Dtool_CullTraverser_get_gsg_1456, METH_NOARGS, (const char *)Dtool_CullTraverser_get_gsg_1456_comment},
  {"getGsg", &Dtool_CullTraverser_get_gsg_1456, METH_NOARGS, (const char *)Dtool_CullTraverser_get_gsg_1456_comment},
  {"get_current_thread", &Dtool_CullTraverser_get_current_thread_1457, METH_NOARGS, (const char *)Dtool_CullTraverser_get_current_thread_1457_comment},
  {"getCurrentThread", &Dtool_CullTraverser_get_current_thread_1457, METH_NOARGS, (const char *)Dtool_CullTraverser_get_current_thread_1457_comment},
  {"set_scene", (PyCFunction) &Dtool_CullTraverser_set_scene_1458, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullTraverser_set_scene_1458_comment},
  {"setScene", (PyCFunction) &Dtool_CullTraverser_set_scene_1458, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullTraverser_set_scene_1458_comment},
  {"get_scene", &Dtool_CullTraverser_get_scene_1459, METH_NOARGS, (const char *)Dtool_CullTraverser_get_scene_1459_comment},
  {"getScene", &Dtool_CullTraverser_get_scene_1459, METH_NOARGS, (const char *)Dtool_CullTraverser_get_scene_1459_comment},
  {"has_tag_state_key", &Dtool_CullTraverser_has_tag_state_key_1460, METH_NOARGS, (const char *)Dtool_CullTraverser_has_tag_state_key_1460_comment},
  {"hasTagStateKey", &Dtool_CullTraverser_has_tag_state_key_1460, METH_NOARGS, (const char *)Dtool_CullTraverser_has_tag_state_key_1460_comment},
  {"get_tag_state_key", &Dtool_CullTraverser_get_tag_state_key_1461, METH_NOARGS, (const char *)Dtool_CullTraverser_get_tag_state_key_1461_comment},
  {"getTagStateKey", &Dtool_CullTraverser_get_tag_state_key_1461, METH_NOARGS, (const char *)Dtool_CullTraverser_get_tag_state_key_1461_comment},
  {"set_camera_mask", &Dtool_CullTraverser_set_camera_mask_1462, METH_O, (const char *)Dtool_CullTraverser_set_camera_mask_1462_comment},
  {"setCameraMask", &Dtool_CullTraverser_set_camera_mask_1462, METH_O, (const char *)Dtool_CullTraverser_set_camera_mask_1462_comment},
  {"get_camera_mask", &Dtool_CullTraverser_get_camera_mask_1463, METH_NOARGS, (const char *)Dtool_CullTraverser_get_camera_mask_1463_comment},
  {"getCameraMask", &Dtool_CullTraverser_get_camera_mask_1463, METH_NOARGS, (const char *)Dtool_CullTraverser_get_camera_mask_1463_comment},
  {"get_camera_transform", &Dtool_CullTraverser_get_camera_transform_1464, METH_NOARGS, (const char *)Dtool_CullTraverser_get_camera_transform_1464_comment},
  {"getCameraTransform", &Dtool_CullTraverser_get_camera_transform_1464, METH_NOARGS, (const char *)Dtool_CullTraverser_get_camera_transform_1464_comment},
  {"get_world_transform", &Dtool_CullTraverser_get_world_transform_1465, METH_NOARGS, (const char *)Dtool_CullTraverser_get_world_transform_1465_comment},
  {"getWorldTransform", &Dtool_CullTraverser_get_world_transform_1465, METH_NOARGS, (const char *)Dtool_CullTraverser_get_world_transform_1465_comment},
  {"get_initial_state", &Dtool_CullTraverser_get_initial_state_1466, METH_NOARGS, (const char *)Dtool_CullTraverser_get_initial_state_1466_comment},
  {"getInitialState", &Dtool_CullTraverser_get_initial_state_1466, METH_NOARGS, (const char *)Dtool_CullTraverser_get_initial_state_1466_comment},
  {"get_depth_offset_decals", &Dtool_CullTraverser_get_depth_offset_decals_1467, METH_NOARGS, (const char *)Dtool_CullTraverser_get_depth_offset_decals_1467_comment},
  {"getDepthOffsetDecals", &Dtool_CullTraverser_get_depth_offset_decals_1467, METH_NOARGS, (const char *)Dtool_CullTraverser_get_depth_offset_decals_1467_comment},
  {"set_view_frustum", &Dtool_CullTraverser_set_view_frustum_1468, METH_O, (const char *)Dtool_CullTraverser_set_view_frustum_1468_comment},
  {"setViewFrustum", &Dtool_CullTraverser_set_view_frustum_1468, METH_O, (const char *)Dtool_CullTraverser_set_view_frustum_1468_comment},
  {"get_view_frustum", &Dtool_CullTraverser_get_view_frustum_1469, METH_NOARGS, (const char *)Dtool_CullTraverser_get_view_frustum_1469_comment},
  {"getViewFrustum", &Dtool_CullTraverser_get_view_frustum_1469, METH_NOARGS, (const char *)Dtool_CullTraverser_get_view_frustum_1469_comment},
  {"get_effective_incomplete_render", &Dtool_CullTraverser_get_effective_incomplete_render_1474, METH_NOARGS, (const char *)Dtool_CullTraverser_get_effective_incomplete_render_1474_comment},
  {"getEffectiveIncompleteRender", &Dtool_CullTraverser_get_effective_incomplete_render_1474, METH_NOARGS, (const char *)Dtool_CullTraverser_get_effective_incomplete_render_1474_comment},
  {"traverse", &Dtool_CullTraverser_traverse_1475, METH_O, (const char *)Dtool_CullTraverser_traverse_1475_comment},
  {"traverse_below", &Dtool_CullTraverser_traverse_below_1476, METH_O, (const char *)Dtool_CullTraverser_traverse_below_1476_comment},
  {"traverseBelow", &Dtool_CullTraverser_traverse_below_1476, METH_O, (const char *)Dtool_CullTraverser_traverse_below_1476_comment},
  {"end_traverse", &Dtool_CullTraverser_end_traverse_1477, METH_NOARGS, (const char *)Dtool_CullTraverser_end_traverse_1477_comment},
  {"endTraverse", &Dtool_CullTraverser_end_traverse_1477, METH_NOARGS, (const char *)Dtool_CullTraverser_end_traverse_1477_comment},
  {"flush_level", &Dtool_CullTraverser_flush_level_1478, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullTraverser_flush_level_1478_comment},
  {"flushLevel", &Dtool_CullTraverser_flush_level_1478, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullTraverser_flush_level_1478_comment},
  {"draw_bounding_volume", (PyCFunction) &Dtool_CullTraverser_draw_bounding_volume_1479, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullTraverser_draw_bounding_volume_1479_comment},
  {"drawBoundingVolume", (PyCFunction) &Dtool_CullTraverser_draw_bounding_volume_1479, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullTraverser_draw_bounding_volume_1479_comment},
  {"get_class_type", &Dtool_CullTraverser_get_class_type_1480, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullTraverser_get_class_type_1480_comment},
  {"getClassType", &Dtool_CullTraverser_get_class_type_1480, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullTraverser_get_class_type_1480_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CullTraverser = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CullTraverser = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CullTraverser = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CullTraverser = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CullTraverser = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CullTraverser = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CullTraverser",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CullTraverser,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CullTraverser,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CullTraverser,
    &Dtool_SequenceMethods_CullTraverser,
    &Dtool_MappingMethods_CullTraverser,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CullTraverser,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object performs a depth-first traversal of the scene graph, with\n"
    " * optional view-frustum culling, collecting CullState and searching for\n"
    " * GeomNodes.  Each renderable Geom encountered is passed along with its\n"
    " * associated RenderState to the CullHandler object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CullTraverser,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CullTraverser,
    PyType_GenericAlloc,
    Dtool_new_CullTraverser,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CullTraverser,
  Dtool_UpcastInterface_CullTraverser,
  Dtool_DowncastInterface_CullTraverser,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CullTraverser(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_CullTraverser._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_CullTraverser._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CullTraverser._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CullTraverser) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CullTraverser)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CullTraverser);
  }
}

/**
 * Python method tables for GeomDrawCallbackData (GeomDrawCallbackData)
 */
static PyMethodDef Dtool_Methods_GeomDrawCallbackData[] = {
  {"get_gsg", &Dtool_GeomDrawCallbackData_get_gsg_1485, METH_NOARGS, (const char *)Dtool_GeomDrawCallbackData_get_gsg_1485_comment},
  {"getGsg", &Dtool_GeomDrawCallbackData_get_gsg_1485, METH_NOARGS, (const char *)Dtool_GeomDrawCallbackData_get_gsg_1485_comment},
  {"get_force", &Dtool_GeomDrawCallbackData_get_force_1486, METH_NOARGS, (const char *)Dtool_GeomDrawCallbackData_get_force_1486_comment},
  {"getForce", &Dtool_GeomDrawCallbackData_get_force_1486, METH_NOARGS, (const char *)Dtool_GeomDrawCallbackData_get_force_1486_comment},
  {"set_lost_state", &Dtool_GeomDrawCallbackData_set_lost_state_1487, METH_O, (const char *)Dtool_GeomDrawCallbackData_set_lost_state_1487_comment},
  {"setLostState", &Dtool_GeomDrawCallbackData_set_lost_state_1487, METH_O, (const char *)Dtool_GeomDrawCallbackData_set_lost_state_1487_comment},
  {"get_lost_state", &Dtool_GeomDrawCallbackData_get_lost_state_1488, METH_NOARGS, (const char *)Dtool_GeomDrawCallbackData_get_lost_state_1488_comment},
  {"getLostState", &Dtool_GeomDrawCallbackData_get_lost_state_1488, METH_NOARGS, (const char *)Dtool_GeomDrawCallbackData_get_lost_state_1488_comment},
  {"get_class_type", &Dtool_GeomDrawCallbackData_get_class_type_1489, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomDrawCallbackData_get_class_type_1489_comment},
  {"getClassType", &Dtool_GeomDrawCallbackData_get_class_type_1489, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomDrawCallbackData_get_class_type_1489_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomDrawCallbackData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomDrawCallbackData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomDrawCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomDrawCallbackData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomDrawCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomDrawCallbackData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomDrawCallbackData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomDrawCallbackData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomDrawCallbackData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomDrawCallbackData,
    &Dtool_SequenceMethods_GeomDrawCallbackData,
    &Dtool_MappingMethods_GeomDrawCallbackData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomDrawCallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This specialization on CallbackData is passed when the callback is\n"
    " * initiated from deep within the draw traversal, for a particular Geom.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomDrawCallbackData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomDrawCallbackData,
    PyType_GenericAlloc,
    Dtool_new_GeomDrawCallbackData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomDrawCallbackData,
  Dtool_UpcastInterface_GeomDrawCallbackData,
  Dtool_DowncastInterface_GeomDrawCallbackData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomDrawCallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CallbackData != nullptr);
    assert(Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit(nullptr);
    Dtool_GeomDrawCallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CallbackData);
    Dtool_GeomDrawCallbackData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomDrawCallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomDrawCallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomDrawCallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomDrawCallbackData);
  }
}

/**
 * Python method tables for RescaleNormalAttrib (RescaleNormalAttrib)
 */
static PyMethodDef Dtool_Methods_RescaleNormalAttrib[] = {
  {"make", &Dtool_RescaleNormalAttrib_make_1493, METH_O | METH_STATIC, (const char *)Dtool_RescaleNormalAttrib_make_1493_comment},
  {"make_default", &Dtool_RescaleNormalAttrib_make_default_1494, METH_NOARGS | METH_STATIC, (const char *)Dtool_RescaleNormalAttrib_make_default_1494_comment},
  {"makeDefault", &Dtool_RescaleNormalAttrib_make_default_1494, METH_NOARGS | METH_STATIC, (const char *)Dtool_RescaleNormalAttrib_make_default_1494_comment},
  {"get_mode", &Dtool_RescaleNormalAttrib_get_mode_1495, METH_NOARGS, (const char *)Dtool_RescaleNormalAttrib_get_mode_1495_comment},
  {"getMode", &Dtool_RescaleNormalAttrib_get_mode_1495, METH_NOARGS, (const char *)Dtool_RescaleNormalAttrib_get_mode_1495_comment},
  {"get_class_slot", &Dtool_RescaleNormalAttrib_get_class_slot_1497, METH_NOARGS | METH_STATIC, (const char *)Dtool_RescaleNormalAttrib_get_class_slot_1497_comment},
  {"getClassSlot", &Dtool_RescaleNormalAttrib_get_class_slot_1497, METH_NOARGS | METH_STATIC, (const char *)Dtool_RescaleNormalAttrib_get_class_slot_1497_comment},
  {"get_class_type", &Dtool_RescaleNormalAttrib_get_class_type_1499, METH_NOARGS | METH_STATIC, (const char *)Dtool_RescaleNormalAttrib_get_class_type_1499_comment},
  {"getClassType", &Dtool_RescaleNormalAttrib_get_class_type_1499, METH_NOARGS | METH_STATIC, (const char *)Dtool_RescaleNormalAttrib_get_class_type_1499_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_RescaleNormalAttrib[] = {
  {(char *)"mode", &Dtool_RescaleNormalAttrib_mode_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_RescaleNormalAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RescaleNormalAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RescaleNormalAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RescaleNormalAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RescaleNormalAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RescaleNormalAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RescaleNormalAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RescaleNormalAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RescaleNormalAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RescaleNormalAttrib,
    &Dtool_SequenceMethods_RescaleNormalAttrib,
    &Dtool_MappingMethods_RescaleNormalAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RescaleNormalAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Specifies how polygons are to be drawn.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RescaleNormalAttrib,
    nullptr, // tp_members
    Dtool_Properties_RescaleNormalAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RescaleNormalAttrib,
    PyType_GenericAlloc,
    Dtool_new_RescaleNormalAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RescaleNormalAttrib,
  Dtool_UpcastInterface_RescaleNormalAttrib,
  Dtool_DowncastInterface_RescaleNormalAttrib,
  (CoerceFunction)Dtool_ConstCoerce_RescaleNormalAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_RescaleNormalAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_RescaleNormalAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_RescaleNormalAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_RescaleNormalAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum RescaleNormalAttrib::Mode;
    PyDict_SetItemString(dict, "M_none", Dtool_WrapValue(RescaleNormalAttrib::M_none));
    PyDict_SetItemString(dict, "MNone", Dtool_WrapValue(RescaleNormalAttrib::M_none));
    PyDict_SetItemString(dict, "M_rescale", Dtool_WrapValue(RescaleNormalAttrib::M_rescale));
    PyDict_SetItemString(dict, "MRescale", Dtool_WrapValue(RescaleNormalAttrib::M_rescale));
    PyDict_SetItemString(dict, "M_normalize", Dtool_WrapValue(RescaleNormalAttrib::M_normalize));
    PyDict_SetItemString(dict, "MNormalize", Dtool_WrapValue(RescaleNormalAttrib::M_normalize));
    PyDict_SetItemString(dict, "M_auto", Dtool_WrapValue(RescaleNormalAttrib::M_auto));
    PyDict_SetItemString(dict, "MAuto", Dtool_WrapValue(RescaleNormalAttrib::M_auto));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_RescaleNormalAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_RescaleNormalAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_RescaleNormalAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RescaleNormalAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RescaleNormalAttrib);
  }
}

/**
 * Python method tables for CullResult (CullResult)
 */
static PyMethodDef Dtool_Methods_CullResult[] = {
  {"make_next", &Dtool_CullResult_make_next_1503, METH_NOARGS, (const char *)Dtool_CullResult_make_next_1503_comment},
  {"makeNext", &Dtool_CullResult_make_next_1503, METH_NOARGS, (const char *)Dtool_CullResult_make_next_1503_comment},
  {"finish_cull", (PyCFunction) &Dtool_CullResult_finish_cull_1506, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullResult_finish_cull_1506_comment},
  {"finishCull", (PyCFunction) &Dtool_CullResult_finish_cull_1506, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CullResult_finish_cull_1506_comment},
  {"draw", &Dtool_CullResult_draw_1507, METH_O, (const char *)Dtool_CullResult_draw_1507_comment},
  {"make_result_graph", &Dtool_CullResult_make_result_graph_1508, METH_NOARGS, (const char *)Dtool_CullResult_make_result_graph_1508_comment},
  {"makeResultGraph", &Dtool_CullResult_make_result_graph_1508, METH_NOARGS, (const char *)Dtool_CullResult_make_result_graph_1508_comment},
  {"get_class_type", &Dtool_CullResult_get_class_type_1509, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullResult_get_class_type_1509_comment},
  {"getClassType", &Dtool_CullResult_get_class_type_1509, METH_NOARGS | METH_STATIC, (const char *)Dtool_CullResult_get_class_type_1509_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CullResult = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CullResult = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CullResult = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CullResult = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CullResult = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CullResult = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CullResult",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CullResult,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CullResult,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CullResult,
    &Dtool_SequenceMethods_CullResult,
    &Dtool_MappingMethods_CullResult,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CullResult,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This stores the result of a BinCullHandler traversal: an ordered collection\n"
    " * of CullBins, each of which holds a number of Geoms and RenderStates to be\n"
    " * rendered in some defined order.\n"
    " *\n"
    " * This is also used to keep the results of last frame's cull traversal around\n"
    " * to make next frame's traversal of the same scene a little easier.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CullResult,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CullResult,
    PyType_GenericAlloc,
    Dtool_new_CullResult,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CullResult,
  Dtool_UpcastInterface_CullResult,
  Dtool_DowncastInterface_CullResult,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CullResult(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_CullResult._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_CullResult._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CullResult._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CullResult) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CullResult)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CullResult);
  }
}

/**
 * Python method tables for DecalEffect (DecalEffect)
 */
static PyMethodDef Dtool_Methods_DecalEffect[] = {
  {"make", &Dtool_DecalEffect_make_1512, METH_NOARGS | METH_STATIC, (const char *)Dtool_DecalEffect_make_1512_comment},
  {"get_class_type", &Dtool_DecalEffect_get_class_type_1513, METH_NOARGS | METH_STATIC, (const char *)Dtool_DecalEffect_get_class_type_1513_comment},
  {"getClassType", &Dtool_DecalEffect_get_class_type_1513, METH_NOARGS | METH_STATIC, (const char *)Dtool_DecalEffect_get_class_type_1513_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DecalEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DecalEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DecalEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DecalEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DecalEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DecalEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DecalEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DecalEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DecalEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DecalEffect,
    &Dtool_SequenceMethods_DecalEffect,
    &Dtool_MappingMethods_DecalEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DecalEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Applied to a GeomNode to indicate that the children of this GeomNode are\n"
    " * coplanar and should be drawn as decals (eliminating Z-fighting).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DecalEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DecalEffect,
    PyType_GenericAlloc,
    Dtool_new_DecalEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DecalEffect,
  Dtool_UpcastInterface_DecalEffect,
  Dtool_DowncastInterface_DecalEffect,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DecalEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderEffect(nullptr);
    Dtool_DecalEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderEffect);
    Dtool_DecalEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DecalEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DecalEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DecalEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DecalEffect);
  }
}

/**
 * Python method tables for DepthOffsetAttrib (DepthOffsetAttrib)
 */
static PyMethodDef Dtool_Methods_DepthOffsetAttrib[] = {
  {"make", (PyCFunction) &Dtool_DepthOffsetAttrib_make_1516, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DepthOffsetAttrib_make_1516_comment},
  {"make_default", &Dtool_DepthOffsetAttrib_make_default_1517, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthOffsetAttrib_make_default_1517_comment},
  {"makeDefault", &Dtool_DepthOffsetAttrib_make_default_1517, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthOffsetAttrib_make_default_1517_comment},
  {"get_offset", &Dtool_DepthOffsetAttrib_get_offset_1518, METH_NOARGS, (const char *)Dtool_DepthOffsetAttrib_get_offset_1518_comment},
  {"getOffset", &Dtool_DepthOffsetAttrib_get_offset_1518, METH_NOARGS, (const char *)Dtool_DepthOffsetAttrib_get_offset_1518_comment},
  {"get_min_value", &Dtool_DepthOffsetAttrib_get_min_value_1519, METH_NOARGS, (const char *)Dtool_DepthOffsetAttrib_get_min_value_1519_comment},
  {"getMinValue", &Dtool_DepthOffsetAttrib_get_min_value_1519, METH_NOARGS, (const char *)Dtool_DepthOffsetAttrib_get_min_value_1519_comment},
  {"get_max_value", &Dtool_DepthOffsetAttrib_get_max_value_1520, METH_NOARGS, (const char *)Dtool_DepthOffsetAttrib_get_max_value_1520_comment},
  {"getMaxValue", &Dtool_DepthOffsetAttrib_get_max_value_1520, METH_NOARGS, (const char *)Dtool_DepthOffsetAttrib_get_max_value_1520_comment},
  {"get_class_slot", &Dtool_DepthOffsetAttrib_get_class_slot_1524, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthOffsetAttrib_get_class_slot_1524_comment},
  {"getClassSlot", &Dtool_DepthOffsetAttrib_get_class_slot_1524, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthOffsetAttrib_get_class_slot_1524_comment},
  {"get_class_type", &Dtool_DepthOffsetAttrib_get_class_type_1526, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthOffsetAttrib_get_class_type_1526_comment},
  {"getClassType", &Dtool_DepthOffsetAttrib_get_class_type_1526, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthOffsetAttrib_get_class_type_1526_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_DepthOffsetAttrib[] = {
  {(char *)"offset", &Dtool_DepthOffsetAttrib_offset_Getter, nullptr, nullptr, nullptr},
  {(char *)"min_value", &Dtool_DepthOffsetAttrib_min_value_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_value", &Dtool_DepthOffsetAttrib_max_value_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DepthOffsetAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DepthOffsetAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DepthOffsetAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DepthOffsetAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DepthOffsetAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DepthOffsetAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DepthOffsetAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DepthOffsetAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DepthOffsetAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DepthOffsetAttrib,
    &Dtool_SequenceMethods_DepthOffsetAttrib,
    &Dtool_MappingMethods_DepthOffsetAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DepthOffsetAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special kind of attribute that instructs the graphics driver to\n"
    " * apply an offset or bias to the generated depth values for rendered\n"
    " * polygons, before they are written to the depth buffer.\n"
    " *\n"
    " * This can be used to shift polygons forward slightly, to resolve depth\n"
    " * conflicts.  The cull traverser may optionally use this, for instance, to\n"
    " * implement decals.  However, driver support for this feature seems to be\n"
    " * spotty, so use with caution.\n"
    " *\n"
    " * The bias is always an integer number, and each integer increment represents\n"
    " * the smallest possible increment in Z that is sufficient to completely\n"
    " * resolve two coplanar polygons.  Positive numbers are closer towards the\n"
    " * camera.\n"
    " *\n"
    " * Nested DepthOffsetAttrib values accumulate; that is, a DepthOffsetAttrib\n"
    " * with a value of 1 beneath another DepthOffsetAttrib with a value of 2\n"
    " * presents a net offset of 3.  (A DepthOffsetAttrib will not, however,\n"
    " * combine with any other DepthOffsetAttribs with a lower override parameter.)\n"
    " * The net value should probably not exceed 16 or drop below 0 for maximum\n"
    " * portability.\n"
    " *\n"
    " * Also, and only tangentially related, the DepthOffsetAttrib can be used to\n"
    " * constrain the Z output value to a subset of the usual [0, 1] range (or\n"
    " * reversing its direction) by specifying a new min_value and max_value.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DepthOffsetAttrib,
    nullptr, // tp_members
    Dtool_Properties_DepthOffsetAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DepthOffsetAttrib,
    PyType_GenericAlloc,
    Dtool_new_DepthOffsetAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DepthOffsetAttrib,
  Dtool_UpcastInterface_DepthOffsetAttrib,
  Dtool_DowncastInterface_DepthOffsetAttrib,
  (CoerceFunction)Dtool_ConstCoerce_DepthOffsetAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_DepthOffsetAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_DepthOffsetAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_DepthOffsetAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DepthOffsetAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_DepthOffsetAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_DepthOffsetAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_DepthOffsetAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DepthOffsetAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DepthOffsetAttrib);
  }
}

/**
 * Python method tables for DepthTestAttrib (DepthTestAttrib)
 */
static PyMethodDef Dtool_Methods_DepthTestAttrib[] = {
  {"make", &Dtool_DepthTestAttrib_make_1529, METH_O | METH_STATIC, (const char *)Dtool_DepthTestAttrib_make_1529_comment},
  {"make_default", &Dtool_DepthTestAttrib_make_default_1530, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthTestAttrib_make_default_1530_comment},
  {"makeDefault", &Dtool_DepthTestAttrib_make_default_1530, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthTestAttrib_make_default_1530_comment},
  {"get_mode", &Dtool_DepthTestAttrib_get_mode_1531, METH_NOARGS, (const char *)Dtool_DepthTestAttrib_get_mode_1531_comment},
  {"getMode", &Dtool_DepthTestAttrib_get_mode_1531, METH_NOARGS, (const char *)Dtool_DepthTestAttrib_get_mode_1531_comment},
  {"get_class_slot", &Dtool_DepthTestAttrib_get_class_slot_1533, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthTestAttrib_get_class_slot_1533_comment},
  {"getClassSlot", &Dtool_DepthTestAttrib_get_class_slot_1533, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthTestAttrib_get_class_slot_1533_comment},
  {"get_class_type", &Dtool_DepthTestAttrib_get_class_type_1535, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthTestAttrib_get_class_type_1535_comment},
  {"getClassType", &Dtool_DepthTestAttrib_get_class_type_1535, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthTestAttrib_get_class_type_1535_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_DepthTestAttrib[] = {
  {(char *)"mode", &Dtool_DepthTestAttrib_mode_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DepthTestAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DepthTestAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DepthTestAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DepthTestAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DepthTestAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DepthTestAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DepthTestAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DepthTestAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DepthTestAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DepthTestAttrib,
    &Dtool_SequenceMethods_DepthTestAttrib,
    &Dtool_MappingMethods_DepthTestAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DepthTestAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Enables or disables writing to the depth buffer.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DepthTestAttrib,
    nullptr, // tp_members
    Dtool_Properties_DepthTestAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DepthTestAttrib,
    PyType_GenericAlloc,
    Dtool_new_DepthTestAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DepthTestAttrib,
  Dtool_UpcastInterface_DepthTestAttrib,
  Dtool_DowncastInterface_DepthTestAttrib,
  (CoerceFunction)Dtool_ConstCoerce_DepthTestAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_DepthTestAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_DepthTestAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_DepthTestAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DepthTestAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_DepthTestAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_DepthTestAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_DepthTestAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DepthTestAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DepthTestAttrib);
  }
}

/**
 * Python method tables for DepthWriteAttrib (DepthWriteAttrib)
 */
static PyMethodDef Dtool_Methods_DepthWriteAttrib[] = {
  {"make", &Dtool_DepthWriteAttrib_make_1539, METH_O | METH_STATIC, (const char *)Dtool_DepthWriteAttrib_make_1539_comment},
  {"make_default", &Dtool_DepthWriteAttrib_make_default_1540, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthWriteAttrib_make_default_1540_comment},
  {"makeDefault", &Dtool_DepthWriteAttrib_make_default_1540, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthWriteAttrib_make_default_1540_comment},
  {"get_mode", &Dtool_DepthWriteAttrib_get_mode_1541, METH_NOARGS, (const char *)Dtool_DepthWriteAttrib_get_mode_1541_comment},
  {"getMode", &Dtool_DepthWriteAttrib_get_mode_1541, METH_NOARGS, (const char *)Dtool_DepthWriteAttrib_get_mode_1541_comment},
  {"get_class_slot", &Dtool_DepthWriteAttrib_get_class_slot_1543, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthWriteAttrib_get_class_slot_1543_comment},
  {"getClassSlot", &Dtool_DepthWriteAttrib_get_class_slot_1543, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthWriteAttrib_get_class_slot_1543_comment},
  {"get_class_type", &Dtool_DepthWriteAttrib_get_class_type_1545, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthWriteAttrib_get_class_type_1545_comment},
  {"getClassType", &Dtool_DepthWriteAttrib_get_class_type_1545, METH_NOARGS | METH_STATIC, (const char *)Dtool_DepthWriteAttrib_get_class_type_1545_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_DepthWriteAttrib[] = {
  {(char *)"mode", &Dtool_DepthWriteAttrib_mode_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DepthWriteAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DepthWriteAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DepthWriteAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DepthWriteAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DepthWriteAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DepthWriteAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DepthWriteAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DepthWriteAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DepthWriteAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DepthWriteAttrib,
    &Dtool_SequenceMethods_DepthWriteAttrib,
    &Dtool_MappingMethods_DepthWriteAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DepthWriteAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Enables or disables writing to the depth buffer.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DepthWriteAttrib,
    nullptr, // tp_members
    Dtool_Properties_DepthWriteAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DepthWriteAttrib,
    PyType_GenericAlloc,
    Dtool_new_DepthWriteAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DepthWriteAttrib,
  Dtool_UpcastInterface_DepthWriteAttrib,
  Dtool_DowncastInterface_DepthWriteAttrib,
  (CoerceFunction)Dtool_ConstCoerce_DepthWriteAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_DepthWriteAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_DepthWriteAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_DepthWriteAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DepthWriteAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum DepthWriteAttrib::Mode;
    PyDict_SetItemString(dict, "M_off", Dtool_WrapValue(DepthWriteAttrib::M_off));
    PyDict_SetItemString(dict, "MOff", Dtool_WrapValue(DepthWriteAttrib::M_off));
    PyDict_SetItemString(dict, "M_on", Dtool_WrapValue(DepthWriteAttrib::M_on));
    PyDict_SetItemString(dict, "MOn", Dtool_WrapValue(DepthWriteAttrib::M_on));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_DepthWriteAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_DepthWriteAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_DepthWriteAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DepthWriteAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DepthWriteAttrib);
  }
}

/**
 * Python method tables for Light (Light)
 */
static PyMethodDef Dtool_Methods_Light[] = {
  {"as_node", &Dtool_Light_as_node_1549, METH_NOARGS, (const char *)Dtool_Light_as_node_1549_comment},
  {"asNode", &Dtool_Light_as_node_1549, METH_NOARGS, (const char *)Dtool_Light_as_node_1549_comment},
  {"is_ambient_light", &Dtool_Light_is_ambient_light_1550, METH_NOARGS, (const char *)Dtool_Light_is_ambient_light_1550_comment},
  {"isAmbientLight", &Dtool_Light_is_ambient_light_1550, METH_NOARGS, (const char *)Dtool_Light_is_ambient_light_1550_comment},
  {"get_color", &Dtool_Light_get_color_1551, METH_NOARGS, (const char *)Dtool_Light_get_color_1551_comment},
  {"getColor", &Dtool_Light_get_color_1551, METH_NOARGS, (const char *)Dtool_Light_get_color_1551_comment},
  {"set_color", &Dtool_Light_set_color_1552, METH_O, (const char *)Dtool_Light_set_color_1552_comment},
  {"setColor", &Dtool_Light_set_color_1552, METH_O, (const char *)Dtool_Light_set_color_1552_comment},
  {"has_color_temperature", &Dtool_Light_has_color_temperature_1554, METH_NOARGS, (const char *)Dtool_Light_has_color_temperature_1554_comment},
  {"hasColorTemperature", &Dtool_Light_has_color_temperature_1554, METH_NOARGS, (const char *)Dtool_Light_has_color_temperature_1554_comment},
  {"get_color_temperature", &Dtool_Light_get_color_temperature_1555, METH_NOARGS, (const char *)Dtool_Light_get_color_temperature_1555_comment},
  {"getColorTemperature", &Dtool_Light_get_color_temperature_1555, METH_NOARGS, (const char *)Dtool_Light_get_color_temperature_1555_comment},
  {"set_color_temperature", &Dtool_Light_set_color_temperature_1556, METH_O, (const char *)Dtool_Light_set_color_temperature_1556_comment},
  {"setColorTemperature", &Dtool_Light_set_color_temperature_1556, METH_O, (const char *)Dtool_Light_set_color_temperature_1556_comment},
  {"get_exponent", &Dtool_Light_get_exponent_1558, METH_NOARGS, (const char *)Dtool_Light_get_exponent_1558_comment},
  {"getExponent", &Dtool_Light_get_exponent_1558, METH_NOARGS, (const char *)Dtool_Light_get_exponent_1558_comment},
  {"get_specular_color", &Dtool_Light_get_specular_color_1559, METH_NOARGS, (const char *)Dtool_Light_get_specular_color_1559_comment},
  {"getSpecularColor", &Dtool_Light_get_specular_color_1559, METH_NOARGS, (const char *)Dtool_Light_get_specular_color_1559_comment},
  {"get_attenuation", &Dtool_Light_get_attenuation_1560, METH_NOARGS, (const char *)Dtool_Light_get_attenuation_1560_comment},
  {"getAttenuation", &Dtool_Light_get_attenuation_1560, METH_NOARGS, (const char *)Dtool_Light_get_attenuation_1560_comment},
  {"set_priority", &Dtool_Light_set_priority_1561, METH_O, (const char *)Dtool_Light_set_priority_1561_comment},
  {"setPriority", &Dtool_Light_set_priority_1561, METH_O, (const char *)Dtool_Light_set_priority_1561_comment},
  {"get_priority", &Dtool_Light_get_priority_1562, METH_NOARGS, (const char *)Dtool_Light_get_priority_1562_comment},
  {"getPriority", &Dtool_Light_get_priority_1562, METH_NOARGS, (const char *)Dtool_Light_get_priority_1562_comment},
  {"get_class_priority", &Dtool_Light_get_class_priority_1563, METH_NOARGS, (const char *)Dtool_Light_get_class_priority_1563_comment},
  {"getClassPriority", &Dtool_Light_get_class_priority_1563, METH_NOARGS, (const char *)Dtool_Light_get_class_priority_1563_comment},
  {"get_class_type", &Dtool_Light_get_class_type_1565, METH_NOARGS | METH_STATIC, (const char *)Dtool_Light_get_class_type_1565_comment},
  {"getClassType", &Dtool_Light_get_class_type_1565, METH_NOARGS | METH_STATIC, (const char *)Dtool_Light_get_class_type_1565_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_Light[] = {
  {(char *)"color", &Dtool_Light_color_Getter, &Dtool_Light_color_Setter, nullptr, nullptr},
  {(char *)"color_temperature", &Dtool_Light_color_temperature_Getter, &Dtool_Light_color_temperature_Setter, nullptr, nullptr},
  {(char *)"priority", &Dtool_Light_priority_Getter, &Dtool_Light_priority_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Light = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Light = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Light",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Light,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Light,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract interface to all kinds of lights.  The actual light objects\n"
    " * also inherit from PandaNode, and can therefore be added to the scene graph\n"
    " * at some arbitrary point to define the coordinate system of effect.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Light,
    nullptr, // tp_members
    Dtool_Properties_Light,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Light,
    PyType_GenericAlloc,
    Dtool_new_Light,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Light,
  Dtool_UpcastInterface_Light,
  Dtool_DowncastInterface_Light,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Light(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Light._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Light._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Light) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Light)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Light);
  }
}

/**
 * Python method tables for LightAttrib (LightAttrib)
 */
static PyMethodDef Dtool_Methods_LightAttrib[] = {
  {"make", (PyCFunction) &Dtool_LightAttrib_make_1568, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LightAttrib_make_1568_comment},
  {"make_default", &Dtool_LightAttrib_make_default_1569, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightAttrib_make_default_1569_comment},
  {"makeDefault", &Dtool_LightAttrib_make_default_1569, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightAttrib_make_default_1569_comment},
  {"get_operation", &Dtool_LightAttrib_get_operation_1570, METH_NOARGS, (const char *)Dtool_LightAttrib_get_operation_1570_comment},
  {"getOperation", &Dtool_LightAttrib_get_operation_1570, METH_NOARGS, (const char *)Dtool_LightAttrib_get_operation_1570_comment},
  {"get_num_lights", &Dtool_LightAttrib_get_num_lights_1571, METH_NOARGS, (const char *)Dtool_LightAttrib_get_num_lights_1571_comment},
  {"getNumLights", &Dtool_LightAttrib_get_num_lights_1571, METH_NOARGS, (const char *)Dtool_LightAttrib_get_num_lights_1571_comment},
  {"get_light", &Dtool_LightAttrib_get_light_1572, METH_O, (const char *)Dtool_LightAttrib_get_light_1572_comment},
  {"getLight", &Dtool_LightAttrib_get_light_1572, METH_O, (const char *)Dtool_LightAttrib_get_light_1572_comment},
  {"has_light", &Dtool_LightAttrib_has_light_1573, METH_O, (const char *)Dtool_LightAttrib_has_light_1573_comment},
  {"hasLight", &Dtool_LightAttrib_has_light_1573, METH_O, (const char *)Dtool_LightAttrib_has_light_1573_comment},
  {"add_light", &Dtool_LightAttrib_add_light_1574, METH_O, (const char *)Dtool_LightAttrib_add_light_1574_comment},
  {"addLight", &Dtool_LightAttrib_add_light_1574, METH_O, (const char *)Dtool_LightAttrib_add_light_1574_comment},
  {"remove_light", &Dtool_LightAttrib_remove_light_1575, METH_O, (const char *)Dtool_LightAttrib_remove_light_1575_comment},
  {"removeLight", &Dtool_LightAttrib_remove_light_1575, METH_O, (const char *)Dtool_LightAttrib_remove_light_1575_comment},
  {"make_all_off", &Dtool_LightAttrib_make_all_off_1576, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightAttrib_make_all_off_1576_comment},
  {"makeAllOff", &Dtool_LightAttrib_make_all_off_1576, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightAttrib_make_all_off_1576_comment},
  {"get_num_on_lights", &Dtool_LightAttrib_get_num_on_lights_1577, METH_NOARGS, (const char *)Dtool_LightAttrib_get_num_on_lights_1577_comment},
  {"getNumOnLights", &Dtool_LightAttrib_get_num_on_lights_1577, METH_NOARGS, (const char *)Dtool_LightAttrib_get_num_on_lights_1577_comment},
  {"get_num_non_ambient_lights", &Dtool_LightAttrib_get_num_non_ambient_lights_1578, METH_NOARGS, (const char *)Dtool_LightAttrib_get_num_non_ambient_lights_1578_comment},
  {"getNumNonAmbientLights", &Dtool_LightAttrib_get_num_non_ambient_lights_1578, METH_NOARGS, (const char *)Dtool_LightAttrib_get_num_non_ambient_lights_1578_comment},
  {"get_on_light", &Dtool_LightAttrib_get_on_light_1579, METH_O, (const char *)Dtool_LightAttrib_get_on_light_1579_comment},
  {"getOnLight", &Dtool_LightAttrib_get_on_light_1579, METH_O, (const char *)Dtool_LightAttrib_get_on_light_1579_comment},
  {"has_on_light", &Dtool_LightAttrib_has_on_light_1581, METH_O, (const char *)Dtool_LightAttrib_has_on_light_1581_comment},
  {"hasOnLight", &Dtool_LightAttrib_has_on_light_1581, METH_O, (const char *)Dtool_LightAttrib_has_on_light_1581_comment},
  {"has_any_on_light", &Dtool_LightAttrib_has_any_on_light_1582, METH_NOARGS, (const char *)Dtool_LightAttrib_has_any_on_light_1582_comment},
  {"hasAnyOnLight", &Dtool_LightAttrib_has_any_on_light_1582, METH_NOARGS, (const char *)Dtool_LightAttrib_has_any_on_light_1582_comment},
  {"get_num_off_lights", &Dtool_LightAttrib_get_num_off_lights_1583, METH_NOARGS, (const char *)Dtool_LightAttrib_get_num_off_lights_1583_comment},
  {"getNumOffLights", &Dtool_LightAttrib_get_num_off_lights_1583, METH_NOARGS, (const char *)Dtool_LightAttrib_get_num_off_lights_1583_comment},
  {"get_off_light", &Dtool_LightAttrib_get_off_light_1584, METH_O, (const char *)Dtool_LightAttrib_get_off_light_1584_comment},
  {"getOffLight", &Dtool_LightAttrib_get_off_light_1584, METH_O, (const char *)Dtool_LightAttrib_get_off_light_1584_comment},
  {"has_off_light", &Dtool_LightAttrib_has_off_light_1586, METH_O, (const char *)Dtool_LightAttrib_has_off_light_1586_comment},
  {"hasOffLight", &Dtool_LightAttrib_has_off_light_1586, METH_O, (const char *)Dtool_LightAttrib_has_off_light_1586_comment},
  {"has_all_off", &Dtool_LightAttrib_has_all_off_1587, METH_NOARGS, (const char *)Dtool_LightAttrib_has_all_off_1587_comment},
  {"hasAllOff", &Dtool_LightAttrib_has_all_off_1587, METH_NOARGS, (const char *)Dtool_LightAttrib_has_all_off_1587_comment},
  {"is_identity", &Dtool_LightAttrib_is_identity_1588, METH_NOARGS, (const char *)Dtool_LightAttrib_is_identity_1588_comment},
  {"isIdentity", &Dtool_LightAttrib_is_identity_1588, METH_NOARGS, (const char *)Dtool_LightAttrib_is_identity_1588_comment},
  {"add_on_light", &Dtool_LightAttrib_add_on_light_1589, METH_O, (const char *)Dtool_LightAttrib_add_on_light_1589_comment},
  {"addOnLight", &Dtool_LightAttrib_add_on_light_1589, METH_O, (const char *)Dtool_LightAttrib_add_on_light_1589_comment},
  {"remove_on_light", &Dtool_LightAttrib_remove_on_light_1590, METH_O, (const char *)Dtool_LightAttrib_remove_on_light_1590_comment},
  {"removeOnLight", &Dtool_LightAttrib_remove_on_light_1590, METH_O, (const char *)Dtool_LightAttrib_remove_on_light_1590_comment},
  {"add_off_light", &Dtool_LightAttrib_add_off_light_1591, METH_O, (const char *)Dtool_LightAttrib_add_off_light_1591_comment},
  {"addOffLight", &Dtool_LightAttrib_add_off_light_1591, METH_O, (const char *)Dtool_LightAttrib_add_off_light_1591_comment},
  {"remove_off_light", &Dtool_LightAttrib_remove_off_light_1592, METH_O, (const char *)Dtool_LightAttrib_remove_off_light_1592_comment},
  {"removeOffLight", &Dtool_LightAttrib_remove_off_light_1592, METH_O, (const char *)Dtool_LightAttrib_remove_off_light_1592_comment},
  {"get_most_important_light", &Dtool_LightAttrib_get_most_important_light_1593, METH_NOARGS, (const char *)Dtool_LightAttrib_get_most_important_light_1593_comment},
  {"getMostImportantLight", &Dtool_LightAttrib_get_most_important_light_1593, METH_NOARGS, (const char *)Dtool_LightAttrib_get_most_important_light_1593_comment},
  {"get_ambient_contribution", &Dtool_LightAttrib_get_ambient_contribution_1594, METH_NOARGS, (const char *)Dtool_LightAttrib_get_ambient_contribution_1594_comment},
  {"getAmbientContribution", &Dtool_LightAttrib_get_ambient_contribution_1594, METH_NOARGS, (const char *)Dtool_LightAttrib_get_ambient_contribution_1594_comment},
  {"get_class_slot", &Dtool_LightAttrib_get_class_slot_1597, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightAttrib_get_class_slot_1597_comment},
  {"getClassSlot", &Dtool_LightAttrib_get_class_slot_1597, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightAttrib_get_class_slot_1597_comment},
  {"get_class_type", &Dtool_LightAttrib_get_class_type_1599, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightAttrib_get_class_type_1599_comment},
  {"getClassType", &Dtool_LightAttrib_get_class_type_1599, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightAttrib_get_class_type_1599_comment},
  {"get_on_lights", (PyCFunction) &MakeSeq_LightAttrib_get_on_lights, METH_NOARGS, nullptr},
  { "getOnLights", (PyCFunction) &MakeSeq_LightAttrib_get_on_lights, METH_NOARGS, nullptr},
  {"get_off_lights", (PyCFunction) &MakeSeq_LightAttrib_get_off_lights, METH_NOARGS, nullptr},
  { "getOffLights", (PyCFunction) &MakeSeq_LightAttrib_get_off_lights, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LightAttrib[] = {
  {(char *)"on_lights", &Dtool_LightAttrib_on_lights_Getter, nullptr, nullptr, nullptr},
  {(char *)"off_lights", &Dtool_LightAttrib_off_lights_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LightAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LightAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LightAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LightAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LightAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LightAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LightAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LightAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LightAttrib,
    &Dtool_SequenceMethods_LightAttrib,
    &Dtool_MappingMethods_LightAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LightAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Indicates which set of lights should be considered \"on\" to illuminate\n"
    " * geometry at this level and below.  A LightAttrib can either add lights or\n"
    " * remove lights from the total set of \"on\" lights.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LightAttrib,
    nullptr, // tp_members
    Dtool_Properties_LightAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LightAttrib,
    PyType_GenericAlloc,
    Dtool_new_LightAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightAttrib,
  Dtool_UpcastInterface_LightAttrib,
  Dtool_DowncastInterface_LightAttrib,
  (CoerceFunction)Dtool_ConstCoerce_LightAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_LightAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_LightAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_LightAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_LightAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LightAttrib::Operation;
    PyDict_SetItemString(dict, "O_set", Dtool_WrapValue(LightAttrib::O_set));
    PyDict_SetItemString(dict, "OSet", Dtool_WrapValue(LightAttrib::O_set));
    PyDict_SetItemString(dict, "O_add", Dtool_WrapValue(LightAttrib::O_add));
    PyDict_SetItemString(dict, "OAdd", Dtool_WrapValue(LightAttrib::O_add));
    PyDict_SetItemString(dict, "O_remove", Dtool_WrapValue(LightAttrib::O_remove));
    PyDict_SetItemString(dict, "ORemove", Dtool_WrapValue(LightAttrib::O_remove));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_LightAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_LightAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_LightAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightAttrib);
  }
}

/**
 * Python method tables for LightRampAttrib (LightRampAttrib)
 */
static PyMethodDef Dtool_Methods_LightRampAttrib[] = {
  {"make_default", &Dtool_LightRampAttrib_make_default_1602, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_default_1602_comment},
  {"makeDefault", &Dtool_LightRampAttrib_make_default_1602, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_default_1602_comment},
  {"make_identity", &Dtool_LightRampAttrib_make_identity_1603, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_identity_1603_comment},
  {"makeIdentity", &Dtool_LightRampAttrib_make_identity_1603, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_identity_1603_comment},
  {"make_single_threshold", (PyCFunction) &Dtool_LightRampAttrib_make_single_threshold_1604, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_single_threshold_1604_comment},
  {"makeSingleThreshold", (PyCFunction) &Dtool_LightRampAttrib_make_single_threshold_1604, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_single_threshold_1604_comment},
  {"make_double_threshold", (PyCFunction) &Dtool_LightRampAttrib_make_double_threshold_1605, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_double_threshold_1605_comment},
  {"makeDoubleThreshold", (PyCFunction) &Dtool_LightRampAttrib_make_double_threshold_1605, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_double_threshold_1605_comment},
  {"make_hdr0", &Dtool_LightRampAttrib_make_hdr0_1606, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_hdr0_1606_comment},
  {"makeHdr0", &Dtool_LightRampAttrib_make_hdr0_1606, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_hdr0_1606_comment},
  {"make_hdr1", &Dtool_LightRampAttrib_make_hdr1_1607, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_hdr1_1607_comment},
  {"makeHdr1", &Dtool_LightRampAttrib_make_hdr1_1607, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_hdr1_1607_comment},
  {"make_hdr2", &Dtool_LightRampAttrib_make_hdr2_1608, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_hdr2_1608_comment},
  {"makeHdr2", &Dtool_LightRampAttrib_make_hdr2_1608, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_make_hdr2_1608_comment},
  {"get_mode", &Dtool_LightRampAttrib_get_mode_1609, METH_NOARGS, (const char *)Dtool_LightRampAttrib_get_mode_1609_comment},
  {"getMode", &Dtool_LightRampAttrib_get_mode_1609, METH_NOARGS, (const char *)Dtool_LightRampAttrib_get_mode_1609_comment},
  {"get_level", &Dtool_LightRampAttrib_get_level_1610, METH_O, (const char *)Dtool_LightRampAttrib_get_level_1610_comment},
  {"getLevel", &Dtool_LightRampAttrib_get_level_1610, METH_O, (const char *)Dtool_LightRampAttrib_get_level_1610_comment},
  {"get_threshold", &Dtool_LightRampAttrib_get_threshold_1611, METH_O, (const char *)Dtool_LightRampAttrib_get_threshold_1611_comment},
  {"getThreshold", &Dtool_LightRampAttrib_get_threshold_1611, METH_O, (const char *)Dtool_LightRampAttrib_get_threshold_1611_comment},
  {"get_class_slot", &Dtool_LightRampAttrib_get_class_slot_1613, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_get_class_slot_1613_comment},
  {"getClassSlot", &Dtool_LightRampAttrib_get_class_slot_1613, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_get_class_slot_1613_comment},
  {"get_class_type", &Dtool_LightRampAttrib_get_class_type_1615, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_get_class_type_1615_comment},
  {"getClassType", &Dtool_LightRampAttrib_get_class_type_1615, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightRampAttrib_get_class_type_1615_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LightRampAttrib[] = {
  {(char *)"mode", &Dtool_LightRampAttrib_mode_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LightRampAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightRampAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LightRampAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LightRampAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LightRampAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LightRampAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LightRampAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LightRampAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LightRampAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LightRampAttrib,
    &Dtool_SequenceMethods_LightRampAttrib,
    &Dtool_MappingMethods_LightRampAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LightRampAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A Light Ramp is any unary operator that takes a rendered pixel as input,\n"
    " * and adjusts the brightness of that pixel.  For example, gamma correction is\n"
    " * a kind of light ramp.  So is HDR tone mapping.  So is cartoon shading.  See\n"
    " * the constructors for an explanation of each kind of ramp.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LightRampAttrib,
    nullptr, // tp_members
    Dtool_Properties_LightRampAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LightRampAttrib,
    PyType_GenericAlloc,
    Dtool_new_LightRampAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightRampAttrib,
  Dtool_UpcastInterface_LightRampAttrib,
  Dtool_DowncastInterface_LightRampAttrib,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LightRampAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_LightRampAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_LightRampAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(15);
    Dtool_LightRampAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LightRampAttrib::LightRampMode;
    PyDict_SetItemString(dict, "LRT_default", Dtool_WrapValue(LightRampAttrib::LRT_default));
    PyDict_SetItemString(dict, "LRTDefault", Dtool_WrapValue(LightRampAttrib::LRT_default));
    PyDict_SetItemString(dict, "LRT_identity", Dtool_WrapValue(LightRampAttrib::LRT_identity));
    PyDict_SetItemString(dict, "LRTIdentity", Dtool_WrapValue(LightRampAttrib::LRT_identity));
    PyDict_SetItemString(dict, "LRT_single_threshold", Dtool_WrapValue(LightRampAttrib::LRT_single_threshold));
    PyDict_SetItemString(dict, "LRTSingleThreshold", Dtool_WrapValue(LightRampAttrib::LRT_single_threshold));
    PyDict_SetItemString(dict, "LRT_double_threshold", Dtool_WrapValue(LightRampAttrib::LRT_double_threshold));
    PyDict_SetItemString(dict, "LRTDoubleThreshold", Dtool_WrapValue(LightRampAttrib::LRT_double_threshold));
    PyDict_SetItemString(dict, "LRT_hdr0", Dtool_WrapValue(LightRampAttrib::LRT_hdr0));
    PyDict_SetItemString(dict, "LRTHdr0", Dtool_WrapValue(LightRampAttrib::LRT_hdr0));
    PyDict_SetItemString(dict, "LRT_hdr1", Dtool_WrapValue(LightRampAttrib::LRT_hdr1));
    PyDict_SetItemString(dict, "LRTHdr1", Dtool_WrapValue(LightRampAttrib::LRT_hdr1));
    PyDict_SetItemString(dict, "LRT_hdr2", Dtool_WrapValue(LightRampAttrib::LRT_hdr2));
    PyDict_SetItemString(dict, "LRTHdr2", Dtool_WrapValue(LightRampAttrib::LRT_hdr2));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_LightRampAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_LightRampAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_LightRampAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightRampAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightRampAttrib);
  }
}

/**
 * Python method tables for Loader_Results (Results)
 */
static PyMethodDef Dtool_Methods_Loader_Results[] = {
  {"assign", &Dtool_Loader_Results_operator_1624, METH_O, (const char *)Dtool_Loader_Results_operator_1624_comment},
  {"clear", &Dtool_Loader_Results_clear_1626, METH_NOARGS, (const char *)Dtool_Loader_Results_clear_1626_comment},
  {"get_num_files", &Dtool_Loader_Results_get_num_files_1627, METH_NOARGS, (const char *)Dtool_Loader_Results_get_num_files_1627_comment},
  {"getNumFiles", &Dtool_Loader_Results_get_num_files_1627, METH_NOARGS, (const char *)Dtool_Loader_Results_get_num_files_1627_comment},
  {"get_file", &Dtool_Loader_Results_get_file_1628, METH_O, (const char *)Dtool_Loader_Results_get_file_1628_comment},
  {"getFile", &Dtool_Loader_Results_get_file_1628, METH_O, (const char *)Dtool_Loader_Results_get_file_1628_comment},
  {"get_file_type", &Dtool_Loader_Results_get_file_type_1630, METH_O, (const char *)Dtool_Loader_Results_get_file_type_1630_comment},
  {"getFileType", &Dtool_Loader_Results_get_file_type_1630, METH_O, (const char *)Dtool_Loader_Results_get_file_type_1630_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_files", (PyCFunction) &MakeSeq_Loader_Results_get_files, METH_NOARGS, nullptr},
  { "getFiles", (PyCFunction) &MakeSeq_Loader_Results_get_files, METH_NOARGS, nullptr},
  {"get_file_types", (PyCFunction) &MakeSeq_Loader_Results_get_file_types, METH_NOARGS, nullptr},
  { "getFileTypes", (PyCFunction) &MakeSeq_Loader_Results_get_file_types, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Loader_Results = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Loader_Results = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Results",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Loader_Results,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Loader_Results,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Loader_Results,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Loader_Results,
    PyType_GenericAlloc,
    Dtool_new_Loader_Results,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Loader_Results,
  Dtool_UpcastInterface_Loader_Results,
  Dtool_DowncastInterface_Loader_Results,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Loader_Results(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Loader_Results._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Loader_Results._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Loader_Results) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Loader_Results)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Loader_Results);
  }
}

/**
 * Python method tables for Loader (Loader)
 */
static PyMethodDef Dtool_Methods_Loader[] = {
  {"set_task_manager", &Dtool_Loader_set_task_manager_1633, METH_O, (const char *)Dtool_Loader_set_task_manager_1633_comment},
  {"setTaskManager", &Dtool_Loader_set_task_manager_1633, METH_O, (const char *)Dtool_Loader_set_task_manager_1633_comment},
  {"get_task_manager", &Dtool_Loader_get_task_manager_1634, METH_NOARGS, (const char *)Dtool_Loader_get_task_manager_1634_comment},
  {"getTaskManager", &Dtool_Loader_get_task_manager_1634, METH_NOARGS, (const char *)Dtool_Loader_get_task_manager_1634_comment},
  {"set_task_chain", &Dtool_Loader_set_task_chain_1635, METH_O, (const char *)Dtool_Loader_set_task_chain_1635_comment},
  {"setTaskChain", &Dtool_Loader_set_task_chain_1635, METH_O, (const char *)Dtool_Loader_set_task_chain_1635_comment},
  {"get_task_chain", &Dtool_Loader_get_task_chain_1636, METH_NOARGS, (const char *)Dtool_Loader_get_task_chain_1636_comment},
  {"getTaskChain", &Dtool_Loader_get_task_chain_1636, METH_NOARGS, (const char *)Dtool_Loader_get_task_chain_1636_comment},
  {"stop_threads", &Dtool_Loader_stop_threads_1637, METH_NOARGS, (const char *)Dtool_Loader_stop_threads_1637_comment},
  {"stopThreads", &Dtool_Loader_stop_threads_1637, METH_NOARGS, (const char *)Dtool_Loader_stop_threads_1637_comment},
  {"remove", &Dtool_Loader_remove_1638, METH_O, (const char *)Dtool_Loader_remove_1638_comment},
  {"load_sync", (PyCFunction) &Dtool_Loader_load_sync_1639, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Loader_load_sync_1639_comment},
  {"loadSync", (PyCFunction) &Dtool_Loader_load_sync_1639, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Loader_load_sync_1639_comment},
  {"make_async_request", (PyCFunction) &Dtool_Loader_make_async_request_1640, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Loader_make_async_request_1640_comment},
  {"makeAsyncRequest", (PyCFunction) &Dtool_Loader_make_async_request_1640, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Loader_make_async_request_1640_comment},
  {"load_async", &Dtool_Loader_load_async_1641, METH_O, (const char *)Dtool_Loader_load_async_1641_comment},
  {"loadAsync", &Dtool_Loader_load_async_1641, METH_O, (const char *)Dtool_Loader_load_async_1641_comment},
  {"save_sync", (PyCFunction) &Dtool_Loader_save_sync_1642, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Loader_save_sync_1642_comment},
  {"saveSync", (PyCFunction) &Dtool_Loader_save_sync_1642, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Loader_save_sync_1642_comment},
  {"make_async_save_request", (PyCFunction) &Dtool_Loader_make_async_save_request_1643, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Loader_make_async_save_request_1643_comment},
  {"makeAsyncSaveRequest", (PyCFunction) &Dtool_Loader_make_async_save_request_1643, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Loader_make_async_save_request_1643_comment},
  {"save_async", &Dtool_Loader_save_async_1644, METH_O, (const char *)Dtool_Loader_save_async_1644_comment},
  {"saveAsync", &Dtool_Loader_save_async_1644, METH_O, (const char *)Dtool_Loader_save_async_1644_comment},
  {"load_bam_stream", &Dtool_Loader_load_bam_stream_1645, METH_O, (const char *)Dtool_Loader_load_bam_stream_1645_comment},
  {"loadBamStream", &Dtool_Loader_load_bam_stream_1645, METH_O, (const char *)Dtool_Loader_load_bam_stream_1645_comment},
  {"output", &Dtool_Loader_output_1646, METH_O, (const char *)Dtool_Loader_output_1646_comment},
  {"get_global_ptr", &Dtool_Loader_get_global_ptr_1647, METH_NOARGS | METH_STATIC, (const char *)Dtool_Loader_get_global_ptr_1647_comment},
  {"getGlobalPtr", &Dtool_Loader_get_global_ptr_1647, METH_NOARGS | METH_STATIC, (const char *)Dtool_Loader_get_global_ptr_1647_comment},
  {"get_class_type", &Dtool_Loader_get_class_type_1648, METH_NOARGS | METH_STATIC, (const char *)Dtool_Loader_get_class_type_1648_comment},
  {"getClassType", &Dtool_Loader_get_class_type_1648, METH_NOARGS | METH_STATIC, (const char *)Dtool_Loader_get_class_type_1648_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_Loader_upcast_to_TypedReferenceCount_1618, METH_NOARGS, (const char *)Dtool_Loader_upcast_to_TypedReferenceCount_1618_comment},
  {"upcastToTypedReferenceCount", &Dtool_Loader_upcast_to_TypedReferenceCount_1618, METH_NOARGS, (const char *)Dtool_Loader_upcast_to_TypedReferenceCount_1618_comment},
  {"upcast_to_Namable", &Dtool_Loader_upcast_to_Namable_1620, METH_NOARGS, (const char *)Dtool_Loader_upcast_to_Namable_1620_comment},
  {"upcastToNamable", &Dtool_Loader_upcast_to_Namable_1620, METH_NOARGS, (const char *)Dtool_Loader_upcast_to_Namable_1620_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     Loader
//////////////////
static PyObject *Dtool_Repr_Loader(PyObject *self) {
  Loader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Loader, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_Loader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Loader = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Loader = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Loader = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Loader = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Loader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Loader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Loader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Loader,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_Loader,
    &Dtool_NumberMethods_Loader,
    &Dtool_SequenceMethods_Loader,
    &Dtool_MappingMethods_Loader,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_Loader,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Loader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A convenient class for loading models from disk, in bam or egg format (or\n"
    " * any of a number of other formats implemented by a LoaderFileType, such as\n"
    " * ptloader).\n"
    " *\n"
    " * This class supports synchronous as well as asynchronous loading.  In\n"
    " * asynchronous loading, the model is loaded in the background by a thread,\n"
    " * and an event will be generated when the model is available.  If threading\n"
    " * is not available, the asynchronous loading interface may be used, but it\n"
    " * loads synchronously.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Loader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Loader,
    PyType_GenericAlloc,
    Dtool_new_Loader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Loader,
  Dtool_UpcastInterface_Loader,
  Dtool_DowncastInterface_Loader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Loader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_Loader._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_Loader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Loader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Nested Object   Loader_Results;
    Dtool_PyModuleClassInit_Loader_Results(nullptr);
    PyDict_SetItemString(dict, "Results", (PyObject *)&Dtool_Loader_Results);
    if (PyType_Ready((PyTypeObject *)&Dtool_Loader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Loader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Loader);
  }
}

/**
 * Python method tables for LoaderFileType (LoaderFileType)
 */
static PyMethodDef Dtool_Methods_LoaderFileType[] = {
  {"get_name", &Dtool_LoaderFileType_get_name_1652, METH_NOARGS, (const char *)Dtool_LoaderFileType_get_name_1652_comment},
  {"getName", &Dtool_LoaderFileType_get_name_1652, METH_NOARGS, (const char *)Dtool_LoaderFileType_get_name_1652_comment},
  {"get_extension", &Dtool_LoaderFileType_get_extension_1653, METH_NOARGS, (const char *)Dtool_LoaderFileType_get_extension_1653_comment},
  {"getExtension", &Dtool_LoaderFileType_get_extension_1653, METH_NOARGS, (const char *)Dtool_LoaderFileType_get_extension_1653_comment},
  {"get_additional_extensions", &Dtool_LoaderFileType_get_additional_extensions_1654, METH_NOARGS, (const char *)Dtool_LoaderFileType_get_additional_extensions_1654_comment},
  {"getAdditionalExtensions", &Dtool_LoaderFileType_get_additional_extensions_1654, METH_NOARGS, (const char *)Dtool_LoaderFileType_get_additional_extensions_1654_comment},
  {"supports_compressed", &Dtool_LoaderFileType_supports_compressed_1655, METH_NOARGS, (const char *)Dtool_LoaderFileType_supports_compressed_1655_comment},
  {"supportsCompressed", &Dtool_LoaderFileType_supports_compressed_1655, METH_NOARGS, (const char *)Dtool_LoaderFileType_supports_compressed_1655_comment},
  {"get_allow_disk_cache", &Dtool_LoaderFileType_get_allow_disk_cache_1656, METH_O, (const char *)Dtool_LoaderFileType_get_allow_disk_cache_1656_comment},
  {"getAllowDiskCache", &Dtool_LoaderFileType_get_allow_disk_cache_1656, METH_O, (const char *)Dtool_LoaderFileType_get_allow_disk_cache_1656_comment},
  {"get_allow_ram_cache", &Dtool_LoaderFileType_get_allow_ram_cache_1657, METH_O, (const char *)Dtool_LoaderFileType_get_allow_ram_cache_1657_comment},
  {"getAllowRamCache", &Dtool_LoaderFileType_get_allow_ram_cache_1657, METH_O, (const char *)Dtool_LoaderFileType_get_allow_ram_cache_1657_comment},
  {"supports_load", &Dtool_LoaderFileType_supports_load_1658, METH_NOARGS, (const char *)Dtool_LoaderFileType_supports_load_1658_comment},
  {"supportsLoad", &Dtool_LoaderFileType_supports_load_1658, METH_NOARGS, (const char *)Dtool_LoaderFileType_supports_load_1658_comment},
  {"supports_save", &Dtool_LoaderFileType_supports_save_1659, METH_NOARGS, (const char *)Dtool_LoaderFileType_supports_save_1659_comment},
  {"supportsSave", &Dtool_LoaderFileType_supports_save_1659, METH_NOARGS, (const char *)Dtool_LoaderFileType_supports_save_1659_comment},
  {"get_class_type", &Dtool_LoaderFileType_get_class_type_1660, METH_NOARGS | METH_STATIC, (const char *)Dtool_LoaderFileType_get_class_type_1660_comment},
  {"getClassType", &Dtool_LoaderFileType_get_class_type_1660, METH_NOARGS | METH_STATIC, (const char *)Dtool_LoaderFileType_get_class_type_1660_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LoaderFileType = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LoaderFileType = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LoaderFileType = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LoaderFileType = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LoaderFileType = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LoaderFileType = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LoaderFileType",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LoaderFileType,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LoaderFileType,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LoaderFileType,
    &Dtool_SequenceMethods_LoaderFileType,
    &Dtool_MappingMethods_LoaderFileType,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LoaderFileType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for a family of scene-graph file types that the\n"
    " * Loader supports.  Each kind of loader that's available should define a\n"
    " * corresponding LoaderFileType object and register itself.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LoaderFileType,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LoaderFileType,
    PyType_GenericAlloc,
    Dtool_new_LoaderFileType,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LoaderFileType,
  Dtool_UpcastInterface_LoaderFileType,
  Dtool_DowncastInterface_LoaderFileType,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LoaderFileType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_LoaderFileType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_LoaderFileType._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LoaderFileType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LoaderFileType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LoaderFileType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LoaderFileType);
  }
}

/**
 * Python method tables for LoaderFileTypeRegistry (LoaderFileTypeRegistry)
 */
static PyMethodDef Dtool_Methods_LoaderFileTypeRegistry[] = {
  {"register_type", &Dtool_LoaderFileTypeRegistry_register_type_1663, METH_O, (const char *)Dtool_LoaderFileTypeRegistry_register_type_1663_comment},
  {"registerType", &Dtool_LoaderFileTypeRegistry_register_type_1663, METH_O, (const char *)Dtool_LoaderFileTypeRegistry_register_type_1663_comment},
  {"register_deferred_type", &Dtool_LoaderFileTypeRegistry_register_deferred_type_1664, METH_O, (const char *)Dtool_LoaderFileTypeRegistry_register_deferred_type_1664_comment},
  {"registerDeferredType", &Dtool_LoaderFileTypeRegistry_register_deferred_type_1664, METH_O, (const char *)Dtool_LoaderFileTypeRegistry_register_deferred_type_1664_comment},
  {"unregister_type", &Dtool_LoaderFileTypeRegistry_unregister_type_1665, METH_O, (const char *)Dtool_LoaderFileTypeRegistry_unregister_type_1665_comment},
  {"unregisterType", &Dtool_LoaderFileTypeRegistry_unregister_type_1665, METH_O, (const char *)Dtool_LoaderFileTypeRegistry_unregister_type_1665_comment},
  {"get_num_types", &Dtool_LoaderFileTypeRegistry_get_num_types_1666, METH_NOARGS, (const char *)Dtool_LoaderFileTypeRegistry_get_num_types_1666_comment},
  {"getNumTypes", &Dtool_LoaderFileTypeRegistry_get_num_types_1666, METH_NOARGS, (const char *)Dtool_LoaderFileTypeRegistry_get_num_types_1666_comment},
  {"get_type", &Dtool_LoaderFileTypeRegistry_get_type_1667, METH_O, (const char *)Dtool_LoaderFileTypeRegistry_get_type_1667_comment},
  {"getType", &Dtool_LoaderFileTypeRegistry_get_type_1667, METH_O, (const char *)Dtool_LoaderFileTypeRegistry_get_type_1667_comment},
  {"get_type_from_extension", &Dtool_LoaderFileTypeRegistry_get_type_from_extension_1671, METH_O, (const char *)Dtool_LoaderFileTypeRegistry_get_type_from_extension_1671_comment},
  {"getTypeFromExtension", &Dtool_LoaderFileTypeRegistry_get_type_from_extension_1671, METH_O, (const char *)Dtool_LoaderFileTypeRegistry_get_type_from_extension_1671_comment},
  {"write", (PyCFunction) &Dtool_LoaderFileTypeRegistry_write_1672, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LoaderFileTypeRegistry_write_1672_comment},
  {"get_global_ptr", &Dtool_LoaderFileTypeRegistry_get_global_ptr_1673, METH_NOARGS | METH_STATIC, (const char *)Dtool_LoaderFileTypeRegistry_get_global_ptr_1673_comment},
  {"getGlobalPtr", &Dtool_LoaderFileTypeRegistry_get_global_ptr_1673, METH_NOARGS | METH_STATIC, (const char *)Dtool_LoaderFileTypeRegistry_get_global_ptr_1673_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_types", (PyCFunction) &MakeSeq_LoaderFileTypeRegistry_get_types, METH_NOARGS, nullptr},
  { "getTypes", (PyCFunction) &MakeSeq_LoaderFileTypeRegistry_get_types, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     LoaderFileTypeRegistry
//////////////////
static PyObject *Dtool_Str_LoaderFileTypeRegistry(PyObject *self) {
  LoaderFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderFileTypeRegistry, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_LoaderFileTypeRegistry[] = {
  {(char *)"types", &Dtool_LoaderFileTypeRegistry_types_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LoaderFileTypeRegistry = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LoaderFileTypeRegistry = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LoaderFileTypeRegistry",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LoaderFileTypeRegistry,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LoaderFileTypeRegistry,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_LoaderFileTypeRegistry,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class maintains the set of all known LoaderFileTypes in the universe.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LoaderFileTypeRegistry,
    nullptr, // tp_members
    Dtool_Properties_LoaderFileTypeRegistry,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LoaderFileTypeRegistry,
    PyType_GenericAlloc,
    Dtool_new_LoaderFileTypeRegistry,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LoaderFileTypeRegistry,
  Dtool_UpcastInterface_LoaderFileTypeRegistry,
  Dtool_DowncastInterface_LoaderFileTypeRegistry,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LoaderFileTypeRegistry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LoaderFileTypeRegistry._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LoaderFileTypeRegistry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LoaderFileTypeRegistry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LoaderFileTypeRegistry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LoaderFileTypeRegistry);
  }
}

/**
 * Python method tables for MaterialAttrib (MaterialAttrib)
 */
static PyMethodDef Dtool_Methods_MaterialAttrib[] = {
  {"make", &Dtool_MaterialAttrib_make_1676, METH_O | METH_STATIC, (const char *)Dtool_MaterialAttrib_make_1676_comment},
  {"make_off", &Dtool_MaterialAttrib_make_off_1677, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialAttrib_make_off_1677_comment},
  {"makeOff", &Dtool_MaterialAttrib_make_off_1677, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialAttrib_make_off_1677_comment},
  {"make_default", &Dtool_MaterialAttrib_make_default_1678, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialAttrib_make_default_1678_comment},
  {"makeDefault", &Dtool_MaterialAttrib_make_default_1678, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialAttrib_make_default_1678_comment},
  {"is_off", &Dtool_MaterialAttrib_is_off_1679, METH_NOARGS, (const char *)Dtool_MaterialAttrib_is_off_1679_comment},
  {"isOff", &Dtool_MaterialAttrib_is_off_1679, METH_NOARGS, (const char *)Dtool_MaterialAttrib_is_off_1679_comment},
  {"get_material", &Dtool_MaterialAttrib_get_material_1680, METH_NOARGS, (const char *)Dtool_MaterialAttrib_get_material_1680_comment},
  {"getMaterial", &Dtool_MaterialAttrib_get_material_1680, METH_NOARGS, (const char *)Dtool_MaterialAttrib_get_material_1680_comment},
  {"get_class_slot", &Dtool_MaterialAttrib_get_class_slot_1684, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialAttrib_get_class_slot_1684_comment},
  {"getClassSlot", &Dtool_MaterialAttrib_get_class_slot_1684, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialAttrib_get_class_slot_1684_comment},
  {"get_class_type", &Dtool_MaterialAttrib_get_class_type_1686, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialAttrib_get_class_type_1686_comment},
  {"getClassType", &Dtool_MaterialAttrib_get_class_type_1686, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialAttrib_get_class_type_1686_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_MaterialAttrib[] = {
  {(char *)"material", &Dtool_MaterialAttrib_material_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_MaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MaterialAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MaterialAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MaterialAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MaterialAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MaterialAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MaterialAttrib,
    &Dtool_SequenceMethods_MaterialAttrib,
    &Dtool_MappingMethods_MaterialAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MaterialAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Indicates which, if any, material should be applied to geometry.  The\n"
    " * material is used primarily to control lighting effects, and isn't necessary\n"
    " * (or useful) in the absence of lighting.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MaterialAttrib,
    nullptr, // tp_members
    Dtool_Properties_MaterialAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MaterialAttrib,
    PyType_GenericAlloc,
    Dtool_new_MaterialAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MaterialAttrib,
  Dtool_UpcastInterface_MaterialAttrib,
  Dtool_DowncastInterface_MaterialAttrib,
  (CoerceFunction)Dtool_ConstCoerce_MaterialAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_MaterialAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_MaterialAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_MaterialAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MaterialAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_MaterialAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_MaterialAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_MaterialAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MaterialAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MaterialAttrib);
  }
}

/**
 * Python method tables for ModelFlattenRequest (ModelFlattenRequest)
 */
static PyMethodDef Dtool_Methods_ModelFlattenRequest[] = {
  {"get_orig", &Dtool_ModelFlattenRequest_get_orig_1691, METH_NOARGS, (const char *)Dtool_ModelFlattenRequest_get_orig_1691_comment},
  {"getOrig", &Dtool_ModelFlattenRequest_get_orig_1691, METH_NOARGS, (const char *)Dtool_ModelFlattenRequest_get_orig_1691_comment},
  {"is_ready", &Dtool_ModelFlattenRequest_is_ready_1692, METH_NOARGS, (const char *)Dtool_ModelFlattenRequest_is_ready_1692_comment},
  {"isReady", &Dtool_ModelFlattenRequest_is_ready_1692, METH_NOARGS, (const char *)Dtool_ModelFlattenRequest_is_ready_1692_comment},
  {"get_model", &Dtool_ModelFlattenRequest_get_model_1693, METH_NOARGS, (const char *)Dtool_ModelFlattenRequest_get_model_1693_comment},
  {"getModel", &Dtool_ModelFlattenRequest_get_model_1693, METH_NOARGS, (const char *)Dtool_ModelFlattenRequest_get_model_1693_comment},
  {"get_class_type", &Dtool_ModelFlattenRequest_get_class_type_1695, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelFlattenRequest_get_class_type_1695_comment},
  {"getClassType", &Dtool_ModelFlattenRequest_get_class_type_1695, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelFlattenRequest_get_class_type_1695_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ModelFlattenRequest[] = {
  {(char *)"orig", &Dtool_ModelFlattenRequest_orig_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ModelFlattenRequest = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ModelFlattenRequest = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ModelFlattenRequest = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ModelFlattenRequest = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ModelFlattenRequest = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ModelFlattenRequest = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ModelFlattenRequest",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ModelFlattenRequest,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ModelFlattenRequest,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ModelFlattenRequest,
    &Dtool_SequenceMethods_ModelFlattenRequest,
    &Dtool_MappingMethods_ModelFlattenRequest,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ModelFlattenRequest,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class object manages a single asynchronous request to flatten a model.\n"
    " * The model will be duplicated and flattened in a sub-thread (if threading is\n"
    " * available), without affecting the original model; and when the result is\n"
    " * done it may be retrieved from this object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ModelFlattenRequest,
    nullptr, // tp_members
    Dtool_Properties_ModelFlattenRequest,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ModelFlattenRequest,
    PyType_GenericAlloc,
    Dtool_new_ModelFlattenRequest,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ModelFlattenRequest,
  Dtool_UpcastInterface_ModelFlattenRequest,
  Dtool_DowncastInterface_ModelFlattenRequest,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ModelFlattenRequest(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_AsyncTask != nullptr);
    assert(Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit(nullptr);
    Dtool_ModelFlattenRequest._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_AsyncTask);
    Dtool_ModelFlattenRequest._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ModelFlattenRequest._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ModelFlattenRequest) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ModelFlattenRequest)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ModelFlattenRequest);
  }
}

/**
 * Python method tables for ModelLoadRequest (ModelLoadRequest)
 */
static PyMethodDef Dtool_Methods_ModelLoadRequest[] = {
  {"get_filename", &Dtool_ModelLoadRequest_get_filename_1699, METH_NOARGS, (const char *)Dtool_ModelLoadRequest_get_filename_1699_comment},
  {"getFilename", &Dtool_ModelLoadRequest_get_filename_1699, METH_NOARGS, (const char *)Dtool_ModelLoadRequest_get_filename_1699_comment},
  {"get_options", &Dtool_ModelLoadRequest_get_options_1700, METH_NOARGS, (const char *)Dtool_ModelLoadRequest_get_options_1700_comment},
  {"getOptions", &Dtool_ModelLoadRequest_get_options_1700, METH_NOARGS, (const char *)Dtool_ModelLoadRequest_get_options_1700_comment},
  {"get_loader", &Dtool_ModelLoadRequest_get_loader_1701, METH_NOARGS, (const char *)Dtool_ModelLoadRequest_get_loader_1701_comment},
  {"getLoader", &Dtool_ModelLoadRequest_get_loader_1701, METH_NOARGS, (const char *)Dtool_ModelLoadRequest_get_loader_1701_comment},
  {"is_ready", &Dtool_ModelLoadRequest_is_ready_1702, METH_NOARGS, (const char *)Dtool_ModelLoadRequest_is_ready_1702_comment},
  {"isReady", &Dtool_ModelLoadRequest_is_ready_1702, METH_NOARGS, (const char *)Dtool_ModelLoadRequest_is_ready_1702_comment},
  {"get_model", &Dtool_ModelLoadRequest_get_model_1703, METH_NOARGS, (const char *)Dtool_ModelLoadRequest_get_model_1703_comment},
  {"getModel", &Dtool_ModelLoadRequest_get_model_1703, METH_NOARGS, (const char *)Dtool_ModelLoadRequest_get_model_1703_comment},
  {"get_class_type", &Dtool_ModelLoadRequest_get_class_type_1712, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelLoadRequest_get_class_type_1712_comment},
  {"getClassType", &Dtool_ModelLoadRequest_get_class_type_1712, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelLoadRequest_get_class_type_1712_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ModelLoadRequest[] = {
  {(char *)"filename", &Dtool_ModelLoadRequest_filename_Getter, nullptr, nullptr, nullptr},
  {(char *)"options", &Dtool_ModelLoadRequest_options_Getter, nullptr, nullptr, nullptr},
  {(char *)"loader", &Dtool_ModelLoadRequest_loader_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ModelLoadRequest = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ModelLoadRequest = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ModelLoadRequest = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ModelLoadRequest = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ModelLoadRequest = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ModelLoadRequest = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ModelLoadRequest",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ModelLoadRequest,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ModelLoadRequest,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ModelLoadRequest,
    &Dtool_SequenceMethods_ModelLoadRequest,
    &Dtool_MappingMethods_ModelLoadRequest,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ModelLoadRequest,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class object that manages a single asynchronous model load request.\n"
    " * Create a new ModelLoadRequest, and add it to the loader via load_async(),\n"
    " * to begin an asynchronous load.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ModelLoadRequest,
    nullptr, // tp_members
    Dtool_Properties_ModelLoadRequest,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ModelLoadRequest,
    PyType_GenericAlloc,
    Dtool_new_ModelLoadRequest,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ModelLoadRequest,
  Dtool_UpcastInterface_ModelLoadRequest,
  Dtool_DowncastInterface_ModelLoadRequest,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ModelLoadRequest(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_AsyncTask != nullptr);
    assert(Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit(nullptr);
    Dtool_ModelLoadRequest._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_AsyncTask);
    Dtool_ModelLoadRequest._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ModelLoadRequest._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ModelLoadRequest) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ModelLoadRequest)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ModelLoadRequest);
  }
}

/**
 * Python method tables for ModelNode (ModelNode)
 */
static PyMethodDef Dtool_Methods_ModelNode[] = {
  {"set_preserve_transform", &Dtool_ModelNode_set_preserve_transform_1717, METH_O, (const char *)Dtool_ModelNode_set_preserve_transform_1717_comment},
  {"setPreserveTransform", &Dtool_ModelNode_set_preserve_transform_1717, METH_O, (const char *)Dtool_ModelNode_set_preserve_transform_1717_comment},
  {"get_preserve_transform", &Dtool_ModelNode_get_preserve_transform_1718, METH_NOARGS, (const char *)Dtool_ModelNode_get_preserve_transform_1718_comment},
  {"getPreserveTransform", &Dtool_ModelNode_get_preserve_transform_1718, METH_NOARGS, (const char *)Dtool_ModelNode_get_preserve_transform_1718_comment},
  {"set_preserve_attributes", &Dtool_ModelNode_set_preserve_attributes_1719, METH_O, (const char *)Dtool_ModelNode_set_preserve_attributes_1719_comment},
  {"setPreserveAttributes", &Dtool_ModelNode_set_preserve_attributes_1719, METH_O, (const char *)Dtool_ModelNode_set_preserve_attributes_1719_comment},
  {"get_preserve_attributes", &Dtool_ModelNode_get_preserve_attributes_1720, METH_NOARGS, (const char *)Dtool_ModelNode_get_preserve_attributes_1720_comment},
  {"getPreserveAttributes", &Dtool_ModelNode_get_preserve_attributes_1720, METH_NOARGS, (const char *)Dtool_ModelNode_get_preserve_attributes_1720_comment},
  {"set_transform_limit", &Dtool_ModelNode_set_transform_limit_1721, METH_O, (const char *)Dtool_ModelNode_set_transform_limit_1721_comment},
  {"setTransformLimit", &Dtool_ModelNode_set_transform_limit_1721, METH_O, (const char *)Dtool_ModelNode_set_transform_limit_1721_comment},
  {"get_class_type", &Dtool_ModelNode_get_class_type_1722, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelNode_get_class_type_1722_comment},
  {"getClassType", &Dtool_ModelNode_get_class_type_1722, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelNode_get_class_type_1722_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ModelNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ModelNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ModelNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ModelNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ModelNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ModelNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ModelNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ModelNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ModelNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ModelNode,
    &Dtool_SequenceMethods_ModelNode,
    &Dtool_MappingMethods_ModelNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ModelNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This node is placed at key points within the scene graph to indicate the\n"
    " * roots of \"models\": subtrees that are conceptually to be treated as a single\n"
    " * unit, like a car or a room, for instance.  It doesn't affect rendering or\n"
    " * any other operations; it's primarily useful as a high-level model\n"
    " * indication.\n"
    " *\n"
    " * ModelNodes are created in response to a <Model> { 1 } flag within an egg\n"
    " * file.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ModelNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ModelNode,
    PyType_GenericAlloc,
    Dtool_new_ModelNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ModelNode,
  Dtool_UpcastInterface_ModelNode,
  Dtool_DowncastInterface_ModelNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ModelNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PandaNode(nullptr);
    Dtool_ModelNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PandaNode);
    Dtool_ModelNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_ModelNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ModelNode::PreserveTransform;
    PyDict_SetItemString(dict, "PT_none", Dtool_WrapValue(ModelNode::PT_none));
    PyDict_SetItemString(dict, "PTNone", Dtool_WrapValue(ModelNode::PT_none));
    PyDict_SetItemString(dict, "PT_local", Dtool_WrapValue(ModelNode::PT_local));
    PyDict_SetItemString(dict, "PTLocal", Dtool_WrapValue(ModelNode::PT_local));
    PyDict_SetItemString(dict, "PT_net", Dtool_WrapValue(ModelNode::PT_net));
    PyDict_SetItemString(dict, "PTNet", Dtool_WrapValue(ModelNode::PT_net));
    PyDict_SetItemString(dict, "PT_drop_node", Dtool_WrapValue(ModelNode::PT_drop_node));
    PyDict_SetItemString(dict, "PTDropNode", Dtool_WrapValue(ModelNode::PT_drop_node));
    PyDict_SetItemString(dict, "PT_no_touch", Dtool_WrapValue(ModelNode::PT_no_touch));
    PyDict_SetItemString(dict, "PTNoTouch", Dtool_WrapValue(ModelNode::PT_no_touch));
    if (PyType_Ready((PyTypeObject *)&Dtool_ModelNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ModelNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ModelNode);
  }
}

/**
 * Python method tables for ModelRoot_ModelReference (ModelReference)
 */
static PyMethodDef Dtool_Methods_ModelRoot_ModelReference[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ModelRoot_ModelReference = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ModelRoot_ModelReference = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ModelRoot_ModelReference = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ModelRoot_ModelReference = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ModelRoot_ModelReference = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ModelRoot_ModelReference = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ModelReference",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ModelRoot_ModelReference,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ModelRoot_ModelReference,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ModelRoot_ModelReference,
    &Dtool_SequenceMethods_ModelRoot_ModelReference,
    &Dtool_MappingMethods_ModelRoot_ModelReference,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ModelRoot_ModelReference,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// This class is used to unify references to the same model.",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ModelRoot_ModelReference,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ModelRoot_ModelReference,
    PyType_GenericAlloc,
    Dtool_new_ModelRoot_ModelReference,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ModelRoot_ModelReference,
  Dtool_UpcastInterface_ModelRoot_ModelReference,
  Dtool_DowncastInterface_ModelRoot_ModelReference,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ModelRoot_ModelReference(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_ModelRoot_ModelReference._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_ModelRoot_ModelReference._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ModelRoot_ModelReference._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ModelRoot_ModelReference) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ModelRoot_ModelReference)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ModelRoot_ModelReference);
  }
}

/**
 * Python method tables for ModelRoot (ModelRoot)
 */
static PyMethodDef Dtool_Methods_ModelRoot[] = {
  {"get_model_ref_count", &Dtool_ModelRoot_get_model_ref_count_1726, METH_NOARGS, (const char *)Dtool_ModelRoot_get_model_ref_count_1726_comment},
  {"getModelRefCount", &Dtool_ModelRoot_get_model_ref_count_1726, METH_NOARGS, (const char *)Dtool_ModelRoot_get_model_ref_count_1726_comment},
  {"get_fullpath", &Dtool_ModelRoot_get_fullpath_1728, METH_NOARGS, (const char *)Dtool_ModelRoot_get_fullpath_1728_comment},
  {"getFullpath", &Dtool_ModelRoot_get_fullpath_1728, METH_NOARGS, (const char *)Dtool_ModelRoot_get_fullpath_1728_comment},
  {"set_fullpath", &Dtool_ModelRoot_set_fullpath_1729, METH_O, (const char *)Dtool_ModelRoot_set_fullpath_1729_comment},
  {"setFullpath", &Dtool_ModelRoot_set_fullpath_1729, METH_O, (const char *)Dtool_ModelRoot_set_fullpath_1729_comment},
  {"get_timestamp", &Dtool_ModelRoot_get_timestamp_1731, METH_NOARGS, (const char *)Dtool_ModelRoot_get_timestamp_1731_comment},
  {"getTimestamp", &Dtool_ModelRoot_get_timestamp_1731, METH_NOARGS, (const char *)Dtool_ModelRoot_get_timestamp_1731_comment},
  {"set_timestamp", &Dtool_ModelRoot_set_timestamp_1732, METH_O, (const char *)Dtool_ModelRoot_set_timestamp_1732_comment},
  {"setTimestamp", &Dtool_ModelRoot_set_timestamp_1732, METH_O, (const char *)Dtool_ModelRoot_set_timestamp_1732_comment},
  {"get_reference", &Dtool_ModelRoot_get_reference_1739, METH_NOARGS, (const char *)Dtool_ModelRoot_get_reference_1739_comment},
  {"getReference", &Dtool_ModelRoot_get_reference_1739, METH_NOARGS, (const char *)Dtool_ModelRoot_get_reference_1739_comment},
  {"set_reference", &Dtool_ModelRoot_set_reference_1740, METH_O, (const char *)Dtool_ModelRoot_set_reference_1740_comment},
  {"setReference", &Dtool_ModelRoot_set_reference_1740, METH_O, (const char *)Dtool_ModelRoot_set_reference_1740_comment},
  {"get_class_type", &Dtool_ModelRoot_get_class_type_1743, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelRoot_get_class_type_1743_comment},
  {"getClassType", &Dtool_ModelRoot_get_class_type_1743, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelRoot_get_class_type_1743_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ModelRoot[] = {
  {(char *)"model_ref_count", &Dtool_ModelRoot_model_ref_count_Getter, nullptr, nullptr, nullptr},
  {(char *)"fullpath", &Dtool_ModelRoot_fullpath_Getter, &Dtool_ModelRoot_fullpath_Setter, nullptr, nullptr},
  {(char *)"timestamp", &Dtool_ModelRoot_timestamp_Getter, &Dtool_ModelRoot_timestamp_Setter, nullptr, nullptr},
  {(char *)"reference", &Dtool_ModelRoot_reference_Getter, &Dtool_ModelRoot_reference_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ModelRoot = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ModelRoot = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ModelRoot = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ModelRoot = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ModelRoot = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ModelRoot = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ModelRoot",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ModelRoot,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ModelRoot,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ModelRoot,
    &Dtool_SequenceMethods_ModelRoot,
    &Dtool_MappingMethods_ModelRoot,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ModelRoot,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node of this type is created automatically at the root of each model file\n"
    " * that is loaded.  It may eventually contain some information about the\n"
    " * contents of the model; at the moment, it contains no special information,\n"
    " * but can be used as a flag to indicate the presence of a loaded model file.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ModelRoot,
    nullptr, // tp_members
    Dtool_Properties_ModelRoot,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ModelRoot,
    PyType_GenericAlloc,
    Dtool_new_ModelRoot,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ModelRoot,
  Dtool_UpcastInterface_ModelRoot,
  Dtool_DowncastInterface_ModelRoot,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ModelRoot(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ModelNode(nullptr);
    Dtool_ModelRoot._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ModelNode);
    Dtool_ModelRoot._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ModelRoot._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Nested Object   ModelRoot_ModelReference;
    Dtool_PyModuleClassInit_ModelRoot_ModelReference(nullptr);
    PyDict_SetItemString(dict, "ModelReference", (PyObject *)&Dtool_ModelRoot_ModelReference);
    if (PyType_Ready((PyTypeObject *)&Dtool_ModelRoot) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ModelRoot)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ModelRoot);
  }
}

/**
 * Python method tables for ModelPool (ModelPool)
 */
static PyMethodDef Dtool_Methods_ModelPool[] = {
  {"has_model", &Dtool_ModelPool_has_model_1746, METH_O | METH_STATIC, (const char *)Dtool_ModelPool_has_model_1746_comment},
  {"hasModel", &Dtool_ModelPool_has_model_1746, METH_O | METH_STATIC, (const char *)Dtool_ModelPool_has_model_1746_comment},
  {"verify_model", &Dtool_ModelPool_verify_model_1747, METH_O | METH_STATIC, (const char *)Dtool_ModelPool_verify_model_1747_comment},
  {"verifyModel", &Dtool_ModelPool_verify_model_1747, METH_O | METH_STATIC, (const char *)Dtool_ModelPool_verify_model_1747_comment},
  {"get_model", (PyCFunction) &Dtool_ModelPool_get_model_1748, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ModelPool_get_model_1748_comment},
  {"getModel", (PyCFunction) &Dtool_ModelPool_get_model_1748, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ModelPool_get_model_1748_comment},
  {"load_model", (PyCFunction) &Dtool_ModelPool_load_model_1749, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ModelPool_load_model_1749_comment},
  {"loadModel", (PyCFunction) &Dtool_ModelPool_load_model_1749, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ModelPool_load_model_1749_comment},
  {"add_model", (PyCFunction) &Dtool_ModelPool_add_model_1750, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ModelPool_add_model_1750_comment},
  {"addModel", (PyCFunction) &Dtool_ModelPool_add_model_1750, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ModelPool_add_model_1750_comment},
  {"release_model", &Dtool_ModelPool_release_model_1751, METH_O | METH_STATIC, (const char *)Dtool_ModelPool_release_model_1751_comment},
  {"releaseModel", &Dtool_ModelPool_release_model_1751, METH_O | METH_STATIC, (const char *)Dtool_ModelPool_release_model_1751_comment},
  {"release_all_models", &Dtool_ModelPool_release_all_models_1752, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelPool_release_all_models_1752_comment},
  {"releaseAllModels", &Dtool_ModelPool_release_all_models_1752, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelPool_release_all_models_1752_comment},
  {"garbage_collect", &Dtool_ModelPool_garbage_collect_1753, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelPool_garbage_collect_1753_comment},
  {"garbageCollect", &Dtool_ModelPool_garbage_collect_1753, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelPool_garbage_collect_1753_comment},
  {"list_contents", &Dtool_ModelPool_list_contents_1754, METH_VARARGS | METH_STATIC, (const char *)Dtool_ModelPool_list_contents_1754_comment},
  {"listContents", &Dtool_ModelPool_list_contents_1754, METH_VARARGS | METH_STATIC, (const char *)Dtool_ModelPool_list_contents_1754_comment},
  {"write", &Dtool_ModelPool_write_1755, METH_O | METH_STATIC, (const char *)Dtool_ModelPool_write_1755_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     ModelPool
//////////////////
static PyObject *Dtool_Str_ModelPool(PyObject *self) {
  ModelPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModelPool, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ModelPool = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ModelPool = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ModelPool",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ModelPool,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ModelPool,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ModelPool,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class unifies all references to the same filename, so that multiple\n"
    " * attempts to load the same model will return the same pointer.  Note that\n"
    " * the default behavior is thus to make instances: use with caution.  Use the\n"
    " * copy_subgraph() method on Node (or use NodePath::copy_to) to make\n"
    " * modifiable copies of the node.\n"
    " *\n"
    " * Unlike TexturePool, this class does not automatically resolve the model\n"
    " * filenames before loading, so a relative path and an absolute path to the\n"
    " * same model will appear to be different filenames.\n"
    " *\n"
    " * However, see the Loader class, which is now the preferred interface for\n"
    " * loading models.  The Loader class can resolve filenames, supports threaded\n"
    " * loading, and can automatically consult the ModelPool, according to the\n"
    " * supplied LoaderOptions.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ModelPool,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ModelPool,
    PyType_GenericAlloc,
    Dtool_new_ModelPool,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ModelPool,
  Dtool_UpcastInterface_ModelPool,
  Dtool_DowncastInterface_ModelPool,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ModelPool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ModelPool._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ModelPool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ModelPool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ModelPool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ModelPool);
  }
}

/**
 * Python method tables for ModelSaveRequest (ModelSaveRequest)
 */
static PyMethodDef Dtool_Methods_ModelSaveRequest[] = {
  {"get_filename", &Dtool_ModelSaveRequest_get_filename_1759, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_get_filename_1759_comment},
  {"getFilename", &Dtool_ModelSaveRequest_get_filename_1759, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_get_filename_1759_comment},
  {"get_options", &Dtool_ModelSaveRequest_get_options_1760, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_get_options_1760_comment},
  {"getOptions", &Dtool_ModelSaveRequest_get_options_1760, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_get_options_1760_comment},
  {"get_node", &Dtool_ModelSaveRequest_get_node_1761, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_get_node_1761_comment},
  {"getNode", &Dtool_ModelSaveRequest_get_node_1761, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_get_node_1761_comment},
  {"get_loader", &Dtool_ModelSaveRequest_get_loader_1762, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_get_loader_1762_comment},
  {"getLoader", &Dtool_ModelSaveRequest_get_loader_1762, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_get_loader_1762_comment},
  {"is_ready", &Dtool_ModelSaveRequest_is_ready_1763, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_is_ready_1763_comment},
  {"isReady", &Dtool_ModelSaveRequest_is_ready_1763, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_is_ready_1763_comment},
  {"get_success", &Dtool_ModelSaveRequest_get_success_1764, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_get_success_1764_comment},
  {"getSuccess", &Dtool_ModelSaveRequest_get_success_1764, METH_NOARGS, (const char *)Dtool_ModelSaveRequest_get_success_1764_comment},
  {"get_class_type", &Dtool_ModelSaveRequest_get_class_type_1769, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelSaveRequest_get_class_type_1769_comment},
  {"getClassType", &Dtool_ModelSaveRequest_get_class_type_1769, METH_NOARGS | METH_STATIC, (const char *)Dtool_ModelSaveRequest_get_class_type_1769_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ModelSaveRequest[] = {
  {(char *)"filename", &Dtool_ModelSaveRequest_filename_Getter, nullptr, nullptr, nullptr},
  {(char *)"options", &Dtool_ModelSaveRequest_options_Getter, nullptr, nullptr, nullptr},
  {(char *)"node", &Dtool_ModelSaveRequest_node_Getter, nullptr, nullptr, nullptr},
  {(char *)"loader", &Dtool_ModelSaveRequest_loader_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ModelSaveRequest = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ModelSaveRequest = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ModelSaveRequest = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ModelSaveRequest = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ModelSaveRequest = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ModelSaveRequest = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ModelSaveRequest",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ModelSaveRequest,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ModelSaveRequest,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ModelSaveRequest,
    &Dtool_SequenceMethods_ModelSaveRequest,
    &Dtool_MappingMethods_ModelSaveRequest,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ModelSaveRequest,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class object that manages a single asynchronous model save request.\n"
    " * Create a new ModelSaveRequest, and add it to the loader via save_async(),\n"
    " * to begin an asynchronous save.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ModelSaveRequest,
    nullptr, // tp_members
    Dtool_Properties_ModelSaveRequest,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ModelSaveRequest,
    PyType_GenericAlloc,
    Dtool_new_ModelSaveRequest,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ModelSaveRequest,
  Dtool_UpcastInterface_ModelSaveRequest,
  Dtool_DowncastInterface_ModelSaveRequest,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ModelSaveRequest(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_AsyncTask != nullptr);
    assert(Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit(nullptr);
    Dtool_ModelSaveRequest._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_AsyncTask);
    Dtool_ModelSaveRequest._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ModelSaveRequest._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ModelSaveRequest) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ModelSaveRequest)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ModelSaveRequest);
  }
}

/**
 * Python method tables for TextureAttrib (TextureAttrib)
 */
static PyMethodDef Dtool_Methods_TextureAttrib[] = {
  {"make", &Dtool_TextureAttrib_make_1772, METH_VARARGS | METH_STATIC, (const char *)Dtool_TextureAttrib_make_1772_comment},
  {"make_off", &Dtool_TextureAttrib_make_off_1773, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureAttrib_make_off_1773_comment},
  {"makeOff", &Dtool_TextureAttrib_make_off_1773, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureAttrib_make_off_1773_comment},
  {"make_default", &Dtool_TextureAttrib_make_default_1774, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureAttrib_make_default_1774_comment},
  {"makeDefault", &Dtool_TextureAttrib_make_default_1774, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureAttrib_make_default_1774_comment},
  {"is_off", &Dtool_TextureAttrib_is_off_1775, METH_NOARGS, (const char *)Dtool_TextureAttrib_is_off_1775_comment},
  {"isOff", &Dtool_TextureAttrib_is_off_1775, METH_NOARGS, (const char *)Dtool_TextureAttrib_is_off_1775_comment},
  {"get_texture", &Dtool_TextureAttrib_get_texture_1776, METH_NOARGS, (const char *)Dtool_TextureAttrib_get_texture_1776_comment},
  {"getTexture", &Dtool_TextureAttrib_get_texture_1776, METH_NOARGS, (const char *)Dtool_TextureAttrib_get_texture_1776_comment},
  {"make_all_off", &Dtool_TextureAttrib_make_all_off_1777, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureAttrib_make_all_off_1777_comment},
  {"makeAllOff", &Dtool_TextureAttrib_make_all_off_1777, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureAttrib_make_all_off_1777_comment},
  {"get_num_on_stages", &Dtool_TextureAttrib_get_num_on_stages_1778, METH_NOARGS, (const char *)Dtool_TextureAttrib_get_num_on_stages_1778_comment},
  {"getNumOnStages", &Dtool_TextureAttrib_get_num_on_stages_1778, METH_NOARGS, (const char *)Dtool_TextureAttrib_get_num_on_stages_1778_comment},
  {"get_on_stage", &Dtool_TextureAttrib_get_on_stage_1779, METH_O, (const char *)Dtool_TextureAttrib_get_on_stage_1779_comment},
  {"getOnStage", &Dtool_TextureAttrib_get_on_stage_1779, METH_O, (const char *)Dtool_TextureAttrib_get_on_stage_1779_comment},
  {"get_num_on_ff_stages", &Dtool_TextureAttrib_get_num_on_ff_stages_1781, METH_NOARGS, (const char *)Dtool_TextureAttrib_get_num_on_ff_stages_1781_comment},
  {"getNumOnFfStages", &Dtool_TextureAttrib_get_num_on_ff_stages_1781, METH_NOARGS, (const char *)Dtool_TextureAttrib_get_num_on_ff_stages_1781_comment},
  {"get_on_ff_stage", &Dtool_TextureAttrib_get_on_ff_stage_1782, METH_O, (const char *)Dtool_TextureAttrib_get_on_ff_stage_1782_comment},
  {"getOnFfStage", &Dtool_TextureAttrib_get_on_ff_stage_1782, METH_O, (const char *)Dtool_TextureAttrib_get_on_ff_stage_1782_comment},
  {"get_ff_tc_index", &Dtool_TextureAttrib_get_ff_tc_index_1784, METH_O, (const char *)Dtool_TextureAttrib_get_ff_tc_index_1784_comment},
  {"getFfTcIndex", &Dtool_TextureAttrib_get_ff_tc_index_1784, METH_O, (const char *)Dtool_TextureAttrib_get_ff_tc_index_1784_comment},
  {"has_on_stage", &Dtool_TextureAttrib_has_on_stage_1785, METH_O, (const char *)Dtool_TextureAttrib_has_on_stage_1785_comment},
  {"hasOnStage", &Dtool_TextureAttrib_has_on_stage_1785, METH_O, (const char *)Dtool_TextureAttrib_has_on_stage_1785_comment},
  {"get_on_texture", &Dtool_TextureAttrib_get_on_texture_1786, METH_O, (const char *)Dtool_TextureAttrib_get_on_texture_1786_comment},
  {"getOnTexture", &Dtool_TextureAttrib_get_on_texture_1786, METH_O, (const char *)Dtool_TextureAttrib_get_on_texture_1786_comment},
  {"get_on_sampler", &Dtool_TextureAttrib_get_on_sampler_1787, METH_O, (const char *)Dtool_TextureAttrib_get_on_sampler_1787_comment},
  {"getOnSampler", &Dtool_TextureAttrib_get_on_sampler_1787, METH_O, (const char *)Dtool_TextureAttrib_get_on_sampler_1787_comment},
  {"get_on_stage_override", &Dtool_TextureAttrib_get_on_stage_override_1788, METH_O, (const char *)Dtool_TextureAttrib_get_on_stage_override_1788_comment},
  {"getOnStageOverride", &Dtool_TextureAttrib_get_on_stage_override_1788, METH_O, (const char *)Dtool_TextureAttrib_get_on_stage_override_1788_comment},
  {"find_on_stage", &Dtool_TextureAttrib_find_on_stage_1789, METH_O, (const char *)Dtool_TextureAttrib_find_on_stage_1789_comment},
  {"findOnStage", &Dtool_TextureAttrib_find_on_stage_1789, METH_O, (const char *)Dtool_TextureAttrib_find_on_stage_1789_comment},
  {"get_num_off_stages", &Dtool_TextureAttrib_get_num_off_stages_1799, METH_NOARGS, (const char *)Dtool_TextureAttrib_get_num_off_stages_1799_comment},
  {"getNumOffStages", &Dtool_TextureAttrib_get_num_off_stages_1799, METH_NOARGS, (const char *)Dtool_TextureAttrib_get_num_off_stages_1799_comment},
  {"get_off_stage", &Dtool_TextureAttrib_get_off_stage_1800, METH_O, (const char *)Dtool_TextureAttrib_get_off_stage_1800_comment},
  {"getOffStage", &Dtool_TextureAttrib_get_off_stage_1800, METH_O, (const char *)Dtool_TextureAttrib_get_off_stage_1800_comment},
  {"has_off_stage", &Dtool_TextureAttrib_has_off_stage_1802, METH_O, (const char *)Dtool_TextureAttrib_has_off_stage_1802_comment},
  {"hasOffStage", &Dtool_TextureAttrib_has_off_stage_1802, METH_O, (const char *)Dtool_TextureAttrib_has_off_stage_1802_comment},
  {"has_all_off", &Dtool_TextureAttrib_has_all_off_1803, METH_NOARGS, (const char *)Dtool_TextureAttrib_has_all_off_1803_comment},
  {"hasAllOff", &Dtool_TextureAttrib_has_all_off_1803, METH_NOARGS, (const char *)Dtool_TextureAttrib_has_all_off_1803_comment},
  {"is_identity", &Dtool_TextureAttrib_is_identity_1805, METH_NOARGS, (const char *)Dtool_TextureAttrib_is_identity_1805_comment},
  {"isIdentity", &Dtool_TextureAttrib_is_identity_1805, METH_NOARGS, (const char *)Dtool_TextureAttrib_is_identity_1805_comment},
  {"add_on_stage", (PyCFunction) &Dtool_TextureAttrib_add_on_stage_1806, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureAttrib_add_on_stage_1806_comment},
  {"addOnStage", (PyCFunction) &Dtool_TextureAttrib_add_on_stage_1806, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureAttrib_add_on_stage_1806_comment},
  {"remove_on_stage", &Dtool_TextureAttrib_remove_on_stage_1807, METH_O, (const char *)Dtool_TextureAttrib_remove_on_stage_1807_comment},
  {"removeOnStage", &Dtool_TextureAttrib_remove_on_stage_1807, METH_O, (const char *)Dtool_TextureAttrib_remove_on_stage_1807_comment},
  {"add_off_stage", (PyCFunction) &Dtool_TextureAttrib_add_off_stage_1808, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureAttrib_add_off_stage_1808_comment},
  {"addOffStage", (PyCFunction) &Dtool_TextureAttrib_add_off_stage_1808, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureAttrib_add_off_stage_1808_comment},
  {"remove_off_stage", &Dtool_TextureAttrib_remove_off_stage_1809, METH_O, (const char *)Dtool_TextureAttrib_remove_off_stage_1809_comment},
  {"removeOffStage", &Dtool_TextureAttrib_remove_off_stage_1809, METH_O, (const char *)Dtool_TextureAttrib_remove_off_stage_1809_comment},
  {"unify_texture_stages", &Dtool_TextureAttrib_unify_texture_stages_1810, METH_O, (const char *)Dtool_TextureAttrib_unify_texture_stages_1810_comment},
  {"unifyTextureStages", &Dtool_TextureAttrib_unify_texture_stages_1810, METH_O, (const char *)Dtool_TextureAttrib_unify_texture_stages_1810_comment},
  {"replace_texture", (PyCFunction) &Dtool_TextureAttrib_replace_texture_1811, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureAttrib_replace_texture_1811_comment},
  {"replaceTexture", (PyCFunction) &Dtool_TextureAttrib_replace_texture_1811, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureAttrib_replace_texture_1811_comment},
  {"get_class_slot", &Dtool_TextureAttrib_get_class_slot_1812, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureAttrib_get_class_slot_1812_comment},
  {"getClassSlot", &Dtool_TextureAttrib_get_class_slot_1812, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureAttrib_get_class_slot_1812_comment},
  {"get_class_type", &Dtool_TextureAttrib_get_class_type_1814, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureAttrib_get_class_type_1814_comment},
  {"getClassType", &Dtool_TextureAttrib_get_class_type_1814, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureAttrib_get_class_type_1814_comment},
  {"get_on_stages", (PyCFunction) &MakeSeq_TextureAttrib_get_on_stages, METH_NOARGS, nullptr},
  { "getOnStages", (PyCFunction) &MakeSeq_TextureAttrib_get_on_stages, METH_NOARGS, nullptr},
  {"get_on_ff_stages", (PyCFunction) &MakeSeq_TextureAttrib_get_on_ff_stages, METH_NOARGS, nullptr},
  { "getOnFfStages", (PyCFunction) &MakeSeq_TextureAttrib_get_on_ff_stages, METH_NOARGS, nullptr},
  {"get_off_stages", (PyCFunction) &MakeSeq_TextureAttrib_get_off_stages, METH_NOARGS, nullptr},
  { "getOffStages", (PyCFunction) &MakeSeq_TextureAttrib_get_off_stages, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_TextureAttrib[] = {
  {(char *)"on_stages", &Dtool_TextureAttrib_on_stages_Getter, nullptr, nullptr, nullptr},
  {(char *)"textures", &Dtool_TextureAttrib_textures_Getter, nullptr, nullptr, nullptr},
  {(char *)"samplers", &Dtool_TextureAttrib_samplers_Getter, nullptr, nullptr, nullptr},
  {(char *)"off_stages", &Dtool_TextureAttrib_off_stages_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TextureAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextureAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TextureAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TextureAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TextureAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TextureAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextureAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextureAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TextureAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextureAttrib,
    &Dtool_SequenceMethods_TextureAttrib,
    &Dtool_MappingMethods_TextureAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TextureAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Indicates the set of TextureStages and their associated Textures that\n"
    " * should be applied to (or removed from) a node.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextureAttrib,
    nullptr, // tp_members
    Dtool_Properties_TextureAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextureAttrib,
    PyType_GenericAlloc,
    Dtool_new_TextureAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextureAttrib,
  Dtool_UpcastInterface_TextureAttrib,
  Dtool_DowncastInterface_TextureAttrib,
  (CoerceFunction)Dtool_ConstCoerce_TextureAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextureAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_TextureAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_TextureAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextureAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_TextureAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_TextureAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_TextureAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextureAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextureAttrib);
  }
}

/**
 * Python method tables for TexGenAttrib (TexGenAttrib)
 */
static PyMethodDef Dtool_Methods_TexGenAttrib[] = {
  {"make", (PyCFunction) &Dtool_TexGenAttrib_make_1817, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexGenAttrib_make_1817_comment},
  {"make_default", &Dtool_TexGenAttrib_make_default_1818, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexGenAttrib_make_default_1818_comment},
  {"makeDefault", &Dtool_TexGenAttrib_make_default_1818, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexGenAttrib_make_default_1818_comment},
  {"add_stage", (PyCFunction) &Dtool_TexGenAttrib_add_stage_1819, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexGenAttrib_add_stage_1819_comment},
  {"addStage", (PyCFunction) &Dtool_TexGenAttrib_add_stage_1819, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexGenAttrib_add_stage_1819_comment},
  {"remove_stage", &Dtool_TexGenAttrib_remove_stage_1820, METH_O, (const char *)Dtool_TexGenAttrib_remove_stage_1820_comment},
  {"removeStage", &Dtool_TexGenAttrib_remove_stage_1820, METH_O, (const char *)Dtool_TexGenAttrib_remove_stage_1820_comment},
  {"is_empty", &Dtool_TexGenAttrib_is_empty_1821, METH_NOARGS, (const char *)Dtool_TexGenAttrib_is_empty_1821_comment},
  {"isEmpty", &Dtool_TexGenAttrib_is_empty_1821, METH_NOARGS, (const char *)Dtool_TexGenAttrib_is_empty_1821_comment},
  {"has_stage", &Dtool_TexGenAttrib_has_stage_1822, METH_O, (const char *)Dtool_TexGenAttrib_has_stage_1822_comment},
  {"hasStage", &Dtool_TexGenAttrib_has_stage_1822, METH_O, (const char *)Dtool_TexGenAttrib_has_stage_1822_comment},
  {"get_mode", &Dtool_TexGenAttrib_get_mode_1823, METH_O, (const char *)Dtool_TexGenAttrib_get_mode_1823_comment},
  {"getMode", &Dtool_TexGenAttrib_get_mode_1823, METH_O, (const char *)Dtool_TexGenAttrib_get_mode_1823_comment},
  {"has_gen_texcoord_stage", &Dtool_TexGenAttrib_has_gen_texcoord_stage_1824, METH_O, (const char *)Dtool_TexGenAttrib_has_gen_texcoord_stage_1824_comment},
  {"hasGenTexcoordStage", &Dtool_TexGenAttrib_has_gen_texcoord_stage_1824, METH_O, (const char *)Dtool_TexGenAttrib_has_gen_texcoord_stage_1824_comment},
  {"get_constant_value", &Dtool_TexGenAttrib_get_constant_value_1825, METH_O, (const char *)Dtool_TexGenAttrib_get_constant_value_1825_comment},
  {"getConstantValue", &Dtool_TexGenAttrib_get_constant_value_1825, METH_O, (const char *)Dtool_TexGenAttrib_get_constant_value_1825_comment},
  {"get_geom_rendering", &Dtool_TexGenAttrib_get_geom_rendering_1826, METH_O, (const char *)Dtool_TexGenAttrib_get_geom_rendering_1826_comment},
  {"getGeomRendering", &Dtool_TexGenAttrib_get_geom_rendering_1826, METH_O, (const char *)Dtool_TexGenAttrib_get_geom_rendering_1826_comment},
  {"get_class_slot", &Dtool_TexGenAttrib_get_class_slot_1827, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexGenAttrib_get_class_slot_1827_comment},
  {"getClassSlot", &Dtool_TexGenAttrib_get_class_slot_1827, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexGenAttrib_get_class_slot_1827_comment},
  {"get_class_type", &Dtool_TexGenAttrib_get_class_type_1829, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexGenAttrib_get_class_type_1829_comment},
  {"getClassType", &Dtool_TexGenAttrib_get_class_type_1829, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexGenAttrib_get_class_type_1829_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TexGenAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TexGenAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TexGenAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TexGenAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TexGenAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TexGenAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TexGenAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TexGenAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TexGenAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TexGenAttrib,
    &Dtool_SequenceMethods_TexGenAttrib,
    &Dtool_MappingMethods_TexGenAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TexGenAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Computes texture coordinates for geometry automatically based on vertex\n"
    " * position and/or normal.  This can be used to implement reflection and/or\n"
    " * refraction maps, for instance to make shiny surfaces, as well as other\n"
    " * special effects such as projective texturing.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TexGenAttrib,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TexGenAttrib,
    PyType_GenericAlloc,
    Dtool_new_TexGenAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TexGenAttrib,
  Dtool_UpcastInterface_TexGenAttrib,
  Dtool_DowncastInterface_TexGenAttrib,
  (CoerceFunction)Dtool_ConstCoerce_TexGenAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_TexGenAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_TexGenAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_TexGenAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TexGenAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_TexGenAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_TexGenAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_TexGenAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TexGenAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TexGenAttrib);
  }
}

/**
 * Python method tables for OccluderNode (OccluderNode)
 */
static PyMethodDef Dtool_Methods_OccluderNode[] = {
  {"set_double_sided", &Dtool_OccluderNode_set_double_sided_1832, METH_O, (const char *)Dtool_OccluderNode_set_double_sided_1832_comment},
  {"setDoubleSided", &Dtool_OccluderNode_set_double_sided_1832, METH_O, (const char *)Dtool_OccluderNode_set_double_sided_1832_comment},
  {"is_double_sided", &Dtool_OccluderNode_is_double_sided_1833, METH_NOARGS, (const char *)Dtool_OccluderNode_is_double_sided_1833_comment},
  {"isDoubleSided", &Dtool_OccluderNode_is_double_sided_1833, METH_NOARGS, (const char *)Dtool_OccluderNode_is_double_sided_1833_comment},
  {"set_min_coverage", &Dtool_OccluderNode_set_min_coverage_1834, METH_O, (const char *)Dtool_OccluderNode_set_min_coverage_1834_comment},
  {"setMinCoverage", &Dtool_OccluderNode_set_min_coverage_1834, METH_O, (const char *)Dtool_OccluderNode_set_min_coverage_1834_comment},
  {"get_min_coverage", &Dtool_OccluderNode_get_min_coverage_1835, METH_NOARGS, (const char *)Dtool_OccluderNode_get_min_coverage_1835_comment},
  {"getMinCoverage", &Dtool_OccluderNode_get_min_coverage_1835, METH_NOARGS, (const char *)Dtool_OccluderNode_get_min_coverage_1835_comment},
  {"set_vertices", (PyCFunction) &Dtool_OccluderNode_set_vertices_1836, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OccluderNode_set_vertices_1836_comment},
  {"setVertices", (PyCFunction) &Dtool_OccluderNode_set_vertices_1836, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OccluderNode_set_vertices_1836_comment},
  {"get_num_vertices", &Dtool_OccluderNode_get_num_vertices_1837, METH_NOARGS, (const char *)Dtool_OccluderNode_get_num_vertices_1837_comment},
  {"getNumVertices", &Dtool_OccluderNode_get_num_vertices_1837, METH_NOARGS, (const char *)Dtool_OccluderNode_get_num_vertices_1837_comment},
  {"get_vertex", &Dtool_OccluderNode_get_vertex_1838, METH_O, (const char *)Dtool_OccluderNode_get_vertex_1838_comment},
  {"getVertex", &Dtool_OccluderNode_get_vertex_1838, METH_O, (const char *)Dtool_OccluderNode_get_vertex_1838_comment},
  {"set_vertex", (PyCFunction) &Dtool_OccluderNode_set_vertex_1839, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OccluderNode_set_vertex_1839_comment},
  {"setVertex", (PyCFunction) &Dtool_OccluderNode_set_vertex_1839, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OccluderNode_set_vertex_1839_comment},
  {"get_class_type", &Dtool_OccluderNode_get_class_type_1844, METH_NOARGS | METH_STATIC, (const char *)Dtool_OccluderNode_get_class_type_1844_comment},
  {"getClassType", &Dtool_OccluderNode_get_class_type_1844, METH_NOARGS | METH_STATIC, (const char *)Dtool_OccluderNode_get_class_type_1844_comment},
  {"get_vertices", (PyCFunction) &MakeSeq_OccluderNode_get_vertices, METH_NOARGS, nullptr},
  { "getVertices", (PyCFunction) &MakeSeq_OccluderNode_get_vertices, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_OccluderNode[] = {
  {(char *)"double_sided", &Dtool_OccluderNode_double_sided_Getter, &Dtool_OccluderNode_double_sided_Setter, nullptr, nullptr},
  {(char *)"min_coverage", &Dtool_OccluderNode_min_coverage_Getter, &Dtool_OccluderNode_min_coverage_Setter, nullptr, nullptr},
  {(char *)"vertices", &Dtool_OccluderNode_vertices_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_OccluderNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OccluderNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OccluderNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OccluderNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OccluderNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OccluderNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.OccluderNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OccluderNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OccluderNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OccluderNode,
    &Dtool_SequenceMethods_OccluderNode,
    &Dtool_MappingMethods_OccluderNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OccluderNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node in the scene graph that can hold an occluder polygon, which must be\n"
    " * a rectangle.  When the occluder is activated with something like\n"
    " * render.set_occluder(), then objects whose bouding volume lies entirely\n"
    " * behind the occluder will not be rendered.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OccluderNode,
    nullptr, // tp_members
    Dtool_Properties_OccluderNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OccluderNode,
    PyType_GenericAlloc,
    Dtool_new_OccluderNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OccluderNode,
  Dtool_UpcastInterface_OccluderNode,
  Dtool_DowncastInterface_OccluderNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OccluderNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PandaNode(nullptr);
    Dtool_OccluderNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PandaNode);
    Dtool_OccluderNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OccluderNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OccluderNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OccluderNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OccluderNode);
  }
}

/**
 * Python method tables for OccluderEffect (OccluderEffect)
 */
static PyMethodDef Dtool_Methods_OccluderEffect[] = {
  {"make", &Dtool_OccluderEffect_make_1846, METH_NOARGS | METH_STATIC, (const char *)Dtool_OccluderEffect_make_1846_comment},
  {"get_num_on_occluders", &Dtool_OccluderEffect_get_num_on_occluders_1847, METH_NOARGS, (const char *)Dtool_OccluderEffect_get_num_on_occluders_1847_comment},
  {"getNumOnOccluders", &Dtool_OccluderEffect_get_num_on_occluders_1847, METH_NOARGS, (const char *)Dtool_OccluderEffect_get_num_on_occluders_1847_comment},
  {"get_on_occluder", &Dtool_OccluderEffect_get_on_occluder_1848, METH_O, (const char *)Dtool_OccluderEffect_get_on_occluder_1848_comment},
  {"getOnOccluder", &Dtool_OccluderEffect_get_on_occluder_1848, METH_O, (const char *)Dtool_OccluderEffect_get_on_occluder_1848_comment},
  {"has_on_occluder", &Dtool_OccluderEffect_has_on_occluder_1850, METH_O, (const char *)Dtool_OccluderEffect_has_on_occluder_1850_comment},
  {"hasOnOccluder", &Dtool_OccluderEffect_has_on_occluder_1850, METH_O, (const char *)Dtool_OccluderEffect_has_on_occluder_1850_comment},
  {"is_identity", &Dtool_OccluderEffect_is_identity_1851, METH_NOARGS, (const char *)Dtool_OccluderEffect_is_identity_1851_comment},
  {"isIdentity", &Dtool_OccluderEffect_is_identity_1851, METH_NOARGS, (const char *)Dtool_OccluderEffect_is_identity_1851_comment},
  {"add_on_occluder", &Dtool_OccluderEffect_add_on_occluder_1852, METH_O, (const char *)Dtool_OccluderEffect_add_on_occluder_1852_comment},
  {"addOnOccluder", &Dtool_OccluderEffect_add_on_occluder_1852, METH_O, (const char *)Dtool_OccluderEffect_add_on_occluder_1852_comment},
  {"remove_on_occluder", &Dtool_OccluderEffect_remove_on_occluder_1853, METH_O, (const char *)Dtool_OccluderEffect_remove_on_occluder_1853_comment},
  {"removeOnOccluder", &Dtool_OccluderEffect_remove_on_occluder_1853, METH_O, (const char *)Dtool_OccluderEffect_remove_on_occluder_1853_comment},
  {"get_class_type", &Dtool_OccluderEffect_get_class_type_1854, METH_NOARGS | METH_STATIC, (const char *)Dtool_OccluderEffect_get_class_type_1854_comment},
  {"getClassType", &Dtool_OccluderEffect_get_class_type_1854, METH_NOARGS | METH_STATIC, (const char *)Dtool_OccluderEffect_get_class_type_1854_comment},
  {"get_on_occluders", (PyCFunction) &MakeSeq_OccluderEffect_get_on_occluders, METH_NOARGS, nullptr},
  { "getOnOccluders", (PyCFunction) &MakeSeq_OccluderEffect_get_on_occluders, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OccluderEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OccluderEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OccluderEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OccluderEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OccluderEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OccluderEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.OccluderEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OccluderEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OccluderEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OccluderEffect,
    &Dtool_SequenceMethods_OccluderEffect,
    &Dtool_MappingMethods_OccluderEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OccluderEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This functions similarly to a LightAttrib or ClipPlaneAttrib.  It indicates\n"
    " * the set of occluders that modify the geometry at this level and below.\n"
    " * Unlike a ClipPlaneAttrib, an OccluderEffect takes effect immediately when\n"
    " * it is encountered during traversal, and thus can only add occluders; it may\n"
    " * not remove them.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OccluderEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OccluderEffect,
    PyType_GenericAlloc,
    Dtool_new_OccluderEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OccluderEffect,
  Dtool_UpcastInterface_OccluderEffect,
  Dtool_DowncastInterface_OccluderEffect,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OccluderEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderEffect(nullptr);
    Dtool_OccluderEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderEffect);
    Dtool_OccluderEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OccluderEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OccluderEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OccluderEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OccluderEffect);
  }
}

/**
 * Python method tables for PolylightNode (PolylightNode)
 */
static PyMethodDef Dtool_Methods_PolylightNode[] = {
  {"enable", &Dtool_PolylightNode_enable_1860, METH_NOARGS, (const char *)Dtool_PolylightNode_enable_1860_comment},
  {"disable", &Dtool_PolylightNode_disable_1861, METH_NOARGS, (const char *)Dtool_PolylightNode_disable_1861_comment},
  {"set_pos", (PyCFunction) &Dtool_PolylightNode_set_pos_1862, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PolylightNode_set_pos_1862_comment},
  {"setPos", (PyCFunction) &Dtool_PolylightNode_set_pos_1862, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PolylightNode_set_pos_1862_comment},
  {"get_pos", &Dtool_PolylightNode_get_pos_1863, METH_NOARGS, (const char *)Dtool_PolylightNode_get_pos_1863_comment},
  {"getPos", &Dtool_PolylightNode_get_pos_1863, METH_NOARGS, (const char *)Dtool_PolylightNode_get_pos_1863_comment},
  {"set_color", (PyCFunction) &Dtool_PolylightNode_set_color_1864, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PolylightNode_set_color_1864_comment},
  {"setColor", (PyCFunction) &Dtool_PolylightNode_set_color_1864, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PolylightNode_set_color_1864_comment},
  {"get_color", &Dtool_PolylightNode_get_color_1865, METH_NOARGS, (const char *)Dtool_PolylightNode_get_color_1865_comment},
  {"getColor", &Dtool_PolylightNode_get_color_1865, METH_NOARGS, (const char *)Dtool_PolylightNode_get_color_1865_comment},
  {"get_color_scenegraph", &Dtool_PolylightNode_get_color_scenegraph_1866, METH_NOARGS, (const char *)Dtool_PolylightNode_get_color_scenegraph_1866_comment},
  {"getColorScenegraph", &Dtool_PolylightNode_get_color_scenegraph_1866, METH_NOARGS, (const char *)Dtool_PolylightNode_get_color_scenegraph_1866_comment},
  {"set_radius", &Dtool_PolylightNode_set_radius_1867, METH_O, (const char *)Dtool_PolylightNode_set_radius_1867_comment},
  {"setRadius", &Dtool_PolylightNode_set_radius_1867, METH_O, (const char *)Dtool_PolylightNode_set_radius_1867_comment},
  {"get_radius", &Dtool_PolylightNode_get_radius_1868, METH_NOARGS, (const char *)Dtool_PolylightNode_get_radius_1868_comment},
  {"getRadius", &Dtool_PolylightNode_get_radius_1868, METH_NOARGS, (const char *)Dtool_PolylightNode_get_radius_1868_comment},
  {"set_attenuation", &Dtool_PolylightNode_set_attenuation_1869, METH_O, (const char *)Dtool_PolylightNode_set_attenuation_1869_comment},
  {"setAttenuation", &Dtool_PolylightNode_set_attenuation_1869, METH_O, (const char *)Dtool_PolylightNode_set_attenuation_1869_comment},
  {"get_attenuation", &Dtool_PolylightNode_get_attenuation_1870, METH_NOARGS, (const char *)Dtool_PolylightNode_get_attenuation_1870_comment},
  {"getAttenuation", &Dtool_PolylightNode_get_attenuation_1870, METH_NOARGS, (const char *)Dtool_PolylightNode_get_attenuation_1870_comment},
  {"set_a0", &Dtool_PolylightNode_set_a0_1871, METH_O, (const char *)Dtool_PolylightNode_set_a0_1871_comment},
  {"setA0", &Dtool_PolylightNode_set_a0_1871, METH_O, (const char *)Dtool_PolylightNode_set_a0_1871_comment},
  {"set_a1", &Dtool_PolylightNode_set_a1_1872, METH_O, (const char *)Dtool_PolylightNode_set_a1_1872_comment},
  {"setA1", &Dtool_PolylightNode_set_a1_1872, METH_O, (const char *)Dtool_PolylightNode_set_a1_1872_comment},
  {"set_a2", &Dtool_PolylightNode_set_a2_1873, METH_O, (const char *)Dtool_PolylightNode_set_a2_1873_comment},
  {"setA2", &Dtool_PolylightNode_set_a2_1873, METH_O, (const char *)Dtool_PolylightNode_set_a2_1873_comment},
  {"get_a0", &Dtool_PolylightNode_get_a0_1874, METH_NOARGS, (const char *)Dtool_PolylightNode_get_a0_1874_comment},
  {"getA0", &Dtool_PolylightNode_get_a0_1874, METH_NOARGS, (const char *)Dtool_PolylightNode_get_a0_1874_comment},
  {"get_a1", &Dtool_PolylightNode_get_a1_1875, METH_NOARGS, (const char *)Dtool_PolylightNode_get_a1_1875_comment},
  {"getA1", &Dtool_PolylightNode_get_a1_1875, METH_NOARGS, (const char *)Dtool_PolylightNode_get_a1_1875_comment},
  {"get_a2", &Dtool_PolylightNode_get_a2_1876, METH_NOARGS, (const char *)Dtool_PolylightNode_get_a2_1876_comment},
  {"getA2", &Dtool_PolylightNode_get_a2_1876, METH_NOARGS, (const char *)Dtool_PolylightNode_get_a2_1876_comment},
  {"flicker_on", &Dtool_PolylightNode_flicker_on_1877, METH_NOARGS, (const char *)Dtool_PolylightNode_flicker_on_1877_comment},
  {"flickerOn", &Dtool_PolylightNode_flicker_on_1877, METH_NOARGS, (const char *)Dtool_PolylightNode_flicker_on_1877_comment},
  {"flicker_off", &Dtool_PolylightNode_flicker_off_1878, METH_NOARGS, (const char *)Dtool_PolylightNode_flicker_off_1878_comment},
  {"flickerOff", &Dtool_PolylightNode_flicker_off_1878, METH_NOARGS, (const char *)Dtool_PolylightNode_flicker_off_1878_comment},
  {"is_flickering", &Dtool_PolylightNode_is_flickering_1879, METH_NOARGS, (const char *)Dtool_PolylightNode_is_flickering_1879_comment},
  {"isFlickering", &Dtool_PolylightNode_is_flickering_1879, METH_NOARGS, (const char *)Dtool_PolylightNode_is_flickering_1879_comment},
  {"set_flicker_type", &Dtool_PolylightNode_set_flicker_type_1880, METH_O, (const char *)Dtool_PolylightNode_set_flicker_type_1880_comment},
  {"setFlickerType", &Dtool_PolylightNode_set_flicker_type_1880, METH_O, (const char *)Dtool_PolylightNode_set_flicker_type_1880_comment},
  {"get_flicker_type", &Dtool_PolylightNode_get_flicker_type_1881, METH_NOARGS, (const char *)Dtool_PolylightNode_get_flicker_type_1881_comment},
  {"getFlickerType", &Dtool_PolylightNode_get_flicker_type_1881, METH_NOARGS, (const char *)Dtool_PolylightNode_get_flicker_type_1881_comment},
  {"set_offset", &Dtool_PolylightNode_set_offset_1882, METH_O, (const char *)Dtool_PolylightNode_set_offset_1882_comment},
  {"setOffset", &Dtool_PolylightNode_set_offset_1882, METH_O, (const char *)Dtool_PolylightNode_set_offset_1882_comment},
  {"get_offset", &Dtool_PolylightNode_get_offset_1883, METH_NOARGS, (const char *)Dtool_PolylightNode_get_offset_1883_comment},
  {"getOffset", &Dtool_PolylightNode_get_offset_1883, METH_NOARGS, (const char *)Dtool_PolylightNode_get_offset_1883_comment},
  {"set_scale", &Dtool_PolylightNode_set_scale_1884, METH_O, (const char *)Dtool_PolylightNode_set_scale_1884_comment},
  {"setScale", &Dtool_PolylightNode_set_scale_1884, METH_O, (const char *)Dtool_PolylightNode_set_scale_1884_comment},
  {"get_scale", &Dtool_PolylightNode_get_scale_1885, METH_NOARGS, (const char *)Dtool_PolylightNode_get_scale_1885_comment},
  {"getScale", &Dtool_PolylightNode_get_scale_1885, METH_NOARGS, (const char *)Dtool_PolylightNode_get_scale_1885_comment},
  {"set_step_size", &Dtool_PolylightNode_set_step_size_1886, METH_O, (const char *)Dtool_PolylightNode_set_step_size_1886_comment},
  {"setStepSize", &Dtool_PolylightNode_set_step_size_1886, METH_O, (const char *)Dtool_PolylightNode_set_step_size_1886_comment},
  {"get_step_size", &Dtool_PolylightNode_get_step_size_1887, METH_NOARGS, (const char *)Dtool_PolylightNode_get_step_size_1887_comment},
  {"getStepSize", &Dtool_PolylightNode_get_step_size_1887, METH_NOARGS, (const char *)Dtool_PolylightNode_get_step_size_1887_comment},
  {"set_freq", &Dtool_PolylightNode_set_freq_1888, METH_O, (const char *)Dtool_PolylightNode_set_freq_1888_comment},
  {"setFreq", &Dtool_PolylightNode_set_freq_1888, METH_O, (const char *)Dtool_PolylightNode_set_freq_1888_comment},
  {"get_freq", &Dtool_PolylightNode_get_freq_1889, METH_NOARGS, (const char *)Dtool_PolylightNode_get_freq_1889_comment},
  {"getFreq", &Dtool_PolylightNode_get_freq_1889, METH_NOARGS, (const char *)Dtool_PolylightNode_get_freq_1889_comment},
  {"compare_to", &Dtool_PolylightNode_compare_to_1893, METH_O, (const char *)Dtool_PolylightNode_compare_to_1893_comment},
  {"compareTo", &Dtool_PolylightNode_compare_to_1893, METH_O, (const char *)Dtool_PolylightNode_compare_to_1893_comment},
  {"is_enabled", &Dtool_PolylightNode_is_enabled_1894, METH_NOARGS, (const char *)Dtool_PolylightNode_is_enabled_1894_comment},
  {"isEnabled", &Dtool_PolylightNode_is_enabled_1894, METH_NOARGS, (const char *)Dtool_PolylightNode_is_enabled_1894_comment},
  {"get_class_type", &Dtool_PolylightNode_get_class_type_1895, METH_NOARGS | METH_STATIC, (const char *)Dtool_PolylightNode_get_class_type_1895_comment},
  {"getClassType", &Dtool_PolylightNode_get_class_type_1895, METH_NOARGS | METH_STATIC, (const char *)Dtool_PolylightNode_get_class_type_1895_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PolylightNode slot tp_compare -> compare_to
//////////////////
static int Dtool_PolylightNode_compare_to_1893_tp_compare(PyObject *self, PyObject *arg) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PolylightNode, (void **)&local_this)) {
    return -1;
  }

  // 1-int PolylightNode::compare_to(PolylightNode const &other) const
  PolylightNode const *arg_this = (PolylightNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PolylightNode, 1, "PolylightNode.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const PolylightNode*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(PolylightNode self, const PolylightNode other)\n");
  }
  return -1;
}

//////////////////
//  A rich comparison function
//     PolylightNode
//////////////////
static PyObject *Dtool_RichCompare_PolylightNode(PyObject *self, PyObject *arg, int op) {
  PolylightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PolylightNode, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool PolylightNode::operator ==(PolylightNode const &other) const
      PolylightNode const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PolylightNode);
      if (arg_this != nullptr) {
        bool return_value = ((*(const PolylightNode*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool PolylightNode::operator !=(PolylightNode const &other) const
      PolylightNode const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PolylightNode);
      if (arg_this != nullptr) {
        bool return_value = ((*(const PolylightNode*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool PolylightNode::operator <(PolylightNode const &other) const
      PolylightNode const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PolylightNode);
      if (arg_this != nullptr) {
        bool return_value = ((*(const PolylightNode*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_PolylightNode_compare_to_1893_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_PolylightNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PolylightNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PolylightNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PolylightNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PolylightNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PolylightNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PolylightNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PolylightNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PolylightNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_PolylightNode_compare_to_1893_tp_compare,
#endif
    nullptr,
    &Dtool_NumberMethods_PolylightNode,
    &Dtool_SequenceMethods_PolylightNode,
    &Dtool_MappingMethods_PolylightNode,
    &DtoolInstance_HashPointer,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PolylightNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A PolylightNode\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_PolylightNode,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PolylightNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PolylightNode,
    PyType_GenericAlloc,
    Dtool_new_PolylightNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PolylightNode,
  Dtool_UpcastInterface_PolylightNode,
  Dtool_DowncastInterface_PolylightNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PolylightNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PandaNode(nullptr);
    Dtool_PolylightNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PandaNode);
    Dtool_PolylightNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_PolylightNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PolylightNode::Flicker_Type;
    PyDict_SetItemString(dict, "FRANDOM", Dtool_WrapValue(PolylightNode::FRANDOM));
    PyDict_SetItemString(dict, "FSIN", Dtool_WrapValue(PolylightNode::FSIN));
    PyDict_SetItemString(dict, "FCUSTOM", Dtool_WrapValue(PolylightNode::FCUSTOM));
    // enum PolylightNode::Attenuation_Type;
    PyDict_SetItemString(dict, "ALINEAR", Dtool_WrapValue(PolylightNode::ALINEAR));
    PyDict_SetItemString(dict, "AQUADRATIC", Dtool_WrapValue(PolylightNode::AQUADRATIC));
    if (PyType_Ready((PyTypeObject *)&Dtool_PolylightNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PolylightNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PolylightNode);
  }
}

/**
 * Python method tables for PolylightEffect (PolylightEffect)
 */
static PyMethodDef Dtool_Methods_PolylightEffect[] = {
  {"make", (PyCFunction) &Dtool_PolylightEffect_make_1901, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PolylightEffect_make_1901_comment},
  {"add_light", &Dtool_PolylightEffect_add_light_1902, METH_O, (const char *)Dtool_PolylightEffect_add_light_1902_comment},
  {"addLight", &Dtool_PolylightEffect_add_light_1902, METH_O, (const char *)Dtool_PolylightEffect_add_light_1902_comment},
  {"remove_light", &Dtool_PolylightEffect_remove_light_1903, METH_O, (const char *)Dtool_PolylightEffect_remove_light_1903_comment},
  {"removeLight", &Dtool_PolylightEffect_remove_light_1903, METH_O, (const char *)Dtool_PolylightEffect_remove_light_1903_comment},
  {"set_weight", &Dtool_PolylightEffect_set_weight_1904, METH_O, (const char *)Dtool_PolylightEffect_set_weight_1904_comment},
  {"setWeight", &Dtool_PolylightEffect_set_weight_1904, METH_O, (const char *)Dtool_PolylightEffect_set_weight_1904_comment},
  {"set_contrib", &Dtool_PolylightEffect_set_contrib_1905, METH_O, (const char *)Dtool_PolylightEffect_set_contrib_1905_comment},
  {"setContrib", &Dtool_PolylightEffect_set_contrib_1905, METH_O, (const char *)Dtool_PolylightEffect_set_contrib_1905_comment},
  {"set_effect_center", &Dtool_PolylightEffect_set_effect_center_1906, METH_O, (const char *)Dtool_PolylightEffect_set_effect_center_1906_comment},
  {"setEffectCenter", &Dtool_PolylightEffect_set_effect_center_1906, METH_O, (const char *)Dtool_PolylightEffect_set_effect_center_1906_comment},
  {"get_weight", &Dtool_PolylightEffect_get_weight_1907, METH_NOARGS, (const char *)Dtool_PolylightEffect_get_weight_1907_comment},
  {"getWeight", &Dtool_PolylightEffect_get_weight_1907, METH_NOARGS, (const char *)Dtool_PolylightEffect_get_weight_1907_comment},
  {"get_contrib", &Dtool_PolylightEffect_get_contrib_1908, METH_NOARGS, (const char *)Dtool_PolylightEffect_get_contrib_1908_comment},
  {"getContrib", &Dtool_PolylightEffect_get_contrib_1908, METH_NOARGS, (const char *)Dtool_PolylightEffect_get_contrib_1908_comment},
  {"get_effect_center", &Dtool_PolylightEffect_get_effect_center_1909, METH_NOARGS, (const char *)Dtool_PolylightEffect_get_effect_center_1909_comment},
  {"getEffectCenter", &Dtool_PolylightEffect_get_effect_center_1909, METH_NOARGS, (const char *)Dtool_PolylightEffect_get_effect_center_1909_comment},
  {"has_light", &Dtool_PolylightEffect_has_light_1910, METH_O, (const char *)Dtool_PolylightEffect_has_light_1910_comment},
  {"hasLight", &Dtool_PolylightEffect_has_light_1910, METH_O, (const char *)Dtool_PolylightEffect_has_light_1910_comment},
  {"get_class_type", &Dtool_PolylightEffect_get_class_type_1911, METH_NOARGS | METH_STATIC, (const char *)Dtool_PolylightEffect_get_class_type_1911_comment},
  {"getClassType", &Dtool_PolylightEffect_get_class_type_1911, METH_NOARGS | METH_STATIC, (const char *)Dtool_PolylightEffect_get_class_type_1911_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PolylightEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PolylightEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PolylightEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PolylightEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PolylightEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PolylightEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PolylightEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PolylightEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PolylightEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PolylightEffect,
    &Dtool_SequenceMethods_PolylightEffect,
    &Dtool_MappingMethods_PolylightEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PolylightEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A PolylightEffect can be used on a node to define a LightGroup  for that\n"
    " * node.  A LightGroup contains PolylightNodes which are essentially nodes\n"
    " * that add color to the polygons of a model based on distance.  PolylightNode\n"
    " * is a cheap way to get lighting effects specially for night scenes\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PolylightEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PolylightEffect,
    PyType_GenericAlloc,
    Dtool_new_PolylightEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PolylightEffect,
  Dtool_UpcastInterface_PolylightEffect,
  Dtool_DowncastInterface_PolylightEffect,
  (CoerceFunction)Dtool_ConstCoerce_PolylightEffect,
  nullptr,
};

static void Dtool_PyModuleClassInit_PolylightEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderEffect(nullptr);
    Dtool_PolylightEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderEffect);
    Dtool_PolylightEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PolylightEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PolylightEffect::ContribType;
    PyDict_SetItemString(dict, "CT_proximal", Dtool_WrapValue(PolylightEffect::CT_proximal));
    PyDict_SetItemString(dict, "CTProximal", Dtool_WrapValue(PolylightEffect::CT_proximal));
    PyDict_SetItemString(dict, "CT_all", Dtool_WrapValue(PolylightEffect::CT_all));
    PyDict_SetItemString(dict, "CTAll", Dtool_WrapValue(PolylightEffect::CT_all));
    if (PyType_Ready((PyTypeObject *)&Dtool_PolylightEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PolylightEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PolylightEffect);
  }
}

/**
 * Python method tables for ShaderAttrib (ShaderAttrib)
 */
static PyMethodDef Dtool_Methods_ShaderAttrib[] = {
  {"make", (PyCFunction) &Dtool_ShaderAttrib_make_1914, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ShaderAttrib_make_1914_comment},
  {"make_off", &Dtool_ShaderAttrib_make_off_1915, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderAttrib_make_off_1915_comment},
  {"makeOff", &Dtool_ShaderAttrib_make_off_1915, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderAttrib_make_off_1915_comment},
  {"make_default", &Dtool_ShaderAttrib_make_default_1916, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderAttrib_make_default_1916_comment},
  {"makeDefault", &Dtool_ShaderAttrib_make_default_1916, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderAttrib_make_default_1916_comment},
  {"has_shader", &Dtool_ShaderAttrib_has_shader_1918, METH_NOARGS, (const char *)Dtool_ShaderAttrib_has_shader_1918_comment},
  {"hasShader", &Dtool_ShaderAttrib_has_shader_1918, METH_NOARGS, (const char *)Dtool_ShaderAttrib_has_shader_1918_comment},
  {"auto_shader", &Dtool_ShaderAttrib_auto_shader_1919, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_shader_1919_comment},
  {"autoShader", &Dtool_ShaderAttrib_auto_shader_1919, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_shader_1919_comment},
  {"get_shader_priority", &Dtool_ShaderAttrib_get_shader_priority_1920, METH_NOARGS, (const char *)Dtool_ShaderAttrib_get_shader_priority_1920_comment},
  {"getShaderPriority", &Dtool_ShaderAttrib_get_shader_priority_1920, METH_NOARGS, (const char *)Dtool_ShaderAttrib_get_shader_priority_1920_comment},
  {"get_instance_count", &Dtool_ShaderAttrib_get_instance_count_1921, METH_NOARGS, (const char *)Dtool_ShaderAttrib_get_instance_count_1921_comment},
  {"getInstanceCount", &Dtool_ShaderAttrib_get_instance_count_1921, METH_NOARGS, (const char *)Dtool_ShaderAttrib_get_instance_count_1921_comment},
  {"auto_normal_on", &Dtool_ShaderAttrib_auto_normal_on_1922, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_normal_on_1922_comment},
  {"autoNormalOn", &Dtool_ShaderAttrib_auto_normal_on_1922, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_normal_on_1922_comment},
  {"auto_glow_on", &Dtool_ShaderAttrib_auto_glow_on_1923, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_glow_on_1923_comment},
  {"autoGlowOn", &Dtool_ShaderAttrib_auto_glow_on_1923, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_glow_on_1923_comment},
  {"auto_gloss_on", &Dtool_ShaderAttrib_auto_gloss_on_1924, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_gloss_on_1924_comment},
  {"autoGlossOn", &Dtool_ShaderAttrib_auto_gloss_on_1924, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_gloss_on_1924_comment},
  {"auto_ramp_on", &Dtool_ShaderAttrib_auto_ramp_on_1925, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_ramp_on_1925_comment},
  {"autoRampOn", &Dtool_ShaderAttrib_auto_ramp_on_1925, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_ramp_on_1925_comment},
  {"auto_shadow_on", &Dtool_ShaderAttrib_auto_shadow_on_1926, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_shadow_on_1926_comment},
  {"autoShadowOn", &Dtool_ShaderAttrib_auto_shadow_on_1926, METH_NOARGS, (const char *)Dtool_ShaderAttrib_auto_shadow_on_1926_comment},
  {"set_shader", (PyCFunction) &Dtool_ShaderAttrib_set_shader_1927, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_shader_1927_comment},
  {"setShader", (PyCFunction) &Dtool_ShaderAttrib_set_shader_1927, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_shader_1927_comment},
  {"set_shader_off", (PyCFunction) &Dtool_ShaderAttrib_set_shader_off_1928, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_shader_off_1928_comment},
  {"setShaderOff", (PyCFunction) &Dtool_ShaderAttrib_set_shader_off_1928, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_shader_off_1928_comment},
  {"set_shader_auto", (PyCFunction) &Dtool_ShaderAttrib_set_shader_auto_1929, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_shader_auto_1929_comment},
  {"setShaderAuto", (PyCFunction) &Dtool_ShaderAttrib_set_shader_auto_1929, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_shader_auto_1929_comment},
  {"clear_shader", &Dtool_ShaderAttrib_clear_shader_1930, METH_NOARGS, (const char *)Dtool_ShaderAttrib_clear_shader_1930_comment},
  {"clearShader", &Dtool_ShaderAttrib_clear_shader_1930, METH_NOARGS, (const char *)Dtool_ShaderAttrib_clear_shader_1930_comment},
  {"set_shader_input", (PyCFunction) &Dtool_ShaderAttrib_set_shader_input_1931, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_shader_input_1931_comment},
  {"setShaderInput", (PyCFunction) &Dtool_ShaderAttrib_set_shader_input_1931, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_shader_input_1931_comment},
  {"set_shader_inputs", (PyCFunction) &Dtool_ShaderAttrib_set_shader_inputs_1932, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_shader_inputs_1932_comment},
  {"setShaderInputs", (PyCFunction) &Dtool_ShaderAttrib_set_shader_inputs_1932, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_shader_inputs_1932_comment},
  {"set_instance_count", &Dtool_ShaderAttrib_set_instance_count_1933, METH_O, (const char *)Dtool_ShaderAttrib_set_instance_count_1933_comment},
  {"setInstanceCount", &Dtool_ShaderAttrib_set_instance_count_1933, METH_O, (const char *)Dtool_ShaderAttrib_set_instance_count_1933_comment},
  {"set_flag", (PyCFunction) &Dtool_ShaderAttrib_set_flag_1934, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_flag_1934_comment},
  {"setFlag", (PyCFunction) &Dtool_ShaderAttrib_set_flag_1934, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_set_flag_1934_comment},
  {"clear_flag", &Dtool_ShaderAttrib_clear_flag_1935, METH_O, (const char *)Dtool_ShaderAttrib_clear_flag_1935_comment},
  {"clearFlag", &Dtool_ShaderAttrib_clear_flag_1935, METH_O, (const char *)Dtool_ShaderAttrib_clear_flag_1935_comment},
  {"clear_shader_input", &Dtool_ShaderAttrib_clear_shader_input_1936, METH_O, (const char *)Dtool_ShaderAttrib_clear_shader_input_1936_comment},
  {"clearShaderInput", &Dtool_ShaderAttrib_clear_shader_input_1936, METH_O, (const char *)Dtool_ShaderAttrib_clear_shader_input_1936_comment},
  {"clear_all_shader_inputs", &Dtool_ShaderAttrib_clear_all_shader_inputs_1937, METH_NOARGS, (const char *)Dtool_ShaderAttrib_clear_all_shader_inputs_1937_comment},
  {"clearAllShaderInputs", &Dtool_ShaderAttrib_clear_all_shader_inputs_1937, METH_NOARGS, (const char *)Dtool_ShaderAttrib_clear_all_shader_inputs_1937_comment},
  {"get_flag", &Dtool_ShaderAttrib_get_flag_1938, METH_O, (const char *)Dtool_ShaderAttrib_get_flag_1938_comment},
  {"getFlag", &Dtool_ShaderAttrib_get_flag_1938, METH_O, (const char *)Dtool_ShaderAttrib_get_flag_1938_comment},
  {"has_shader_input", &Dtool_ShaderAttrib_has_shader_input_1939, METH_O, (const char *)Dtool_ShaderAttrib_has_shader_input_1939_comment},
  {"hasShaderInput", &Dtool_ShaderAttrib_has_shader_input_1939, METH_O, (const char *)Dtool_ShaderAttrib_has_shader_input_1939_comment},
  {"get_shader", &Dtool_ShaderAttrib_get_shader_1940, METH_NOARGS, (const char *)Dtool_ShaderAttrib_get_shader_1940_comment},
  {"getShader", &Dtool_ShaderAttrib_get_shader_1940, METH_NOARGS, (const char *)Dtool_ShaderAttrib_get_shader_1940_comment},
  {"get_shader_input", &Dtool_ShaderAttrib_get_shader_input_1941, METH_O, (const char *)Dtool_ShaderAttrib_get_shader_input_1941_comment},
  {"getShaderInput", &Dtool_ShaderAttrib_get_shader_input_1941, METH_O, (const char *)Dtool_ShaderAttrib_get_shader_input_1941_comment},
  {"get_shader_input_nodepath", &Dtool_ShaderAttrib_get_shader_input_nodepath_1942, METH_O, (const char *)Dtool_ShaderAttrib_get_shader_input_nodepath_1942_comment},
  {"getShaderInputNodepath", &Dtool_ShaderAttrib_get_shader_input_nodepath_1942, METH_O, (const char *)Dtool_ShaderAttrib_get_shader_input_nodepath_1942_comment},
  {"get_shader_input_vector", &Dtool_ShaderAttrib_get_shader_input_vector_1943, METH_O, (const char *)Dtool_ShaderAttrib_get_shader_input_vector_1943_comment},
  {"getShaderInputVector", &Dtool_ShaderAttrib_get_shader_input_vector_1943, METH_O, (const char *)Dtool_ShaderAttrib_get_shader_input_vector_1943_comment},
  {"get_shader_input_texture", (PyCFunction) &Dtool_ShaderAttrib_get_shader_input_texture_1944, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_get_shader_input_texture_1944_comment},
  {"getShaderInputTexture", (PyCFunction) &Dtool_ShaderAttrib_get_shader_input_texture_1944, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_get_shader_input_texture_1944_comment},
  {"get_shader_input_matrix", (PyCFunction) &Dtool_ShaderAttrib_get_shader_input_matrix_1946, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_get_shader_input_matrix_1946_comment},
  {"getShaderInputMatrix", (PyCFunction) &Dtool_ShaderAttrib_get_shader_input_matrix_1946, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderAttrib_get_shader_input_matrix_1946_comment},
  {"get_shader_input_buffer", &Dtool_ShaderAttrib_get_shader_input_buffer_1947, METH_O, (const char *)Dtool_ShaderAttrib_get_shader_input_buffer_1947_comment},
  {"getShaderInputBuffer", &Dtool_ShaderAttrib_get_shader_input_buffer_1947, METH_O, (const char *)Dtool_ShaderAttrib_get_shader_input_buffer_1947_comment},
  {"register_with_read_factory", &Dtool_ShaderAttrib_register_with_read_factory_1948, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderAttrib_register_with_read_factory_1948_comment},
  {"registerWithReadFactory", &Dtool_ShaderAttrib_register_with_read_factory_1948, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderAttrib_register_with_read_factory_1948_comment},
  {"get_class_slot", &Dtool_ShaderAttrib_get_class_slot_1954, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderAttrib_get_class_slot_1954_comment},
  {"getClassSlot", &Dtool_ShaderAttrib_get_class_slot_1954, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderAttrib_get_class_slot_1954_comment},
  {"get_class_type", &Dtool_ShaderAttrib_get_class_type_1956, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderAttrib_get_class_type_1956_comment},
  {"getClassType", &Dtool_ShaderAttrib_get_class_type_1956, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderAttrib_get_class_type_1956_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ShaderAttrib[] = {
  {(char *)"shader", &Dtool_ShaderAttrib_shader_Getter, nullptr, nullptr, nullptr},
  {(char *)"instance_count", &Dtool_ShaderAttrib_instance_count_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ShaderAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShaderAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ShaderAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ShaderAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ShaderAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ShaderAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ShaderAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ShaderAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShaderAttrib,
    &Dtool_SequenceMethods_ShaderAttrib,
    &Dtool_MappingMethods_ShaderAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ShaderAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShaderAttrib,
    nullptr, // tp_members
    Dtool_Properties_ShaderAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShaderAttrib,
    PyType_GenericAlloc,
    Dtool_new_ShaderAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderAttrib,
  Dtool_UpcastInterface_ShaderAttrib,
  Dtool_DowncastInterface_ShaderAttrib,
  (CoerceFunction)Dtool_ConstCoerce_ShaderAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShaderAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_ShaderAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_ShaderAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_ShaderAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ShaderAttrib::;
    PyDict_SetItemString(dict, "F_disable_alpha_write", Dtool_WrapValue(ShaderAttrib::F_disable_alpha_write));
    PyDict_SetItemString(dict, "F_subsume_alpha_test", Dtool_WrapValue(ShaderAttrib::F_subsume_alpha_test));
    PyDict_SetItemString(dict, "F_hardware_skinning", Dtool_WrapValue(ShaderAttrib::F_hardware_skinning));
    PyDict_SetItemString(dict, "F_shader_point_size", Dtool_WrapValue(ShaderAttrib::F_shader_point_size));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_ShaderAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_ShaderAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderAttrib);
  }
}

/**
 * Python method tables for ShowBoundsEffect (ShowBoundsEffect)
 */
static PyMethodDef Dtool_Methods_ShowBoundsEffect[] = {
  {"make", (PyCFunction) &Dtool_ShowBoundsEffect_make_1959, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ShowBoundsEffect_make_1959_comment},
  {"get_tight", &Dtool_ShowBoundsEffect_get_tight_1960, METH_NOARGS, (const char *)Dtool_ShowBoundsEffect_get_tight_1960_comment},
  {"getTight", &Dtool_ShowBoundsEffect_get_tight_1960, METH_NOARGS, (const char *)Dtool_ShowBoundsEffect_get_tight_1960_comment},
  {"get_class_type", &Dtool_ShowBoundsEffect_get_class_type_1961, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShowBoundsEffect_get_class_type_1961_comment},
  {"getClassType", &Dtool_ShowBoundsEffect_get_class_type_1961, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShowBoundsEffect_get_class_type_1961_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ShowBoundsEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShowBoundsEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ShowBoundsEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ShowBoundsEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ShowBoundsEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ShowBoundsEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ShowBoundsEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShowBoundsEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ShowBoundsEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShowBoundsEffect,
    &Dtool_SequenceMethods_ShowBoundsEffect,
    &Dtool_MappingMethods_ShowBoundsEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ShowBoundsEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Applied to a GeomNode to cause a visible bounding volume to be drawn for\n"
    " * this node.  This is generally used only during development to help identify\n"
    " * bounding volume issues.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShowBoundsEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShowBoundsEffect,
    PyType_GenericAlloc,
    Dtool_new_ShowBoundsEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShowBoundsEffect,
  Dtool_UpcastInterface_ShowBoundsEffect,
  Dtool_DowncastInterface_ShowBoundsEffect,
  (CoerceFunction)Dtool_ConstCoerce_ShowBoundsEffect,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShowBoundsEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderEffect(nullptr);
    Dtool_ShowBoundsEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderEffect);
    Dtool_ShowBoundsEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShowBoundsEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShowBoundsEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShowBoundsEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShowBoundsEffect);
  }
}

/**
 * Python method tables for TexProjectorEffect (TexProjectorEffect)
 */
static PyMethodDef Dtool_Methods_TexProjectorEffect[] = {
  {"make", &Dtool_TexProjectorEffect_make_1964, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexProjectorEffect_make_1964_comment},
  {"add_stage", (PyCFunction) &Dtool_TexProjectorEffect_add_stage_1965, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexProjectorEffect_add_stage_1965_comment},
  {"addStage", (PyCFunction) &Dtool_TexProjectorEffect_add_stage_1965, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexProjectorEffect_add_stage_1965_comment},
  {"remove_stage", &Dtool_TexProjectorEffect_remove_stage_1966, METH_O, (const char *)Dtool_TexProjectorEffect_remove_stage_1966_comment},
  {"removeStage", &Dtool_TexProjectorEffect_remove_stage_1966, METH_O, (const char *)Dtool_TexProjectorEffect_remove_stage_1966_comment},
  {"is_empty", &Dtool_TexProjectorEffect_is_empty_1967, METH_NOARGS, (const char *)Dtool_TexProjectorEffect_is_empty_1967_comment},
  {"isEmpty", &Dtool_TexProjectorEffect_is_empty_1967, METH_NOARGS, (const char *)Dtool_TexProjectorEffect_is_empty_1967_comment},
  {"has_stage", &Dtool_TexProjectorEffect_has_stage_1968, METH_O, (const char *)Dtool_TexProjectorEffect_has_stage_1968_comment},
  {"hasStage", &Dtool_TexProjectorEffect_has_stage_1968, METH_O, (const char *)Dtool_TexProjectorEffect_has_stage_1968_comment},
  {"get_from", &Dtool_TexProjectorEffect_get_from_1969, METH_O, (const char *)Dtool_TexProjectorEffect_get_from_1969_comment},
  {"getFrom", &Dtool_TexProjectorEffect_get_from_1969, METH_O, (const char *)Dtool_TexProjectorEffect_get_from_1969_comment},
  {"get_to", &Dtool_TexProjectorEffect_get_to_1970, METH_O, (const char *)Dtool_TexProjectorEffect_get_to_1970_comment},
  {"getTo", &Dtool_TexProjectorEffect_get_to_1970, METH_O, (const char *)Dtool_TexProjectorEffect_get_to_1970_comment},
  {"get_lens_index", &Dtool_TexProjectorEffect_get_lens_index_1971, METH_O, (const char *)Dtool_TexProjectorEffect_get_lens_index_1971_comment},
  {"getLensIndex", &Dtool_TexProjectorEffect_get_lens_index_1971, METH_O, (const char *)Dtool_TexProjectorEffect_get_lens_index_1971_comment},
  {"get_class_type", &Dtool_TexProjectorEffect_get_class_type_1972, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexProjectorEffect_get_class_type_1972_comment},
  {"getClassType", &Dtool_TexProjectorEffect_get_class_type_1972, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexProjectorEffect_get_class_type_1972_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TexProjectorEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TexProjectorEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TexProjectorEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TexProjectorEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TexProjectorEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TexProjectorEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TexProjectorEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TexProjectorEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TexProjectorEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TexProjectorEffect,
    &Dtool_SequenceMethods_TexProjectorEffect,
    &Dtool_MappingMethods_TexProjectorEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TexProjectorEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This effect automatically applies a computed texture matrix to the\n"
    " * specified texture stage, according to the relative position of two\n"
    " * specified nodes.\n"
    " *\n"
    " * The relative transform from the \"from\" node to the \"to\" node is applied\n"
    " * directly to the texture matrix each frame.  If the \"to\" node happens to be\n"
    " * a LensNode, its lens projection matrix is applied as well.\n"
    " *\n"
    " * This can be used to apply a number of special effects.  Fundamentally, it\n"
    " * may simply be used to provide a separate PandaNode that may be adjusted\n"
    " * (e.g.  via a LerpInterval) in order to easily apply a linear transformation\n"
    " * to an object's texture coordinates (rather than having to explicitly call\n"
    " * NodePath.set_tex_transform() each frame).\n"
    " *\n"
    " * In a more sophisticated case, the TexProjectorEffect is particularly useful\n"
    " * in conjunction with a TexGenAttrib that specifies a mode of\n"
    " * M_world_position (which copies the world position of each vertex to the\n"
    " * texture coordinates).  Then the TexProjector can be used to convert these\n"
    " * world coordinates to the relative coordinates of a particular node, causing\n"
    " * (for instance) a texture to appear to follow a node around as it moves\n"
    " * through the world.  With a LensNode, you can project a texture onto the\n"
    " * walls, for instance to apply a flashlight effect or an image-based shadow.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TexProjectorEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TexProjectorEffect,
    PyType_GenericAlloc,
    Dtool_new_TexProjectorEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TexProjectorEffect,
  Dtool_UpcastInterface_TexProjectorEffect,
  Dtool_DowncastInterface_TexProjectorEffect,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TexProjectorEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderEffect(nullptr);
    Dtool_TexProjectorEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderEffect);
    Dtool_TexProjectorEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TexProjectorEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TexProjectorEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TexProjectorEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TexProjectorEffect);
  }
}

/**
 * Python method tables for ScissorEffect (ScissorEffect)
 */
static PyMethodDef Dtool_Methods_ScissorEffect[] = {
  {"make_screen", (PyCFunction) &Dtool_ScissorEffect_make_screen_1974, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ScissorEffect_make_screen_1974_comment},
  {"makeScreen", (PyCFunction) &Dtool_ScissorEffect_make_screen_1974, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ScissorEffect_make_screen_1974_comment},
  {"make_node", (PyCFunction) &Dtool_ScissorEffect_make_node_1975, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ScissorEffect_make_node_1975_comment},
  {"makeNode", (PyCFunction) &Dtool_ScissorEffect_make_node_1975, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ScissorEffect_make_node_1975_comment},
  {"add_point", (PyCFunction) &Dtool_ScissorEffect_add_point_1976, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ScissorEffect_add_point_1976_comment},
  {"addPoint", (PyCFunction) &Dtool_ScissorEffect_add_point_1976, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ScissorEffect_add_point_1976_comment},
  {"is_screen", &Dtool_ScissorEffect_is_screen_1977, METH_NOARGS, (const char *)Dtool_ScissorEffect_is_screen_1977_comment},
  {"isScreen", &Dtool_ScissorEffect_is_screen_1977, METH_NOARGS, (const char *)Dtool_ScissorEffect_is_screen_1977_comment},
  {"get_frame", &Dtool_ScissorEffect_get_frame_1978, METH_NOARGS, (const char *)Dtool_ScissorEffect_get_frame_1978_comment},
  {"getFrame", &Dtool_ScissorEffect_get_frame_1978, METH_NOARGS, (const char *)Dtool_ScissorEffect_get_frame_1978_comment},
  {"get_num_points", &Dtool_ScissorEffect_get_num_points_1979, METH_NOARGS, (const char *)Dtool_ScissorEffect_get_num_points_1979_comment},
  {"getNumPoints", &Dtool_ScissorEffect_get_num_points_1979, METH_NOARGS, (const char *)Dtool_ScissorEffect_get_num_points_1979_comment},
  {"get_point", &Dtool_ScissorEffect_get_point_1980, METH_O, (const char *)Dtool_ScissorEffect_get_point_1980_comment},
  {"getPoint", &Dtool_ScissorEffect_get_point_1980, METH_O, (const char *)Dtool_ScissorEffect_get_point_1980_comment},
  {"get_node", &Dtool_ScissorEffect_get_node_1982, METH_O, (const char *)Dtool_ScissorEffect_get_node_1982_comment},
  {"getNode", &Dtool_ScissorEffect_get_node_1982, METH_O, (const char *)Dtool_ScissorEffect_get_node_1982_comment},
  {"get_clip", &Dtool_ScissorEffect_get_clip_1984, METH_NOARGS, (const char *)Dtool_ScissorEffect_get_clip_1984_comment},
  {"getClip", &Dtool_ScissorEffect_get_clip_1984, METH_NOARGS, (const char *)Dtool_ScissorEffect_get_clip_1984_comment},
  {"get_class_type", &Dtool_ScissorEffect_get_class_type_1985, METH_NOARGS | METH_STATIC, (const char *)Dtool_ScissorEffect_get_class_type_1985_comment},
  {"getClassType", &Dtool_ScissorEffect_get_class_type_1985, METH_NOARGS | METH_STATIC, (const char *)Dtool_ScissorEffect_get_class_type_1985_comment},
  {"get_points", (PyCFunction) &MakeSeq_ScissorEffect_get_points, METH_NOARGS, nullptr},
  { "getPoints", (PyCFunction) &MakeSeq_ScissorEffect_get_points, METH_NOARGS, nullptr},
  {"get_nodes", (PyCFunction) &MakeSeq_ScissorEffect_get_nodes, METH_NOARGS, nullptr},
  { "getNodes", (PyCFunction) &MakeSeq_ScissorEffect_get_nodes, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ScissorEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ScissorEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ScissorEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ScissorEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ScissorEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ScissorEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ScissorEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ScissorEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ScissorEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ScissorEffect,
    &Dtool_SequenceMethods_ScissorEffect,
    &Dtool_MappingMethods_ScissorEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ScissorEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This provides a higher-level wrapper around ScissorAttrib.  It allows for\n"
    " * the scissor region to be defined via points relative to the current node,\n"
    " * and also performs culling based on the scissor region.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ScissorEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ScissorEffect,
    PyType_GenericAlloc,
    Dtool_new_ScissorEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ScissorEffect,
  Dtool_UpcastInterface_ScissorEffect,
  Dtool_DowncastInterface_ScissorEffect,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ScissorEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderEffect(nullptr);
    Dtool_ScissorEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderEffect);
    Dtool_ScissorEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ScissorEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ScissorEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ScissorEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ScissorEffect);
  }
}

/**
 * Python method tables for SceneGraphReducer (SceneGraphReducer)
 */
static PyMethodDef Dtool_Methods_SceneGraphReducer[] = {
  {"set_gsg", &Dtool_SceneGraphReducer_set_gsg_1994, METH_O, (const char *)Dtool_SceneGraphReducer_set_gsg_1994_comment},
  {"setGsg", &Dtool_SceneGraphReducer_set_gsg_1994, METH_O, (const char *)Dtool_SceneGraphReducer_set_gsg_1994_comment},
  {"clear_gsg", &Dtool_SceneGraphReducer_clear_gsg_1995, METH_NOARGS, (const char *)Dtool_SceneGraphReducer_clear_gsg_1995_comment},
  {"clearGsg", &Dtool_SceneGraphReducer_clear_gsg_1995, METH_NOARGS, (const char *)Dtool_SceneGraphReducer_clear_gsg_1995_comment},
  {"get_gsg", &Dtool_SceneGraphReducer_get_gsg_1996, METH_NOARGS, (const char *)Dtool_SceneGraphReducer_get_gsg_1996_comment},
  {"getGsg", &Dtool_SceneGraphReducer_get_gsg_1996, METH_NOARGS, (const char *)Dtool_SceneGraphReducer_get_gsg_1996_comment},
  {"set_combine_radius", &Dtool_SceneGraphReducer_set_combine_radius_1997, METH_O, (const char *)Dtool_SceneGraphReducer_set_combine_radius_1997_comment},
  {"setCombineRadius", &Dtool_SceneGraphReducer_set_combine_radius_1997, METH_O, (const char *)Dtool_SceneGraphReducer_set_combine_radius_1997_comment},
  {"get_combine_radius", &Dtool_SceneGraphReducer_get_combine_radius_1998, METH_NOARGS, (const char *)Dtool_SceneGraphReducer_get_combine_radius_1998_comment},
  {"getCombineRadius", &Dtool_SceneGraphReducer_get_combine_radius_1998, METH_NOARGS, (const char *)Dtool_SceneGraphReducer_get_combine_radius_1998_comment},
  {"apply_attribs", (PyCFunction) &Dtool_SceneGraphReducer_apply_attribs_1999, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_apply_attribs_1999_comment},
  {"applyAttribs", (PyCFunction) &Dtool_SceneGraphReducer_apply_attribs_1999, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_apply_attribs_1999_comment},
  {"flatten", (PyCFunction) &Dtool_SceneGraphReducer_flatten_2000, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_flatten_2000_comment},
  {"remove_column", (PyCFunction) &Dtool_SceneGraphReducer_remove_column_2001, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_remove_column_2001_comment},
  {"removeColumn", (PyCFunction) &Dtool_SceneGraphReducer_remove_column_2001, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_remove_column_2001_comment},
  {"make_compatible_state", &Dtool_SceneGraphReducer_make_compatible_state_2002, METH_O, (const char *)Dtool_SceneGraphReducer_make_compatible_state_2002_comment},
  {"makeCompatibleState", &Dtool_SceneGraphReducer_make_compatible_state_2002, METH_O, (const char *)Dtool_SceneGraphReducer_make_compatible_state_2002_comment},
  {"make_compatible_format", (PyCFunction) &Dtool_SceneGraphReducer_make_compatible_format_2003, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_make_compatible_format_2003_comment},
  {"makeCompatibleFormat", (PyCFunction) &Dtool_SceneGraphReducer_make_compatible_format_2003, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_make_compatible_format_2003_comment},
  {"decompose", &Dtool_SceneGraphReducer_decompose_2004, METH_O, (const char *)Dtool_SceneGraphReducer_decompose_2004_comment},
  {"collect_vertex_data", (PyCFunction) &Dtool_SceneGraphReducer_collect_vertex_data_2005, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_collect_vertex_data_2005_comment},
  {"collectVertexData", (PyCFunction) &Dtool_SceneGraphReducer_collect_vertex_data_2005, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_collect_vertex_data_2005_comment},
  {"make_nonindexed", (PyCFunction) &Dtool_SceneGraphReducer_make_nonindexed_2006, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_make_nonindexed_2006_comment},
  {"makeNonindexed", (PyCFunction) &Dtool_SceneGraphReducer_make_nonindexed_2006, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_make_nonindexed_2006_comment},
  {"unify", (PyCFunction) &Dtool_SceneGraphReducer_unify_2007, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_unify_2007_comment},
  {"remove_unused_vertices", &Dtool_SceneGraphReducer_remove_unused_vertices_2008, METH_O, (const char *)Dtool_SceneGraphReducer_remove_unused_vertices_2008_comment},
  {"removeUnusedVertices", &Dtool_SceneGraphReducer_remove_unused_vertices_2008, METH_O, (const char *)Dtool_SceneGraphReducer_remove_unused_vertices_2008_comment},
  {"premunge", (PyCFunction) &Dtool_SceneGraphReducer_premunge_2009, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphReducer_premunge_2009_comment},
  {"check_live_flatten", &Dtool_SceneGraphReducer_check_live_flatten_2010, METH_O, (const char *)Dtool_SceneGraphReducer_check_live_flatten_2010_comment},
  {"checkLiveFlatten", &Dtool_SceneGraphReducer_check_live_flatten_2010, METH_O, (const char *)Dtool_SceneGraphReducer_check_live_flatten_2010_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_SceneGraphReducer = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_SceneGraphReducer = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SceneGraphReducer",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SceneGraphReducer,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SceneGraphReducer,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An interface for simplifying (\"flattening\") scene graphs by eliminating\n"
    " * unneeded nodes and collapsing out unneeded state changes and transforms.\n"
    " *\n"
    " * This class is designed so that it may be inherited from and specialized, if\n"
    " * needed, to fine-tune the flattening behavior, but normally the default\n"
    " * behavior is sufficient.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SceneGraphReducer,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SceneGraphReducer,
    PyType_GenericAlloc,
    Dtool_new_SceneGraphReducer,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SceneGraphReducer,
  Dtool_UpcastInterface_SceneGraphReducer,
  Dtool_DowncastInterface_SceneGraphReducer,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SceneGraphReducer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SceneGraphReducer._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(47);
    Dtool_SceneGraphReducer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum SceneGraphReducer::AttribTypes;
    PyDict_SetItemString(dict, "TT_transform", Dtool_WrapValue(SceneGraphReducer::TT_transform));
    PyDict_SetItemString(dict, "TTTransform", Dtool_WrapValue(SceneGraphReducer::TT_transform));
    PyDict_SetItemString(dict, "TT_color", Dtool_WrapValue(SceneGraphReducer::TT_color));
    PyDict_SetItemString(dict, "TTColor", Dtool_WrapValue(SceneGraphReducer::TT_color));
    PyDict_SetItemString(dict, "TT_color_scale", Dtool_WrapValue(SceneGraphReducer::TT_color_scale));
    PyDict_SetItemString(dict, "TTColorScale", Dtool_WrapValue(SceneGraphReducer::TT_color_scale));
    PyDict_SetItemString(dict, "TT_tex_matrix", Dtool_WrapValue(SceneGraphReducer::TT_tex_matrix));
    PyDict_SetItemString(dict, "TTTexMatrix", Dtool_WrapValue(SceneGraphReducer::TT_tex_matrix));
    PyDict_SetItemString(dict, "TT_clip_plane", Dtool_WrapValue(SceneGraphReducer::TT_clip_plane));
    PyDict_SetItemString(dict, "TTClipPlane", Dtool_WrapValue(SceneGraphReducer::TT_clip_plane));
    PyDict_SetItemString(dict, "TT_cull_face", Dtool_WrapValue(SceneGraphReducer::TT_cull_face));
    PyDict_SetItemString(dict, "TTCullFace", Dtool_WrapValue(SceneGraphReducer::TT_cull_face));
    PyDict_SetItemString(dict, "TT_apply_texture_color", Dtool_WrapValue(SceneGraphReducer::TT_apply_texture_color));
    PyDict_SetItemString(dict, "TTApplyTextureColor", Dtool_WrapValue(SceneGraphReducer::TT_apply_texture_color));
    PyDict_SetItemString(dict, "TT_other", Dtool_WrapValue(SceneGraphReducer::TT_other));
    PyDict_SetItemString(dict, "TTOther", Dtool_WrapValue(SceneGraphReducer::TT_other));
    // enum SceneGraphReducer::CombineSiblings;
    PyDict_SetItemString(dict, "CS_geom_node", Dtool_WrapValue(SceneGraphReducer::CS_geom_node));
    PyDict_SetItemString(dict, "CSGeomNode", Dtool_WrapValue(SceneGraphReducer::CS_geom_node));
    PyDict_SetItemString(dict, "CS_within_radius", Dtool_WrapValue(SceneGraphReducer::CS_within_radius));
    PyDict_SetItemString(dict, "CSWithinRadius", Dtool_WrapValue(SceneGraphReducer::CS_within_radius));
    PyDict_SetItemString(dict, "CS_other", Dtool_WrapValue(SceneGraphReducer::CS_other));
    PyDict_SetItemString(dict, "CSOther", Dtool_WrapValue(SceneGraphReducer::CS_other));
    PyDict_SetItemString(dict, "CS_recurse", Dtool_WrapValue(SceneGraphReducer::CS_recurse));
    PyDict_SetItemString(dict, "CSRecurse", Dtool_WrapValue(SceneGraphReducer::CS_recurse));
    // enum SceneGraphReducer::CollectVertexData;
    PyDict_SetItemString(dict, "CVD_name", Dtool_WrapValue(SceneGraphReducer::CVD_name));
    PyDict_SetItemString(dict, "CVDName", Dtool_WrapValue(SceneGraphReducer::CVD_name));
    PyDict_SetItemString(dict, "CVD_model", Dtool_WrapValue(SceneGraphReducer::CVD_model));
    PyDict_SetItemString(dict, "CVDModel", Dtool_WrapValue(SceneGraphReducer::CVD_model));
    PyDict_SetItemString(dict, "CVD_transform", Dtool_WrapValue(SceneGraphReducer::CVD_transform));
    PyDict_SetItemString(dict, "CVDTransform", Dtool_WrapValue(SceneGraphReducer::CVD_transform));
    PyDict_SetItemString(dict, "CVD_avoid_dynamic", Dtool_WrapValue(SceneGraphReducer::CVD_avoid_dynamic));
    PyDict_SetItemString(dict, "CVDAvoidDynamic", Dtool_WrapValue(SceneGraphReducer::CVD_avoid_dynamic));
    PyDict_SetItemString(dict, "CVD_one_node_only", Dtool_WrapValue(SceneGraphReducer::CVD_one_node_only));
    PyDict_SetItemString(dict, "CVDOneNodeOnly", Dtool_WrapValue(SceneGraphReducer::CVD_one_node_only));
    PyDict_SetItemString(dict, "CVD_format", Dtool_WrapValue(SceneGraphReducer::CVD_format));
    PyDict_SetItemString(dict, "CVDFormat", Dtool_WrapValue(SceneGraphReducer::CVD_format));
    PyDict_SetItemString(dict, "CVD_usage_hint", Dtool_WrapValue(SceneGraphReducer::CVD_usage_hint));
    PyDict_SetItemString(dict, "CVDUsageHint", Dtool_WrapValue(SceneGraphReducer::CVD_usage_hint));
    PyDict_SetItemString(dict, "CVD_animation_type", Dtool_WrapValue(SceneGraphReducer::CVD_animation_type));
    PyDict_SetItemString(dict, "CVDAnimationType", Dtool_WrapValue(SceneGraphReducer::CVD_animation_type));
    // enum SceneGraphReducer::MakeNonindexed;
    PyDict_SetItemString(dict, "MN_composite_only", Dtool_WrapValue(SceneGraphReducer::MN_composite_only));
    PyDict_SetItemString(dict, "MNCompositeOnly", Dtool_WrapValue(SceneGraphReducer::MN_composite_only));
    PyDict_SetItemString(dict, "MN_avoid_animated", Dtool_WrapValue(SceneGraphReducer::MN_avoid_animated));
    PyDict_SetItemString(dict, "MNAvoidAnimated", Dtool_WrapValue(SceneGraphReducer::MN_avoid_animated));
    PyDict_SetItemString(dict, "MN_avoid_dynamic", Dtool_WrapValue(SceneGraphReducer::MN_avoid_dynamic));
    PyDict_SetItemString(dict, "MNAvoidDynamic", Dtool_WrapValue(SceneGraphReducer::MN_avoid_dynamic));
    if (PyType_Ready((PyTypeObject *)&Dtool_SceneGraphReducer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SceneGraphReducer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SceneGraphReducer);
  }
}

/**
 * Python method tables for ParamNodePath (ParamNodePath)
 */
static PyMethodDef Dtool_Methods_ParamNodePath[] = {
  {"get_value", &Dtool_ParamNodePath_get_value_2016, METH_NOARGS, (const char *)Dtool_ParamNodePath_get_value_2016_comment},
  {"getValue", &Dtool_ParamNodePath_get_value_2016, METH_NOARGS, (const char *)Dtool_ParamNodePath_get_value_2016_comment},
  {"get_class_type", &Dtool_ParamNodePath_get_class_type_2017, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamNodePath_get_class_type_2017_comment},
  {"getClassType", &Dtool_ParamNodePath_get_class_type_2017, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamNodePath_get_class_type_2017_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ParamNodePath = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamNodePath = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamNodePath = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamNodePath = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamNodePath = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamNodePath = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamNodePath",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamNodePath,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamNodePath,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamNodePath,
    &Dtool_SequenceMethods_ParamNodePath,
    &Dtool_MappingMethods_ParamNodePath,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamNodePath,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class object for storing a NodePath as a parameter.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamNodePath,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamNodePath,
    PyType_GenericAlloc,
    Dtool_new_ParamNodePath,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamNodePath,
  Dtool_UpcastInterface_ParamNodePath,
  Dtool_DowncastInterface_ParamNodePath,
  (CoerceFunction)Dtool_ConstCoerce_ParamNodePath,
  (CoerceFunction)Dtool_Coerce_ParamNodePath,
};

static void Dtool_PyModuleClassInit_ParamNodePath(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ParamValueBase != nullptr);
    assert(Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit(nullptr);
    Dtool_ParamNodePath._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ParamValueBase);
    Dtool_ParamNodePath._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamNodePath._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamNodePath) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamNodePath)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamNodePath);
  }
}

/**
 * Python method tables for PortalNode (PortalNode)
 */
static PyMethodDef Dtool_Methods_PortalNode[] = {
  {"set_portal_mask", &Dtool_PortalNode_set_portal_mask_2020, METH_O, (const char *)Dtool_PortalNode_set_portal_mask_2020_comment},
  {"setPortalMask", &Dtool_PortalNode_set_portal_mask_2020, METH_O, (const char *)Dtool_PortalNode_set_portal_mask_2020_comment},
  {"set_from_portal_mask", &Dtool_PortalNode_set_from_portal_mask_2021, METH_O, (const char *)Dtool_PortalNode_set_from_portal_mask_2021_comment},
  {"setFromPortalMask", &Dtool_PortalNode_set_from_portal_mask_2021, METH_O, (const char *)Dtool_PortalNode_set_from_portal_mask_2021_comment},
  {"set_into_portal_mask", &Dtool_PortalNode_set_into_portal_mask_2022, METH_O, (const char *)Dtool_PortalNode_set_into_portal_mask_2022_comment},
  {"setIntoPortalMask", &Dtool_PortalNode_set_into_portal_mask_2022, METH_O, (const char *)Dtool_PortalNode_set_into_portal_mask_2022_comment},
  {"get_from_portal_mask", &Dtool_PortalNode_get_from_portal_mask_2023, METH_NOARGS, (const char *)Dtool_PortalNode_get_from_portal_mask_2023_comment},
  {"getFromPortalMask", &Dtool_PortalNode_get_from_portal_mask_2023, METH_NOARGS, (const char *)Dtool_PortalNode_get_from_portal_mask_2023_comment},
  {"get_into_portal_mask", &Dtool_PortalNode_get_into_portal_mask_2024, METH_NOARGS, (const char *)Dtool_PortalNode_get_into_portal_mask_2024_comment},
  {"getIntoPortalMask", &Dtool_PortalNode_get_into_portal_mask_2024, METH_NOARGS, (const char *)Dtool_PortalNode_get_into_portal_mask_2024_comment},
  {"set_portal_geom", &Dtool_PortalNode_set_portal_geom_2025, METH_O, (const char *)Dtool_PortalNode_set_portal_geom_2025_comment},
  {"setPortalGeom", &Dtool_PortalNode_set_portal_geom_2025, METH_O, (const char *)Dtool_PortalNode_set_portal_geom_2025_comment},
  {"get_portal_geom", &Dtool_PortalNode_get_portal_geom_2026, METH_NOARGS, (const char *)Dtool_PortalNode_get_portal_geom_2026_comment},
  {"getPortalGeom", &Dtool_PortalNode_get_portal_geom_2026, METH_NOARGS, (const char *)Dtool_PortalNode_get_portal_geom_2026_comment},
  {"clear_vertices", &Dtool_PortalNode_clear_vertices_2027, METH_NOARGS, (const char *)Dtool_PortalNode_clear_vertices_2027_comment},
  {"clearVertices", &Dtool_PortalNode_clear_vertices_2027, METH_NOARGS, (const char *)Dtool_PortalNode_clear_vertices_2027_comment},
  {"add_vertex", &Dtool_PortalNode_add_vertex_2028, METH_O, (const char *)Dtool_PortalNode_add_vertex_2028_comment},
  {"addVertex", &Dtool_PortalNode_add_vertex_2028, METH_O, (const char *)Dtool_PortalNode_add_vertex_2028_comment},
  {"get_num_vertices", &Dtool_PortalNode_get_num_vertices_2029, METH_NOARGS, (const char *)Dtool_PortalNode_get_num_vertices_2029_comment},
  {"getNumVertices", &Dtool_PortalNode_get_num_vertices_2029, METH_NOARGS, (const char *)Dtool_PortalNode_get_num_vertices_2029_comment},
  {"get_vertex", &Dtool_PortalNode_get_vertex_2030, METH_O, (const char *)Dtool_PortalNode_get_vertex_2030_comment},
  {"getVertex", &Dtool_PortalNode_get_vertex_2030, METH_O, (const char *)Dtool_PortalNode_get_vertex_2030_comment},
  {"set_cell_in", &Dtool_PortalNode_set_cell_in_2032, METH_O, (const char *)Dtool_PortalNode_set_cell_in_2032_comment},
  {"setCellIn", &Dtool_PortalNode_set_cell_in_2032, METH_O, (const char *)Dtool_PortalNode_set_cell_in_2032_comment},
  {"get_cell_in", &Dtool_PortalNode_get_cell_in_2033, METH_NOARGS, (const char *)Dtool_PortalNode_get_cell_in_2033_comment},
  {"getCellIn", &Dtool_PortalNode_get_cell_in_2033, METH_NOARGS, (const char *)Dtool_PortalNode_get_cell_in_2033_comment},
  {"set_cell_out", &Dtool_PortalNode_set_cell_out_2034, METH_O, (const char *)Dtool_PortalNode_set_cell_out_2034_comment},
  {"setCellOut", &Dtool_PortalNode_set_cell_out_2034, METH_O, (const char *)Dtool_PortalNode_set_cell_out_2034_comment},
  {"get_cell_out", &Dtool_PortalNode_get_cell_out_2035, METH_NOARGS, (const char *)Dtool_PortalNode_get_cell_out_2035_comment},
  {"getCellOut", &Dtool_PortalNode_get_cell_out_2035, METH_NOARGS, (const char *)Dtool_PortalNode_get_cell_out_2035_comment},
  {"set_clip_plane", &Dtool_PortalNode_set_clip_plane_2036, METH_O, (const char *)Dtool_PortalNode_set_clip_plane_2036_comment},
  {"setClipPlane", &Dtool_PortalNode_set_clip_plane_2036, METH_O, (const char *)Dtool_PortalNode_set_clip_plane_2036_comment},
  {"is_clip_plane", &Dtool_PortalNode_is_clip_plane_2037, METH_NOARGS, (const char *)Dtool_PortalNode_is_clip_plane_2037_comment},
  {"isClipPlane", &Dtool_PortalNode_is_clip_plane_2037, METH_NOARGS, (const char *)Dtool_PortalNode_is_clip_plane_2037_comment},
  {"set_visible", &Dtool_PortalNode_set_visible_2038, METH_O, (const char *)Dtool_PortalNode_set_visible_2038_comment},
  {"setVisible", &Dtool_PortalNode_set_visible_2038, METH_O, (const char *)Dtool_PortalNode_set_visible_2038_comment},
  {"is_visible", &Dtool_PortalNode_is_visible_2039, METH_NOARGS, (const char *)Dtool_PortalNode_is_visible_2039_comment},
  {"isVisible", &Dtool_PortalNode_is_visible_2039, METH_NOARGS, (const char *)Dtool_PortalNode_is_visible_2039_comment},
  {"set_max_depth", &Dtool_PortalNode_set_max_depth_2040, METH_O, (const char *)Dtool_PortalNode_set_max_depth_2040_comment},
  {"setMaxDepth", &Dtool_PortalNode_set_max_depth_2040, METH_O, (const char *)Dtool_PortalNode_set_max_depth_2040_comment},
  {"get_max_depth", &Dtool_PortalNode_get_max_depth_2041, METH_NOARGS, (const char *)Dtool_PortalNode_get_max_depth_2041_comment},
  {"getMaxDepth", &Dtool_PortalNode_get_max_depth_2041, METH_NOARGS, (const char *)Dtool_PortalNode_get_max_depth_2041_comment},
  {"set_open", &Dtool_PortalNode_set_open_2042, METH_O, (const char *)Dtool_PortalNode_set_open_2042_comment},
  {"setOpen", &Dtool_PortalNode_set_open_2042, METH_O, (const char *)Dtool_PortalNode_set_open_2042_comment},
  {"is_open", &Dtool_PortalNode_is_open_2043, METH_NOARGS, (const char *)Dtool_PortalNode_is_open_2043_comment},
  {"isOpen", &Dtool_PortalNode_is_open_2043, METH_NOARGS, (const char *)Dtool_PortalNode_is_open_2043_comment},
  {"get_class_type", &Dtool_PortalNode_get_class_type_2055, METH_NOARGS | METH_STATIC, (const char *)Dtool_PortalNode_get_class_type_2055_comment},
  {"getClassType", &Dtool_PortalNode_get_class_type_2055, METH_NOARGS | METH_STATIC, (const char *)Dtool_PortalNode_get_class_type_2055_comment},
  {"get_vertices", (PyCFunction) &MakeSeq_PortalNode_get_vertices, METH_NOARGS, nullptr},
  { "getVertices", (PyCFunction) &MakeSeq_PortalNode_get_vertices, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PortalNode[] = {
  {(char *)"into_portal_mask", &Dtool_PortalNode_into_portal_mask_Getter, &Dtool_PortalNode_into_portal_mask_Setter, nullptr, nullptr},
  {(char *)"from_portal_mask", &Dtool_PortalNode_from_portal_mask_Getter, &Dtool_PortalNode_from_portal_mask_Setter, nullptr, nullptr},
  {(char *)"portal_geom", &Dtool_PortalNode_portal_geom_Getter, &Dtool_PortalNode_portal_geom_Setter, nullptr, nullptr},
  {(char *)"vertices", &Dtool_PortalNode_vertices_Getter, nullptr, nullptr, nullptr},
  {(char *)"cell_in", &Dtool_PortalNode_cell_in_Getter, &Dtool_PortalNode_cell_in_Setter, nullptr, nullptr},
  {(char *)"cell_out", &Dtool_PortalNode_cell_out_Getter, &Dtool_PortalNode_cell_out_Setter, nullptr, nullptr},
  {(char *)"clip_plane", &Dtool_PortalNode_clip_plane_Getter, &Dtool_PortalNode_clip_plane_Setter, nullptr, nullptr},
  {(char *)"visible", &Dtool_PortalNode_visible_Getter, &Dtool_PortalNode_visible_Setter, nullptr, nullptr},
  {(char *)"max_depth", &Dtool_PortalNode_max_depth_Getter, &Dtool_PortalNode_max_depth_Setter, nullptr, nullptr},
  {(char *)"open", &Dtool_PortalNode_open_Getter, &Dtool_PortalNode_open_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PortalNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PortalNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PortalNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PortalNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PortalNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PortalNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PortalNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PortalNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PortalNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PortalNode,
    &Dtool_SequenceMethods_PortalNode,
    &Dtool_MappingMethods_PortalNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PortalNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node in the scene graph that can hold a Portal Polygon, which is a\n"
    " * rectangle.  Other types of polygons are not supported for now.  It also\n"
    " * holds a PT(PandaNode) Cell that this portal is connected to\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PortalNode,
    nullptr, // tp_members
    Dtool_Properties_PortalNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PortalNode,
    PyType_GenericAlloc,
    Dtool_new_PortalNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PortalNode,
  Dtool_UpcastInterface_PortalNode,
  Dtool_DowncastInterface_PortalNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PortalNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PandaNode(nullptr);
    Dtool_PortalNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PandaNode);
    Dtool_PortalNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PortalNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PortalNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PortalNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PortalNode);
  }
}

/**
 * Python method tables for ScissorAttrib (ScissorAttrib)
 */
static PyMethodDef Dtool_Methods_ScissorAttrib[] = {
  {"make_off", &Dtool_ScissorAttrib_make_off_2057, METH_NOARGS | METH_STATIC, (const char *)Dtool_ScissorAttrib_make_off_2057_comment},
  {"makeOff", &Dtool_ScissorAttrib_make_off_2057, METH_NOARGS | METH_STATIC, (const char *)Dtool_ScissorAttrib_make_off_2057_comment},
  {"make", (PyCFunction) &Dtool_ScissorAttrib_make_2058, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ScissorAttrib_make_2058_comment},
  {"make_default", &Dtool_ScissorAttrib_make_default_2059, METH_NOARGS | METH_STATIC, (const char *)Dtool_ScissorAttrib_make_default_2059_comment},
  {"makeDefault", &Dtool_ScissorAttrib_make_default_2059, METH_NOARGS | METH_STATIC, (const char *)Dtool_ScissorAttrib_make_default_2059_comment},
  {"is_off", &Dtool_ScissorAttrib_is_off_2060, METH_NOARGS, (const char *)Dtool_ScissorAttrib_is_off_2060_comment},
  {"isOff", &Dtool_ScissorAttrib_is_off_2060, METH_NOARGS, (const char *)Dtool_ScissorAttrib_is_off_2060_comment},
  {"get_frame", &Dtool_ScissorAttrib_get_frame_2061, METH_NOARGS, (const char *)Dtool_ScissorAttrib_get_frame_2061_comment},
  {"getFrame", &Dtool_ScissorAttrib_get_frame_2061, METH_NOARGS, (const char *)Dtool_ScissorAttrib_get_frame_2061_comment},
  {"get_class_slot", &Dtool_ScissorAttrib_get_class_slot_2063, METH_NOARGS | METH_STATIC, (const char *)Dtool_ScissorAttrib_get_class_slot_2063_comment},
  {"getClassSlot", &Dtool_ScissorAttrib_get_class_slot_2063, METH_NOARGS | METH_STATIC, (const char *)Dtool_ScissorAttrib_get_class_slot_2063_comment},
  {"get_class_type", &Dtool_ScissorAttrib_get_class_type_2065, METH_NOARGS | METH_STATIC, (const char *)Dtool_ScissorAttrib_get_class_type_2065_comment},
  {"getClassType", &Dtool_ScissorAttrib_get_class_type_2065, METH_NOARGS | METH_STATIC, (const char *)Dtool_ScissorAttrib_get_class_type_2065_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ScissorAttrib[] = {
  {(char *)"frame", &Dtool_ScissorAttrib_frame_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ScissorAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ScissorAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ScissorAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ScissorAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ScissorAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ScissorAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ScissorAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ScissorAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ScissorAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ScissorAttrib,
    &Dtool_SequenceMethods_ScissorAttrib,
    &Dtool_MappingMethods_ScissorAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ScissorAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This restricts rendering to within a rectangular region of the scene,\n"
    " * without otherwise affecting the viewport or lens properties.  Geometry that\n"
    " * falls outside the scissor region is not rendered.  It is akin to the OpenGL\n"
    " * glScissor() function.\n"
    " *\n"
    " * The ScissorAttrib always specifies its region relative to its enclosing\n"
    " * DisplayRegion, in screen space, and performs no culling.\n"
    " *\n"
    " * See ScissorEffect if you wish to define a region relative to 2-D or 3-D\n"
    " * coordinates in the scene graph, with culling.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ScissorAttrib,
    nullptr, // tp_members
    Dtool_Properties_ScissorAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ScissorAttrib,
    PyType_GenericAlloc,
    Dtool_new_ScissorAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ScissorAttrib,
  Dtool_UpcastInterface_ScissorAttrib,
  Dtool_DowncastInterface_ScissorAttrib,
  (CoerceFunction)Dtool_ConstCoerce_ScissorAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_ScissorAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_ScissorAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_ScissorAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ScissorAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_ScissorAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_ScissorAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_ScissorAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ScissorAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ScissorAttrib);
  }
}

/**
 * Python method tables for ShadeModelAttrib (ShadeModelAttrib)
 */
static PyMethodDef Dtool_Methods_ShadeModelAttrib[] = {
  {"make", &Dtool_ShadeModelAttrib_make_2069, METH_O | METH_STATIC, (const char *)Dtool_ShadeModelAttrib_make_2069_comment},
  {"make_default", &Dtool_ShadeModelAttrib_make_default_2070, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShadeModelAttrib_make_default_2070_comment},
  {"makeDefault", &Dtool_ShadeModelAttrib_make_default_2070, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShadeModelAttrib_make_default_2070_comment},
  {"get_mode", &Dtool_ShadeModelAttrib_get_mode_2071, METH_NOARGS, (const char *)Dtool_ShadeModelAttrib_get_mode_2071_comment},
  {"getMode", &Dtool_ShadeModelAttrib_get_mode_2071, METH_NOARGS, (const char *)Dtool_ShadeModelAttrib_get_mode_2071_comment},
  {"get_class_slot", &Dtool_ShadeModelAttrib_get_class_slot_2073, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShadeModelAttrib_get_class_slot_2073_comment},
  {"getClassSlot", &Dtool_ShadeModelAttrib_get_class_slot_2073, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShadeModelAttrib_get_class_slot_2073_comment},
  {"get_class_type", &Dtool_ShadeModelAttrib_get_class_type_2075, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShadeModelAttrib_get_class_type_2075_comment},
  {"getClassType", &Dtool_ShadeModelAttrib_get_class_type_2075, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShadeModelAttrib_get_class_type_2075_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ShadeModelAttrib[] = {
  {(char *)"mode", &Dtool_ShadeModelAttrib_mode_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ShadeModelAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShadeModelAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ShadeModelAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ShadeModelAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ShadeModelAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ShadeModelAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ShadeModelAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShadeModelAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ShadeModelAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShadeModelAttrib,
    &Dtool_SequenceMethods_ShadeModelAttrib,
    &Dtool_MappingMethods_ShadeModelAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ShadeModelAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Specifies whether flat shading (per-polygon) or smooth shading (per-vertex)\n"
    " * is in effect.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShadeModelAttrib,
    nullptr, // tp_members
    Dtool_Properties_ShadeModelAttrib,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShadeModelAttrib,
    PyType_GenericAlloc,
    Dtool_new_ShadeModelAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShadeModelAttrib,
  Dtool_UpcastInterface_ShadeModelAttrib,
  Dtool_DowncastInterface_ShadeModelAttrib,
  (CoerceFunction)Dtool_ConstCoerce_ShadeModelAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShadeModelAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_ShadeModelAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_ShadeModelAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShadeModelAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ShadeModelAttrib::Mode;
    PyDict_SetItemString(dict, "M_flat", Dtool_WrapValue(ShadeModelAttrib::M_flat));
    PyDict_SetItemString(dict, "MFlat", Dtool_WrapValue(ShadeModelAttrib::M_flat));
    PyDict_SetItemString(dict, "M_smooth", Dtool_WrapValue(ShadeModelAttrib::M_smooth));
    PyDict_SetItemString(dict, "MSmooth", Dtool_WrapValue(ShadeModelAttrib::M_smooth));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_ShadeModelAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_ShadeModelAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_ShadeModelAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShadeModelAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShadeModelAttrib);
  }
}

/**
 * Python method tables for StencilAttrib (StencilAttrib)
 */
static PyMethodDef Dtool_Methods_StencilAttrib[] = {
  {"make_off", &Dtool_StencilAttrib_make_off_2081, METH_NOARGS | METH_STATIC, (const char *)Dtool_StencilAttrib_make_off_2081_comment},
  {"makeOff", &Dtool_StencilAttrib_make_off_2081, METH_NOARGS | METH_STATIC, (const char *)Dtool_StencilAttrib_make_off_2081_comment},
  {"make_default", &Dtool_StencilAttrib_make_default_2082, METH_NOARGS | METH_STATIC, (const char *)Dtool_StencilAttrib_make_default_2082_comment},
  {"makeDefault", &Dtool_StencilAttrib_make_default_2082, METH_NOARGS | METH_STATIC, (const char *)Dtool_StencilAttrib_make_default_2082_comment},
  {"make", (PyCFunction) &Dtool_StencilAttrib_make_2083, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_StencilAttrib_make_2083_comment},
  {"make_2_sided", (PyCFunction) &Dtool_StencilAttrib_make_2_sided_2084, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_StencilAttrib_make_2_sided_2084_comment},
  {"make2Sided", (PyCFunction) &Dtool_StencilAttrib_make_2_sided_2084, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_StencilAttrib_make_2_sided_2084_comment},
  {"make_with_clear", (PyCFunction) &Dtool_StencilAttrib_make_with_clear_2085, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_StencilAttrib_make_with_clear_2085_comment},
  {"makeWithClear", (PyCFunction) &Dtool_StencilAttrib_make_with_clear_2085, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_StencilAttrib_make_with_clear_2085_comment},
  {"make_2_sided_with_clear", (PyCFunction) &Dtool_StencilAttrib_make_2_sided_with_clear_2086, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_StencilAttrib_make_2_sided_with_clear_2086_comment},
  {"make2SidedWithClear", (PyCFunction) &Dtool_StencilAttrib_make_2_sided_with_clear_2086, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_StencilAttrib_make_2_sided_with_clear_2086_comment},
  {"get_render_state", &Dtool_StencilAttrib_get_render_state_2087, METH_O, (const char *)Dtool_StencilAttrib_get_render_state_2087_comment},
  {"getRenderState", &Dtool_StencilAttrib_get_render_state_2087, METH_O, (const char *)Dtool_StencilAttrib_get_render_state_2087_comment},
  {"get_class_slot", &Dtool_StencilAttrib_get_class_slot_2088, METH_NOARGS | METH_STATIC, (const char *)Dtool_StencilAttrib_get_class_slot_2088_comment},
  {"getClassSlot", &Dtool_StencilAttrib_get_class_slot_2088, METH_NOARGS | METH_STATIC, (const char *)Dtool_StencilAttrib_get_class_slot_2088_comment},
  {"get_class_type", &Dtool_StencilAttrib_get_class_type_2090, METH_NOARGS | METH_STATIC, (const char *)Dtool_StencilAttrib_get_class_type_2090_comment},
  {"getClassType", &Dtool_StencilAttrib_get_class_type_2090, METH_NOARGS | METH_STATIC, (const char *)Dtool_StencilAttrib_get_class_type_2090_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_StencilAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_StencilAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_StencilAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_StencilAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_StencilAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_StencilAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.StencilAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_StencilAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_StencilAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_StencilAttrib,
    &Dtool_SequenceMethods_StencilAttrib,
    &Dtool_MappingMethods_StencilAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_StencilAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A StencilAttrib is a collection of all stencil render states.  The render\n"
    " * states in a StencilAttrib are read-only.  A StencilAttrib is created with\n"
    " * make or make_2_sided.  To determine if two sided stencil is supported, call\n"
    " * the function GraphicsStateGuardian:: get_supports_two_sided_stencil.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_StencilAttrib,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_StencilAttrib,
    PyType_GenericAlloc,
    Dtool_new_StencilAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StencilAttrib,
  Dtool_UpcastInterface_StencilAttrib,
  Dtool_DowncastInterface_StencilAttrib,
  (CoerceFunction)Dtool_ConstCoerce_StencilAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_StencilAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RenderAttrib(nullptr);
    Dtool_StencilAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RenderAttrib);
    Dtool_StencilAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(61);
    Dtool_StencilAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum StencilAttrib::StencilRenderState;
    PyDict_SetItemString(dict, "SRS_front_comparison_function", Dtool_WrapValue(StencilAttrib::SRS_front_comparison_function));
    PyDict_SetItemString(dict, "SRSFrontComparisonFunction", Dtool_WrapValue(StencilAttrib::SRS_front_comparison_function));
    PyDict_SetItemString(dict, "SRS_front_stencil_fail_operation", Dtool_WrapValue(StencilAttrib::SRS_front_stencil_fail_operation));
    PyDict_SetItemString(dict, "SRSFrontStencilFailOperation", Dtool_WrapValue(StencilAttrib::SRS_front_stencil_fail_operation));
    PyDict_SetItemString(dict, "SRS_front_stencil_pass_z_fail_operation", Dtool_WrapValue(StencilAttrib::SRS_front_stencil_pass_z_fail_operation));
    PyDict_SetItemString(dict, "SRSFrontStencilPassZFailOperation", Dtool_WrapValue(StencilAttrib::SRS_front_stencil_pass_z_fail_operation));
    PyDict_SetItemString(dict, "SRS_front_stencil_pass_z_pass_operation", Dtool_WrapValue(StencilAttrib::SRS_front_stencil_pass_z_pass_operation));
    PyDict_SetItemString(dict, "SRSFrontStencilPassZPassOperation", Dtool_WrapValue(StencilAttrib::SRS_front_stencil_pass_z_pass_operation));
    PyDict_SetItemString(dict, "SRS_reference", Dtool_WrapValue(StencilAttrib::SRS_reference));
    PyDict_SetItemString(dict, "SRSReference", Dtool_WrapValue(StencilAttrib::SRS_reference));
    PyDict_SetItemString(dict, "SRS_read_mask", Dtool_WrapValue(StencilAttrib::SRS_read_mask));
    PyDict_SetItemString(dict, "SRSReadMask", Dtool_WrapValue(StencilAttrib::SRS_read_mask));
    PyDict_SetItemString(dict, "SRS_write_mask", Dtool_WrapValue(StencilAttrib::SRS_write_mask));
    PyDict_SetItemString(dict, "SRSWriteMask", Dtool_WrapValue(StencilAttrib::SRS_write_mask));
    PyDict_SetItemString(dict, "SRS_back_comparison_function", Dtool_WrapValue(StencilAttrib::SRS_back_comparison_function));
    PyDict_SetItemString(dict, "SRSBackComparisonFunction", Dtool_WrapValue(StencilAttrib::SRS_back_comparison_function));
    PyDict_SetItemString(dict, "SRS_back_stencil_fail_operation", Dtool_WrapValue(StencilAttrib::SRS_back_stencil_fail_operation));
    PyDict_SetItemString(dict, "SRSBackStencilFailOperation", Dtool_WrapValue(StencilAttrib::SRS_back_stencil_fail_operation));
    PyDict_SetItemString(dict, "SRS_back_stencil_pass_z_fail_operation", Dtool_WrapValue(StencilAttrib::SRS_back_stencil_pass_z_fail_operation));
    PyDict_SetItemString(dict, "SRSBackStencilPassZFailOperation", Dtool_WrapValue(StencilAttrib::SRS_back_stencil_pass_z_fail_operation));
    PyDict_SetItemString(dict, "SRS_back_stencil_pass_z_pass_operation", Dtool_WrapValue(StencilAttrib::SRS_back_stencil_pass_z_pass_operation));
    PyDict_SetItemString(dict, "SRSBackStencilPassZPassOperation", Dtool_WrapValue(StencilAttrib::SRS_back_stencil_pass_z_pass_operation));
    PyDict_SetItemString(dict, "SRS_clear", Dtool_WrapValue(StencilAttrib::SRS_clear));
    PyDict_SetItemString(dict, "SRSClear", Dtool_WrapValue(StencilAttrib::SRS_clear));
    PyDict_SetItemString(dict, "SRS_clear_value", Dtool_WrapValue(StencilAttrib::SRS_clear_value));
    PyDict_SetItemString(dict, "SRSClearValue", Dtool_WrapValue(StencilAttrib::SRS_clear_value));
    PyDict_SetItemString(dict, "SRS_total", Dtool_WrapValue(StencilAttrib::SRS_total));
    PyDict_SetItemString(dict, "SRSTotal", Dtool_WrapValue(StencilAttrib::SRS_total));
    // enum StencilAttrib::StencilComparisonFunction;
    PyDict_SetItemString(dict, "SCF_never", Dtool_WrapValue(StencilAttrib::SCF_never));
    PyDict_SetItemString(dict, "SCFNever", Dtool_WrapValue(StencilAttrib::SCF_never));
    PyDict_SetItemString(dict, "SCF_less_than", Dtool_WrapValue(StencilAttrib::SCF_less_than));
    PyDict_SetItemString(dict, "SCFLessThan", Dtool_WrapValue(StencilAttrib::SCF_less_than));
    PyDict_SetItemString(dict, "SCF_equal", Dtool_WrapValue(StencilAttrib::SCF_equal));
    PyDict_SetItemString(dict, "SCFEqual", Dtool_WrapValue(StencilAttrib::SCF_equal));
    PyDict_SetItemString(dict, "SCF_less_than_or_equal", Dtool_WrapValue(StencilAttrib::SCF_less_than_or_equal));
    PyDict_SetItemString(dict, "SCFLessThanOrEqual", Dtool_WrapValue(StencilAttrib::SCF_less_than_or_equal));
    PyDict_SetItemString(dict, "SCF_greater_than", Dtool_WrapValue(StencilAttrib::SCF_greater_than));
    PyDict_SetItemString(dict, "SCFGreaterThan", Dtool_WrapValue(StencilAttrib::SCF_greater_than));
    PyDict_SetItemString(dict, "SCF_not_equal", Dtool_WrapValue(StencilAttrib::SCF_not_equal));
    PyDict_SetItemString(dict, "SCFNotEqual", Dtool_WrapValue(StencilAttrib::SCF_not_equal));
    PyDict_SetItemString(dict, "SCF_greater_than_or_equal", Dtool_WrapValue(StencilAttrib::SCF_greater_than_or_equal));
    PyDict_SetItemString(dict, "SCFGreaterThanOrEqual", Dtool_WrapValue(StencilAttrib::SCF_greater_than_or_equal));
    PyDict_SetItemString(dict, "SCF_always", Dtool_WrapValue(StencilAttrib::SCF_always));
    PyDict_SetItemString(dict, "SCFAlways", Dtool_WrapValue(StencilAttrib::SCF_always));
    // enum StencilAttrib::StencilOperation;
    PyDict_SetItemString(dict, "SO_keep", Dtool_WrapValue(StencilAttrib::SO_keep));
    PyDict_SetItemString(dict, "SOKeep", Dtool_WrapValue(StencilAttrib::SO_keep));
    PyDict_SetItemString(dict, "SO_zero", Dtool_WrapValue(StencilAttrib::SO_zero));
    PyDict_SetItemString(dict, "SOZero", Dtool_WrapValue(StencilAttrib::SO_zero));
    PyDict_SetItemString(dict, "SO_replace", Dtool_WrapValue(StencilAttrib::SO_replace));
    PyDict_SetItemString(dict, "SOReplace", Dtool_WrapValue(StencilAttrib::SO_replace));
    PyDict_SetItemString(dict, "SO_increment", Dtool_WrapValue(StencilAttrib::SO_increment));
    PyDict_SetItemString(dict, "SOIncrement", Dtool_WrapValue(StencilAttrib::SO_increment));
    PyDict_SetItemString(dict, "SO_decrement", Dtool_WrapValue(StencilAttrib::SO_decrement));
    PyDict_SetItemString(dict, "SODecrement", Dtool_WrapValue(StencilAttrib::SO_decrement));
    PyDict_SetItemString(dict, "SO_invert", Dtool_WrapValue(StencilAttrib::SO_invert));
    PyDict_SetItemString(dict, "SOInvert", Dtool_WrapValue(StencilAttrib::SO_invert));
    PyDict_SetItemString(dict, "SO_increment_saturate", Dtool_WrapValue(StencilAttrib::SO_increment_saturate));
    PyDict_SetItemString(dict, "SOIncrementSaturate", Dtool_WrapValue(StencilAttrib::SO_increment_saturate));
    PyDict_SetItemString(dict, "SO_decrement_saturate", Dtool_WrapValue(StencilAttrib::SO_decrement_saturate));
    PyDict_SetItemString(dict, "SODecrementSaturate", Dtool_WrapValue(StencilAttrib::SO_decrement_saturate));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_StencilAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_StencilAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_StencilAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StencilAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StencilAttrib);
  }
}

/**
 * Python method tables for ShaderPool (ShaderPool)
 */
static PyMethodDef Dtool_Methods_ShaderPool[] = {
  {"has_shader", &Dtool_ShaderPool_has_shader_2093, METH_O | METH_STATIC, (const char *)Dtool_ShaderPool_has_shader_2093_comment},
  {"hasShader", &Dtool_ShaderPool_has_shader_2093, METH_O | METH_STATIC, (const char *)Dtool_ShaderPool_has_shader_2093_comment},
  {"verify_shader", &Dtool_ShaderPool_verify_shader_2094, METH_O | METH_STATIC, (const char *)Dtool_ShaderPool_verify_shader_2094_comment},
  {"verifyShader", &Dtool_ShaderPool_verify_shader_2094, METH_O | METH_STATIC, (const char *)Dtool_ShaderPool_verify_shader_2094_comment},
  {"load_shader", &Dtool_ShaderPool_load_shader_2095, METH_O | METH_STATIC, (const char *)Dtool_ShaderPool_load_shader_2095_comment},
  {"loadShader", &Dtool_ShaderPool_load_shader_2095, METH_O | METH_STATIC, (const char *)Dtool_ShaderPool_load_shader_2095_comment},
  {"add_shader", (PyCFunction) &Dtool_ShaderPool_add_shader_2096, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ShaderPool_add_shader_2096_comment},
  {"addShader", (PyCFunction) &Dtool_ShaderPool_add_shader_2096, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ShaderPool_add_shader_2096_comment},
  {"release_shader", &Dtool_ShaderPool_release_shader_2097, METH_O | METH_STATIC, (const char *)Dtool_ShaderPool_release_shader_2097_comment},
  {"releaseShader", &Dtool_ShaderPool_release_shader_2097, METH_O | METH_STATIC, (const char *)Dtool_ShaderPool_release_shader_2097_comment},
  {"release_all_shaders", &Dtool_ShaderPool_release_all_shaders_2098, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderPool_release_all_shaders_2098_comment},
  {"releaseAllShaders", &Dtool_ShaderPool_release_all_shaders_2098, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderPool_release_all_shaders_2098_comment},
  {"garbage_collect", &Dtool_ShaderPool_garbage_collect_2099, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderPool_garbage_collect_2099_comment},
  {"garbageCollect", &Dtool_ShaderPool_garbage_collect_2099, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderPool_garbage_collect_2099_comment},
  {"list_contents", &Dtool_ShaderPool_list_contents_2100, METH_O | METH_STATIC, (const char *)Dtool_ShaderPool_list_contents_2100_comment},
  {"listContents", &Dtool_ShaderPool_list_contents_2100, METH_O | METH_STATIC, (const char *)Dtool_ShaderPool_list_contents_2100_comment},
  {"write", &Dtool_ShaderPool_write_2101, METH_O | METH_STATIC, (const char *)Dtool_ShaderPool_write_2101_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     ShaderPool
//////////////////
static PyObject *Dtool_Str_ShaderPool(PyObject *self) {
  ShaderPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderPool, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ShaderPool = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ShaderPool = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ShaderPool",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderPool,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShaderPool,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ShaderPool,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the preferred interface for loading shaders for the TextNode\n"
    " * system.  It is similar to ModelPool and TexturePool in that it unifies\n"
    " * references to the same filename.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShaderPool,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShaderPool,
    PyType_GenericAlloc,
    Dtool_new_ShaderPool,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderPool,
  Dtool_UpcastInterface_ShaderPool,
  Dtool_DowncastInterface_ShaderPool,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShaderPool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ShaderPool._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShaderPool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderPool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderPool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderPool);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3pgraph_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    TransformState::init_type();
    TypeHandle handle = TransformState::get_class_type();
    Dtool_TransformState._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TransformState);
  }
  {
    RenderAttrib::init_type();
    TypeHandle handle = RenderAttrib::get_class_type();
    Dtool_RenderAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RenderAttrib);
  }
  {
    RenderModeAttrib::init_type();
    TypeHandle handle = RenderModeAttrib::get_class_type();
    Dtool_RenderModeAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RenderModeAttrib);
  }
  {
    TexMatrixAttrib::init_type();
    TypeHandle handle = TexMatrixAttrib::get_class_type();
    Dtool_TexMatrixAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TexMatrixAttrib);
  }
  {
    RenderState::init_type();
    TypeHandle handle = RenderState::get_class_type();
    Dtool_RenderState._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RenderState);
  }
  {
    AlphaTestAttrib::init_type();
    TypeHandle handle = AlphaTestAttrib::get_class_type();
    Dtool_AlphaTestAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AlphaTestAttrib);
  }
  {
    AntialiasAttrib::init_type();
    TypeHandle handle = AntialiasAttrib::get_class_type();
    Dtool_AntialiasAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AntialiasAttrib);
  }
  {
    RenderEffect::init_type();
    TypeHandle handle = RenderEffect::get_class_type();
    Dtool_RenderEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RenderEffect);
  }
  {
    RenderEffects::init_type();
    TypeHandle handle = RenderEffects::get_class_type();
    Dtool_RenderEffects._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RenderEffects);
  }
  {
    PandaNode::init_type();
    TypeHandle handle = PandaNode::get_class_type();
    Dtool_PandaNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PandaNode);
  }
  {
    TransparencyAttrib::init_type();
    TypeHandle handle = TransparencyAttrib::get_class_type();
    Dtool_TransparencyAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TransparencyAttrib);
  }
  {
    LogicOpAttrib::init_type();
    TypeHandle handle = LogicOpAttrib::get_class_type();
    Dtool_LogicOpAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LogicOpAttrib);
  }
  {
    NodePath::init_type();
    TypeHandle handle = NodePath::get_class_type();
    Dtool_NodePath._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_NodePath);
  }
  {
    AudioVolumeAttrib::init_type();
    TypeHandle handle = AudioVolumeAttrib::get_class_type();
    Dtool_AudioVolumeAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AudioVolumeAttrib);
  }
  {
    AuxBitplaneAttrib::init_type();
    TypeHandle handle = AuxBitplaneAttrib::get_class_type();
    Dtool_AuxBitplaneAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AuxBitplaneAttrib);
  }
  {
    AuxSceneData::init_type();
    TypeHandle handle = AuxSceneData::get_class_type();
    Dtool_AuxSceneData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AuxSceneData);
  }
  {
    BillboardEffect::init_type();
    TypeHandle handle = BillboardEffect::get_class_type();
    Dtool_BillboardEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BillboardEffect);
  }
  {
    LensNode::init_type();
    TypeHandle handle = LensNode::get_class_type();
    Dtool_LensNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LensNode);
  }
  {
    Camera::init_type();
    TypeHandle handle = Camera::get_class_type();
    Dtool_Camera._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Camera);
  }
  {
    PlaneNode::init_type();
    TypeHandle handle = PlaneNode::get_class_type();
    Dtool_PlaneNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PlaneNode);
  }
  {
    ClipPlaneAttrib::init_type();
    TypeHandle handle = ClipPlaneAttrib::get_class_type();
    Dtool_ClipPlaneAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ClipPlaneAttrib);
  }
  {
    ColorAttrib::init_type();
    TypeHandle handle = ColorAttrib::get_class_type();
    Dtool_ColorAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ColorAttrib);
  }
  {
    ColorBlendAttrib::init_type();
    TypeHandle handle = ColorBlendAttrib::get_class_type();
    Dtool_ColorBlendAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ColorBlendAttrib);
  }
  {
    ColorScaleAttrib::init_type();
    TypeHandle handle = ColorScaleAttrib::get_class_type();
    Dtool_ColorScaleAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ColorScaleAttrib);
  }
  {
    ColorWriteAttrib::init_type();
    TypeHandle handle = ColorWriteAttrib::get_class_type();
    Dtool_ColorWriteAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ColorWriteAttrib);
  }
  {
    CompassEffect::init_type();
    TypeHandle handle = CompassEffect::get_class_type();
    Dtool_CompassEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CompassEffect);
  }
  {
    GeomNode::init_type();
    TypeHandle handle = GeomNode::get_class_type();
    Dtool_GeomNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomNode);
  }
  {
    CullBinAttrib::init_type();
    TypeHandle handle = CullBinAttrib::get_class_type();
    Dtool_CullBinAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CullBinAttrib);
  }
  {
    CullFaceAttrib::init_type();
    TypeHandle handle = CullFaceAttrib::get_class_type();
    Dtool_CullFaceAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CullFaceAttrib);
  }
  {
    SceneSetup::init_type();
    TypeHandle handle = SceneSetup::get_class_type();
    Dtool_SceneSetup._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_SceneSetup);
  }
  {
    Fog::init_type();
    TypeHandle handle = Fog::get_class_type();
    Dtool_Fog._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Fog);
  }
  {
    FogAttrib::init_type();
    TypeHandle handle = FogAttrib::get_class_type();
    Dtool_FogAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_FogAttrib);
  }
  {
    CullTraverser::init_type();
    TypeHandle handle = CullTraverser::get_class_type();
    Dtool_CullTraverser._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CullTraverser);
  }
  {
    GeomDrawCallbackData::init_type();
    TypeHandle handle = GeomDrawCallbackData::get_class_type();
    Dtool_GeomDrawCallbackData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomDrawCallbackData);
  }
  {
    RescaleNormalAttrib::init_type();
    TypeHandle handle = RescaleNormalAttrib::get_class_type();
    Dtool_RescaleNormalAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RescaleNormalAttrib);
  }
  {
    CullResult::init_type();
    TypeHandle handle = CullResult::get_class_type();
    Dtool_CullResult._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CullResult);
  }
  {
    DecalEffect::init_type();
    TypeHandle handle = DecalEffect::get_class_type();
    Dtool_DecalEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DecalEffect);
  }
  {
    DepthOffsetAttrib::init_type();
    TypeHandle handle = DepthOffsetAttrib::get_class_type();
    Dtool_DepthOffsetAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DepthOffsetAttrib);
  }
  {
    DepthTestAttrib::init_type();
    TypeHandle handle = DepthTestAttrib::get_class_type();
    Dtool_DepthTestAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DepthTestAttrib);
  }
  {
    DepthWriteAttrib::init_type();
    TypeHandle handle = DepthWriteAttrib::get_class_type();
    Dtool_DepthWriteAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DepthWriteAttrib);
  }
  {
    Light::init_type();
    TypeHandle handle = Light::get_class_type();
    Dtool_Light._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Light);
  }
  {
    LightAttrib::init_type();
    TypeHandle handle = LightAttrib::get_class_type();
    Dtool_LightAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LightAttrib);
  }
  {
    LightRampAttrib::init_type();
    TypeHandle handle = LightRampAttrib::get_class_type();
    Dtool_LightRampAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LightRampAttrib);
  }
  {
    Loader::init_type();
    TypeHandle handle = Loader::get_class_type();
    Dtool_Loader._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Loader);
  }
  {
    LoaderFileType::init_type();
    TypeHandle handle = LoaderFileType::get_class_type();
    Dtool_LoaderFileType._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LoaderFileType);
  }
  {
    MaterialAttrib::init_type();
    TypeHandle handle = MaterialAttrib::get_class_type();
    Dtool_MaterialAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MaterialAttrib);
  }
  {
    ModelFlattenRequest::init_type();
    TypeHandle handle = ModelFlattenRequest::get_class_type();
    Dtool_ModelFlattenRequest._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ModelFlattenRequest);
  }
  {
    ModelLoadRequest::init_type();
    TypeHandle handle = ModelLoadRequest::get_class_type();
    Dtool_ModelLoadRequest._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ModelLoadRequest);
  }
  {
    ModelNode::init_type();
    TypeHandle handle = ModelNode::get_class_type();
    Dtool_ModelNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ModelNode);
  }
  {
    ModelRoot::init_type();
    TypeHandle handle = ModelRoot::get_class_type();
    Dtool_ModelRoot._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ModelRoot);
  }
  {
    ModelSaveRequest::init_type();
    TypeHandle handle = ModelSaveRequest::get_class_type();
    Dtool_ModelSaveRequest._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ModelSaveRequest);
  }
  {
    TextureAttrib::init_type();
    TypeHandle handle = TextureAttrib::get_class_type();
    Dtool_TextureAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TextureAttrib);
  }
  {
    TexGenAttrib::init_type();
    TypeHandle handle = TexGenAttrib::get_class_type();
    Dtool_TexGenAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TexGenAttrib);
  }
  {
    OccluderNode::init_type();
    TypeHandle handle = OccluderNode::get_class_type();
    Dtool_OccluderNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OccluderNode);
  }
  {
    OccluderEffect::init_type();
    TypeHandle handle = OccluderEffect::get_class_type();
    Dtool_OccluderEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OccluderEffect);
  }
  {
    PolylightNode::init_type();
    TypeHandle handle = PolylightNode::get_class_type();
    Dtool_PolylightNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PolylightNode);
  }
  {
    PolylightEffect::init_type();
    TypeHandle handle = PolylightEffect::get_class_type();
    Dtool_PolylightEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PolylightEffect);
  }
  {
    ShaderAttrib::init_type();
    TypeHandle handle = ShaderAttrib::get_class_type();
    Dtool_ShaderAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ShaderAttrib);
  }
  {
    ShowBoundsEffect::init_type();
    TypeHandle handle = ShowBoundsEffect::get_class_type();
    Dtool_ShowBoundsEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ShowBoundsEffect);
  }
  {
    TexProjectorEffect::init_type();
    TypeHandle handle = TexProjectorEffect::get_class_type();
    Dtool_TexProjectorEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TexProjectorEffect);
  }
  {
    ScissorEffect::init_type();
    TypeHandle handle = ScissorEffect::get_class_type();
    Dtool_ScissorEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ScissorEffect);
  }
  {
    ParamNodePath::init_type();
    TypeHandle handle = ParamNodePath::get_class_type();
    Dtool_ParamNodePath._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamNodePath);
  }
  {
    PortalNode::init_type();
    TypeHandle handle = PortalNode::get_class_type();
    Dtool_PortalNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PortalNode);
  }
  {
    ScissorAttrib::init_type();
    TypeHandle handle = ScissorAttrib::get_class_type();
    Dtool_ScissorAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ScissorAttrib);
  }
  {
    ShadeModelAttrib::init_type();
    TypeHandle handle = ShadeModelAttrib::get_class_type();
    Dtool_ShadeModelAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ShadeModelAttrib);
  }
  {
    StencilAttrib::init_type();
    TypeHandle handle = StencilAttrib::get_class_type();
    Dtool_StencilAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_StencilAttrib);
  }
}

void Dtool_libp3pgraph_BuildInstants(PyObject *module) {
  (void) module;
  // TransformState
  Dtool_PyModuleClassInit_TransformState(module);
  PyModule_AddObject(module, "TransformState", (PyObject *)&Dtool_TransformState);
  // RenderAttribRegistry
  Dtool_PyModuleClassInit_RenderAttribRegistry(module);
  PyModule_AddObject(module, "RenderAttribRegistry", (PyObject *)&Dtool_RenderAttribRegistry);
  // RenderAttrib
  Dtool_PyModuleClassInit_RenderAttrib(module);
  PyModule_AddObject(module, "RenderAttrib", (PyObject *)&Dtool_RenderAttrib);
  // RenderModeAttrib
  Dtool_PyModuleClassInit_RenderModeAttrib(module);
  PyModule_AddObject(module, "RenderModeAttrib", (PyObject *)&Dtool_RenderModeAttrib);
  // TexMatrixAttrib
  Dtool_PyModuleClassInit_TexMatrixAttrib(module);
  PyModule_AddObject(module, "TexMatrixAttrib", (PyObject *)&Dtool_TexMatrixAttrib);
  // RenderState
  Dtool_PyModuleClassInit_RenderState(module);
  PyModule_AddObject(module, "RenderState", (PyObject *)&Dtool_RenderState);
  // AlphaTestAttrib
  Dtool_PyModuleClassInit_AlphaTestAttrib(module);
  PyModule_AddObject(module, "AlphaTestAttrib", (PyObject *)&Dtool_AlphaTestAttrib);
  // AntialiasAttrib
  Dtool_PyModuleClassInit_AntialiasAttrib(module);
  PyModule_AddObject(module, "AntialiasAttrib", (PyObject *)&Dtool_AntialiasAttrib);
  // RenderEffect
  Dtool_PyModuleClassInit_RenderEffect(module);
  PyModule_AddObject(module, "RenderEffect", (PyObject *)&Dtool_RenderEffect);
  // RenderEffects
  Dtool_PyModuleClassInit_RenderEffects(module);
  PyModule_AddObject(module, "RenderEffects", (PyObject *)&Dtool_RenderEffects);
  // PandaNode
  Dtool_PyModuleClassInit_PandaNode(module);
  PyModule_AddObject(module, "PandaNode", (PyObject *)&Dtool_PandaNode);
  // TransparencyAttrib
  Dtool_PyModuleClassInit_TransparencyAttrib(module);
  PyModule_AddObject(module, "TransparencyAttrib", (PyObject *)&Dtool_TransparencyAttrib);
  // LogicOpAttrib
  Dtool_PyModuleClassInit_LogicOpAttrib(module);
  PyModule_AddObject(module, "LogicOpAttrib", (PyObject *)&Dtool_LogicOpAttrib);
  // ShaderInput
  Dtool_PyModuleClassInit_ShaderInput(module);
  PyModule_AddObject(module, "ShaderInput", (PyObject *)&Dtool_ShaderInput);
  // InternalNameCollection
  Dtool_PyModuleClassInit_InternalNameCollection(module);
  PyModule_AddObject(module, "InternalNameCollection", (PyObject *)&Dtool_InternalNameCollection);
  // MaterialCollection
  Dtool_PyModuleClassInit_MaterialCollection(module);
  PyModule_AddObject(module, "MaterialCollection", (PyObject *)&Dtool_MaterialCollection);
  // TextureStageCollection
  Dtool_PyModuleClassInit_TextureStageCollection(module);
  PyModule_AddObject(module, "TextureStageCollection", (PyObject *)&Dtool_TextureStageCollection);
  // NodePath
  Dtool_PyModuleClassInit_NodePath(module);
  PyModule_AddObject(module, "NodePath", (PyObject *)&Dtool_NodePath);
  // NodePathCollection
  Dtool_PyModuleClassInit_NodePathCollection(module);
  PyModule_AddObject(module, "NodePathCollection", (PyObject *)&Dtool_NodePathCollection);
  // AttribNodeRegistry
  Dtool_PyModuleClassInit_AttribNodeRegistry(module);
  PyModule_AddObject(module, "AttribNodeRegistry", (PyObject *)&Dtool_AttribNodeRegistry);
  // AudioVolumeAttrib
  Dtool_PyModuleClassInit_AudioVolumeAttrib(module);
  PyModule_AddObject(module, "AudioVolumeAttrib", (PyObject *)&Dtool_AudioVolumeAttrib);
  // AuxBitplaneAttrib
  Dtool_PyModuleClassInit_AuxBitplaneAttrib(module);
  PyModule_AddObject(module, "AuxBitplaneAttrib", (PyObject *)&Dtool_AuxBitplaneAttrib);
  // AuxSceneData
  Dtool_PyModuleClassInit_AuxSceneData(module);
  PyModule_AddObject(module, "AuxSceneData", (PyObject *)&Dtool_AuxSceneData);
  // BamFile
  Dtool_PyModuleClassInit_BamFile(module);
  PyModule_AddObject(module, "BamFile", (PyObject *)&Dtool_BamFile);
  // BillboardEffect
  Dtool_PyModuleClassInit_BillboardEffect(module);
  PyModule_AddObject(module, "BillboardEffect", (PyObject *)&Dtool_BillboardEffect);
  // LensNode
  Dtool_PyModuleClassInit_LensNode(module);
  PyModule_AddObject(module, "LensNode", (PyObject *)&Dtool_LensNode);
  // WeakNodePath
  Dtool_PyModuleClassInit_WeakNodePath(module);
  PyModule_AddObject(module, "WeakNodePath", (PyObject *)&Dtool_WeakNodePath);
  // Camera
  Dtool_PyModuleClassInit_Camera(module);
  PyModule_AddObject(module, "Camera", (PyObject *)&Dtool_Camera);
  // PlaneNode
  Dtool_PyModuleClassInit_PlaneNode(module);
  PyModule_AddObject(module, "PlaneNode", (PyObject *)&Dtool_PlaneNode);
  // ClipPlaneAttrib
  Dtool_PyModuleClassInit_ClipPlaneAttrib(module);
  PyModule_AddObject(module, "ClipPlaneAttrib", (PyObject *)&Dtool_ClipPlaneAttrib);
  // ColorAttrib
  Dtool_PyModuleClassInit_ColorAttrib(module);
  PyModule_AddObject(module, "ColorAttrib", (PyObject *)&Dtool_ColorAttrib);
  // ColorBlendAttrib
  Dtool_PyModuleClassInit_ColorBlendAttrib(module);
  PyModule_AddObject(module, "ColorBlendAttrib", (PyObject *)&Dtool_ColorBlendAttrib);
  // ColorScaleAttrib
  Dtool_PyModuleClassInit_ColorScaleAttrib(module);
  PyModule_AddObject(module, "ColorScaleAttrib", (PyObject *)&Dtool_ColorScaleAttrib);
  // ColorWriteAttrib
  Dtool_PyModuleClassInit_ColorWriteAttrib(module);
  PyModule_AddObject(module, "ColorWriteAttrib", (PyObject *)&Dtool_ColorWriteAttrib);
  // CompassEffect
  Dtool_PyModuleClassInit_CompassEffect(module);
  PyModule_AddObject(module, "CompassEffect", (PyObject *)&Dtool_CompassEffect);
  // CullBinEnums
  Dtool_PyModuleClassInit_CullBinEnums(module);
  PyModule_AddObject(module, "CullBinEnums", (PyObject *)&Dtool_CullBinEnums);
  // GeomNode
  Dtool_PyModuleClassInit_GeomNode(module);
  PyModule_AddObject(module, "GeomNode", (PyObject *)&Dtool_GeomNode);
  // CullBinAttrib
  Dtool_PyModuleClassInit_CullBinAttrib(module);
  PyModule_AddObject(module, "CullBinAttrib", (PyObject *)&Dtool_CullBinAttrib);
  // CullBinManager
  Dtool_PyModuleClassInit_CullBinManager(module);
  PyModule_AddObject(module, "CullBinManager", (PyObject *)&Dtool_CullBinManager);
  // CullFaceAttrib
  Dtool_PyModuleClassInit_CullFaceAttrib(module);
  PyModule_AddObject(module, "CullFaceAttrib", (PyObject *)&Dtool_CullFaceAttrib);
  // WorkingNodePath
  Dtool_PyModuleClassInit_WorkingNodePath(module);
  PyModule_AddObject(module, "WorkingNodePath", (PyObject *)&Dtool_WorkingNodePath);
  // CullTraverserData
  Dtool_PyModuleClassInit_CullTraverserData(module);
  PyModule_AddObject(module, "CullTraverserData", (PyObject *)&Dtool_CullTraverserData);
  // SceneSetup
  Dtool_PyModuleClassInit_SceneSetup(module);
  PyModule_AddObject(module, "SceneSetup", (PyObject *)&Dtool_SceneSetup);
  // Fog
  Dtool_PyModuleClassInit_Fog(module);
  PyModule_AddObject(module, "Fog", (PyObject *)&Dtool_Fog);
  // FogAttrib
  Dtool_PyModuleClassInit_FogAttrib(module);
  PyModule_AddObject(module, "FogAttrib", (PyObject *)&Dtool_FogAttrib);
  // CullTraverser
  Dtool_PyModuleClassInit_CullTraverser(module);
  PyModule_AddObject(module, "CullTraverser", (PyObject *)&Dtool_CullTraverser);
  // GeomDrawCallbackData
  Dtool_PyModuleClassInit_GeomDrawCallbackData(module);
  PyModule_AddObject(module, "GeomDrawCallbackData", (PyObject *)&Dtool_GeomDrawCallbackData);
  // RescaleNormalAttrib
  Dtool_PyModuleClassInit_RescaleNormalAttrib(module);
  PyModule_AddObject(module, "RescaleNormalAttrib", (PyObject *)&Dtool_RescaleNormalAttrib);
  // CullResult
  Dtool_PyModuleClassInit_CullResult(module);
  PyModule_AddObject(module, "CullResult", (PyObject *)&Dtool_CullResult);
  // DecalEffect
  Dtool_PyModuleClassInit_DecalEffect(module);
  PyModule_AddObject(module, "DecalEffect", (PyObject *)&Dtool_DecalEffect);
  // DepthOffsetAttrib
  Dtool_PyModuleClassInit_DepthOffsetAttrib(module);
  PyModule_AddObject(module, "DepthOffsetAttrib", (PyObject *)&Dtool_DepthOffsetAttrib);
  // DepthTestAttrib
  Dtool_PyModuleClassInit_DepthTestAttrib(module);
  PyModule_AddObject(module, "DepthTestAttrib", (PyObject *)&Dtool_DepthTestAttrib);
  // DepthWriteAttrib
  Dtool_PyModuleClassInit_DepthWriteAttrib(module);
  PyModule_AddObject(module, "DepthWriteAttrib", (PyObject *)&Dtool_DepthWriteAttrib);
  // Light
  Dtool_PyModuleClassInit_Light(module);
  PyModule_AddObject(module, "Light", (PyObject *)&Dtool_Light);
  // LightAttrib
  Dtool_PyModuleClassInit_LightAttrib(module);
  PyModule_AddObject(module, "LightAttrib", (PyObject *)&Dtool_LightAttrib);
  // LightRampAttrib
  Dtool_PyModuleClassInit_LightRampAttrib(module);
  PyModule_AddObject(module, "LightRampAttrib", (PyObject *)&Dtool_LightRampAttrib);
  // Loader
  Dtool_PyModuleClassInit_Loader(module);
  PyModule_AddObject(module, "Loader", (PyObject *)&Dtool_Loader);
  // LoaderFileType
  Dtool_PyModuleClassInit_LoaderFileType(module);
  PyModule_AddObject(module, "LoaderFileType", (PyObject *)&Dtool_LoaderFileType);
  // LoaderFileTypeRegistry
  Dtool_PyModuleClassInit_LoaderFileTypeRegistry(module);
  PyModule_AddObject(module, "LoaderFileTypeRegistry", (PyObject *)&Dtool_LoaderFileTypeRegistry);
  // MaterialAttrib
  Dtool_PyModuleClassInit_MaterialAttrib(module);
  PyModule_AddObject(module, "MaterialAttrib", (PyObject *)&Dtool_MaterialAttrib);
  // ModelFlattenRequest
  Dtool_PyModuleClassInit_ModelFlattenRequest(module);
  PyModule_AddObject(module, "ModelFlattenRequest", (PyObject *)&Dtool_ModelFlattenRequest);
  // ModelLoadRequest
  Dtool_PyModuleClassInit_ModelLoadRequest(module);
  PyModule_AddObject(module, "ModelLoadRequest", (PyObject *)&Dtool_ModelLoadRequest);
  // ModelNode
  Dtool_PyModuleClassInit_ModelNode(module);
  PyModule_AddObject(module, "ModelNode", (PyObject *)&Dtool_ModelNode);
  // ModelRoot
  Dtool_PyModuleClassInit_ModelRoot(module);
  PyModule_AddObject(module, "ModelRoot", (PyObject *)&Dtool_ModelRoot);
  // ModelPool
  Dtool_PyModuleClassInit_ModelPool(module);
  PyModule_AddObject(module, "ModelPool", (PyObject *)&Dtool_ModelPool);
  // ModelSaveRequest
  Dtool_PyModuleClassInit_ModelSaveRequest(module);
  PyModule_AddObject(module, "ModelSaveRequest", (PyObject *)&Dtool_ModelSaveRequest);
  // TextureAttrib
  Dtool_PyModuleClassInit_TextureAttrib(module);
  PyModule_AddObject(module, "TextureAttrib", (PyObject *)&Dtool_TextureAttrib);
  // TexGenAttrib
  Dtool_PyModuleClassInit_TexGenAttrib(module);
  PyModule_AddObject(module, "TexGenAttrib", (PyObject *)&Dtool_TexGenAttrib);
  // OccluderNode
  Dtool_PyModuleClassInit_OccluderNode(module);
  PyModule_AddObject(module, "OccluderNode", (PyObject *)&Dtool_OccluderNode);
  // OccluderEffect
  Dtool_PyModuleClassInit_OccluderEffect(module);
  PyModule_AddObject(module, "OccluderEffect", (PyObject *)&Dtool_OccluderEffect);
  // PolylightNode
  Dtool_PyModuleClassInit_PolylightNode(module);
  PyModule_AddObject(module, "PolylightNode", (PyObject *)&Dtool_PolylightNode);
  // PolylightEffect
  Dtool_PyModuleClassInit_PolylightEffect(module);
  PyModule_AddObject(module, "PolylightEffect", (PyObject *)&Dtool_PolylightEffect);
  // ShaderAttrib
  Dtool_PyModuleClassInit_ShaderAttrib(module);
  PyModule_AddObject(module, "ShaderAttrib", (PyObject *)&Dtool_ShaderAttrib);
  // ShowBoundsEffect
  Dtool_PyModuleClassInit_ShowBoundsEffect(module);
  PyModule_AddObject(module, "ShowBoundsEffect", (PyObject *)&Dtool_ShowBoundsEffect);
  // TexProjectorEffect
  Dtool_PyModuleClassInit_TexProjectorEffect(module);
  PyModule_AddObject(module, "TexProjectorEffect", (PyObject *)&Dtool_TexProjectorEffect);
  // ScissorEffect
  Dtool_PyModuleClassInit_ScissorEffect(module);
  PyModule_AddObject(module, "ScissorEffect", (PyObject *)&Dtool_ScissorEffect);
  // SceneGraphReducer
  Dtool_PyModuleClassInit_SceneGraphReducer(module);
  PyModule_AddObject(module, "SceneGraphReducer", (PyObject *)&Dtool_SceneGraphReducer);
  // ParamNodePath
  Dtool_PyModuleClassInit_ParamNodePath(module);
  PyModule_AddObject(module, "ParamNodePath", (PyObject *)&Dtool_ParamNodePath);
  // PortalNode
  Dtool_PyModuleClassInit_PortalNode(module);
  PyModule_AddObject(module, "PortalNode", (PyObject *)&Dtool_PortalNode);
  // ScissorAttrib
  Dtool_PyModuleClassInit_ScissorAttrib(module);
  PyModule_AddObject(module, "ScissorAttrib", (PyObject *)&Dtool_ScissorAttrib);
  // ShadeModelAttrib
  Dtool_PyModuleClassInit_ShadeModelAttrib(module);
  PyModule_AddObject(module, "ShadeModelAttrib", (PyObject *)&Dtool_ShadeModelAttrib);
  // StencilAttrib
  Dtool_PyModuleClassInit_StencilAttrib(module);
  PyModule_AddObject(module, "StencilAttrib", (PyObject *)&Dtool_StencilAttrib);
  // ShaderPool
  Dtool_PyModuleClassInit_ShaderPool(module);
  PyModule_AddObject(module, "ShaderPool", (PyObject *)&Dtool_ShaderPool);
}

static PyMethodDef python_simple_funcs[] = {
  {"py_decode_NodePath_from_bam_stream", &Dtool_py_decode_NodePath_from_bam_stream_2011, METH_O, (const char *)Dtool_py_decode_NodePath_from_bam_stream_2011_comment},
  {"pyDecodeNodePathFromBamStream", &Dtool_py_decode_NodePath_from_bam_stream_2011, METH_O, (const char *)Dtool_py_decode_NodePath_from_bam_stream_2011_comment},
  {"py_decode_NodePath_from_bam_stream_persist", (PyCFunction) &Dtool_py_decode_NodePath_from_bam_stream_persist_2012, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_py_decode_NodePath_from_bam_stream_persist_2012_comment},
  {"pyDecodeNodePathFromBamStreamPersist", (PyCFunction) &Dtool_py_decode_NodePath_from_bam_stream_persist_2012, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_py_decode_NodePath_from_bam_stream_persist_2012_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3pgraph_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3pgraph_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613360,  /* file_identifier */
  "libp3pgraph",  /* library_name */
  "w0Cq",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3pgraph.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  4320  /* next_index */
};

Configure(_in_configure_libp3pgraph);
ConfigureFn(_in_configure_libp3pgraph) {
  interrogate_request_module(&_in_module_def);
}

