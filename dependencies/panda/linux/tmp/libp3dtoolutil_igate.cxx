/*
 * This file was generated by:
 * built/bin/interrogate -srcdir dtool/src/dtoolutil -Idtool/src/dtoolutil -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3dtoolutil_igate.cxx -od built/pandac/input/libp3dtoolutil.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Idtool/src/dtoolutil -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3dtoolutil p3dtoolutil_composite1.cxx p3dtoolutil_composite2.cxx p3dtoolutil_ext_composite.cxx config_dtoolutil.h pandaSystem.h dSearchPath.h executionEnvironment.h textEncoder.h textEncoder_ext.h filename.h filename_ext.h globPattern.h globPattern_ext.h pandaFileStream.h lineStream.h iostream_ext.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "config_dtoolutil.h"
#include "dSearchPath.h"
#include "executionEnvironment.h"
#include "filename.h"
#include "filename_ext.h"
#include "globPattern.h"
#include "globPattern_ext.h"
#include "iostream_ext.h"
#include "lineStream.h"
#include "pandaFileStream.h"
#include "pandaSystem.h"
#include "textEncoder.h"
#include "textEncoder_ext.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class std_basic_ios_char
 */
typedef std::basic_ios< char > std_basic_ios_char_localtype;
Define_Module_Class(panda3d.core, std_basic_ios_char, std_basic_ios_char_localtype, basic_ios_char);
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_basic_ios_char = &Dtool_std_basic_ios_char;
static void Dtool_PyModuleClassInit_std_basic_ios_char(PyObject *module);

/**
 * Forward declarations for top-level class std_ios_base
 */
typedef std::ios_base std_ios_base_localtype;
Define_Module_Class(panda3d.core, std_ios_base, std_ios_base_localtype, ios_base);
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ios_base = &Dtool_std_ios_base;
static void Dtool_PyModuleClassInit_std_ios_base(PyObject *module);

/**
 * Forward declarations for top-level class std_fstream
 */
typedef std::fstream std_fstream_localtype;
Define_Module_Class(panda3d.core, std_fstream, std_fstream_localtype, fstream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_fstream = &Dtool_std_fstream;
static void Dtool_PyModuleClassInit_std_fstream(PyObject *module);

/**
 * Forward declarations for top-level class std_iostream
 */
typedef std::iostream std_iostream_localtype;
Define_Module_Class(panda3d.core, std_iostream, std_iostream_localtype, iostream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_iostream = &Dtool_std_iostream;
static void Dtool_PyModuleClassInit_std_iostream(PyObject *module);

/**
 * Forward declarations for top-level class std_istream
 */
typedef std::istream std_istream_localtype;
Define_Module_Class(panda3d.core, std_istream, std_istream_localtype, istream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_istream = &Dtool_std_istream;
static void Dtool_PyModuleClassInit_std_istream(PyObject *module);

/**
 * Forward declarations for top-level class std_ostream
 */
typedef std::ostream std_ostream_localtype;
Define_Module_Class(panda3d.core, std_ostream, std_ostream_localtype, ostream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
static void Dtool_PyModuleClassInit_std_ostream(PyObject *module);

/**
 * Forward declarations for top-level class std_ifstream
 */
typedef std::ifstream std_ifstream_localtype;
Define_Module_Class(panda3d.core, std_ifstream, std_ifstream_localtype, ifstream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ifstream = &Dtool_std_ifstream;
static void Dtool_PyModuleClassInit_std_ifstream(PyObject *module);

/**
 * Forward declarations for top-level class std_ofstream
 */
typedef std::ofstream std_ofstream_localtype;
Define_Module_Class(panda3d.core, std_ofstream, std_ofstream_localtype, ofstream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ofstream = &Dtool_std_ofstream;
static void Dtool_PyModuleClassInit_std_ofstream(PyObject *module);

/**
 * Forward declarations for top-level class IFileStream
 */
typedef IFileStream IFileStream_localtype;
Define_Module_Class(panda3d.core, IFileStream, IFileStream_localtype, IFileStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IFileStream = &Dtool_IFileStream;
static void Dtool_PyModuleClassInit_IFileStream(PyObject *module);

/**
 * Forward declarations for top-level class OFileStream
 */
typedef OFileStream OFileStream_localtype;
Define_Module_Class(panda3d.core, OFileStream, OFileStream_localtype, OFileStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OFileStream = &Dtool_OFileStream;
static void Dtool_PyModuleClassInit_OFileStream(PyObject *module);

/**
 * Forward declarations for top-level class FileStream
 */
typedef FileStream FileStream_localtype;
Define_Module_Class(panda3d.core, FileStream, FileStream_localtype, FileStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FileStream = &Dtool_FileStream;
static void Dtool_PyModuleClassInit_FileStream(PyObject *module);

/**
 * Forward declarations for top-level class TextEncoder
 */
typedef TextEncoder TextEncoder_localtype;
Define_Module_Class(panda3d.core, TextEncoder, TextEncoder_localtype, TextEncoder);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextEncoder = &Dtool_TextEncoder;
static void Dtool_PyModuleClassInit_TextEncoder(PyObject *module);

/**
 * Forward declarations for top-level class Filename
 */
typedef Filename Filename_localtype;
Define_Module_Class(panda3d.core, Filename, Filename_localtype, Filename);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
static void Dtool_PyModuleClassInit_Filename(PyObject *module);
Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);

/**
 * Forward declarations for top-level class PandaSystem
 */
typedef PandaSystem PandaSystem_localtype;
Define_Module_Class_Private(panda3d.core, PandaSystem, PandaSystem_localtype, PandaSystem);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaSystem = &Dtool_PandaSystem;
static void Dtool_PyModuleClassInit_PandaSystem(PyObject *module);

/**
 * Forward declarations for top-level class DSearchPath
 */
typedef DSearchPath DSearchPath_localtype;
Define_Module_Class(panda3d.core, DSearchPath, DSearchPath_localtype, DSearchPath);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DSearchPath = &Dtool_DSearchPath;
static void Dtool_PyModuleClassInit_DSearchPath(PyObject *module);
DSearchPath *Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath &coerced);

/**
 * Forward declarations for top-level class DSearchPath_Results
 */
typedef DSearchPath::Results DSearchPath_Results_localtype;
Define_Module_Class(panda3d.core, DSearchPath_Results, DSearchPath_Results_localtype, Results);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DSearchPath_Results = &Dtool_DSearchPath_Results;
static void Dtool_PyModuleClassInit_DSearchPath_Results(PyObject *module);

/**
 * Forward declarations for top-level class ExecutionEnvironment
 */
typedef ExecutionEnvironment ExecutionEnvironment_localtype;
Define_Module_Class(panda3d.core, ExecutionEnvironment, ExecutionEnvironment_localtype, ExecutionEnvironment);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ExecutionEnvironment = &Dtool_ExecutionEnvironment;
static void Dtool_PyModuleClassInit_ExecutionEnvironment(PyObject *module);

/**
 * Forward declarations for top-level class GlobPattern
 */
typedef GlobPattern GlobPattern_localtype;
Define_Module_Class(panda3d.core, GlobPattern, GlobPattern_localtype, GlobPattern);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GlobPattern = &Dtool_GlobPattern;
static void Dtool_PyModuleClassInit_GlobPattern(PyObject *module);
GlobPattern *Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern &coerced);

/**
 * Forward declarations for top-level class LineStream
 */
typedef LineStream LineStream_localtype;
Define_Module_Class(panda3d.core, LineStream, LineStream_localtype, LineStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LineStream = &Dtool_LineStream;
static void Dtool_PyModuleClassInit_LineStream(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"std::basic_ios< char >", &Dtool_std_basic_ios_char},
  {"std::ios_base", &Dtool_std_ios_base},
  {"std::fstream", &Dtool_std_fstream},
  {"std::iostream", &Dtool_std_iostream},
  {"std::istream", &Dtool_std_istream},
  {"std::ostream", &Dtool_std_ostream},
  {"std::ifstream", &Dtool_std_ifstream},
  {"std::ofstream", &Dtool_std_ofstream},
  {"IFileStream", &Dtool_IFileStream},
  {"OFileStream", &Dtool_OFileStream},
  {"FileStream", &Dtool_FileStream},
  {"TextEncoder", &Dtool_TextEncoder},
  {"Filename", &Dtool_Filename},
  {"PandaSystem", &Dtool_PandaSystem},
  {"DSearchPath", &Dtool_DSearchPath},
  {"DSearchPath::Results", &Dtool_DSearchPath_Results},
  {"ExecutionEnvironment", &Dtool_ExecutionEnvironment},
  {"GlobPattern", &Dtool_GlobPattern},
  {"LineStream", &Dtool_LineStream},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[0].type)
  {nullptr, nullptr},
};
#endif

// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class std::basic_ios< char >
 */
/**
 * Python function wrapper for:
 * bool std::basic_ios< char >::good(void) const
 */
static PyObject *Dtool_std_basic_ios_char_good_7(PyObject *self, PyObject *) {
  std::basic_ios< char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_std_basic_ios_char)) {
    return nullptr;
  }
  // 1-bool std::basic_ios< char >::good(void) const
  bool return_value = ((*(const std::basic_ios< char >*)local_this).good)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_std_basic_ios_char_good_7_comment =
  "C++ Interface:\n"
  "good(basic_ios self)\n";
#else
static const char *Dtool_std_basic_ios_char_good_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool std::basic_ios< char >::eof(void) const
 */
static PyObject *Dtool_std_basic_ios_char_eof_8(PyObject *self, PyObject *) {
  std::basic_ios< char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_std_basic_ios_char)) {
    return nullptr;
  }
  // 1-bool std::basic_ios< char >::eof(void) const
  bool return_value = ((*(const std::basic_ios< char >*)local_this).eof)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_std_basic_ios_char_eof_8_comment =
  "C++ Interface:\n"
  "eof(basic_ios self)\n";
#else
static const char *Dtool_std_basic_ios_char_eof_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool std::basic_ios< char >::fail(void) const
 */
static PyObject *Dtool_std_basic_ios_char_fail_9(PyObject *self, PyObject *) {
  std::basic_ios< char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_std_basic_ios_char)) {
    return nullptr;
  }
  // 1-bool std::basic_ios< char >::fail(void) const
  bool return_value = ((*(const std::basic_ios< char >*)local_this).fail)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_std_basic_ios_char_fail_9_comment =
  "C++ Interface:\n"
  "fail(basic_ios self)\n";
#else
static const char *Dtool_std_basic_ios_char_fail_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool std::basic_ios< char >::bad(void) const
 */
static PyObject *Dtool_std_basic_ios_char_bad_10(PyObject *self, PyObject *) {
  std::basic_ios< char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_std_basic_ios_char)) {
    return nullptr;
  }
  // 1-bool std::basic_ios< char >::bad(void) const
  bool return_value = ((*(const std::basic_ios< char >*)local_this).bad)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_std_basic_ios_char_bad_10_comment =
  "C++ Interface:\n"
  "bad(basic_ios self)\n";
#else
static const char *Dtool_std_basic_ios_char_bad_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void std::basic_ios< char >::clear(void)
 */
static PyObject *Dtool_std_basic_ios_char_clear_11(PyObject *self, PyObject *) {
  std::basic_ios< char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_basic_ios_char, (void **)&local_this, "std::basic_ios_char.clear")) {
    return nullptr;
  }
  // 1-void std::basic_ios< char >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_std_basic_ios_char_clear_11_comment =
  "C++ Interface:\n"
  "clear(const basic_ios self)\n";
#else
static const char *Dtool_std_basic_ios_char_clear_11_comment = nullptr;
#endif

static int Dtool_Init_std_basic_ios_char(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_std_basic_ios_char(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_std_basic_ios_char) {
    printf("std_basic_ios_char ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  std::basic_ios< char > *local_this = (std::basic_ios< char > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_std_basic_ios_char) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_std_basic_ios_char(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_std_basic_ios_char) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_ios_base) {
    std::ios_base* other_this = (std::ios_base*)from_this;
    return (std::basic_ios< char >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class std::ios_base
 */
static int Dtool_Init_std_ios_base(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_std_ios_base(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_std_ios_base) {
    printf("std_ios_base ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  std::ios_base *local_this = (std::ios_base *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_std_ios_base) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_std_ios_base(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_std_ios_base) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class std::fstream
 */
/**
 * Python function wrapper for:
 * void std::fstream::close(void)
 */
static PyObject *Dtool_std_fstream_close_44(PyObject *self, PyObject *) {
  std::fstream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_fstream, (void **)&local_this, "std::fstream.close")) {
    return nullptr;
  }
  // 1-void std::fstream::close(void)
  ((*local_this).close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_std_fstream_close_44_comment =
  "C++ Interface:\n"
  "close(const fstream self)\n";
#else
static const char *Dtool_std_fstream_close_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::fstream::fstream(void)
 */
static int Dtool_Init_std_fstream(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("fstream() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "fstream() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-std::fstream::fstream(void)
  std::fstream *return_value = new std::fstream();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_std_fstream, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "fstream()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_std_fstream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_std_fstream) {
    printf("std_fstream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  std::fstream *local_this = (std::fstream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_std_fstream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_iostream) {
    return (std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_istream) {
    return (std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ostream) {
    return (std::ostream *)(std::iostream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_std_fstream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_std_fstream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_iostream) {
    std::iostream* other_this = (std::iostream*)from_this;
    return (std::fstream*)other_this;
  }
  if (from_type == Dtool_Ptr_std_istream) {
    std::istream* other_this = (std::istream*)from_this;
    return (std::fstream*)other_this;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    std::ostream* other_this = (std::ostream*)from_this;
    return (std::fstream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class std::iostream
 */
/**
 * Python function wrapper for:
 * void std::iostream::flush(void)
 */
static PyObject *Dtool_std_iostream_flush_41(PyObject *self, PyObject *) {
  std::iostream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_iostream, (void **)&local_this, "std::iostream.flush")) {
    return nullptr;
  }
  // 1-void std::iostream::flush(void)
  ((*local_this).flush)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_std_iostream_flush_41_comment =
  "C++ Interface:\n"
  "flush(const iostream self)\n";
#else
static const char *Dtool_std_iostream_flush_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::istream *std::iostream::upcast_to_istream(void)
 */
static PyObject *Dtool_std_iostream_upcast_to_istream_28(PyObject *self, PyObject *) {
  std::iostream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_iostream, (void **)&local_this, "std::iostream.upcast_to_istream")) {
    return nullptr;
  }
  // 1-std::istream *std::iostream::upcast_to_istream(void)
  std::istream *return_value = (std::istream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_istream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_std_iostream_upcast_to_istream_28_comment =
  "C++ Interface:\n"
  "upcast_to_istream(const iostream self)\n"
  "\n"
  "upcast from iostream to istream";
#else
static const char *Dtool_std_iostream_upcast_to_istream_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::ostream *std::iostream::upcast_to_ostream(void)
 */
static PyObject *Dtool_std_iostream_upcast_to_ostream_39(PyObject *self, PyObject *) {
  std::iostream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_iostream, (void **)&local_this, "std::iostream.upcast_to_ostream")) {
    return nullptr;
  }
  // 1-std::ostream *std::iostream::upcast_to_ostream(void)
  std::ostream *return_value = (std::ostream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_std_iostream_upcast_to_ostream_39_comment =
  "C++ Interface:\n"
  "upcast_to_ostream(const iostream self)\n"
  "\n"
  "upcast from iostream to ostream";
#else
static const char *Dtool_std_iostream_upcast_to_ostream_39_comment = nullptr;
#endif

static int Dtool_Init_std_iostream(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_std_iostream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_std_iostream) {
    printf("std_iostream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  std::iostream *local_this = (std::iostream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_std_iostream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_istream) {
    return (std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ostream) {
    return (std::ostream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_std_iostream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_std_iostream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_istream) {
    std::istream* other_this = (std::istream*)from_this;
    return (std::iostream*)other_this;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    std::ostream* other_this = (std::ostream*)from_this;
    return (std::iostream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class std::istream
 */
/**
 * Python function wrapper for:
 * PyObject *std::istream::read(Py_ssize_t size = -1)
 */
static PyObject *Dtool_std_istream_read_17(PyObject *self, PyObject *args, PyObject *kwds) {
  std::istream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_istream, (void **)&local_this, "std::istream.read")) {
    return nullptr;
  }
  // 1-PyObject *std::istream::read(Py_ssize_t size = -1)
  Py_ssize_t param1 = -1;
  static const char *keyword_list[] = {"size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|n:read", (char **)keyword_list, &param1)) {
    PyObject *return_value = invoke_extension(local_this).read((Py_ssize_t)param1);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const istream self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_std_istream_read_17_comment =
  "C++ Interface:\n"
  "read(const istream self, int size)\n";
#else
static const char *Dtool_std_istream_read_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *std::istream::read1(Py_ssize_t size = -1)
 */
static PyObject *Dtool_std_istream_read1_18(PyObject *self, PyObject *args, PyObject *kwds) {
  std::istream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_istream, (void **)&local_this, "std::istream.read1")) {
    return nullptr;
  }
  // 1-PyObject *std::istream::read1(Py_ssize_t size = -1)
  Py_ssize_t param1 = -1;
  static const char *keyword_list[] = {"size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|n:read1", (char **)keyword_list, &param1)) {
    PyObject *return_value = invoke_extension(local_this).read1((Py_ssize_t)param1);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read1(const istream self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_std_istream_read1_18_comment =
  "C++ Interface:\n"
  "read1(const istream self, int size)\n";
#else
static const char *Dtool_std_istream_read1_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *std::istream::readall(void)
 */
static PyObject *Dtool_std_istream_readall_19(PyObject *self, PyObject *) {
  std::istream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_istream, (void **)&local_this, "std::istream.readall")) {
    return nullptr;
  }
  // 1-PyObject *std::istream::readall(void)
  PyObject *return_value = invoke_extension(local_this).readall();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_std_istream_readall_19_comment =
  "C++ Interface:\n"
  "readall(const istream self)\n";
#else
static const char *Dtool_std_istream_readall_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::streamsize std::istream::readinto(PyObject *b)
 */
static PyObject *Dtool_std_istream_readinto_20(PyObject *self, PyObject *arg) {
  std::istream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_istream, (void **)&local_this, "std::istream.readinto")) {
    return nullptr;
  }
  // 1-std::streamsize std::istream::readinto(PyObject *b)
  std::streamsize return_value = invoke_extension(local_this).readinto(arg);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "readinto(const istream self, object b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_std_istream_readinto_20_comment =
  "C++ Interface:\n"
  "readinto(const istream self, object b)\n";
#else
static const char *Dtool_std_istream_readinto_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *std::istream::readline(Py_ssize_t size = -1)
 */
static PyObject *Dtool_std_istream_readline_21(PyObject *self, PyObject *args, PyObject *kwds) {
  std::istream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_istream, (void **)&local_this, "std::istream.readline")) {
    return nullptr;
  }
  // 1-PyObject *std::istream::readline(Py_ssize_t size = -1)
  Py_ssize_t param1 = -1;
  static const char *keyword_list[] = {"size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|n:readline", (char **)keyword_list, &param1)) {
    PyObject *return_value = invoke_extension(local_this).readline((Py_ssize_t)param1);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "readline(const istream self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_std_istream_readline_21_comment =
  "C++ Interface:\n"
  "readline(const istream self, int size)\n";
#else
static const char *Dtool_std_istream_readline_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *std::istream::readlines(Py_ssize_t hint = -1)
 */
static PyObject *Dtool_std_istream_readlines_22(PyObject *self, PyObject *args, PyObject *kwds) {
  std::istream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_istream, (void **)&local_this, "std::istream.readlines")) {
    return nullptr;
  }
  // 1-PyObject *std::istream::readlines(Py_ssize_t hint = -1)
  Py_ssize_t param1 = -1;
  static const char *keyword_list[] = {"hint", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|n:readlines", (char **)keyword_list, &param1)) {
    PyObject *return_value = invoke_extension(local_this).readlines((Py_ssize_t)param1);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "readlines(const istream self, int hint)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_std_istream_readlines_22_comment =
  "C++ Interface:\n"
  "readlines(const istream self, int hint)\n";
#else
static const char *Dtool_std_istream_readlines_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int std::istream::get(void)
 */
static PyObject *Dtool_std_istream_get_24(PyObject *self, PyObject *) {
  std::istream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_istream, (void **)&local_this, "std::istream.get")) {
    return nullptr;
  }
  // 1-int std::istream::get(void)
  int return_value = ((*local_this).get)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_std_istream_get_24_comment =
  "C++ Interface:\n"
  "get(const istream self)\n";
#else
static const char *Dtool_std_istream_get_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::streamoff std::istream::tellg(void)
 */
static PyObject *Dtool_std_istream_tellg_25(PyObject *self, PyObject *) {
  std::istream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_istream, (void **)&local_this, "std::istream.tellg")) {
    return nullptr;
  }
  // 1-std::streamoff std::istream::tellg(void)
  std::streamoff return_value = ((*local_this).tellg)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_std_istream_tellg_25_comment =
  "C++ Interface:\n"
  "tellg(const istream self)\n";
#else
static const char *Dtool_std_istream_tellg_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void std::istream::seekg(std::streamoff pos)
 * void std::istream::seekg(std::streamoff off, std::ios_base::seekdir dir)
 */
static PyObject *Dtool_std_istream_seekg_26(PyObject *self, PyObject *args, PyObject *kwds) {
  std::istream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_istream, (void **)&local_this, "std::istream.seekg")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-void std::istream::seekg(std::streamoff pos)
        PY_LONG_LONG param1;
        if (PyArg_Parse(arg, "L:seekg", &param1)) {
          ((*local_this).seekg)((std::streamoff)param1);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void std::istream::seekg(std::streamoff off, std::ios_base::seekdir dir)
      PY_LONG_LONG param1;
      int param2;
      static const char *keyword_list[] = {"off", "dir", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Li:seekg", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).seekg)((std::streamoff)param1, (std::ios_base::seekdir)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "seekg() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "seekg(const istream self, long pos)\n"
      "seekg(const istream self, long off, int dir)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_std_istream_seekg_26_comment =
  "C++ Interface:\n"
  "seekg(const istream self, long pos)\n"
  "seekg(const istream self, long off, int dir)\n";
#else
static const char *Dtool_std_istream_seekg_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::basic_ios< char > *std::istream::upcast_to_basic_ios_char(void)
 */
static PyObject *Dtool_std_istream_upcast_to_basic_ios_char_16(PyObject *self, PyObject *) {
  std::istream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_istream, (void **)&local_this, "std::istream.upcast_to_basic_ios_char")) {
    return nullptr;
  }
  // 1-std::basic_ios< char > *std::istream::upcast_to_basic_ios_char(void)
  std::basic_ios< char > *return_value = (std::basic_ios< char > *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_basic_ios_char, false, false);
}

#ifndef NDEBUG
static const char *Dtool_std_istream_upcast_to_basic_ios_char_16_comment =
  "C++ Interface:\n"
  "upcast_to_basic_ios_char(const istream self)\n"
  "\n"
  "upcast from istream to basic_ios< char >";
#else
static const char *Dtool_std_istream_upcast_to_basic_ios_char_16_comment = nullptr;
#endif

static int Dtool_Init_std_istream(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_std_istream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_std_istream) {
    printf("std_istream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  std::istream *local_this = (std::istream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_std_istream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_std_istream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_std_istream) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class std::ostream
 */
/**
 * Python function wrapper for:
 * void std::ostream::write(PyObject *b)
 */
static PyObject *Dtool_std_ostream_write_32(PyObject *self, PyObject *arg) {
  std::ostream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_ostream, (void **)&local_this, "std::ostream.write")) {
    return nullptr;
  }
  // 1-void std::ostream::write(PyObject *b)
  invoke_extension(local_this).write(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(const ostream self, object b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_std_ostream_write_32_comment =
  "C++ Interface:\n"
  "write(const ostream self, object b)\n";
#else
static const char *Dtool_std_ostream_write_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void std::ostream::writelines(PyObject *lines)
 */
static PyObject *Dtool_std_ostream_writelines_33(PyObject *self, PyObject *arg) {
  std::ostream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_ostream, (void **)&local_this, "std::ostream.writelines")) {
    return nullptr;
  }
  // 1-void std::ostream::writelines(PyObject *lines)
  invoke_extension(local_this).writelines(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "writelines(const ostream self, object lines)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_std_ostream_writelines_33_comment =
  "C++ Interface:\n"
  "writelines(const ostream self, object lines)\n";
#else
static const char *Dtool_std_ostream_writelines_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void std::ostream::put(char c)
 */
static PyObject *Dtool_std_ostream_put_34(PyObject *self, PyObject *arg) {
  std::ostream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_ostream, (void **)&local_this, "std::ostream.put")) {
    return nullptr;
  }
  // 1-void std::ostream::put(char c)
  char *param1_str;
  Py_ssize_t param1_len;
  if (PyArg_Parse(arg, "s#:put", &param1_str, &param1_len)) {
    if (param1_len == 1) {
      ((*local_this).put)(param1_str[0]);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "put(const ostream self, char c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_std_ostream_put_34_comment =
  "C++ Interface:\n"
  "put(const ostream self, char c)\n";
#else
static const char *Dtool_std_ostream_put_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void std::ostream::flush(void)
 */
static PyObject *Dtool_std_ostream_flush_35(PyObject *self, PyObject *) {
  std::ostream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_ostream, (void **)&local_this, "std::ostream.flush")) {
    return nullptr;
  }
  // 1-void std::ostream::flush(void)
  ((*local_this).flush)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_std_ostream_flush_35_comment =
  "C++ Interface:\n"
  "flush(const ostream self)\n";
#else
static const char *Dtool_std_ostream_flush_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::streamoff std::ostream::tellp(void)
 */
static PyObject *Dtool_std_ostream_tellp_36(PyObject *self, PyObject *) {
  std::ostream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_ostream, (void **)&local_this, "std::ostream.tellp")) {
    return nullptr;
  }
  // 1-std::streamoff std::ostream::tellp(void)
  std::streamoff return_value = ((*local_this).tellp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_std_ostream_tellp_36_comment =
  "C++ Interface:\n"
  "tellp(const ostream self)\n";
#else
static const char *Dtool_std_ostream_tellp_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void std::ostream::seekp(std::streamoff pos)
 * void std::ostream::seekp(std::streamoff off, std::ios_base::seekdir dir)
 */
static PyObject *Dtool_std_ostream_seekp_37(PyObject *self, PyObject *args, PyObject *kwds) {
  std::ostream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_ostream, (void **)&local_this, "std::ostream.seekp")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-void std::ostream::seekp(std::streamoff pos)
        PY_LONG_LONG param1;
        if (PyArg_Parse(arg, "L:seekp", &param1)) {
          ((*local_this).seekp)((std::streamoff)param1);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void std::ostream::seekp(std::streamoff off, std::ios_base::seekdir dir)
      PY_LONG_LONG param1;
      int param2;
      static const char *keyword_list[] = {"off", "dir", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Li:seekp", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).seekp)((std::streamoff)param1, (std::ios_base::seekdir)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "seekp() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "seekp(const ostream self, long pos)\n"
      "seekp(const ostream self, long off, int dir)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_std_ostream_seekp_37_comment =
  "C++ Interface:\n"
  "seekp(const ostream self, long pos)\n"
  "seekp(const ostream self, long off, int dir)\n";
#else
static const char *Dtool_std_ostream_seekp_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::basic_ios< char > *std::ostream::upcast_to_basic_ios_char(void)
 */
static PyObject *Dtool_std_ostream_upcast_to_basic_ios_char_31(PyObject *self, PyObject *) {
  std::ostream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_ostream, (void **)&local_this, "std::ostream.upcast_to_basic_ios_char")) {
    return nullptr;
  }
  // 1-std::basic_ios< char > *std::ostream::upcast_to_basic_ios_char(void)
  std::basic_ios< char > *return_value = (std::basic_ios< char > *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_basic_ios_char, false, false);
}

#ifndef NDEBUG
static const char *Dtool_std_ostream_upcast_to_basic_ios_char_31_comment =
  "C++ Interface:\n"
  "upcast_to_basic_ios_char(const ostream self)\n"
  "\n"
  "upcast from ostream to basic_ios< char >";
#else
static const char *Dtool_std_ostream_upcast_to_basic_ios_char_31_comment = nullptr;
#endif

static int Dtool_Init_std_ostream(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_std_ostream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_std_ostream) {
    printf("std_ostream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  std::ostream *local_this = (std::ostream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_std_ostream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_std_ostream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class std::ifstream
 */
/**
 * Python function wrapper for:
 * void std::ifstream::close(void)
 */
static PyObject *Dtool_std_ifstream_close_48(PyObject *self, PyObject *) {
  std::ifstream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_ifstream, (void **)&local_this, "std::ifstream.close")) {
    return nullptr;
  }
  // 1-void std::ifstream::close(void)
  ((*local_this).close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_std_ifstream_close_48_comment =
  "C++ Interface:\n"
  "close(const ifstream self)\n";
#else
static const char *Dtool_std_ifstream_close_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::ifstream::ifstream(void)
 */
static int Dtool_Init_std_ifstream(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ifstream() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ifstream() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-std::ifstream::ifstream(void)
  std::ifstream *return_value = new std::ifstream();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_std_ifstream, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ifstream()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_std_ifstream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_std_ifstream) {
    printf("std_ifstream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  std::ifstream *local_this = (std::ifstream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_std_ifstream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_istream) {
    return (std::istream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_std_ifstream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_std_ifstream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_istream) {
    std::istream* other_this = (std::istream*)from_this;
    return (std::ifstream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class std::ofstream
 */
/**
 * Python function wrapper for:
 * void std::ofstream::close(void)
 */
static PyObject *Dtool_std_ofstream_close_53(PyObject *self, PyObject *) {
  std::ofstream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_std_ofstream, (void **)&local_this, "std::ofstream.close")) {
    return nullptr;
  }
  // 1-void std::ofstream::close(void)
  ((*local_this).close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_std_ofstream_close_53_comment =
  "C++ Interface:\n"
  "close(const ofstream self)\n";
#else
static const char *Dtool_std_ofstream_close_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::ofstream::ofstream(void)
 */
static int Dtool_Init_std_ofstream(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ofstream() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ofstream() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-std::ofstream::ofstream(void)
  std::ofstream *return_value = new std::ofstream();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_std_ofstream, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ofstream()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_std_ofstream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_std_ofstream) {
    printf("std_ofstream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  std::ofstream *local_this = (std::ofstream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_std_ofstream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ostream) {
    return (std::ostream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_std_ofstream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_std_ofstream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    std::ostream* other_this = (std::ostream*)from_this;
    return (std::ofstream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class IFileStream
 */
/**
 * Python function wrapper for:
 * inline void IFileStream::open(char const *filename, std::ios_base::openmode mode = ::std::ios_base::in)
 */
static PyObject *Dtool_IFileStream_open_58(PyObject *self, PyObject *args, PyObject *kwds) {
  IFileStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IFileStream, (void **)&local_this, "IFileStream.open")) {
    return nullptr;
  }
  // 1-inline void IFileStream::open(char const *filename, std::ios_base::openmode mode = ::std::ios_base::in)
  char const *param1;
  int param2 = std::ios_base::in;
  static const char *keyword_list[] = {"filename", "mode", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:open", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).open)((char const *)param1, (std::ios_base::openmode)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const IFileStream self, str filename, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IFileStream_open_58_comment =
  "C++ Interface:\n"
  "open(const IFileStream self, str filename, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_IFileStream_open_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void IFileStream::close(void)
 */
static PyObject *Dtool_IFileStream_close_59(PyObject *self, PyObject *) {
  IFileStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IFileStream, (void **)&local_this, "IFileStream.close")) {
    return nullptr;
  }
  // 1-inline void IFileStream::close(void)
  ((*local_this).close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_IFileStream_close_59_comment =
  "C++ Interface:\n"
  "close(const IFileStream self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_IFileStream_close_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline IFileStream::IFileStream(void)
 * inline explicit IFileStream::IFileStream(char const *filename, std::ios_base::openmode mode = ::std::ios_base::in)
 */
static int Dtool_Init_IFileStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline IFileStream::IFileStream(void)
      IFileStream *return_value = new IFileStream();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IFileStream, true, false);
    }
    break;
  case 1:
  case 2:
    {
      // 1-inline explicit IFileStream::IFileStream(char const *filename, std::ios_base::openmode mode = ::std::ios_base::in)
      char const *param0;
      int param1 = std::ios_base::in;
      static const char *keyword_list[] = {"filename", "mode", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:IFileStream", (char **)keyword_list, &param0, &param1)) {
        IFileStream *return_value = new IFileStream((char const *)param0, (std::ios_base::openmode)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IFileStream, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "IFileStream() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IFileStream()\n"
      "IFileStream(str filename, int mode)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_IFileStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_IFileStream) {
    printf("IFileStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  IFileStream *local_this = (IFileStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_IFileStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_istream) {
    return (std::istream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_IFileStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_IFileStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_istream) {
    std::istream* other_this = (std::istream*)from_this;
    return (IFileStream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OFileStream
 */
/**
 * Python function wrapper for:
 * inline void OFileStream::open(char const *filename, std::ios_base::openmode mode = ::std::ios_base::out)
 */
static PyObject *Dtool_OFileStream_open_63(PyObject *self, PyObject *args, PyObject *kwds) {
  OFileStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OFileStream, (void **)&local_this, "OFileStream.open")) {
    return nullptr;
  }
  // 1-inline void OFileStream::open(char const *filename, std::ios_base::openmode mode = ::std::ios_base::out)
  char const *param1;
  int param2 = std::ios_base::out;
  static const char *keyword_list[] = {"filename", "mode", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:open", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).open)((char const *)param1, (std::ios_base::openmode)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const OFileStream self, str filename, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OFileStream_open_63_comment =
  "C++ Interface:\n"
  "open(const OFileStream self, str filename, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_OFileStream_open_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OFileStream::close(void)
 */
static PyObject *Dtool_OFileStream_close_64(PyObject *self, PyObject *) {
  OFileStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OFileStream, (void **)&local_this, "OFileStream.close")) {
    return nullptr;
  }
  // 1-inline void OFileStream::close(void)
  ((*local_this).close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OFileStream_close_64_comment =
  "C++ Interface:\n"
  "close(const OFileStream self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_OFileStream_close_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OFileStream::OFileStream(void)
 * inline explicit OFileStream::OFileStream(char const *filename, std::ios_base::openmode mode = ::std::ios_base::out)
 */
static int Dtool_Init_OFileStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline OFileStream::OFileStream(void)
      OFileStream *return_value = new OFileStream();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OFileStream, true, false);
    }
    break;
  case 1:
  case 2:
    {
      // 1-inline explicit OFileStream::OFileStream(char const *filename, std::ios_base::openmode mode = ::std::ios_base::out)
      char const *param0;
      int param1 = std::ios_base::out;
      static const char *keyword_list[] = {"filename", "mode", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:OFileStream", (char **)keyword_list, &param0, &param1)) {
        OFileStream *return_value = new OFileStream((char const *)param0, (std::ios_base::openmode)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OFileStream, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OFileStream() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OFileStream()\n"
      "OFileStream(str filename, int mode)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OFileStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OFileStream) {
    printf("OFileStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OFileStream *local_this = (OFileStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OFileStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ostream) {
    return (std::ostream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OFileStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OFileStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    std::ostream* other_this = (std::ostream*)from_this;
    return (OFileStream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class FileStream
 */
/**
 * Python function wrapper for:
 * inline void FileStream::open(char const *filename, std::ios_base::openmode mode = ::std::ios_base::in)
 */
static PyObject *Dtool_FileStream_open_68(PyObject *self, PyObject *args, PyObject *kwds) {
  FileStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FileStream, (void **)&local_this, "FileStream.open")) {
    return nullptr;
  }
  // 1-inline void FileStream::open(char const *filename, std::ios_base::openmode mode = ::std::ios_base::in)
  char const *param1;
  int param2 = std::ios_base::in;
  static const char *keyword_list[] = {"filename", "mode", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:open", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).open)((char const *)param1, (std::ios_base::openmode)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const FileStream self, str filename, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FileStream_open_68_comment =
  "C++ Interface:\n"
  "open(const FileStream self, str filename, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FileStream_open_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FileStream::close(void)
 */
static PyObject *Dtool_FileStream_close_69(PyObject *self, PyObject *) {
  FileStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FileStream, (void **)&local_this, "FileStream.close")) {
    return nullptr;
  }
  // 1-inline void FileStream::close(void)
  ((*local_this).close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FileStream_close_69_comment =
  "C++ Interface:\n"
  "close(const FileStream self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FileStream_close_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline FileStream::FileStream(void)
 * inline explicit FileStream::FileStream(char const *filename, std::ios_base::openmode mode = ::std::ios_base::in)
 */
static int Dtool_Init_FileStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline FileStream::FileStream(void)
      FileStream *return_value = new FileStream();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileStream, true, false);
    }
    break;
  case 1:
  case 2:
    {
      // 1-inline explicit FileStream::FileStream(char const *filename, std::ios_base::openmode mode = ::std::ios_base::in)
      char const *param0;
      int param1 = std::ios_base::in;
      static const char *keyword_list[] = {"filename", "mode", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:FileStream", (char **)keyword_list, &param0, &param1)) {
        FileStream *return_value = new FileStream((char const *)param0, (std::ios_base::openmode)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileStream, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "FileStream() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FileStream()\n"
      "FileStream(str filename, int mode)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_FileStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FileStream) {
    printf("FileStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FileStream *local_this = (FileStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FileStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_iostream) {
    return (std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_istream) {
    return (std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ostream) {
    return (std::ostream *)(std::iostream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FileStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FileStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_iostream) {
    std::iostream* other_this = (std::iostream*)from_this;
    return (FileStream*)other_this;
  }
  if (from_type == Dtool_Ptr_std_istream) {
    std::istream* other_this = (std::istream*)from_this;
    return (FileStream*)other_this;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    std::ostream* other_this = (std::ostream*)from_this;
    return (FileStream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextEncoder
 */
/**
 * Python function wrapper for:
 * inline void TextEncoder::set_encoding(TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_set_encoding_77(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.set_encoding")) {
    return nullptr;
  }
  // 1-inline void TextEncoder::set_encoding(TextEncoder::Encoding encoding)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_encoding)((TextEncoder::Encoding)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encoding(const TextEncoder self, int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_set_encoding_77_comment =
  "C++ Interface:\n"
  "set_encoding(const TextEncoder self, int encoding)\n"
  "\n"
  "/**\n"
  " * Specifies how the string set via set_text() is to be interpreted.  The\n"
  " * default, E_iso8859, means a standard string with one-byte characters (i.e.\n"
  " * ASCII).  Other encodings are possible to take advantage of character sets\n"
  " * with more than 256 characters.\n"
  " *\n"
  " * This affects only future calls to set_text(); it does not change text that\n"
  " * was set previously.\n"
  " */";
#else
static const char *Dtool_TextEncoder_set_encoding_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextEncoder::Encoding TextEncoder::get_encoding(void) const
 */
static PyObject *Dtool_TextEncoder_get_encoding_78(PyObject *self, PyObject *) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  // 1-inline TextEncoder::Encoding TextEncoder::get_encoding(void) const
  TextEncoder::Encoding return_value = ((*(const TextEncoder*)local_this).get_encoding)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_encoding_78_comment =
  "C++ Interface:\n"
  "get_encoding(TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Returns the encoding by which the string set via set_text() is to be\n"
  " * interpreted.  See set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_encoding_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TextEncoder::set_default_encoding(TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_set_default_encoding_79(PyObject *, PyObject *arg) {
  // 1-static inline void TextEncoder::set_default_encoding(TextEncoder::Encoding encoding)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (TextEncoder::set_default_encoding)((TextEncoder::Encoding)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_encoding(int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_set_default_encoding_79_comment =
  "C++ Interface:\n"
  "set_default_encoding(int encoding)\n"
  "\n"
  "/**\n"
  " * Specifies the default encoding to be used for all subsequently created\n"
  " * TextEncoder objects.  See set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_set_default_encoding_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline TextEncoder::Encoding TextEncoder::get_default_encoding(void)
 */
static PyObject *Dtool_TextEncoder_get_default_encoding_80(PyObject *, PyObject *) {
  // 1-static inline TextEncoder::Encoding TextEncoder::get_default_encoding(void)
  TextEncoder::Encoding return_value = (TextEncoder::get_default_encoding)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_default_encoding_80_comment =
  "C++ Interface:\n"
  "get_default_encoding()\n"
  "\n"
  "/**\n"
  " * Specifies the default encoding to be used for all subsequently created\n"
  " * TextEncoder objects.  See set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_default_encoding_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextEncoder::set_text(PyObject *text)
 * void TextEncoder::set_text(PyObject *text, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_set_text_82(PyObject *self, PyObject *args, PyObject *kwds) {
  TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.set_text")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "text")) {
        // 1-void TextEncoder::set_text(PyObject *text)
        invoke_extension(local_this).set_text(arg);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void TextEncoder::set_text(PyObject *text, TextEncoder::Encoding encoding)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"text", "encoding", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_text", (char **)keyword_list, &param1, &param2)) {
        invoke_extension(local_this).set_text(param1, (TextEncoder::Encoding)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_text() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text(const TextEncoder self, object text)\n"
      "set_text(const TextEncoder self, object text, int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_set_text_82_comment =
  "C++ Interface:\n"
  "set_text(const TextEncoder self, object text)\n"
  "set_text(const TextEncoder self, object text, int encoding)\n"
  "\n"
  "/**\n"
  " * Changes the text that is stored in the encoder.  The text should be encoded\n"
  " * according to the method indicated by set_encoding().  Subsequent calls to\n"
  " * get_text() will return this same string, while get_wtext() will return the\n"
  " * decoded version of the string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * The two-parameter version of set_text() accepts an explicit encoding; the\n"
  " * text is immediately decoded and stored as a wide-character string.\n"
  " * Subsequent calls to get_text() will return the same text re-encoded using\n"
  " * whichever encoding is specified by set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_set_text_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::clear_text(void)
 */
static PyObject *Dtool_TextEncoder_clear_text_83(PyObject *self, PyObject *) {
  TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.clear_text")) {
    return nullptr;
  }
  // 1-inline void TextEncoder::clear_text(void)
  ((*local_this).clear_text)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_clear_text_83_comment =
  "C++ Interface:\n"
  "clear_text(const TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Removes the text from the TextEncoder.\n"
  " */";
#else
static const char *Dtool_TextEncoder_clear_text_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextEncoder::has_text(void) const
 */
static PyObject *Dtool_TextEncoder_has_text_84(PyObject *self, PyObject *) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  // 1-inline bool TextEncoder::has_text(void) const
  bool return_value = ((*(const TextEncoder*)local_this).has_text)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_has_text_84_comment =
  "C++ Interface:\n"
  "has_text(TextEncoder self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextEncoder_has_text_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextEncoder::make_upper(void)
 */
static PyObject *Dtool_TextEncoder_make_upper_85(PyObject *self, PyObject *) {
  TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.make_upper")) {
    return nullptr;
  }
  // 1-void TextEncoder::make_upper(void)
  ((*local_this).make_upper)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_make_upper_85_comment =
  "C++ Interface:\n"
  "make_upper(const TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Adjusts the text stored within the encoder to all uppercase letters\n"
  " * (preserving accent marks correctly).\n"
  " */";
#else
static const char *Dtool_TextEncoder_make_upper_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextEncoder::make_lower(void)
 */
static PyObject *Dtool_TextEncoder_make_lower_86(PyObject *self, PyObject *) {
  TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.make_lower")) {
    return nullptr;
  }
  // 1-void TextEncoder::make_lower(void)
  ((*local_this).make_lower)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_make_lower_86_comment =
  "C++ Interface:\n"
  "make_lower(const TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Adjusts the text stored within the encoder to all lowercase letters\n"
  " * (preserving accent marks correctly).\n"
  " */";
#else
static const char *Dtool_TextEncoder_make_lower_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *TextEncoder::get_text(void) const
 * PyObject *TextEncoder::get_text(TextEncoder::Encoding encoding) const
 */
static PyObject *Dtool_TextEncoder_get_text_87(PyObject *self, PyObject *args) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-PyObject *TextEncoder::get_text(void) const
      PyObject *return_value = invoke_extension((const TextEncoder*)local_this).get_text();
      return Dtool_Return(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-PyObject *TextEncoder::get_text(TextEncoder::Encoding encoding) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        PyObject *return_value = invoke_extension((const TextEncoder*)local_this).get_text((TextEncoder::Encoding)arg_val);
        return Dtool_Return(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_text() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_text(TextEncoder self)\n"
      "get_text(TextEncoder self, int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_text_87_comment =
  "C++ Interface:\n"
  "get_text(TextEncoder self)\n"
  "get_text(TextEncoder self, int encoding)\n"
  "\n"
  "/**\n"
  " * Returns the current text, as encoded via the current encoding system.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the current text, as encoded via the indicated encoding system.\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_text_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextEncoder::append_text(PyObject *text)
 */
static PyObject *Dtool_TextEncoder_append_text_88(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.append_text")) {
    return nullptr;
  }
  // 1-void TextEncoder::append_text(PyObject *text)
  invoke_extension(local_this).append_text(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_text(const TextEncoder self, object text)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_append_text_88_comment =
  "C++ Interface:\n"
  "append_text(const TextEncoder self, object text)\n"
  "\n"
  "/**\n"
  " * Appends the indicates string to the end of the stored text.\n"
  " */";
#else
static const char *Dtool_TextEncoder_append_text_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::append_unicode_char(char32_t character)
 */
static PyObject *Dtool_TextEncoder_append_unicode_char_89(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.append_unicode_char")) {
    return nullptr;
  }
  // 1-inline void TextEncoder::append_unicode_char(char32_t character)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).append_unicode_char)((char32_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_unicode_char(const TextEncoder self, int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_append_unicode_char_89_comment =
  "C++ Interface:\n"
  "append_unicode_char(const TextEncoder self, int character)\n"
  "\n"
  "/**\n"
  " * Appends a single character to the end of the stored text.  This may be a\n"
  " * wide character, up to 16 bits in Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_append_unicode_char_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TextEncoder::get_num_chars(void) const
 */
static PyObject *Dtool_TextEncoder_get_num_chars_90(PyObject *self, PyObject *) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  // 1-inline std::size_t TextEncoder::get_num_chars(void) const
  std::size_t return_value = ((*(const TextEncoder*)local_this).get_num_chars)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_num_chars_90_comment =
  "C++ Interface:\n"
  "get_num_chars(TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Returns the number of characters in the stored text.  This is a count of\n"
  " * wide characters, after the string has been decoded according to\n"
  " * set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_num_chars_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextEncoder::get_unicode_char(std::size_t index) const
 */
static PyObject *Dtool_TextEncoder_get_unicode_char_91(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  // 1-inline int TextEncoder::get_unicode_char(std::size_t index) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    int return_value = ((*(const TextEncoder*)local_this).get_unicode_char)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_unicode_char(TextEncoder self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_unicode_char_91_comment =
  "C++ Interface:\n"
  "get_unicode_char(TextEncoder self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the Unicode value of the nth character in the stored text.  This\n"
  " * may be a wide character (greater than 255), after the string has been\n"
  " * decoded according to set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_unicode_char_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::set_unicode_char(std::size_t index, char32_t character)
 */
static PyObject *Dtool_TextEncoder_set_unicode_char_92(PyObject *self, PyObject *args, PyObject *kwds) {
  TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.set_unicode_char")) {
    return nullptr;
  }
  // 1-inline void TextEncoder::set_unicode_char(std::size_t index, char32_t character)
  Py_ssize_t param1;
  unsigned long param2;
  static const char *keyword_list[] = {"index", "character", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nk:set_unicode_char", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    ((*local_this).set_unicode_char)((std::size_t)param1, (char32_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_unicode_char(const TextEncoder self, int index, int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_set_unicode_char_92_comment =
  "C++ Interface:\n"
  "set_unicode_char(const TextEncoder self, int index, int character)\n"
  "\n"
  "/**\n"
  " * Sets the Unicode value of the nth character in the stored text.  This may\n"
  " * be a wide character (greater than 255), after the string has been decoded\n"
  " * according to set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_set_unicode_char_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string TextEncoder::get_encoded_char(std::size_t index) const
 * inline std::string TextEncoder::get_encoded_char(std::size_t index, TextEncoder::Encoding encoding) const
 */
static PyObject *Dtool_TextEncoder_get_encoded_char_93(PyObject *self, PyObject *args, PyObject *kwds) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "index")) {
        // 1-inline std::string TextEncoder::get_encoded_char(std::size_t index) const
        if (PyLongOrInt_Check(arg)) {
          size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
          if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
            return nullptr;
          }
#endif
          std::string return_value = ((*(const TextEncoder*)local_this).get_encoded_char)(arg_val);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline std::string TextEncoder::get_encoded_char(std::size_t index, TextEncoder::Encoding encoding) const
      Py_ssize_t param1;
      int param2;
      static const char *keyword_list[] = {"index", "encoding", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ni:get_encoded_char", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::string return_value = ((*(const TextEncoder*)local_this).get_encoded_char)((std::size_t)param1, (TextEncoder::Encoding)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_encoded_char() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_encoded_char(TextEncoder self, int index)\n"
      "get_encoded_char(TextEncoder self, int index, int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_encoded_char_93_comment =
  "C++ Interface:\n"
  "get_encoded_char(TextEncoder self, int index)\n"
  "get_encoded_char(TextEncoder self, int index, int encoding)\n"
  "\n"
  "/**\n"
  " * Returns the nth char of the stored text, as a one-, two-, or three-byte\n"
  " * encoded string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the nth char of the stored text, as a one-, two-, or three-byte\n"
  " * encoded string.\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_encoded_char_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string TextEncoder::get_text_as_ascii(void) const
 */
static PyObject *Dtool_TextEncoder_get_text_as_ascii_94(PyObject *self, PyObject *) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  // 1-inline std::string TextEncoder::get_text_as_ascii(void) const
  std::string return_value = ((*(const TextEncoder*)local_this).get_text_as_ascii)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_text_as_ascii_94_comment =
  "C++ Interface:\n"
  "get_text_as_ascii(TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Returns the text associated with the node, converted as nearly as possible\n"
  " * to a fully-ASCII representation.  This means replacing accented letters\n"
  " * with their unaccented ASCII equivalents.\n"
  " *\n"
  " * It is possible that some characters in the string cannot be converted to\n"
  " * ASCII.  (The string may involve symbols like the copyright symbol, for\n"
  " * instance, or it might involve letters in some other alphabet such as Greek\n"
  " * or Cyrillic, or even Latin letters like thorn or eth that are not part of\n"
  " * the ASCII character set.)  In this case, as much of the string as possible\n"
  " * will be converted to ASCII, and the nonconvertible characters will remain\n"
  " * encoded in the encoding specified by set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_text_as_ascii_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string TextEncoder::reencode_text(std::string const &text, TextEncoder::Encoding from, TextEncoder::Encoding to)
 */
static PyObject *Dtool_TextEncoder_reencode_text_95(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline std::string TextEncoder::reencode_text(std::string const &text, TextEncoder::Encoding from, TextEncoder::Encoding to)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  int param1;
  int param2;
  static const char *keyword_list[] = {"text", "from", "to", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#ii:reencode_text", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2)) {
    std::string return_value = (TextEncoder::reencode_text)(std::string(param0_str, param0_len), (TextEncoder::Encoding)param1, (TextEncoder::Encoding)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reencode_text(str text, int from, int to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_reencode_text_95_comment =
  "C++ Interface:\n"
  "reencode_text(str text, int from, int to)\n"
  "\n"
  "/**\n"
  " * Given the indicated text string, which is assumed to be encoded via the\n"
  " * encoding \"from\", decodes it and then reencodes it into the encoding \"to\",\n"
  " * and returns the newly encoded string.  This does not change or affect any\n"
  " * properties on the TextEncoder itself.\n"
  " */";
#else
static const char *Dtool_TextEncoder_reencode_text_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_isalpha(char32_t character)
 */
static PyObject *Dtool_TextEncoder_unicode_isalpha_96(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_isalpha(char32_t character)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param0 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param0);
    }
#endif
    bool return_value = (TextEncoder::unicode_isalpha)((char32_t)param0);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_isalpha(int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_isalpha_96_comment =
  "C++ Interface:\n"
  "unicode_isalpha(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is an alphabetic letter, false\n"
  " * otherwise.  This is akin to ctype's isalpha(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_isalpha_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_isdigit(char32_t character)
 */
static PyObject *Dtool_TextEncoder_unicode_isdigit_97(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_isdigit(char32_t character)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param0 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param0);
    }
#endif
    bool return_value = (TextEncoder::unicode_isdigit)((char32_t)param0);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_isdigit(int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_isdigit_97_comment =
  "C++ Interface:\n"
  "unicode_isdigit(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is a numeric digit, false\n"
  " * otherwise.  This is akin to ctype's isdigit(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_isdigit_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_ispunct(char32_t character)
 */
static PyObject *Dtool_TextEncoder_unicode_ispunct_98(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_ispunct(char32_t character)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param0 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param0);
    }
#endif
    bool return_value = (TextEncoder::unicode_ispunct)((char32_t)param0);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_ispunct(int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_ispunct_98_comment =
  "C++ Interface:\n"
  "unicode_ispunct(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is a punctuation mark, false\n"
  " * otherwise.  This is akin to ctype's ispunct(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_ispunct_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_islower(char32_t character)
 */
static PyObject *Dtool_TextEncoder_unicode_islower_99(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_islower(char32_t character)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param0 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param0);
    }
#endif
    bool return_value = (TextEncoder::unicode_islower)((char32_t)param0);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_islower(int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_islower_99_comment =
  "C++ Interface:\n"
  "unicode_islower(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is a lowercase letter, false\n"
  " * otherwise.  This is akin to ctype's islower(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_islower_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_isupper(char32_t character)
 */
static PyObject *Dtool_TextEncoder_unicode_isupper_100(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_isupper(char32_t character)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param0 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param0);
    }
#endif
    bool return_value = (TextEncoder::unicode_isupper)((char32_t)param0);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_isupper(int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_isupper_100_comment =
  "C++ Interface:\n"
  "unicode_isupper(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is an uppercase letter, false\n"
  " * otherwise.  This is akin to ctype's isupper(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_isupper_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_isspace(char32_t character)
 */
static PyObject *Dtool_TextEncoder_unicode_isspace_101(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_isspace(char32_t character)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param0 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param0);
    }
#endif
    bool return_value = (TextEncoder::unicode_isspace)((char32_t)param0);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_isspace(int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_isspace_101_comment =
  "C++ Interface:\n"
  "unicode_isspace(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is a whitespace letter, false\n"
  " * otherwise.  This is akin to ctype's isspace(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_isspace_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int TextEncoder::unicode_toupper(char32_t character)
 */
static PyObject *Dtool_TextEncoder_unicode_toupper_102(PyObject *, PyObject *arg) {
  // 1-static inline int TextEncoder::unicode_toupper(char32_t character)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param0 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param0);
    }
#endif
    int return_value = (TextEncoder::unicode_toupper)((char32_t)param0);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_toupper(int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_toupper_102_comment =
  "C++ Interface:\n"
  "unicode_toupper(int character)\n"
  "\n"
  "/**\n"
  " * Returns the uppercase equivalent of the given Unicode character.  This is\n"
  " * akin to ctype's toupper(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_toupper_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int TextEncoder::unicode_tolower(char32_t character)
 */
static PyObject *Dtool_TextEncoder_unicode_tolower_103(PyObject *, PyObject *arg) {
  // 1-static inline int TextEncoder::unicode_tolower(char32_t character)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param0 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param0);
    }
#endif
    int return_value = (TextEncoder::unicode_tolower)((char32_t)param0);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_tolower(int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_tolower_103_comment =
  "C++ Interface:\n"
  "unicode_tolower(int character)\n"
  "\n"
  "/**\n"
  " * Returns the uppercase equivalent of the given Unicode character.  This is\n"
  " * akin to ctype's tolower(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_tolower_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string TextEncoder::upper(std::string const &source)
 * static inline std::string TextEncoder::upper(std::string const &source, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_upper_104(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "source")) {
        // 1-static inline std::string TextEncoder::upper(std::string const &source)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          std::string return_value = (TextEncoder::upper)(std::string(param0_str, param0_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-static inline std::string TextEncoder::upper(std::string const &source, TextEncoder::Encoding encoding)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      int param1;
      static const char *keyword_list[] = {"source", "encoding", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:upper", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        std::string return_value = (TextEncoder::upper)(std::string(param0_str, param0_len), (TextEncoder::Encoding)param1);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "upper() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "upper(str source)\n"
      "upper(str source, int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_upper_104_comment =
  "C++ Interface:\n"
  "upper(str source)\n"
  "upper(str source, int encoding)\n"
  "\n"
  "/**\n"
  " * Converts the string to uppercase, assuming the string is encoded in the\n"
  " * default encoding.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Converts the string to uppercase, assuming the string is encoded in the\n"
  " * indicated encoding.\n"
  " */";
#else
static const char *Dtool_TextEncoder_upper_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string TextEncoder::lower(std::string const &source)
 * static inline std::string TextEncoder::lower(std::string const &source, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_lower_105(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "source")) {
        // 1-static inline std::string TextEncoder::lower(std::string const &source)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          std::string return_value = (TextEncoder::lower)(std::string(param0_str, param0_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-static inline std::string TextEncoder::lower(std::string const &source, TextEncoder::Encoding encoding)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      int param1;
      static const char *keyword_list[] = {"source", "encoding", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:lower", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        std::string return_value = (TextEncoder::lower)(std::string(param0_str, param0_len), (TextEncoder::Encoding)param1);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "lower() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower(str source)\n"
      "lower(str source, int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_lower_105_comment =
  "C++ Interface:\n"
  "lower(str source)\n"
  "lower(str source, int encoding)\n"
  "\n"
  "/**\n"
  " * Converts the string to lowercase, assuming the string is encoded in the\n"
  " * default encoding.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Converts the string to lowercase, assuming the string is encoded in the\n"
  " * indicated encoding.\n"
  " */";
#else
static const char *Dtool_TextEncoder_lower_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::set_wtext(std::wstring const &wtext)
 */
static PyObject *Dtool_TextEncoder_set_wtext_106(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.set_wtext")) {
    return nullptr;
  }
  // 1-inline void TextEncoder::set_wtext(std::wstring const &wtext)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  if (PyArg_Parse(arg, "U:set_wtext", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    ((*local_this).set_wtext)(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wtext(const TextEncoder self, unicode wtext)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_set_wtext_106_comment =
  "C++ Interface:\n"
  "set_wtext(const TextEncoder self, unicode wtext)\n"
  "\n"
  "// Direct support for wide-character strings.  Now publishable with the new\n"
  "// wstring support in interrogate.\n"
  "\n"
  "/**\n"
  " * Changes the text that is stored in the encoder.  Subsequent calls to\n"
  " * get_wtext() will return this same string, while get_text() will return the\n"
  " * encoded version of the string.\n"
  " */";
#else
static const char *Dtool_TextEncoder_set_wtext_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring const &TextEncoder::get_wtext(void) const
 */
static PyObject *Dtool_TextEncoder_get_wtext_107(PyObject *self, PyObject *) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  // 1-inline std::wstring const &TextEncoder::get_wtext(void) const
  std::wstring const &return_value = ((*(const TextEncoder*)local_this).get_wtext)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_wtext_107_comment =
  "C++ Interface:\n"
  "get_wtext(TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Returns the text associated with the TextEncoder, as a wide-character\n"
  " * string.\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_wtext_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::append_wtext(std::wstring const &text)
 */
static PyObject *Dtool_TextEncoder_append_wtext_108(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.append_wtext")) {
    return nullptr;
  }
  // 1-inline void TextEncoder::append_wtext(std::wstring const &text)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  if (PyArg_Parse(arg, "U:append_wtext", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    ((*local_this).append_wtext)(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_wtext(const TextEncoder self, unicode text)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_append_wtext_108_comment =
  "C++ Interface:\n"
  "append_wtext(const TextEncoder self, unicode text)\n"
  "\n"
  "/**\n"
  " * Appends the indicates string to the end of the stored wide-character text.\n"
  " */";
#else
static const char *Dtool_TextEncoder_append_wtext_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::wstring TextEncoder::get_wtext_as_ascii(void) const
 */
static PyObject *Dtool_TextEncoder_get_wtext_as_ascii_109(PyObject *self, PyObject *) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  // 1-std::wstring TextEncoder::get_wtext_as_ascii(void) const
  std::wstring return_value = ((*(const TextEncoder*)local_this).get_wtext_as_ascii)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_wtext_as_ascii_109_comment =
  "C++ Interface:\n"
  "get_wtext_as_ascii(TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Returns the text associated with the node, converted as nearly as possible\n"
  " * to a fully-ASCII representation.  This means replacing accented letters\n"
  " * with their unaccented ASCII equivalents.\n"
  " *\n"
  " * It is possible that some characters in the string cannot be converted to\n"
  " * ASCII.  (The string may involve symbols like the copyright symbol, for\n"
  " * instance, or it might involve letters in some other alphabet such as Greek\n"
  " * or Cyrillic, or even Latin letters like thorn or eth that are not part of\n"
  " * the ASCII character set.)  In this case, as much of the string as possible\n"
  " * will be converted to ASCII, and the nonconvertible characters will remain\n"
  " * in their original form.\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_wtext_as_ascii_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextEncoder::is_wtext(void) const
 */
static PyObject *Dtool_TextEncoder_is_wtext_110(PyObject *self, PyObject *) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  // 1-bool TextEncoder::is_wtext(void) const
  bool return_value = ((*(const TextEncoder*)local_this).is_wtext)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_is_wtext_110_comment =
  "C++ Interface:\n"
  "is_wtext(TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Returns true if any of the characters in the string returned by get_wtext()\n"
  " * are out of the range of an ASCII character (and, therefore, get_wtext()\n"
  " * should be called in preference to get_text()).\n"
  " */";
#else
static const char *Dtool_TextEncoder_is_wtext_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PyObject *TextEncoder::encode_wchar(char32_t ch, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_encode_wchar_111(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PyObject *TextEncoder::encode_wchar(char32_t ch, TextEncoder::Encoding encoding)
  unsigned long param0;
  int param1;
  static const char *keyword_list[] = {"ch", "encoding", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ki:encode_wchar", (char **)keyword_list, &param0, &param1)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param0 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param0);
    }
#endif
    PyObject *return_value = Extension<TextEncoder>::encode_wchar((char32_t)param0, (TextEncoder::Encoding)param1);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encode_wchar(int ch, int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_encode_wchar_111_comment =
  "C++ Interface:\n"
  "encode_wchar(int ch, int encoding)\n"
  "\n"
  "/**\n"
  " * Encodes a single Unicode character into a one-, two-, three-, or four-byte\n"
  " * string, according to the given encoding system.\n"
  " */";
#else
static const char *Dtool_TextEncoder_encode_wchar_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *TextEncoder::encode_wtext(std::wstring const &wtext) const
 * static PyObject *TextEncoder::encode_wtext(std::wstring const &wtext, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_encode_wtext_112(PyObject *self, PyObject *args, PyObject *kwds) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "wtext")) {
        // 1-inline PyObject *TextEncoder::encode_wtext(std::wstring const &wtext) const
#if PY_VERSION_HEX >= 0x03020000
        PyObject *param1;
#else
        PyUnicodeObject *param1;
#endif
        if (PyArg_Parse(arg, "U:encode_wtext", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
          Py_ssize_t param1_len;
          wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
          Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
          wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
          PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
          PyObject *return_value = invoke_extension((const TextEncoder*)local_this).encode_wtext(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
          PyMem_Free(param1_str);
#endif
          return Dtool_Return(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-static PyObject *TextEncoder::encode_wtext(std::wstring const &wtext, TextEncoder::Encoding encoding)
#if PY_VERSION_HEX >= 0x03020000
      PyObject *param0;
#else
      PyUnicodeObject *param0;
#endif
      int param1;
      static const char *keyword_list[] = {"wtext", "encoding", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Ui:encode_wtext", (char **)keyword_list, &param0, &param1)) {
#if PY_VERSION_HEX >= 0x03030000
        Py_ssize_t param0_len;
        wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
        Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
        wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
        PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
        PyObject *return_value = Extension<TextEncoder>::encode_wtext(std::wstring(param0_str, param0_len), (TextEncoder::Encoding)param1);
#if PY_VERSION_HEX >= 0x03030000
        PyMem_Free(param0_str);
#endif
        return Dtool_Return(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "encode_wtext() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encode_wtext(TextEncoder self, unicode wtext)\n"
      "encode_wtext(unicode wtext, int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_encode_wtext_112_comment =
  "C++ Interface:\n"
  "encode_wtext(TextEncoder self, unicode wtext)\n"
  "encode_wtext(unicode wtext, int encoding)\n"
  "\n"
  "/**\n"
  " * Encodes a wide-text string into a single-char string, according to the\n"
  " * current encoding.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Encodes a wide-text string into a single-char string, according to the\n"
  " * given encoding.\n"
  " */";
#else
static const char *Dtool_TextEncoder_encode_wtext_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *TextEncoder::decode_text(PyObject *text) const
 * static PyObject *TextEncoder::decode_text(PyObject *text, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_decode_text_113(PyObject *self, PyObject *args, PyObject *kwds) {
  TextEncoder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextEncoder)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "text")) {
        // 1-inline PyObject *TextEncoder::decode_text(PyObject *text) const
        PyObject *return_value = invoke_extension((const TextEncoder*)local_this).decode_text(arg);
        return Dtool_Return(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-static PyObject *TextEncoder::decode_text(PyObject *text, TextEncoder::Encoding encoding)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"text", "encoding", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:decode_text", (char **)keyword_list, &param0, &param1)) {
        PyObject *return_value = Extension<TextEncoder>::decode_text(param0, (TextEncoder::Encoding)param1);
        return Dtool_Return(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "decode_text() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decode_text(TextEncoder self, object text)\n"
      "decode_text(object text, int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_decode_text_113_comment =
  "C++ Interface:\n"
  "decode_text(TextEncoder self, object text)\n"
  "decode_text(object text, int encoding)\n"
  "\n"
  "/**\n"
  " * Returns the given wstring decoded to a single-byte string, via the current\n"
  " * encoding system.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the given wstring decoded to a single-byte string, via the given\n"
  " * encoding system.\n"
  " */";
#else
static const char *Dtool_TextEncoder_decode_text_113_comment = nullptr;
#endif

static PyObject *Dtool_TextEncoder_default_encoding_Getter(PyObject *self, void *) {
  // 1-static inline TextEncoder::Encoding TextEncoder::get_default_encoding(void)
  TextEncoder::Encoding return_value = (TextEncoder::get_default_encoding)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextEncoder_default_encoding_Setter(PyObject *self, PyObject *arg, void *) {
  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete default_encoding attribute");
    return -1;
  }
  // 1-static inline void TextEncoder::set_default_encoding(TextEncoder::Encoding encoding)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (TextEncoder::set_default_encoding)((TextEncoder::Encoding)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_default_encoding(int encoding)\n");
  }
  return -1;
}

static PyObject *Dtool_TextEncoder_text_Getter(PyObject *self, void *) {
  const TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PyObject *TextEncoder::get_text(void) const
  PyObject *return_value = invoke_extension((const TextEncoder*)local_this).get_text();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextEncoder_text_Setter(PyObject *self, PyObject *arg, void *) {
  TextEncoder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.text")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete text attribute");
    return -1;
  }
  // 1-void TextEncoder::set_text(PyObject *text)
  invoke_extension(local_this).set_text(arg);
  if (Dtool_CheckErrorOccurred()) {
    return -1;
  }
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_text(const TextEncoder self, object text)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline TextEncoder::TextEncoder(void)
 * inline TextEncoder::TextEncoder(TextEncoder const &copy)
 */
static int Dtool_Init_TextEncoder(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TextEncoder::TextEncoder(void)
      TextEncoder *return_value = new TextEncoder();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextEncoder, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline TextEncoder::TextEncoder(TextEncoder const &copy)
        TextEncoder const *arg_this = (TextEncoder *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextEncoder, 0, "TextEncoder.TextEncoder", true, true);
        if (arg_this != nullptr) {
          TextEncoder *return_value = new TextEncoder(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextEncoder, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextEncoder() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextEncoder()\n"
      "TextEncoder(const TextEncoder copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextEncoder(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextEncoder) {
    printf("TextEncoder ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextEncoder *local_this = (TextEncoder *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextEncoder) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextEncoder(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextEncoder) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Filename
 */
/**
 * Python function wrapper for:
 * PyObject *Filename::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_Filename_reduce_121(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-PyObject *Filename::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const Filename*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_reduce_121_comment =
  "C++ Interface:\n"
  "__reduce__(Filename self)\n";
#else
static const char *Dtool_Filename_reduce_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Filename Filename::text_filename(Filename const &filename)
 * static inline Filename Filename::text_filename(std::string const &filename)
 */
static PyObject *Dtool_Filename_text_filename_122(PyObject *, PyObject *arg) {
  {
    // -2 static inline Filename Filename::text_filename(Filename const &filename)
    Filename const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
    if (arg_this != nullptr) {
      Filename *return_value = new Filename((Filename::text_filename)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
  }

  {
    // -2 static inline Filename Filename::text_filename(std::string const &filename)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      Filename *return_value = new Filename((Filename::text_filename)(std::string(param0_str, param0_len)));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 static inline Filename Filename::text_filename(Filename const &filename)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != nullptr)) {
      Filename *return_value = new Filename((Filename::text_filename)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
  }

  // No coercion possible: static inline Filename Filename::text_filename(std::string const &filename)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "text_filename(const Filename filename)\n"
      "text_filename(str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_text_filename_122_comment =
  "C++ Interface:\n"
  "text_filename(const Filename filename)\n"
  "text_filename(str filename)\n"
  "\n"
  "// Static constructors to explicitly create a filename that refers to a text\n"
  "// or binary file.  This is in lieu of calling set_text() or set_binary() or\n"
  "// set_type().\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_text_filename_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Filename Filename::binary_filename(Filename const &filename)
 * static inline Filename Filename::binary_filename(std::string const &filename)
 */
static PyObject *Dtool_Filename_binary_filename_123(PyObject *, PyObject *arg) {
  {
    // -2 static inline Filename Filename::binary_filename(Filename const &filename)
    Filename const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
    if (arg_this != nullptr) {
      Filename *return_value = new Filename((Filename::binary_filename)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
  }

  {
    // -2 static inline Filename Filename::binary_filename(std::string const &filename)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      Filename *return_value = new Filename((Filename::binary_filename)(std::string(param0_str, param0_len)));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 static inline Filename Filename::binary_filename(Filename const &filename)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != nullptr)) {
      Filename *return_value = new Filename((Filename::binary_filename)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
  }

  // No coercion possible: static inline Filename Filename::binary_filename(std::string const &filename)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "binary_filename(const Filename filename)\n"
      "binary_filename(str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_binary_filename_123_comment =
  "C++ Interface:\n"
  "binary_filename(const Filename filename)\n"
  "binary_filename(str filename)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_binary_filename_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Filename Filename::dso_filename(std::string const &filename)
 */
static PyObject *Dtool_Filename_dso_filename_124(PyObject *, PyObject *arg) {
  // 1-static inline Filename Filename::dso_filename(std::string const &filename)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    Filename *return_value = new Filename((Filename::dso_filename)(std::string(param0_str, param0_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dso_filename(str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_dso_filename_124_comment =
  "C++ Interface:\n"
  "dso_filename(str filename)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_dso_filename_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Filename Filename::executable_filename(std::string const &filename)
 */
static PyObject *Dtool_Filename_executable_filename_125(PyObject *, PyObject *arg) {
  // 1-static inline Filename Filename::executable_filename(std::string const &filename)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    Filename *return_value = new Filename((Filename::executable_filename)(std::string(param0_str, param0_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "executable_filename(str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_executable_filename_125_comment =
  "C++ Interface:\n"
  "executable_filename(str filename)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_executable_filename_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Filename Filename::pattern_filename(std::string const &filename)
 */
static PyObject *Dtool_Filename_pattern_filename_126(PyObject *, PyObject *arg) {
  // 1-static inline Filename Filename::pattern_filename(std::string const &filename)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    Filename *return_value = new Filename((Filename::pattern_filename)(std::string(param0_str, param0_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pattern_filename(str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_pattern_filename_126_comment =
  "C++ Interface:\n"
  "pattern_filename(str filename)\n"
  "\n"
  "/**\n"
  " * Constructs a filename that represents a sequence of numbered files.  See\n"
  " * set_pattern().\n"
  " */";
#else
static const char *Dtool_Filename_pattern_filename_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Filename Filename::from_os_specific(std::string const &os_specific, Filename::Type type = ::Filename::T_general)
 */
static PyObject *Dtool_Filename_from_os_specific_127(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static Filename Filename::from_os_specific(std::string const &os_specific, Filename::Type type = ::Filename::T_general)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  int param1 = Filename::T_general;
  static const char *keyword_list[] = {"os_specific", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|i:from_os_specific", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    Filename *return_value = new Filename((Filename::from_os_specific)(std::string(param0_str, param0_len), (Filename::Type)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "from_os_specific(str os_specific, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_from_os_specific_127_comment =
  "C++ Interface:\n"
  "from_os_specific(str os_specific, int type)\n"
  "\n"
  "/**\n"
  " * This named constructor returns a Panda-style filename (that is, using\n"
  " * forward slashes, and no drive letter) based on the supplied filename string\n"
  " * that describes a filename in the local system conventions (for instance, on\n"
  " * Windows, it may use backslashes or begin with a drive letter and a colon).\n"
  " *\n"
  " * Use this function to create a Filename from an externally-given filename\n"
  " * string.  Use to_os_specific() again later to reconvert it back to the local\n"
  " * operating system's conventions.\n"
  " *\n"
  " * This function will do the right thing even if the filename is partially\n"
  " * local conventions and partially Panda conventions; e.g.  some backslashes\n"
  " * and some forward slashes.\n"
  " */";
#else
static const char *Dtool_Filename_from_os_specific_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Filename Filename::from_os_specific_w(std::wstring const &os_specific, Filename::Type type = ::Filename::T_general)
 */
static PyObject *Dtool_Filename_from_os_specific_w_128(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static Filename Filename::from_os_specific_w(std::wstring const &os_specific, Filename::Type type = ::Filename::T_general)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param0;
#else
  PyUnicodeObject *param0;
#endif
  int param1 = Filename::T_general;
  static const char *keyword_list[] = {"os_specific", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "U|i:from_os_specific_w", (char **)keyword_list, &param0, &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param0_len;
    wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
    Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
    wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
    PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
    Filename *return_value = new Filename((Filename::from_os_specific_w)(std::wstring(param0_str, param0_len), (Filename::Type)param1));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param0_str);
#endif
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "from_os_specific_w(unicode os_specific, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_from_os_specific_w_128_comment =
  "C++ Interface:\n"
  "from_os_specific_w(unicode os_specific, int type)\n"
  "\n"
  "/**\n"
  " * The wide-string variant of from_os_specific(). Returns a new Filename,\n"
  " * converted from an os-specific wide-character string.\n"
  " */";
#else
static const char *Dtool_Filename_from_os_specific_w_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Filename Filename::expand_from(std::string const &user_string, Filename::Type type = ::Filename::T_general)
 */
static PyObject *Dtool_Filename_expand_from_129(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static Filename Filename::expand_from(std::string const &user_string, Filename::Type type = ::Filename::T_general)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  int param1 = Filename::T_general;
  static const char *keyword_list[] = {"user_string", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|i:expand_from", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    Filename *return_value = new Filename((Filename::expand_from)(std::string(param0_str, param0_len), (Filename::Type)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "expand_from(str user_string, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_expand_from_129_comment =
  "C++ Interface:\n"
  "expand_from(str user_string, int type)\n"
  "\n"
  "/**\n"
  " * Returns the same thing as from_os_specific(), but embedded environment\n"
  " * variable references (e.g.  \"$DMODELS/foo.txt\") are expanded out.  It also\n"
  " * automatically elevates the file to its true case if needed.\n"
  " */";
#else
static const char *Dtool_Filename_expand_from_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Filename Filename::temporary(std::string const &dirname, std::string const &prefix, std::string const &suffix = string(), Filename::Type type = ::Filename::T_general)
 */
static PyObject *Dtool_Filename_temporary_130(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static Filename Filename::temporary(std::string const &dirname, std::string const &prefix, std::string const &suffix = string(), Filename::Type type = ::Filename::T_general)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  int param3 = Filename::T_general;
  static const char *keyword_list[] = {"dirname", "prefix", "suffix", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:temporary", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
    Filename *return_value = new Filename((Filename::temporary)(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (Filename::Type)param3));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "temporary(str dirname, str prefix, str suffix, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_temporary_130_comment =
  "C++ Interface:\n"
  "temporary(str dirname, str prefix, str suffix, int type)\n"
  "\n"
  "/**\n"
  " * Generates a temporary filename within the indicated directory, using the\n"
  " * indicated prefix.  If the directory is empty, a system-defined directory is\n"
  " * chosen instead.\n"
  " *\n"
  " * The generated filename did not exist when the Filename checked, but since\n"
  " * it does not specifically create the file, it is possible that another\n"
  " * process could simultaneously create a file by the same name.\n"
  " */";
#else
static const char *Dtool_Filename_temporary_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Filename const &Filename::get_home_directory(void)
 */
static PyObject *Dtool_Filename_get_home_directory_131(PyObject *, PyObject *) {
  // 1-static Filename const &Filename::get_home_directory(void)
  Filename const *return_value = &((Filename::get_home_directory)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_home_directory_131_comment =
  "C++ Interface:\n"
  "get_home_directory()\n"
  "\n"
  "/**\n"
  " * Returns a path to the user's home directory, if such a thing makes sense in\n"
  " * the current OS, or to the nearest equivalent.  This may or may not be\n"
  " * directly writable by the application.\n"
  " */";
#else
static const char *Dtool_Filename_get_home_directory_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Filename const &Filename::get_temp_directory(void)
 */
static PyObject *Dtool_Filename_get_temp_directory_132(PyObject *, PyObject *) {
  // 1-static Filename const &Filename::get_temp_directory(void)
  Filename const *return_value = &((Filename::get_temp_directory)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_temp_directory_132_comment =
  "C++ Interface:\n"
  "get_temp_directory()\n"
  "\n"
  "/**\n"
  " * Returns a path to a system-defined temporary directory.\n"
  " */";
#else
static const char *Dtool_Filename_get_temp_directory_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Filename const &Filename::get_user_appdata_directory(void)
 */
static PyObject *Dtool_Filename_get_user_appdata_directory_133(PyObject *, PyObject *) {
  // 1-static Filename const &Filename::get_user_appdata_directory(void)
  Filename const *return_value = &((Filename::get_user_appdata_directory)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_user_appdata_directory_133_comment =
  "C++ Interface:\n"
  "get_user_appdata_directory()\n"
  "\n"
  "/**\n"
  " * Returns a path to a system-defined directory appropriate for creating a\n"
  " * subdirectory for storing application-specific data, specific to the current\n"
  " * user.\n"
  " */";
#else
static const char *Dtool_Filename_get_user_appdata_directory_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Filename const &Filename::get_common_appdata_directory(void)
 */
static PyObject *Dtool_Filename_get_common_appdata_directory_134(PyObject *, PyObject *) {
  // 1-static Filename const &Filename::get_common_appdata_directory(void)
  Filename const *return_value = &((Filename::get_common_appdata_directory)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_common_appdata_directory_134_comment =
  "C++ Interface:\n"
  "get_common_appdata_directory()\n"
  "\n"
  "/**\n"
  " * Returns a path to a system-defined directory appropriate for creating a\n"
  " * subdirectory for storing application-specific data, common to all users.\n"
  " */";
#else
static const char *Dtool_Filename_get_common_appdata_directory_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Rejected Remap [inline void Filename::operator =(Filename &&from) noexcept]
 * inline void Filename::operator =(Filename const &copy)
 * inline void Filename::operator =(char const *filename)
 * inline void Filename::operator =(std::string const &filename)
 * inline void Filename::operator =(std::wstring const &filename)
 */
static PyObject *Dtool_Filename_operator_135(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.assign")) {
    return nullptr;
  }
  {
    // -2 inline void Filename::operator =(Filename const &copy)
    Filename const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
    if (arg_this != nullptr) {
      ((*local_this).operator =)(*arg_this);
      Filename *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, false);
    }
  }

  {
    // -2 inline void Filename::operator =(std::wstring const &filename)
#if PY_VERSION_HEX >= 0x03020000
    PyObject *param1;
#else
    PyUnicodeObject *param1;
#endif
    if (PyArg_Parse(arg, "U:assign", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
      Py_ssize_t param1_len;
      wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
      Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
      wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
      PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
      ((*local_this).operator =)(std::wstring(param1_str, param1_len));
      Filename *return_value = local_this;
#if PY_VERSION_HEX >= 0x03030000
      PyMem_Free(param1_str);
#endif
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline void Filename::operator =(std::string const &filename)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).operator =)(std::string(param1_str, param1_len));
      Filename *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline void Filename::operator =(char const *filename)
    char const *param1;
    if (PyArg_Parse(arg, "z:assign", &param1)) {
      ((*local_this).operator =)((char const *)param1);
      Filename *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline void Filename::operator =(Filename const &copy)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).operator =)(*arg_this);
      Filename *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, false);
    }
  }

  // No coercion possible: inline void Filename::operator =(std::wstring const &filename)
  // No coercion possible: inline void Filename::operator =(std::string const &filename)
  // No coercion possible: inline void Filename::operator =(char const *filename)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Filename self, const Filename copy)\n"
      "assign(const Filename self, unicode filename)\n"
      "assign(const Filename self, str filename)\n"
      "assign(const Filename self, str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_operator_135_comment =
  "C++ Interface:\n"
  "assign(const Filename self, const Filename copy)\n"
  "assign(const Filename self, unicode filename)\n"
  "assign(const Filename self, str filename)\n"
  "assign(const Filename self, str filename)\n"
  "\n"
  "// Assignment is via the = operator.\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_operator_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline char const *Filename::c_str(void) const
 */
static PyObject *Dtool_Filename_c_str_137(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline char const *Filename::c_str(void) const
  char const *return_value = ((*(const Filename*)local_this).c_str)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_c_str_137_comment =
  "C++ Interface:\n"
  "c_str(Filename self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_c_str_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::empty(void) const
 */
static PyObject *Dtool_Filename_empty_138(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline bool Filename::empty(void) const
  bool return_value = ((*(const Filename*)local_this).empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_empty_138_comment =
  "C++ Interface:\n"
  "empty(Filename self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_empty_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Filename::length(void) const
 */
static PyObject *Dtool_Filename_length_139(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline std::size_t Filename::length(void) const
  std::size_t return_value = ((*(const Filename*)local_this).length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_length_139_comment =
  "C++ Interface:\n"
  "length(Filename self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_length_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *Filename::__fspath__(void) const
 */
static PyObject *Dtool_Filename_fspath_142(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-PyObject *Filename::__fspath__(void) const
  PyObject *return_value = invoke_extension((const Filename*)local_this).__fspath__();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_fspath_142_comment =
  "C++ Interface:\n"
  "__fspath__(Filename self)\n";
#else
static const char *Dtool_Filename_fspath_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::substr(std::size_t begin) const
 * inline std::string Filename::substr(std::size_t begin, std::size_t end) const
 */
static PyObject *Dtool_Filename_substr_143(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "begin")) {
        // 1-inline std::string Filename::substr(std::size_t begin) const
        if (PyLongOrInt_Check(arg)) {
          size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
          if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
            return nullptr;
          }
#endif
          std::string return_value = ((*(const Filename*)local_this).substr)(arg_val);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline std::string Filename::substr(std::size_t begin, std::size_t end) const
      Py_ssize_t param1;
      Py_ssize_t param2;
      static const char *keyword_list[] = {"begin", "end", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nn:substr", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
#ifndef NDEBUG
        if (param2 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param2);
        }
#endif
        std::string return_value = ((*(const Filename*)local_this).substr)((std::size_t)param1, (std::size_t)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "substr() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "substr(Filename self, int begin)\n"
      "substr(Filename self, int begin, int end)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_substr_143_comment =
  "C++ Interface:\n"
  "substr(Filename self, int begin)\n"
  "substr(Filename self, int begin, int end)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_substr_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_fullpath(void) const
 */
static PyObject *Dtool_Filename_get_fullpath_147(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline std::string Filename::get_fullpath(void) const
  std::string return_value = ((*(const Filename*)local_this).get_fullpath)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_fullpath_147_comment =
  "C++ Interface:\n"
  "get_fullpath(Filename self)\n"
  "\n"
  "// Or, you can use any of these.\n"
  "\n"
  "/**\n"
  " * Returns the entire filename: directory, basename, extension.  This is the\n"
  " * same thing returned by the string typecast operator.\n"
  " */";
#else
static const char *Dtool_Filename_get_fullpath_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring Filename::get_fullpath_w(void) const
 */
static PyObject *Dtool_Filename_get_fullpath_w_148(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline std::wstring Filename::get_fullpath_w(void) const
  std::wstring return_value = ((*(const Filename*)local_this).get_fullpath_w)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_fullpath_w_148_comment =
  "C++ Interface:\n"
  "get_fullpath_w(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the entire filename as a wide-character string.\n"
  " */";
#else
static const char *Dtool_Filename_get_fullpath_w_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_dirname(void) const
 */
static PyObject *Dtool_Filename_get_dirname_149(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline std::string Filename::get_dirname(void) const
  std::string return_value = ((*(const Filename*)local_this).get_dirname)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_dirname_149_comment =
  "C++ Interface:\n"
  "get_dirname(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the directory part of the filename.  This is everything in the\n"
  " * filename up to, but not including the rightmost slash.\n"
  " */";
#else
static const char *Dtool_Filename_get_dirname_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_basename(void) const
 */
static PyObject *Dtool_Filename_get_basename_150(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline std::string Filename::get_basename(void) const
  std::string return_value = ((*(const Filename*)local_this).get_basename)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_basename_150_comment =
  "C++ Interface:\n"
  "get_basename(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the basename part of the filename.  This is everything in the\n"
  " * filename after the rightmost slash, including any extensions.\n"
  " */";
#else
static const char *Dtool_Filename_get_basename_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_fullpath_wo_extension(void) const
 */
static PyObject *Dtool_Filename_get_fullpath_wo_extension_151(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline std::string Filename::get_fullpath_wo_extension(void) const
  std::string return_value = ((*(const Filename*)local_this).get_fullpath_wo_extension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_fullpath_wo_extension_151_comment =
  "C++ Interface:\n"
  "get_fullpath_wo_extension(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the full filename--directory and basename parts--except for the\n"
  " * extension.\n"
  " */";
#else
static const char *Dtool_Filename_get_fullpath_wo_extension_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_basename_wo_extension(void) const
 */
static PyObject *Dtool_Filename_get_basename_wo_extension_152(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline std::string Filename::get_basename_wo_extension(void) const
  std::string return_value = ((*(const Filename*)local_this).get_basename_wo_extension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_basename_wo_extension_152_comment =
  "C++ Interface:\n"
  "get_basename_wo_extension(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the basename part of the filename, without the file extension.\n"
  " */";
#else
static const char *Dtool_Filename_get_basename_wo_extension_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_extension(void) const
 */
static PyObject *Dtool_Filename_get_extension_153(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline std::string Filename::get_extension(void) const
  std::string return_value = ((*(const Filename*)local_this).get_extension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_extension_153_comment =
  "C++ Interface:\n"
  "get_extension(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the file extension.  This is everything after the rightmost dot, if\n"
  " * there is one, or the empty string if there is not.\n"
  " */";
#else
static const char *Dtool_Filename_get_extension_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_fullpath(std::string const &s)
 */
static PyObject *Dtool_Filename_set_fullpath_154(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_fullpath")) {
    return nullptr;
  }
  // 1-void Filename::set_fullpath(std::string const &s)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_fullpath)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fullpath(const Filename self, str s)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_fullpath_154_comment =
  "C++ Interface:\n"
  "set_fullpath(const Filename self, str s)\n"
  "\n"
  "// You can also use any of these to reassign pieces of the filename.\n"
  "\n"
  "/**\n"
  " * Replaces the entire filename: directory, basename, extension.  This can\n"
  " * also be achieved with the assignment operator.\n"
  " */";
#else
static const char *Dtool_Filename_set_fullpath_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_dirname(std::string const &s)
 */
static PyObject *Dtool_Filename_set_dirname_155(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_dirname")) {
    return nullptr;
  }
  // 1-void Filename::set_dirname(std::string const &s)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_dirname)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dirname(const Filename self, str s)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_dirname_155_comment =
  "C++ Interface:\n"
  "set_dirname(const Filename self, str s)\n"
  "\n"
  "/**\n"
  " * Replaces the directory part of the filename.  This is everything in the\n"
  " * filename up to, but not including the rightmost slash.\n"
  " */";
#else
static const char *Dtool_Filename_set_dirname_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_basename(std::string const &s)
 */
static PyObject *Dtool_Filename_set_basename_156(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_basename")) {
    return nullptr;
  }
  // 1-void Filename::set_basename(std::string const &s)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_basename)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_basename(const Filename self, str s)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_basename_156_comment =
  "C++ Interface:\n"
  "set_basename(const Filename self, str s)\n"
  "\n"
  "/**\n"
  " * Replaces the basename part of the filename.  This is everything in the\n"
  " * filename after the rightmost slash, including any extensions.\n"
  " */";
#else
static const char *Dtool_Filename_set_basename_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_fullpath_wo_extension(std::string const &s)
 */
static PyObject *Dtool_Filename_set_fullpath_wo_extension_157(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_fullpath_wo_extension")) {
    return nullptr;
  }
  // 1-void Filename::set_fullpath_wo_extension(std::string const &s)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_fullpath_wo_extension)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fullpath_wo_extension(const Filename self, str s)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_fullpath_wo_extension_157_comment =
  "C++ Interface:\n"
  "set_fullpath_wo_extension(const Filename self, str s)\n"
  "\n"
  "/**\n"
  " * Replaces the full filename--directory and basename parts--except for the\n"
  " * extension.\n"
  " */";
#else
static const char *Dtool_Filename_set_fullpath_wo_extension_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_basename_wo_extension(std::string const &s)
 */
static PyObject *Dtool_Filename_set_basename_wo_extension_158(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_basename_wo_extension")) {
    return nullptr;
  }
  // 1-void Filename::set_basename_wo_extension(std::string const &s)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_basename_wo_extension)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_basename_wo_extension(const Filename self, str s)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_basename_wo_extension_158_comment =
  "C++ Interface:\n"
  "set_basename_wo_extension(const Filename self, str s)\n"
  "\n"
  "/**\n"
  " * Replaces the basename part of the filename, without the file extension.\n"
  " */";
#else
static const char *Dtool_Filename_set_basename_wo_extension_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_extension(std::string const &s)
 */
static PyObject *Dtool_Filename_set_extension_159(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_extension")) {
    return nullptr;
  }
  // 1-void Filename::set_extension(std::string const &s)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_extension)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extension(const Filename self, str s)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_extension_159_comment =
  "C++ Interface:\n"
  "set_extension(const Filename self, str s)\n"
  "\n"
  "/**\n"
  " * Replaces the file extension.  This is everything after the rightmost dot,\n"
  " * if there is one, or the empty string if there is not.\n"
  " */";
#else
static const char *Dtool_Filename_set_extension_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Filename::set_binary(void)
 */
static PyObject *Dtool_Filename_set_binary_160(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_binary")) {
    return nullptr;
  }
  // 1-inline void Filename::set_binary(void)
  ((*local_this).set_binary)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_binary_160_comment =
  "C++ Interface:\n"
  "set_binary(const Filename self)\n"
  "\n"
  "// Setting these flags appropriately is helpful when opening or searching\n"
  "// for a file; it helps the Filename resolve OS-specific conventions (for\n"
  "// instance, that dynamic library names should perhaps be changed from .so\n"
  "// to .dll).\n"
  "\n"
  "/**\n"
  " * Indicates that the filename represents a binary file.  This is primarily\n"
  " * relevant to the read_file() and write_file() methods, so they can set the\n"
  " * appropriate flags to the OS.\n"
  " */";
#else
static const char *Dtool_Filename_set_binary_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Filename::set_text(void)
 */
static PyObject *Dtool_Filename_set_text_161(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_text")) {
    return nullptr;
  }
  // 1-inline void Filename::set_text(void)
  ((*local_this).set_text)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_text_161_comment =
  "C++ Interface:\n"
  "set_text(const Filename self)\n"
  "\n"
  "/**\n"
  " * Indicates that the filename represents a text file.  This is primarily\n"
  " * relevant to the read_file() and write_file() methods, so they can set the\n"
  " * appropriate flags to the OS.\n"
  " */";
#else
static const char *Dtool_Filename_set_text_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::is_binary(void) const
 */
static PyObject *Dtool_Filename_is_binary_162(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline bool Filename::is_binary(void) const
  bool return_value = ((*(const Filename*)local_this).is_binary)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_binary_162_comment =
  "C++ Interface:\n"
  "is_binary(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Filename has been indicated to represent a binary file\n"
  " * via a previous call to set_binary().  It is possible that neither\n"
  " * is_binary() nor is_text() will be true, if neither set_binary() nor\n"
  " * set_text() was ever called.\n"
  " */";
#else
static const char *Dtool_Filename_is_binary_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::is_text(void) const
 */
static PyObject *Dtool_Filename_is_text_163(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline bool Filename::is_text(void) const
  bool return_value = ((*(const Filename*)local_this).is_text)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_text_163_comment =
  "C++ Interface:\n"
  "is_text(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Filename has been indicated to represent a text file\n"
  " * via a previous call to set_text().  It is possible that neither is_binary()\n"
  " * nor is_text() will be true, if neither set_binary() nor set_text() was ever\n"
  " * called.\n"
  " */";
#else
static const char *Dtool_Filename_is_text_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::is_binary_or_text(void) const
 */
static PyObject *Dtool_Filename_is_binary_or_text_164(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline bool Filename::is_binary_or_text(void) const
  bool return_value = ((*(const Filename*)local_this).is_binary_or_text)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_binary_or_text_164_comment =
  "C++ Interface:\n"
  "is_binary_or_text(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true either is_binary() or is_text() is true; that is, that the\n"
  " * filename has been specified as either binary or text.  If this is false,\n"
  " * the filename has not been specified.\n"
  " */";
#else
static const char *Dtool_Filename_is_binary_or_text_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Filename::set_type(Filename::Type type)
 */
static PyObject *Dtool_Filename_set_type_165(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_type")) {
    return nullptr;
  }
  // 1-inline void Filename::set_type(Filename::Type type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_type)((Filename::Type)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_type(const Filename self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_type_165_comment =
  "C++ Interface:\n"
  "set_type(const Filename self, int type)\n"
  "\n"
  "/**\n"
  " * Sets the type of the file represented by the filename.  This is useful for\n"
  " * to_os_specific(), resolve_filename(), test_existence(), and all such real-\n"
  " * world access functions.  It helps the Filename know how to map the internal\n"
  " * filename to the OS-specific filename (for instance, maybe executables\n"
  " * should have an .exe extension).\n"
  " */";
#else
static const char *Dtool_Filename_set_type_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename::Type Filename::get_type(void) const
 */
static PyObject *Dtool_Filename_get_type_166(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline Filename::Type Filename::get_type(void) const
  Filename::Type return_value = ((*(const Filename*)local_this).get_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_type_166_comment =
  "C++ Interface:\n"
  "get_type(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the type of the file represented by the filename, as previously set\n"
  " * by set_type().\n"
  " */";
#else
static const char *Dtool_Filename_get_type_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Filename::set_pattern(bool pattern)
 */
static PyObject *Dtool_Filename_set_pattern_167(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_pattern")) {
    return nullptr;
  }
  // 1-inline void Filename::set_pattern(bool pattern)
  ((*local_this).set_pattern)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pattern(const Filename self, bool pattern)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_pattern_167_comment =
  "C++ Interface:\n"
  "set_pattern(const Filename self, bool pattern)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether this is a filename pattern.  When this is\n"
  " * true, the filename is understood to be a placeholder for a numbered\n"
  " * sequence of filename, such as an image sequence.  In this case, a sequence\n"
  " * of one or more hash characters (\"#\") should appear in the filename string;\n"
  " * these characters will be filled in with the corresponding number (or more)\n"
  " * of digits representing the sequence number.  Sequence numbers always begin\n"
  " * counting at 0.\n"
  " *\n"
  " * When this is true, methods like has_hash() and get_hash_to_end() and\n"
  " * get_filename_index() may be called.  Methods like is_exists() will\n"
  " * implicitly test for existance of filename sequence 0.\n"
  " */";
#else
static const char *Dtool_Filename_set_pattern_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::get_pattern(void) const
 */
static PyObject *Dtool_Filename_get_pattern_168(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline bool Filename::get_pattern(void) const
  bool return_value = ((*(const Filename*)local_this).get_pattern)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_pattern_168_comment =
  "C++ Interface:\n"
  "get_pattern(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the flag indicating whether this is a filename pattern.  See\n"
  " * set_pattern().\n"
  " */";
#else
static const char *Dtool_Filename_get_pattern_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::has_hash(void) const
 */
static PyObject *Dtool_Filename_has_hash_169(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline bool Filename::has_hash(void) const
  bool return_value = ((*(const Filename*)local_this).has_hash)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_has_hash_169_comment =
  "C++ Interface:\n"
  "has_hash(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename is indicated to be a filename pattern (that\n"
  " * is, set_pattern(true) was called), and the filename pattern did include a\n"
  " * sequence of hash marks, or false if it was not a filename pattern or did\n"
  " * not include hash marks.  If this is true, then get_filename_index() will\n"
  " * return a different filename each time.\n"
  " */";
#else
static const char *Dtool_Filename_has_hash_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Filename Filename::get_filename_index(int index) const
 */
static PyObject *Dtool_Filename_get_filename_index_170(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-Filename Filename::get_filename_index(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Filename *return_value = new Filename(((*(const Filename*)local_this).get_filename_index)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_filename_index(Filename self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_filename_index_170_comment =
  "C++ Interface:\n"
  "get_filename_index(Filename self, int index)\n"
  "\n"
  "/**\n"
  " * If the pattern flag is set for this Filename and the filename string\n"
  " * actually includes a sequence of hash marks, then this returns a new\n"
  " * Filename with the sequence of hash marks replaced by the indicated index\n"
  " * number.\n"
  " *\n"
  " * If the pattern flag is not set for this Filename or it does not contain a\n"
  " * sequence of hash marks, this quietly returns the original filename.\n"
  " */";
#else
static const char *Dtool_Filename_get_filename_index_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_hash_to_end(void) const
 */
static PyObject *Dtool_Filename_get_hash_to_end_171(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline std::string Filename::get_hash_to_end(void) const
  std::string return_value = ((*(const Filename*)local_this).get_hash_to_end)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_hash_to_end_171_comment =
  "C++ Interface:\n"
  "get_hash_to_end(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the part of the filename beginning at the hash sequence (if any),\n"
  " * and continuing to the end of the filename.\n"
  " */";
#else
static const char *Dtool_Filename_get_hash_to_end_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_hash_to_end(std::string const &s)
 */
static PyObject *Dtool_Filename_set_hash_to_end_172(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_hash_to_end")) {
    return nullptr;
  }
  // 1-void Filename::set_hash_to_end(std::string const &s)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_hash_to_end)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hash_to_end(const Filename self, str s)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_hash_to_end_172_comment =
  "C++ Interface:\n"
  "set_hash_to_end(const Filename self, str s)\n"
  "\n"
  "/**\n"
  " * Replaces the part of the filename from the beginning of the hash sequence\n"
  " * to the end of the filename.\n"
  " */";
#else
static const char *Dtool_Filename_set_hash_to_end_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Filename::standardize(void)
 */
static PyObject *Dtool_Filename_standardize_174(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.standardize")) {
    return nullptr;
  }
  // 1-void Filename::standardize(void)
  ((*local_this).standardize)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Filename_standardize_174_comment =
  "C++ Interface:\n"
  "standardize(const Filename self)\n"
  "\n"
  "/**\n"
  " * Converts the filename to standard form by replacing consecutive slashes\n"
  " * with a single slash, removing a trailing slash if present, and backing up\n"
  " * over .. sequences within the filename where possible.\n"
  " */";
#else
static const char *Dtool_Filename_standardize_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::is_local(void) const
 */
static PyObject *Dtool_Filename_is_local_175(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline bool Filename::is_local(void) const
  bool return_value = ((*(const Filename*)local_this).is_local)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_local_175_comment =
  "C++ Interface:\n"
  "is_local(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename is local, e.g.  does not begin with a slash,\n"
  " * or false if the filename is fully specified from the root.\n"
  " */";
#else
static const char *Dtool_Filename_is_local_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::is_fully_qualified(void) const
 */
static PyObject *Dtool_Filename_is_fully_qualified_176(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline bool Filename::is_fully_qualified(void) const
  bool return_value = ((*(const Filename*)local_this).is_fully_qualified)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_fully_qualified_176_comment =
  "C++ Interface:\n"
  "is_fully_qualified(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename is fully qualified, e.g.  begins with a slash.\n"
  " * This is almost, but not quite, the same thing as !is_local().  It's not\n"
  " * exactly the same because a special case is made for filenames that begin\n"
  " * with a single dot followed by a slash--these are considered to be fully\n"
  " * qualified (they are explicitly relative to the current directory, and do\n"
  " * not refer to a filename on a search path somewhere).\n"
  " */";
#else
static const char *Dtool_Filename_is_fully_qualified_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Filename::make_absolute(void)
 * void Filename::make_absolute(Filename const &start_directory)
 */
static PyObject *Dtool_Filename_make_absolute_177(PyObject *self, PyObject *args) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.make_absolute")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void Filename::make_absolute(void)
      ((*local_this).make_absolute)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void Filename::make_absolute(Filename const &start_directory)
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "Filename.make_absolute", "Filename");
      }
      ((*local_this).make_absolute)(*arg_this);
      return Dtool_Return_None();
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_absolute() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_absolute(const Filename self)\n"
      "make_absolute(const Filename self, const Filename start_directory)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_make_absolute_177_comment =
  "C++ Interface:\n"
  "make_absolute(const Filename self)\n"
  "make_absolute(const Filename self, const Filename start_directory)\n"
  "\n"
  "/**\n"
  " * Converts the filename to a fully-qualified pathname from the root (if it is\n"
  " * a relative pathname), and then standardizes it (see standardize()).\n"
  " *\n"
  " * This is sometimes a little problematic, since it may convert the file to\n"
  " * its 'true' absolute pathname, which could be an ugly NFS-named file,\n"
  " * irrespective of symbolic links (e.g.\n"
  " * /.automount/dimbo/root/usr2/fit/people/drose instead of /fit/people/drose);\n"
  " * besides being ugly, filenames like this may not be consistent across\n"
  " * multiple different platforms.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Converts the filename to a fully-qualified filename from the root (if it is\n"
  " * a relative filename), and then standardizes it (see standardize()).  This\n"
  " * flavor accepts a specific starting directory that the filename is known to\n"
  " * be relative to.\n"
  " */";
#else
static const char *Dtool_Filename_make_absolute_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::make_canonical(void)
 */
static PyObject *Dtool_Filename_make_canonical_178(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.make_canonical")) {
    return nullptr;
  }
  // 1-bool Filename::make_canonical(void)
  bool return_value = ((*local_this).make_canonical)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_make_canonical_178_comment =
  "C++ Interface:\n"
  "make_canonical(const Filename self)\n"
  "\n"
  "/**\n"
  " * Converts this filename to a canonical name by replacing the directory part\n"
  " * with the fully-qualified directory part.  This is done by changing to that\n"
  " * directory and calling getcwd().\n"
  " *\n"
  " * This has the effect of (a) converting relative paths to absolute paths (but\n"
  " * see make_absolute() if this is the only effect you want), and (b) always\n"
  " * resolving a given directory name to the same string, even if different\n"
  " * symbolic links are traversed, and (c) changing nice symbolic-link paths\n"
  " * like fit/people/drose to ugly NFS automounter names like\n"
  " * hosts/dimbo/usr2/fit/people/drose.  This can be troubling, but sometimes\n"
  " * this is exactly what you want, particularly if you're about to call\n"
  " * make_relative_to() between two filenames.\n"
  " *\n"
  " * The return value is true if successful, or false on failure (usually\n"
  " * because the directory name does not exist or cannot be chdir'ed into).\n"
  " */";
#else
static const char *Dtool_Filename_make_canonical_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::make_true_case(void)
 */
static PyObject *Dtool_Filename_make_true_case_179(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.make_true_case")) {
    return nullptr;
  }
  // 1-bool Filename::make_true_case(void)
  bool return_value = ((*local_this).make_true_case)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_make_true_case_179_comment =
  "C++ Interface:\n"
  "make_true_case(const Filename self)\n"
  "\n"
  "/**\n"
  " * On a case-insensitive operating system (e.g.  Windows), this method looks\n"
  " * up the file in the file system and resets the Filename to represent the\n"
  " * actual case of the file as it exists on the disk.  The return value is true\n"
  " * if the file exists and the conversion can be made, or false if there is\n"
  " * some error.\n"
  " *\n"
  " * On a case-sensitive operating system, this method does nothing and always\n"
  " * returns true.\n"
  " *\n"
  " * An empty filename is considered to exist in this case.\n"
  " */";
#else
static const char *Dtool_Filename_make_true_case_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Filename::to_os_specific(void) const
 */
static PyObject *Dtool_Filename_to_os_specific_180(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-std::string Filename::to_os_specific(void) const
  std::string return_value = ((*(const Filename*)local_this).to_os_specific)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_to_os_specific_180_comment =
  "C++ Interface:\n"
  "to_os_specific(Filename self)\n"
  "\n"
  "/**\n"
  " * Converts the filename from our generic Unix-like convention (forward\n"
  " * slashes starting with the root at '/') to the corresponding filename in the\n"
  " * local operating system (slashes in the appropriate direction, starting with\n"
  " * the root at C:\\, for instance).  Returns the string representing the\n"
  " * converted filename, but does not change the Filename itself.\n"
  " *\n"
  " * See also from_os_specific().\n"
  " */";
#else
static const char *Dtool_Filename_to_os_specific_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::wstring Filename::to_os_specific_w(void) const
 */
static PyObject *Dtool_Filename_to_os_specific_w_181(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-std::wstring Filename::to_os_specific_w(void) const
  std::wstring return_value = ((*(const Filename*)local_this).to_os_specific_w)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_to_os_specific_w_181_comment =
  "C++ Interface:\n"
  "to_os_specific_w(Filename self)\n"
  "\n"
  "/**\n"
  " * The wide-string variant on to_os_specific().\n"
  " */";
#else
static const char *Dtool_Filename_to_os_specific_w_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Filename::to_os_generic(void) const
 */
static PyObject *Dtool_Filename_to_os_generic_182(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-std::string Filename::to_os_generic(void) const
  std::string return_value = ((*(const Filename*)local_this).to_os_generic)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_to_os_generic_182_comment =
  "C++ Interface:\n"
  "to_os_generic(Filename self)\n"
  "\n"
  "/**\n"
  " * This is similar to to_os_specific(), but it is designed to generate a\n"
  " * filename that can be understood on as many platforms as possible.  Since\n"
  " * Windows can usually understand a forward-slash-delimited filename, this\n"
  " * means it does the same thing as to_os_specific(), but it uses forward\n"
  " * slashes instead of backslashes.\n"
  " *\n"
  " * This method has a pretty limited use; it should generally be used for\n"
  " * writing file references to a file that might be read on any operating\n"
  " * system.\n"
  " */";
#else
static const char *Dtool_Filename_to_os_generic_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Filename::to_os_short_name(void) const
 */
static PyObject *Dtool_Filename_to_os_short_name_183(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-std::string Filename::to_os_short_name(void) const
  std::string return_value = ((*(const Filename*)local_this).to_os_short_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_to_os_short_name_183_comment =
  "C++ Interface:\n"
  "to_os_short_name(Filename self)\n"
  "\n"
  "/**\n"
  " * This works like to_os_generic(), but it returns the \"short name\" version of\n"
  " * the filename, if it exists, or the original filename otherwise.\n"
  " *\n"
  " * On Windows platforms, this returns the 8.3 filename version of the given\n"
  " * filename, if the file exists, and the same thing as to_os_specific()\n"
  " * otherwise.  On non-Windows platforms, this always returns the same thing as\n"
  " * to_os_specific().\n"
  " */";
#else
static const char *Dtool_Filename_to_os_short_name_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Filename::to_os_long_name(void) const
 */
static PyObject *Dtool_Filename_to_os_long_name_184(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-std::string Filename::to_os_long_name(void) const
  std::string return_value = ((*(const Filename*)local_this).to_os_long_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_to_os_long_name_184_comment =
  "C++ Interface:\n"
  "to_os_long_name(Filename self)\n"
  "\n"
  "/**\n"
  " * This is the opposite of to_os_short_name(): it returns the \"long name\" of\n"
  " * the filename, if the filename exists.  On non-Windows platforms, this\n"
  " * returns the same thing as to_os_specific().\n"
  " */";
#else
static const char *Dtool_Filename_to_os_long_name_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::exists(void) const
 */
static PyObject *Dtool_Filename_exists_185(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::exists(void) const
  bool return_value = ((*(const Filename*)local_this).exists)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_exists_185_comment =
  "C++ Interface:\n"
  "exists(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename exists on the disk, false otherwise.  If the\n"
  " * type is indicated to be executable, this also tests that the file has\n"
  " * execute permission.\n"
  " */";
#else
static const char *Dtool_Filename_exists_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::is_regular_file(void) const
 */
static PyObject *Dtool_Filename_is_regular_file_186(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::is_regular_file(void) const
  bool return_value = ((*(const Filename*)local_this).is_regular_file)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_regular_file_186_comment =
  "C++ Interface:\n"
  "is_regular_file(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename exists and is the name of a regular file (i.e.\n"
  " * not a directory or device), false otherwise.\n"
  " */";
#else
static const char *Dtool_Filename_is_regular_file_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::is_writable(void) const
 */
static PyObject *Dtool_Filename_is_writable_187(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::is_writable(void) const
  bool return_value = ((*(const Filename*)local_this).is_writable)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_writable_187_comment =
  "C++ Interface:\n"
  "is_writable(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename exists and is either a directory or a regular\n"
  " * file that can be written to, or false otherwise.\n"
  " */";
#else
static const char *Dtool_Filename_is_writable_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::is_directory(void) const
 */
static PyObject *Dtool_Filename_is_directory_188(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::is_directory(void) const
  bool return_value = ((*(const Filename*)local_this).is_directory)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_directory_188_comment =
  "C++ Interface:\n"
  "is_directory(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename exists and is a directory name, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_Filename_is_directory_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::is_executable(void) const
 */
static PyObject *Dtool_Filename_is_executable_189(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::is_executable(void) const
  bool return_value = ((*(const Filename*)local_this).is_executable)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_executable_189_comment =
  "C++ Interface:\n"
  "is_executable(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename exists and is executable\n"
  " */";
#else
static const char *Dtool_Filename_is_executable_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Filename::compare_timestamps(Filename const &other, bool this_missing_is_old = true, bool other_missing_is_old = true) const
 */
static PyObject *Dtool_Filename_compare_timestamps_190(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-int Filename::compare_timestamps(Filename const &other, bool this_missing_is_old = true, bool other_missing_is_old = true) const
  PyObject *param1;
  PyObject *param2 = Py_True;
  PyObject *param3 = Py_True;
  static const char *keyword_list[] = {"other", "this_missing_is_old", "other_missing_is_old", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:compare_timestamps", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Filename.compare_timestamps", "Filename");
    }
    int return_value = ((*(const Filename*)local_this).compare_timestamps)(*param1_this, (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_timestamps(Filename self, const Filename other, bool this_missing_is_old, bool other_missing_is_old)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_compare_timestamps_190_comment =
  "C++ Interface:\n"
  "compare_timestamps(Filename self, const Filename other, bool this_missing_is_old, bool other_missing_is_old)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if the file named by this object is older\n"
  " * than the given file, zero if they have the same timestamp, or greater than\n"
  " * zero if this one is newer.\n"
  " *\n"
  " * If this_missing_is_old is true, it indicates that a missing file will be\n"
  " * treated as if it were older than any other file; otherwise, a missing file\n"
  " * will be treated as if it were newer than any other file.  Similarly for\n"
  " * other_missing_is_old.\n"
  " */";
#else
static const char *Dtool_Filename_compare_timestamps_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * time_t Filename::get_timestamp(void) const
 */
static PyObject *Dtool_Filename_get_timestamp_191(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-time_t Filename::get_timestamp(void) const
  time_t return_value = ((*(const Filename*)local_this).get_timestamp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_timestamp_191_comment =
  "C++ Interface:\n"
  "get_timestamp(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns a time_t value that represents the time the file was last modified,\n"
  " * to within whatever precision the operating system records this information\n"
  " * (on a Windows95 system, for instance, this may only be accurate to within 2\n"
  " * seconds).\n"
  " *\n"
  " * If the timestamp cannot be determined, either because it is not supported\n"
  " * by the operating system or because there is some error (such as file not\n"
  " * found), returns 0.\n"
  " */";
#else
static const char *Dtool_Filename_get_timestamp_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * time_t Filename::get_access_timestamp(void) const
 */
static PyObject *Dtool_Filename_get_access_timestamp_192(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-time_t Filename::get_access_timestamp(void) const
  time_t return_value = ((*(const Filename*)local_this).get_access_timestamp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_access_timestamp_192_comment =
  "C++ Interface:\n"
  "get_access_timestamp(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns a time_t value that represents the time the file was last accessed,\n"
  " * if this information is available.  See also get_timestamp(), which returns\n"
  " * the last modification time.\n"
  " */";
#else
static const char *Dtool_Filename_get_access_timestamp_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::streamsize Filename::get_file_size(void) const
 */
static PyObject *Dtool_Filename_get_file_size_193(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-std::streamsize Filename::get_file_size(void) const
  std::streamsize return_value = ((*(const Filename*)local_this).get_file_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_file_size_193_comment =
  "C++ Interface:\n"
  "get_file_size(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the file in bytes, or 0 if there is an error.\n"
  " */";
#else
static const char *Dtool_Filename_get_file_size_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::resolve_filename(DSearchPath const &searchpath, std::string const &default_extension = string())
 */
static PyObject *Dtool_Filename_resolve_filename_194(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.resolve_filename")) {
    return nullptr;
  }
  // 1-bool Filename::resolve_filename(DSearchPath const &searchpath, std::string const &default_extension = string())
  PyObject *param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"searchpath", "default_extension", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:resolve_filename", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    DSearchPath param1_local;
    DSearchPath const *param1_this = Dtool_Coerce_DSearchPath(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Filename.resolve_filename", "DSearchPath");
    }
    bool return_value = ((*local_this).resolve_filename)(*param1_this, std::string(param2_str, param2_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resolve_filename(const Filename self, const DSearchPath searchpath, str default_extension)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_resolve_filename_194_comment =
  "C++ Interface:\n"
  "resolve_filename(const Filename self, const DSearchPath searchpath, str default_extension)\n"
  "\n"
  "/**\n"
  " * Searches the given search path for the filename.  If it is found, updates\n"
  " * the filename to the full pathname found and returns true; otherwise,\n"
  " * returns false.\n"
  " */";
#else
static const char *Dtool_Filename_resolve_filename_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::make_relative_to(Filename directory, bool allow_backups = true)
 */
static PyObject *Dtool_Filename_make_relative_to_195(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.make_relative_to")) {
    return nullptr;
  }
  // 1-bool Filename::make_relative_to(Filename directory, bool allow_backups = true)
  PyObject *param1;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"directory", "allow_backups", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:make_relative_to", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Filename.make_relative_to", "Filename");
    }
    bool return_value = ((*local_this).make_relative_to)(*param1_this, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_relative_to(const Filename self, Filename directory, bool allow_backups)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_make_relative_to_195_comment =
  "C++ Interface:\n"
  "make_relative_to(const Filename self, Filename directory, bool allow_backups)\n"
  "\n"
  "/**\n"
  " * Adjusts this filename, which must be a fully-specified pathname beginning\n"
  " * with a slash, to make it a relative filename, relative to the fully-\n"
  " * specified directory indicated (which must also begin with, and may or may\n"
  " * not end with, a slash--a terminating slash is ignored).\n"
  " *\n"
  " * This only performs a string comparsion, so it may be wise to call\n"
  " * make_canonical() on both filenames before calling make_relative_to().\n"
  " *\n"
  " * If allow_backups is false, the filename will only be adjusted to be made\n"
  " * relative if it is already somewhere within or below the indicated\n"
  " * directory.  If allow_backups is true, it will be adjusted in all cases,\n"
  " * even if this requires putting a series of .. characters before the filename\n"
  " * --unless it would have to back all the way up to the root.\n"
  " *\n"
  " * Returns true if the file was adjusted, false if it was not.\n"
  " */";
#else
static const char *Dtool_Filename_make_relative_to_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Filename::find_on_searchpath(DSearchPath const &searchpath)
 */
static PyObject *Dtool_Filename_find_on_searchpath_196(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.find_on_searchpath")) {
    return nullptr;
  }
  // 1-int Filename::find_on_searchpath(DSearchPath const &searchpath)
  DSearchPath arg_local;
  DSearchPath const *arg_this = Dtool_Coerce_DSearchPath(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Filename.find_on_searchpath", "DSearchPath");
  }
  int return_value = ((*local_this).find_on_searchpath)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_on_searchpath(const Filename self, const DSearchPath searchpath)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_find_on_searchpath_196_comment =
  "C++ Interface:\n"
  "find_on_searchpath(const Filename self, const DSearchPath searchpath)\n"
  "\n"
  "/**\n"
  " * Performs the reverse of the resolve_filename() operation: assuming that the\n"
  " * current filename is fully-specified pathname (i.e.  beginning with '/'),\n"
  " * look on the indicated search path for a directory under which the file can\n"
  " * be found.  When found, adjust the Filename to be relative to the indicated\n"
  " * directory name.\n"
  " *\n"
  " * Returns the index of the directory on the searchpath at which the file was\n"
  " * found, or -1 if it was not found.\n"
  " */";
#else
static const char *Dtool_Filename_find_on_searchpath_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *Filename::scan_directory(void) const
 * Rejected Remap [bool Filename::scan_directory(vector_string &contents) const]
 */
static PyObject *Dtool_Filename_scan_directory_197(PyObject *self, PyObject *args) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    return Dtool_Raise_TypeError("function takes no arguments");
#else
    return PyErr_Format(PyExc_TypeError,
                        "scan_directory() takes no arguments (%d given)",
                        parameter_count);
#endif
  }
  // 1-PyObject *Filename::scan_directory(void) const
  PyObject *return_value = invoke_extension((const Filename*)local_this).scan_directory();
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scan_directory(Filename self)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_scan_directory_197_comment =
  "C++ Interface:\n"
  "scan_directory(Filename self)\n"
  "\n"
  "/**\n"
  " * Attempts to open the named filename as if it were a directory and looks for\n"
  " * the non-hidden files within the directory.  Fills the given vector up with\n"
  " * the sorted list of filenames that are local to this directory.\n"
  " *\n"
  " * It is the user's responsibility to ensure that the contents vector is empty\n"
  " * before making this call; otherwise, the new files will be appended to it.\n"
  " *\n"
  " * Returns true on success, false if the directory could not be read for some\n"
  " * reason.\n"
  " */";
#else
static const char *Dtool_Filename_scan_directory_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::open_read(pifstream &stream) const
 * bool Filename::open_read(std::ifstream &stream) const
 */
static PyObject *Dtool_Filename_open_read_198(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  {
    // -2 bool Filename::open_read(pifstream &stream) const
    pifstream *arg_this = (IFileStream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_IFileStream, 1, "Filename.open_read", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*(const Filename*)local_this).open_read)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool Filename::open_read(std::ifstream &stream) const
    std::ifstream *arg_this = (std::ifstream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ifstream, 1, "Filename.open_read", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*(const Filename*)local_this).open_read)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: bool Filename::open_read(pifstream &stream) const
  // No coercion possible: bool Filename::open_read(std::ifstream &stream) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read(Filename self, IFileStream stream)\n"
      "open_read(Filename self, ifstream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_open_read_198_comment =
  "C++ Interface:\n"
  "open_read(Filename self, IFileStream stream)\n"
  "open_read(Filename self, ifstream stream)\n"
  "\n"
  "/**\n"
  " * Opens the indicated ifstream for reading the file, if possible.  Returns\n"
  " * true if successful, false otherwise.  This requires the setting of the\n"
  " * set_text()/set_binary() flags to open the file appropriately as indicated;\n"
  " * it is an error to call open_read() without first calling one of set_text()\n"
  " * or set_binary().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens the indicated pifstream for reading the file, if possible.  Returns\n"
  " * true if successful, false otherwise.  This requires the setting of the\n"
  " * set_text()/set_binary() flags to open the file appropriately as indicated;\n"
  " * it is an error to call open_read() without first calling one of set_text()\n"
  " * or set_binary().\n"
  " */";
#else
static const char *Dtool_Filename_open_read_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::open_write(pofstream &stream, bool truncate = true) const
 * bool Filename::open_write(std::ofstream &stream, bool truncate = true) const
 */
static PyObject *Dtool_Filename_open_write_199(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  {
    // -2 bool Filename::open_write(pofstream &stream, bool truncate = true) const
    PyObject *param1;
    PyObject *param2 = Py_True;
    static const char *keyword_list[] = {"stream", "truncate", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_write", (char **)keyword_list, &param1, &param2)) {
      pofstream *param1_this = (OFileStream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OFileStream, 1, "Filename.open_write", false, false);
      if (param1_this != nullptr) {
        bool return_value = ((*(const Filename*)local_this).open_write)(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool Filename::open_write(std::ofstream &stream, bool truncate = true) const
    PyObject *param1;
    PyObject *param2 = Py_True;
    static const char *keyword_list[] = {"stream", "truncate", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_write", (char **)keyword_list, &param1, &param2)) {
      std::ofstream *param1_this = (std::ofstream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ofstream, 1, "Filename.open_write", false, false);
      if (param1_this != nullptr) {
        bool return_value = ((*(const Filename*)local_this).open_write)(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool Filename::open_write(pofstream &stream, bool truncate = true) const
  // No coercion possible: bool Filename::open_write(std::ofstream &stream, bool truncate = true) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_write(Filename self, OFileStream stream, bool truncate)\n"
      "open_write(Filename self, ofstream stream, bool truncate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_open_write_199_comment =
  "C++ Interface:\n"
  "open_write(Filename self, OFileStream stream, bool truncate)\n"
  "open_write(Filename self, ofstream stream, bool truncate)\n"
  "\n"
  "/**\n"
  " * Opens the indicated ifstream for writing the file, if possible.  Returns\n"
  " * true if successful, false otherwise.  This requires the setting of the\n"
  " * set_text()/set_binary() flags to open the file appropriately as indicated;\n"
  " * it is an error to call open_read() without first calling one of set_text()\n"
  " * or set_binary().\n"
  " *\n"
  " * If truncate is true, the file is truncated to zero length upon opening it,\n"
  " * if it already exists.  Otherwise, the file is kept at its original length.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens the indicated pifstream for writing the file, if possible.  Returns\n"
  " * true if successful, false otherwise.  This requires the setting of the\n"
  " * set_text()/set_binary() flags to open the file appropriately as indicated;\n"
  " * it is an error to call open_read() without first calling one of set_text()\n"
  " * or set_binary().\n"
  " *\n"
  " * If truncate is true, the file is truncated to zero length upon opening it,\n"
  " * if it already exists.  Otherwise, the file is kept at its original length.\n"
  " */";
#else
static const char *Dtool_Filename_open_write_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::open_append(pofstream &stream) const
 * bool Filename::open_append(std::ofstream &stream) const
 */
static PyObject *Dtool_Filename_open_append_200(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  {
    // -2 bool Filename::open_append(pofstream &stream) const
    pofstream *arg_this = (OFileStream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OFileStream, 1, "Filename.open_append", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*(const Filename*)local_this).open_append)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool Filename::open_append(std::ofstream &stream) const
    std::ofstream *arg_this = (std::ofstream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ofstream, 1, "Filename.open_append", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*(const Filename*)local_this).open_append)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: bool Filename::open_append(pofstream &stream) const
  // No coercion possible: bool Filename::open_append(std::ofstream &stream) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_append(Filename self, OFileStream stream)\n"
      "open_append(Filename self, ofstream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_open_append_200_comment =
  "C++ Interface:\n"
  "open_append(Filename self, OFileStream stream)\n"
  "open_append(Filename self, ofstream stream)\n"
  "\n"
  "/**\n"
  " * Opens the indicated ofstream for writing the file, if possible.  Returns\n"
  " * true if successful, false otherwise.  This requires the setting of the\n"
  " * set_text()/set_binary() flags to open the file appropriately as indicated;\n"
  " * it is an error to call open_read() without first calling one of set_text()\n"
  " * or set_binary().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens the indicated pifstream for writing the file, if possible.  Returns\n"
  " * true if successful, false otherwise.  This requires the setting of the\n"
  " * set_text()/set_binary() flags to open the file appropriately as indicated;\n"
  " * it is an error to call open_read() without first calling one of set_text()\n"
  " * or set_binary().\n"
  " */";
#else
static const char *Dtool_Filename_open_append_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::open_read_write(pfstream &stream, bool truncate = false) const
 * bool Filename::open_read_write(std::fstream &stream, bool truncate = false) const
 */
static PyObject *Dtool_Filename_open_read_write_201(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  {
    // -2 bool Filename::open_read_write(pfstream &stream, bool truncate = false) const
    PyObject *param1;
    PyObject *param2 = Py_False;
    static const char *keyword_list[] = {"stream", "truncate", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_read_write", (char **)keyword_list, &param1, &param2)) {
      pfstream *param1_this = (FileStream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_FileStream, 1, "Filename.open_read_write", false, false);
      if (param1_this != nullptr) {
        bool return_value = ((*(const Filename*)local_this).open_read_write)(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool Filename::open_read_write(std::fstream &stream, bool truncate = false) const
    PyObject *param1;
    PyObject *param2 = Py_False;
    static const char *keyword_list[] = {"stream", "truncate", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_read_write", (char **)keyword_list, &param1, &param2)) {
      std::fstream *param1_this = (std::fstream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_fstream, 1, "Filename.open_read_write", false, false);
      if (param1_this != nullptr) {
        bool return_value = ((*(const Filename*)local_this).open_read_write)(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool Filename::open_read_write(pfstream &stream, bool truncate = false) const
  // No coercion possible: bool Filename::open_read_write(std::fstream &stream, bool truncate = false) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_write(Filename self, FileStream stream, bool truncate)\n"
      "open_read_write(Filename self, fstream stream, bool truncate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_open_read_write_201_comment =
  "C++ Interface:\n"
  "open_read_write(Filename self, FileStream stream, bool truncate)\n"
  "open_read_write(Filename self, fstream stream, bool truncate)\n"
  "\n"
  "/**\n"
  " * Opens the indicated fstream for read/write access to the file, if possible.\n"
  " * Returns true if successful, false otherwise.  This requires the setting of\n"
  " * the set_text()/set_binary() flags to open the file appropriately as\n"
  " * indicated; it is an error to call open_read_write() without first calling\n"
  " * one of set_text() or set_binary().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens the indicated fstream for read/write access to the file, if possible.\n"
  " * Returns true if successful, false otherwise.  This requires the setting of\n"
  " * the set_text()/set_binary() flags to open the file appropriately as\n"
  " * indicated; it is an error to call open_read_write() without first calling\n"
  " * one of set_text() or set_binary().\n"
  " */";
#else
static const char *Dtool_Filename_open_read_write_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::open_read_append(pfstream &stream) const
 * bool Filename::open_read_append(std::fstream &stream) const
 */
static PyObject *Dtool_Filename_open_read_append_202(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  {
    // -2 bool Filename::open_read_append(pfstream &stream) const
    pfstream *arg_this = (FileStream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FileStream, 1, "Filename.open_read_append", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*(const Filename*)local_this).open_read_append)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool Filename::open_read_append(std::fstream &stream) const
    std::fstream *arg_this = (std::fstream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_fstream, 1, "Filename.open_read_append", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*(const Filename*)local_this).open_read_append)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: bool Filename::open_read_append(pfstream &stream) const
  // No coercion possible: bool Filename::open_read_append(std::fstream &stream) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_append(Filename self, FileStream stream)\n"
      "open_read_append(Filename self, fstream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_open_read_append_202_comment =
  "C++ Interface:\n"
  "open_read_append(Filename self, FileStream stream)\n"
  "open_read_append(Filename self, fstream stream)\n"
  "\n"
  "/**\n"
  " * Opens the indicated ifstream for reading and writing the file, if possible;\n"
  " * writes are appended to the end of the file.  Returns true if successful,\n"
  " * false otherwise.  This requires the setting of the set_text()/set_binary()\n"
  " * flags to open the file appropriately as indicated; it is an error to call\n"
  " * open_read() without first calling one of set_text() or set_binary().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens the indicated pfstream for reading and writing the file, if possible;\n"
  " * writes are appended to the end of the file.  Returns true if successful,\n"
  " * false otherwise.  This requires the setting of the set_text()/set_binary()\n"
  " * flags to open the file appropriately as indicated; it is an error to call\n"
  " * open_read() without first calling one of set_text() or set_binary().\n"
  " */";
#else
static const char *Dtool_Filename_open_read_append_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::chdir(void) const
 */
static PyObject *Dtool_Filename_chdir_203(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::chdir(void) const
  bool return_value = ((*(const Filename*)local_this).chdir)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_chdir_203_comment =
  "C++ Interface:\n"
  "chdir(Filename self)\n"
  "\n"
  "/**\n"
  " * Changes directory to the specified location.  Returns true if successful,\n"
  " * false if failure.\n"
  " */";
#else
static const char *Dtool_Filename_chdir_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::touch(void) const
 */
static PyObject *Dtool_Filename_touch_204(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::touch(void) const
  bool return_value = ((*(const Filename*)local_this).touch)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_touch_204_comment =
  "C++ Interface:\n"
  "touch(Filename self)\n"
  "\n"
  "/**\n"
  " * Updates the modification time of the file to the current time.  If the file\n"
  " * does not already exist, it will be created.  Returns true if successful,\n"
  " * false if there is an error.\n"
  " */";
#else
static const char *Dtool_Filename_touch_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::unlink(void) const
 */
static PyObject *Dtool_Filename_unlink_205(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::unlink(void) const
  bool return_value = ((*(const Filename*)local_this).unlink)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_unlink_205_comment =
  "C++ Interface:\n"
  "unlink(Filename self)\n"
  "\n"
  "/**\n"
  " * Permanently deletes the file associated with the filename, if possible.\n"
  " * Returns true if successful, false if failure (for instance, because the\n"
  " * file did not exist, or because permissions were inadequate).\n"
  " */";
#else
static const char *Dtool_Filename_unlink_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::rename_to(Filename const &other) const
 */
static PyObject *Dtool_Filename_rename_to_206(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::rename_to(Filename const &other) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Filename.rename_to", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*(const Filename*)local_this).rename_to)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rename_to(Filename self, const Filename other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_rename_to_206_comment =
  "C++ Interface:\n"
  "rename_to(Filename self, const Filename other)\n"
  "\n"
  "/**\n"
  " * Renames the file to the indicated new filename.  If the new filename is in\n"
  " * a different directory, this will perform a move.  Returns true if\n"
  " * successful, false on failure.\n"
  " */";
#else
static const char *Dtool_Filename_rename_to_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::copy_to(Filename const &other) const
 */
static PyObject *Dtool_Filename_copy_to_207(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::copy_to(Filename const &other) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Filename.copy_to", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*(const Filename*)local_this).copy_to)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_to(Filename self, const Filename other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_copy_to_207_comment =
  "C++ Interface:\n"
  "copy_to(Filename self, const Filename other)\n"
  "\n"
  "/**\n"
  " * Copies the file to the indicated new filename, by reading the contents and\n"
  " * writing it to the new file.  Returns true if successful, false on failure.\n"
  " * The copy is always binary, regardless of the filename settings.\n"
  " */";
#else
static const char *Dtool_Filename_copy_to_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::make_dir(void) const
 */
static PyObject *Dtool_Filename_make_dir_208(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::make_dir(void) const
  bool return_value = ((*(const Filename*)local_this).make_dir)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_make_dir_208_comment =
  "C++ Interface:\n"
  "make_dir(Filename self)\n"
  "\n"
  "/**\n"
  " * Creates all the directories in the path to the file specified in the\n"
  " * filename, except for the basename itself.  This assumes that the Filename\n"
  " * contains the name of a file, not a directory name; it ensures that the\n"
  " * directory containing the file exists.\n"
  " *\n"
  " * However, if the filename ends in a slash, it assumes the Filename\n"
  " * represents the name of a directory, and creates all the paths.\n"
  " */";
#else
static const char *Dtool_Filename_make_dir_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::mkdir(void) const
 */
static PyObject *Dtool_Filename_mkdir_209(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::mkdir(void) const
  bool return_value = ((*(const Filename*)local_this).mkdir)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_mkdir_209_comment =
  "C++ Interface:\n"
  "mkdir(Filename self)\n"
  "\n"
  "/**\n"
  " * Creates the directory named by this filename.  Unlike make_dir(), this\n"
  " * assumes that the Filename contains the directory name itself.  Also, parent\n"
  " * directories are not automatically created; this function fails if any\n"
  " * parent directory is missing.\n"
  " */";
#else
static const char *Dtool_Filename_mkdir_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Filename::rmdir(void) const
 */
static PyObject *Dtool_Filename_rmdir_210(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-bool Filename::rmdir(void) const
  bool return_value = ((*(const Filename*)local_this).rmdir)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_rmdir_210_comment =
  "C++ Interface:\n"
  "rmdir(Filename self)\n"
  "\n"
  "/**\n"
  " * The inverse of mkdir(): this removes the directory named by this Filename,\n"
  " * if it is in fact a directory.\n"
  " */";
#else
static const char *Dtool_Filename_rmdir_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Filename::compare_to(Filename const &other) const
 */
static PyObject *Dtool_Filename_compare_to_214(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline int Filename::compare_to(Filename const &other) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Filename.compare_to", "Filename");
  }
  int return_value = ((*(const Filename*)local_this).compare_to)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(Filename self, const Filename other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_compare_to_214_comment =
  "C++ Interface:\n"
  "compare_to(Filename self, const Filename other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_compare_to_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Filename::get_hash(void) const
 */
static PyObject *Dtool_Filename_get_hash_216(PyObject *self, PyObject *) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-int Filename::get_hash(void) const
  int return_value = ((*(const Filename*)local_this).get_hash)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_hash_216_comment =
  "C++ Interface:\n"
  "get_hash(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns a hash code that attempts to be mostly unique for different\n"
  " * Filenames.\n"
  " */";
#else
static const char *Dtool_Filename_get_hash_216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Filename::output(std::ostream &out) const
 */
static PyObject *Dtool_Filename_output_217(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Filename)) {
    return nullptr;
  }
  // 1-inline void Filename::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Filename.output", false, true);
  if (arg_this != nullptr) {
    ((*(const Filename*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Filename self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_output_217_comment =
  "C++ Interface:\n"
  "output(Filename self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_output_217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void Filename::set_filesystem_encoding(TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_Filename_set_filesystem_encoding_218(PyObject *, PyObject *arg) {
  // 1-static inline void Filename::set_filesystem_encoding(TextEncoder::Encoding encoding)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (Filename::set_filesystem_encoding)((TextEncoder::Encoding)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_filesystem_encoding(int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_filesystem_encoding_218_comment =
  "C++ Interface:\n"
  "set_filesystem_encoding(int encoding)\n"
  "\n"
  "/**\n"
  " * Specifies the default encoding to be used for all subsequent Filenames.\n"
  " * This is used to represent wide-character (Unicode) filenames internally.\n"
  " * On non-Windows-based systems, the encoded filename is also passed to the\n"
  " * underlying operating system.\n"
  " */";
#else
static const char *Dtool_Filename_set_filesystem_encoding_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline TextEncoder::Encoding Filename::get_filesystem_encoding(void)
 */
static PyObject *Dtool_Filename_get_filesystem_encoding_219(PyObject *, PyObject *) {
  // 1-static inline TextEncoder::Encoding Filename::get_filesystem_encoding(void)
  TextEncoder::Encoding return_value = (Filename::get_filesystem_encoding)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_filesystem_encoding_219_comment =
  "C++ Interface:\n"
  "get_filesystem_encoding()\n"
  "\n"
  "/**\n"
  " * Specifies the default encoding to be used for all subsequent Filenames\n"
  " * objects.  See set_filesystem_encoding().\n"
  " */";
#else
static const char *Dtool_Filename_get_filesystem_encoding_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Filename::get_class_type(void)
 */
static PyObject *Dtool_Filename_get_class_type_220(PyObject *, PyObject *) {
  // 1-static TypeHandle Filename::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Filename::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_class_type_220_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Filename_get_class_type_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename::Filename(void)
 * Filename::Filename(Filename const &dirname, Filename const &basename)
 * Filename::Filename(PyObject *path)
 */
static int Dtool_Init_Filename(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Filename::Filename(void)
      Filename *return_value = new Filename();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Filename, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "path")) {
        // 1-Filename::Filename(PyObject *path)
        Filename *result = new Filename;
        invoke_extension(result).__init__(arg);
        Filename *return_value = result;
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Filename, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-Filename::Filename(Filename const &dirname, Filename const &basename)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"dirname", "basename", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:Filename", (char **)keyword_list, &param0, &param1)) {
        Filename param0_local;
        Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "Filename.Filename", "Filename");
          return -1;
        }
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "Filename.Filename", "Filename");
          return -1;
        }
        Filename *return_value = new Filename(*param0_this, *param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Filename, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Filename() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Filename()\n"
      "Filename(object path)\n"
      "Filename(const Filename dirname, const Filename basename)\n");
  }
  return -1;
}

Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  Filename *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_Filename)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const Filename *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Filename::Filename(PyObject *path)
    invoke_extension(&coerced).__init__(arg);
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      return nullptr;
    } else {
      return &coerced;
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-Filename::Filename(Filename const &dirname, Filename const &basename)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "Filename", 2, 2, &param0, &param1)) {
        Filename const *param0_this = nullptr;
        DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
        Filename const *param1_this = nullptr;
        DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
        if (param0_this != nullptr && param1_this != nullptr) {
          coerced = Filename(*param0_this, *param1_this);
          if (_PyErr_OCCURRED()) {
            return nullptr;
          } else {
            return &coerced;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_Filename(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Filename) {
    printf("Filename ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Filename *local_this = (Filename *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Filename) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Filename(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Filename) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PandaSystem
 */
/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_version_string(void)
 */
static PyObject *Dtool_PandaSystem_get_version_string_223(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_version_string(void)
  std::string return_value = (PandaSystem::get_version_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_version_string_223_comment =
  "C++ Interface:\n"
  "get_version_string()\n"
  "\n"
  "/**\n"
  " * Returns the current version of Panda, expressed as a string, e.g.  \"1.0.0\".\n"
  " * The string will end in the letter \"c\" if this build does not represent an\n"
  " * official version.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_version_string_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_package_version_string(void)
 */
static PyObject *Dtool_PandaSystem_get_package_version_string_224(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_package_version_string(void)
  std::string return_value = (PandaSystem::get_package_version_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_package_version_string_224_comment =
  "C++ Interface:\n"
  "get_package_version_string()\n"
  "\n"
  "/**\n"
  " * Returns the version of the Panda3D distributable package that provides this\n"
  " * build of Panda.\n"
  " *\n"
  " * When the currently-executing version of Panda was loaded from a\n"
  " * distributable package, such as via the browser plugin, then this string\n"
  " * will be nonempty and will contain the corresponding version string.  You\n"
  " * can build applications that use this particular version of Panda by\n"
  " * requesting it in the pdef file, using \"panda3d\", this version string, and\n"
  " * the download host provided by get_package_host_url().\n"
  " *\n"
  " * If this string is empty, then the currently-executing Panda was built\n"
  " * independently, and is not part of a distributable package.\n"
  " *\n"
  " * @deprecated Runtime/plugin environment has been removed, this now always\n"
  " * returns an empty string.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_package_version_string_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_package_host_url(void)
 */
static PyObject *Dtool_PandaSystem_get_package_host_url_225(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_package_host_url(void)
  std::string return_value = (PandaSystem::get_package_host_url)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_package_host_url_225_comment =
  "C++ Interface:\n"
  "get_package_host_url()\n"
  "\n"
  "/**\n"
  " * Returns the URL of the download server that provides the Panda3D\n"
  " * distributable package currently running.  This can be used, along with the\n"
  " * get_package_version_string(), to uniquely identify the running version of\n"
  " * Panda among distributable Panda versions.\n"
  " *\n"
  " * See get_package_version_string() for more information.\n"
  " *\n"
  " * This string is set explicitly at compilation time.  Normally, it should be\n"
  " * set to a nonempty string only when building a Panda3D package for\n"
  " * distribution.\n"
  " *\n"
  " * @deprecated Runtime/plugin environment has been removed, this now always\n"
  " * returns an empty string.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_package_host_url_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_p3d_coreapi_version_string(void)
 */
static PyObject *Dtool_PandaSystem_get_p3d_coreapi_version_string_226(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_p3d_coreapi_version_string(void)
  std::string return_value = (PandaSystem::get_p3d_coreapi_version_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_p3d_coreapi_version_string_226_comment =
  "C++ Interface:\n"
  "get_p3d_coreapi_version_string()\n"
  "\n"
  "/**\n"
  " * Returns the current version of Panda's Core API, expressed as a string of\n"
  " * dot-delimited integers.  There are usually four integers in this version,\n"
  " * but this is not guaranteed.\n"
  " *\n"
  " * The Core API is used during the runtime (plugin) environment only.  This\n"
  " * may be the empty string if the current version of Panda is not built to\n"
  " * provide a particular Core API, which will be the normal case in a\n"
  " * development SDK.  However, you should not use this method to determine\n"
  " * whether you are running in a runtime environment or not.\n"
  " *\n"
  " * @deprecated Runtime/plugin environment has been removed, this now always\n"
  " * returns an empty string.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_p3d_coreapi_version_string_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int PandaSystem::get_major_version(void)
 */
static PyObject *Dtool_PandaSystem_get_major_version_227(PyObject *, PyObject *) {
  // 1-static int PandaSystem::get_major_version(void)
  int return_value = (PandaSystem::get_major_version)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_major_version_227_comment =
  "C++ Interface:\n"
  "get_major_version()\n"
  "\n"
  "/**\n"
  " * Returns the major version number of the current version of Panda.  This is\n"
  " * the first number of the dotted triple returned by get_version_string().  It\n"
  " * changes very rarely.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_major_version_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int PandaSystem::get_minor_version(void)
 */
static PyObject *Dtool_PandaSystem_get_minor_version_228(PyObject *, PyObject *) {
  // 1-static int PandaSystem::get_minor_version(void)
  int return_value = (PandaSystem::get_minor_version)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_minor_version_228_comment =
  "C++ Interface:\n"
  "get_minor_version()\n"
  "\n"
  "/**\n"
  " * Returns the minor version number of the current version of Panda.  This is\n"
  " * the second number of the dotted triple returned by get_version_string().\n"
  " * It changes with each release that introduces new features.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_minor_version_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int PandaSystem::get_sequence_version(void)
 */
static PyObject *Dtool_PandaSystem_get_sequence_version_229(PyObject *, PyObject *) {
  // 1-static int PandaSystem::get_sequence_version(void)
  int return_value = (PandaSystem::get_sequence_version)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_sequence_version_229_comment =
  "C++ Interface:\n"
  "get_sequence_version()\n"
  "\n"
  "/**\n"
  " * Returns the sequence version number of the current version of Panda.  This\n"
  " * is the third number of the dotted triple returned by get_version_string().\n"
  " * It changes with bugfix updates and very minor feature updates.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_sequence_version_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool PandaSystem::is_official_version(void)
 */
static PyObject *Dtool_PandaSystem_is_official_version_230(PyObject *, PyObject *) {
  // 1-static bool PandaSystem::is_official_version(void)
  bool return_value = (PandaSystem::is_official_version)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_is_official_version_230_comment =
  "C++ Interface:\n"
  "is_official_version()\n"
  "\n"
  "/**\n"
  " * Returns true if current version of Panda claims to be an \"official\"\n"
  " * version, that is, one that was compiled by an official distributor of Panda\n"
  " * using a specific version of the panda source tree.  If this is true, there\n"
  " * will not be a \"c\" at the end of the version string returned by\n"
  " * get_version_string().\n"
  " *\n"
  " * Note that we must take the distributor's word for it here.\n"
  " */";
#else
static const char *Dtool_PandaSystem_is_official_version_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int PandaSystem::get_memory_alignment(void)
 */
static PyObject *Dtool_PandaSystem_get_memory_alignment_231(PyObject *, PyObject *) {
  // 1-static int PandaSystem::get_memory_alignment(void)
  int return_value = (PandaSystem::get_memory_alignment)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_memory_alignment_231_comment =
  "C++ Interface:\n"
  "get_memory_alignment()\n"
  "\n"
  "/**\n"
  " * Returns the memory alignment that Panda's allocators are using.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_memory_alignment_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_distributor(void)
 */
static PyObject *Dtool_PandaSystem_get_distributor_232(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_distributor(void)
  std::string return_value = (PandaSystem::get_distributor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_distributor_232_comment =
  "C++ Interface:\n"
  "get_distributor()\n"
  "\n"
  "/**\n"
  " * Returns the string defined by the distributor of this version of Panda, or\n"
  " * \"homebuilt\" if this version was built directly from the sources by the end-\n"
  " * user.  This is a completely arbitrary string.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_distributor_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_compiler(void)
 */
static PyObject *Dtool_PandaSystem_get_compiler_233(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_compiler(void)
  std::string return_value = (PandaSystem::get_compiler)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_compiler_233_comment =
  "C++ Interface:\n"
  "get_compiler()\n"
  "\n"
  "/**\n"
  " * Returns a string representing the compiler that was used to generate this\n"
  " * version of Panda, if it is available, or \"unknown\" if it is not.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_compiler_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_build_date(void)
 */
static PyObject *Dtool_PandaSystem_get_build_date_234(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_build_date(void)
  std::string return_value = (PandaSystem::get_build_date)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_build_date_234_comment =
  "C++ Interface:\n"
  "get_build_date()\n"
  "\n"
  "/**\n"
  " * Returns a string representing the date and time at which this version of\n"
  " * Panda (or at least dtool) was compiled, if available.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_build_date_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_git_commit(void)
 */
static PyObject *Dtool_PandaSystem_get_git_commit_235(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_git_commit(void)
  std::string return_value = (PandaSystem::get_git_commit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_git_commit_235_comment =
  "C++ Interface:\n"
  "get_git_commit()\n"
  "\n"
  "/**\n"
  " * Returns a string representing the git commit hash that this source tree is\n"
  " * based on, or the empty string if it has not been specified at build time.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_git_commit_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_platform(void)
 */
static PyObject *Dtool_PandaSystem_get_platform_236(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_platform(void)
  std::string return_value = (PandaSystem::get_platform)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_platform_236_comment =
  "C++ Interface:\n"
  "get_platform()\n"
  "\n"
  "/**\n"
  " * Returns a string representing the runtime platform that we are currently\n"
  " * running on.  This will be something like \"win32\" or \"osx_i386\" or\n"
  " * \"linux_amd64\".\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_platform_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PandaSystem::has_system(std::string const &system) const
 */
static PyObject *Dtool_PandaSystem_has_system_252(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaSystem)) {
    return nullptr;
  }
  // 1-bool PandaSystem::has_system(std::string const &system) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const PandaSystem*)local_this).has_system)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_system(PandaSystem self, str system)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_has_system_252_comment =
  "C++ Interface:\n"
  "has_system(PandaSystem self, str system)\n"
  "\n"
  "/**\n"
  " * Returns true if the current version of Panda claims to have the indicated\n"
  " * subsystem installed, false otherwise.  The set of available subsystems is\n"
  " * implementation defined.\n"
  " */";
#else
static const char *Dtool_PandaSystem_has_system_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t PandaSystem::get_num_systems(void) const
 */
static PyObject *Dtool_PandaSystem_get_num_systems_253(PyObject *self, PyObject *) {
  PandaSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaSystem)) {
    return nullptr;
  }
  // 1-std::size_t PandaSystem::get_num_systems(void) const
  std::size_t return_value = ((*(const PandaSystem*)local_this).get_num_systems)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_num_systems_253_comment =
  "C++ Interface:\n"
  "get_num_systems(PandaSystem self)\n"
  "\n"
  "/**\n"
  " * Returns the number of Panda subsystems that have registered themselves.\n"
  " * This can be used with get_system() to iterate through the entire list of\n"
  " * available Panda subsystems.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_num_systems_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string PandaSystem::get_system(std::size_t n) const
 */
static PyObject *Dtool_PandaSystem_get_system_254(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaSystem)) {
    return nullptr;
  }
  // 1-std::string PandaSystem::get_system(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const PandaSystem*)local_this).get_system)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_system(PandaSystem self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_system_254_comment =
  "C++ Interface:\n"
  "get_system(PandaSystem self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth Panda subsystem that has registered itself.  This list will\n"
  " * be sorted in alphabetical order.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_system_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string PandaSystem::get_system_tag(std::string const &system, std::string const &tag) const
 */
static PyObject *Dtool_PandaSystem_get_system_tag_257(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaSystem)) {
    return nullptr;
  }
  // 1-std::string PandaSystem::get_system_tag(std::string const &system, std::string const &tag) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"system", "tag", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:get_system_tag", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    std::string return_value = ((*(const PandaSystem*)local_this).get_system_tag)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_system_tag(PandaSystem self, str system, str tag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_system_tag_257_comment =
  "C++ Interface:\n"
  "get_system_tag(PandaSystem self, str system, str tag)\n"
  "\n"
  "/**\n"
  " * Returns the value associated with the indicated tag for the given system.\n"
  " * This provides a standard way to query each subsystem's advertised\n"
  " * capabilities.  The set of tags and values are per-system and\n"
  " * implementation-defined.\n"
  " *\n"
  " * The return value is the empty string if the indicated system is undefined\n"
  " * or if does not define the indicated tag.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_system_tag_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaSystem::add_system(std::string const &system)
 */
static PyObject *Dtool_PandaSystem_add_system_258(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaSystem, (void **)&local_this, "PandaSystem.add_system")) {
    return nullptr;
  }
  // 1-void PandaSystem::add_system(std::string const &system)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).add_system)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_system(const PandaSystem self, str system)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_add_system_258_comment =
  "C++ Interface:\n"
  "add_system(const PandaSystem self, str system)\n"
  "\n"
  "/**\n"
  " * Intended for use by each subsystem to register itself at startup.\n"
  " */";
#else
static const char *Dtool_PandaSystem_add_system_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaSystem::set_system_tag(std::string const &system, std::string const &tag, std::string const &value)
 */
static PyObject *Dtool_PandaSystem_set_system_tag_259(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaSystem, (void **)&local_this, "PandaSystem.set_system_tag")) {
    return nullptr;
  }
  // 1-void PandaSystem::set_system_tag(std::string const &system, std::string const &tag, std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"system", "tag", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#:set_system_tag", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len)) {
    ((*local_this).set_system_tag)(std::string(param1_str, param1_len), std::string(param2_str, param2_len), std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_system_tag(const PandaSystem self, str system, str tag, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_set_system_tag_259_comment =
  "C++ Interface:\n"
  "set_system_tag(const PandaSystem self, str system, str tag, str value)\n"
  "\n"
  "/**\n"
  " * Intended for use by each subsystem to register its set of capabilities at\n"
  " * startup.\n"
  " */";
#else
static const char *Dtool_PandaSystem_set_system_tag_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PandaSystem::heap_trim(std::size_t pad)
 */
static PyObject *Dtool_PandaSystem_heap_trim_260(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaSystem, (void **)&local_this, "PandaSystem.heap_trim")) {
    return nullptr;
  }
  // 1-bool PandaSystem::heap_trim(std::size_t pad)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*local_this).heap_trim)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "heap_trim(const PandaSystem self, int pad)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_heap_trim_260_comment =
  "C++ Interface:\n"
  "heap_trim(const PandaSystem self, int pad)\n"
  "\n"
  "/**\n"
  " * Attempts to release memory back to the system, if possible.  The pad\n"
  " * argument is the minimum amount of unused memory to keep in the heap\n"
  " * (against future allocations).  Any memory above that may be released to the\n"
  " * system, reducing the memory size of this process.  There is no guarantee\n"
  " * that any memory may be released.\n"
  " *\n"
  " * Returns true if any memory was actually released, false otherwise.\n"
  " */";
#else
static const char *Dtool_PandaSystem_heap_trim_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaSystem::output(std::ostream &out) const
 */
static PyObject *Dtool_PandaSystem_output_261(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaSystem)) {
    return nullptr;
  }
  // 1-void PandaSystem::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PandaSystem.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PandaSystem*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PandaSystem self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_output_261_comment =
  "C++ Interface:\n"
  "output(PandaSystem self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PandaSystem_output_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PandaSystem::write(std::ostream &out) const
 */
static PyObject *Dtool_PandaSystem_write_262(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PandaSystem)) {
    return nullptr;
  }
  // 1-void PandaSystem::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PandaSystem.write", false, true);
  if (arg_this != nullptr) {
    ((*(const PandaSystem*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PandaSystem self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_write_262_comment =
  "C++ Interface:\n"
  "write(PandaSystem self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PandaSystem_write_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PandaSystem *PandaSystem::get_global_ptr(void)
 */
static PyObject *Dtool_PandaSystem_get_global_ptr_263(PyObject *, PyObject *) {
  // 1-static PandaSystem *PandaSystem::get_global_ptr(void)
  PandaSystem *return_value = (PandaSystem::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PandaSystem, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_global_ptr_263_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns the global PandaSystem object.\n"
  " */";
#else
static const char *Dtool_PandaSystem_get_global_ptr_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PandaSystem::get_class_type(void)
 */
static PyObject *Dtool_PandaSystem_get_class_type_264(PyObject *, PyObject *) {
  // 1-static TypeHandle PandaSystem::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PandaSystem::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_class_type_264_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PandaSystem_get_class_type_264_comment = nullptr;
#endif

static PyObject *Dtool_PandaSystem_version_string_Getter(PyObject *self, void *) {
  // 1-static std::string PandaSystem::get_version_string(void)
  std::string return_value = (PandaSystem::get_version_string)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaSystem_major_version_Getter(PyObject *self, void *) {
  // 1-static int PandaSystem::get_major_version(void)
  int return_value = (PandaSystem::get_major_version)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaSystem_minor_version_Getter(PyObject *self, void *) {
  // 1-static int PandaSystem::get_minor_version(void)
  int return_value = (PandaSystem::get_minor_version)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaSystem_sequence_version_Getter(PyObject *self, void *) {
  // 1-static int PandaSystem::get_sequence_version(void)
  int return_value = (PandaSystem::get_sequence_version)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaSystem_official_version_Getter(PyObject *self, void *) {
  // 1-static bool PandaSystem::is_official_version(void)
  bool return_value = (PandaSystem::is_official_version)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaSystem_memory_alignment_Getter(PyObject *self, void *) {
  // 1-static int PandaSystem::get_memory_alignment(void)
  int return_value = (PandaSystem::get_memory_alignment)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaSystem_distributor_Getter(PyObject *self, void *) {
  // 1-static std::string PandaSystem::get_distributor(void)
  std::string return_value = (PandaSystem::get_distributor)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaSystem_compiler_Getter(PyObject *self, void *) {
  // 1-static std::string PandaSystem::get_compiler(void)
  std::string return_value = (PandaSystem::get_compiler)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaSystem_build_date_Getter(PyObject *self, void *) {
  // 1-static std::string PandaSystem::get_build_date(void)
  std::string return_value = (PandaSystem::get_build_date)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaSystem_git_commit_Getter(PyObject *self, void *) {
  // 1-static std::string PandaSystem::get_git_commit(void)
  std::string return_value = (PandaSystem::get_git_commit)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PandaSystem_platform_Getter(PyObject *self, void *) {
  // 1-static std::string PandaSystem::get_platform(void)
  std::string return_value = (PandaSystem::get_platform)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property PandaSystem::systems
 */
static Py_ssize_t Dtool_PandaSystem_systems_Len(PyObject *self) {
  PandaSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_systems)();
}

/**
 * sequence getter for property PandaSystem::systems
 */
static PyObject *Dtool_PandaSystem_systems_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  PandaSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_systems)()) {
    PyErr_SetString(PyExc_IndexError, "PandaSystem.systems[] index out of range");
    return nullptr;
  }
  // 1-std::string PandaSystem::get_system(std::size_t n) const
  std::string return_value = ((*(const PandaSystem*)local_this).get_system)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_system(PandaSystem self, index)\n");
  }
}

static PyObject *Dtool_PandaSystem_systems_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "PandaSystem.systems");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_PandaSystem_systems_Len;
    wrap->_getitem_func = &Dtool_PandaSystem_systems_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static int Dtool_Init_PandaSystem(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PandaSystem_get_systems(PyObject *self, PyObject *) {
  PandaSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_systems)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PandaSystem_get_system_254(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PandaSystem(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PandaSystem) {
    printf("PandaSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PandaSystem *local_this = (PandaSystem *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PandaSystem) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PandaSystem(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PandaSystem) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DSearchPath
 */
/**
 * Python function wrapper for:
 * Rejected Remap [void DSearchPath::operator =(DSearchPath &&from) = default]
 * void DSearchPath::operator =(DSearchPath const &copy) = default
 */
static PyObject *Dtool_DSearchPath_operator_279(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.assign")) {
    return nullptr;
  }
  // 1-void DSearchPath::operator =(DSearchPath const &copy) = default
  DSearchPath arg_local;
  DSearchPath const *arg_this = Dtool_Coerce_DSearchPath(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.assign", "DSearchPath");
  }
  ((*local_this).operator =)(*arg_this);
  DSearchPath *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const DSearchPath self, const DSearchPath copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_operator_279_comment =
  "C++ Interface:\n"
  "assign(const DSearchPath self, const DSearchPath copy)\n";
#else
static const char *Dtool_DSearchPath_operator_279_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::clear(void)
 */
static PyObject *Dtool_DSearchPath_clear_280(PyObject *self, PyObject *) {
  DSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.clear")) {
    return nullptr;
  }
  // 1-void DSearchPath::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_clear_280_comment =
  "C++ Interface:\n"
  "clear(const DSearchPath self)\n"
  "\n"
  "/**\n"
  " * Removes all the directories from the search list.\n"
  " */";
#else
static const char *Dtool_DSearchPath_clear_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::append_directory(Filename const &directory)
 */
static PyObject *Dtool_DSearchPath_append_directory_281(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.append_directory")) {
    return nullptr;
  }
  // 1-void DSearchPath::append_directory(Filename const &directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.append_directory", "Filename");
  }
  ((*local_this).append_directory)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_directory(const DSearchPath self, const Filename directory)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_append_directory_281_comment =
  "C++ Interface:\n"
  "append_directory(const DSearchPath self, const Filename directory)\n"
  "\n"
  "/**\n"
  " * Adds a new directory to the end of the search list.\n"
  " */";
#else
static const char *Dtool_DSearchPath_append_directory_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::prepend_directory(Filename const &directory)
 */
static PyObject *Dtool_DSearchPath_prepend_directory_282(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.prepend_directory")) {
    return nullptr;
  }
  // 1-void DSearchPath::prepend_directory(Filename const &directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.prepend_directory", "Filename");
  }
  ((*local_this).prepend_directory)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepend_directory(const DSearchPath self, const Filename directory)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_prepend_directory_282_comment =
  "C++ Interface:\n"
  "prepend_directory(const DSearchPath self, const Filename directory)\n"
  "\n"
  "/**\n"
  " * Adds a new directory to the front of the search list.\n"
  " */";
#else
static const char *Dtool_DSearchPath_prepend_directory_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::append_path(DSearchPath const &path)
 * void DSearchPath::append_path(std::string const &path, std::string const &separator = string())
 */
static PyObject *Dtool_DSearchPath_append_path_283(PyObject *self, PyObject *args, PyObject *kwds) {
  DSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.append_path")) {
    return nullptr;
  }
  {
    // -2 void DSearchPath::append_path(std::string const &path, std::string const &separator = string())
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    static const char *keyword_list[] = {"path", "separator", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:append_path", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
      ((*local_this).append_path)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: void DSearchPath::append_path(std::string const &path, std::string const &separator = string())
  {
    // -2 void DSearchPath::append_path(DSearchPath const &path)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "path")) {
      DSearchPath param1_local;
      DSearchPath const *param1_this = Dtool_Coerce_DSearchPath(param1, param1_local);
      if ((param1_this != nullptr)) {
        ((*local_this).append_path)(*param1_this);
        return Dtool_Return_None();
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_path(const DSearchPath self, str path, str separator)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_append_path_283_comment =
  "C++ Interface:\n"
  "append_path(const DSearchPath self, str path, str separator)\n"
  "\n"
  "/**\n"
  " * Adds all of the directories listed in the search path to the end of the\n"
  " * search list.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds all of the directories listed in the search path to the end of the\n"
  " * search list.\n"
  " */";
#else
static const char *Dtool_DSearchPath_append_path_283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::prepend_path(DSearchPath const &path)
 */
static PyObject *Dtool_DSearchPath_prepend_path_284(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.prepend_path")) {
    return nullptr;
  }
  // 1-void DSearchPath::prepend_path(DSearchPath const &path)
  DSearchPath arg_local;
  DSearchPath const *arg_this = Dtool_Coerce_DSearchPath(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.prepend_path", "DSearchPath");
  }
  ((*local_this).prepend_path)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepend_path(const DSearchPath self, const DSearchPath path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_prepend_path_284_comment =
  "C++ Interface:\n"
  "prepend_path(const DSearchPath self, const DSearchPath path)\n"
  "\n"
  "/**\n"
  " * Adds all of the directories listed in the search path to the beginning of\n"
  " * the search list.\n"
  " */";
#else
static const char *Dtool_DSearchPath_prepend_path_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DSearchPath::is_empty(void) const
 */
static PyObject *Dtool_DSearchPath_is_empty_285(PyObject *self, PyObject *) {
  DSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DSearchPath)) {
    return nullptr;
  }
  // 1-bool DSearchPath::is_empty(void) const
  bool return_value = ((*(const DSearchPath*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_is_empty_285_comment =
  "C++ Interface:\n"
  "is_empty(DSearchPath self)\n"
  "\n"
  "/**\n"
  " * Returns true if the search list is empty, false otherwise.\n"
  " */";
#else
static const char *Dtool_DSearchPath_is_empty_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t DSearchPath::get_num_directories(void) const
 */
static PyObject *Dtool_DSearchPath_get_num_directories_286(PyObject *self, PyObject *) {
  DSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DSearchPath)) {
    return nullptr;
  }
  // 1-std::size_t DSearchPath::get_num_directories(void) const
  std::size_t return_value = ((*(const DSearchPath*)local_this).get_num_directories)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_get_num_directories_286_comment =
  "C++ Interface:\n"
  "get_num_directories(DSearchPath self)\n"
  "\n"
  "/**\n"
  " * Returns the number of directories on the search list.\n"
  " */";
#else
static const char *Dtool_DSearchPath_get_num_directories_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Filename const &DSearchPath::get_directory(std::size_t n) const
 */
static PyObject *Dtool_DSearchPath_get_directory_287(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DSearchPath)) {
    return nullptr;
  }
  // 1-Filename const &DSearchPath::get_directory(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    Filename const *return_value = &(((*(const DSearchPath*)local_this).get_directory)(arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_directory(DSearchPath self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_get_directory_287_comment =
  "C++ Interface:\n"
  "get_directory(DSearchPath self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth directory on the search list.\n"
  " */";
#else
static const char *Dtool_DSearchPath_get_directory_287_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Filename DSearchPath::find_file(Filename const &filename) const
 */
static PyObject *Dtool_DSearchPath_find_file_291(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DSearchPath)) {
    return nullptr;
  }
  // 1-Filename DSearchPath::find_file(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.find_file", "Filename");
  }
  Filename *return_value = new Filename(((*(const DSearchPath*)local_this).find_file)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_file(DSearchPath self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_find_file_291_comment =
  "C++ Interface:\n"
  "find_file(DSearchPath self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Searches all the directories in the search list for the indicated file, in\n"
  " * order.  Returns the full matching pathname of the first match if found, or\n"
  " * the empty string if not found.\n"
  " */";
#else
static const char *Dtool_DSearchPath_find_file_291_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DSearchPath::Results DSearchPath::find_all_files(Filename const &filename) const
 * std::size_t DSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
 */
static PyObject *Dtool_DSearchPath_find_all_files_292(PyObject *self, PyObject *args, PyObject *kwds) {
  DSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DSearchPath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "filename")) {
        // 1-inline DSearchPath::Results DSearchPath::find_all_files(Filename const &filename) const
        Filename arg_local;
        Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.find_all_files", "Filename");
        }
        DSearchPath::Results *return_value = new DSearchPath::Results(((*(const DSearchPath*)local_this).find_all_files)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath_Results, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-std::size_t DSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"filename", "results", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:find_all_files", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "DSearchPath.find_all_files", "Filename");
        }
        DSearchPath::Results *param2_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_DSearchPath_Results, 2, "DSearchPath.find_all_files", false, true);
        if (param2_this != nullptr) {
          std::size_t return_value = ((*(const DSearchPath*)local_this).find_all_files)(*param1_this, *param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "find_all_files() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_files(DSearchPath self, const Filename filename)\n"
      "find_all_files(DSearchPath self, const Filename filename, Results results)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_find_all_files_292_comment =
  "C++ Interface:\n"
  "find_all_files(DSearchPath self, const Filename filename)\n"
  "find_all_files(DSearchPath self, const Filename filename, Results results)\n"
  "\n"
  "/**\n"
  " * This variant of find_all_files() returns the new Results object, instead of\n"
  " * filling on in on the parameter list.  This is a little more convenient to\n"
  " * call from Python.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Searches all the directories in the search list for the indicated file, in\n"
  " * order.  Fills up the results list with *all* of the matching filenames\n"
  " * found, if any.  Returns the number of matches found.\n"
  " *\n"
  " * It is the responsibility of the the caller to clear the results list first;\n"
  " * otherwise, the newly-found files will be appended to the list.\n"
  " */";
#else
static const char *Dtool_DSearchPath_find_all_files_292_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Filename DSearchPath::search_path(Filename const &filename, std::string const &path, std::string const &separator = string())
 */
static PyObject *Dtool_DSearchPath_search_path_293(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline Filename DSearchPath::search_path(Filename const &filename, std::string const &path, std::string const &separator = string())
  PyObject *param0;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"filename", "path", "separator", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#|s#:search_path", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2_str, &param2_len)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "DSearchPath.search_path", "Filename");
    }
    Filename *return_value = new Filename((DSearchPath::search_path)(*param0_this, std::string(param1_str, param1_len), std::string(param2_str, param2_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "search_path(const Filename filename, str path, str separator)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_search_path_293_comment =
  "C++ Interface:\n"
  "search_path(const Filename filename, str path, str separator)\n"
  "\n"
  "/**\n"
  " * A quick-and-easy way to search a searchpath for a file when you don't feel\n"
  " * like building or keeping around a DSearchPath object.  This simply\n"
  " * constructs a temporary DSearchPath based on the indicated path string, and\n"
  " * searches that.\n"
  " */";
#else
static const char *Dtool_DSearchPath_search_path_293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::output(std::ostream &out, std::string const &separator = string()) const
 */
static PyObject *Dtool_DSearchPath_output_294(PyObject *self, PyObject *args, PyObject *kwds) {
  DSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DSearchPath)) {
    return nullptr;
  }
  // 1-void DSearchPath::output(std::ostream &out, std::string const &separator = string()) const
  PyObject *param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"out", "separator", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:output", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DSearchPath.output", false, true);
    if (param1_this != nullptr) {
      ((*(const DSearchPath*)local_this).output)(*param1_this, std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DSearchPath self, ostream out, str separator)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_output_294_comment =
  "C++ Interface:\n"
  "output(DSearchPath self, ostream out, str separator)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DSearchPath_output_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_DSearchPath_write_295(PyObject *self, PyObject *args, PyObject *kwds) {
  DSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DSearchPath)) {
    return nullptr;
  }
  // 1-void DSearchPath::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DSearchPath.write", false, true);
    if (param1_this != nullptr) {
      ((*(const DSearchPath*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DSearchPath self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_write_295_comment =
  "C++ Interface:\n"
  "write(DSearchPath self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DSearchPath_write_295_comment = nullptr;
#endif

/**
 * sequence length function for property DSearchPath::directories
 */
static Py_ssize_t Dtool_DSearchPath_directories_Len(PyObject *self) {
  DSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_directories)();
}

/**
 * sequence getter for property DSearchPath::directories
 */
static PyObject *Dtool_DSearchPath_directories_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  DSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_directories)()) {
    PyErr_SetString(PyExc_IndexError, "DSearchPath.directories[] index out of range");
    return nullptr;
  }
  // 1-Filename const &DSearchPath::get_directory(std::size_t n) const
  Filename const *return_value = &(((*(const DSearchPath*)local_this).get_directory)(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_directory(DSearchPath self, index)\n");
  }
}

static PyObject *Dtool_DSearchPath_directories_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "DSearchPath.directories");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_DSearchPath_directories_Len;
    wrap->_getitem_func = &Dtool_DSearchPath_directories_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * DSearchPath::DSearchPath(void) = default
 * Rejected Remap [DSearchPath::DSearchPath(DSearchPath &&from) = default]
 * DSearchPath::DSearchPath(DSearchPath const &copy) = default
 * DSearchPath::DSearchPath(Filename const &directory)
 * DSearchPath::DSearchPath(std::string const &path, std::string const &separator = string())
 */
static int Dtool_Init_DSearchPath(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-DSearchPath::DSearchPath(void) = default
      DSearchPath *return_value = new DSearchPath();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 DSearchPath::DSearchPath(std::string const &path, std::string const &separator = string())
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        const char *param1_str = "";
        Py_ssize_t param1_len = 0;
        static const char *keyword_list[] = {"path", "separator", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:DSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
          DSearchPath *return_value = new DSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 DSearchPath::DSearchPath(DSearchPath const &copy) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          DSearchPath const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_DSearchPath);
          if (param0_this != nullptr) {
            DSearchPath *return_value = new DSearchPath(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
          }
        }
      }

      {
        // -2 DSearchPath::DSearchPath(Filename const &directory)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "directory")) {
          Filename const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
          if (param0_this != nullptr) {
            DSearchPath *return_value = new DSearchPath(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
          }
        }
      }

      // No coercion possible: DSearchPath::DSearchPath(std::string const &path, std::string const &separator = string())
      {
        // -2 DSearchPath::DSearchPath(DSearchPath const &copy) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          DSearchPath param0_local;
          DSearchPath const *param0_this = Dtool_Coerce_DSearchPath(param0, param0_local);
          if ((param0_this != nullptr)) {
            DSearchPath *return_value = new DSearchPath(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
          }
        }
      }

      {
        // -2 DSearchPath::DSearchPath(Filename const &directory)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "directory")) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          if ((param0_this != nullptr)) {
            DSearchPath *return_value = new DSearchPath(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
          }
        }
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DSearchPath() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DSearchPath()\n"
      "DSearchPath(str path, str separator)\n"
      "DSearchPath(const DSearchPath copy)\n"
      "DSearchPath(const Filename directory)\n");
  }
  return -1;
}

DSearchPath *Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath &coerced) {
  DSearchPath *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_DSearchPath)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const DSearchPath *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 DSearchPath::DSearchPath(std::string const &path, std::string const &separator)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
        param0_str = nullptr;
      }
#endif
      if (param0_str != nullptr) {
        coerced = DSearchPath(std::string(param0_str, param0_len));
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 DSearchPath::DSearchPath(Filename const &directory)
      Filename const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
      if (arg_this != nullptr) {
        coerced = DSearchPath(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-DSearchPath::DSearchPath(std::string const &path, std::string const &separator)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "s#s#:DSearchPath", &param0_str, &param0_len, &param1_str, &param1_len)) {
        coerced = DSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return nullptr;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_DSearchPath_get_directories(PyObject *self, PyObject *) {
  DSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_directories)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_DSearchPath_get_directory_287(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_DSearchPath(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DSearchPath) {
    printf("DSearchPath ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DSearchPath *local_this = (DSearchPath *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DSearchPath) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DSearchPath(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DSearchPath) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DSearchPath::Results
 */
/**
 * Python function wrapper for:
 * void DSearchPath::Results::operator =(DSearchPath::Results const &copy)
 */
static PyObject *Dtool_DSearchPath_Results_operator_268(PyObject *self, PyObject *arg) {
  DSearchPath::Results *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath_Results, (void **)&local_this, "DSearchPath::Results.assign")) {
    return nullptr;
  }
  // 1-void DSearchPath::Results::operator =(DSearchPath::Results const &copy)
  DSearchPath::Results const *arg_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DSearchPath_Results, 1, "Results.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    DSearchPath::Results *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath_Results, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Results self, const Results copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_operator_268_comment =
  "C++ Interface:\n"
  "assign(const Results self, const Results copy)\n";
#else
static const char *Dtool_DSearchPath_Results_operator_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::Results::clear(void)
 */
static PyObject *Dtool_DSearchPath_Results_clear_270(PyObject *self, PyObject *) {
  DSearchPath::Results *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath_Results, (void **)&local_this, "DSearchPath::Results.clear")) {
    return nullptr;
  }
  // 1-void DSearchPath::Results::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_clear_270_comment =
  "C++ Interface:\n"
  "clear(const Results self)\n"
  "\n"
  "/**\n"
  " * Removes all the files from the list.\n"
  " */";
#else
static const char *Dtool_DSearchPath_Results_clear_270_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t DSearchPath::Results::get_num_files(void) const
 */
static PyObject *Dtool_DSearchPath_Results_get_num_files_271(PyObject *self, PyObject *) {
  DSearchPath::Results *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DSearchPath_Results)) {
    return nullptr;
  }
  // 1-std::size_t DSearchPath::Results::get_num_files(void) const
  std::size_t return_value = ((*(const DSearchPath::Results*)local_this).get_num_files)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_get_num_files_271_comment =
  "C++ Interface:\n"
  "get_num_files(Results self)\n"
  "\n"
  "/**\n"
  " * Returns the number of files on the result list.\n"
  " */";
#else
static const char *Dtool_DSearchPath_Results_get_num_files_271_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Filename const &DSearchPath::Results::get_file(std::size_t n) const
 */
static PyObject *Dtool_DSearchPath_Results_get_file_272(PyObject *self, PyObject *arg) {
  DSearchPath::Results *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DSearchPath_Results)) {
    return nullptr;
  }
  // 1-Filename const &DSearchPath::Results::get_file(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    Filename const *return_value = &(((*(const DSearchPath::Results*)local_this).get_file)(arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_file(Results self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_get_file_272_comment =
  "C++ Interface:\n"
  "get_file(Results self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth file on the result list.\n"
  " */";
#else
static const char *Dtool_DSearchPath_Results_get_file_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::Results::output(std::ostream &out) const
 */
static PyObject *Dtool_DSearchPath_Results_output_275(PyObject *self, PyObject *arg) {
  DSearchPath::Results *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DSearchPath_Results)) {
    return nullptr;
  }
  // 1-void DSearchPath::Results::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Results.output", false, true);
  if (arg_this != nullptr) {
    ((*(const DSearchPath::Results*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Results self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_output_275_comment =
  "C++ Interface:\n"
  "output(Results self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DSearchPath_Results_output_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::Results::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_DSearchPath_Results_write_276(PyObject *self, PyObject *args, PyObject *kwds) {
  DSearchPath::Results *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DSearchPath_Results)) {
    return nullptr;
  }
  // 1-void DSearchPath::Results::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Results.write", false, true);
    if (param1_this != nullptr) {
      ((*(const DSearchPath::Results*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(Results self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_write_276_comment =
  "C++ Interface:\n"
  "write(Results self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DSearchPath_Results_write_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DSearchPath::Results::Results(void)
 * DSearchPath::Results::Results(DSearchPath::Results const &copy)
 */
static int Dtool_Init_DSearchPath_Results(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-DSearchPath::Results::Results(void)
      DSearchPath::Results *return_value = new DSearchPath::Results();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath_Results, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-DSearchPath::Results::Results(DSearchPath::Results const &copy)
        DSearchPath::Results const *arg_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DSearchPath_Results, 0, "Results.Results", true, true);
        if (arg_this != nullptr) {
          DSearchPath::Results *return_value = new DSearchPath::Results(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath_Results, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Results() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Results()\n"
      "Results(const Results copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DSearchPath_Results(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DSearchPath_Results) {
    printf("DSearchPath_Results ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DSearchPath::Results *local_this = (DSearchPath::Results *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DSearchPath_Results) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DSearchPath_Results(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DSearchPath_Results) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ExecutionEnvironment
 */
/**
 * Python function wrapper for:
 * static inline bool ExecutionEnvironment::has_environment_variable(std::string const &var)
 */
static PyObject *Dtool_ExecutionEnvironment_has_environment_variable_297(PyObject *, PyObject *arg) {
  // 1-static inline bool ExecutionEnvironment::has_environment_variable(std::string const &var)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    bool return_value = (ExecutionEnvironment::has_environment_variable)(std::string(param0_str, param0_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_environment_variable(str var)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_has_environment_variable_297_comment =
  "C++ Interface:\n"
  "has_environment_variable(str var)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated environment variable is defined.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_has_environment_variable_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string ExecutionEnvironment::get_environment_variable(std::string const &var)
 */
static PyObject *Dtool_ExecutionEnvironment_get_environment_variable_298(PyObject *, PyObject *arg) {
  // 1-static inline std::string ExecutionEnvironment::get_environment_variable(std::string const &var)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    std::string return_value = (ExecutionEnvironment::get_environment_variable)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_environment_variable(str var)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_environment_variable_298_comment =
  "C++ Interface:\n"
  "get_environment_variable(str var)\n"
  "\n"
  "/**\n"
  " * Returns the definition of the indicated environment variable, or the empty\n"
  " * string if the variable is undefined.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_get_environment_variable_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ExecutionEnvironment::set_environment_variable(std::string const &var, std::string const &value)
 */
static PyObject *Dtool_ExecutionEnvironment_set_environment_variable_299(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline void ExecutionEnvironment::set_environment_variable(std::string const &var, std::string const &value)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"var", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:set_environment_variable", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    (ExecutionEnvironment::set_environment_variable)(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_environment_variable(str var, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_set_environment_variable_299_comment =
  "C++ Interface:\n"
  "set_environment_variable(str var, str value)\n"
  "\n"
  "/**\n"
  " * Changes the definition of the indicated environment variable.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_set_environment_variable_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ExecutionEnvironment::shadow_environment_variable(std::string const &var, std::string const &value)
 */
static PyObject *Dtool_ExecutionEnvironment_shadow_environment_variable_300(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline void ExecutionEnvironment::shadow_environment_variable(std::string const &var, std::string const &value)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"var", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:shadow_environment_variable", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    (ExecutionEnvironment::shadow_environment_variable)(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "shadow_environment_variable(str var, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_shadow_environment_variable_300_comment =
  "C++ Interface:\n"
  "shadow_environment_variable(str var, str value)\n"
  "\n"
  "/**\n"
  " * Changes the apparent definition of the indicated environment variable by\n"
  " * masking it within this class with a new value.  This does not change the\n"
  " * actual environment variable, but future calls to get_environment_variable()\n"
  " * will return this new value.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_shadow_environment_variable_300_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ExecutionEnvironment::clear_shadow(std::string const &var)
 */
static PyObject *Dtool_ExecutionEnvironment_clear_shadow_301(PyObject *, PyObject *arg) {
  // 1-static inline void ExecutionEnvironment::clear_shadow(std::string const &var)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    (ExecutionEnvironment::clear_shadow)(std::string(param0_str, param0_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_shadow(str var)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_clear_shadow_301_comment =
  "C++ Interface:\n"
  "clear_shadow(str var)\n"
  "\n"
  "/**\n"
  " * Removes a value set by a previous call to shadow_environment_variable(),\n"
  " * and lets the actual value of the variable show again.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_clear_shadow_301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string ExecutionEnvironment::expand_string(std::string const &str)
 */
static PyObject *Dtool_ExecutionEnvironment_expand_string_302(PyObject *, PyObject *arg) {
  // 1-static std::string ExecutionEnvironment::expand_string(std::string const &str)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    std::string return_value = (ExecutionEnvironment::expand_string)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "expand_string(str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_expand_string_302_comment =
  "C++ Interface:\n"
  "expand_string(str str)\n"
  "\n"
  "/**\n"
  " * Reads the string, looking for environment variable names marked by a $.\n"
  " * Expands all such variable names.  A repeated dollar sign ($$) is mapped to\n"
  " * a single dollar sign.\n"
  " *\n"
  " * Returns the expanded string.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_expand_string_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t ExecutionEnvironment::get_num_args(void)
 */
static PyObject *Dtool_ExecutionEnvironment_get_num_args_303(PyObject *, PyObject *) {
  // 1-static inline std::size_t ExecutionEnvironment::get_num_args(void)
  std::size_t return_value = (ExecutionEnvironment::get_num_args)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_num_args_303_comment =
  "C++ Interface:\n"
  "get_num_args()\n"
  "\n"
  "/**\n"
  " * Returns the number of command-line arguments available, not counting arg 0,\n"
  " * the binary name.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_get_num_args_303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string ExecutionEnvironment::get_arg(std::size_t n)
 */
static PyObject *Dtool_ExecutionEnvironment_get_arg_304(PyObject *, PyObject *arg) {
  // 1-static inline std::string ExecutionEnvironment::get_arg(std::size_t n)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = (ExecutionEnvironment::get_arg)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_arg(int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_arg_304_comment =
  "C++ Interface:\n"
  "get_arg(int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth command-line argument.  The index n must be in the range [0\n"
  " * .. get_num_args()).  The first parameter, n == 0, is the first actual\n"
  " * parameter, not the binary name.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_get_arg_304_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string ExecutionEnvironment::get_binary_name(void)
 */
static PyObject *Dtool_ExecutionEnvironment_get_binary_name_305(PyObject *, PyObject *) {
  // 1-static inline std::string ExecutionEnvironment::get_binary_name(void)
  std::string return_value = (ExecutionEnvironment::get_binary_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_binary_name_305_comment =
  "C++ Interface:\n"
  "get_binary_name()\n"
  "\n"
  "/**\n"
  " * Returns the name of the binary executable that started this program, if it\n"
  " * can be determined.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_get_binary_name_305_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string ExecutionEnvironment::get_dtool_name(void)
 */
static PyObject *Dtool_ExecutionEnvironment_get_dtool_name_306(PyObject *, PyObject *) {
  // 1-static inline std::string ExecutionEnvironment::get_dtool_name(void)
  std::string return_value = (ExecutionEnvironment::get_dtool_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_dtool_name_306_comment =
  "C++ Interface:\n"
  "get_dtool_name()\n"
  "\n"
  "/**\n"
  " * Returns the name of the libdtool DLL that is used in this program, if it\n"
  " * can be determined.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_get_dtool_name_306_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ExecutionEnvironment::set_binary_name(std::string const &name)
 */
static PyObject *Dtool_ExecutionEnvironment_set_binary_name_307(PyObject *, PyObject *arg) {
  // 1-static inline void ExecutionEnvironment::set_binary_name(std::string const &name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    (ExecutionEnvironment::set_binary_name)(std::string(param0_str, param0_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_binary_name(str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_set_binary_name_307_comment =
  "C++ Interface:\n"
  "set_binary_name(str name)\n"
  "\n"
  "/**\n"
  " * Do not use.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_set_binary_name_307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void ExecutionEnvironment::set_dtool_name(std::string const &name)
 */
static PyObject *Dtool_ExecutionEnvironment_set_dtool_name_308(PyObject *, PyObject *arg) {
  // 1-static inline void ExecutionEnvironment::set_dtool_name(std::string const &name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    (ExecutionEnvironment::set_dtool_name)(std::string(param0_str, param0_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dtool_name(str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_set_dtool_name_308_comment =
  "C++ Interface:\n"
  "set_dtool_name(str name)\n"
  "\n"
  "/**\n"
  " * Do not use.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_set_dtool_name_308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Filename ExecutionEnvironment::get_cwd(void)
 */
static PyObject *Dtool_ExecutionEnvironment_get_cwd_309(PyObject *, PyObject *) {
  // 1-static Filename ExecutionEnvironment::get_cwd(void)
  Filename *return_value = new Filename((ExecutionEnvironment::get_cwd)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_cwd_309_comment =
  "C++ Interface:\n"
  "get_cwd()\n"
  "\n"
  "/**\n"
  " * Returns the name of the current working directory.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_get_cwd_309_comment = nullptr;
#endif

/**
 * mapping getitem for property ExecutionEnvironment::environment_variables
 */
static PyObject *Dtool_ExecutionEnvironment_environment_variables_Mapping_Getitem(PyObject *self, PyObject *arg) {
  {
    // 1-static inline bool ExecutionEnvironment::has_environment_variable(std::string const &var)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      bool return_value = (ExecutionEnvironment::has_environment_variable)(std::string(param0_str, param0_len));
      if (!return_value) {
        PyErr_SetObject(PyExc_KeyError, arg);
        return nullptr;
      }
    }
  }
  // 1-static inline std::string ExecutionEnvironment::get_environment_variable(std::string const &var)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    std::string return_value = (ExecutionEnvironment::get_environment_variable)(std::string(param0_str, param0_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_environment_variable(str var)\n");
  }
  return nullptr;
}

/**
 * mapping setitem for property ExecutionEnvironment::environment_variables
 */
static int Dtool_ExecutionEnvironment_environment_variables_Mapping_Setitem(PyObject *self, PyObject *key, PyObject *value) {
  if (value == nullptr) {
    Dtool_Raise_TypeError("can't delete environment_variables[] attribute");
    return -1;
  }
  PyObject *args = PyTuple_New(2);
  PyTuple_SET_ITEM(args, 0, key);
  PyTuple_SET_ITEM(args, 1, value);
  Py_INCREF(key);
  Py_INCREF(value);
  // 1-static inline void ExecutionEnvironment::set_environment_variable(std::string const &var, std::string const &value)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyArg_ParseTuple(args, "s#s#:set_environment_variable", &param0_str, &param0_len, &param1_str, &param1_len)) {
    (ExecutionEnvironment::set_environment_variable)(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    Py_DECREF(args);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_environment_variable(str var, str value)\n");
  }
  Py_DECREF(args);
  return -1;
}

static PyObject *Dtool_ExecutionEnvironment_environment_variables_Getter(PyObject *self, void *) {
  Dtool_MappingWrapper *wrap = Dtool_NewMutableMappingWrapper(self, "ExecutionEnvironment.environment_variables");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_ExecutionEnvironment_environment_variables_Mapping_Getitem;
    {
      wrap->_setitem_func = &Dtool_ExecutionEnvironment_environment_variables_Mapping_Setitem;
    }
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property ExecutionEnvironment::args
 */
static Py_ssize_t Dtool_ExecutionEnvironment_args_Len(PyObject *self) {
  return (Py_ssize_t)(ExecutionEnvironment::get_num_args)();
}

/**
 * sequence getter for property ExecutionEnvironment::args
 */
static PyObject *Dtool_ExecutionEnvironment_args_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  if (index < 0 || index >= (Py_ssize_t)(ExecutionEnvironment::get_num_args)()) {
    PyErr_SetString(PyExc_IndexError, "ExecutionEnvironment.args[] index out of range");
    return nullptr;
  }
  // 1-static inline std::string ExecutionEnvironment::get_arg(std::size_t n)
  std::string return_value = (ExecutionEnvironment::get_arg)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_arg(index)\n");
  }
}

static PyObject *Dtool_ExecutionEnvironment_args_Getter(PyObject *self, void *) {
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "ExecutionEnvironment.args");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ExecutionEnvironment_args_Len;
    wrap->_getitem_func = &Dtool_ExecutionEnvironment_args_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_ExecutionEnvironment_binary_name_Getter(PyObject *self, void *) {
  // 1-static inline std::string ExecutionEnvironment::get_binary_name(void)
  std::string return_value = (ExecutionEnvironment::get_binary_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ExecutionEnvironment_binary_name_Setter(PyObject *self, PyObject *arg, void *) {
  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete binary_name attribute");
    return -1;
  }
  // 1-static inline void ExecutionEnvironment::set_binary_name(std::string const &name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    (ExecutionEnvironment::set_binary_name)(std::string(param0_str, param0_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_binary_name(str name)\n");
  }
  return -1;
}

static PyObject *Dtool_ExecutionEnvironment_dtool_name_Getter(PyObject *self, void *) {
  // 1-static inline std::string ExecutionEnvironment::get_dtool_name(void)
  std::string return_value = (ExecutionEnvironment::get_dtool_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ExecutionEnvironment_dtool_name_Setter(PyObject *self, PyObject *arg, void *) {
  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete dtool_name attribute");
    return -1;
  }
  // 1-static inline void ExecutionEnvironment::set_dtool_name(std::string const &name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    (ExecutionEnvironment::set_dtool_name)(std::string(param0_str, param0_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dtool_name(str name)\n");
  }
  return -1;
}

static PyObject *Dtool_ExecutionEnvironment_cwd_Getter(PyObject *self, void *) {
  // 1-static Filename ExecutionEnvironment::get_cwd(void)
  Filename *return_value = new Filename((ExecutionEnvironment::get_cwd)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

/**
 * Python function wrapper for:
 * inline ExecutionEnvironment::ExecutionEnvironment(ExecutionEnvironment const &) = default
 */
static int Dtool_Init_ExecutionEnvironment(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ExecutionEnvironment() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline ExecutionEnvironment::ExecutionEnvironment(ExecutionEnvironment const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    ExecutionEnvironment const *param0_this = (ExecutionEnvironment *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ExecutionEnvironment, 0, "ExecutionEnvironment.ExecutionEnvironment", true, true);
    if (param0_this != nullptr) {
      ExecutionEnvironment *return_value = new ExecutionEnvironment(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ExecutionEnvironment, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ExecutionEnvironment(const ExecutionEnvironment param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ExecutionEnvironment(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ExecutionEnvironment) {
    printf("ExecutionEnvironment ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ExecutionEnvironment *local_this = (ExecutionEnvironment *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ExecutionEnvironment) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ExecutionEnvironment(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ExecutionEnvironment) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GlobPattern
 */
/**
 * Python function wrapper for:
 * inline void GlobPattern::operator =(GlobPattern const &copy)
 */
static PyObject *Dtool_GlobPattern_operator_319(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.assign")) {
    return nullptr;
  }
  // 1-inline void GlobPattern::operator =(GlobPattern const &copy)
  GlobPattern arg_local;
  GlobPattern const *arg_this = Dtool_Coerce_GlobPattern(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GlobPattern.assign", "GlobPattern");
  }
  ((*local_this).operator =)(*arg_this);
  GlobPattern *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GlobPattern, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GlobPattern self, const GlobPattern copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_operator_319_comment =
  "C++ Interface:\n"
  "assign(const GlobPattern self, const GlobPattern copy)\n";
#else
static const char *Dtool_GlobPattern_operator_319_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GlobPattern::set_pattern(std::string const &pattern)
 */
static PyObject *Dtool_GlobPattern_set_pattern_323(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.set_pattern")) {
    return nullptr;
  }
  // 1-inline void GlobPattern::set_pattern(std::string const &pattern)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_pattern)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pattern(const GlobPattern self, str pattern)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_set_pattern_323_comment =
  "C++ Interface:\n"
  "set_pattern(const GlobPattern self, str pattern)\n"
  "\n"
  "/**\n"
  " * Changes the pattern string that the GlobPattern object matches.\n"
  " */";
#else
static const char *Dtool_GlobPattern_set_pattern_323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &GlobPattern::get_pattern(void) const
 */
static PyObject *Dtool_GlobPattern_get_pattern_324(PyObject *self, PyObject *) {
  GlobPattern *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GlobPattern)) {
    return nullptr;
  }
  // 1-inline std::string const &GlobPattern::get_pattern(void) const
  std::string const &return_value = ((*(const GlobPattern*)local_this).get_pattern)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_get_pattern_324_comment =
  "C++ Interface:\n"
  "get_pattern(GlobPattern self)\n"
  "\n"
  "/**\n"
  " * Returns the pattern string that the GlobPattern object matches.\n"
  " */";
#else
static const char *Dtool_GlobPattern_get_pattern_324_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GlobPattern::set_case_sensitive(bool case_sensitive)
 */
static PyObject *Dtool_GlobPattern_set_case_sensitive_327(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.set_case_sensitive")) {
    return nullptr;
  }
  // 1-inline void GlobPattern::set_case_sensitive(bool case_sensitive)
  ((*local_this).set_case_sensitive)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_case_sensitive(const GlobPattern self, bool case_sensitive)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_set_case_sensitive_327_comment =
  "C++ Interface:\n"
  "set_case_sensitive(const GlobPattern self, bool case_sensitive)\n"
  "\n"
  "/**\n"
  " * Sets whether the match is case sensitive (true) or case insensitive\n"
  " * (false).  The default is case sensitive.\n"
  " */";
#else
static const char *Dtool_GlobPattern_set_case_sensitive_327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GlobPattern::get_case_sensitive(void) const
 */
static PyObject *Dtool_GlobPattern_get_case_sensitive_328(PyObject *self, PyObject *) {
  GlobPattern *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GlobPattern)) {
    return nullptr;
  }
  // 1-inline bool GlobPattern::get_case_sensitive(void) const
  bool return_value = ((*(const GlobPattern*)local_this).get_case_sensitive)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_get_case_sensitive_328_comment =
  "C++ Interface:\n"
  "get_case_sensitive(GlobPattern self)\n"
  "\n"
  "/**\n"
  " * Returns whether the match is case sensitive (true) or case insensitive\n"
  " * (false).  The default is case sensitive.\n"
  " */";
#else
static const char *Dtool_GlobPattern_get_case_sensitive_328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GlobPattern::set_nomatch_chars(std::string const &nomatch_chars)
 */
static PyObject *Dtool_GlobPattern_set_nomatch_chars_330(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.set_nomatch_chars")) {
    return nullptr;
  }
  // 1-inline void GlobPattern::set_nomatch_chars(std::string const &nomatch_chars)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_nomatch_chars)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_nomatch_chars(const GlobPattern self, str nomatch_chars)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_set_nomatch_chars_330_comment =
  "C++ Interface:\n"
  "set_nomatch_chars(const GlobPattern self, str nomatch_chars)\n"
  "\n"
  "/**\n"
  " * Specifies a set of characters that are not matched by * or ?.\n"
  " */";
#else
static const char *Dtool_GlobPattern_set_nomatch_chars_330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &GlobPattern::get_nomatch_chars(void) const
 */
static PyObject *Dtool_GlobPattern_get_nomatch_chars_331(PyObject *self, PyObject *) {
  GlobPattern *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GlobPattern)) {
    return nullptr;
  }
  // 1-inline std::string const &GlobPattern::get_nomatch_chars(void) const
  std::string const &return_value = ((*(const GlobPattern*)local_this).get_nomatch_chars)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_get_nomatch_chars_331_comment =
  "C++ Interface:\n"
  "get_nomatch_chars(GlobPattern self)\n"
  "\n"
  "/**\n"
  " * Returns the set of characters that are not matched by * or ?.\n"
  " */";
#else
static const char *Dtool_GlobPattern_get_nomatch_chars_331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GlobPattern::matches(std::string const &candidate) const
 */
static PyObject *Dtool_GlobPattern_matches_333(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GlobPattern)) {
    return nullptr;
  }
  // 1-inline bool GlobPattern::matches(std::string const &candidate) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const GlobPattern*)local_this).matches)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches(GlobPattern self, str candidate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_matches_333_comment =
  "C++ Interface:\n"
  "matches(GlobPattern self, str candidate)\n"
  "\n"
  "/**\n"
  " * Returns true if the candidate string matches the pattern, false otherwise.\n"
  " */";
#else
static const char *Dtool_GlobPattern_matches_333_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GlobPattern::matches_file(Filename candidate) const
 */
static PyObject *Dtool_GlobPattern_matches_file_334(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GlobPattern)) {
    return nullptr;
  }
  // 1-bool GlobPattern::matches_file(Filename candidate) const
  Filename arg_local;
  Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GlobPattern.matches_file", "Filename");
  }
  bool return_value = ((*(const GlobPattern*)local_this).matches_file)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches_file(GlobPattern self, Filename candidate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_matches_file_334_comment =
  "C++ Interface:\n"
  "matches_file(GlobPattern self, Filename candidate)\n"
  "\n"
  "/**\n"
  " * Treats the GlobPattern as a filename pattern, and returns true if the given\n"
  " * filename matches the pattern.  Unlike matches(), this will not match slash\n"
  " * characters for single asterisk characters, and it will ignore path\n"
  " * components that only contain a dot.\n"
  " */";
#else
static const char *Dtool_GlobPattern_matches_file_334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GlobPattern::output(std::ostream &out) const
 */
static PyObject *Dtool_GlobPattern_output_335(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GlobPattern)) {
    return nullptr;
  }
  // 1-inline void GlobPattern::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GlobPattern.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GlobPattern*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GlobPattern self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_output_335_comment =
  "C++ Interface:\n"
  "output(GlobPattern self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GlobPattern_output_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GlobPattern::has_glob_characters(void) const
 */
static PyObject *Dtool_GlobPattern_has_glob_characters_336(PyObject *self, PyObject *) {
  GlobPattern *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GlobPattern)) {
    return nullptr;
  }
  // 1-bool GlobPattern::has_glob_characters(void) const
  bool return_value = ((*(const GlobPattern*)local_this).has_glob_characters)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_has_glob_characters_336_comment =
  "C++ Interface:\n"
  "has_glob_characters(GlobPattern self)\n"
  "\n"
  "/**\n"
  " * Returns true if the pattern includes any special globbing characters, or\n"
  " * false if it is just a literal string.\n"
  " */";
#else
static const char *Dtool_GlobPattern_has_glob_characters_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string GlobPattern::get_const_prefix(void) const
 */
static PyObject *Dtool_GlobPattern_get_const_prefix_337(PyObject *self, PyObject *) {
  GlobPattern *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GlobPattern)) {
    return nullptr;
  }
  // 1-std::string GlobPattern::get_const_prefix(void) const
  std::string return_value = ((*(const GlobPattern*)local_this).get_const_prefix)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_get_const_prefix_337_comment =
  "C++ Interface:\n"
  "get_const_prefix(GlobPattern self)\n"
  "\n"
  "/**\n"
  " * Returns the initial part of the pattern before the first glob character.\n"
  " * Since many glob patterns begin with a sequence of static characters and end\n"
  " * with one or more glob characters, this can be used to optimized searches\n"
  " * through sorted indices.\n"
  " */";
#else
static const char *Dtool_GlobPattern_get_const_prefix_337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *GlobPattern::match_files(Filename const &cwd = Filename()) const
 * Rejected Remap [int GlobPattern::match_files(vector_string &results, Filename const &cwd) const]
 */
static PyObject *Dtool_GlobPattern_match_files_338(PyObject *self, PyObject *args, PyObject *kwds) {
  GlobPattern *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GlobPattern)) {
    return nullptr;
  }
  // 1-PyObject *GlobPattern::match_files(Filename const &cwd = Filename()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "cwd")) {
    Filename param1_local;
    Filename const *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_Filename(param1, param1_local);
    } else {
      param1_local = Filename();
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GlobPattern.match_files", "Filename");
    }
    PyObject *return_value = invoke_extension((const GlobPattern*)local_this).match_files(*param1_this);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "match_files(GlobPattern self, const Filename cwd)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_match_files_338_comment =
  "C++ Interface:\n"
  "match_files(GlobPattern self, const Filename cwd)\n"
  "\n"
  "/**\n"
  " * Treats the GlobPattern as a filename pattern, and returns a list of any\n"
  " * actual files that match the pattern.  This is the behavior of the standard\n"
  " * Posix glob() function.  Any part of the filename may contain glob\n"
  " * characters, including intermediate directory names.\n"
  " *\n"
  " * If cwd is specified, it is the directory that relative filenames are taken\n"
  " * to be relative to; otherwise, the actual current working directory is\n"
  " * assumed.\n"
  " *\n"
  " * The return value is the number of files matched, which are added to the\n"
  " * results vector.\n"
  " */";
#else
static const char *Dtool_GlobPattern_match_files_338_comment = nullptr;
#endif

static PyObject *Dtool_GlobPattern_pattern_Getter(PyObject *self, void *) {
  const GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &GlobPattern::get_pattern(void) const
  std::string const &return_value = ((*(const GlobPattern*)local_this).get_pattern)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GlobPattern_pattern_Setter(PyObject *self, PyObject *arg, void *) {
  GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.pattern")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete pattern attribute");
    return -1;
  }
  // 1-inline void GlobPattern::set_pattern(std::string const &pattern)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_pattern)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pattern(const GlobPattern self, str pattern)\n");
  }
  return -1;
}

static PyObject *Dtool_GlobPattern_case_sensitive_Getter(PyObject *self, void *) {
  const GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GlobPattern::get_case_sensitive(void) const
  bool return_value = ((*(const GlobPattern*)local_this).get_case_sensitive)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GlobPattern_case_sensitive_Setter(PyObject *self, PyObject *arg, void *) {
  GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.case_sensitive")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete case_sensitive attribute");
    return -1;
  }
  // 1-inline void GlobPattern::set_case_sensitive(bool case_sensitive)
  ((*local_this).set_case_sensitive)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_case_sensitive(const GlobPattern self, bool case_sensitive)\n");
  }
  return -1;
}

static PyObject *Dtool_GlobPattern_nomatch_chars_Getter(PyObject *self, void *) {
  const GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &GlobPattern::get_nomatch_chars(void) const
  std::string const &return_value = ((*(const GlobPattern*)local_this).get_nomatch_chars)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GlobPattern_nomatch_chars_Setter(PyObject *self, PyObject *arg, void *) {
  GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.nomatch_chars")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete nomatch_chars attribute");
    return -1;
  }
  // 1-inline void GlobPattern::set_nomatch_chars(std::string const &nomatch_chars)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_nomatch_chars)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_nomatch_chars(const GlobPattern self, str nomatch_chars)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline GlobPattern::GlobPattern(GlobPattern const &copy)
 * inline GlobPattern::GlobPattern(std::string const &pattern = string())
 */
static int Dtool_Init_GlobPattern(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline GlobPattern::GlobPattern(std::string const &pattern)
      GlobPattern *return_value = new GlobPattern();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GlobPattern, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline GlobPattern::GlobPattern(GlobPattern const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          GlobPattern const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GlobPattern);
          if (param0_this != nullptr) {
            GlobPattern *return_value = new GlobPattern(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GlobPattern, true, false);
          }
        }
      }

      {
        // -2 inline GlobPattern::GlobPattern(std::string const &pattern)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"pattern", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:GlobPattern", (char **)keyword_list, &param0_str, &param0_len)) {
          GlobPattern *return_value = new GlobPattern(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GlobPattern, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline GlobPattern::GlobPattern(GlobPattern const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          GlobPattern param0_local;
          GlobPattern const *param0_this = Dtool_Coerce_GlobPattern(param0, param0_local);
          if ((param0_this != nullptr)) {
            GlobPattern *return_value = new GlobPattern(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GlobPattern, true, false);
          }
        }
      }

      // No coercion possible: inline GlobPattern::GlobPattern(std::string const &pattern)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GlobPattern() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GlobPattern()\n"
      "GlobPattern(const GlobPattern copy)\n"
      "GlobPattern(str pattern)\n");
  }
  return -1;
}

GlobPattern *Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern &coerced) {
  GlobPattern *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_GlobPattern)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const GlobPattern *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline GlobPattern::GlobPattern(std::string const &pattern)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      coerced = GlobPattern(std::string(param0_str, param0_len));
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_GlobPattern(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GlobPattern) {
    printf("GlobPattern ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GlobPattern *local_this = (GlobPattern *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GlobPattern) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GlobPattern(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GlobPattern) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LineStream
 */
/**
 * Python function wrapper for:
 * inline bool LineStream::is_text_available(void) const
 */
static PyObject *Dtool_LineStream_is_text_available_342(PyObject *self, PyObject *) {
  LineStream *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LineStream)) {
    return nullptr;
  }
  // 1-inline bool LineStream::is_text_available(void) const
  bool return_value = ((*(const LineStream*)local_this).is_text_available)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LineStream_is_text_available_342_comment =
  "C++ Interface:\n"
  "is_text_available(LineStream self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is at least one line of text (or even a partial line)\n"
  " * available in the LineStream object.  If this returns true, the line may\n"
  " * then be retrieved via get_line().\n"
  " */";
#else
static const char *Dtool_LineStream_is_text_available_342_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string LineStream::get_line(void)
 */
static PyObject *Dtool_LineStream_get_line_343(PyObject *self, PyObject *) {
  LineStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineStream, (void **)&local_this, "LineStream.get_line")) {
    return nullptr;
  }
  // 1-inline std::string LineStream::get_line(void)
  std::string return_value = ((*local_this).get_line)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LineStream_get_line_343_comment =
  "C++ Interface:\n"
  "get_line(const LineStream self)\n"
  "\n"
  "/**\n"
  " * Extracts and returns the next line (or partial line) of text available in\n"
  " * the LineStream object.  Once the line has been extracted, you may call\n"
  " * has_newline() to determine whether or not there was an explicit newline\n"
  " * character written following this line.\n"
  " */";
#else
static const char *Dtool_LineStream_get_line_343_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LineStream::has_newline(void) const
 */
static PyObject *Dtool_LineStream_has_newline_344(PyObject *self, PyObject *) {
  LineStream *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LineStream)) {
    return nullptr;
  }
  // 1-inline bool LineStream::has_newline(void) const
  bool return_value = ((*(const LineStream*)local_this).has_newline)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LineStream_has_newline_344_comment =
  "C++ Interface:\n"
  "has_newline(LineStream self)\n"
  "\n"
  "/**\n"
  " * Returns true if the line of text most recently returned by get_line() was\n"
  " * written out with a terminating newline, or false if a newline character has\n"
  " * not yet been written to the LineStream.\n"
  " */";
#else
static const char *Dtool_LineStream_has_newline_344_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LineStream::LineStream(void)
 */
static int Dtool_Init_LineStream(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("LineStream() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "LineStream() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline LineStream::LineStream(void)
  LineStream *return_value = new LineStream();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LineStream, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LineStream()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LineStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LineStream) {
    printf("LineStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LineStream *local_this = (LineStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LineStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ostream) {
    return (std::ostream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LineStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LineStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    std::ostream* other_this = (std::ostream*)from_this;
    return (LineStream*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for std_basic_ios_char (basic_ios_char)
 */
static PyMethodDef Dtool_Methods_std_basic_ios_char[] = {
  {"good", &Dtool_std_basic_ios_char_good_7, METH_NOARGS, (const char *)Dtool_std_basic_ios_char_good_7_comment},
  {"eof", &Dtool_std_basic_ios_char_eof_8, METH_NOARGS, (const char *)Dtool_std_basic_ios_char_eof_8_comment},
  {"fail", &Dtool_std_basic_ios_char_fail_9, METH_NOARGS, (const char *)Dtool_std_basic_ios_char_fail_9_comment},
  {"bad", &Dtool_std_basic_ios_char_bad_10, METH_NOARGS, (const char *)Dtool_std_basic_ios_char_bad_10_comment},
  {"clear", &Dtool_std_basic_ios_char_clear_11, METH_NOARGS, (const char *)Dtool_std_basic_ios_char_clear_11_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_std_basic_ios_char = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_std_basic_ios_char = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_std_basic_ios_char = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_std_basic_ios_char = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_std_basic_ios_char = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_std_basic_ios_char = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.basic_ios_char",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_std_basic_ios_char,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_std_basic_ios_char,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_std_basic_ios_char,
    &Dtool_SequenceMethods_std_basic_ios_char,
    &Dtool_MappingMethods_std_basic_ios_char,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_std_basic_ios_char,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_std_basic_ios_char,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_std_basic_ios_char,
    PyType_GenericAlloc,
    Dtool_new_std_basic_ios_char,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_std_basic_ios_char,
  Dtool_UpcastInterface_std_basic_ios_char,
  Dtool_DowncastInterface_std_basic_ios_char,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_std_basic_ios_char(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_std_ios_base(nullptr);
    Dtool_std_basic_ios_char._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_std_ios_base);
    Dtool_std_basic_ios_char._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_std_basic_ios_char._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_std_basic_ios_char) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(std_basic_ios_char)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_std_basic_ios_char);
  }
}

/**
 * Python method tables for std_ios_base (ios_base)
 */
static PyMethodDef Dtool_Methods_std_ios_base[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_std_ios_base = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_std_ios_base = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ios_base",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_std_ios_base,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_std_ios_base,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// We need to expose one method in each class to force it to publish.\n"
    "// But we'd like to expose some of these methods anyway, so no\n"
    "// problem.",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_std_ios_base,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_std_ios_base,
    PyType_GenericAlloc,
    Dtool_new_std_ios_base,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_std_ios_base,
  Dtool_UpcastInterface_std_ios_base,
  Dtool_DowncastInterface_std_ios_base,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_std_ios_base(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_std_ios_base._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_std_ios_base._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum std::ios_base::seekdir;
    PyDict_SetItemString(dict, "beg", Dtool_WrapValue(std::ios_base::beg));
    PyDict_SetItemString(dict, "Beg", Dtool_WrapValue(std::ios_base::beg));
    PyDict_SetItemString(dict, "cur", Dtool_WrapValue(std::ios_base::cur));
    PyDict_SetItemString(dict, "Cur", Dtool_WrapValue(std::ios_base::cur));
    PyDict_SetItemString(dict, "end", Dtool_WrapValue(std::ios_base::end));
    PyDict_SetItemString(dict, "End", Dtool_WrapValue(std::ios_base::end));
    // enum std::ios_base::openmode;
    // enum std::ios_base::iostate;
    if (PyType_Ready((PyTypeObject *)&Dtool_std_ios_base) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(std_ios_base)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_std_ios_base);
  }
}

/**
 * Python method tables for std_fstream (fstream)
 */
static PyMethodDef Dtool_Methods_std_fstream[] = {
  {"close", &Dtool_std_fstream_close_44, METH_NOARGS, (const char *)Dtool_std_fstream_close_44_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_std_fstream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_std_fstream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_std_fstream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_std_fstream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_std_fstream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_std_fstream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.fstream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_std_fstream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_std_fstream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_std_fstream,
    &Dtool_SequenceMethods_std_fstream,
    &Dtool_MappingMethods_std_fstream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_std_fstream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_std_fstream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_std_fstream,
    PyType_GenericAlloc,
    Dtool_new_std_fstream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_std_fstream,
  Dtool_UpcastInterface_std_fstream,
  Dtool_DowncastInterface_std_fstream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_std_fstream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_std_iostream(nullptr);
    Dtool_std_fstream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_std_iostream);
    Dtool_std_fstream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_std_fstream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_std_fstream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(std_fstream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_std_fstream);
  }
}

/**
 * Python method tables for std_iostream (iostream)
 */
static PyMethodDef Dtool_Methods_std_iostream[] = {
  {"flush", &Dtool_std_iostream_flush_41, METH_NOARGS, (const char *)Dtool_std_iostream_flush_41_comment},
  {"upcast_to_istream", &Dtool_std_iostream_upcast_to_istream_28, METH_NOARGS, (const char *)Dtool_std_iostream_upcast_to_istream_28_comment},
  {"upcastToIstream", &Dtool_std_iostream_upcast_to_istream_28, METH_NOARGS, (const char *)Dtool_std_iostream_upcast_to_istream_28_comment},
  {"upcast_to_ostream", &Dtool_std_iostream_upcast_to_ostream_39, METH_NOARGS, (const char *)Dtool_std_iostream_upcast_to_ostream_39_comment},
  {"upcastToOstream", &Dtool_std_iostream_upcast_to_ostream_39, METH_NOARGS, (const char *)Dtool_std_iostream_upcast_to_ostream_39_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_std_iostream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_std_iostream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_std_iostream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_std_iostream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_std_iostream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_std_iostream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.iostream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_std_iostream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_std_iostream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_std_iostream,
    &Dtool_SequenceMethods_std_iostream,
    &Dtool_MappingMethods_std_iostream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_std_iostream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_std_iostream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_std_iostream,
    PyType_GenericAlloc,
    Dtool_new_std_iostream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_std_iostream,
  Dtool_UpcastInterface_std_iostream,
  Dtool_DowncastInterface_std_iostream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_std_iostream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_std_istream(nullptr);
    Dtool_PyModuleClassInit_std_ostream(nullptr);
    Dtool_std_iostream._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_std_istream, (PyTypeObject *)&Dtool_std_ostream);
    Dtool_std_iostream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_std_iostream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_std_iostream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(std_iostream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_std_iostream);
  }
}

/**
 * Python method tables for std_istream (istream)
 */
static PyMethodDef Dtool_Methods_std_istream[] = {
  {"read", (PyCFunction) &Dtool_std_istream_read_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_std_istream_read_17_comment},
  {"read1", (PyCFunction) &Dtool_std_istream_read1_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_std_istream_read1_18_comment},
  {"readall", &Dtool_std_istream_readall_19, METH_NOARGS, (const char *)Dtool_std_istream_readall_19_comment},
  {"readinto", &Dtool_std_istream_readinto_20, METH_O, (const char *)Dtool_std_istream_readinto_20_comment},
  {"readline", (PyCFunction) &Dtool_std_istream_readline_21, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_std_istream_readline_21_comment},
  {"readlines", (PyCFunction) &Dtool_std_istream_readlines_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_std_istream_readlines_22_comment},
  {"get", &Dtool_std_istream_get_24, METH_NOARGS, (const char *)Dtool_std_istream_get_24_comment},
  {"tellg", &Dtool_std_istream_tellg_25, METH_NOARGS, (const char *)Dtool_std_istream_tellg_25_comment},
  {"seekg", (PyCFunction) &Dtool_std_istream_seekg_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_std_istream_seekg_26_comment},
  {"upcast_to_basic_ios_char", &Dtool_std_istream_upcast_to_basic_ios_char_16, METH_NOARGS, (const char *)Dtool_std_istream_upcast_to_basic_ios_char_16_comment},
  {"upcastToBasicIosChar", &Dtool_std_istream_upcast_to_basic_ios_char_16, METH_NOARGS, (const char *)Dtool_std_istream_upcast_to_basic_ios_char_16_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// std_istream slot tp_iter -> __iter__
//////////////////
static PyObject *Dtool_std_istream_iter_23_tp_iter(PyObject *self) {
  std::istream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_std_istream, (void **)&local_this)) {
    return nullptr;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    // 1-PyObject *std::istream::__iter__(PyObject *self)
    PyObject *return_value = invoke_extension(local_this).__iter__(self);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return Dtool_WrapValue(return_value);
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call istream.__iter__() on a const object.");
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__iter__(const istream self)\n");
  }
  return nullptr;
}

static PyNumberMethods Dtool_NumberMethods_std_istream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_std_istream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_std_istream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_std_istream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_std_istream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_std_istream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.istream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_std_istream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_std_istream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_std_istream,
    &Dtool_SequenceMethods_std_istream,
    &Dtool_MappingMethods_std_istream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_std_istream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    &Dtool_std_istream_iter_23_tp_iter,
    nullptr,
    Dtool_Methods_std_istream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_std_istream,
    PyType_GenericAlloc,
    Dtool_new_std_istream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_std_istream,
  Dtool_UpcastInterface_std_istream,
  Dtool_DowncastInterface_std_istream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_std_istream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_std_basic_ios_char(nullptr);
    Dtool_std_istream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_std_basic_ios_char);
    Dtool_std_istream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_std_istream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_std_istream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(std_istream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_std_istream);
  }
}

/**
 * Python method tables for std_ostream (ostream)
 */
static PyMethodDef Dtool_Methods_std_ostream[] = {
  {"write", &Dtool_std_ostream_write_32, METH_O, (const char *)Dtool_std_ostream_write_32_comment},
  {"writelines", &Dtool_std_ostream_writelines_33, METH_O, (const char *)Dtool_std_ostream_writelines_33_comment},
  {"put", &Dtool_std_ostream_put_34, METH_O, (const char *)Dtool_std_ostream_put_34_comment},
  {"flush", &Dtool_std_ostream_flush_35, METH_NOARGS, (const char *)Dtool_std_ostream_flush_35_comment},
  {"tellp", &Dtool_std_ostream_tellp_36, METH_NOARGS, (const char *)Dtool_std_ostream_tellp_36_comment},
  {"seekp", (PyCFunction) &Dtool_std_ostream_seekp_37, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_std_ostream_seekp_37_comment},
  {"upcast_to_basic_ios_char", &Dtool_std_ostream_upcast_to_basic_ios_char_31, METH_NOARGS, (const char *)Dtool_std_ostream_upcast_to_basic_ios_char_31_comment},
  {"upcastToBasicIosChar", &Dtool_std_ostream_upcast_to_basic_ios_char_31, METH_NOARGS, (const char *)Dtool_std_ostream_upcast_to_basic_ios_char_31_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_std_ostream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_std_ostream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_std_ostream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_std_ostream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_std_ostream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_std_ostream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ostream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_std_ostream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_std_ostream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_std_ostream,
    &Dtool_SequenceMethods_std_ostream,
    &Dtool_MappingMethods_std_ostream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_std_ostream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_std_ostream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_std_ostream,
    PyType_GenericAlloc,
    Dtool_new_std_ostream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_std_ostream,
  Dtool_UpcastInterface_std_ostream,
  Dtool_DowncastInterface_std_ostream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_std_ostream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_std_basic_ios_char(nullptr);
    Dtool_std_ostream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_std_basic_ios_char);
    Dtool_std_ostream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_std_ostream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_std_ostream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(std_ostream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_std_ostream);
  }
}

/**
 * Python method tables for std_ifstream (ifstream)
 */
static PyMethodDef Dtool_Methods_std_ifstream[] = {
  {"close", &Dtool_std_ifstream_close_48, METH_NOARGS, (const char *)Dtool_std_ifstream_close_48_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_std_ifstream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_std_ifstream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_std_ifstream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_std_ifstream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_std_ifstream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_std_ifstream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ifstream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_std_ifstream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_std_ifstream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_std_ifstream,
    &Dtool_SequenceMethods_std_ifstream,
    &Dtool_MappingMethods_std_ifstream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_std_ifstream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_std_ifstream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_std_ifstream,
    PyType_GenericAlloc,
    Dtool_new_std_ifstream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_std_ifstream,
  Dtool_UpcastInterface_std_ifstream,
  Dtool_DowncastInterface_std_ifstream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_std_ifstream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_std_istream(nullptr);
    Dtool_std_ifstream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_std_istream);
    Dtool_std_ifstream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_std_ifstream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_std_ifstream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(std_ifstream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_std_ifstream);
  }
}

/**
 * Python method tables for std_ofstream (ofstream)
 */
static PyMethodDef Dtool_Methods_std_ofstream[] = {
  {"close", &Dtool_std_ofstream_close_53, METH_NOARGS, (const char *)Dtool_std_ofstream_close_53_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_std_ofstream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_std_ofstream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_std_ofstream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_std_ofstream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_std_ofstream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_std_ofstream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ofstream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_std_ofstream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_std_ofstream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_std_ofstream,
    &Dtool_SequenceMethods_std_ofstream,
    &Dtool_MappingMethods_std_ofstream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_std_ofstream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_std_ofstream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_std_ofstream,
    PyType_GenericAlloc,
    Dtool_new_std_ofstream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_std_ofstream,
  Dtool_UpcastInterface_std_ofstream,
  Dtool_DowncastInterface_std_ofstream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_std_ofstream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_std_ostream(nullptr);
    Dtool_std_ofstream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_std_ostream);
    Dtool_std_ofstream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_std_ofstream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_std_ofstream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(std_ofstream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_std_ofstream);
  }
}

/**
 * Python method tables for IFileStream (IFileStream)
 */
static PyMethodDef Dtool_Methods_IFileStream[] = {
  {"open", (PyCFunction) &Dtool_IFileStream_open_58, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_IFileStream_open_58_comment},
  {"close", &Dtool_IFileStream_close_59, METH_NOARGS, (const char *)Dtool_IFileStream_close_59_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_IFileStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_IFileStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_IFileStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_IFileStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_IFileStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_IFileStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.IFileStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_IFileStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_IFileStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_IFileStream,
    &Dtool_SequenceMethods_IFileStream,
    &Dtool_MappingMethods_IFileStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_IFileStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Implements a C++ stream object suitable for reading from files on disk.\n"
    " * This is similar to ifstream, but it provides low-level support for Panda's\n"
    " * simple-threading implementation (using this interface will block only the\n"
    " * current thread, rather than the entire process, on I/O waits).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_IFileStream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_IFileStream,
    PyType_GenericAlloc,
    Dtool_new_IFileStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IFileStream,
  Dtool_UpcastInterface_IFileStream,
  Dtool_DowncastInterface_IFileStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_IFileStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_std_istream(nullptr);
    Dtool_IFileStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_std_istream);
    Dtool_IFileStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_IFileStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IFileStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IFileStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IFileStream);
  }
}

/**
 * Python method tables for OFileStream (OFileStream)
 */
static PyMethodDef Dtool_Methods_OFileStream[] = {
  {"open", (PyCFunction) &Dtool_OFileStream_open_63, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OFileStream_open_63_comment},
  {"close", &Dtool_OFileStream_close_64, METH_NOARGS, (const char *)Dtool_OFileStream_close_64_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OFileStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OFileStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OFileStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OFileStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OFileStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OFileStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.OFileStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OFileStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OFileStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OFileStream,
    &Dtool_SequenceMethods_OFileStream,
    &Dtool_MappingMethods_OFileStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OFileStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Implements a C++ stream object suitable for writing to files on disk.  This\n"
    " * is similar to ofstream, but it provides low-level support for Panda's\n"
    " * simple-threading implementation (using this interface will block only the\n"
    " * current thread, rather than the entire process, on I/O waits).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OFileStream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OFileStream,
    PyType_GenericAlloc,
    Dtool_new_OFileStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OFileStream,
  Dtool_UpcastInterface_OFileStream,
  Dtool_DowncastInterface_OFileStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OFileStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_std_ostream(nullptr);
    Dtool_OFileStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_std_ostream);
    Dtool_OFileStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OFileStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OFileStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OFileStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OFileStream);
  }
}

/**
 * Python method tables for FileStream (FileStream)
 */
static PyMethodDef Dtool_Methods_FileStream[] = {
  {"open", (PyCFunction) &Dtool_FileStream_open_68, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FileStream_open_68_comment},
  {"close", &Dtool_FileStream_close_69, METH_NOARGS, (const char *)Dtool_FileStream_close_69_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_FileStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FileStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_FileStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_FileStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_FileStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_FileStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.FileStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FileStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_FileStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_FileStream,
    &Dtool_SequenceMethods_FileStream,
    &Dtool_MappingMethods_FileStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_FileStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Implements a C++ stream object suitable for reading from and/or writing to\n"
    " * files on disk.  This is similar to fstream, but it provides low-level\n"
    " * support for Panda's simple-threading implementation (using this interface\n"
    " * will block only the current thread, rather than the entire process, on I/O\n"
    " * waits).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FileStream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FileStream,
    PyType_GenericAlloc,
    Dtool_new_FileStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FileStream,
  Dtool_UpcastInterface_FileStream,
  Dtool_DowncastInterface_FileStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_FileStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_std_iostream(nullptr);
    Dtool_FileStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_std_iostream);
    Dtool_FileStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_FileStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FileStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FileStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FileStream);
  }
}

/**
 * Python method tables for TextEncoder (TextEncoder)
 */
static PyMethodDef Dtool_Methods_TextEncoder[] = {
  {"set_encoding", &Dtool_TextEncoder_set_encoding_77, METH_O, (const char *)Dtool_TextEncoder_set_encoding_77_comment},
  {"setEncoding", &Dtool_TextEncoder_set_encoding_77, METH_O, (const char *)Dtool_TextEncoder_set_encoding_77_comment},
  {"get_encoding", &Dtool_TextEncoder_get_encoding_78, METH_NOARGS, (const char *)Dtool_TextEncoder_get_encoding_78_comment},
  {"getEncoding", &Dtool_TextEncoder_get_encoding_78, METH_NOARGS, (const char *)Dtool_TextEncoder_get_encoding_78_comment},
  {"set_default_encoding", &Dtool_TextEncoder_set_default_encoding_79, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_set_default_encoding_79_comment},
  {"setDefaultEncoding", &Dtool_TextEncoder_set_default_encoding_79, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_set_default_encoding_79_comment},
  {"get_default_encoding", &Dtool_TextEncoder_get_default_encoding_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextEncoder_get_default_encoding_80_comment},
  {"getDefaultEncoding", &Dtool_TextEncoder_get_default_encoding_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextEncoder_get_default_encoding_80_comment},
  {"set_text", (PyCFunction) &Dtool_TextEncoder_set_text_82, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_set_text_82_comment},
  {"setText", (PyCFunction) &Dtool_TextEncoder_set_text_82, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_set_text_82_comment},
  {"clear_text", &Dtool_TextEncoder_clear_text_83, METH_NOARGS, (const char *)Dtool_TextEncoder_clear_text_83_comment},
  {"clearText", &Dtool_TextEncoder_clear_text_83, METH_NOARGS, (const char *)Dtool_TextEncoder_clear_text_83_comment},
  {"has_text", &Dtool_TextEncoder_has_text_84, METH_NOARGS, (const char *)Dtool_TextEncoder_has_text_84_comment},
  {"hasText", &Dtool_TextEncoder_has_text_84, METH_NOARGS, (const char *)Dtool_TextEncoder_has_text_84_comment},
  {"make_upper", &Dtool_TextEncoder_make_upper_85, METH_NOARGS, (const char *)Dtool_TextEncoder_make_upper_85_comment},
  {"makeUpper", &Dtool_TextEncoder_make_upper_85, METH_NOARGS, (const char *)Dtool_TextEncoder_make_upper_85_comment},
  {"make_lower", &Dtool_TextEncoder_make_lower_86, METH_NOARGS, (const char *)Dtool_TextEncoder_make_lower_86_comment},
  {"makeLower", &Dtool_TextEncoder_make_lower_86, METH_NOARGS, (const char *)Dtool_TextEncoder_make_lower_86_comment},
  {"get_text", &Dtool_TextEncoder_get_text_87, METH_VARARGS, (const char *)Dtool_TextEncoder_get_text_87_comment},
  {"getText", &Dtool_TextEncoder_get_text_87, METH_VARARGS, (const char *)Dtool_TextEncoder_get_text_87_comment},
  {"append_text", &Dtool_TextEncoder_append_text_88, METH_O, (const char *)Dtool_TextEncoder_append_text_88_comment},
  {"appendText", &Dtool_TextEncoder_append_text_88, METH_O, (const char *)Dtool_TextEncoder_append_text_88_comment},
  {"append_unicode_char", &Dtool_TextEncoder_append_unicode_char_89, METH_O, (const char *)Dtool_TextEncoder_append_unicode_char_89_comment},
  {"appendUnicodeChar", &Dtool_TextEncoder_append_unicode_char_89, METH_O, (const char *)Dtool_TextEncoder_append_unicode_char_89_comment},
  {"get_num_chars", &Dtool_TextEncoder_get_num_chars_90, METH_NOARGS, (const char *)Dtool_TextEncoder_get_num_chars_90_comment},
  {"getNumChars", &Dtool_TextEncoder_get_num_chars_90, METH_NOARGS, (const char *)Dtool_TextEncoder_get_num_chars_90_comment},
  {"get_unicode_char", &Dtool_TextEncoder_get_unicode_char_91, METH_O, (const char *)Dtool_TextEncoder_get_unicode_char_91_comment},
  {"getUnicodeChar", &Dtool_TextEncoder_get_unicode_char_91, METH_O, (const char *)Dtool_TextEncoder_get_unicode_char_91_comment},
  {"set_unicode_char", (PyCFunction) &Dtool_TextEncoder_set_unicode_char_92, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_set_unicode_char_92_comment},
  {"setUnicodeChar", (PyCFunction) &Dtool_TextEncoder_set_unicode_char_92, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_set_unicode_char_92_comment},
  {"get_encoded_char", (PyCFunction) &Dtool_TextEncoder_get_encoded_char_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_get_encoded_char_93_comment},
  {"getEncodedChar", (PyCFunction) &Dtool_TextEncoder_get_encoded_char_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_get_encoded_char_93_comment},
  {"get_text_as_ascii", &Dtool_TextEncoder_get_text_as_ascii_94, METH_NOARGS, (const char *)Dtool_TextEncoder_get_text_as_ascii_94_comment},
  {"getTextAsAscii", &Dtool_TextEncoder_get_text_as_ascii_94, METH_NOARGS, (const char *)Dtool_TextEncoder_get_text_as_ascii_94_comment},
  {"reencode_text", (PyCFunction) &Dtool_TextEncoder_reencode_text_95, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_reencode_text_95_comment},
  {"reencodeText", (PyCFunction) &Dtool_TextEncoder_reencode_text_95, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_reencode_text_95_comment},
  {"unicode_isalpha", &Dtool_TextEncoder_unicode_isalpha_96, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isalpha_96_comment},
  {"unicodeIsalpha", &Dtool_TextEncoder_unicode_isalpha_96, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isalpha_96_comment},
  {"unicode_isdigit", &Dtool_TextEncoder_unicode_isdigit_97, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isdigit_97_comment},
  {"unicodeIsdigit", &Dtool_TextEncoder_unicode_isdigit_97, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isdigit_97_comment},
  {"unicode_ispunct", &Dtool_TextEncoder_unicode_ispunct_98, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_ispunct_98_comment},
  {"unicodeIspunct", &Dtool_TextEncoder_unicode_ispunct_98, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_ispunct_98_comment},
  {"unicode_islower", &Dtool_TextEncoder_unicode_islower_99, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_islower_99_comment},
  {"unicodeIslower", &Dtool_TextEncoder_unicode_islower_99, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_islower_99_comment},
  {"unicode_isupper", &Dtool_TextEncoder_unicode_isupper_100, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isupper_100_comment},
  {"unicodeIsupper", &Dtool_TextEncoder_unicode_isupper_100, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isupper_100_comment},
  {"unicode_isspace", &Dtool_TextEncoder_unicode_isspace_101, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isspace_101_comment},
  {"unicodeIsspace", &Dtool_TextEncoder_unicode_isspace_101, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isspace_101_comment},
  {"unicode_toupper", &Dtool_TextEncoder_unicode_toupper_102, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_toupper_102_comment},
  {"unicodeToupper", &Dtool_TextEncoder_unicode_toupper_102, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_toupper_102_comment},
  {"unicode_tolower", &Dtool_TextEncoder_unicode_tolower_103, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_tolower_103_comment},
  {"unicodeTolower", &Dtool_TextEncoder_unicode_tolower_103, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_tolower_103_comment},
  {"upper", (PyCFunction) &Dtool_TextEncoder_upper_104, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_upper_104_comment},
  {"lower", (PyCFunction) &Dtool_TextEncoder_lower_105, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_lower_105_comment},
  {"set_wtext", &Dtool_TextEncoder_set_wtext_106, METH_O, (const char *)Dtool_TextEncoder_set_wtext_106_comment},
  {"setWtext", &Dtool_TextEncoder_set_wtext_106, METH_O, (const char *)Dtool_TextEncoder_set_wtext_106_comment},
  {"get_wtext", &Dtool_TextEncoder_get_wtext_107, METH_NOARGS, (const char *)Dtool_TextEncoder_get_wtext_107_comment},
  {"getWtext", &Dtool_TextEncoder_get_wtext_107, METH_NOARGS, (const char *)Dtool_TextEncoder_get_wtext_107_comment},
  {"append_wtext", &Dtool_TextEncoder_append_wtext_108, METH_O, (const char *)Dtool_TextEncoder_append_wtext_108_comment},
  {"appendWtext", &Dtool_TextEncoder_append_wtext_108, METH_O, (const char *)Dtool_TextEncoder_append_wtext_108_comment},
  {"get_wtext_as_ascii", &Dtool_TextEncoder_get_wtext_as_ascii_109, METH_NOARGS, (const char *)Dtool_TextEncoder_get_wtext_as_ascii_109_comment},
  {"getWtextAsAscii", &Dtool_TextEncoder_get_wtext_as_ascii_109, METH_NOARGS, (const char *)Dtool_TextEncoder_get_wtext_as_ascii_109_comment},
  {"is_wtext", &Dtool_TextEncoder_is_wtext_110, METH_NOARGS, (const char *)Dtool_TextEncoder_is_wtext_110_comment},
  {"isWtext", &Dtool_TextEncoder_is_wtext_110, METH_NOARGS, (const char *)Dtool_TextEncoder_is_wtext_110_comment},
  {"encode_wchar", (PyCFunction) &Dtool_TextEncoder_encode_wchar_111, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_encode_wchar_111_comment},
  {"encodeWchar", (PyCFunction) &Dtool_TextEncoder_encode_wchar_111, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_encode_wchar_111_comment},
  {"encode_wtext", (PyCFunction) &Dtool_TextEncoder_encode_wtext_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_encode_wtext_112_comment},
  {"encodeWtext", (PyCFunction) &Dtool_TextEncoder_encode_wtext_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_encode_wtext_112_comment},
  {"decode_text", (PyCFunction) &Dtool_TextEncoder_decode_text_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_decode_text_113_comment},
  {"decodeText", (PyCFunction) &Dtool_TextEncoder_decode_text_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_decode_text_113_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_TextEncoder[] = {
  {(char *)"text", &Dtool_TextEncoder_text_Getter, &Dtool_TextEncoder_text_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TextEncoder = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TextEncoder = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextEncoder",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextEncoder,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextEncoder,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can be used to convert text between multiple representations,\n"
    " * e.g.  UTF-8 to UTF-16.  You may use it as a static class object, passing\n"
    " * the encoding each time, or you may create an instance and use that object,\n"
    " * which will record the current encoding and retain the current string.\n"
    " *\n"
    " * This class is also a base class of TextNode, which inherits this\n"
    " * functionality.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextEncoder,
    nullptr, // tp_members
    Dtool_Properties_TextEncoder,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextEncoder,
    PyType_GenericAlloc,
    Dtool_new_TextEncoder,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextEncoder,
  Dtool_UpcastInterface_TextEncoder,
  Dtool_DowncastInterface_TextEncoder,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextEncoder(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextEncoder._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_TextEncoder._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TextEncoder::Encoding;
    PyDict_SetItemString(dict, "E_iso8859", Dtool_WrapValue(TextEncoder::E_iso8859));
    PyDict_SetItemString(dict, "EIso8859", Dtool_WrapValue(TextEncoder::E_iso8859));
    PyDict_SetItemString(dict, "E_utf8", Dtool_WrapValue(TextEncoder::E_utf8));
    PyDict_SetItemString(dict, "EUtf8", Dtool_WrapValue(TextEncoder::E_utf8));
    PyDict_SetItemString(dict, "E_utf16be", Dtool_WrapValue(TextEncoder::E_utf16be));
    PyDict_SetItemString(dict, "EUtf16be", Dtool_WrapValue(TextEncoder::E_utf16be));
    PyDict_SetItemString(dict, "E_unicode", Dtool_WrapValue(TextEncoder::E_unicode));
    PyDict_SetItemString(dict, "EUnicode", Dtool_WrapValue(TextEncoder::E_unicode));
    static const PyGetSetDef def_default_encoding = {(char *)"default_encoding", &Dtool_TextEncoder_default_encoding_Getter, &Dtool_TextEncoder_default_encoding_Setter, nullptr, nullptr};
    PyDict_SetItemString(dict, "default_encoding", Dtool_NewStaticProperty(&Dtool_TextEncoder._PyType, &def_default_encoding));
    if (PyType_Ready((PyTypeObject *)&Dtool_TextEncoder) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextEncoder)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextEncoder);
  }
}

/**
 * Python method tables for Filename (Filename)
 */
static PyMethodDef Dtool_Methods_Filename[] = {
  {"__reduce__", &Dtool_Filename_reduce_121, METH_NOARGS, (const char *)Dtool_Filename_reduce_121_comment},
  {"text_filename", &Dtool_Filename_text_filename_122, METH_O | METH_STATIC, (const char *)Dtool_Filename_text_filename_122_comment},
  {"textFilename", &Dtool_Filename_text_filename_122, METH_O | METH_STATIC, (const char *)Dtool_Filename_text_filename_122_comment},
  {"binary_filename", &Dtool_Filename_binary_filename_123, METH_O | METH_STATIC, (const char *)Dtool_Filename_binary_filename_123_comment},
  {"binaryFilename", &Dtool_Filename_binary_filename_123, METH_O | METH_STATIC, (const char *)Dtool_Filename_binary_filename_123_comment},
  {"dso_filename", &Dtool_Filename_dso_filename_124, METH_O | METH_STATIC, (const char *)Dtool_Filename_dso_filename_124_comment},
  {"dsoFilename", &Dtool_Filename_dso_filename_124, METH_O | METH_STATIC, (const char *)Dtool_Filename_dso_filename_124_comment},
  {"executable_filename", &Dtool_Filename_executable_filename_125, METH_O | METH_STATIC, (const char *)Dtool_Filename_executable_filename_125_comment},
  {"executableFilename", &Dtool_Filename_executable_filename_125, METH_O | METH_STATIC, (const char *)Dtool_Filename_executable_filename_125_comment},
  {"pattern_filename", &Dtool_Filename_pattern_filename_126, METH_O | METH_STATIC, (const char *)Dtool_Filename_pattern_filename_126_comment},
  {"patternFilename", &Dtool_Filename_pattern_filename_126, METH_O | METH_STATIC, (const char *)Dtool_Filename_pattern_filename_126_comment},
  {"from_os_specific", (PyCFunction) &Dtool_Filename_from_os_specific_127, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_from_os_specific_127_comment},
  {"fromOsSpecific", (PyCFunction) &Dtool_Filename_from_os_specific_127, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_from_os_specific_127_comment},
  {"from_os_specific_w", (PyCFunction) &Dtool_Filename_from_os_specific_w_128, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_from_os_specific_w_128_comment},
  {"fromOsSpecificW", (PyCFunction) &Dtool_Filename_from_os_specific_w_128, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_from_os_specific_w_128_comment},
  {"expand_from", (PyCFunction) &Dtool_Filename_expand_from_129, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_expand_from_129_comment},
  {"expandFrom", (PyCFunction) &Dtool_Filename_expand_from_129, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_expand_from_129_comment},
  {"temporary", (PyCFunction) &Dtool_Filename_temporary_130, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_temporary_130_comment},
  {"get_home_directory", &Dtool_Filename_get_home_directory_131, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_home_directory_131_comment},
  {"getHomeDirectory", &Dtool_Filename_get_home_directory_131, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_home_directory_131_comment},
  {"get_temp_directory", &Dtool_Filename_get_temp_directory_132, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_temp_directory_132_comment},
  {"getTempDirectory", &Dtool_Filename_get_temp_directory_132, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_temp_directory_132_comment},
  {"get_user_appdata_directory", &Dtool_Filename_get_user_appdata_directory_133, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_user_appdata_directory_133_comment},
  {"getUserAppdataDirectory", &Dtool_Filename_get_user_appdata_directory_133, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_user_appdata_directory_133_comment},
  {"get_common_appdata_directory", &Dtool_Filename_get_common_appdata_directory_134, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_common_appdata_directory_134_comment},
  {"getCommonAppdataDirectory", &Dtool_Filename_get_common_appdata_directory_134, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_common_appdata_directory_134_comment},
  {"assign", &Dtool_Filename_operator_135, METH_O, (const char *)Dtool_Filename_operator_135_comment},
  {"c_str", &Dtool_Filename_c_str_137, METH_NOARGS, (const char *)Dtool_Filename_c_str_137_comment},
  {"cStr", &Dtool_Filename_c_str_137, METH_NOARGS, (const char *)Dtool_Filename_c_str_137_comment},
  {"empty", &Dtool_Filename_empty_138, METH_NOARGS, (const char *)Dtool_Filename_empty_138_comment},
  {"length", &Dtool_Filename_length_139, METH_NOARGS, (const char *)Dtool_Filename_length_139_comment},
  {"__fspath__", &Dtool_Filename_fspath_142, METH_NOARGS, (const char *)Dtool_Filename_fspath_142_comment},
  {"Fspath", &Dtool_Filename_fspath_142, METH_NOARGS, (const char *)Dtool_Filename_fspath_142_comment},
  {"substr", (PyCFunction) &Dtool_Filename_substr_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_substr_143_comment},
  {"get_fullpath", &Dtool_Filename_get_fullpath_147, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_147_comment},
  {"getFullpath", &Dtool_Filename_get_fullpath_147, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_147_comment},
  {"get_fullpath_w", &Dtool_Filename_get_fullpath_w_148, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_w_148_comment},
  {"getFullpathW", &Dtool_Filename_get_fullpath_w_148, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_w_148_comment},
  {"get_dirname", &Dtool_Filename_get_dirname_149, METH_NOARGS, (const char *)Dtool_Filename_get_dirname_149_comment},
  {"getDirname", &Dtool_Filename_get_dirname_149, METH_NOARGS, (const char *)Dtool_Filename_get_dirname_149_comment},
  {"get_basename", &Dtool_Filename_get_basename_150, METH_NOARGS, (const char *)Dtool_Filename_get_basename_150_comment},
  {"getBasename", &Dtool_Filename_get_basename_150, METH_NOARGS, (const char *)Dtool_Filename_get_basename_150_comment},
  {"get_fullpath_wo_extension", &Dtool_Filename_get_fullpath_wo_extension_151, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_wo_extension_151_comment},
  {"getFullpathWoExtension", &Dtool_Filename_get_fullpath_wo_extension_151, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_wo_extension_151_comment},
  {"get_basename_wo_extension", &Dtool_Filename_get_basename_wo_extension_152, METH_NOARGS, (const char *)Dtool_Filename_get_basename_wo_extension_152_comment},
  {"getBasenameWoExtension", &Dtool_Filename_get_basename_wo_extension_152, METH_NOARGS, (const char *)Dtool_Filename_get_basename_wo_extension_152_comment},
  {"get_extension", &Dtool_Filename_get_extension_153, METH_NOARGS, (const char *)Dtool_Filename_get_extension_153_comment},
  {"getExtension", &Dtool_Filename_get_extension_153, METH_NOARGS, (const char *)Dtool_Filename_get_extension_153_comment},
  {"set_fullpath", &Dtool_Filename_set_fullpath_154, METH_O, (const char *)Dtool_Filename_set_fullpath_154_comment},
  {"setFullpath", &Dtool_Filename_set_fullpath_154, METH_O, (const char *)Dtool_Filename_set_fullpath_154_comment},
  {"set_dirname", &Dtool_Filename_set_dirname_155, METH_O, (const char *)Dtool_Filename_set_dirname_155_comment},
  {"setDirname", &Dtool_Filename_set_dirname_155, METH_O, (const char *)Dtool_Filename_set_dirname_155_comment},
  {"set_basename", &Dtool_Filename_set_basename_156, METH_O, (const char *)Dtool_Filename_set_basename_156_comment},
  {"setBasename", &Dtool_Filename_set_basename_156, METH_O, (const char *)Dtool_Filename_set_basename_156_comment},
  {"set_fullpath_wo_extension", &Dtool_Filename_set_fullpath_wo_extension_157, METH_O, (const char *)Dtool_Filename_set_fullpath_wo_extension_157_comment},
  {"setFullpathWoExtension", &Dtool_Filename_set_fullpath_wo_extension_157, METH_O, (const char *)Dtool_Filename_set_fullpath_wo_extension_157_comment},
  {"set_basename_wo_extension", &Dtool_Filename_set_basename_wo_extension_158, METH_O, (const char *)Dtool_Filename_set_basename_wo_extension_158_comment},
  {"setBasenameWoExtension", &Dtool_Filename_set_basename_wo_extension_158, METH_O, (const char *)Dtool_Filename_set_basename_wo_extension_158_comment},
  {"set_extension", &Dtool_Filename_set_extension_159, METH_O, (const char *)Dtool_Filename_set_extension_159_comment},
  {"setExtension", &Dtool_Filename_set_extension_159, METH_O, (const char *)Dtool_Filename_set_extension_159_comment},
  {"set_binary", &Dtool_Filename_set_binary_160, METH_NOARGS, (const char *)Dtool_Filename_set_binary_160_comment},
  {"setBinary", &Dtool_Filename_set_binary_160, METH_NOARGS, (const char *)Dtool_Filename_set_binary_160_comment},
  {"set_text", &Dtool_Filename_set_text_161, METH_NOARGS, (const char *)Dtool_Filename_set_text_161_comment},
  {"setText", &Dtool_Filename_set_text_161, METH_NOARGS, (const char *)Dtool_Filename_set_text_161_comment},
  {"is_binary", &Dtool_Filename_is_binary_162, METH_NOARGS, (const char *)Dtool_Filename_is_binary_162_comment},
  {"isBinary", &Dtool_Filename_is_binary_162, METH_NOARGS, (const char *)Dtool_Filename_is_binary_162_comment},
  {"is_text", &Dtool_Filename_is_text_163, METH_NOARGS, (const char *)Dtool_Filename_is_text_163_comment},
  {"isText", &Dtool_Filename_is_text_163, METH_NOARGS, (const char *)Dtool_Filename_is_text_163_comment},
  {"is_binary_or_text", &Dtool_Filename_is_binary_or_text_164, METH_NOARGS, (const char *)Dtool_Filename_is_binary_or_text_164_comment},
  {"isBinaryOrText", &Dtool_Filename_is_binary_or_text_164, METH_NOARGS, (const char *)Dtool_Filename_is_binary_or_text_164_comment},
  {"set_type", &Dtool_Filename_set_type_165, METH_O, (const char *)Dtool_Filename_set_type_165_comment},
  {"setType", &Dtool_Filename_set_type_165, METH_O, (const char *)Dtool_Filename_set_type_165_comment},
  {"get_type", &Dtool_Filename_get_type_166, METH_NOARGS, (const char *)Dtool_Filename_get_type_166_comment},
  {"getType", &Dtool_Filename_get_type_166, METH_NOARGS, (const char *)Dtool_Filename_get_type_166_comment},
  {"set_pattern", &Dtool_Filename_set_pattern_167, METH_O, (const char *)Dtool_Filename_set_pattern_167_comment},
  {"setPattern", &Dtool_Filename_set_pattern_167, METH_O, (const char *)Dtool_Filename_set_pattern_167_comment},
  {"get_pattern", &Dtool_Filename_get_pattern_168, METH_NOARGS, (const char *)Dtool_Filename_get_pattern_168_comment},
  {"getPattern", &Dtool_Filename_get_pattern_168, METH_NOARGS, (const char *)Dtool_Filename_get_pattern_168_comment},
  {"has_hash", &Dtool_Filename_has_hash_169, METH_NOARGS, (const char *)Dtool_Filename_has_hash_169_comment},
  {"hasHash", &Dtool_Filename_has_hash_169, METH_NOARGS, (const char *)Dtool_Filename_has_hash_169_comment},
  {"get_filename_index", &Dtool_Filename_get_filename_index_170, METH_O, (const char *)Dtool_Filename_get_filename_index_170_comment},
  {"getFilenameIndex", &Dtool_Filename_get_filename_index_170, METH_O, (const char *)Dtool_Filename_get_filename_index_170_comment},
  {"get_hash_to_end", &Dtool_Filename_get_hash_to_end_171, METH_NOARGS, (const char *)Dtool_Filename_get_hash_to_end_171_comment},
  {"getHashToEnd", &Dtool_Filename_get_hash_to_end_171, METH_NOARGS, (const char *)Dtool_Filename_get_hash_to_end_171_comment},
  {"set_hash_to_end", &Dtool_Filename_set_hash_to_end_172, METH_O, (const char *)Dtool_Filename_set_hash_to_end_172_comment},
  {"setHashToEnd", &Dtool_Filename_set_hash_to_end_172, METH_O, (const char *)Dtool_Filename_set_hash_to_end_172_comment},
  {"standardize", &Dtool_Filename_standardize_174, METH_NOARGS, (const char *)Dtool_Filename_standardize_174_comment},
  {"is_local", &Dtool_Filename_is_local_175, METH_NOARGS, (const char *)Dtool_Filename_is_local_175_comment},
  {"isLocal", &Dtool_Filename_is_local_175, METH_NOARGS, (const char *)Dtool_Filename_is_local_175_comment},
  {"is_fully_qualified", &Dtool_Filename_is_fully_qualified_176, METH_NOARGS, (const char *)Dtool_Filename_is_fully_qualified_176_comment},
  {"isFullyQualified", &Dtool_Filename_is_fully_qualified_176, METH_NOARGS, (const char *)Dtool_Filename_is_fully_qualified_176_comment},
  {"make_absolute", &Dtool_Filename_make_absolute_177, METH_VARARGS, (const char *)Dtool_Filename_make_absolute_177_comment},
  {"makeAbsolute", &Dtool_Filename_make_absolute_177, METH_VARARGS, (const char *)Dtool_Filename_make_absolute_177_comment},
  {"make_canonical", &Dtool_Filename_make_canonical_178, METH_NOARGS, (const char *)Dtool_Filename_make_canonical_178_comment},
  {"makeCanonical", &Dtool_Filename_make_canonical_178, METH_NOARGS, (const char *)Dtool_Filename_make_canonical_178_comment},
  {"make_true_case", &Dtool_Filename_make_true_case_179, METH_NOARGS, (const char *)Dtool_Filename_make_true_case_179_comment},
  {"makeTrueCase", &Dtool_Filename_make_true_case_179, METH_NOARGS, (const char *)Dtool_Filename_make_true_case_179_comment},
  {"to_os_specific", &Dtool_Filename_to_os_specific_180, METH_NOARGS, (const char *)Dtool_Filename_to_os_specific_180_comment},
  {"toOsSpecific", &Dtool_Filename_to_os_specific_180, METH_NOARGS, (const char *)Dtool_Filename_to_os_specific_180_comment},
  {"to_os_specific_w", &Dtool_Filename_to_os_specific_w_181, METH_NOARGS, (const char *)Dtool_Filename_to_os_specific_w_181_comment},
  {"toOsSpecificW", &Dtool_Filename_to_os_specific_w_181, METH_NOARGS, (const char *)Dtool_Filename_to_os_specific_w_181_comment},
  {"to_os_generic", &Dtool_Filename_to_os_generic_182, METH_NOARGS, (const char *)Dtool_Filename_to_os_generic_182_comment},
  {"toOsGeneric", &Dtool_Filename_to_os_generic_182, METH_NOARGS, (const char *)Dtool_Filename_to_os_generic_182_comment},
  {"to_os_short_name", &Dtool_Filename_to_os_short_name_183, METH_NOARGS, (const char *)Dtool_Filename_to_os_short_name_183_comment},
  {"toOsShortName", &Dtool_Filename_to_os_short_name_183, METH_NOARGS, (const char *)Dtool_Filename_to_os_short_name_183_comment},
  {"to_os_long_name", &Dtool_Filename_to_os_long_name_184, METH_NOARGS, (const char *)Dtool_Filename_to_os_long_name_184_comment},
  {"toOsLongName", &Dtool_Filename_to_os_long_name_184, METH_NOARGS, (const char *)Dtool_Filename_to_os_long_name_184_comment},
  {"exists", &Dtool_Filename_exists_185, METH_NOARGS, (const char *)Dtool_Filename_exists_185_comment},
  {"is_regular_file", &Dtool_Filename_is_regular_file_186, METH_NOARGS, (const char *)Dtool_Filename_is_regular_file_186_comment},
  {"isRegularFile", &Dtool_Filename_is_regular_file_186, METH_NOARGS, (const char *)Dtool_Filename_is_regular_file_186_comment},
  {"is_writable", &Dtool_Filename_is_writable_187, METH_NOARGS, (const char *)Dtool_Filename_is_writable_187_comment},
  {"isWritable", &Dtool_Filename_is_writable_187, METH_NOARGS, (const char *)Dtool_Filename_is_writable_187_comment},
  {"is_directory", &Dtool_Filename_is_directory_188, METH_NOARGS, (const char *)Dtool_Filename_is_directory_188_comment},
  {"isDirectory", &Dtool_Filename_is_directory_188, METH_NOARGS, (const char *)Dtool_Filename_is_directory_188_comment},
  {"is_executable", &Dtool_Filename_is_executable_189, METH_NOARGS, (const char *)Dtool_Filename_is_executable_189_comment},
  {"isExecutable", &Dtool_Filename_is_executable_189, METH_NOARGS, (const char *)Dtool_Filename_is_executable_189_comment},
  {"compare_timestamps", (PyCFunction) &Dtool_Filename_compare_timestamps_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_compare_timestamps_190_comment},
  {"compareTimestamps", (PyCFunction) &Dtool_Filename_compare_timestamps_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_compare_timestamps_190_comment},
  {"get_timestamp", &Dtool_Filename_get_timestamp_191, METH_NOARGS, (const char *)Dtool_Filename_get_timestamp_191_comment},
  {"getTimestamp", &Dtool_Filename_get_timestamp_191, METH_NOARGS, (const char *)Dtool_Filename_get_timestamp_191_comment},
  {"get_access_timestamp", &Dtool_Filename_get_access_timestamp_192, METH_NOARGS, (const char *)Dtool_Filename_get_access_timestamp_192_comment},
  {"getAccessTimestamp", &Dtool_Filename_get_access_timestamp_192, METH_NOARGS, (const char *)Dtool_Filename_get_access_timestamp_192_comment},
  {"get_file_size", &Dtool_Filename_get_file_size_193, METH_NOARGS, (const char *)Dtool_Filename_get_file_size_193_comment},
  {"getFileSize", &Dtool_Filename_get_file_size_193, METH_NOARGS, (const char *)Dtool_Filename_get_file_size_193_comment},
  {"resolve_filename", (PyCFunction) &Dtool_Filename_resolve_filename_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_resolve_filename_194_comment},
  {"resolveFilename", (PyCFunction) &Dtool_Filename_resolve_filename_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_resolve_filename_194_comment},
  {"make_relative_to", (PyCFunction) &Dtool_Filename_make_relative_to_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_make_relative_to_195_comment},
  {"makeRelativeTo", (PyCFunction) &Dtool_Filename_make_relative_to_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_make_relative_to_195_comment},
  {"find_on_searchpath", &Dtool_Filename_find_on_searchpath_196, METH_O, (const char *)Dtool_Filename_find_on_searchpath_196_comment},
  {"findOnSearchpath", &Dtool_Filename_find_on_searchpath_196, METH_O, (const char *)Dtool_Filename_find_on_searchpath_196_comment},
  {"scan_directory", &Dtool_Filename_scan_directory_197, METH_VARARGS, (const char *)Dtool_Filename_scan_directory_197_comment},
  {"scanDirectory", &Dtool_Filename_scan_directory_197, METH_VARARGS, (const char *)Dtool_Filename_scan_directory_197_comment},
  {"open_read", &Dtool_Filename_open_read_198, METH_O, (const char *)Dtool_Filename_open_read_198_comment},
  {"openRead", &Dtool_Filename_open_read_198, METH_O, (const char *)Dtool_Filename_open_read_198_comment},
  {"open_write", (PyCFunction) &Dtool_Filename_open_write_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_open_write_199_comment},
  {"openWrite", (PyCFunction) &Dtool_Filename_open_write_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_open_write_199_comment},
  {"open_append", &Dtool_Filename_open_append_200, METH_O, (const char *)Dtool_Filename_open_append_200_comment},
  {"openAppend", &Dtool_Filename_open_append_200, METH_O, (const char *)Dtool_Filename_open_append_200_comment},
  {"open_read_write", (PyCFunction) &Dtool_Filename_open_read_write_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_open_read_write_201_comment},
  {"openReadWrite", (PyCFunction) &Dtool_Filename_open_read_write_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_open_read_write_201_comment},
  {"open_read_append", &Dtool_Filename_open_read_append_202, METH_O, (const char *)Dtool_Filename_open_read_append_202_comment},
  {"openReadAppend", &Dtool_Filename_open_read_append_202, METH_O, (const char *)Dtool_Filename_open_read_append_202_comment},
  {"chdir", &Dtool_Filename_chdir_203, METH_NOARGS, (const char *)Dtool_Filename_chdir_203_comment},
  {"touch", &Dtool_Filename_touch_204, METH_NOARGS, (const char *)Dtool_Filename_touch_204_comment},
  {"unlink", &Dtool_Filename_unlink_205, METH_NOARGS, (const char *)Dtool_Filename_unlink_205_comment},
  {"rename_to", &Dtool_Filename_rename_to_206, METH_O, (const char *)Dtool_Filename_rename_to_206_comment},
  {"renameTo", &Dtool_Filename_rename_to_206, METH_O, (const char *)Dtool_Filename_rename_to_206_comment},
  {"copy_to", &Dtool_Filename_copy_to_207, METH_O, (const char *)Dtool_Filename_copy_to_207_comment},
  {"copyTo", &Dtool_Filename_copy_to_207, METH_O, (const char *)Dtool_Filename_copy_to_207_comment},
  {"make_dir", &Dtool_Filename_make_dir_208, METH_NOARGS, (const char *)Dtool_Filename_make_dir_208_comment},
  {"makeDir", &Dtool_Filename_make_dir_208, METH_NOARGS, (const char *)Dtool_Filename_make_dir_208_comment},
  {"mkdir", &Dtool_Filename_mkdir_209, METH_NOARGS, (const char *)Dtool_Filename_mkdir_209_comment},
  {"rmdir", &Dtool_Filename_rmdir_210, METH_NOARGS, (const char *)Dtool_Filename_rmdir_210_comment},
  {"compare_to", &Dtool_Filename_compare_to_214, METH_O, (const char *)Dtool_Filename_compare_to_214_comment},
  {"compareTo", &Dtool_Filename_compare_to_214, METH_O, (const char *)Dtool_Filename_compare_to_214_comment},
  {"get_hash", &Dtool_Filename_get_hash_216, METH_NOARGS, (const char *)Dtool_Filename_get_hash_216_comment},
  {"getHash", &Dtool_Filename_get_hash_216, METH_NOARGS, (const char *)Dtool_Filename_get_hash_216_comment},
  {"output", &Dtool_Filename_output_217, METH_O, (const char *)Dtool_Filename_output_217_comment},
  {"set_filesystem_encoding", &Dtool_Filename_set_filesystem_encoding_218, METH_O | METH_STATIC, (const char *)Dtool_Filename_set_filesystem_encoding_218_comment},
  {"setFilesystemEncoding", &Dtool_Filename_set_filesystem_encoding_218, METH_O | METH_STATIC, (const char *)Dtool_Filename_set_filesystem_encoding_218_comment},
  {"get_filesystem_encoding", &Dtool_Filename_get_filesystem_encoding_219, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_filesystem_encoding_219_comment},
  {"getFilesystemEncoding", &Dtool_Filename_get_filesystem_encoding_219, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_filesystem_encoding_219_comment},
  {"get_class_type", &Dtool_Filename_get_class_type_220, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_class_type_220_comment},
  {"getClassType", &Dtool_Filename_get_class_type_220, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_class_type_220_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot mp_subscript -> operator []
//////////////////
static PyObject *Dtool_Filename_operator_140_mp_subscript(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return nullptr;
  }
  // 1-inline char Filename::operator [](std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    char return_value = ((*(const Filename*)local_this).operator [])(arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Filename self, int n)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot nb_add -> operator +
//////////////////
static PyObject *Dtool_Filename_operator_145_nb_add(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_Filename, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline Filename Filename::operator +(std::string const &other) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    Filename *return_value = new Filename(((*(const Filename*)local_this).operator +)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot nb_bool -> __nonzero__
//////////////////
static int Dtool_Filename_nonzero_215_nb_bool(PyObject *self) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return -1;
  }

  return (int) ((*local_this).__nonzero__)();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_Filename_operator_146_nb_divide(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_Filename, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline Filename Filename::operator /(Filename const &other) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Filename.__div__", "Filename");
  }
  Filename *return_value = new Filename(((*(const Filename*)local_this).operator /)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_Filename_operator_144_nb_inplace_add(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_Filename, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void Filename::operator +=(std::string const &other)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).operator +=)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot tp_compare -> compare_to
//////////////////
static int Dtool_Filename_compare_to_214_tp_compare(PyObject *self, PyObject *arg) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int Filename::compare_to(Filename const &other) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Filename.compare_to", "Filename");
    return -1;
  }
  int return_value = ((*(const Filename*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(Filename self, const Filename other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_Filename_get_hash_216_tp_hash(PyObject *self) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_hash)();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_Filename_repr_141_tp_repr(PyObject *self) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PyObject *Filename::__repr__(void) const
  PyObject *return_value = invoke_extension((const Filename*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(Filename self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot tp_str -> operator typecast
//////////////////
static PyObject *Dtool_Filename_operator_typecast_136_tp_str(PyObject *self) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline operator std::string const &(void) const
  std::string const &return_value = (std::string const &)*(const Filename*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast(Filename self)\n");
  }
  return nullptr;
}

//////////////////
//  A rich comparison function
//     Filename
//////////////////
static PyObject *Dtool_RichCompare_Filename(PyObject *self, PyObject *arg, int op) {
  Filename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool Filename::operator ==(std::string const &other) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        bool return_value = ((*(const Filename*)local_this).operator ==)(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  case Py_NE:
    {
      // 1-inline bool Filename::operator !=(std::string const &other) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        bool return_value = ((*(const Filename*)local_this).operator !=)(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  case Py_LT:
    {
      // 1-inline bool Filename::operator <(std::string const &other) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        bool return_value = ((*(const Filename*)local_this).operator <)(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_Filename_compare_to_214_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_Filename = {
  &Dtool_Filename_operator_145_nb_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  &Dtool_Filename_operator_146_nb_divide,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_Filename_nonzero_215_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_Filename_operator_144_nb_inplace_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PyMappingMethods Dtool_MappingMethods_Filename = {
  nullptr,
  &Dtool_Filename_operator_140_mp_subscript,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_Filename = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Filename",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Filename,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_Filename_compare_to_214_tp_compare,
#endif
    &Dtool_Filename_repr_141_tp_repr,
    &Dtool_NumberMethods_Filename,
    nullptr, // tp_as_sequence
    &Dtool_MappingMethods_Filename,
    &Dtool_Filename_get_hash_216_tp_hash,
    nullptr,
    &Dtool_Filename_operator_typecast_136_tp_str,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The name of a file, such as a texture file or an Egg file.  Stores the full\n"
    " * pathname, and includes functions for extracting out the directory prefix\n"
    " * part and the file extension and stuff.\n"
    " *\n"
    " * A Filename is also aware of the mapping between the Unix-like filename\n"
    " * convention we use internally, and the local OS's specific filename\n"
    " * convention, and it knows how to perform basic OS-specific I/O, like testing\n"
    " * for file existence and searching a searchpath, as well as the best way to\n"
    " * open an fstream for reading or writing.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_Filename,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Filename,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Filename,
    PyType_GenericAlloc,
    Dtool_new_Filename,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Filename,
  Dtool_UpcastInterface_Filename,
  Dtool_DowncastInterface_Filename,
  nullptr,
  (CoerceFunction)Dtool_Coerce_Filename,
};

static void Dtool_PyModuleClassInit_Filename(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Filename._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_Filename._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum Filename::Type;
    PyDict_SetItemString(dict, "T_general", Dtool_WrapValue(Filename::T_general));
    PyDict_SetItemString(dict, "TGeneral", Dtool_WrapValue(Filename::T_general));
    PyDict_SetItemString(dict, "T_dso", Dtool_WrapValue(Filename::T_dso));
    PyDict_SetItemString(dict, "TDso", Dtool_WrapValue(Filename::T_dso));
    PyDict_SetItemString(dict, "T_executable", Dtool_WrapValue(Filename::T_executable));
    PyDict_SetItemString(dict, "TExecutable", Dtool_WrapValue(Filename::T_executable));
    if (PyType_Ready((PyTypeObject *)&Dtool_Filename) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Filename)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Filename);
  }
}

/**
 * Python method tables for PandaSystem (PandaSystem)
 */
static PyMethodDef Dtool_Methods_PandaSystem[] = {
  {"get_version_string", &Dtool_PandaSystem_get_version_string_223, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_version_string_223_comment},
  {"getVersionString", &Dtool_PandaSystem_get_version_string_223, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_version_string_223_comment},
  {"get_package_version_string", &Dtool_PandaSystem_get_package_version_string_224, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_package_version_string_224_comment},
  {"getPackageVersionString", &Dtool_PandaSystem_get_package_version_string_224, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_package_version_string_224_comment},
  {"get_package_host_url", &Dtool_PandaSystem_get_package_host_url_225, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_package_host_url_225_comment},
  {"getPackageHostUrl", &Dtool_PandaSystem_get_package_host_url_225, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_package_host_url_225_comment},
  {"get_p3d_coreapi_version_string", &Dtool_PandaSystem_get_p3d_coreapi_version_string_226, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_p3d_coreapi_version_string_226_comment},
  {"getP3dCoreapiVersionString", &Dtool_PandaSystem_get_p3d_coreapi_version_string_226, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_p3d_coreapi_version_string_226_comment},
  {"get_major_version", &Dtool_PandaSystem_get_major_version_227, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_major_version_227_comment},
  {"getMajorVersion", &Dtool_PandaSystem_get_major_version_227, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_major_version_227_comment},
  {"get_minor_version", &Dtool_PandaSystem_get_minor_version_228, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_minor_version_228_comment},
  {"getMinorVersion", &Dtool_PandaSystem_get_minor_version_228, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_minor_version_228_comment},
  {"get_sequence_version", &Dtool_PandaSystem_get_sequence_version_229, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_sequence_version_229_comment},
  {"getSequenceVersion", &Dtool_PandaSystem_get_sequence_version_229, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_sequence_version_229_comment},
  {"is_official_version", &Dtool_PandaSystem_is_official_version_230, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_is_official_version_230_comment},
  {"isOfficialVersion", &Dtool_PandaSystem_is_official_version_230, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_is_official_version_230_comment},
  {"get_memory_alignment", &Dtool_PandaSystem_get_memory_alignment_231, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_memory_alignment_231_comment},
  {"getMemoryAlignment", &Dtool_PandaSystem_get_memory_alignment_231, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_memory_alignment_231_comment},
  {"get_distributor", &Dtool_PandaSystem_get_distributor_232, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_distributor_232_comment},
  {"getDistributor", &Dtool_PandaSystem_get_distributor_232, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_distributor_232_comment},
  {"get_compiler", &Dtool_PandaSystem_get_compiler_233, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_compiler_233_comment},
  {"getCompiler", &Dtool_PandaSystem_get_compiler_233, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_compiler_233_comment},
  {"get_build_date", &Dtool_PandaSystem_get_build_date_234, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_build_date_234_comment},
  {"getBuildDate", &Dtool_PandaSystem_get_build_date_234, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_build_date_234_comment},
  {"get_git_commit", &Dtool_PandaSystem_get_git_commit_235, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_git_commit_235_comment},
  {"getGitCommit", &Dtool_PandaSystem_get_git_commit_235, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_git_commit_235_comment},
  {"get_platform", &Dtool_PandaSystem_get_platform_236, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_platform_236_comment},
  {"getPlatform", &Dtool_PandaSystem_get_platform_236, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_platform_236_comment},
  {"has_system", &Dtool_PandaSystem_has_system_252, METH_O, (const char *)Dtool_PandaSystem_has_system_252_comment},
  {"hasSystem", &Dtool_PandaSystem_has_system_252, METH_O, (const char *)Dtool_PandaSystem_has_system_252_comment},
  {"get_num_systems", &Dtool_PandaSystem_get_num_systems_253, METH_NOARGS, (const char *)Dtool_PandaSystem_get_num_systems_253_comment},
  {"getNumSystems", &Dtool_PandaSystem_get_num_systems_253, METH_NOARGS, (const char *)Dtool_PandaSystem_get_num_systems_253_comment},
  {"get_system", &Dtool_PandaSystem_get_system_254, METH_O, (const char *)Dtool_PandaSystem_get_system_254_comment},
  {"getSystem", &Dtool_PandaSystem_get_system_254, METH_O, (const char *)Dtool_PandaSystem_get_system_254_comment},
  {"get_system_tag", (PyCFunction) &Dtool_PandaSystem_get_system_tag_257, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaSystem_get_system_tag_257_comment},
  {"getSystemTag", (PyCFunction) &Dtool_PandaSystem_get_system_tag_257, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaSystem_get_system_tag_257_comment},
  {"add_system", &Dtool_PandaSystem_add_system_258, METH_O, (const char *)Dtool_PandaSystem_add_system_258_comment},
  {"addSystem", &Dtool_PandaSystem_add_system_258, METH_O, (const char *)Dtool_PandaSystem_add_system_258_comment},
  {"set_system_tag", (PyCFunction) &Dtool_PandaSystem_set_system_tag_259, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaSystem_set_system_tag_259_comment},
  {"setSystemTag", (PyCFunction) &Dtool_PandaSystem_set_system_tag_259, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaSystem_set_system_tag_259_comment},
  {"heap_trim", &Dtool_PandaSystem_heap_trim_260, METH_O, (const char *)Dtool_PandaSystem_heap_trim_260_comment},
  {"heapTrim", &Dtool_PandaSystem_heap_trim_260, METH_O, (const char *)Dtool_PandaSystem_heap_trim_260_comment},
  {"output", &Dtool_PandaSystem_output_261, METH_O, (const char *)Dtool_PandaSystem_output_261_comment},
  {"write", &Dtool_PandaSystem_write_262, METH_O, (const char *)Dtool_PandaSystem_write_262_comment},
  {"get_global_ptr", &Dtool_PandaSystem_get_global_ptr_263, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_global_ptr_263_comment},
  {"getGlobalPtr", &Dtool_PandaSystem_get_global_ptr_263, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_global_ptr_263_comment},
  {"get_class_type", &Dtool_PandaSystem_get_class_type_264, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_class_type_264_comment},
  {"getClassType", &Dtool_PandaSystem_get_class_type_264, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_class_type_264_comment},
  {"get_systems", (PyCFunction) &MakeSeq_PandaSystem_get_systems, METH_NOARGS, nullptr},
  { "getSystems", (PyCFunction) &MakeSeq_PandaSystem_get_systems, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PandaSystem
//////////////////
static PyObject *Dtool_Repr_PandaSystem(PyObject *self) {
  PandaSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     PandaSystem
//////////////////
static PyObject *Dtool_Str_PandaSystem(PyObject *self) {
  PandaSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PandaSystem[] = {
  {(char *)"systems", &Dtool_PandaSystem_systems_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PandaSystem = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PandaSystem = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PandaSystem",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PandaSystem,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PandaSystem,
    &Dtool_NumberMethods_PandaSystem,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_PandaSystem,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used as a namespace to group several global properties of\n"
    " * Panda.  Application developers can use this class to query the runtime\n"
    " * version or capabilities of the current Panda environment.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PandaSystem,
    nullptr, // tp_members
    Dtool_Properties_PandaSystem,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PandaSystem,
    PyType_GenericAlloc,
    Dtool_new_PandaSystem,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PandaSystem,
  Dtool_UpcastInterface_PandaSystem,
  Dtool_DowncastInterface_PandaSystem,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PandaSystem(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PandaSystem._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PandaSystem._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_version_string = {(char *)"version_string", &Dtool_PandaSystem_version_string_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "version_string", Dtool_NewStaticProperty(&Dtool_PandaSystem._PyType, &def_version_string));
    static const PyGetSetDef def_major_version = {(char *)"major_version", &Dtool_PandaSystem_major_version_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "major_version", Dtool_NewStaticProperty(&Dtool_PandaSystem._PyType, &def_major_version));
    static const PyGetSetDef def_minor_version = {(char *)"minor_version", &Dtool_PandaSystem_minor_version_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "minor_version", Dtool_NewStaticProperty(&Dtool_PandaSystem._PyType, &def_minor_version));
    static const PyGetSetDef def_sequence_version = {(char *)"sequence_version", &Dtool_PandaSystem_sequence_version_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "sequence_version", Dtool_NewStaticProperty(&Dtool_PandaSystem._PyType, &def_sequence_version));
    static const PyGetSetDef def_official_version = {(char *)"official_version", &Dtool_PandaSystem_official_version_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "official_version", Dtool_NewStaticProperty(&Dtool_PandaSystem._PyType, &def_official_version));
    static const PyGetSetDef def_memory_alignment = {(char *)"memory_alignment", &Dtool_PandaSystem_memory_alignment_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "memory_alignment", Dtool_NewStaticProperty(&Dtool_PandaSystem._PyType, &def_memory_alignment));
    static const PyGetSetDef def_distributor = {(char *)"distributor", &Dtool_PandaSystem_distributor_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "distributor", Dtool_NewStaticProperty(&Dtool_PandaSystem._PyType, &def_distributor));
    static const PyGetSetDef def_compiler = {(char *)"compiler", &Dtool_PandaSystem_compiler_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "compiler", Dtool_NewStaticProperty(&Dtool_PandaSystem._PyType, &def_compiler));
    static const PyGetSetDef def_build_date = {(char *)"build_date", &Dtool_PandaSystem_build_date_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "build_date", Dtool_NewStaticProperty(&Dtool_PandaSystem._PyType, &def_build_date));
    static const PyGetSetDef def_git_commit = {(char *)"git_commit", &Dtool_PandaSystem_git_commit_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "git_commit", Dtool_NewStaticProperty(&Dtool_PandaSystem._PyType, &def_git_commit));
    static const PyGetSetDef def_platform = {(char *)"platform", &Dtool_PandaSystem_platform_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "platform", Dtool_NewStaticProperty(&Dtool_PandaSystem._PyType, &def_platform));
    if (PyType_Ready((PyTypeObject *)&Dtool_PandaSystem) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PandaSystem)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PandaSystem);
  }
}

/**
 * Python method tables for DSearchPath_Results (Results)
 */
static PyMethodDef Dtool_Methods_DSearchPath_Results[] = {
  {"assign", &Dtool_DSearchPath_Results_operator_268, METH_O, (const char *)Dtool_DSearchPath_Results_operator_268_comment},
  {"clear", &Dtool_DSearchPath_Results_clear_270, METH_NOARGS, (const char *)Dtool_DSearchPath_Results_clear_270_comment},
  {"get_num_files", &Dtool_DSearchPath_Results_get_num_files_271, METH_NOARGS, (const char *)Dtool_DSearchPath_Results_get_num_files_271_comment},
  {"getNumFiles", &Dtool_DSearchPath_Results_get_num_files_271, METH_NOARGS, (const char *)Dtool_DSearchPath_Results_get_num_files_271_comment},
  {"get_file", &Dtool_DSearchPath_Results_get_file_272, METH_O, (const char *)Dtool_DSearchPath_Results_get_file_272_comment},
  {"getFile", &Dtool_DSearchPath_Results_get_file_272, METH_O, (const char *)Dtool_DSearchPath_Results_get_file_272_comment},
  {"output", &Dtool_DSearchPath_Results_output_275, METH_O, (const char *)Dtool_DSearchPath_Results_output_275_comment},
  {"write", (PyCFunction) &Dtool_DSearchPath_Results_write_276, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_Results_write_276_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DSearchPath_Results slot sq_item -> operator []
//////////////////
static PyObject *Dtool_DSearchPath_Results_operator_273_sq_item(PyObject *self, Py_ssize_t index) {
  DSearchPath::Results *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "DSearchPath_Results index out of range");
    return nullptr;
  }
  // 1-inline Filename DSearchPath::Results::operator [](std::size_t n) const
  Filename *return_value = new Filename(((*(const DSearchPath::Results*)local_this).operator [])(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Results self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DSearchPath_Results slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_DSearchPath_Results_size_274_sq_length(PyObject *self) {
  DSearchPath::Results *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     DSearchPath_Results
//////////////////
static PyObject *Dtool_Repr_DSearchPath_Results(PyObject *self) {
  DSearchPath::Results *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DSearchPath_Results
//////////////////
static PyObject *Dtool_Str_DSearchPath_Results(PyObject *self) {
  DSearchPath::Results *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DSearchPath_Results = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DSearchPath_Results = {
  &Dtool_DSearchPath_Results_size_274_sq_length,
  nullptr,
  nullptr,
  &Dtool_DSearchPath_Results_operator_273_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_DSearchPath_Results = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Results",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DSearchPath_Results,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_DSearchPath_Results,
    &Dtool_NumberMethods_DSearchPath_Results,
    &Dtool_SequenceMethods_DSearchPath_Results,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_DSearchPath_Results,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DSearchPath_Results,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DSearchPath_Results,
    PyType_GenericAlloc,
    Dtool_new_DSearchPath_Results,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DSearchPath_Results,
  Dtool_UpcastInterface_DSearchPath_Results,
  Dtool_DowncastInterface_DSearchPath_Results,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DSearchPath_Results(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DSearchPath_Results._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DSearchPath_Results._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DSearchPath_Results) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DSearchPath_Results)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DSearchPath_Results);
  }
}

/**
 * Python method tables for DSearchPath (DSearchPath)
 */
static PyMethodDef Dtool_Methods_DSearchPath[] = {
  {"assign", &Dtool_DSearchPath_operator_279, METH_O, (const char *)Dtool_DSearchPath_operator_279_comment},
  {"clear", &Dtool_DSearchPath_clear_280, METH_NOARGS, (const char *)Dtool_DSearchPath_clear_280_comment},
  {"append_directory", &Dtool_DSearchPath_append_directory_281, METH_O, (const char *)Dtool_DSearchPath_append_directory_281_comment},
  {"appendDirectory", &Dtool_DSearchPath_append_directory_281, METH_O, (const char *)Dtool_DSearchPath_append_directory_281_comment},
  {"prepend_directory", &Dtool_DSearchPath_prepend_directory_282, METH_O, (const char *)Dtool_DSearchPath_prepend_directory_282_comment},
  {"prependDirectory", &Dtool_DSearchPath_prepend_directory_282, METH_O, (const char *)Dtool_DSearchPath_prepend_directory_282_comment},
  {"append_path", (PyCFunction) &Dtool_DSearchPath_append_path_283, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_append_path_283_comment},
  {"appendPath", (PyCFunction) &Dtool_DSearchPath_append_path_283, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_append_path_283_comment},
  {"prepend_path", &Dtool_DSearchPath_prepend_path_284, METH_O, (const char *)Dtool_DSearchPath_prepend_path_284_comment},
  {"prependPath", &Dtool_DSearchPath_prepend_path_284, METH_O, (const char *)Dtool_DSearchPath_prepend_path_284_comment},
  {"is_empty", &Dtool_DSearchPath_is_empty_285, METH_NOARGS, (const char *)Dtool_DSearchPath_is_empty_285_comment},
  {"isEmpty", &Dtool_DSearchPath_is_empty_285, METH_NOARGS, (const char *)Dtool_DSearchPath_is_empty_285_comment},
  {"get_num_directories", &Dtool_DSearchPath_get_num_directories_286, METH_NOARGS, (const char *)Dtool_DSearchPath_get_num_directories_286_comment},
  {"getNumDirectories", &Dtool_DSearchPath_get_num_directories_286, METH_NOARGS, (const char *)Dtool_DSearchPath_get_num_directories_286_comment},
  {"get_directory", &Dtool_DSearchPath_get_directory_287, METH_O, (const char *)Dtool_DSearchPath_get_directory_287_comment},
  {"getDirectory", &Dtool_DSearchPath_get_directory_287, METH_O, (const char *)Dtool_DSearchPath_get_directory_287_comment},
  {"find_file", &Dtool_DSearchPath_find_file_291, METH_O, (const char *)Dtool_DSearchPath_find_file_291_comment},
  {"findFile", &Dtool_DSearchPath_find_file_291, METH_O, (const char *)Dtool_DSearchPath_find_file_291_comment},
  {"find_all_files", (PyCFunction) &Dtool_DSearchPath_find_all_files_292, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_find_all_files_292_comment},
  {"findAllFiles", (PyCFunction) &Dtool_DSearchPath_find_all_files_292, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_find_all_files_292_comment},
  {"search_path", (PyCFunction) &Dtool_DSearchPath_search_path_293, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DSearchPath_search_path_293_comment},
  {"searchPath", (PyCFunction) &Dtool_DSearchPath_search_path_293, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DSearchPath_search_path_293_comment},
  {"output", (PyCFunction) &Dtool_DSearchPath_output_294, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_output_294_comment},
  {"write", (PyCFunction) &Dtool_DSearchPath_write_295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_write_295_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_directories", (PyCFunction) &MakeSeq_DSearchPath_get_directories, METH_NOARGS, nullptr},
  { "getDirectories", (PyCFunction) &MakeSeq_DSearchPath_get_directories, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     DSearchPath
//////////////////
static PyObject *Dtool_Repr_DSearchPath(PyObject *self) {
  DSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DSearchPath
//////////////////
static PyObject *Dtool_Str_DSearchPath(PyObject *self) {
  DSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_DSearchPath[] = {
  {(char *)"directories", &Dtool_DSearchPath_directories_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DSearchPath = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DSearchPath = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DSearchPath",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DSearchPath,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_DSearchPath,
    &Dtool_NumberMethods_DSearchPath,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_DSearchPath,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class stores a list of directories that can be searched, in order, to\n"
    " * locate a particular file.  It is normally constructed by passing it a\n"
    " * traditional searchpath-style string, e.g.  a list of directory names\n"
    " * delimited by spaces or colons, but it can also be built up explicitly.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DSearchPath,
    nullptr, // tp_members
    Dtool_Properties_DSearchPath,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DSearchPath,
    PyType_GenericAlloc,
    Dtool_new_DSearchPath,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DSearchPath,
  Dtool_UpcastInterface_DSearchPath,
  Dtool_DowncastInterface_DSearchPath,
  nullptr,
  (CoerceFunction)Dtool_Coerce_DSearchPath,
};

static void Dtool_PyModuleClassInit_DSearchPath(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DSearchPath._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DSearchPath._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Nested Object   DSearchPath_Results;
    Dtool_PyModuleClassInit_DSearchPath_Results(nullptr);
    PyDict_SetItemString(dict, "Results", (PyObject *)&Dtool_DSearchPath_Results);
    if (PyType_Ready((PyTypeObject *)&Dtool_DSearchPath) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DSearchPath)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DSearchPath);
  }
}

/**
 * Python method tables for ExecutionEnvironment (ExecutionEnvironment)
 */
static PyMethodDef Dtool_Methods_ExecutionEnvironment[] = {
  {"has_environment_variable", &Dtool_ExecutionEnvironment_has_environment_variable_297, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_has_environment_variable_297_comment},
  {"hasEnvironmentVariable", &Dtool_ExecutionEnvironment_has_environment_variable_297, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_has_environment_variable_297_comment},
  {"get_environment_variable", &Dtool_ExecutionEnvironment_get_environment_variable_298, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_environment_variable_298_comment},
  {"getEnvironmentVariable", &Dtool_ExecutionEnvironment_get_environment_variable_298, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_environment_variable_298_comment},
  {"set_environment_variable", (PyCFunction) &Dtool_ExecutionEnvironment_set_environment_variable_299, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_environment_variable_299_comment},
  {"setEnvironmentVariable", (PyCFunction) &Dtool_ExecutionEnvironment_set_environment_variable_299, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_environment_variable_299_comment},
  {"shadow_environment_variable", (PyCFunction) &Dtool_ExecutionEnvironment_shadow_environment_variable_300, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_shadow_environment_variable_300_comment},
  {"shadowEnvironmentVariable", (PyCFunction) &Dtool_ExecutionEnvironment_shadow_environment_variable_300, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_shadow_environment_variable_300_comment},
  {"clear_shadow", &Dtool_ExecutionEnvironment_clear_shadow_301, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_clear_shadow_301_comment},
  {"clearShadow", &Dtool_ExecutionEnvironment_clear_shadow_301, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_clear_shadow_301_comment},
  {"expand_string", &Dtool_ExecutionEnvironment_expand_string_302, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_expand_string_302_comment},
  {"expandString", &Dtool_ExecutionEnvironment_expand_string_302, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_expand_string_302_comment},
  {"get_num_args", &Dtool_ExecutionEnvironment_get_num_args_303, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_num_args_303_comment},
  {"getNumArgs", &Dtool_ExecutionEnvironment_get_num_args_303, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_num_args_303_comment},
  {"get_arg", &Dtool_ExecutionEnvironment_get_arg_304, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_arg_304_comment},
  {"getArg", &Dtool_ExecutionEnvironment_get_arg_304, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_arg_304_comment},
  {"get_binary_name", &Dtool_ExecutionEnvironment_get_binary_name_305, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_binary_name_305_comment},
  {"getBinaryName", &Dtool_ExecutionEnvironment_get_binary_name_305, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_binary_name_305_comment},
  {"get_dtool_name", &Dtool_ExecutionEnvironment_get_dtool_name_306, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_dtool_name_306_comment},
  {"getDtoolName", &Dtool_ExecutionEnvironment_get_dtool_name_306, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_dtool_name_306_comment},
  {"set_binary_name", &Dtool_ExecutionEnvironment_set_binary_name_307, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_binary_name_307_comment},
  {"setBinaryName", &Dtool_ExecutionEnvironment_set_binary_name_307, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_binary_name_307_comment},
  {"set_dtool_name", &Dtool_ExecutionEnvironment_set_dtool_name_308, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_dtool_name_308_comment},
  {"setDtoolName", &Dtool_ExecutionEnvironment_set_dtool_name_308, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_dtool_name_308_comment},
  {"get_cwd", &Dtool_ExecutionEnvironment_get_cwd_309, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_cwd_309_comment},
  {"getCwd", &Dtool_ExecutionEnvironment_get_cwd_309, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_cwd_309_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ExecutionEnvironment = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ExecutionEnvironment = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ExecutionEnvironment",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ExecutionEnvironment,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ExecutionEnvironment,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Encapsulates access to the environment variables and command-line arguments\n"
    " * at the time of execution.  This is encapsulated to support accessing these\n"
    " * things during static init time, which seems to be risky at best.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ExecutionEnvironment,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ExecutionEnvironment,
    PyType_GenericAlloc,
    Dtool_new_ExecutionEnvironment,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ExecutionEnvironment,
  Dtool_UpcastInterface_ExecutionEnvironment,
  Dtool_DowncastInterface_ExecutionEnvironment,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ExecutionEnvironment(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ExecutionEnvironment._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ExecutionEnvironment._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_environment_variables = {(char *)"environment_variables", &Dtool_ExecutionEnvironment_environment_variables_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "environment_variables", Dtool_NewStaticProperty(&Dtool_ExecutionEnvironment._PyType, &def_environment_variables));
    static const PyGetSetDef def_args = {(char *)"args", &Dtool_ExecutionEnvironment_args_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "args", Dtool_NewStaticProperty(&Dtool_ExecutionEnvironment._PyType, &def_args));
    static const PyGetSetDef def_binary_name = {(char *)"binary_name", &Dtool_ExecutionEnvironment_binary_name_Getter, &Dtool_ExecutionEnvironment_binary_name_Setter, nullptr, nullptr};
    PyDict_SetItemString(dict, "binary_name", Dtool_NewStaticProperty(&Dtool_ExecutionEnvironment._PyType, &def_binary_name));
    static const PyGetSetDef def_dtool_name = {(char *)"dtool_name", &Dtool_ExecutionEnvironment_dtool_name_Getter, &Dtool_ExecutionEnvironment_dtool_name_Setter, nullptr, nullptr};
    PyDict_SetItemString(dict, "dtool_name", Dtool_NewStaticProperty(&Dtool_ExecutionEnvironment._PyType, &def_dtool_name));
    static const PyGetSetDef def_cwd = {(char *)"cwd", &Dtool_ExecutionEnvironment_cwd_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "cwd", Dtool_NewStaticProperty(&Dtool_ExecutionEnvironment._PyType, &def_cwd));
    if (PyType_Ready((PyTypeObject *)&Dtool_ExecutionEnvironment) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ExecutionEnvironment)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ExecutionEnvironment);
  }
}

/**
 * Python method tables for GlobPattern (GlobPattern)
 */
static PyMethodDef Dtool_Methods_GlobPattern[] = {
  {"assign", &Dtool_GlobPattern_operator_319, METH_O, (const char *)Dtool_GlobPattern_operator_319_comment},
  {"set_pattern", &Dtool_GlobPattern_set_pattern_323, METH_O, (const char *)Dtool_GlobPattern_set_pattern_323_comment},
  {"setPattern", &Dtool_GlobPattern_set_pattern_323, METH_O, (const char *)Dtool_GlobPattern_set_pattern_323_comment},
  {"get_pattern", &Dtool_GlobPattern_get_pattern_324, METH_NOARGS, (const char *)Dtool_GlobPattern_get_pattern_324_comment},
  {"getPattern", &Dtool_GlobPattern_get_pattern_324, METH_NOARGS, (const char *)Dtool_GlobPattern_get_pattern_324_comment},
  {"set_case_sensitive", &Dtool_GlobPattern_set_case_sensitive_327, METH_O, (const char *)Dtool_GlobPattern_set_case_sensitive_327_comment},
  {"setCaseSensitive", &Dtool_GlobPattern_set_case_sensitive_327, METH_O, (const char *)Dtool_GlobPattern_set_case_sensitive_327_comment},
  {"get_case_sensitive", &Dtool_GlobPattern_get_case_sensitive_328, METH_NOARGS, (const char *)Dtool_GlobPattern_get_case_sensitive_328_comment},
  {"getCaseSensitive", &Dtool_GlobPattern_get_case_sensitive_328, METH_NOARGS, (const char *)Dtool_GlobPattern_get_case_sensitive_328_comment},
  {"set_nomatch_chars", &Dtool_GlobPattern_set_nomatch_chars_330, METH_O, (const char *)Dtool_GlobPattern_set_nomatch_chars_330_comment},
  {"setNomatchChars", &Dtool_GlobPattern_set_nomatch_chars_330, METH_O, (const char *)Dtool_GlobPattern_set_nomatch_chars_330_comment},
  {"get_nomatch_chars", &Dtool_GlobPattern_get_nomatch_chars_331, METH_NOARGS, (const char *)Dtool_GlobPattern_get_nomatch_chars_331_comment},
  {"getNomatchChars", &Dtool_GlobPattern_get_nomatch_chars_331, METH_NOARGS, (const char *)Dtool_GlobPattern_get_nomatch_chars_331_comment},
  {"matches", &Dtool_GlobPattern_matches_333, METH_O, (const char *)Dtool_GlobPattern_matches_333_comment},
  {"matches_file", &Dtool_GlobPattern_matches_file_334, METH_O, (const char *)Dtool_GlobPattern_matches_file_334_comment},
  {"matchesFile", &Dtool_GlobPattern_matches_file_334, METH_O, (const char *)Dtool_GlobPattern_matches_file_334_comment},
  {"output", &Dtool_GlobPattern_output_335, METH_O, (const char *)Dtool_GlobPattern_output_335_comment},
  {"has_glob_characters", &Dtool_GlobPattern_has_glob_characters_336, METH_NOARGS, (const char *)Dtool_GlobPattern_has_glob_characters_336_comment},
  {"hasGlobCharacters", &Dtool_GlobPattern_has_glob_characters_336, METH_NOARGS, (const char *)Dtool_GlobPattern_has_glob_characters_336_comment},
  {"get_const_prefix", &Dtool_GlobPattern_get_const_prefix_337, METH_NOARGS, (const char *)Dtool_GlobPattern_get_const_prefix_337_comment},
  {"getConstPrefix", &Dtool_GlobPattern_get_const_prefix_337, METH_NOARGS, (const char *)Dtool_GlobPattern_get_const_prefix_337_comment},
  {"match_files", (PyCFunction) &Dtool_GlobPattern_match_files_338, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GlobPattern_match_files_338_comment},
  {"matchFiles", (PyCFunction) &Dtool_GlobPattern_match_files_338, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GlobPattern_match_files_338_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     GlobPattern
//////////////////
static PyObject *Dtool_Repr_GlobPattern(PyObject *self) {
  GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     GlobPattern
//////////////////
static PyObject *Dtool_RichCompare_GlobPattern(PyObject *self, PyObject *arg, int op) {
  GlobPattern *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool GlobPattern::operator ==(GlobPattern const &other) const
      GlobPattern arg_local;
      GlobPattern const *arg_this = Dtool_Coerce_GlobPattern(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const GlobPattern*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool GlobPattern::operator !=(GlobPattern const &other) const
      GlobPattern arg_local;
      GlobPattern const *arg_this = Dtool_Coerce_GlobPattern(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const GlobPattern*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool GlobPattern::operator <(GlobPattern const &other) const
      GlobPattern arg_local;
      GlobPattern const *arg_this = Dtool_Coerce_GlobPattern(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const GlobPattern*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_GlobPattern[] = {
  {(char *)"pattern", &Dtool_GlobPattern_pattern_Getter, &Dtool_GlobPattern_pattern_Setter, nullptr, nullptr},
  {(char *)"case_sensitive", &Dtool_GlobPattern_case_sensitive_Getter, &Dtool_GlobPattern_case_sensitive_Setter, nullptr, nullptr},
  {(char *)"nomatch_chars", &Dtool_GlobPattern_nomatch_chars_Getter, &Dtool_GlobPattern_nomatch_chars_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GlobPattern = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_GlobPattern = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GlobPattern",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GlobPattern,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    &Dtool_Repr_GlobPattern,
    &Dtool_NumberMethods_GlobPattern,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Repr_GlobPattern,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can be used to test for string matches against standard Unix-\n"
    " * shell filename globbing conventions.  It serves as a portable standin for\n"
    " * the Posix fnmatch() call.\n"
    " *\n"
    " * A GlobPattern is given a pattern string, which can contain operators like\n"
    " * *, ?, and [].  Then it can be tested against any number of candidate\n"
    " * strings; for each candidate, it will indicate whether the string matches\n"
    " * the pattern or not.  It can be used, for example, to scan a directory for\n"
    " * all files matching a particular pattern.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_GlobPattern,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GlobPattern,
    nullptr, // tp_members
    Dtool_Properties_GlobPattern,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GlobPattern,
    PyType_GenericAlloc,
    Dtool_new_GlobPattern,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GlobPattern,
  Dtool_UpcastInterface_GlobPattern,
  Dtool_DowncastInterface_GlobPattern,
  nullptr,
  (CoerceFunction)Dtool_Coerce_GlobPattern,
};

static void Dtool_PyModuleClassInit_GlobPattern(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_GlobPattern._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GlobPattern._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GlobPattern) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GlobPattern)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GlobPattern);
  }
}

/**
 * Python method tables for LineStream (LineStream)
 */
static PyMethodDef Dtool_Methods_LineStream[] = {
  {"is_text_available", &Dtool_LineStream_is_text_available_342, METH_NOARGS, (const char *)Dtool_LineStream_is_text_available_342_comment},
  {"isTextAvailable", &Dtool_LineStream_is_text_available_342, METH_NOARGS, (const char *)Dtool_LineStream_is_text_available_342_comment},
  {"get_line", &Dtool_LineStream_get_line_343, METH_NOARGS, (const char *)Dtool_LineStream_get_line_343_comment},
  {"getLine", &Dtool_LineStream_get_line_343, METH_NOARGS, (const char *)Dtool_LineStream_get_line_343_comment},
  {"has_newline", &Dtool_LineStream_has_newline_344, METH_NOARGS, (const char *)Dtool_LineStream_has_newline_344_comment},
  {"hasNewline", &Dtool_LineStream_has_newline_344, METH_NOARGS, (const char *)Dtool_LineStream_has_newline_344_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LineStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LineStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LineStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LineStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LineStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LineStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LineStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LineStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LineStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LineStream,
    &Dtool_SequenceMethods_LineStream,
    &Dtool_MappingMethods_LineStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LineStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special ostream that writes to a memory buffer, like ostrstream.\n"
    " * However, its contents can be continuously extracted as a sequence of lines\n"
    " * of text.\n"
    " *\n"
    " * Unlike ostrstream, which can only be extracted from once (and then the\n"
    " * buffer freezes and it can no longer be written to), the LineStream is not\n"
    " * otherwise affected when a line of text is extracted.  More text can still\n"
    " * be written to it and continuously extracted.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LineStream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LineStream,
    PyType_GenericAlloc,
    Dtool_new_LineStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LineStream,
  Dtool_UpcastInterface_LineStream,
  Dtool_DowncastInterface_LineStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LineStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_std_ostream(nullptr);
    Dtool_LineStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_std_ostream);
    Dtool_LineStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LineStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LineStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LineStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LineStream);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3dtoolutil_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    Filename::init_type();
    TypeHandle handle = Filename::get_class_type();
    Dtool_Filename._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Filename);
  }
  {
    PandaSystem::init_type();
    TypeHandle handle = PandaSystem::get_class_type();
    Dtool_PandaSystem._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PandaSystem);
  }
}

void Dtool_libp3dtoolutil_BuildInstants(PyObject *module) {
  (void) module;
  // basic_ios< char >
  Dtool_PyModuleClassInit_std_basic_ios_char(module);
  PyModule_AddObject(module, "basic_ios_char", (PyObject *)&Dtool_std_basic_ios_char);
  Py_INCREF(Dtool_Ptr_std_basic_ios_char);
  PyModule_AddObject(module, "BasicIosChar", (PyObject *)&Dtool_std_basic_ios_char);
  // ios_base
  Dtool_PyModuleClassInit_std_ios_base(module);
  PyModule_AddObject(module, "ios_base", (PyObject *)&Dtool_std_ios_base);
  Py_INCREF(Dtool_Ptr_std_ios_base);
  PyModule_AddObject(module, "IosBase", (PyObject *)&Dtool_std_ios_base);
  // fstream
  Dtool_PyModuleClassInit_std_fstream(module);
  PyModule_AddObject(module, "fstream", (PyObject *)&Dtool_std_fstream);
  Py_INCREF(Dtool_Ptr_std_fstream);
  PyModule_AddObject(module, "Fstream", (PyObject *)&Dtool_std_fstream);
  // iostream
  Dtool_PyModuleClassInit_std_iostream(module);
  PyModule_AddObject(module, "iostream", (PyObject *)&Dtool_std_iostream);
  Py_INCREF(Dtool_Ptr_std_iostream);
  PyModule_AddObject(module, "Iostream", (PyObject *)&Dtool_std_iostream);
  // istream
  Dtool_PyModuleClassInit_std_istream(module);
  PyModule_AddObject(module, "istream", (PyObject *)&Dtool_std_istream);
  Py_INCREF(Dtool_Ptr_std_istream);
  PyModule_AddObject(module, "Istream", (PyObject *)&Dtool_std_istream);
  // ostream
  Dtool_PyModuleClassInit_std_ostream(module);
  PyModule_AddObject(module, "ostream", (PyObject *)&Dtool_std_ostream);
  Py_INCREF(Dtool_Ptr_std_ostream);
  PyModule_AddObject(module, "Ostream", (PyObject *)&Dtool_std_ostream);
  // ifstream
  Dtool_PyModuleClassInit_std_ifstream(module);
  PyModule_AddObject(module, "ifstream", (PyObject *)&Dtool_std_ifstream);
  Py_INCREF(Dtool_Ptr_std_ifstream);
  PyModule_AddObject(module, "Ifstream", (PyObject *)&Dtool_std_ifstream);
  // typedef std::basic_ios< char > ios
  Dtool_PyModuleClassInit_std_basic_ios_char(module);
  Py_INCREF((PyObject *)&Dtool_std_basic_ios_char);
  PyModule_AddObject(module, "ios", (PyObject *)&Dtool_std_basic_ios_char);
  Py_INCREF(Dtool_Ptr_std_basic_ios_char);
  PyModule_AddObject(module, "Ios", (PyObject *)&Dtool_std_basic_ios_char);
  // ofstream
  Dtool_PyModuleClassInit_std_ofstream(module);
  PyModule_AddObject(module, "ofstream", (PyObject *)&Dtool_std_ofstream);
  Py_INCREF(Dtool_Ptr_std_ofstream);
  PyModule_AddObject(module, "Ofstream", (PyObject *)&Dtool_std_ofstream);
  // IFileStream
  Dtool_PyModuleClassInit_IFileStream(module);
  PyModule_AddObject(module, "IFileStream", (PyObject *)&Dtool_IFileStream);
  // OFileStream
  Dtool_PyModuleClassInit_OFileStream(module);
  PyModule_AddObject(module, "OFileStream", (PyObject *)&Dtool_OFileStream);
  // FileStream
  Dtool_PyModuleClassInit_FileStream(module);
  PyModule_AddObject(module, "FileStream", (PyObject *)&Dtool_FileStream);
  // typedef IFileStream pifstream
  Dtool_PyModuleClassInit_IFileStream(module);
  Py_INCREF((PyObject *)&Dtool_IFileStream);
  PyModule_AddObject(module, "pifstream", (PyObject *)&Dtool_IFileStream);
  Py_INCREF(Dtool_Ptr_IFileStream);
  PyModule_AddObject(module, "Pifstream", (PyObject *)&Dtool_IFileStream);
  // typedef OFileStream pofstream
  Dtool_PyModuleClassInit_OFileStream(module);
  Py_INCREF((PyObject *)&Dtool_OFileStream);
  PyModule_AddObject(module, "pofstream", (PyObject *)&Dtool_OFileStream);
  Py_INCREF(Dtool_Ptr_OFileStream);
  PyModule_AddObject(module, "Pofstream", (PyObject *)&Dtool_OFileStream);
  // typedef FileStream pfstream
  Dtool_PyModuleClassInit_FileStream(module);
  Py_INCREF((PyObject *)&Dtool_FileStream);
  PyModule_AddObject(module, "pfstream", (PyObject *)&Dtool_FileStream);
  Py_INCREF(Dtool_Ptr_FileStream);
  PyModule_AddObject(module, "Pfstream", (PyObject *)&Dtool_FileStream);
  // TextEncoder
  Dtool_PyModuleClassInit_TextEncoder(module);
  PyModule_AddObject(module, "TextEncoder", (PyObject *)&Dtool_TextEncoder);
  // Filename
  Dtool_PyModuleClassInit_Filename(module);
  PyModule_AddObject(module, "Filename", (PyObject *)&Dtool_Filename);
  // PandaSystem
  Dtool_PyModuleClassInit_PandaSystem(module);
  PyModule_AddObject(module, "PandaSystem", (PyObject *)&Dtool_PandaSystem);
  // DSearchPath
  Dtool_PyModuleClassInit_DSearchPath(module);
  PyModule_AddObject(module, "DSearchPath", (PyObject *)&Dtool_DSearchPath);
  // ExecutionEnvironment
  Dtool_PyModuleClassInit_ExecutionEnvironment(module);
  PyModule_AddObject(module, "ExecutionEnvironment", (PyObject *)&Dtool_ExecutionEnvironment);
  // GlobPattern
  Dtool_PyModuleClassInit_GlobPattern(module);
  PyModule_AddObject(module, "GlobPattern", (PyObject *)&Dtool_GlobPattern);
  // LineStream
  Dtool_PyModuleClassInit_LineStream(module);
  PyModule_AddObject(module, "LineStream", (PyObject *)&Dtool_LineStream);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3dtoolutil_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3dtoolutil_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583612448,  /* file_identifier */
  "libp3dtoolutil",  /* library_name */
  "3LYc",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3dtoolutil.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  704  /* next_index */
};

Configure(_in_configure_libp3dtoolutil);
ConfigureFn(_in_configure_libp3dtoolutil) {
  interrogate_request_module(&_in_module_def);
}

