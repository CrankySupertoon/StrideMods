/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/gobj -Ipanda/src/gobj -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3gobj_igate.cxx -od built/pandac/input/libp3gobj.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/gobj -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3gobj adaptiveLru.h animateVerticesRequest.h bufferContext.h bufferContextChain.h bufferResidencyTracker.h config_gobj.h geom.h geomCacheEntry.h geomCacheManager.h geomContext.h geomEnums.h geomLines.h geomLinesAdjacency.h geomLinestrips.h geomLinestripsAdjacency.h geomMunger.h geomPatches.h geomPoints.h geomPrimitive.h geomTriangles.h geomTrianglesAdjacency.h geomTrifans.h geomTristrips.h geomTristripsAdjacency.h geomVertexAnimationSpec.h geomVertexArrayData.h geomVertexArrayData_ext.h geomVertexArrayFormat.h geomVertexColumn.h geomVertexData.h geomVertexFormat.h geomVertexReader.h geomVertexRewriter.h geomVertexWriter.h indexBufferContext.h internalName.h internalName_ext.h lens.h material.h materialPool.h matrixLens.h occlusionQueryContext.h orthographicLens.h p3gobj_composite1.cxx p3gobj_composite2.cxx p3gobj_ext_composite.cxx paramTexture.h perspectiveLens.h preparedGraphicsObjects.h queryContext.h samplerContext.h samplerState.h savedContext.h shader.h shaderBuffer.h shaderContext.h simpleAllocator.h simpleLru.h sliderTable.h texture.h textureCollection.h textureCollection_ext.h textureContext.h texturePeeker.h texturePool.h texturePoolFilter.h textureReloadRequest.h textureStage.h textureStagePool.h texture_ext.h timerQueryContext.h transformBlend.h transformBlendTable.h transformTable.h userVertexSlider.h userVertexTransform.h vertexBufferContext.h vertexDataBlock.h vertexDataBook.h vertexDataBuffer.h vertexDataPage.h vertexDataSaveFile.h vertexSlider.h vertexTransform.h videoTexture.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "adaptiveLru.h"
#include "animateVerticesRequest.h"
#include "asyncTask.h"
#include "boundingVolume.h"
#include "bufferContext.h"
#include "bufferContextChain.h"
#include "bufferResidencyTracker.h"
#include "config_gobj.h"
#include "copyOnWriteObject.h"
#include "copyOnWritePointer.h"
#include "cycleData.h"
#include "cycleDataLockedReader.h"
#include "cycleDataReader.h"
#include "cycleDataStageReader.h"
#include "cycleDataStageWriter.h"
#include "cycleDataWriter.h"
#include "deletedChain.h"
#include "dtoolbase.h"
#include "extension.h"
#include "geom.h"
#include "geomCacheEntry.h"
#include "geomCacheManager.h"
#include "geomContext.h"
#include "geomEnums.h"
#include "geomLines.h"
#include "geomLinesAdjacency.h"
#include "geomLinestrips.h"
#include "geomLinestripsAdjacency.h"
#include "geomMunger.h"
#include "geomPatches.h"
#include "geomPoints.h"
#include "geomPrimitive.h"
#include "geomTriangles.h"
#include "geomTrianglesAdjacency.h"
#include "geomTrifans.h"
#include "geomTristrips.h"
#include "geomTristripsAdjacency.h"
#include "geomVertexAnimationSpec.h"
#include "geomVertexArrayData.h"
#include "geomVertexArrayData_ext.h"
#include "geomVertexArrayFormat.h"
#include "geomVertexColumn.h"
#include "geomVertexData.h"
#include "geomVertexFormat.h"
#include "geomVertexReader.h"
#include "geomVertexRewriter.h"
#include "geomVertexWriter.h"
#include "graphicsStateGuardianBase.h"
#include "indexBufferContext.h"
#include "indirectLess.h"
#include "internalName.h"
#include "internalName_ext.h"
#include "lens.h"
#include "lightMutex.h"
#include "lightMutexHolder.h"
#include "linkedListNode.h"
#include "luse.h"
#include "material.h"
#include "materialPool.h"
#include "matrixLens.h"
#include "namable.h"
#include "numeric_types.h"
#include "occlusionQueryContext.h"
#include "orthographicLens.h"
#include "pStatCollector.h"
#include "pandabase.h"
#include "paramTexture.h"
#include "perspectiveLens.h"
#include "pipelineCycler.h"
#include "pmap.h"
#include "pointerTo.h"
#include "preparedGraphicsObjects.h"
#include "pset.h"
#include "py_panda.h"
#include "queryContext.h"
#include "samplerContext.h"
#include "samplerState.h"
#include "savedContext.h"
#include "shader.h"
#include "shaderBuffer.h"
#include "shaderContext.h"
#include "simpleAllocator.h"
#include "simpleLru.h"
#include "sliderTable.h"
#include "texture.h"
#include "textureCollection.h"
#include "textureCollection_ext.h"
#include "textureContext.h"
#include "texturePeeker.h"
#include "texturePool.h"
#include "texturePoolFilter.h"
#include "textureReloadRequest.h"
#include "textureStage.h"
#include "textureStagePool.h"
#include "texture_ext.h"
#include "timerQueryContext.h"
#include "transformBlend.h"
#include "transformBlendTable.h"
#include "transformTable.h"
#include "typedWritableReferenceCount.h"
#include "updateSeq.h"
#include "userVertexSlider.h"
#include "userVertexTransform.h"
#include "vertexBufferContext.h"
#include "vertexDataBlock.h"
#include "vertexDataBook.h"
#include "vertexDataBuffer.h"
#include "vertexDataPage.h"
#include "vertexDataSaveFile.h"
#include "vertexSlider.h"
#include "vertexTransform.h"
#include "videoTexture.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class AdaptiveLru
 */
typedef AdaptiveLru AdaptiveLru_localtype;
Define_Module_Class(panda3d.core, AdaptiveLru, AdaptiveLru_localtype, AdaptiveLru);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AdaptiveLru = &Dtool_AdaptiveLru;
static void Dtool_PyModuleClassInit_AdaptiveLru(PyObject *module);

/**
 * Forward declarations for top-level class AdaptiveLruPage
 */
typedef AdaptiveLruPage AdaptiveLruPage_localtype;
Define_Module_Class(panda3d.core, AdaptiveLruPage, AdaptiveLruPage_localtype, AdaptiveLruPage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AdaptiveLruPage = &Dtool_AdaptiveLruPage;
static void Dtool_PyModuleClassInit_AdaptiveLruPage(PyObject *module);

/**
 * Forward declarations for top-level class GeomEnums
 */
typedef GeomEnums GeomEnums_localtype;
Define_Module_Class(panda3d.core, GeomEnums, GeomEnums_localtype, GeomEnums);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomEnums = &Dtool_GeomEnums;
static void Dtool_PyModuleClassInit_GeomEnums(PyObject *module);

/**
 * Forward declarations for top-level class GeomVertexAnimationSpec
 */
typedef GeomVertexAnimationSpec GeomVertexAnimationSpec_localtype;
Define_Module_Class(panda3d.core, GeomVertexAnimationSpec, GeomVertexAnimationSpec_localtype, GeomVertexAnimationSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexAnimationSpec = &Dtool_GeomVertexAnimationSpec;
static void Dtool_PyModuleClassInit_GeomVertexAnimationSpec(PyObject *module);

/**
 * Forward declarations for top-level class InternalName
 */
typedef InternalName InternalName_localtype;
Define_Module_ClassRef(panda3d.core, InternalName, InternalName_localtype, InternalName);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InternalName = &Dtool_InternalName;
static void Dtool_PyModuleClassInit_InternalName(PyObject *module);
bool Dtool_ConstCoerce_InternalName(PyObject *args, CPT(InternalName) &coerced);
bool Dtool_Coerce_InternalName(PyObject *args, PT(InternalName) &coerced);

/**
 * Forward declarations for top-level class GeomVertexColumn
 */
typedef GeomVertexColumn GeomVertexColumn_localtype;
Define_Module_Class(panda3d.core, GeomVertexColumn, GeomVertexColumn_localtype, GeomVertexColumn);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexColumn = &Dtool_GeomVertexColumn;
static void Dtool_PyModuleClassInit_GeomVertexColumn(PyObject *module);

/**
 * Forward declarations for top-level class GeomVertexArrayFormat
 */
typedef GeomVertexArrayFormat GeomVertexArrayFormat_localtype;
Define_Module_ClassRef(panda3d.core, GeomVertexArrayFormat, GeomVertexArrayFormat_localtype, GeomVertexArrayFormat);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexArrayFormat = &Dtool_GeomVertexArrayFormat;
static void Dtool_PyModuleClassInit_GeomVertexArrayFormat(PyObject *module);
bool Dtool_ConstCoerce_GeomVertexArrayFormat(PyObject *args, CPT(GeomVertexArrayFormat) &coerced);
bool Dtool_Coerce_GeomVertexArrayFormat(PyObject *args, PT(GeomVertexArrayFormat) &coerced);

/**
 * Forward declarations for top-level class GeomVertexFormat
 */
typedef GeomVertexFormat GeomVertexFormat_localtype;
Define_Module_ClassRef(panda3d.core, GeomVertexFormat, GeomVertexFormat_localtype, GeomVertexFormat);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexFormat = &Dtool_GeomVertexFormat;
static void Dtool_PyModuleClassInit_GeomVertexFormat(PyObject *module);
bool Dtool_ConstCoerce_GeomVertexFormat(PyObject *args, CPT(GeomVertexFormat) &coerced);
bool Dtool_Coerce_GeomVertexFormat(PyObject *args, PT(GeomVertexFormat) &coerced);

/**
 * Forward declarations for top-level class SimpleLru
 */
typedef SimpleLru SimpleLru_localtype;
Define_Module_Class(panda3d.core, SimpleLru, SimpleLru_localtype, SimpleLru);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SimpleLru = &Dtool_SimpleLru;
static void Dtool_PyModuleClassInit_SimpleLru(PyObject *module);

/**
 * Forward declarations for top-level class SimpleLruPage
 */
typedef SimpleLruPage SimpleLruPage_localtype;
Define_Module_Class(panda3d.core, SimpleLruPage, SimpleLruPage_localtype, SimpleLruPage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SimpleLruPage = &Dtool_SimpleLruPage;
static void Dtool_PyModuleClassInit_SimpleLruPage(PyObject *module);

/**
 * Forward declarations for top-level class SimpleAllocator
 */
typedef SimpleAllocator SimpleAllocator_localtype;
Define_Module_Class(panda3d.core, SimpleAllocator, SimpleAllocator_localtype, SimpleAllocator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SimpleAllocator = &Dtool_SimpleAllocator;
static void Dtool_PyModuleClassInit_SimpleAllocator(PyObject *module);

/**
 * Forward declarations for top-level class SimpleAllocatorBlock
 */
typedef SimpleAllocatorBlock SimpleAllocatorBlock_localtype;
Define_Module_Class(panda3d.core, SimpleAllocatorBlock, SimpleAllocatorBlock_localtype, SimpleAllocatorBlock);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SimpleAllocatorBlock = &Dtool_SimpleAllocatorBlock;
static void Dtool_PyModuleClassInit_SimpleAllocatorBlock(PyObject *module);

/**
 * Forward declarations for top-level class VertexDataSaveFile
 */
typedef VertexDataSaveFile VertexDataSaveFile_localtype;
Define_Module_Class(panda3d.core, VertexDataSaveFile, VertexDataSaveFile_localtype, VertexDataSaveFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexDataSaveFile = &Dtool_VertexDataSaveFile;
static void Dtool_PyModuleClassInit_VertexDataSaveFile(PyObject *module);

/**
 * Forward declarations for top-level class VertexDataPage
 */
typedef VertexDataPage VertexDataPage_localtype;
Define_Module_Class_Private(panda3d.core, VertexDataPage, VertexDataPage_localtype, VertexDataPage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexDataPage = &Dtool_VertexDataPage;
static void Dtool_PyModuleClassInit_VertexDataPage(PyObject *module);

/**
 * Forward declarations for top-level class VertexDataBook
 */
typedef VertexDataBook VertexDataBook_localtype;
Define_Module_Class(panda3d.core, VertexDataBook, VertexDataBook_localtype, VertexDataBook);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexDataBook = &Dtool_VertexDataBook;
static void Dtool_PyModuleClassInit_VertexDataBook(PyObject *module);

/**
 * Forward declarations for top-level class VertexDataBlock
 */
typedef VertexDataBlock VertexDataBlock_localtype;
Define_Module_ClassRef(panda3d.core, VertexDataBlock, VertexDataBlock_localtype, VertexDataBlock);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexDataBlock = &Dtool_VertexDataBlock;
static void Dtool_PyModuleClassInit_VertexDataBlock(PyObject *module);

/**
 * Forward declarations for top-level class GeomVertexArrayData
 */
typedef GeomVertexArrayData GeomVertexArrayData_localtype;
Define_Module_ClassRef(panda3d.core, GeomVertexArrayData, GeomVertexArrayData_localtype, GeomVertexArrayData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexArrayData = &Dtool_GeomVertexArrayData;
static void Dtool_PyModuleClassInit_GeomVertexArrayData(PyObject *module);

/**
 * Forward declarations for top-level class GeomVertexArrayDataHandle
 */
typedef GeomVertexArrayDataHandle GeomVertexArrayDataHandle_localtype;
Define_Module_ClassRef(panda3d.core, GeomVertexArrayDataHandle, GeomVertexArrayDataHandle_localtype, GeomVertexArrayDataHandle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexArrayDataHandle = &Dtool_GeomVertexArrayDataHandle;
static void Dtool_PyModuleClassInit_GeomVertexArrayDataHandle(PyObject *module);

/**
 * Forward declarations for top-level class GeomCacheManager
 */
typedef GeomCacheManager GeomCacheManager_localtype;
Define_Module_Class_Private(panda3d.core, GeomCacheManager, GeomCacheManager_localtype, GeomCacheManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomCacheManager = &Dtool_GeomCacheManager;
static void Dtool_PyModuleClassInit_GeomCacheManager(PyObject *module);

/**
 * Forward declarations for top-level class VertexTransform
 */
typedef VertexTransform VertexTransform_localtype;
Define_Module_ClassRef(panda3d.core, VertexTransform, VertexTransform_localtype, VertexTransform);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexTransform = &Dtool_VertexTransform;
static void Dtool_PyModuleClassInit_VertexTransform(PyObject *module);

/**
 * Forward declarations for top-level class TransformTable
 */
typedef TransformTable TransformTable_localtype;
Define_Module_ClassRef(panda3d.core, TransformTable, TransformTable_localtype, TransformTable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformTable = &Dtool_TransformTable;
static void Dtool_PyModuleClassInit_TransformTable(PyObject *module);

/**
 * Forward declarations for top-level class TransformBlend
 */
typedef TransformBlend TransformBlend_localtype;
Define_Module_Class(panda3d.core, TransformBlend, TransformBlend_localtype, TransformBlend);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformBlend = &Dtool_TransformBlend;
static void Dtool_PyModuleClassInit_TransformBlend(PyObject *module);
TransformBlend *Dtool_Coerce_TransformBlend(PyObject *args, TransformBlend &coerced);

/**
 * Forward declarations for top-level class TransformBlendTable
 */
typedef TransformBlendTable TransformBlendTable_localtype;
Define_Module_ClassRef(panda3d.core, TransformBlendTable, TransformBlendTable_localtype, TransformBlendTable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformBlendTable = &Dtool_TransformBlendTable;
static void Dtool_PyModuleClassInit_TransformBlendTable(PyObject *module);

/**
 * Forward declarations for top-level class VertexSlider
 */
typedef VertexSlider VertexSlider_localtype;
Define_Module_ClassRef(panda3d.core, VertexSlider, VertexSlider_localtype, VertexSlider);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexSlider = &Dtool_VertexSlider;
static void Dtool_PyModuleClassInit_VertexSlider(PyObject *module);

/**
 * Forward declarations for top-level class SliderTable
 */
typedef SliderTable SliderTable_localtype;
Define_Module_ClassRef(panda3d.core, SliderTable, SliderTable_localtype, SliderTable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SliderTable = &Dtool_SliderTable;
static void Dtool_PyModuleClassInit_SliderTable(PyObject *module);

/**
 * Forward declarations for top-level class GeomVertexData
 */
typedef GeomVertexData GeomVertexData_localtype;
Define_Module_ClassRef(panda3d.core, GeomVertexData, GeomVertexData_localtype, GeomVertexData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexData = &Dtool_GeomVertexData;
static void Dtool_PyModuleClassInit_GeomVertexData(PyObject *module);

/**
 * Forward declarations for top-level class AnimateVerticesRequest
 */
typedef AnimateVerticesRequest AnimateVerticesRequest_localtype;
Define_Module_ClassRef(panda3d.core, AnimateVerticesRequest, AnimateVerticesRequest_localtype, AnimateVerticesRequest);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimateVerticesRequest = &Dtool_AnimateVerticesRequest;
static void Dtool_PyModuleClassInit_AnimateVerticesRequest(PyObject *module);

/**
 * Forward declarations for top-level class SavedContext
 */
typedef SavedContext SavedContext_localtype;
Define_Module_Class(panda3d.core, SavedContext, SavedContext_localtype, SavedContext);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SavedContext = &Dtool_SavedContext;
static void Dtool_PyModuleClassInit_SavedContext(PyObject *module);

/**
 * Forward declarations for top-level class BufferContext
 */
typedef BufferContext BufferContext_localtype;
Define_Module_Class(panda3d.core, BufferContext, BufferContext_localtype, BufferContext);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BufferContext = &Dtool_BufferContext;
static void Dtool_PyModuleClassInit_BufferContext(PyObject *module);

/**
 * Forward declarations for top-level class GeomPrimitive
 */
typedef GeomPrimitive GeomPrimitive_localtype;
Define_Module_ClassRef(panda3d.core, GeomPrimitive, GeomPrimitive_localtype, GeomPrimitive);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomPrimitive = &Dtool_GeomPrimitive;
static void Dtool_PyModuleClassInit_GeomPrimitive(PyObject *module);

/**
 * Forward declarations for top-level class TextureStage
 */
typedef TextureStage TextureStage_localtype;
Define_Module_ClassRef(panda3d.core, TextureStage, TextureStage_localtype, TextureStage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStage = &Dtool_TextureStage;
static void Dtool_PyModuleClassInit_TextureStage(PyObject *module);

/**
 * Forward declarations for top-level class Geom
 */
typedef Geom Geom_localtype;
Define_Module_ClassRef(panda3d.core, Geom, Geom_localtype, Geom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Geom = &Dtool_Geom;
static void Dtool_PyModuleClassInit_Geom(PyObject *module);

/**
 * Forward declarations for top-level class GeomContext
 */
typedef GeomContext GeomContext_localtype;
Define_Module_Class(panda3d.core, GeomContext, GeomContext_localtype, GeomContext);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomContext = &Dtool_GeomContext;
static void Dtool_PyModuleClassInit_GeomContext(PyObject *module);

/**
 * Forward declarations for top-level class GeomLines
 */
typedef GeomLines GeomLines_localtype;
Define_Module_ClassRef(panda3d.core, GeomLines, GeomLines_localtype, GeomLines);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomLines = &Dtool_GeomLines;
static void Dtool_PyModuleClassInit_GeomLines(PyObject *module);

/**
 * Forward declarations for top-level class GeomLinesAdjacency
 */
typedef GeomLinesAdjacency GeomLinesAdjacency_localtype;
Define_Module_ClassRef(panda3d.core, GeomLinesAdjacency, GeomLinesAdjacency_localtype, GeomLinesAdjacency);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomLinesAdjacency = &Dtool_GeomLinesAdjacency;
static void Dtool_PyModuleClassInit_GeomLinesAdjacency(PyObject *module);

/**
 * Forward declarations for top-level class GeomLinestrips
 */
typedef GeomLinestrips GeomLinestrips_localtype;
Define_Module_ClassRef(panda3d.core, GeomLinestrips, GeomLinestrips_localtype, GeomLinestrips);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomLinestrips = &Dtool_GeomLinestrips;
static void Dtool_PyModuleClassInit_GeomLinestrips(PyObject *module);

/**
 * Forward declarations for top-level class GeomLinestripsAdjacency
 */
typedef GeomLinestripsAdjacency GeomLinestripsAdjacency_localtype;
Define_Module_ClassRef(panda3d.core, GeomLinestripsAdjacency, GeomLinestripsAdjacency_localtype, GeomLinestripsAdjacency);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomLinestripsAdjacency = &Dtool_GeomLinestripsAdjacency;
static void Dtool_PyModuleClassInit_GeomLinestripsAdjacency(PyObject *module);

/**
 * Forward declarations for top-level class GeomPatches
 */
typedef GeomPatches GeomPatches_localtype;
Define_Module_ClassRef(panda3d.core, GeomPatches, GeomPatches_localtype, GeomPatches);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomPatches = &Dtool_GeomPatches;
static void Dtool_PyModuleClassInit_GeomPatches(PyObject *module);

/**
 * Forward declarations for top-level class GeomPoints
 */
typedef GeomPoints GeomPoints_localtype;
Define_Module_ClassRef(panda3d.core, GeomPoints, GeomPoints_localtype, GeomPoints);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomPoints = &Dtool_GeomPoints;
static void Dtool_PyModuleClassInit_GeomPoints(PyObject *module);

/**
 * Forward declarations for top-level class GeomTriangles
 */
typedef GeomTriangles GeomTriangles_localtype;
Define_Module_ClassRef(panda3d.core, GeomTriangles, GeomTriangles_localtype, GeomTriangles);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomTriangles = &Dtool_GeomTriangles;
static void Dtool_PyModuleClassInit_GeomTriangles(PyObject *module);

/**
 * Forward declarations for top-level class GeomTrianglesAdjacency
 */
typedef GeomTrianglesAdjacency GeomTrianglesAdjacency_localtype;
Define_Module_ClassRef(panda3d.core, GeomTrianglesAdjacency, GeomTrianglesAdjacency_localtype, GeomTrianglesAdjacency);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomTrianglesAdjacency = &Dtool_GeomTrianglesAdjacency;
static void Dtool_PyModuleClassInit_GeomTrianglesAdjacency(PyObject *module);

/**
 * Forward declarations for top-level class GeomTrifans
 */
typedef GeomTrifans GeomTrifans_localtype;
Define_Module_ClassRef(panda3d.core, GeomTrifans, GeomTrifans_localtype, GeomTrifans);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomTrifans = &Dtool_GeomTrifans;
static void Dtool_PyModuleClassInit_GeomTrifans(PyObject *module);

/**
 * Forward declarations for top-level class GeomTristrips
 */
typedef GeomTristrips GeomTristrips_localtype;
Define_Module_ClassRef(panda3d.core, GeomTristrips, GeomTristrips_localtype, GeomTristrips);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomTristrips = &Dtool_GeomTristrips;
static void Dtool_PyModuleClassInit_GeomTristrips(PyObject *module);

/**
 * Forward declarations for top-level class GeomTristripsAdjacency
 */
typedef GeomTristripsAdjacency GeomTristripsAdjacency_localtype;
Define_Module_ClassRef(panda3d.core, GeomTristripsAdjacency, GeomTristripsAdjacency_localtype, GeomTristripsAdjacency);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomTristripsAdjacency = &Dtool_GeomTristripsAdjacency;
static void Dtool_PyModuleClassInit_GeomTristripsAdjacency(PyObject *module);

/**
 * Forward declarations for top-level class GeomVertexReader
 */
typedef GeomVertexReader GeomVertexReader_localtype;
Define_Module_Class(panda3d.core, GeomVertexReader, GeomVertexReader_localtype, GeomVertexReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexReader = &Dtool_GeomVertexReader;
static void Dtool_PyModuleClassInit_GeomVertexReader(PyObject *module);
GeomVertexReader *Dtool_Coerce_GeomVertexReader(PyObject *args, GeomVertexReader &coerced);

/**
 * Forward declarations for top-level class GeomVertexWriter
 */
typedef GeomVertexWriter GeomVertexWriter_localtype;
Define_Module_Class(panda3d.core, GeomVertexWriter, GeomVertexWriter_localtype, GeomVertexWriter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexWriter = &Dtool_GeomVertexWriter;
static void Dtool_PyModuleClassInit_GeomVertexWriter(PyObject *module);
GeomVertexWriter *Dtool_Coerce_GeomVertexWriter(PyObject *args, GeomVertexWriter &coerced);

/**
 * Forward declarations for top-level class GeomVertexRewriter
 */
typedef GeomVertexRewriter GeomVertexRewriter_localtype;
Define_Module_Class(panda3d.core, GeomVertexRewriter, GeomVertexRewriter_localtype, GeomVertexRewriter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexRewriter = &Dtool_GeomVertexRewriter;
static void Dtool_PyModuleClassInit_GeomVertexRewriter(PyObject *module);
GeomVertexRewriter *Dtool_Coerce_GeomVertexRewriter(PyObject *args, GeomVertexRewriter &coerced);

/**
 * Forward declarations for top-level class SamplerState
 */
typedef SamplerState SamplerState_localtype;
Define_Module_Class(panda3d.core, SamplerState, SamplerState_localtype, SamplerState);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SamplerState = &Dtool_SamplerState;
static void Dtool_PyModuleClassInit_SamplerState(PyObject *module);

/**
 * Forward declarations for top-level class Texture
 */
typedef Texture Texture_localtype;
Define_Module_ClassRef(panda3d.core, Texture, Texture_localtype, Texture);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
static void Dtool_PyModuleClassInit_Texture(PyObject *module);

/**
 * Forward declarations for top-level class Shader
 */
typedef Shader Shader_localtype;
Define_Module_ClassRef(panda3d.core, Shader, Shader_localtype, Shader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Shader = &Dtool_Shader;
static void Dtool_PyModuleClassInit_Shader(PyObject *module);
bool Dtool_ConstCoerce_Shader(PyObject *args, CPT(Shader) &coerced);
bool Dtool_Coerce_Shader(PyObject *args, PT(Shader) &coerced);

/**
 * Forward declarations for top-level class ShaderBuffer
 */
typedef ShaderBuffer ShaderBuffer_localtype;
Define_Module_ClassRef(panda3d.core, ShaderBuffer, ShaderBuffer_localtype, ShaderBuffer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderBuffer = &Dtool_ShaderBuffer;
static void Dtool_PyModuleClassInit_ShaderBuffer(PyObject *module);

/**
 * Forward declarations for top-level class PreparedGraphicsObjects
 */
typedef PreparedGraphicsObjects PreparedGraphicsObjects_localtype;
Define_Module_ClassRef(panda3d.core, PreparedGraphicsObjects, PreparedGraphicsObjects_localtype, PreparedGraphicsObjects);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PreparedGraphicsObjects = &Dtool_PreparedGraphicsObjects;
static void Dtool_PyModuleClassInit_PreparedGraphicsObjects(PyObject *module);

/**
 * Forward declarations for top-level class IndexBufferContext
 */
typedef IndexBufferContext IndexBufferContext_localtype;
Define_Module_Class(panda3d.core, IndexBufferContext, IndexBufferContext_localtype, IndexBufferContext);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IndexBufferContext = &Dtool_IndexBufferContext;
static void Dtool_PyModuleClassInit_IndexBufferContext(PyObject *module);

/**
 * Forward declarations for top-level class Lens
 */
typedef Lens Lens_localtype;
Define_Module_ClassRef(panda3d.core, Lens, Lens_localtype, Lens);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Lens = &Dtool_Lens;
static void Dtool_PyModuleClassInit_Lens(PyObject *module);

/**
 * Forward declarations for top-level class Material
 */
typedef Material Material_localtype;
Define_Module_ClassRef(panda3d.core, Material, Material_localtype, Material);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Material = &Dtool_Material;
static void Dtool_PyModuleClassInit_Material(PyObject *module);

/**
 * Forward declarations for top-level class MaterialPool
 */
typedef MaterialPool MaterialPool_localtype;
Define_Module_Class(panda3d.core, MaterialPool, MaterialPool_localtype, MaterialPool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MaterialPool = &Dtool_MaterialPool;
static void Dtool_PyModuleClassInit_MaterialPool(PyObject *module);

/**
 * Forward declarations for top-level class MatrixLens
 */
typedef MatrixLens MatrixLens_localtype;
Define_Module_ClassRef(panda3d.core, MatrixLens, MatrixLens_localtype, MatrixLens);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MatrixLens = &Dtool_MatrixLens;
static void Dtool_PyModuleClassInit_MatrixLens(PyObject *module);

/**
 * Forward declarations for top-level class OrthographicLens
 */
typedef OrthographicLens OrthographicLens_localtype;
Define_Module_ClassRef(panda3d.core, OrthographicLens, OrthographicLens_localtype, OrthographicLens);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OrthographicLens = &Dtool_OrthographicLens;
static void Dtool_PyModuleClassInit_OrthographicLens(PyObject *module);

/**
 * Forward declarations for top-level class ParamTextureSampler
 */
typedef ParamTextureSampler ParamTextureSampler_localtype;
Define_Module_ClassRef(panda3d.core, ParamTextureSampler, ParamTextureSampler_localtype, ParamTextureSampler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamTextureSampler = &Dtool_ParamTextureSampler;
static void Dtool_PyModuleClassInit_ParamTextureSampler(PyObject *module);
bool Dtool_ConstCoerce_ParamTextureSampler(PyObject *args, CPT(ParamTextureSampler) &coerced);
bool Dtool_Coerce_ParamTextureSampler(PyObject *args, PT(ParamTextureSampler) &coerced);

/**
 * Forward declarations for top-level class ParamTextureImage
 */
typedef ParamTextureImage ParamTextureImage_localtype;
Define_Module_ClassRef(panda3d.core, ParamTextureImage, ParamTextureImage_localtype, ParamTextureImage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamTextureImage = &Dtool_ParamTextureImage;
static void Dtool_PyModuleClassInit_ParamTextureImage(PyObject *module);
bool Dtool_ConstCoerce_ParamTextureImage(PyObject *args, CPT(ParamTextureImage) &coerced);
bool Dtool_Coerce_ParamTextureImage(PyObject *args, PT(ParamTextureImage) &coerced);

/**
 * Forward declarations for top-level class PerspectiveLens
 */
typedef PerspectiveLens PerspectiveLens_localtype;
Define_Module_ClassRef(panda3d.core, PerspectiveLens, PerspectiveLens_localtype, PerspectiveLens);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PerspectiveLens = &Dtool_PerspectiveLens;
static void Dtool_PyModuleClassInit_PerspectiveLens(PyObject *module);

/**
 * Forward declarations for top-level class TextureReloadRequest
 */
typedef TextureReloadRequest TextureReloadRequest_localtype;
Define_Module_ClassRef(panda3d.core, TextureReloadRequest, TextureReloadRequest_localtype, TextureReloadRequest);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureReloadRequest = &Dtool_TextureReloadRequest;
static void Dtool_PyModuleClassInit_TextureReloadRequest(PyObject *module);

/**
 * Forward declarations for top-level class TextureContext
 */
typedef TextureContext TextureContext_localtype;
Define_Module_Class(panda3d.core, TextureContext, TextureContext_localtype, TextureContext);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureContext = &Dtool_TextureContext;
static void Dtool_PyModuleClassInit_TextureContext(PyObject *module);

/**
 * Forward declarations for top-level class ShaderContext
 */
typedef ShaderContext ShaderContext_localtype;
Define_Module_Class(panda3d.core, ShaderContext, ShaderContext_localtype, ShaderContext);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderContext = &Dtool_ShaderContext;
static void Dtool_PyModuleClassInit_ShaderContext(PyObject *module);

/**
 * Forward declarations for top-level class UserVertexSlider
 */
typedef UserVertexSlider UserVertexSlider_localtype;
Define_Module_ClassRef(panda3d.core, UserVertexSlider, UserVertexSlider_localtype, UserVertexSlider);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UserVertexSlider = &Dtool_UserVertexSlider;
static void Dtool_PyModuleClassInit_UserVertexSlider(PyObject *module);

/**
 * Forward declarations for top-level class UserVertexTransform
 */
typedef UserVertexTransform UserVertexTransform_localtype;
Define_Module_ClassRef(panda3d.core, UserVertexTransform, UserVertexTransform_localtype, UserVertexTransform);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UserVertexTransform = &Dtool_UserVertexTransform;
static void Dtool_PyModuleClassInit_UserVertexTransform(PyObject *module);

/**
 * Forward declarations for top-level class VideoTexture
 */
typedef VideoTexture VideoTexture_localtype;
Define_Module_ClassRef(panda3d.core, VideoTexture, VideoTexture_localtype, VideoTexture);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VideoTexture = &Dtool_VideoTexture;
static void Dtool_PyModuleClassInit_VideoTexture(PyObject *module);

/**
 * Forward declarations for top-level class VertexBufferContext
 */
typedef VertexBufferContext VertexBufferContext_localtype;
Define_Module_Class(panda3d.core, VertexBufferContext, VertexBufferContext_localtype, VertexBufferContext);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexBufferContext = &Dtool_VertexBufferContext;
static void Dtool_PyModuleClassInit_VertexBufferContext(PyObject *module);

/**
 * Forward declarations for top-level class TextureCollection
 */
typedef TextureCollection TextureCollection_localtype;
Define_Module_Class(panda3d.core, TextureCollection, TextureCollection_localtype, TextureCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureCollection = &Dtool_TextureCollection;
static void Dtool_PyModuleClassInit_TextureCollection(PyObject *module);
TextureCollection *Dtool_Coerce_TextureCollection(PyObject *args, TextureCollection &coerced);

/**
 * Forward declarations for top-level class TexturePool
 */
typedef TexturePool TexturePool_localtype;
Define_Module_Class(panda3d.core, TexturePool, TexturePool_localtype, TexturePool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TexturePool = &Dtool_TexturePool;
static void Dtool_PyModuleClassInit_TexturePool(PyObject *module);

/**
 * Forward declarations for top-level class TexturePeeker
 */
typedef TexturePeeker TexturePeeker_localtype;
Define_Module_ClassRef(panda3d.core, TexturePeeker, TexturePeeker_localtype, TexturePeeker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TexturePeeker = &Dtool_TexturePeeker;
static void Dtool_PyModuleClassInit_TexturePeeker(PyObject *module);

/**
 * Forward declarations for top-level class TextureStagePool
 */
typedef TextureStagePool TextureStagePool_localtype;
Define_Module_Class(panda3d.core, TextureStagePool, TextureStagePool_localtype, TextureStagePool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStagePool = &Dtool_TextureStagePool;
static void Dtool_PyModuleClassInit_TextureStagePool(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"AdaptiveLru", &Dtool_AdaptiveLru},
  {"AdaptiveLruPage", &Dtool_AdaptiveLruPage},
  {"GeomEnums", &Dtool_GeomEnums},
  {"GeomVertexAnimationSpec", &Dtool_GeomVertexAnimationSpec},
  {"InternalName", &Dtool_InternalName},
  {"GeomVertexColumn", &Dtool_GeomVertexColumn},
  {"GeomVertexArrayFormat", &Dtool_GeomVertexArrayFormat},
  {"GeomVertexFormat", &Dtool_GeomVertexFormat},
  {"SimpleLru", &Dtool_SimpleLru},
  {"SimpleLruPage", &Dtool_SimpleLruPage},
  {"SimpleAllocator", &Dtool_SimpleAllocator},
  {"SimpleAllocatorBlock", &Dtool_SimpleAllocatorBlock},
  {"VertexDataSaveFile", &Dtool_VertexDataSaveFile},
  {"VertexDataPage", &Dtool_VertexDataPage},
  {"VertexDataBook", &Dtool_VertexDataBook},
  {"VertexDataBlock", &Dtool_VertexDataBlock},
  {"GeomVertexArrayData", &Dtool_GeomVertexArrayData},
  {"GeomVertexArrayDataHandle", &Dtool_GeomVertexArrayDataHandle},
  {"GeomCacheManager", &Dtool_GeomCacheManager},
  {"VertexTransform", &Dtool_VertexTransform},
  {"TransformTable", &Dtool_TransformTable},
  {"TransformBlend", &Dtool_TransformBlend},
  {"TransformBlendTable", &Dtool_TransformBlendTable},
  {"VertexSlider", &Dtool_VertexSlider},
  {"SliderTable", &Dtool_SliderTable},
  {"GeomVertexData", &Dtool_GeomVertexData},
  {"AnimateVerticesRequest", &Dtool_AnimateVerticesRequest},
  {"SavedContext", &Dtool_SavedContext},
  {"BufferContext", &Dtool_BufferContext},
  {"GeomPrimitive", &Dtool_GeomPrimitive},
  {"TextureStage", &Dtool_TextureStage},
  {"Geom", &Dtool_Geom},
  {"GeomContext", &Dtool_GeomContext},
  {"GeomLines", &Dtool_GeomLines},
  {"GeomLinesAdjacency", &Dtool_GeomLinesAdjacency},
  {"GeomLinestrips", &Dtool_GeomLinestrips},
  {"GeomLinestripsAdjacency", &Dtool_GeomLinestripsAdjacency},
  {"GeomPatches", &Dtool_GeomPatches},
  {"GeomPoints", &Dtool_GeomPoints},
  {"GeomTriangles", &Dtool_GeomTriangles},
  {"GeomTrianglesAdjacency", &Dtool_GeomTrianglesAdjacency},
  {"GeomTrifans", &Dtool_GeomTrifans},
  {"GeomTristrips", &Dtool_GeomTristrips},
  {"GeomTristripsAdjacency", &Dtool_GeomTristripsAdjacency},
  {"GeomVertexReader", &Dtool_GeomVertexReader},
  {"GeomVertexWriter", &Dtool_GeomVertexWriter},
  {"GeomVertexRewriter", &Dtool_GeomVertexRewriter},
  {"SamplerState", &Dtool_SamplerState},
  {"Texture", &Dtool_Texture},
  {"Shader", &Dtool_Shader},
  {"ShaderBuffer", &Dtool_ShaderBuffer},
  {"PreparedGraphicsObjects", &Dtool_PreparedGraphicsObjects},
  {"IndexBufferContext", &Dtool_IndexBufferContext},
  {"Lens", &Dtool_Lens},
  {"Material", &Dtool_Material},
  {"MaterialPool", &Dtool_MaterialPool},
  {"MatrixLens", &Dtool_MatrixLens},
  {"OrthographicLens", &Dtool_OrthographicLens},
  {"ParamTextureSampler", &Dtool_ParamTextureSampler},
  {"ParamTextureImage", &Dtool_ParamTextureImage},
  {"PerspectiveLens", &Dtool_PerspectiveLens},
  {"TextureReloadRequest", &Dtool_TextureReloadRequest},
  {"TextureContext", &Dtool_TextureContext},
  {"ShaderContext", &Dtool_ShaderContext},
  {"UserVertexSlider", &Dtool_UserVertexSlider},
  {"UserVertexTransform", &Dtool_UserVertexTransform},
  {"VideoTexture", &Dtool_VideoTexture},
  {"VertexBufferContext", &Dtool_VertexBufferContext},
  {"TextureCollection", &Dtool_TextureCollection},
  {"TexturePool", &Dtool_TexturePool},
  {"TexturePeeker", &Dtool_TexturePeeker},
  {"TextureStagePool", &Dtool_TextureStagePool},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"std::istream", nullptr},
#define Dtool_Ptr_std_istream (imports[1].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[2].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[3].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[4].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[5].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[6].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[7].type)
  {"Thread", nullptr},
#define Dtool_Ptr_Thread (imports[8].type)
  {"Mutex", nullptr},
#define Dtool_Ptr_Mutex (imports[9].type)
  {"UpdateSeq", nullptr},
#define Dtool_Ptr_UpdateSeq (imports[10].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[11].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[12].type)
  {"PointerToArray< unsigned char >", nullptr},
#define Dtool_Ptr_PointerToArray_unsigned_char (imports[13].type)
  {"ConstPointerToArray< unsigned char >", nullptr},
#define Dtool_Ptr_ConstPointerToArray_unsigned_char (imports[14].type)
  {"LoaderOptions", nullptr},
#define Dtool_Ptr_LoaderOptions (imports[15].type)
  {"LVecBase2f", nullptr},
#define Dtool_Ptr_LVecBase2f (imports[16].type)
  {"LVecBase2d", nullptr},
#define Dtool_Ptr_LVecBase2d (imports[17].type)
  {"LVecBase2i", nullptr},
#define Dtool_Ptr_LVecBase2i (imports[18].type)
  {"LVector2f", nullptr},
#define Dtool_Ptr_LVector2f (imports[19].type)
  {"LPoint2f", nullptr},
#define Dtool_Ptr_LPoint2f (imports[20].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[21].type)
  {"LVecBase3d", nullptr},
#define Dtool_Ptr_LVecBase3d (imports[22].type)
  {"LVecBase3i", nullptr},
#define Dtool_Ptr_LVecBase3i (imports[23].type)
  {"LVector3f", nullptr},
#define Dtool_Ptr_LVector3f (imports[24].type)
  {"LVector3d", nullptr},
#define Dtool_Ptr_LVector3d (imports[25].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[26].type)
  {"LPoint3d", nullptr},
#define Dtool_Ptr_LPoint3d (imports[27].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[28].type)
  {"LVecBase4d", nullptr},
#define Dtool_Ptr_LVecBase4d (imports[29].type)
  {"LVecBase4i", nullptr},
#define Dtool_Ptr_LVecBase4i (imports[30].type)
  {"LPoint4f", nullptr},
#define Dtool_Ptr_LPoint4f (imports[31].type)
  {"LPoint4d", nullptr},
#define Dtool_Ptr_LPoint4d (imports[32].type)
  {"LMatrix3f", nullptr},
#define Dtool_Ptr_LMatrix3f (imports[33].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[34].type)
  {"LMatrix3d", nullptr},
#define Dtool_Ptr_LMatrix3d (imports[35].type)
  {"LMatrix4d", nullptr},
#define Dtool_Ptr_LMatrix4d (imports[36].type)
  {"ParamValueBase", nullptr},
#define Dtool_Ptr_ParamValueBase (imports[37].type)
  {"AsyncFuture", nullptr},
#define Dtool_Ptr_AsyncFuture (imports[38].type)
  {"AsyncTask", nullptr},
#define Dtool_Ptr_AsyncTask (imports[39].type)
  {"CachedTypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_CachedTypedWritableReferenceCount (imports[40].type)
  {"CopyOnWriteObject", nullptr},
#define Dtool_Ptr_CopyOnWriteObject (imports[41].type)
  {"SparseArray", nullptr},
#define Dtool_Ptr_SparseArray (imports[42].type)
  {"PointerToArray< int >", nullptr},
#define Dtool_Ptr_PointerToArray_int (imports[43].type)
  {"ConstPointerToArray< int >", nullptr},
#define Dtool_Ptr_ConstPointerToArray_int (imports[44].type)
  {"GraphicsStateGuardianBase", nullptr},
#define Dtool_Ptr_GraphicsStateGuardianBase (imports[45].type)
  {"BoundingVolume", nullptr},
#define Dtool_Ptr_BoundingVolume (imports[46].type)
  {"BamCacheRecord", nullptr},
#define Dtool_Ptr_BamCacheRecord (imports[47].type)
  {"PNMImage", nullptr},
#define Dtool_Ptr_PNMImage (imports[48].type)
  {"PfmFile", nullptr},
#define Dtool_Ptr_PfmFile (imports[49].type)
  {"AnimInterface", nullptr},
#define Dtool_Ptr_AnimInterface (imports[50].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// std::istream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_istream = &Dtool_std_istream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// Thread
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Thread;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Thread = &Dtool_Thread;
#endif
// Mutex
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Mutex;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Mutex = &Dtool_Mutex;
#endif
// UpdateSeq
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_UpdateSeq;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UpdateSeq = &Dtool_UpdateSeq;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// PointerToArray< unsigned char >
#ifndef LINK_ALL_STATIC
inline static PointerToArray< unsigned char > *Dtool_Coerce_PointerToArray_unsigned_char(PyObject *args, PointerToArray< unsigned char > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_unsigned_char != nullptr, nullptr);
  nassertr(Dtool_Ptr_PointerToArray_unsigned_char->_Dtool_Coerce != nullptr, nullptr);
  return ((PointerToArray< unsigned char > *(*)(PyObject *, PointerToArray< unsigned char > &))Dtool_Ptr_PointerToArray_unsigned_char->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_unsigned_char;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_unsigned_char = &Dtool_PointerToArray_unsigned_char;
extern PointerToArray< unsigned char > *Dtool_Coerce_PointerToArray_unsigned_char(PyObject *args, PointerToArray< unsigned char > &coerced);
#endif
// ConstPointerToArray< unsigned char >
#ifndef LINK_ALL_STATIC
inline static ConstPointerToArray< unsigned char > *Dtool_Coerce_ConstPointerToArray_unsigned_char(PyObject *args, ConstPointerToArray< unsigned char > &coerced) {
  nassertr(Dtool_Ptr_ConstPointerToArray_unsigned_char != nullptr, nullptr);
  nassertr(Dtool_Ptr_ConstPointerToArray_unsigned_char->_Dtool_Coerce != nullptr, nullptr);
  return ((ConstPointerToArray< unsigned char > *(*)(PyObject *, ConstPointerToArray< unsigned char > &))Dtool_Ptr_ConstPointerToArray_unsigned_char->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ConstPointerToArray_unsigned_char;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_unsigned_char = &Dtool_ConstPointerToArray_unsigned_char;
extern ConstPointerToArray< unsigned char > *Dtool_Coerce_ConstPointerToArray_unsigned_char(PyObject *args, ConstPointerToArray< unsigned char > &coerced);
#endif
// LoaderOptions
#ifndef LINK_ALL_STATIC
inline static LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced) {
  nassertr(Dtool_Ptr_LoaderOptions != nullptr, nullptr);
  nassertr(Dtool_Ptr_LoaderOptions->_Dtool_Coerce != nullptr, nullptr);
  return ((LoaderOptions *(*)(PyObject *, LoaderOptions &))Dtool_Ptr_LoaderOptions->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LoaderOptions;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LoaderOptions = &Dtool_LoaderOptions;
extern LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced);
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVecBase2d
#ifndef LINK_ALL_STATIC
inline static LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced) {
  nassertr(Dtool_Ptr_LVecBase2d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2d *(*)(PyObject *, LVecBase2d &))Dtool_Ptr_LVecBase2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2d = &Dtool_LVecBase2d;
extern LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced);
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LVector2f
#ifndef LINK_ALL_STATIC
inline static LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced) {
  nassertr(Dtool_Ptr_LVector2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector2f *(*)(PyObject *, LVector2f &))Dtool_Ptr_LVector2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2f = &Dtool_LVector2f;
extern LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced);
#endif
// LPoint2f
#ifndef LINK_ALL_STATIC
inline static LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced) {
  nassertr(Dtool_Ptr_LPoint2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint2f *(*)(PyObject *, LPoint2f &))Dtool_Ptr_LPoint2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2f = &Dtool_LPoint2f;
extern LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVecBase3d
#ifndef LINK_ALL_STATIC
inline static LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced) {
  nassertr(Dtool_Ptr_LVecBase3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3d *(*)(PyObject *, LVecBase3d &))Dtool_Ptr_LVecBase3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3d = &Dtool_LVecBase3d;
extern LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced);
#endif
// LVecBase3i
#ifndef LINK_ALL_STATIC
inline static LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced) {
  nassertr(Dtool_Ptr_LVecBase3i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3i *(*)(PyObject *, LVecBase3i &))Dtool_Ptr_LVecBase3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3i = &Dtool_LVecBase3i;
extern LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LVector3d
#ifndef LINK_ALL_STATIC
inline static LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced) {
  nassertr(Dtool_Ptr_LVector3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3d *(*)(PyObject *, LVector3d &))Dtool_Ptr_LVector3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3d = &Dtool_LVector3d;
extern LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LPoint3d
#ifndef LINK_ALL_STATIC
inline static LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced) {
  nassertr(Dtool_Ptr_LPoint3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3d *(*)(PyObject *, LPoint3d &))Dtool_Ptr_LPoint3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3d = &Dtool_LPoint3d;
extern LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVecBase4d
#ifndef LINK_ALL_STATIC
inline static LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced) {
  nassertr(Dtool_Ptr_LVecBase4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4d *(*)(PyObject *, LVecBase4d &))Dtool_Ptr_LVecBase4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4d = &Dtool_LVecBase4d;
extern LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced);
#endif
// LVecBase4i
#ifndef LINK_ALL_STATIC
inline static LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced) {
  nassertr(Dtool_Ptr_LVecBase4i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4i *(*)(PyObject *, LVecBase4i &))Dtool_Ptr_LVecBase4i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4i = &Dtool_LVecBase4i;
extern LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced);
#endif
// LPoint4f
#ifndef LINK_ALL_STATIC
inline static LPoint4f *Dtool_Coerce_LPoint4f(PyObject *args, LPoint4f &coerced) {
  nassertr(Dtool_Ptr_LPoint4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint4f *(*)(PyObject *, LPoint4f &))Dtool_Ptr_LPoint4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint4f = &Dtool_LPoint4f;
extern LPoint4f *Dtool_Coerce_LPoint4f(PyObject *args, LPoint4f &coerced);
#endif
// LPoint4d
#ifndef LINK_ALL_STATIC
inline static LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced) {
  nassertr(Dtool_Ptr_LPoint4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint4d *(*)(PyObject *, LPoint4d &))Dtool_Ptr_LPoint4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint4d = &Dtool_LPoint4d;
extern LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced);
#endif
// LMatrix3f
#ifndef LINK_ALL_STATIC
inline static LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced) {
  nassertr(Dtool_Ptr_LMatrix3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix3f *(*)(PyObject *, LMatrix3f &))Dtool_Ptr_LMatrix3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f = &Dtool_LMatrix3f;
extern LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LMatrix3d
#ifndef LINK_ALL_STATIC
inline static LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced) {
  nassertr(Dtool_Ptr_LMatrix3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix3d *(*)(PyObject *, LMatrix3d &))Dtool_Ptr_LMatrix3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3d = &Dtool_LMatrix3d;
extern LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced);
#endif
// LMatrix4d
#ifndef LINK_ALL_STATIC
inline static LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced) {
  nassertr(Dtool_Ptr_LMatrix4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4d *(*)(PyObject *, LMatrix4d &))Dtool_Ptr_LMatrix4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d = &Dtool_LMatrix4d;
extern LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced);
#endif
// ParamValueBase
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ParamValueBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValueBase = &Dtool_ParamValueBase;
#endif
// AsyncFuture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AsyncFuture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncFuture = &Dtool_AsyncFuture;
#endif
// AsyncTask
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AsyncTask;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTask = &Dtool_AsyncTask;
#endif
// CachedTypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CachedTypedWritableReferenceCount = &Dtool_CachedTypedWritableReferenceCount;
#endif
// CopyOnWriteObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CopyOnWriteObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CopyOnWriteObject = &Dtool_CopyOnWriteObject;
#endif
// SparseArray
#ifndef LINK_ALL_STATIC
inline static SparseArray *Dtool_Coerce_SparseArray(PyObject *args, SparseArray &coerced) {
  nassertr(Dtool_Ptr_SparseArray != nullptr, nullptr);
  nassertr(Dtool_Ptr_SparseArray->_Dtool_Coerce != nullptr, nullptr);
  return ((SparseArray *(*)(PyObject *, SparseArray &))Dtool_Ptr_SparseArray->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_SparseArray;
static struct Dtool_PyTypedObject *const Dtool_Ptr_SparseArray = &Dtool_SparseArray;
extern SparseArray *Dtool_Coerce_SparseArray(PyObject *args, SparseArray &coerced);
#endif
// PointerToArray< int >
#ifndef LINK_ALL_STATIC
inline static PointerToArray< int > *Dtool_Coerce_PointerToArray_int(PyObject *args, PointerToArray< int > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_int != nullptr, nullptr);
  nassertr(Dtool_Ptr_PointerToArray_int->_Dtool_Coerce != nullptr, nullptr);
  return ((PointerToArray< int > *(*)(PyObject *, PointerToArray< int > &))Dtool_Ptr_PointerToArray_int->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_int;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_int = &Dtool_PointerToArray_int;
extern PointerToArray< int > *Dtool_Coerce_PointerToArray_int(PyObject *args, PointerToArray< int > &coerced);
#endif
// ConstPointerToArray< int >
#ifndef LINK_ALL_STATIC
inline static ConstPointerToArray< int > *Dtool_Coerce_ConstPointerToArray_int(PyObject *args, ConstPointerToArray< int > &coerced) {
  nassertr(Dtool_Ptr_ConstPointerToArray_int != nullptr, nullptr);
  nassertr(Dtool_Ptr_ConstPointerToArray_int->_Dtool_Coerce != nullptr, nullptr);
  return ((ConstPointerToArray< int > *(*)(PyObject *, ConstPointerToArray< int > &))Dtool_Ptr_ConstPointerToArray_int->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ConstPointerToArray_int;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_int = &Dtool_ConstPointerToArray_int;
extern ConstPointerToArray< int > *Dtool_Coerce_ConstPointerToArray_int(PyObject *args, ConstPointerToArray< int > &coerced);
#endif
// GraphicsStateGuardianBase
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsStateGuardianBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardianBase = &Dtool_GraphicsStateGuardianBase;
#endif
// BoundingVolume
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BoundingVolume;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingVolume = &Dtool_BoundingVolume;
#endif
// BamCacheRecord
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BamCacheRecord;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamCacheRecord = &Dtool_BamCacheRecord;
#endif
// PNMImage
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PNMImage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImage = &Dtool_PNMImage;
#endif
// PfmFile
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PfmFile;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PfmFile = &Dtool_PfmFile;
#endif
// AnimInterface
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AnimInterface;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimInterface = &Dtool_AnimInterface;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class AdaptiveLru
 */
/**
 * Python function wrapper for:
 * inline std::size_t AdaptiveLru::get_total_size(void) const
 */
static PyObject *Dtool_AdaptiveLru_get_total_size_5(PyObject *self, PyObject *) {
  AdaptiveLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLru)) {
    return nullptr;
  }
  // 1-inline std::size_t AdaptiveLru::get_total_size(void) const
  std::size_t return_value = ((*(const AdaptiveLru*)local_this).get_total_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_get_total_size_5_comment =
  "C++ Interface:\n"
  "get_total_size(AdaptiveLru self)\n"
  "\n"
  "/**\n"
  " * Returns the total size of all objects currently active on the LRU.\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_get_total_size_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t AdaptiveLru::get_max_size(void) const
 */
static PyObject *Dtool_AdaptiveLru_get_max_size_6(PyObject *self, PyObject *) {
  AdaptiveLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLru)) {
    return nullptr;
  }
  // 1-inline std::size_t AdaptiveLru::get_max_size(void) const
  std::size_t return_value = ((*(const AdaptiveLru*)local_this).get_max_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_get_max_size_6_comment =
  "C++ Interface:\n"
  "get_max_size(AdaptiveLru self)\n"
  "\n"
  "/**\n"
  " * Returns the max size of all objects that are allowed to be active on the\n"
  " * LRU.\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_get_max_size_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AdaptiveLru::set_max_size(std::size_t max_size)
 */
static PyObject *Dtool_AdaptiveLru_set_max_size_7(PyObject *self, PyObject *arg) {
  AdaptiveLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLru, (void **)&local_this, "AdaptiveLru.set_max_size")) {
    return nullptr;
  }
  // 1-inline void AdaptiveLru::set_max_size(std::size_t max_size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).set_max_size)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_size(const AdaptiveLru self, int max_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_set_max_size_7_comment =
  "C++ Interface:\n"
  "set_max_size(const AdaptiveLru self, int max_size)\n"
  "\n"
  "/**\n"
  " * Changes the max size of all objects that are allowed to be active on the\n"
  " * LRU.\n"
  " *\n"
  " * If the size is (size_t)-1, there is no limit.\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_set_max_size_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t AdaptiveLru::count_active_size(void) const
 */
static PyObject *Dtool_AdaptiveLru_count_active_size_8(PyObject *self, PyObject *) {
  AdaptiveLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLru)) {
    return nullptr;
  }
  // 1-std::size_t AdaptiveLru::count_active_size(void) const
  std::size_t return_value = ((*(const AdaptiveLru*)local_this).count_active_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_count_active_size_8_comment =
  "C++ Interface:\n"
  "count_active_size(AdaptiveLru self)\n"
  "\n"
  "/**\n"
  " * Returns the total size of the pages that were enqueued since the last call\n"
  " * to begin_epoch().\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_count_active_size_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AdaptiveLru::consider_evict(void)
 */
static PyObject *Dtool_AdaptiveLru_consider_evict_9(PyObject *self, PyObject *) {
  AdaptiveLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLru, (void **)&local_this, "AdaptiveLru.consider_evict")) {
    return nullptr;
  }
  // 1-inline void AdaptiveLru::consider_evict(void)
  ((*local_this).consider_evict)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_consider_evict_9_comment =
  "C++ Interface:\n"
  "consider_evict(const AdaptiveLru self)\n"
  "\n"
  "/**\n"
  " * Evicts a sequence of objects if the queue is full.\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_consider_evict_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AdaptiveLru::evict_to(std::size_t target_size)
 */
static PyObject *Dtool_AdaptiveLru_evict_to_10(PyObject *self, PyObject *arg) {
  AdaptiveLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLru, (void **)&local_this, "AdaptiveLru.evict_to")) {
    return nullptr;
  }
  // 1-inline void AdaptiveLru::evict_to(std::size_t target_size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).evict_to)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evict_to(const AdaptiveLru self, int target_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_evict_to_10_comment =
  "C++ Interface:\n"
  "evict_to(const AdaptiveLru self, int target_size)\n"
  "\n"
  "/**\n"
  " * Evicts a sequence of objects until the queue fits within the indicated\n"
  " * target size, regardless of its normal max size.\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_evict_to_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AdaptiveLru::begin_epoch(void)
 */
static PyObject *Dtool_AdaptiveLru_begin_epoch_11(PyObject *self, PyObject *) {
  AdaptiveLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLru, (void **)&local_this, "AdaptiveLru.begin_epoch")) {
    return nullptr;
  }
  // 1-void AdaptiveLru::begin_epoch(void)
  ((*local_this).begin_epoch)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_begin_epoch_11_comment =
  "C++ Interface:\n"
  "begin_epoch(const AdaptiveLru self)\n"
  "\n"
  "/**\n"
  " * Marks the end of the previous epoch and the beginning of the next one.\n"
  " * This will evict any objects that are pending eviction, and also update any\n"
  " * internal bookkeeping.\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_begin_epoch_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AdaptiveLru::validate(void)
 */
static PyObject *Dtool_AdaptiveLru_validate_12(PyObject *self, PyObject *) {
  AdaptiveLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLru, (void **)&local_this, "AdaptiveLru.validate")) {
    return nullptr;
  }
  // 1-inline bool AdaptiveLru::validate(void)
  bool return_value = ((*local_this).validate)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_validate_12_comment =
  "C++ Interface:\n"
  "validate(const AdaptiveLru self)\n"
  "\n"
  "/**\n"
  " * Checks that the LRU is internally self-consistent.  Returns true if\n"
  " * successful, false if there is some problem.\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_validate_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AdaptiveLru::output(std::ostream &out) const
 */
static PyObject *Dtool_AdaptiveLru_output_13(PyObject *self, PyObject *arg) {
  AdaptiveLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLru)) {
    return nullptr;
  }
  // 1-void AdaptiveLru::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AdaptiveLru.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AdaptiveLru*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AdaptiveLru self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_output_13_comment =
  "C++ Interface:\n"
  "output(AdaptiveLru self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_output_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AdaptiveLru::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_AdaptiveLru_write_14(PyObject *self, PyObject *args, PyObject *kwds) {
  AdaptiveLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLru)) {
    return nullptr;
  }
  // 1-void AdaptiveLru::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "AdaptiveLru.write", false, true);
    if (param1_this != nullptr) {
      ((*(const AdaptiveLru*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AdaptiveLru self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_write_14_comment =
  "C++ Interface:\n"
  "write(AdaptiveLru self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_write_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AdaptiveLru::set_weight(PN_stdfloat weight)
 */
static PyObject *Dtool_AdaptiveLru_set_weight_15(PyObject *self, PyObject *arg) {
  AdaptiveLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLru, (void **)&local_this, "AdaptiveLru.set_weight")) {
    return nullptr;
  }
  // 1-inline void AdaptiveLru::set_weight(PN_stdfloat weight)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_weight)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_weight(const AdaptiveLru self, float weight)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_set_weight_15_comment =
  "C++ Interface:\n"
  "set_weight(const AdaptiveLru self, float weight)\n"
  "\n"
  "// The following methods are specific to AdaptiveLru, and do not exist in\n"
  "// the SimpleLru implementation.  In most cases, the defaults will be\n"
  "// sufficient, so you do not need to mess with them.\n"
  "\n"
  "/**\n"
  " * Specifies the weight value used to compute the exponential moving average.\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_set_weight_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat AdaptiveLru::get_weight(void) const
 */
static PyObject *Dtool_AdaptiveLru_get_weight_16(PyObject *self, PyObject *) {
  AdaptiveLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLru)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat AdaptiveLru::get_weight(void) const
  PN_stdfloat return_value = ((*(const AdaptiveLru*)local_this).get_weight)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_get_weight_16_comment =
  "C++ Interface:\n"
  "get_weight(AdaptiveLru self)\n"
  "\n"
  "/**\n"
  " * Returns the weight value used to compute the exponential moving average.\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_get_weight_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AdaptiveLru::set_max_updates_per_frame(int max_updates_per_frame)
 */
static PyObject *Dtool_AdaptiveLru_set_max_updates_per_frame_17(PyObject *self, PyObject *arg) {
  AdaptiveLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLru, (void **)&local_this, "AdaptiveLru.set_max_updates_per_frame")) {
    return nullptr;
  }
  // 1-inline void AdaptiveLru::set_max_updates_per_frame(int max_updates_per_frame)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_max_updates_per_frame)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_updates_per_frame(const AdaptiveLru self, int max_updates_per_frame)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_set_max_updates_per_frame_17_comment =
  "C++ Interface:\n"
  "set_max_updates_per_frame(const AdaptiveLru self, int max_updates_per_frame)\n"
  "\n"
  "/**\n"
  " * Specifies the maximum number of pages the AdaptiveLru will update each\n"
  " * frame.  This is a performance optimization: keeping this number low limits\n"
  " * the impact of the AdaptiveLru's adaptive algorithm.\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_set_max_updates_per_frame_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AdaptiveLru::get_max_updates_per_frame(void) const
 */
static PyObject *Dtool_AdaptiveLru_get_max_updates_per_frame_18(PyObject *self, PyObject *) {
  AdaptiveLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLru)) {
    return nullptr;
  }
  // 1-inline int AdaptiveLru::get_max_updates_per_frame(void) const
  int return_value = ((*(const AdaptiveLru*)local_this).get_max_updates_per_frame)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLru_get_max_updates_per_frame_18_comment =
  "C++ Interface:\n"
  "get_max_updates_per_frame(AdaptiveLru self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of pages the AdaptiveLru will update each frame.\n"
  " */";
#else
static const char *Dtool_AdaptiveLru_get_max_updates_per_frame_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit AdaptiveLru::AdaptiveLru(std::string const &name, std::size_t max_size)
 */
static int Dtool_Init_AdaptiveLru(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit AdaptiveLru::AdaptiveLru(std::string const &name, std::size_t max_size)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  Py_ssize_t param1;
  static const char *keyword_list[] = {"name", "max_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#n:AdaptiveLru", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      PyErr_Format(PyExc_OverflowError,
                   "can't convert negative value %zd to size_t",
                   param1);
      return -1;
    }
#endif
    AdaptiveLru *return_value = new AdaptiveLru(std::string(param0_str, param0_len), (std::size_t)param1);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AdaptiveLru, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AdaptiveLru(str name, int max_size)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AdaptiveLru(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AdaptiveLru) {
    printf("AdaptiveLru ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AdaptiveLru *local_this = (AdaptiveLru *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AdaptiveLru) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AdaptiveLru(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AdaptiveLru) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AdaptiveLru*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AdaptiveLruPage
 */
/**
 * Python function wrapper for:
 * void AdaptiveLruPage::operator =(AdaptiveLruPage const &copy)
 */
static PyObject *Dtool_AdaptiveLruPage_operator_27(PyObject *self, PyObject *arg) {
  AdaptiveLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLruPage, (void **)&local_this, "AdaptiveLruPage.assign")) {
    return nullptr;
  }
  // 1-void AdaptiveLruPage::operator =(AdaptiveLruPage const &copy)
  AdaptiveLruPage const *arg_this = (AdaptiveLruPage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AdaptiveLruPage, 1, "AdaptiveLruPage.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    AdaptiveLruPage *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AdaptiveLruPage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const AdaptiveLruPage self, const AdaptiveLruPage copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_operator_27_comment =
  "C++ Interface:\n"
  "assign(const AdaptiveLruPage self, const AdaptiveLruPage copy)\n";
#else
static const char *Dtool_AdaptiveLruPage_operator_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AdaptiveLru *AdaptiveLruPage::get_lru(void) const
 */
static PyObject *Dtool_AdaptiveLruPage_get_lru_29(PyObject *self, PyObject *) {
  AdaptiveLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLruPage)) {
    return nullptr;
  }
  // 1-inline AdaptiveLru *AdaptiveLruPage::get_lru(void) const
  AdaptiveLru *return_value = ((*(const AdaptiveLruPage*)local_this).get_lru)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AdaptiveLru, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_get_lru_29_comment =
  "C++ Interface:\n"
  "get_lru(AdaptiveLruPage self)\n"
  "\n"
  "/**\n"
  " * Returns the LRU that manages this page, or NULL if it is not currently\n"
  " * managed by any LRU.\n"
  " */";
#else
static const char *Dtool_AdaptiveLruPage_get_lru_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AdaptiveLruPage::enqueue_lru(AdaptiveLru *lru)
 */
static PyObject *Dtool_AdaptiveLruPage_enqueue_lru_30(PyObject *self, PyObject *arg) {
  AdaptiveLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLruPage, (void **)&local_this, "AdaptiveLruPage.enqueue_lru")) {
    return nullptr;
  }
  // 1-void AdaptiveLruPage::enqueue_lru(AdaptiveLru *lru)
  AdaptiveLru *arg_this = (AdaptiveLru *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AdaptiveLru, 1, "AdaptiveLruPage.enqueue_lru", false, true);
  if (arg_this != nullptr) {
    ((*local_this).enqueue_lru)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enqueue_lru(const AdaptiveLruPage self, AdaptiveLru lru)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_enqueue_lru_30_comment =
  "C++ Interface:\n"
  "enqueue_lru(const AdaptiveLruPage self, AdaptiveLru lru)\n"
  "\n"
  "/**\n"
  " * Adds the page to the LRU for the first time, or marks it recently-accessed\n"
  " * if it has already been added.\n"
  " *\n"
  " * If lru is NULL, it means to remove this page from its LRU.\n"
  " */";
#else
static const char *Dtool_AdaptiveLruPage_enqueue_lru_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AdaptiveLruPage::dequeue_lru(void)
 */
static PyObject *Dtool_AdaptiveLruPage_dequeue_lru_31(PyObject *self, PyObject *) {
  AdaptiveLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLruPage, (void **)&local_this, "AdaptiveLruPage.dequeue_lru")) {
    return nullptr;
  }
  // 1-inline void AdaptiveLruPage::dequeue_lru(void)
  ((*local_this).dequeue_lru)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_dequeue_lru_31_comment =
  "C++ Interface:\n"
  "dequeue_lru(const AdaptiveLruPage self)\n"
  "\n"
  "/**\n"
  " * Removes the page from its AdaptiveLru.\n"
  " */";
#else
static const char *Dtool_AdaptiveLruPage_dequeue_lru_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AdaptiveLruPage::mark_used_lru(void) const
 * inline void AdaptiveLruPage::mark_used_lru(AdaptiveLru *lru)
 */
static PyObject *Dtool_AdaptiveLruPage_mark_used_lru_32(PyObject *self, PyObject *args) {
  AdaptiveLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLruPage)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void AdaptiveLruPage::mark_used_lru(void) const
      ((*(const AdaptiveLruPage*)local_this).mark_used_lru)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      if (!DtoolInstance_IS_CONST(self)) {
        // 1-inline void AdaptiveLruPage::mark_used_lru(AdaptiveLru *lru)
        AdaptiveLru *arg_this = (AdaptiveLru *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AdaptiveLru, 1, "AdaptiveLruPage.mark_used_lru", false, true);
        if (arg_this != nullptr) {
          ((*local_this).mark_used_lru)(arg_this);
          return Dtool_Return_None();
        }
      } else {
#ifdef NDEBUG
        return Dtool_Raise_TypeError("non-const method called on const object");
#else
        return Dtool_Raise_TypeError("Cannot call AdaptiveLruPage.mark_used_lru() on a const object.");
#endif
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "mark_used_lru() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mark_used_lru(AdaptiveLruPage self)\n"
      "mark_used_lru(const AdaptiveLruPage self, AdaptiveLru lru)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_mark_used_lru_32_comment =
  "C++ Interface:\n"
  "mark_used_lru(AdaptiveLruPage self)\n"
  "mark_used_lru(const AdaptiveLruPage self, AdaptiveLru lru)\n"
  "\n"
  "/**\n"
  " * To be called when the page is used; this will move it to the tail of the\n"
  " * AdaptiveLru queue it is already on.\n"
  " *\n"
  " * This method is const because it's not technically modifying the contents of\n"
  " * the page itself.\n"
  " */\n"
  "\n"
  "/**\n"
  " * To be called when the page is used; this will move it to the tail of the\n"
  " * specified AdaptiveLru queue.\n"
  " */";
#else
static const char *Dtool_AdaptiveLruPage_mark_used_lru_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t AdaptiveLruPage::get_lru_size(void) const
 */
static PyObject *Dtool_AdaptiveLruPage_get_lru_size_33(PyObject *self, PyObject *) {
  AdaptiveLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLruPage)) {
    return nullptr;
  }
  // 1-inline std::size_t AdaptiveLruPage::get_lru_size(void) const
  std::size_t return_value = ((*(const AdaptiveLruPage*)local_this).get_lru_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_get_lru_size_33_comment =
  "C++ Interface:\n"
  "get_lru_size(AdaptiveLruPage self)\n"
  "\n"
  "/**\n"
  " * Returns the size of this page as reported to the LRU, presumably in bytes.\n"
  " */";
#else
static const char *Dtool_AdaptiveLruPage_get_lru_size_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AdaptiveLruPage::set_lru_size(std::size_t lru_size)
 */
static PyObject *Dtool_AdaptiveLruPage_set_lru_size_34(PyObject *self, PyObject *arg) {
  AdaptiveLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLruPage, (void **)&local_this, "AdaptiveLruPage.set_lru_size")) {
    return nullptr;
  }
  // 1-inline void AdaptiveLruPage::set_lru_size(std::size_t lru_size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).set_lru_size)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lru_size(const AdaptiveLruPage self, int lru_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_set_lru_size_34_comment =
  "C++ Interface:\n"
  "set_lru_size(const AdaptiveLruPage self, int lru_size)\n"
  "\n"
  "/**\n"
  " * Specifies the size of this page, presumably in bytes, although any unit is\n"
  " * possible.\n"
  " */";
#else
static const char *Dtool_AdaptiveLruPage_set_lru_size_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AdaptiveLruPage::evict_lru(void)
 */
static PyObject *Dtool_AdaptiveLruPage_evict_lru_35(PyObject *self, PyObject *) {
  AdaptiveLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AdaptiveLruPage, (void **)&local_this, "AdaptiveLruPage.evict_lru")) {
    return nullptr;
  }
  // 1-virtual void AdaptiveLruPage::evict_lru(void)
  ((*local_this).evict_lru)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_evict_lru_35_comment =
  "C++ Interface:\n"
  "evict_lru(const AdaptiveLruPage self)\n"
  "\n"
  "/**\n"
  " * Evicts the page from the LRU.  Called internally when the LRU determines\n"
  " * that it is full.  May also be called externally when necessary to\n"
  " * explicitly evict the page.\n"
  " *\n"
  " * It is legal for this method to either evict the page as requested, do\n"
  " * nothing (in which case the eviction will be requested again at the next\n"
  " * epoch), or requeue itself on the tail of the queue (in which case the\n"
  " * eviction will be requested again much later).\n"
  " */";
#else
static const char *Dtool_AdaptiveLruPage_evict_lru_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AdaptiveLruPage::output(std::ostream &out) const
 */
static PyObject *Dtool_AdaptiveLruPage_output_36(PyObject *self, PyObject *arg) {
  AdaptiveLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLruPage)) {
    return nullptr;
  }
  // 1-virtual void AdaptiveLruPage::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AdaptiveLruPage.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AdaptiveLruPage*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AdaptiveLruPage self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_output_36_comment =
  "C++ Interface:\n"
  "output(AdaptiveLruPage self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AdaptiveLruPage_output_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AdaptiveLruPage::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_AdaptiveLruPage_write_37(PyObject *self, PyObject *args, PyObject *kwds) {
  AdaptiveLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLruPage)) {
    return nullptr;
  }
  // 1-virtual void AdaptiveLruPage::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "AdaptiveLruPage.write", false, true);
    if (param1_this != nullptr) {
      ((*(const AdaptiveLruPage*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AdaptiveLruPage self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_write_37_comment =
  "C++ Interface:\n"
  "write(AdaptiveLruPage self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AdaptiveLruPage_write_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * unsigned int AdaptiveLruPage::get_num_frames(void) const
 */
static PyObject *Dtool_AdaptiveLruPage_get_num_frames_38(PyObject *self, PyObject *) {
  AdaptiveLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLruPage)) {
    return nullptr;
  }
  // 1-unsigned int AdaptiveLruPage::get_num_frames(void) const
  unsigned int return_value = ((*(const AdaptiveLruPage*)local_this).get_num_frames)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_get_num_frames_38_comment =
  "C++ Interface:\n"
  "get_num_frames(AdaptiveLruPage self)\n"
  "\n"
  "// Not defined in SimpleLruPage.\n"
  "\n"
  "/**\n"
  " * Returns the number of frames since the page was first added to its LRU.\n"
  " * Returns 0 if it does not have an LRU.\n"
  " */";
#else
static const char *Dtool_AdaptiveLruPage_get_num_frames_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * unsigned int AdaptiveLruPage::get_num_inactive_frames(void) const
 */
static PyObject *Dtool_AdaptiveLruPage_get_num_inactive_frames_39(PyObject *self, PyObject *) {
  AdaptiveLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AdaptiveLruPage)) {
    return nullptr;
  }
  // 1-unsigned int AdaptiveLruPage::get_num_inactive_frames(void) const
  unsigned int return_value = ((*(const AdaptiveLruPage*)local_this).get_num_inactive_frames)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AdaptiveLruPage_get_num_inactive_frames_39_comment =
  "C++ Interface:\n"
  "get_num_inactive_frames(AdaptiveLruPage self)\n"
  "\n"
  "/**\n"
  " * Returns the number of frames since the page was last accessed on its LRU.\n"
  " * Returns 0 if it does not have an LRU.\n"
  " */";
#else
static const char *Dtool_AdaptiveLruPage_get_num_inactive_frames_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AdaptiveLruPage::AdaptiveLruPage(AdaptiveLruPage const &copy)
 * explicit AdaptiveLruPage::AdaptiveLruPage(std::size_t lru_size)
 */
static int Dtool_Init_AdaptiveLruPage(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AdaptiveLruPage() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 AdaptiveLruPage::AdaptiveLruPage(AdaptiveLruPage const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      AdaptiveLruPage const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_AdaptiveLruPage);
      if (param0_this != nullptr) {
        AdaptiveLruPage *return_value = new AdaptiveLruPage(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AdaptiveLruPage, true, false);
      }
    }
  }

  {
    // -2 explicit AdaptiveLruPage::AdaptiveLruPage(std::size_t lru_size)
    Py_ssize_t param0;
    static const char *keyword_list[] = {"lru_size", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "n:AdaptiveLruPage", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
      if (param0 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param0);
        return -1;
      }
#endif
      AdaptiveLruPage *return_value = new AdaptiveLruPage((std::size_t)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AdaptiveLruPage, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: AdaptiveLruPage::AdaptiveLruPage(AdaptiveLruPage const &copy)
  // No coercion possible: explicit AdaptiveLruPage::AdaptiveLruPage(std::size_t lru_size)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AdaptiveLruPage(const AdaptiveLruPage copy)\n"
      "AdaptiveLruPage(int lru_size)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AdaptiveLruPage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AdaptiveLruPage) {
    printf("AdaptiveLruPage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AdaptiveLruPage *local_this = (AdaptiveLruPage *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AdaptiveLruPage) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AdaptiveLruPage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AdaptiveLruPage) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomEnums
 */
/**
 * Python function wrapper for:
 * inline GeomEnums::GeomEnums(void) = default
 * inline GeomEnums::GeomEnums(GeomEnums const &) = default
 */
static int Dtool_Init_GeomEnums(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("GeomEnums() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline GeomEnums::GeomEnums(void) = default
      GeomEnums *return_value = new GeomEnums();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomEnums, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline GeomEnums::GeomEnums(GeomEnums const &) = default
      GeomEnums const *arg_this = (GeomEnums *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomEnums, 0, "GeomEnums.GeomEnums", true, true);
      if (arg_this != nullptr) {
        GeomEnums *return_value = new GeomEnums(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomEnums, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomEnums() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomEnums()\n"
      "GeomEnums(const GeomEnums param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomEnums(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomEnums) {
    printf("GeomEnums ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomEnums *local_this = (GeomEnums *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomEnums) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomEnums(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomVertexAnimationSpec
 */
/**
 * Python function wrapper for:
 * inline void GeomVertexAnimationSpec::operator =(GeomVertexAnimationSpec const &other)
 */
static PyObject *Dtool_GeomVertexAnimationSpec_operator_52(PyObject *self, PyObject *arg) {
  GeomVertexAnimationSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexAnimationSpec, (void **)&local_this, "GeomVertexAnimationSpec.assign")) {
    return nullptr;
  }
  // 1-inline void GeomVertexAnimationSpec::operator =(GeomVertexAnimationSpec const &other)
  GeomVertexAnimationSpec const *arg_this = (GeomVertexAnimationSpec *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexAnimationSpec, 1, "GeomVertexAnimationSpec.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    GeomVertexAnimationSpec *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexAnimationSpec, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GeomVertexAnimationSpec self, const GeomVertexAnimationSpec other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexAnimationSpec_operator_52_comment =
  "C++ Interface:\n"
  "assign(const GeomVertexAnimationSpec self, const GeomVertexAnimationSpec other)\n";
#else
static const char *Dtool_GeomVertexAnimationSpec_operator_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::AnimationType GeomVertexAnimationSpec::get_animation_type(void) const
 */
static PyObject *Dtool_GeomVertexAnimationSpec_get_animation_type_53(PyObject *self, PyObject *) {
  GeomVertexAnimationSpec *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexAnimationSpec)) {
    return nullptr;
  }
  // 1-inline GeomEnums::AnimationType GeomVertexAnimationSpec::get_animation_type(void) const
  GeomEnums::AnimationType return_value = ((*(const GeomVertexAnimationSpec*)local_this).get_animation_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexAnimationSpec_get_animation_type_53_comment =
  "C++ Interface:\n"
  "get_animation_type(GeomVertexAnimationSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the type of animation represented by this spec.\n"
  " */";
#else
static const char *Dtool_GeomVertexAnimationSpec_get_animation_type_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexAnimationSpec::get_num_transforms(void) const
 */
static PyObject *Dtool_GeomVertexAnimationSpec_get_num_transforms_55(PyObject *self, PyObject *) {
  GeomVertexAnimationSpec *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexAnimationSpec)) {
    return nullptr;
  }
  // 1-inline int GeomVertexAnimationSpec::get_num_transforms(void) const
  int return_value = ((*(const GeomVertexAnimationSpec*)local_this).get_num_transforms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexAnimationSpec_get_num_transforms_55_comment =
  "C++ Interface:\n"
  "get_num_transforms(GeomVertexAnimationSpec self)\n"
  "\n"
  "/**\n"
  " * This is only meaningful for animation_type AT_hardware.  It specifies the\n"
  " * maximum number of transforms that might be simultaneously applied to any\n"
  " * one vertex by the data in this format.\n"
  " */";
#else
static const char *Dtool_GeomVertexAnimationSpec_get_num_transforms_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexAnimationSpec::get_indexed_transforms(void) const
 */
static PyObject *Dtool_GeomVertexAnimationSpec_get_indexed_transforms_56(PyObject *self, PyObject *) {
  GeomVertexAnimationSpec *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexAnimationSpec)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexAnimationSpec::get_indexed_transforms(void) const
  bool return_value = ((*(const GeomVertexAnimationSpec*)local_this).get_indexed_transforms)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexAnimationSpec_get_indexed_transforms_56_comment =
  "C++ Interface:\n"
  "get_indexed_transforms(GeomVertexAnimationSpec self)\n"
  "\n"
  "/**\n"
  " * This is only meaningful for animation_type AT_hardware.  If true, it\n"
  " * indicates that the format uses indexed animation tables.  It is false if\n"
  " * each vertex will reference the first _num_transforms table entries only.\n"
  " */";
#else
static const char *Dtool_GeomVertexAnimationSpec_get_indexed_transforms_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexAnimationSpec::set_none(void)
 */
static PyObject *Dtool_GeomVertexAnimationSpec_set_none_61(PyObject *self, PyObject *) {
  GeomVertexAnimationSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexAnimationSpec, (void **)&local_this, "GeomVertexAnimationSpec.set_none")) {
    return nullptr;
  }
  // 1-inline void GeomVertexAnimationSpec::set_none(void)
  ((*local_this).set_none)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexAnimationSpec_set_none_61_comment =
  "C++ Interface:\n"
  "set_none(const GeomVertexAnimationSpec self)\n"
  "\n"
  "/**\n"
  " * Specifies that no vertex animation is represented by this spec.\n"
  " */";
#else
static const char *Dtool_GeomVertexAnimationSpec_set_none_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexAnimationSpec::set_panda(void)
 */
static PyObject *Dtool_GeomVertexAnimationSpec_set_panda_62(PyObject *self, PyObject *) {
  GeomVertexAnimationSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexAnimationSpec, (void **)&local_this, "GeomVertexAnimationSpec.set_panda")) {
    return nullptr;
  }
  // 1-inline void GeomVertexAnimationSpec::set_panda(void)
  ((*local_this).set_panda)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexAnimationSpec_set_panda_62_comment =
  "C++ Interface:\n"
  "set_panda(const GeomVertexAnimationSpec self)\n"
  "\n"
  "/**\n"
  " * Specifies that vertex animation is to be performed by Panda.  This is the\n"
  " * most general setting and can handle any kind of vertex animation\n"
  " * represented.\n"
  " */";
#else
static const char *Dtool_GeomVertexAnimationSpec_set_panda_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexAnimationSpec::set_hardware(int num_transforms, bool indexed_transforms)
 */
static PyObject *Dtool_GeomVertexAnimationSpec_set_hardware_63(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexAnimationSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexAnimationSpec, (void **)&local_this, "GeomVertexAnimationSpec.set_hardware")) {
    return nullptr;
  }
  // 1-inline void GeomVertexAnimationSpec::set_hardware(int num_transforms, bool indexed_transforms)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"num_transforms", "indexed_transforms", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_hardware", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_hardware)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hardware(const GeomVertexAnimationSpec self, int num_transforms, bool indexed_transforms)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexAnimationSpec_set_hardware_63_comment =
  "C++ Interface:\n"
  "set_hardware(const GeomVertexAnimationSpec self, int num_transforms, bool indexed_transforms)\n"
  "\n"
  "/**\n"
  " * Specifies that vertex animation is to be performed by the graphics hardware\n"
  " * (or at least by the graphics backend API, which is actually still free to\n"
  " * animate the vertices on the CPU).\n"
  " *\n"
  " * This is only legal if the graphics hardware can support the specified\n"
  " * limits on number of transforms and/or indexed transforms.  Also, no current\n"
  " * graphics API's support morphing.\n"
  " */";
#else
static const char *Dtool_GeomVertexAnimationSpec_set_hardware_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexAnimationSpec::output(std::ostream &out) const
 */
static PyObject *Dtool_GeomVertexAnimationSpec_output_64(PyObject *self, PyObject *arg) {
  GeomVertexAnimationSpec *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexAnimationSpec)) {
    return nullptr;
  }
  // 1-void GeomVertexAnimationSpec::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GeomVertexAnimationSpec.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GeomVertexAnimationSpec*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GeomVertexAnimationSpec self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexAnimationSpec_output_64_comment =
  "C++ Interface:\n"
  "output(GeomVertexAnimationSpec self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexAnimationSpec_output_64_comment = nullptr;
#endif

static PyObject *Dtool_GeomVertexAnimationSpec_animation_type_Getter(PyObject *self, void *) {
  const GeomVertexAnimationSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexAnimationSpec, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::AnimationType GeomVertexAnimationSpec::get_animation_type(void) const
  GeomEnums::AnimationType return_value = ((*(const GeomVertexAnimationSpec*)local_this).get_animation_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomVertexAnimationSpec_num_transforms_Getter(PyObject *self, void *) {
  const GeomVertexAnimationSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexAnimationSpec, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GeomVertexAnimationSpec::get_num_transforms(void) const
  int return_value = ((*(const GeomVertexAnimationSpec*)local_this).get_num_transforms)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomVertexAnimationSpec_indexed_transforms_Getter(PyObject *self, void *) {
  const GeomVertexAnimationSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexAnimationSpec, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GeomVertexAnimationSpec::get_indexed_transforms(void) const
  bool return_value = ((*(const GeomVertexAnimationSpec*)local_this).get_indexed_transforms)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline GeomVertexAnimationSpec::GeomVertexAnimationSpec(void)
 * inline GeomVertexAnimationSpec::GeomVertexAnimationSpec(GeomVertexAnimationSpec const &other)
 */
static int Dtool_Init_GeomVertexAnimationSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline GeomVertexAnimationSpec::GeomVertexAnimationSpec(void)
      GeomVertexAnimationSpec *return_value = new GeomVertexAnimationSpec();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexAnimationSpec, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "other")) {
        // 1-inline GeomVertexAnimationSpec::GeomVertexAnimationSpec(GeomVertexAnimationSpec const &other)
        GeomVertexAnimationSpec const *arg_this = (GeomVertexAnimationSpec *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexAnimationSpec, 0, "GeomVertexAnimationSpec.GeomVertexAnimationSpec", true, true);
        if (arg_this != nullptr) {
          GeomVertexAnimationSpec *return_value = new GeomVertexAnimationSpec(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexAnimationSpec, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomVertexAnimationSpec() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomVertexAnimationSpec()\n"
      "GeomVertexAnimationSpec(const GeomVertexAnimationSpec other)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomVertexAnimationSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomVertexAnimationSpec) {
    printf("GeomVertexAnimationSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomVertexAnimationSpec *local_this = (GeomVertexAnimationSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomVertexAnimationSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomVertexAnimationSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomVertexAnimationSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomVertexAnimationSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InternalName
 */
/**
 * Python function wrapper for:
 * static PointerTo< InternalName > InternalName::make(PyObject *str)
 * static PointerTo< InternalName > InternalName::make(std::string const &name, int index)
 */
static PyObject *Dtool_InternalName_make_68(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "str")) {
        // 1-static PointerTo< InternalName > InternalName::make(PyObject *str)
        PointerTo< InternalName > return_value = Extension<InternalName>::make(arg);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        InternalName *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static PointerTo< InternalName > InternalName::make(std::string const &name, int index)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      int param1;
      static const char *keyword_list[] = {"name", "index", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:make", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        PointerTo< InternalName > return_value = (InternalName::make)(std::string(param0_str, param0_len), (int)param1);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        InternalName *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(object str)\n"
      "make(str name, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalName_make_68_comment =
  "C++ Interface:\n"
  "make(object str)\n"
  "make(str name, int index)\n"
  "\n"
  "// These versions are exposed to Python, which have additional logic to map\n"
  "// from Python interned strings.\n"
  "\n"
  "/**\n"
  " * The public interface for constructing an InternalName pointer.  This will\n"
  " * return a new InternalName representing the indicated name, if this is the\n"
  " * first time the particular name has been requested; if the name is already\n"
  " * in use, it will return the existing pointer.\n"
  " *\n"
  " * If the string contains the '.' character, the string will be divided at the\n"
  " * dots and the so-defined hierarchy of names will be registered.  This is\n"
  " * handled transparently.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Make using a string and an integer.  Concatenates the two.\n"
  " */";
#else
static const char *Dtool_InternalName_make_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< InternalName > InternalName::append(std::string const &basename)
 */
static PyObject *Dtool_InternalName_append_69(PyObject *self, PyObject *arg) {
  InternalName *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalName, (void **)&local_this, "InternalName.append")) {
    return nullptr;
  }
  // 1-PointerTo< InternalName > InternalName::append(std::string const &basename)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PointerTo< InternalName > return_value = ((*local_this).append)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    InternalName *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append(const InternalName self, str basename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalName_append_69_comment =
  "C++ Interface:\n"
  "append(const InternalName self, str basename)\n"
  "\n"
  "/**\n"
  " * Constructs a new InternalName based on this name, with the indicated string\n"
  " * following it.  This is a cheaper way to construct a hierarchical name than\n"
  " * InternalName::make(parent->get_name() + \".basename\").\n"
  " */";
#else
static const char *Dtool_InternalName_append_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName *InternalName::get_parent(void) const
 */
static PyObject *Dtool_InternalName_get_parent_70(PyObject *self, PyObject *) {
  InternalName *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalName)) {
    return nullptr;
  }
  // 1-inline InternalName *InternalName::get_parent(void) const
  InternalName *return_value = ((*(const InternalName*)local_this).get_parent)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_parent_70_comment =
  "C++ Interface:\n"
  "get_parent(InternalName self)\n"
  "\n"
  "/**\n"
  " * Return the parent of this InternalName.  All names have a parent, except\n"
  " * the root name.\n"
  " */";
#else
static const char *Dtool_InternalName_get_parent_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string InternalName::get_name(void) const
 */
static PyObject *Dtool_InternalName_get_name_71(PyObject *self, PyObject *) {
  InternalName *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalName)) {
    return nullptr;
  }
  // 1-std::string InternalName::get_name(void) const
  std::string return_value = ((*(const InternalName*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_name_71_comment =
  "C++ Interface:\n"
  "get_name(InternalName self)\n"
  "\n"
  "/**\n"
  " * Returns the complete name represented by the InternalName and all of its\n"
  " * parents.\n"
  " */";
#else
static const char *Dtool_InternalName_get_name_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string InternalName::join(std::string const &sep) const
 */
static PyObject *Dtool_InternalName_join_72(PyObject *self, PyObject *arg) {
  InternalName *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalName)) {
    return nullptr;
  }
  // 1-std::string InternalName::join(std::string const &sep) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    std::string return_value = ((*(const InternalName*)local_this).join)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "join(InternalName self, str sep)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalName_join_72_comment =
  "C++ Interface:\n"
  "join(InternalName self, str sep)\n"
  "\n"
  "/**\n"
  " * Like get_name, but uses a custom separator instead of \".\".\n"
  " */";
#else
static const char *Dtool_InternalName_join_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &InternalName::get_basename(void) const
 */
static PyObject *Dtool_InternalName_get_basename_73(PyObject *self, PyObject *) {
  InternalName *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalName)) {
    return nullptr;
  }
  // 1-inline std::string const &InternalName::get_basename(void) const
  std::string const &return_value = ((*(const InternalName*)local_this).get_basename)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_basename_73_comment =
  "C++ Interface:\n"
  "get_basename(InternalName self)\n"
  "\n"
  "/**\n"
  " * Return the name represented by just this particular InternalName object,\n"
  " * ignoring its parents names.  This is everything after the rightmost dot.\n"
  " */";
#else
static const char *Dtool_InternalName_get_basename_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int InternalName::find_ancestor(std::string const &basename) const
 */
static PyObject *Dtool_InternalName_find_ancestor_81(PyObject *self, PyObject *arg) {
  InternalName *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalName)) {
    return nullptr;
  }
  // 1-int InternalName::find_ancestor(std::string const &basename) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    int return_value = ((*(const InternalName*)local_this).find_ancestor)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_ancestor(InternalName self, str basename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalName_find_ancestor_81_comment =
  "C++ Interface:\n"
  "find_ancestor(InternalName self, str basename)\n"
  "\n"
  "/**\n"
  " * Returns the index of the ancestor with the indicated basename, or -1 if no\n"
  " * ancestor has that basename.  Returns 0 if this name has the basename.\n"
  " *\n"
  " * This index value may be passed to get_ancestor() or get_net_basename() to\n"
  " * retrieve more information about the indicated name.\n"
  " */";
#else
static const char *Dtool_InternalName_find_ancestor_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * InternalName const *InternalName::get_ancestor(int n) const
 */
static PyObject *Dtool_InternalName_get_ancestor_82(PyObject *self, PyObject *arg) {
  InternalName *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalName)) {
    return nullptr;
  }
  // 1-InternalName const *InternalName::get_ancestor(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    InternalName const *return_value = ((*(const InternalName*)local_this).get_ancestor)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ancestor(InternalName self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_ancestor_82_comment =
  "C++ Interface:\n"
  "get_ancestor(InternalName self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the ancestor with the indicated index number.  0 is this name\n"
  " * itself, 1 is the name's parent, 2 is the parent's parent, and so on.  If\n"
  " * there are not enough ancestors, returns the root InternalName.\n"
  " */";
#else
static const char *Dtool_InternalName_get_ancestor_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * InternalName const *InternalName::get_top(void) const
 */
static PyObject *Dtool_InternalName_get_top_83(PyObject *self, PyObject *) {
  InternalName *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalName)) {
    return nullptr;
  }
  // 1-InternalName const *InternalName::get_top(void) const
  InternalName const *return_value = ((*(const InternalName*)local_this).get_top)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_top_83_comment =
  "C++ Interface:\n"
  "get_top(InternalName self)\n"
  "\n"
  "/**\n"
  " * Returns the oldest ancestor in the InternalName's chain, not counting the\n"
  " * root.  This will be the first name in the string, e.g.  \"texcoord.foo.bar\"\n"
  " * will return the InternalName \"texcoord\".\n"
  " */";
#else
static const char *Dtool_InternalName_get_top_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string InternalName::get_net_basename(int n) const
 */
static PyObject *Dtool_InternalName_get_net_basename_84(PyObject *self, PyObject *arg) {
  InternalName *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalName)) {
    return nullptr;
  }
  // 1-std::string InternalName::get_net_basename(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const InternalName*)local_this).get_net_basename)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_basename(InternalName self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_net_basename_84_comment =
  "C++ Interface:\n"
  "get_net_basename(InternalName self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the basename of this name prefixed by the indicated number of\n"
  " * ancestors.  0 is this name's basename, 1 is parent.basename, 2 is\n"
  " * grandparent.parent.basename, and so on.\n"
  " */";
#else
static const char *Dtool_InternalName_get_net_basename_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InternalName::output(std::ostream &out) const
 */
static PyObject *Dtool_InternalName_output_85(PyObject *self, PyObject *arg) {
  InternalName *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalName)) {
    return nullptr;
  }
  // 1-void InternalName::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "InternalName.output", false, true);
  if (arg_this != nullptr) {
    ((*(const InternalName*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(InternalName self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalName_output_85_comment =
  "C++ Interface:\n"
  "output(InternalName self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_InternalName_output_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_root(void)
 */
static PyObject *Dtool_InternalName_get_root_86(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_root(void)
  PointerTo< InternalName > return_value = (InternalName::get_root)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_root_86_comment =
  "C++ Interface:\n"
  "get_root()\n"
  "\n"
  "// Some predefined built-in names.\n"
  "\n"
  "/**\n"
  " * Returns the standard root InternalName.  This is the root of all other\n"
  " * InternalNames.  It has no name itself, and it is the only InternalName with\n"
  " * no parent.\n"
  " */";
#else
static const char *Dtool_InternalName_get_root_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_error(void)
 */
static PyObject *Dtool_InternalName_get_error_87(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_error(void)
  PointerTo< InternalName > return_value = (InternalName::get_error)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_error_87_comment =
  "C++ Interface:\n"
  "get_error()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"error\".\n"
  " */";
#else
static const char *Dtool_InternalName_get_error_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_vertex(void)
 */
static PyObject *Dtool_InternalName_get_vertex_88(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_vertex(void)
  PointerTo< InternalName > return_value = (InternalName::get_vertex)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_vertex_88_comment =
  "C++ Interface:\n"
  "get_vertex()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"vertex\".  This is the column header for\n"
  " * the 3-d or 4-d vertex position information for each vertex.\n"
  " */";
#else
static const char *Dtool_InternalName_get_vertex_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_normal(void)
 */
static PyObject *Dtool_InternalName_get_normal_89(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_normal(void)
  PointerTo< InternalName > return_value = (InternalName::get_normal)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_normal_89_comment =
  "C++ Interface:\n"
  "get_normal()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"normal\".  This is the column header for\n"
  " * the 3-d lighting normal for each vertex.\n"
  " */";
#else
static const char *Dtool_InternalName_get_normal_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_tangent(void)
 */
static PyObject *Dtool_InternalName_get_tangent_90(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_tangent(void)
  PointerTo< InternalName > return_value = (InternalName::get_tangent)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_tangent_90_comment =
  "C++ Interface:\n"
  "get_tangent()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"tangent\".  This is the column header for\n"
  " * the tangent vector associated with each vertex, which is a unit vector\n"
  " * usually perpendicular to the normal and in the direction of the U texture\n"
  " * coordinate change.  It is used for deriving bump maps.\n"
  " */";
#else
static const char *Dtool_InternalName_get_tangent_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_tangent_name(std::string const &name)
 */
static PyObject *Dtool_InternalName_get_tangent_name_91(PyObject *, PyObject *arg) {
  // 1-static inline PointerTo< InternalName > InternalName::get_tangent_name(std::string const &name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    PointerTo< InternalName > return_value = (InternalName::get_tangent_name)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    InternalName *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tangent_name(str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_tangent_name_91_comment =
  "C++ Interface:\n"
  "get_tangent_name(str name)\n"
  "\n"
  "/**\n"
  " * Returns the InternalName \"tangent.name\", where name is the supplied string.\n"
  " * This is the column header for the tangent associated with the named texture\n"
  " * coordinate set.\n"
  " */";
#else
static const char *Dtool_InternalName_get_tangent_name_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_binormal(void)
 */
static PyObject *Dtool_InternalName_get_binormal_92(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_binormal(void)
  PointerTo< InternalName > return_value = (InternalName::get_binormal)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_binormal_92_comment =
  "C++ Interface:\n"
  "get_binormal()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"binormal\".  This is the column header\n"
  " * for the tangent vector associated with each vertex, which is a unit vector\n"
  " * usually perpendicular to both the normal and the tangent, and in the\n"
  " * direction of the V texture coordinate change.  It is used for deriving bump\n"
  " * maps.\n"
  " */";
#else
static const char *Dtool_InternalName_get_binormal_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_binormal_name(std::string const &name)
 */
static PyObject *Dtool_InternalName_get_binormal_name_93(PyObject *, PyObject *arg) {
  // 1-static inline PointerTo< InternalName > InternalName::get_binormal_name(std::string const &name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    PointerTo< InternalName > return_value = (InternalName::get_binormal_name)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    InternalName *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_binormal_name(str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_binormal_name_93_comment =
  "C++ Interface:\n"
  "get_binormal_name(str name)\n"
  "\n"
  "/**\n"
  " * Returns the InternalName \"binormal.name\", where name is the supplied\n"
  " * string.  This is the column header for the binormal associated with the\n"
  " * named texture coordinate set.\n"
  " */";
#else
static const char *Dtool_InternalName_get_binormal_name_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_texcoord(void)
 */
static PyObject *Dtool_InternalName_get_texcoord_94(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_texcoord(void)
  PointerTo< InternalName > return_value = (InternalName::get_texcoord)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_texcoord_94_comment =
  "C++ Interface:\n"
  "get_texcoord()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"texcoord\".  This is the column header\n"
  " * for the default texture coordinate set for each vertex.  It is also used\n"
  " * for identifying the default texture coordinate set in a TextureStage.\n"
  " */";
#else
static const char *Dtool_InternalName_get_texcoord_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_texcoord_name(std::string const &name)
 */
static PyObject *Dtool_InternalName_get_texcoord_name_95(PyObject *, PyObject *arg) {
  // 1-static inline PointerTo< InternalName > InternalName::get_texcoord_name(std::string const &name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    PointerTo< InternalName > return_value = (InternalName::get_texcoord_name)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    InternalName *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texcoord_name(str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_texcoord_name_95_comment =
  "C++ Interface:\n"
  "get_texcoord_name(str name)\n"
  "\n"
  "/**\n"
  " * Returns the InternalName \"texcoord.name\", where name is the supplied\n"
  " * string.  This is the column header for the named texture coordinate set for\n"
  " * each vertex.  It is also used for identifying the named texture coordinate\n"
  " * set in a TextureStage.\n"
  " */";
#else
static const char *Dtool_InternalName_get_texcoord_name_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_color(void)
 */
static PyObject *Dtool_InternalName_get_color_96(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_color(void)
  PointerTo< InternalName > return_value = (InternalName::get_color)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_color_96_comment =
  "C++ Interface:\n"
  "get_color()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"color\".  This is the column header for\n"
  " * the 4-component color value for each vertex.\n"
  " */";
#else
static const char *Dtool_InternalName_get_color_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_rotate(void)
 */
static PyObject *Dtool_InternalName_get_rotate_97(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_rotate(void)
  PointerTo< InternalName > return_value = (InternalName::get_rotate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_rotate_97_comment =
  "C++ Interface:\n"
  "get_rotate()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"rotate\".  This is the column header for\n"
  " * the floating-point rotate value, which represents a number of degrees\n"
  " * counter-clockwise to rotate each point or point sprite.\n"
  " */";
#else
static const char *Dtool_InternalName_get_rotate_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_size(void)
 */
static PyObject *Dtool_InternalName_get_size_98(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_size(void)
  PointerTo< InternalName > return_value = (InternalName::get_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_size_98_comment =
  "C++ Interface:\n"
  "get_size()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"size\".  This is the column header for\n"
  " * the floating-point size value, which overrides the thickness parameter of\n"
  " * the RenderModeAttrib on a per-vertex (e.g.  per-point) basis.\n"
  " */";
#else
static const char *Dtool_InternalName_get_size_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_aspect_ratio(void)
 */
static PyObject *Dtool_InternalName_get_aspect_ratio_99(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_aspect_ratio(void)
  PointerTo< InternalName > return_value = (InternalName::get_aspect_ratio)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_aspect_ratio_99_comment =
  "C++ Interface:\n"
  "get_aspect_ratio()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"aspect_ratio\". This is the column header\n"
  " * for the floating-point aspect ratio value, which is used to define non-\n"
  " * square points.  This number is the ratio x / y, where y is the point size\n"
  " * (above).\n"
  " */";
#else
static const char *Dtool_InternalName_get_aspect_ratio_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_transform_blend(void)
 */
static PyObject *Dtool_InternalName_get_transform_blend_100(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_transform_blend(void)
  PointerTo< InternalName > return_value = (InternalName::get_transform_blend)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_transform_blend_100_comment =
  "C++ Interface:\n"
  "get_transform_blend()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"transform_blend\". This is the column\n"
  " * header for the integer transform_blend index, which is used to define\n"
  " * vertex animation on the CPU by indexing to a particular vertex weighting\n"
  " * from the TransformBlendTable.\n"
  " */";
#else
static const char *Dtool_InternalName_get_transform_blend_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_transform_weight(void)
 */
static PyObject *Dtool_InternalName_get_transform_weight_101(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_transform_weight(void)
  PointerTo< InternalName > return_value = (InternalName::get_transform_weight)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_transform_weight_101_comment =
  "C++ Interface:\n"
  "get_transform_weight()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"transform_weight\". This is the column\n"
  " * header for the n-component transform_weight value, which is used in\n"
  " * conjuntion with \"transform_index\" to define vertex animation on the\n"
  " * graphics card.  The transform_weight value specifies the weight of the nth\n"
  " * transform.  By convention, there are 1 fewer weight values than transforms,\n"
  " * since the weights are assumed to sum to 1 (and the last value is therefore\n"
  " * implicit).\n"
  " */";
#else
static const char *Dtool_InternalName_get_transform_weight_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_transform_index(void)
 */
static PyObject *Dtool_InternalName_get_transform_index_102(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_transform_index(void)
  PointerTo< InternalName > return_value = (InternalName::get_transform_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_transform_index_102_comment =
  "C++ Interface:\n"
  "get_transform_index()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"transform_index\". This is the column\n"
  " * header for the n-component transform_index value, which is used in\n"
  " * conjuntion with \"transform_weight\" to define vertex animation on the\n"
  " * graphics card.  The transform_index value specifies the nth transform, by\n"
  " * lookup in the TransformTable.  The transform_index column may be omitted,\n"
  " * in which case the nth transform is the nth entry in the table.\n"
  " */";
#else
static const char *Dtool_InternalName_get_transform_index_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_morph(InternalName *column, std::string const &slider)
 */
static PyObject *Dtool_InternalName_get_morph_103(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerTo< InternalName > InternalName::get_morph(InternalName *column, std::string const &slider)
  PyObject *param0;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"column", "slider", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:get_morph", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    PT(InternalName) param0_this;
    if (!Dtool_Coerce_InternalName(param0, param0_this)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "InternalName.get_morph", "InternalName");
    }
    PointerTo< InternalName > return_value = (InternalName::get_morph)(std::move(param0_this), std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    InternalName *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_morph(InternalName column, str slider)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_morph_103_comment =
  "C++ Interface:\n"
  "get_morph(InternalName column, str slider)\n"
  "\n"
  "/**\n"
  " * Returns an InternalName derived from the given base column name and the\n"
  " * given slider name, which is the column header for the offset vector that\n"
  " * should be applied to the base column name when the named morph slider is\n"
  " * engaged.\n"
  " *\n"
  " * Each morph slider requires a set of n morph columns, one for each base\n"
  " * column it applies to.\n"
  " */";
#else
static const char *Dtool_InternalName_get_morph_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_index(void)
 */
static PyObject *Dtool_InternalName_get_index_104(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_index(void)
  PointerTo< InternalName > return_value = (InternalName::get_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_index_104_comment =
  "C++ Interface:\n"
  "get_index()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"index\".  This is the column header for\n"
  " * the integer vertex index.  It is not used in the vertex data itself, but is\n"
  " * used in the GeomPrimitive structure to index into the vertex data.\n"
  " */";
#else
static const char *Dtool_InternalName_get_index_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_world(void)
 */
static PyObject *Dtool_InternalName_get_world_105(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_world(void)
  PointerTo< InternalName > return_value = (InternalName::get_world)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_world_105_comment =
  "C++ Interface:\n"
  "get_world()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"world\".  This is used as a keyword in\n"
  " * the shader subsystem.\n"
  " */";
#else
static const char *Dtool_InternalName_get_world_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_camera(void)
 */
static PyObject *Dtool_InternalName_get_camera_106(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_camera(void)
  PointerTo< InternalName > return_value = (InternalName::get_camera)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_camera_106_comment =
  "C++ Interface:\n"
  "get_camera()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"camera\".  This is used as a keyword in\n"
  " * the shader subsystem.\n"
  " */";
#else
static const char *Dtool_InternalName_get_camera_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_model(void)
 */
static PyObject *Dtool_InternalName_get_model_107(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_model(void)
  PointerTo< InternalName > return_value = (InternalName::get_model)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_model_107_comment =
  "C++ Interface:\n"
  "get_model()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"model\".  This is used as a keyword in\n"
  " * the shader subsystem.\n"
  " */";
#else
static const char *Dtool_InternalName_get_model_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< InternalName > InternalName::get_view(void)
 */
static PyObject *Dtool_InternalName_get_view_108(PyObject *, PyObject *) {
  // 1-static inline PointerTo< InternalName > InternalName::get_view(void)
  PointerTo< InternalName > return_value = (InternalName::get_view)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  InternalName *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_view_108_comment =
  "C++ Interface:\n"
  "get_view()\n"
  "\n"
  "/**\n"
  " * Returns the standard InternalName \"view\".  This is used as a keyword in the\n"
  " * shader subsystem.\n"
  " */";
#else
static const char *Dtool_InternalName_get_view_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle InternalName::get_class_type(void)
 */
static PyObject *Dtool_InternalName_get_class_type_109(PyObject *, PyObject *) {
  // 1-static TypeHandle InternalName::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((InternalName::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalName_get_class_type_109_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_InternalName_get_class_type_109_comment = nullptr;
#endif

static PyObject *Dtool_InternalName_parent_Getter(PyObject *self, void *) {
  const InternalName *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalName, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline InternalName *InternalName::get_parent(void) const
  InternalName *return_value = ((*(const InternalName*)local_this).get_parent)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, false);
}

static PyObject *Dtool_InternalName_name_Getter(PyObject *self, void *) {
  const InternalName *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalName, (void **)&local_this)) {
    return nullptr;
  }

  // 1-std::string InternalName::get_name(void) const
  std::string return_value = ((*(const InternalName*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InternalName_basename_Getter(PyObject *self, void *) {
  const InternalName *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalName, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &InternalName::get_basename(void) const
  std::string const &return_value = ((*(const InternalName*)local_this).get_basename)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_InternalName(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_InternalName(PyObject *args, CPT(InternalName) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_InternalName)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static PointerTo< InternalName > InternalName::make(PyObject *str)
    PointerTo< InternalName > return_value = Extension<InternalName>::make(arg);
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      return false;
    } else {
      coerced = std::move(DCAST(InternalName, return_value.p()));
      return true;
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-static PointerTo< InternalName > InternalName::make(std::string const &name, int index)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      int param1;
      if (PyArg_ParseTuple(args, "s#i:make", &param0_str, &param0_len, &param1)) {
        PointerTo< InternalName > return_value = (InternalName::make)(std::string(param0_str, param0_len), (int)param1);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move(DCAST(InternalName, return_value.p()));
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_InternalName(PyObject *args, PT(InternalName) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_InternalName)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static PointerTo< InternalName > InternalName::make(PyObject *str)
    PointerTo< InternalName > return_value = Extension<InternalName>::make(arg);
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      return false;
    } else {
      coerced = std::move(DCAST(InternalName, return_value.p()));
      return true;
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-static PointerTo< InternalName > InternalName::make(std::string const &name, int index)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      int param1;
      if (PyArg_ParseTuple(args, "s#i:make", &param0_str, &param0_len, &param1)) {
        PointerTo< InternalName > return_value = (InternalName::make)(std::string(param0_str, param0_len), (int)param1);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move(DCAST(InternalName, return_value.p()));
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_InternalName(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InternalName) {
    printf("InternalName ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InternalName *local_this = (InternalName *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InternalName) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InternalName(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InternalName) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (InternalName*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (InternalName*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (InternalName*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (InternalName*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomVertexColumn
 */
/**
 * Python function wrapper for:
 * void GeomVertexColumn::operator =(GeomVertexColumn const &copy)
 */
static PyObject *Dtool_GeomVertexColumn_operator_112(PyObject *self, PyObject *arg) {
  GeomVertexColumn *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexColumn, (void **)&local_this, "GeomVertexColumn.assign")) {
    return nullptr;
  }
  // 1-void GeomVertexColumn::operator =(GeomVertexColumn const &copy)
  GeomVertexColumn const *arg_this = (GeomVertexColumn *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexColumn, 1, "GeomVertexColumn.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    GeomVertexColumn *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GeomVertexColumn self, const GeomVertexColumn copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_operator_112_comment =
  "C++ Interface:\n"
  "assign(const GeomVertexColumn self, const GeomVertexColumn copy)\n";
#else
static const char *Dtool_GeomVertexColumn_operator_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName const *GeomVertexColumn::get_name(void) const
 */
static PyObject *Dtool_GeomVertexColumn_get_name_114(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline InternalName const *GeomVertexColumn::get_name(void) const
  InternalName const *return_value = ((*(const GeomVertexColumn*)local_this).get_name)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_get_name_114_comment =
  "C++ Interface:\n"
  "get_name(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this particular data field, e.g.  \"vertex\" or \"normal\".\n"
  " * The name may be a user-defined string, or it may be one of the standard\n"
  " * system-defined field types.  Only the system-defined field types are used\n"
  " * for the actual rendering.\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_get_name_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexColumn::get_num_components(void) const
 */
static PyObject *Dtool_GeomVertexColumn_get_num_components_115(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline int GeomVertexColumn::get_num_components(void) const
  int return_value = ((*(const GeomVertexColumn*)local_this).get_num_components)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_get_num_components_115_comment =
  "C++ Interface:\n"
  "get_num_components(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * Returns the number of components of the column: the number of instances of\n"
  " * the NumericType in each element.  This is usually, but not always, the same\n"
  " * thing as get_num_values().\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_get_num_components_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexColumn::get_num_values(void) const
 */
static PyObject *Dtool_GeomVertexColumn_get_num_values_116(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline int GeomVertexColumn::get_num_values(void) const
  int return_value = ((*(const GeomVertexColumn*)local_this).get_num_values)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_get_num_values_116_comment =
  "C++ Interface:\n"
  "get_num_values(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * Returns the number of numeric values of the column: the number of distinct\n"
  " * numeric values that go into each element.  This is usually, but not always,\n"
  " * the same thing as get_num_components(); the difference is in the case of a\n"
  " * composite numeric type like NT_packed_dcba, which has four numeric values\n"
  " * per component.\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_get_num_values_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexColumn::get_num_elements(void) const
 */
static PyObject *Dtool_GeomVertexColumn_get_num_elements_117(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline int GeomVertexColumn::get_num_elements(void) const
  int return_value = ((*(const GeomVertexColumn*)local_this).get_num_elements)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_get_num_elements_117_comment =
  "C++ Interface:\n"
  "get_num_elements(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * Returns the number of times this column is repeated.  This is usually 1,\n"
  " * except for matrices.\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_get_num_elements_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::NumericType GeomVertexColumn::get_numeric_type(void) const
 */
static PyObject *Dtool_GeomVertexColumn_get_numeric_type_118(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline GeomEnums::NumericType GeomVertexColumn::get_numeric_type(void) const
  GeomEnums::NumericType return_value = ((*(const GeomVertexColumn*)local_this).get_numeric_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_get_numeric_type_118_comment =
  "C++ Interface:\n"
  "get_numeric_type(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * Returns the token representing the numeric type of the data storage.\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_get_numeric_type_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::Contents GeomVertexColumn::get_contents(void) const
 */
static PyObject *Dtool_GeomVertexColumn_get_contents_119(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline GeomEnums::Contents GeomVertexColumn::get_contents(void) const
  GeomEnums::Contents return_value = ((*(const GeomVertexColumn*)local_this).get_contents)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_get_contents_119_comment =
  "C++ Interface:\n"
  "get_contents(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * Returns the token representing the semantic meaning of the stored value.\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_get_contents_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexColumn::get_start(void) const
 */
static PyObject *Dtool_GeomVertexColumn_get_start_120(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline int GeomVertexColumn::get_start(void) const
  int return_value = ((*(const GeomVertexColumn*)local_this).get_start)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_get_start_120_comment =
  "C++ Interface:\n"
  "get_start(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * Returns the byte within the array record at which this column starts.  This\n"
  " * can be set to non-zero to implement interleaved arrays.\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_get_start_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexColumn::get_column_alignment(void) const
 */
static PyObject *Dtool_GeomVertexColumn_get_column_alignment_121(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline int GeomVertexColumn::get_column_alignment(void) const
  int return_value = ((*(const GeomVertexColumn*)local_this).get_column_alignment)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_get_column_alignment_121_comment =
  "C++ Interface:\n"
  "get_column_alignment(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * Returns the alignment requirements for this column.  If this is greater\n"
  " * than 1, it restricts the column to appear only on memory addresses that are\n"
  " * integer multiples of this value; this has implications for this column's\n"
  " * start value, as well as the stride of the resulting array.\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_get_column_alignment_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexColumn::get_element_stride(void) const
 */
static PyObject *Dtool_GeomVertexColumn_get_element_stride_122(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline int GeomVertexColumn::get_element_stride(void) const
  int return_value = ((*(const GeomVertexColumn*)local_this).get_element_stride)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_get_element_stride_122_comment =
  "C++ Interface:\n"
  "get_element_stride(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * This value is only relevant for matrix types.  Returns the number of bytes\n"
  " * to add to access the next row of the matrix.\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_get_element_stride_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexColumn::get_component_bytes(void) const
 */
static PyObject *Dtool_GeomVertexColumn_get_component_bytes_123(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline int GeomVertexColumn::get_component_bytes(void) const
  int return_value = ((*(const GeomVertexColumn*)local_this).get_component_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_get_component_bytes_123_comment =
  "C++ Interface:\n"
  "get_component_bytes(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes used by each component (that is, by one element\n"
  " * of the numeric type).\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_get_component_bytes_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexColumn::get_total_bytes(void) const
 */
static PyObject *Dtool_GeomVertexColumn_get_total_bytes_124(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline int GeomVertexColumn::get_total_bytes(void) const
  int return_value = ((*(const GeomVertexColumn*)local_this).get_total_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_get_total_bytes_124_comment =
  "C++ Interface:\n"
  "get_total_bytes(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes used by each element of the column:\n"
  " * component_bytes * num_components.\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_get_total_bytes_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexColumn::has_homogeneous_coord(void) const
 */
static PyObject *Dtool_GeomVertexColumn_has_homogeneous_coord_125(PyObject *self, PyObject *) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexColumn::has_homogeneous_coord(void) const
  bool return_value = ((*(const GeomVertexColumn*)local_this).has_homogeneous_coord)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_has_homogeneous_coord_125_comment =
  "C++ Interface:\n"
  "has_homogeneous_coord(GeomVertexColumn self)\n"
  "\n"
  "/**\n"
  " * Returns true if this Contents type is one that includes a homogeneous\n"
  " * coordinate in the fourth component, or false otherwise.  If this is true,\n"
  " * correct operation on the vertex data may require scaling by the homogeneous\n"
  " * coordinate from time to time (but in general this is handled automatically\n"
  " * if you use the 3-component or smaller forms of get_data() and set_data()).\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_has_homogeneous_coord_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexColumn::overlaps_with(int start_byte, int num_bytes) const
 */
static PyObject *Dtool_GeomVertexColumn_overlaps_with_126(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexColumn::overlaps_with(int start_byte, int num_bytes) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"start_byte", "num_bytes", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:overlaps_with", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const GeomVertexColumn*)local_this).overlaps_with)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "overlaps_with(GeomVertexColumn self, int start_byte, int num_bytes)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_overlaps_with_126_comment =
  "C++ Interface:\n"
  "overlaps_with(GeomVertexColumn self, int start_byte, int num_bytes)\n"
  "\n"
  "/**\n"
  " * Returns true if this column overlaps with any of the bytes in the indicated\n"
  " * range, false if it does not.\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_overlaps_with_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexColumn::is_bytewise_equivalent(GeomVertexColumn const &other) const
 */
static PyObject *Dtool_GeomVertexColumn_is_bytewise_equivalent_127(PyObject *self, PyObject *arg) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexColumn::is_bytewise_equivalent(GeomVertexColumn const &other) const
  GeomVertexColumn const *arg_this = (GeomVertexColumn *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexColumn, 1, "GeomVertexColumn.is_bytewise_equivalent", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const GeomVertexColumn*)local_this).is_bytewise_equivalent)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_bytewise_equivalent(GeomVertexColumn self, const GeomVertexColumn other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_is_bytewise_equivalent_127_comment =
  "C++ Interface:\n"
  "is_bytewise_equivalent(GeomVertexColumn self, const GeomVertexColumn other)\n"
  "\n"
  "/**\n"
  " * Returns true if the data store of this column is exactly the same as that\n"
  " * of the other, irrespective of name or start position within the record.\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_is_bytewise_equivalent_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexColumn::set_name(InternalName *name)
 */
static PyObject *Dtool_GeomVertexColumn_set_name_128(PyObject *self, PyObject *arg) {
  GeomVertexColumn *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexColumn, (void **)&local_this, "GeomVertexColumn.set_name")) {
    return nullptr;
  }
  // 1-void GeomVertexColumn::set_name(InternalName *name)
  PT(InternalName) arg_this;
  if (!Dtool_Coerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexColumn.set_name", "InternalName");
  }
  ((*local_this).set_name)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const GeomVertexColumn self, InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_set_name_128_comment =
  "C++ Interface:\n"
  "set_name(const GeomVertexColumn self, InternalName name)\n"
  "\n"
  "/**\n"
  " * Replaces the name of an existing column.  This is only legal on an\n"
  " * unregistered format (i.e.  when constructing the format initially).\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_set_name_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexColumn::set_num_components(int num_components)
 */
static PyObject *Dtool_GeomVertexColumn_set_num_components_129(PyObject *self, PyObject *arg) {
  GeomVertexColumn *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexColumn, (void **)&local_this, "GeomVertexColumn.set_num_components")) {
    return nullptr;
  }
  // 1-void GeomVertexColumn::set_num_components(int num_components)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_components)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_components(const GeomVertexColumn self, int num_components)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_set_num_components_129_comment =
  "C++ Interface:\n"
  "set_num_components(const GeomVertexColumn self, int num_components)\n"
  "\n"
  "/**\n"
  " * Changes the number of components of an existing column.  This is only legal\n"
  " * on an unregistered format (i.e.  when constructing the format initially).\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_set_num_components_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexColumn::set_numeric_type(GeomEnums::NumericType numeric_type)
 */
static PyObject *Dtool_GeomVertexColumn_set_numeric_type_130(PyObject *self, PyObject *arg) {
  GeomVertexColumn *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexColumn, (void **)&local_this, "GeomVertexColumn.set_numeric_type")) {
    return nullptr;
  }
  // 1-void GeomVertexColumn::set_numeric_type(GeomEnums::NumericType numeric_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_numeric_type)((GeomEnums::NumericType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_numeric_type(const GeomVertexColumn self, int numeric_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_set_numeric_type_130_comment =
  "C++ Interface:\n"
  "set_numeric_type(const GeomVertexColumn self, int numeric_type)\n"
  "\n"
  "/**\n"
  " * Changes the numeric type an existing column.  This is only legal on an\n"
  " * unregistered format (i.e.  when constructing the format initially).\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_set_numeric_type_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexColumn::set_contents(GeomEnums::Contents contents)
 */
static PyObject *Dtool_GeomVertexColumn_set_contents_131(PyObject *self, PyObject *arg) {
  GeomVertexColumn *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexColumn, (void **)&local_this, "GeomVertexColumn.set_contents")) {
    return nullptr;
  }
  // 1-void GeomVertexColumn::set_contents(GeomEnums::Contents contents)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_contents)((GeomEnums::Contents)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contents(const GeomVertexColumn self, int contents)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_set_contents_131_comment =
  "C++ Interface:\n"
  "set_contents(const GeomVertexColumn self, int contents)\n"
  "\n"
  "/**\n"
  " * Changes the semantic meaning of an existing column.  This is only legal on\n"
  " * an unregistered format (i.e.  when constructing the format initially).\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_set_contents_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexColumn::set_start(int start)
 */
static PyObject *Dtool_GeomVertexColumn_set_start_132(PyObject *self, PyObject *arg) {
  GeomVertexColumn *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexColumn, (void **)&local_this, "GeomVertexColumn.set_start")) {
    return nullptr;
  }
  // 1-void GeomVertexColumn::set_start(int start)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_start)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start(const GeomVertexColumn self, int start)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_set_start_132_comment =
  "C++ Interface:\n"
  "set_start(const GeomVertexColumn self, int start)\n"
  "\n"
  "/**\n"
  " * Changes the start byte of an existing column.  This is only legal on an\n"
  " * unregistered format (i.e.  when constructing the format initially).\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_set_start_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexColumn::set_column_alignment(int column_alignment)
 */
static PyObject *Dtool_GeomVertexColumn_set_column_alignment_133(PyObject *self, PyObject *arg) {
  GeomVertexColumn *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexColumn, (void **)&local_this, "GeomVertexColumn.set_column_alignment")) {
    return nullptr;
  }
  // 1-void GeomVertexColumn::set_column_alignment(int column_alignment)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_column_alignment)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_column_alignment(const GeomVertexColumn self, int column_alignment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_set_column_alignment_133_comment =
  "C++ Interface:\n"
  "set_column_alignment(const GeomVertexColumn self, int column_alignment)\n"
  "\n"
  "/**\n"
  " * Changes the column alignment of an existing column.  This is only legal on\n"
  " * an unregistered format (i.e.  when constructing the format initially).\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_set_column_alignment_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexColumn::output(std::ostream &out) const
 */
static PyObject *Dtool_GeomVertexColumn_output_134(PyObject *self, PyObject *arg) {
  GeomVertexColumn *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexColumn)) {
    return nullptr;
  }
  // 1-void GeomVertexColumn::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GeomVertexColumn.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GeomVertexColumn*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GeomVertexColumn self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexColumn_output_134_comment =
  "C++ Interface:\n"
  "output(GeomVertexColumn self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexColumn_output_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline explicit GeomVertexColumn::GeomVertexColumn(CPT_InternalName name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents, int start, int column_alignment = 0, int num_elements = 0, int element_stride = 0)
 * inline GeomVertexColumn::GeomVertexColumn(GeomVertexColumn const &copy)
 */
static int Dtool_Init_GeomVertexColumn(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline GeomVertexColumn::GeomVertexColumn(GeomVertexColumn const &copy)
        GeomVertexColumn const *arg_this = (GeomVertexColumn *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexColumn, 0, "GeomVertexColumn.GeomVertexColumn", true, true);
        if (arg_this != nullptr) {
          GeomVertexColumn *return_value = new GeomVertexColumn(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexColumn, true, false);
        }
      }
    }
    break;
  case 5:
  case 6:
  case 7:
  case 8:
    {
      // 1-inline explicit GeomVertexColumn::GeomVertexColumn(CPT_InternalName name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents, int start, int column_alignment = 0, int num_elements = 0, int element_stride = 0)
      PyObject *param0;
      int param1;
      int param2;
      int param3;
      int param4;
      int param5 = 0;
      int param6 = 0;
      int param7 = 0;
      static const char *keyword_list[] = {"name", "num_components", "numeric_type", "contents", "start", "column_alignment", "num_elements", "element_stride", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiiii|iii:GeomVertexColumn", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        CPT(InternalName) param0_this;
        if (!Dtool_ConstCoerce_InternalName(param0, param0_this)) {
          Dtool_Raise_ArgTypeError(param0, 0, "GeomVertexColumn.GeomVertexColumn", "InternalName");
          return -1;
        }
        GeomVertexColumn *return_value = new GeomVertexColumn(std::move(param0_this), (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3, (int)param4, (int)param5, (int)param6, (int)param7);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexColumn, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomVertexColumn() takes 1, 5, 6, 7 or 8 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomVertexColumn(const GeomVertexColumn copy)\n"
      "GeomVertexColumn(const InternalName name, int num_components, int numeric_type, int contents, int start, int column_alignment, int num_elements, int element_stride)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomVertexColumn(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomVertexColumn) {
    printf("GeomVertexColumn ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomVertexColumn *local_this = (GeomVertexColumn *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomVertexColumn) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomVertexColumn(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomVertexColumn) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomVertexColumn*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomVertexArrayFormat
 */
/**
 * Python function wrapper for:
 * void GeomVertexArrayFormat::operator =(GeomVertexArrayFormat const &copy)
 */
static PyObject *Dtool_GeomVertexArrayFormat_operator_141(PyObject *self, PyObject *arg) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.assign")) {
    return nullptr;
  }
  // 1-void GeomVertexArrayFormat::operator =(GeomVertexArrayFormat const &copy)
  CPT(GeomVertexArrayFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexArrayFormat(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexArrayFormat.assign", "GeomVertexArrayFormat");
  }
  ((*local_this).operator =)(*std::move(arg_this));
  GeomVertexArrayFormat *return_value = local_this;
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexArrayFormat, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GeomVertexArrayFormat self, const GeomVertexArrayFormat copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_operator_141_comment =
  "C++ Interface:\n"
  "assign(const GeomVertexArrayFormat self, const GeomVertexArrayFormat copy)\n";
#else
static const char *Dtool_GeomVertexArrayFormat_operator_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool GeomVertexArrayFormat::unref(void) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_unref_143(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-virtual bool GeomVertexArrayFormat::unref(void) const
  bool return_value = ((*(const GeomVertexArrayFormat*)local_this).unref)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_unref_143_comment =
  "C++ Interface:\n"
  "unref(GeomVertexArrayFormat self)\n"
  "\n"
  "/**\n"
  " * This method overrides ReferenceCount::unref() to unregister the object when\n"
  " * its reference count goes to zero.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_unref_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexArrayFormat::is_registered(void) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_is_registered_144(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexArrayFormat::is_registered(void) const
  bool return_value = ((*(const GeomVertexArrayFormat*)local_this).is_registered)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_is_registered_144_comment =
  "C++ Interface:\n"
  "is_registered(GeomVertexArrayFormat self)\n"
  "\n"
  "/**\n"
  " * Returns true if this format has been registered, false if it has not.  It\n"
  " * may not be used for a Geom until it has been registered, but once\n"
  " * registered, it may no longer be modified.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_is_registered_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< GeomVertexArrayFormat > GeomVertexArrayFormat::register_format(GeomVertexArrayFormat const *format)
 */
static PyObject *Dtool_GeomVertexArrayFormat_register_format_145(PyObject *, PyObject *arg) {
  // 1-static inline ConstPointerTo< GeomVertexArrayFormat > GeomVertexArrayFormat::register_format(GeomVertexArrayFormat const *format)
  CPT(GeomVertexArrayFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexArrayFormat(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "GeomVertexArrayFormat.register_format", "GeomVertexArrayFormat");
  }
  ConstPointerTo< GeomVertexArrayFormat > return_value = (GeomVertexArrayFormat::register_format)(std::move(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomVertexArrayFormat const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayFormat, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_format(const GeomVertexArrayFormat format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_register_format_145_comment =
  "C++ Interface:\n"
  "register_format(const GeomVertexArrayFormat format)\n"
  "\n"
  "/**\n"
  " * Adds the indicated format to the registry, if there is not an equivalent\n"
  " * format already there; in either case, returns the pointer to the equivalent\n"
  " * format now in the registry.\n"
  " *\n"
  " * This is similar to GeomVertexFormat::register_format(), except that you\n"
  " * generally need not call it explicitly.  Calling\n"
  " * GeomVertexFormat::register_format() automatically registers all of the\n"
  " * nested array formats.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_register_format_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexArrayFormat::get_stride(void) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_get_stride_147(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-inline int GeomVertexArrayFormat::get_stride(void) const
  int return_value = ((*(const GeomVertexArrayFormat*)local_this).get_stride)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_get_stride_147_comment =
  "C++ Interface:\n"
  "get_stride(GeomVertexArrayFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes reserved in the array for each vertex.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_get_stride_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexArrayFormat::set_stride(int stride)
 */
static PyObject *Dtool_GeomVertexArrayFormat_set_stride_148(PyObject *self, PyObject *arg) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.set_stride")) {
    return nullptr;
  }
  // 1-inline void GeomVertexArrayFormat::set_stride(int stride)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_stride)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_stride(const GeomVertexArrayFormat self, int stride)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_set_stride_148_comment =
  "C++ Interface:\n"
  "set_stride(const GeomVertexArrayFormat self, int stride)\n"
  "\n"
  "/**\n"
  " * Changes the total number of bytes reserved in the array for each vertex.\n"
  " * You may not reduce this below get_total_bytes(), but you may increase it\n"
  " * arbitrarily.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_set_stride_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexArrayFormat::get_pad_to(void) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_get_pad_to_150(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-inline int GeomVertexArrayFormat::get_pad_to(void) const
  int return_value = ((*(const GeomVertexArrayFormat*)local_this).get_pad_to)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_get_pad_to_150_comment =
  "C++ Interface:\n"
  "get_pad_to(GeomVertexArrayFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the byte divisor to which the data record must be padded to meet\n"
  " * hardware limitations.  For instance, if this is 4, the stride will be\n"
  " * automatically rounded up to the next multiple of 4 bytes.  This value is\n"
  " * automatically increased as needed to ensure the individual numeric\n"
  " * components in the array are word-aligned.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_get_pad_to_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexArrayFormat::set_pad_to(int pad_to)
 */
static PyObject *Dtool_GeomVertexArrayFormat_set_pad_to_151(PyObject *self, PyObject *arg) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.set_pad_to")) {
    return nullptr;
  }
  // 1-inline void GeomVertexArrayFormat::set_pad_to(int pad_to)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_pad_to)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pad_to(const GeomVertexArrayFormat self, int pad_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_set_pad_to_151_comment =
  "C++ Interface:\n"
  "set_pad_to(const GeomVertexArrayFormat self, int pad_to)\n"
  "\n"
  "/**\n"
  " * Explicitly sets the byte divisor to which the data record must be padded to\n"
  " * meet hardware limitations.  See get_pad_to().  Normally it is not necessary\n"
  " * to call this unless you have some specific requirements for row-to-row data\n"
  " * alignment.  Note that this value may be automatically increased at each\n"
  " * subsequent call to add_column().\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_set_pad_to_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexArrayFormat::get_divisor(void) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_get_divisor_153(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-inline int GeomVertexArrayFormat::get_divisor(void) const
  int return_value = ((*(const GeomVertexArrayFormat*)local_this).get_divisor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_get_divisor_153_comment =
  "C++ Interface:\n"
  "get_divisor(GeomVertexArrayFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the divisor attribute for the data in this array.  If 0, it\n"
  " * contains per-vertex data.  If 1, it contains per-instance data.  If higher\n"
  " * than 1, the read row is advanced for each n instances.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_get_divisor_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexArrayFormat::set_divisor(int divisor)
 */
static PyObject *Dtool_GeomVertexArrayFormat_set_divisor_154(PyObject *self, PyObject *arg) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.set_divisor")) {
    return nullptr;
  }
  // 1-inline void GeomVertexArrayFormat::set_divisor(int divisor)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_divisor)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_divisor(const GeomVertexArrayFormat self, int divisor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_set_divisor_154_comment =
  "C++ Interface:\n"
  "set_divisor(const GeomVertexArrayFormat self, int divisor)\n"
  "\n"
  "/**\n"
  " * Set this to 0 to indicate that this array contains per-vertex data, or to 1\n"
  " * to indicate that it contains per-instance data.  If higher than 1, the read\n"
  " * row is advanced for each n instances.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_set_divisor_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexArrayFormat::get_total_bytes(void) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_get_total_bytes_156(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-inline int GeomVertexArrayFormat::get_total_bytes(void) const
  int return_value = ((*(const GeomVertexArrayFormat*)local_this).get_total_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_get_total_bytes_156_comment =
  "C++ Interface:\n"
  "get_total_bytes(GeomVertexArrayFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes used by the data types within the format,\n"
  " * including gaps between elements.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_get_total_bytes_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomVertexArrayFormat::add_column(CPT_InternalName name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents, int start = -1, int column_alignment = 0)
 * int GeomVertexArrayFormat::add_column(GeomVertexColumn const &column)
 */
static PyObject *Dtool_GeomVertexArrayFormat_add_column_158(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.add_column")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "column")) {
        // 1-int GeomVertexArrayFormat::add_column(GeomVertexColumn const &column)
        GeomVertexColumn const *arg_this = (GeomVertexColumn *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexColumn, 1, "GeomVertexArrayFormat.add_column", true, true);
        if (arg_this != nullptr) {
          int return_value = ((*local_this).add_column)(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 4:
  case 5:
  case 6:
    {
      // 1-int GeomVertexArrayFormat::add_column(CPT_InternalName name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents, int start = -1, int column_alignment = 0)
      PyObject *param1;
      int param2;
      int param3;
      int param4;
      int param5 = -1;
      int param6 = 0;
      static const char *keyword_list[] = {"name", "num_components", "numeric_type", "contents", "start", "column_alignment", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiii|ii:add_column", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        CPT(InternalName) param1_this;
        if (!Dtool_ConstCoerce_InternalName(param1, param1_this)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "GeomVertexArrayFormat.add_column", "InternalName");
        }
        int return_value = ((*local_this).add_column)(std::move(param1_this), (int)param2, (GeomEnums::NumericType)param3, (GeomEnums::Contents)param4, (int)param5, (int)param6);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_column() takes 2, 5, 6 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_column(const GeomVertexArrayFormat self, const GeomVertexColumn column)\n"
      "add_column(const GeomVertexArrayFormat self, const InternalName name, int num_components, int numeric_type, int contents, int start, int column_alignment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_add_column_158_comment =
  "C++ Interface:\n"
  "add_column(const GeomVertexArrayFormat self, const GeomVertexColumn column)\n"
  "add_column(const GeomVertexArrayFormat self, const InternalName name, int num_components, int numeric_type, int contents, int start, int column_alignment)\n"
  "\n"
  "/**\n"
  " * Adds a new column to the specification.  This is a table of per-vertex\n"
  " * floating-point numbers such as \"vertex\" or \"normal\"; you must specify where\n"
  " * in each record the table starts, and how many components (dimensions) exist\n"
  " * per vertex.\n"
  " *\n"
  " * The return value is the index number of the new data type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new column to the specification.  This is a table of per-vertex\n"
  " * floating-point numbers such as \"vertex\" or \"normal\"; you must specify where\n"
  " * in each record the table starts, and how many components (dimensions) exist\n"
  " * per vertex.\n"
  " *\n"
  " * Adding a column with the same name as a previous type, or that overlaps\n"
  " * with one or more previous types, quietly removes the previous type(s).\n"
  " *\n"
  " * The return value is the index number of the new data type.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_add_column_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayFormat::remove_column(InternalName const *name)
 */
static PyObject *Dtool_GeomVertexArrayFormat_remove_column_159(PyObject *self, PyObject *arg) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.remove_column")) {
    return nullptr;
  }
  // 1-void GeomVertexArrayFormat::remove_column(InternalName const *name)
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexArrayFormat.remove_column", "InternalName");
  }
  ((*local_this).remove_column)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_column(const GeomVertexArrayFormat self, const InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_remove_column_159_comment =
  "C++ Interface:\n"
  "remove_column(const GeomVertexArrayFormat self, const InternalName name)\n"
  "\n"
  "/**\n"
  " * Removes the column with the indicated name, if any.  This leaves a gap in\n"
  " * the byte structure.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_remove_column_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayFormat::clear_columns(void)
 */
static PyObject *Dtool_GeomVertexArrayFormat_clear_columns_160(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.clear_columns")) {
    return nullptr;
  }
  // 1-void GeomVertexArrayFormat::clear_columns(void)
  ((*local_this).clear_columns)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_clear_columns_160_comment =
  "C++ Interface:\n"
  "clear_columns(const GeomVertexArrayFormat self)\n"
  "\n"
  "/**\n"
  " * Removes all columns previously added, sets the stride to zero, and prepares\n"
  " * to start over.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_clear_columns_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayFormat::pack_columns(void)
 */
static PyObject *Dtool_GeomVertexArrayFormat_pack_columns_161(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.pack_columns")) {
    return nullptr;
  }
  // 1-void GeomVertexArrayFormat::pack_columns(void)
  ((*local_this).pack_columns)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_pack_columns_161_comment =
  "C++ Interface:\n"
  "pack_columns(const GeomVertexArrayFormat self)\n"
  "\n"
  "/**\n"
  " * Removes wasted space between columns.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_pack_columns_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayFormat::align_columns_for_animation(void)
 */
static PyObject *Dtool_GeomVertexArrayFormat_align_columns_for_animation_162(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.align_columns_for_animation")) {
    return nullptr;
  }
  // 1-void GeomVertexArrayFormat::align_columns_for_animation(void)
  ((*local_this).align_columns_for_animation)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_align_columns_for_animation_162_comment =
  "C++ Interface:\n"
  "align_columns_for_animation(const GeomVertexArrayFormat self)\n"
  "\n"
  "/**\n"
  " * Reprocesses the columns in the format to align the C_point and C_vector\n"
  " * columns to 16-byte boundaries to allow for the more efficient SSE2\n"
  " * operations (assuming SSE2 is enabled in the build).\n"
  " *\n"
  " * The caller is responsible for testing vertex_animation_align_16 to decide\n"
  " * whether to call this method.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_align_columns_for_animation_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexArrayFormat::get_num_columns(void) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_get_num_columns_163(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-inline int GeomVertexArrayFormat::get_num_columns(void) const
  int return_value = ((*(const GeomVertexArrayFormat*)local_this).get_num_columns)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_get_num_columns_163_comment =
  "C++ Interface:\n"
  "get_num_columns(GeomVertexArrayFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the number of different columns in the array.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_get_num_columns_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomVertexColumn const *GeomVertexArrayFormat::get_column(InternalName const *name) const
 * inline GeomVertexColumn const *GeomVertexArrayFormat::get_column(int i) const
 * GeomVertexColumn const *GeomVertexArrayFormat::get_column(int start_byte, int num_bytes) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_get_column_164(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 GeomVertexColumn const *GeomVertexArrayFormat::get_column(InternalName const *name) const
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "name")) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          if (param1_this != nullptr) {
            GeomVertexColumn const *return_value = ((*(const GeomVertexArrayFormat*)local_this).get_column)(param1_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
          }
        }
      }

      {
        // -2 inline GeomVertexColumn const *GeomVertexArrayFormat::get_column(int i) const
        int param1;
        static const char *keyword_list[] = {"i", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:get_column", (char **)keyword_list, &param1)) {
          GeomVertexColumn const *return_value = ((*(const GeomVertexArrayFormat*)local_this).get_column)((int)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
        }
        PyErr_Clear();
      }

      {
        // -2 GeomVertexColumn const *GeomVertexArrayFormat::get_column(InternalName const *name) const
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "name")) {
          CPT(InternalName) param1_this;
          if (Dtool_ConstCoerce_InternalName(param1, param1_this)) {
            GeomVertexColumn const *return_value = ((*(const GeomVertexArrayFormat*)local_this).get_column)(std::move(param1_this));
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
          }
        }
      }

      // No coercion possible: inline GeomVertexColumn const *GeomVertexArrayFormat::get_column(int i) const
    }
    break;
  case 2:
    {
      // 1-GeomVertexColumn const *GeomVertexArrayFormat::get_column(int start_byte, int num_bytes) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"start_byte", "num_bytes", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_column", (char **)keyword_list, &param1, &param2)) {
        GeomVertexColumn const *return_value = ((*(const GeomVertexArrayFormat*)local_this).get_column)((int)param1, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_column() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_column(GeomVertexArrayFormat self, const InternalName name)\n"
      "get_column(GeomVertexArrayFormat self, int i)\n"
      "get_column(GeomVertexArrayFormat self, int start_byte, int num_bytes)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_get_column_164_comment =
  "C++ Interface:\n"
  "get_column(GeomVertexArrayFormat self, const InternalName name)\n"
  "get_column(GeomVertexArrayFormat self, int i)\n"
  "get_column(GeomVertexArrayFormat self, int start_byte, int num_bytes)\n"
  "\n"
  "/**\n"
  " * Returns the ith column of the array.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the specification with the indicated name, or NULL if the name is\n"
  " * not used.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the first specification that overlaps with any of the indicated\n"
  " * bytes in the range, or NULL if none do.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_get_column_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexArrayFormat::has_column(InternalName const *name) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_has_column_169(PyObject *self, PyObject *arg) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexArrayFormat::has_column(InternalName const *name) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexArrayFormat.has_column", "InternalName");
  }
  bool return_value = ((*(const GeomVertexArrayFormat*)local_this).has_column)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_column(GeomVertexArrayFormat self, const InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_has_column_169_comment =
  "C++ Interface:\n"
  "has_column(GeomVertexArrayFormat self, const InternalName name)\n"
  "\n"
  "/**\n"
  " * Returns true if the array has the named column, false otherwise.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_has_column_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GeomVertexArrayFormat::is_data_subset_of(GeomVertexArrayFormat const &other) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_is_data_subset_of_170(PyObject *self, PyObject *arg) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-bool GeomVertexArrayFormat::is_data_subset_of(GeomVertexArrayFormat const &other) const
  CPT(GeomVertexArrayFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexArrayFormat(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexArrayFormat.is_data_subset_of", "GeomVertexArrayFormat");
  }
  bool return_value = ((*(const GeomVertexArrayFormat*)local_this).is_data_subset_of)(*std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_data_subset_of(GeomVertexArrayFormat self, const GeomVertexArrayFormat other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_is_data_subset_of_170_comment =
  "C++ Interface:\n"
  "is_data_subset_of(GeomVertexArrayFormat self, const GeomVertexArrayFormat other)\n"
  "\n"
  "/**\n"
  " * Returns true if all of the fields in this array format are also present and\n"
  " * equivalent in the other array format, and in the same byte positions, and\n"
  " * the stride is the same.  That is, true if this format can share the same\n"
  " * data pointer as the other format (with possibly some unused gaps).\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_is_data_subset_of_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomVertexArrayFormat::count_unused_space(void) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_count_unused_space_171(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-int GeomVertexArrayFormat::count_unused_space(void) const
  int return_value = ((*(const GeomVertexArrayFormat*)local_this).count_unused_space)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_count_unused_space_171_comment =
  "C++ Interface:\n"
  "count_unused_space(GeomVertexArrayFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes per row that are not assigned to any column.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_count_unused_space_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayFormat::output(std::ostream &out) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_output_172(PyObject *self, PyObject *arg) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-void GeomVertexArrayFormat::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GeomVertexArrayFormat.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GeomVertexArrayFormat*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GeomVertexArrayFormat self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_output_172_comment =
  "C++ Interface:\n"
  "output(GeomVertexArrayFormat self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_output_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayFormat::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_write_173(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-void GeomVertexArrayFormat::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "GeomVertexArrayFormat.write", false, true);
    if (param1_this != nullptr) {
      ((*(const GeomVertexArrayFormat*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(GeomVertexArrayFormat self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_write_173_comment =
  "C++ Interface:\n"
  "write(GeomVertexArrayFormat self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_write_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayFormat::write_with_data(std::ostream &out, int indent_level, GeomVertexArrayData const *array_data) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_write_with_data_174(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-void GeomVertexArrayFormat::write_with_data(std::ostream &out, int indent_level, GeomVertexArrayData const *array_data) const
  PyObject *param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"out", "indent_level", "array_data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO:write_with_data", (char **)keyword_list, &param1, &param2, &param3)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "GeomVertexArrayFormat.write_with_data", false, true);
    GeomVertexArrayData const *param3_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_GeomVertexArrayData, 3, "GeomVertexArrayFormat.write_with_data", true, true);
    if (param1_this != nullptr && param3_this != nullptr) {
      ((*(const GeomVertexArrayFormat*)local_this).write_with_data)(*param1_this, (int)param2, param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_with_data(GeomVertexArrayFormat self, ostream out, int indent_level, const GeomVertexArrayData array_data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_write_with_data_174_comment =
  "C++ Interface:\n"
  "write_with_data(GeomVertexArrayFormat self, ostream out, int indent_level, const GeomVertexArrayData array_data)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_write_with_data_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string GeomVertexArrayFormat::get_format_string(bool pad = true) const
 */
static PyObject *Dtool_GeomVertexArrayFormat_get_format_string_175(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayFormat)) {
    return nullptr;
  }
  // 1-std::string GeomVertexArrayFormat::get_format_string(bool pad = true) const
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "pad")) {
    std::string return_value = ((*(const GeomVertexArrayFormat*)local_this).get_format_string)((PyObject_IsTrue(param1) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_format_string(GeomVertexArrayFormat self, bool pad)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_get_format_string_175_comment =
  "C++ Interface:\n"
  "get_format_string(GeomVertexArrayFormat self, bool pad)\n"
  "\n"
  "/**\n"
  " * Returns a string with format codes representing the exact memory layout of\n"
  " * the columns in memory, as understood by Python's struct module.  If pad is\n"
  " * true, extra padding bytes are added to the end as 'x' characters as needed.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayFormat_get_format_string_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeomVertexArrayFormat::get_class_type(void)
 */
static PyObject *Dtool_GeomVertexArrayFormat_get_class_type_176(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomVertexArrayFormat::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomVertexArrayFormat::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_get_class_type_176_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomVertexArrayFormat_get_class_type_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *GeomVertexArrayFormat::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_GeomVertexArrayFormat_upcast_to_TypedWritableReferenceCount_136(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.upcast_to_TypedWritableReferenceCount")) {
    return nullptr;
  }
  // 1-TypedWritableReferenceCount *GeomVertexArrayFormat::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_upcast_to_TypedWritableReferenceCount_136_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const GeomVertexArrayFormat self)\n"
  "\n"
  "upcast from GeomVertexArrayFormat to TypedWritableReferenceCount";
#else
static const char *Dtool_GeomVertexArrayFormat_upcast_to_TypedWritableReferenceCount_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomEnums *GeomVertexArrayFormat::upcast_to_GeomEnums(void)
 */
static PyObject *Dtool_GeomVertexArrayFormat_upcast_to_GeomEnums_138(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.upcast_to_GeomEnums")) {
    return nullptr;
  }
  // 1-GeomEnums *GeomVertexArrayFormat::upcast_to_GeomEnums(void)
  GeomEnums *return_value = (GeomEnums *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomEnums, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayFormat_upcast_to_GeomEnums_138_comment =
  "C++ Interface:\n"
  "upcast_to_GeomEnums(const GeomVertexArrayFormat self)\n"
  "\n"
  "upcast from GeomVertexArrayFormat to GeomEnums";
#else
static const char *Dtool_GeomVertexArrayFormat_upcast_to_GeomEnums_138_comment = nullptr;
#endif

static PyObject *Dtool_GeomVertexArrayFormat_registered_Getter(PyObject *self, void *) {
  const GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayFormat, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GeomVertexArrayFormat::is_registered(void) const
  bool return_value = ((*(const GeomVertexArrayFormat*)local_this).is_registered)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomVertexArrayFormat_stride_Getter(PyObject *self, void *) {
  const GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayFormat, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GeomVertexArrayFormat::get_stride(void) const
  int return_value = ((*(const GeomVertexArrayFormat*)local_this).get_stride)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GeomVertexArrayFormat_stride_Setter(PyObject *self, PyObject *arg, void *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.stride")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete stride attribute");
    return -1;
  }
  // 1-inline void GeomVertexArrayFormat::set_stride(int stride)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_stride)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_stride(const GeomVertexArrayFormat self, int stride)\n");
  }
  return -1;
}

static PyObject *Dtool_GeomVertexArrayFormat_pad_to_Getter(PyObject *self, void *) {
  const GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayFormat, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GeomVertexArrayFormat::get_pad_to(void) const
  int return_value = ((*(const GeomVertexArrayFormat*)local_this).get_pad_to)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GeomVertexArrayFormat_pad_to_Setter(PyObject *self, PyObject *arg, void *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.pad_to")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete pad_to attribute");
    return -1;
  }
  // 1-inline void GeomVertexArrayFormat::set_pad_to(int pad_to)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_pad_to)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pad_to(const GeomVertexArrayFormat self, int pad_to)\n");
  }
  return -1;
}

static PyObject *Dtool_GeomVertexArrayFormat_divisor_Getter(PyObject *self, void *) {
  const GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayFormat, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GeomVertexArrayFormat::get_divisor(void) const
  int return_value = ((*(const GeomVertexArrayFormat*)local_this).get_divisor)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GeomVertexArrayFormat_divisor_Setter(PyObject *self, PyObject *arg, void *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayFormat, (void **)&local_this, "GeomVertexArrayFormat.divisor")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete divisor attribute");
    return -1;
  }
  // 1-inline void GeomVertexArrayFormat::set_divisor(int divisor)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_divisor)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_divisor(const GeomVertexArrayFormat self, int divisor)\n");
  }
  return -1;
}

static PyObject *Dtool_GeomVertexArrayFormat_total_bytes_Getter(PyObject *self, void *) {
  const GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayFormat, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GeomVertexArrayFormat::get_total_bytes(void) const
  int return_value = ((*(const GeomVertexArrayFormat*)local_this).get_total_bytes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property GeomVertexArrayFormat::columns
 */
static Py_ssize_t Dtool_GeomVertexArrayFormat_columns_Len(PyObject *self) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayFormat, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_columns)();
}

/**
 * sequence getter for property GeomVertexArrayFormat::columns
 */
static PyObject *Dtool_GeomVertexArrayFormat_columns_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayFormat, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_columns)()) {
    PyErr_SetString(PyExc_IndexError, "GeomVertexArrayFormat.columns[] index out of range");
    return nullptr;
  }
  // 1-inline GeomVertexColumn const *GeomVertexArrayFormat::get_column(int i) const
  GeomVertexColumn const *return_value = ((*(const GeomVertexArrayFormat*)local_this).get_column)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_column(GeomVertexArrayFormat self, index)\n");
  }
}

static PyObject *Dtool_GeomVertexArrayFormat_columns_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "GeomVertexArrayFormat.columns");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_GeomVertexArrayFormat_columns_Len;
    wrap->_getitem_func = &Dtool_GeomVertexArrayFormat_columns_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * GeomVertexArrayFormat::GeomVertexArrayFormat(void)
 * GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0)
 * GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1)
 * GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2)
 * GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2, CPT_InternalName name3, int num_components3, GeomEnums::NumericType numeric_type3, GeomEnums::Contents contents3)
 * GeomVertexArrayFormat::GeomVertexArrayFormat(GeomVertexArrayFormat const &copy)
 */
static int Dtool_Init_GeomVertexArrayFormat(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(void)
      GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexArrayFormat, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(GeomVertexArrayFormat const &copy)
        CPT(GeomVertexArrayFormat) arg_this;
        if (!Dtool_ConstCoerce_GeomVertexArrayFormat(arg, arg_this)) {
          Dtool_Raise_ArgTypeError(arg, 0, "GeomVertexArrayFormat.GeomVertexArrayFormat", "GeomVertexArrayFormat");
          return -1;
        }
        GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(*std::move(arg_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexArrayFormat, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0)
      PyObject *param0;
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"name0", "num_components0", "numeric_type0", "contents0", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiii:GeomVertexArrayFormat", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        CPT(InternalName) param0_this;
        if (!Dtool_ConstCoerce_InternalName(param0, param0_this)) {
          Dtool_Raise_ArgTypeError(param0, 0, "GeomVertexArrayFormat.GeomVertexArrayFormat", "InternalName");
          return -1;
        }
        GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(std::move(param0_this), (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexArrayFormat, true, false);
      }
    }
    break;
  case 8:
    {
      // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1)
      PyObject *param0;
      int param1;
      int param2;
      int param3;
      PyObject *param4;
      int param5;
      int param6;
      int param7;
      static const char *keyword_list[] = {"name0", "num_components0", "numeric_type0", "contents0", "name1", "num_components1", "numeric_type1", "contents1", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OiiiOiii:GeomVertexArrayFormat", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        CPT(InternalName) param0_this;
        if (!Dtool_ConstCoerce_InternalName(param0, param0_this)) {
          Dtool_Raise_ArgTypeError(param0, 0, "GeomVertexArrayFormat.GeomVertexArrayFormat", "InternalName");
          return -1;
        }
        CPT(InternalName) param4_this;
        if (!Dtool_ConstCoerce_InternalName(param4, param4_this)) {
          Dtool_Raise_ArgTypeError(param4, 4, "GeomVertexArrayFormat.GeomVertexArrayFormat", "InternalName");
          return -1;
        }
        GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(std::move(param0_this), (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3, std::move(param4_this), (int)param5, (GeomEnums::NumericType)param6, (GeomEnums::Contents)param7);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexArrayFormat, true, false);
      }
    }
    break;
  case 12:
    {
      // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2)
      PyObject *param0;
      int param1;
      int param2;
      int param3;
      PyObject *param4;
      int param5;
      int param6;
      int param7;
      PyObject *param8;
      int param9;
      int param10;
      int param11;
      static const char *keyword_list[] = {"name0", "num_components0", "numeric_type0", "contents0", "name1", "num_components1", "numeric_type1", "contents1", "name2", "num_components2", "numeric_type2", "contents2", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OiiiOiiiOiii:GeomVertexArrayFormat", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11)) {
        CPT(InternalName) param0_this;
        if (!Dtool_ConstCoerce_InternalName(param0, param0_this)) {
          Dtool_Raise_ArgTypeError(param0, 0, "GeomVertexArrayFormat.GeomVertexArrayFormat", "InternalName");
          return -1;
        }
        CPT(InternalName) param4_this;
        if (!Dtool_ConstCoerce_InternalName(param4, param4_this)) {
          Dtool_Raise_ArgTypeError(param4, 4, "GeomVertexArrayFormat.GeomVertexArrayFormat", "InternalName");
          return -1;
        }
        CPT(InternalName) param8_this;
        if (!Dtool_ConstCoerce_InternalName(param8, param8_this)) {
          Dtool_Raise_ArgTypeError(param8, 8, "GeomVertexArrayFormat.GeomVertexArrayFormat", "InternalName");
          return -1;
        }
        GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(std::move(param0_this), (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3, std::move(param4_this), (int)param5, (GeomEnums::NumericType)param6, (GeomEnums::Contents)param7, std::move(param8_this), (int)param9, (GeomEnums::NumericType)param10, (GeomEnums::Contents)param11);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexArrayFormat, true, false);
      }
    }
    break;
  case 16:
    {
      // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2, CPT_InternalName name3, int num_components3, GeomEnums::NumericType numeric_type3, GeomEnums::Contents contents3)
      PyObject *param0;
      int param1;
      int param2;
      int param3;
      PyObject *param4;
      int param5;
      int param6;
      int param7;
      PyObject *param8;
      int param9;
      int param10;
      int param11;
      PyObject *param12;
      int param13;
      int param14;
      int param15;
      static const char *keyword_list[] = {"name0", "num_components0", "numeric_type0", "contents0", "name1", "num_components1", "numeric_type1", "contents1", "name2", "num_components2", "numeric_type2", "contents2", "name3", "num_components3", "numeric_type3", "contents3", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OiiiOiiiOiiiOiii:GeomVertexArrayFormat", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15)) {
        CPT(InternalName) param0_this;
        if (!Dtool_ConstCoerce_InternalName(param0, param0_this)) {
          Dtool_Raise_ArgTypeError(param0, 0, "GeomVertexArrayFormat.GeomVertexArrayFormat", "InternalName");
          return -1;
        }
        CPT(InternalName) param4_this;
        if (!Dtool_ConstCoerce_InternalName(param4, param4_this)) {
          Dtool_Raise_ArgTypeError(param4, 4, "GeomVertexArrayFormat.GeomVertexArrayFormat", "InternalName");
          return -1;
        }
        CPT(InternalName) param8_this;
        if (!Dtool_ConstCoerce_InternalName(param8, param8_this)) {
          Dtool_Raise_ArgTypeError(param8, 8, "GeomVertexArrayFormat.GeomVertexArrayFormat", "InternalName");
          return -1;
        }
        CPT(InternalName) param12_this;
        if (!Dtool_ConstCoerce_InternalName(param12, param12_this)) {
          Dtool_Raise_ArgTypeError(param12, 12, "GeomVertexArrayFormat.GeomVertexArrayFormat", "InternalName");
          return -1;
        }
        GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(std::move(param0_this), (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3, std::move(param4_this), (int)param5, (GeomEnums::NumericType)param6, (GeomEnums::Contents)param7, std::move(param8_this), (int)param9, (GeomEnums::NumericType)param10, (GeomEnums::Contents)param11, std::move(param12_this), (int)param13, (GeomEnums::NumericType)param14, (GeomEnums::Contents)param15);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexArrayFormat, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomVertexArrayFormat() takes 0, 1, 4, 8, 12 or 16 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomVertexArrayFormat()\n"
      "GeomVertexArrayFormat(const GeomVertexArrayFormat copy)\n"
      "GeomVertexArrayFormat(const InternalName name0, int num_components0, int numeric_type0, int contents0)\n"
      "GeomVertexArrayFormat(const InternalName name0, int num_components0, int numeric_type0, int contents0, const InternalName name1, int num_components1, int numeric_type1, int contents1)\n"
      "GeomVertexArrayFormat(const InternalName name0, int num_components0, int numeric_type0, int contents0, const InternalName name1, int num_components1, int numeric_type1, int contents1, const InternalName name2, int num_components2, int numeric_type2, int contents2)\n"
      "GeomVertexArrayFormat(const InternalName name0, int num_components0, int numeric_type0, int contents0, const InternalName name1, int num_components1, int numeric_type1, int contents1, const InternalName name2, int num_components2, int numeric_type2, int contents2, const InternalName name3, int num_components3, int numeric_type3, int contents3)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_GeomVertexArrayFormat(PyObject *args, CPT(GeomVertexArrayFormat) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_GeomVertexArrayFormat)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 4: {
        // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0)
        PyObject *param0;
        int param1;
        int param2;
        int param3;
        if (PyArg_ParseTuple(args, "Oiii:GeomVertexArrayFormat", &param0, &param1, &param2, &param3)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr) {
            GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(param0_this, (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 8: {
        // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1)
        PyObject *param0;
        int param1;
        int param2;
        int param3;
        PyObject *param4;
        int param5;
        int param6;
        int param7;
        if (PyArg_ParseTuple(args, "OiiiOiii:GeomVertexArrayFormat", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          InternalName const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr && param4_this != nullptr) {
            GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(param0_this, (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3, param4_this, (int)param5, (GeomEnums::NumericType)param6, (GeomEnums::Contents)param7);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 12: {
        // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2)
        PyObject *param0;
        int param1;
        int param2;
        int param3;
        PyObject *param4;
        int param5;
        int param6;
        int param7;
        PyObject *param8;
        int param9;
        int param10;
        int param11;
        if (PyArg_ParseTuple(args, "OiiiOiiiOiii:GeomVertexArrayFormat", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          InternalName const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_InternalName);
          InternalName const *param8_this = nullptr;
          DtoolInstance_GetPointer(param8, param8_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr && param4_this != nullptr && param8_this != nullptr) {
            GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(param0_this, (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3, param4_this, (int)param5, (GeomEnums::NumericType)param6, (GeomEnums::Contents)param7, param8_this, (int)param9, (GeomEnums::NumericType)param10, (GeomEnums::Contents)param11);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 16: {
        // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2, CPT_InternalName name3, int num_components3, GeomEnums::NumericType numeric_type3, GeomEnums::Contents contents3)
        PyObject *param0;
        int param1;
        int param2;
        int param3;
        PyObject *param4;
        int param5;
        int param6;
        int param7;
        PyObject *param8;
        int param9;
        int param10;
        int param11;
        PyObject *param12;
        int param13;
        int param14;
        int param15;
        if (PyArg_ParseTuple(args, "OiiiOiiiOiiiOiii:GeomVertexArrayFormat", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          InternalName const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_InternalName);
          InternalName const *param8_this = nullptr;
          DtoolInstance_GetPointer(param8, param8_this, *Dtool_Ptr_InternalName);
          InternalName const *param12_this = nullptr;
          DtoolInstance_GetPointer(param12, param12_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr && param4_this != nullptr && param8_this != nullptr && param12_this != nullptr) {
            GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(param0_this, (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3, param4_this, (int)param5, (GeomEnums::NumericType)param6, (GeomEnums::Contents)param7, param8_this, (int)param9, (GeomEnums::NumericType)param10, (GeomEnums::Contents)param11, param12_this, (int)param13, (GeomEnums::NumericType)param14, (GeomEnums::Contents)param15);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_GeomVertexArrayFormat(PyObject *args, PT(GeomVertexArrayFormat) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_GeomVertexArrayFormat)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 4: {
        // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0)
        PyObject *param0;
        int param1;
        int param2;
        int param3;
        if (PyArg_ParseTuple(args, "Oiii:GeomVertexArrayFormat", &param0, &param1, &param2, &param3)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr) {
            GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(param0_this, (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 8: {
        // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1)
        PyObject *param0;
        int param1;
        int param2;
        int param3;
        PyObject *param4;
        int param5;
        int param6;
        int param7;
        if (PyArg_ParseTuple(args, "OiiiOiii:GeomVertexArrayFormat", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          InternalName const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr && param4_this != nullptr) {
            GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(param0_this, (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3, param4_this, (int)param5, (GeomEnums::NumericType)param6, (GeomEnums::Contents)param7);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 12: {
        // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2)
        PyObject *param0;
        int param1;
        int param2;
        int param3;
        PyObject *param4;
        int param5;
        int param6;
        int param7;
        PyObject *param8;
        int param9;
        int param10;
        int param11;
        if (PyArg_ParseTuple(args, "OiiiOiiiOiii:GeomVertexArrayFormat", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          InternalName const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_InternalName);
          InternalName const *param8_this = nullptr;
          DtoolInstance_GetPointer(param8, param8_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr && param4_this != nullptr && param8_this != nullptr) {
            GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(param0_this, (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3, param4_this, (int)param5, (GeomEnums::NumericType)param6, (GeomEnums::Contents)param7, param8_this, (int)param9, (GeomEnums::NumericType)param10, (GeomEnums::Contents)param11);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 16: {
        // 1-GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2, CPT_InternalName name3, int num_components3, GeomEnums::NumericType numeric_type3, GeomEnums::Contents contents3)
        PyObject *param0;
        int param1;
        int param2;
        int param3;
        PyObject *param4;
        int param5;
        int param6;
        int param7;
        PyObject *param8;
        int param9;
        int param10;
        int param11;
        PyObject *param12;
        int param13;
        int param14;
        int param15;
        if (PyArg_ParseTuple(args, "OiiiOiiiOiiiOiii:GeomVertexArrayFormat", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15)) {
          InternalName const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_InternalName);
          InternalName const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_InternalName);
          InternalName const *param8_this = nullptr;
          DtoolInstance_GetPointer(param8, param8_this, *Dtool_Ptr_InternalName);
          InternalName const *param12_this = nullptr;
          DtoolInstance_GetPointer(param12, param12_this, *Dtool_Ptr_InternalName);
          if (param0_this != nullptr && param4_this != nullptr && param8_this != nullptr && param12_this != nullptr) {
            GeomVertexArrayFormat *return_value = new GeomVertexArrayFormat(param0_this, (int)param1, (GeomEnums::NumericType)param2, (GeomEnums::Contents)param3, param4_this, (int)param5, (GeomEnums::NumericType)param6, (GeomEnums::Contents)param7, param8_this, (int)param9, (GeomEnums::NumericType)param10, (GeomEnums::Contents)param11, param12_this, (int)param13, (GeomEnums::NumericType)param14, (GeomEnums::Contents)param15);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomVertexArrayFormat_get_columns(PyObject *self, PyObject *) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayFormat, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_columns)();
  PyTupleObject args;
  (void)PyObject_INIT_VAR((PyVarObject *)&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_GeomVertexArrayFormat_get_column_164(self, (PyObject *)&args, nullptr);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_GeomVertexArrayFormat(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomVertexArrayFormat) {
    printf("GeomVertexArrayFormat ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomVertexArrayFormat *local_this = (GeomVertexArrayFormat *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomVertexArrayFormat) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomVertexArrayFormat(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomVertexArrayFormat) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomVertexArrayFormat*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomVertexArrayFormat*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomVertexArrayFormat*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomVertexArrayFormat*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomVertexArrayFormat*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomVertexFormat
 */
/**
 * Python function wrapper for:
 * void GeomVertexFormat::operator =(GeomVertexFormat const &copy)
 */
static PyObject *Dtool_GeomVertexFormat_operator_183(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.assign")) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::operator =(GeomVertexFormat const &copy)
  CPT(GeomVertexFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexFormat(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexFormat.assign", "GeomVertexFormat");
  }
  ((*local_this).operator =)(*std::move(arg_this));
  GeomVertexFormat *return_value = local_this;
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GeomVertexFormat self, const GeomVertexFormat copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_operator_183_comment =
  "C++ Interface:\n"
  "assign(const GeomVertexFormat self, const GeomVertexFormat copy)\n";
#else
static const char *Dtool_GeomVertexFormat_operator_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool GeomVertexFormat::unref(void) const
 */
static PyObject *Dtool_GeomVertexFormat_unref_185(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-virtual bool GeomVertexFormat::unref(void) const
  bool return_value = ((*(const GeomVertexFormat*)local_this).unref)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_unref_185_comment =
  "C++ Interface:\n"
  "unref(GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * This method overrides ReferenceCount::unref() to unregister the object when\n"
  " * its reference count goes to zero.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_unref_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexFormat::is_registered(void) const
 */
static PyObject *Dtool_GeomVertexFormat_is_registered_186(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexFormat::is_registered(void) const
  bool return_value = ((*(const GeomVertexFormat*)local_this).is_registered)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_is_registered_186_comment =
  "C++ Interface:\n"
  "is_registered(GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Returns true if this format has been registered, false if it has not.  It\n"
  " * may not be used for a Geom until it has been registered, but once\n"
  " * registered, it may no longer be modified.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_is_registered_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< GeomVertexFormat > GeomVertexFormat::register_format(GeomVertexArrayFormat const *format)
 * static inline ConstPointerTo< GeomVertexFormat > GeomVertexFormat::register_format(GeomVertexFormat const *format)
 */
static PyObject *Dtool_GeomVertexFormat_register_format_187(PyObject *, PyObject *arg) {
  {
    // -2 static inline ConstPointerTo< GeomVertexFormat > GeomVertexFormat::register_format(GeomVertexArrayFormat const *format)
    GeomVertexArrayFormat const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GeomVertexArrayFormat);
    if (arg_this != nullptr) {
      ConstPointerTo< GeomVertexFormat > return_value = (GeomVertexFormat::register_format)(arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GeomVertexFormat const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexFormat, true, true);
    }
  }

  {
    // -2 static inline ConstPointerTo< GeomVertexFormat > GeomVertexFormat::register_format(GeomVertexFormat const *format)
    GeomVertexFormat const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GeomVertexFormat);
    if (arg_this != nullptr) {
      ConstPointerTo< GeomVertexFormat > return_value = (GeomVertexFormat::register_format)(arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GeomVertexFormat const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexFormat, true, true);
    }
  }

  {
    // -2 static inline ConstPointerTo< GeomVertexFormat > GeomVertexFormat::register_format(GeomVertexArrayFormat const *format)
    CPT(GeomVertexArrayFormat) arg_this;
    if (Dtool_ConstCoerce_GeomVertexArrayFormat(arg, arg_this)) {
      ConstPointerTo< GeomVertexFormat > return_value = (GeomVertexFormat::register_format)(std::move(arg_this));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GeomVertexFormat const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexFormat, true, true);
    }
  }

  {
    // -2 static inline ConstPointerTo< GeomVertexFormat > GeomVertexFormat::register_format(GeomVertexFormat const *format)
    CPT(GeomVertexFormat) arg_this;
    if (Dtool_ConstCoerce_GeomVertexFormat(arg, arg_this)) {
      ConstPointerTo< GeomVertexFormat > return_value = (GeomVertexFormat::register_format)(std::move(arg_this));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GeomVertexFormat const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexFormat, true, true);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_format(const GeomVertexArrayFormat format)\n"
      "register_format(const GeomVertexFormat format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_register_format_187_comment =
  "C++ Interface:\n"
  "register_format(const GeomVertexArrayFormat format)\n"
  "register_format(const GeomVertexFormat format)\n"
  "\n"
  "/**\n"
  " * Adds the indicated format to the registry, if there is not an equivalent\n"
  " * format already there; in either case, returns the pointer to the equivalent\n"
  " * format now in the registry.\n"
  " *\n"
  " * This must be called before a format may be used in a Geom.  After this\n"
  " * call, you should discard the original pointer you passed in (which may or\n"
  " * may not now be invalid) and let its reference count decrement normally; you\n"
  " * should use only the returned value from this point on.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of register_format() implicitly creates a one-array vertex\n"
  " * format from the array definition.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_register_format_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexAnimationSpec const &GeomVertexFormat::get_animation(void) const
 */
static PyObject *Dtool_GeomVertexFormat_get_animation_189(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline GeomVertexAnimationSpec const &GeomVertexFormat::get_animation(void) const
  GeomVertexAnimationSpec const *return_value = &(((*(const GeomVertexFormat*)local_this).get_animation)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexAnimationSpec, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_animation_189_comment =
  "C++ Interface:\n"
  "get_animation(GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the GeomVertexAnimationSpec that indicates how this format's\n"
  " * vertices are set up for animation.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_animation_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexFormat::set_animation(GeomVertexAnimationSpec const &animation)
 */
static PyObject *Dtool_GeomVertexFormat_set_animation_190(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.set_animation")) {
    return nullptr;
  }
  // 1-inline void GeomVertexFormat::set_animation(GeomVertexAnimationSpec const &animation)
  GeomVertexAnimationSpec const *arg_this = (GeomVertexAnimationSpec *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexAnimationSpec, 1, "GeomVertexFormat.set_animation", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_animation)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_animation(const GeomVertexFormat self, const GeomVertexAnimationSpec animation)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_set_animation_190_comment =
  "C++ Interface:\n"
  "set_animation(const GeomVertexFormat self, const GeomVertexAnimationSpec animation)\n"
  "\n"
  "/**\n"
  " * Resets the GeomVertexAnimationSpec that indicates how this format's\n"
  " * vertices are set up for animation.  You should also, of course, change the\n"
  " * columns in the tables accordingly.\n"
  " *\n"
  " * This may not be called once the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_set_animation_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomVertexFormat > GeomVertexFormat::get_post_animated_format(void) const
 */
static PyObject *Dtool_GeomVertexFormat_get_post_animated_format_193(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomVertexFormat > GeomVertexFormat::get_post_animated_format(void) const
  ConstPointerTo< GeomVertexFormat > return_value = ((*(const GeomVertexFormat*)local_this).get_post_animated_format)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomVertexFormat const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_post_animated_format_193_comment =
  "C++ Interface:\n"
  "get_post_animated_format(GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Returns a suitable vertex format for sending the animated vertices to the\n"
  " * graphics backend.  This is the same format as the source format, with the\n"
  " * CPU-animation data elements removed.\n"
  " *\n"
  " * This may only be called after the format has been registered.  The return\n"
  " * value will have been already registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_post_animated_format_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomVertexFormat > GeomVertexFormat::get_union_format(GeomVertexFormat const *other) const
 */
static PyObject *Dtool_GeomVertexFormat_get_union_format_194(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomVertexFormat > GeomVertexFormat::get_union_format(GeomVertexFormat const *other) const
  CPT(GeomVertexFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexFormat(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexFormat.get_union_format", "GeomVertexFormat");
  }
  ConstPointerTo< GeomVertexFormat > return_value = ((*(const GeomVertexFormat*)local_this).get_union_format)(std::move(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomVertexFormat const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexFormat, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_union_format(GeomVertexFormat self, const GeomVertexFormat other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_union_format_194_comment =
  "C++ Interface:\n"
  "get_union_format(GeomVertexFormat self, const GeomVertexFormat other)\n"
  "\n"
  "/**\n"
  " * Returns a new GeomVertexFormat that includes all of the columns defined in\n"
  " * either this GeomVertexFormat or the other one.  If any column is defined in\n"
  " * both formats with different sizes (for instance, texcoord2 vs.  texcoord3),\n"
  " * the new format will include the larger of the two definitions.\n"
  " *\n"
  " * This may only be called after both source formats have been registered.\n"
  " * The return value will also have been already registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_union_format_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t GeomVertexFormat::get_num_arrays(void) const
 */
static PyObject *Dtool_GeomVertexFormat_get_num_arrays_195(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline std::size_t GeomVertexFormat::get_num_arrays(void) const
  std::size_t return_value = ((*(const GeomVertexFormat*)local_this).get_num_arrays)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_num_arrays_195_comment =
  "C++ Interface:\n"
  "get_num_arrays(GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the number of individual arrays required by the format.  If the\n"
  " * array data is completely interleaved, this will be 1; if it is completely\n"
  " * parallel, this will be the same as the number of data types.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_num_arrays_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexArrayFormat const *GeomVertexFormat::get_array(std::size_t array) const
 */
static PyObject *Dtool_GeomVertexFormat_get_array_196(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline GeomVertexArrayFormat const *GeomVertexFormat::get_array(std::size_t array) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    GeomVertexArrayFormat const *return_value = ((*(const GeomVertexFormat*)local_this).get_array)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexArrayFormat, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_array(GeomVertexFormat self, int array)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_array_196_comment =
  "C++ Interface:\n"
  "get_array(GeomVertexFormat self, int array)\n"
  "\n"
  "/**\n"
  " * Returns the description of the nth array used by the format.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_array_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomVertexArrayFormat *GeomVertexFormat::modify_array(std::size_t array)
 */
static PyObject *Dtool_GeomVertexFormat_modify_array_198(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.modify_array")) {
    return nullptr;
  }
  // 1-GeomVertexArrayFormat *GeomVertexFormat::modify_array(std::size_t array)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    GeomVertexArrayFormat *return_value = ((*local_this).modify_array)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexArrayFormat, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_array(const GeomVertexFormat self, int array)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_modify_array_198_comment =
  "C++ Interface:\n"
  "modify_array(const GeomVertexFormat self, int array)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the indicated array.  This means\n"
  " * duplicating it if it is shared or registered.\n"
  " *\n"
  " * This may not be called once the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_modify_array_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::set_array(std::size_t array, GeomVertexArrayFormat const *format)
 */
static PyObject *Dtool_GeomVertexFormat_set_array_199(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.set_array")) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::set_array(std::size_t array, GeomVertexArrayFormat const *format)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"array", "format", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_array", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    CPT(GeomVertexArrayFormat) param2_this;
    if (!Dtool_ConstCoerce_GeomVertexArrayFormat(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "GeomVertexFormat.set_array", "GeomVertexArrayFormat");
    }
    ((*local_this).set_array)((std::size_t)param1, std::move(param2_this));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_array(const GeomVertexFormat self, int array, const GeomVertexArrayFormat format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_set_array_199_comment =
  "C++ Interface:\n"
  "set_array(const GeomVertexFormat self, int array, const GeomVertexArrayFormat format)\n"
  "\n"
  "/**\n"
  " * Replaces the definition of the indicated array.\n"
  " *\n"
  " * This may not be called once the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_set_array_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::remove_array(std::size_t array)
 */
static PyObject *Dtool_GeomVertexFormat_remove_array_200(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.remove_array")) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::remove_array(std::size_t array)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).remove_array)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_array(const GeomVertexFormat self, int array)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_remove_array_200_comment =
  "C++ Interface:\n"
  "remove_array(const GeomVertexFormat self, int array)\n"
  "\n"
  "/**\n"
  " * Removes the nth array from the format.\n"
  " *\n"
  " * This may not be called once the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_remove_array_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t GeomVertexFormat::add_array(GeomVertexArrayFormat const *array_format)
 */
static PyObject *Dtool_GeomVertexFormat_add_array_201(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.add_array")) {
    return nullptr;
  }
  // 1-std::size_t GeomVertexFormat::add_array(GeomVertexArrayFormat const *array_format)
  CPT(GeomVertexArrayFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexArrayFormat(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexFormat.add_array", "GeomVertexArrayFormat");
  }
  std::size_t return_value = ((*local_this).add_array)(std::move(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_array(const GeomVertexFormat self, const GeomVertexArrayFormat array_format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_add_array_201_comment =
  "C++ Interface:\n"
  "add_array(const GeomVertexFormat self, const GeomVertexArrayFormat array_format)\n"
  "\n"
  "/**\n"
  " * Adds the indicated array definition to the list of arrays included within\n"
  " * this vertex format definition.  The return value is the index number of the\n"
  " * new array.\n"
  " *\n"
  " * This may not be called once the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_add_array_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::insert_array(std::size_t array, GeomVertexArrayFormat const *array_format)
 */
static PyObject *Dtool_GeomVertexFormat_insert_array_202(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.insert_array")) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::insert_array(std::size_t array, GeomVertexArrayFormat const *array_format)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"array", "array_format", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:insert_array", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    CPT(GeomVertexArrayFormat) param2_this;
    if (!Dtool_ConstCoerce_GeomVertexArrayFormat(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "GeomVertexFormat.insert_array", "GeomVertexArrayFormat");
    }
    ((*local_this).insert_array)((std::size_t)param1, std::move(param2_this));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_array(const GeomVertexFormat self, int array, const GeomVertexArrayFormat array_format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_insert_array_202_comment =
  "C++ Interface:\n"
  "insert_array(const GeomVertexFormat self, int array, const GeomVertexArrayFormat array_format)\n"
  "\n"
  "/**\n"
  " * Adds the indicated array definition to the list of arrays at the indicated\n"
  " * position.  This works just like add_array(), except that you can specify\n"
  " * which array index the new array should have.\n"
  " *\n"
  " * This may not be called once the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_insert_array_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::clear_arrays(void)
 */
static PyObject *Dtool_GeomVertexFormat_clear_arrays_203(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.clear_arrays")) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::clear_arrays(void)
  ((*local_this).clear_arrays)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_clear_arrays_203_comment =
  "C++ Interface:\n"
  "clear_arrays(const GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Removes all of the array definitions from the format and starts over.\n"
  " *\n"
  " * This may not be called once the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_clear_arrays_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::remove_empty_arrays(void)
 */
static PyObject *Dtool_GeomVertexFormat_remove_empty_arrays_204(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.remove_empty_arrays")) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::remove_empty_arrays(void)
  ((*local_this).remove_empty_arrays)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_remove_empty_arrays_204_comment =
  "C++ Interface:\n"
  "remove_empty_arrays(const GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Removes the arrays that define no columns.\n"
  " *\n"
  " * This may not be called once the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_remove_empty_arrays_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t GeomVertexFormat::get_num_columns(void) const
 */
static PyObject *Dtool_GeomVertexFormat_get_num_columns_205(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-std::size_t GeomVertexFormat::get_num_columns(void) const
  std::size_t return_value = ((*(const GeomVertexFormat*)local_this).get_num_columns)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_num_columns_205_comment =
  "C++ Interface:\n"
  "get_num_columns(GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of different columns in the specification, across\n"
  " * all arrays.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_num_columns_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomVertexFormat::get_array_with(InternalName const *name) const
 * int GeomVertexFormat::get_array_with(std::size_t i) const
 */
static PyObject *Dtool_GeomVertexFormat_get_array_with_206(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  {
    // -2 int GeomVertexFormat::get_array_with(InternalName const *name) const
    InternalName const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_InternalName);
    if (arg_this != nullptr) {
      int return_value = ((*(const GeomVertexFormat*)local_this).get_array_with)(arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 int GeomVertexFormat::get_array_with(std::size_t i) const
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      int return_value = ((*(const GeomVertexFormat*)local_this).get_array_with)(arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 int GeomVertexFormat::get_array_with(InternalName const *name) const
    CPT(InternalName) arg_this;
    if (Dtool_ConstCoerce_InternalName(arg, arg_this)) {
      int return_value = ((*(const GeomVertexFormat*)local_this).get_array_with)(std::move(arg_this));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: int GeomVertexFormat::get_array_with(std::size_t i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_array_with(GeomVertexFormat self, const InternalName name)\n"
      "get_array_with(GeomVertexFormat self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_array_with_206_comment =
  "C++ Interface:\n"
  "get_array_with(GeomVertexFormat self, const InternalName name)\n"
  "get_array_with(GeomVertexFormat self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the array with the ith column.\n"
  " *\n"
  " * The return value can be passed to get_array_format() to get the format of\n"
  " * the array.  It may also be passed to GeomVertexData::get_array_data() or\n"
  " * get_data() or set_data() to manipulate the actual array data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the index number of the array with the indicated column, or -1 if\n"
  " * no arrays contained that name.\n"
  " *\n"
  " * The return value can be passed to get_array_format() to get the format of\n"
  " * the array.  It may also be passed to GeomVertexData::get_array_data() or\n"
  " * get_data() or set_data() to manipulate the actual array data.\n"
  " *\n"
  " * This may only be called after the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_array_with_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomVertexColumn const *GeomVertexFormat::get_column(InternalName const *name) const
 * GeomVertexColumn const *GeomVertexFormat::get_column(std::size_t i) const
 */
static PyObject *Dtool_GeomVertexFormat_get_column_207(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  {
    // -2 GeomVertexColumn const *GeomVertexFormat::get_column(InternalName const *name) const
    InternalName const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_InternalName);
    if (arg_this != nullptr) {
      GeomVertexColumn const *return_value = ((*(const GeomVertexFormat*)local_this).get_column)(arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
    }
  }

  {
    // -2 GeomVertexColumn const *GeomVertexFormat::get_column(std::size_t i) const
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      GeomVertexColumn const *return_value = ((*(const GeomVertexFormat*)local_this).get_column)(arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
    }
  }

  {
    // -2 GeomVertexColumn const *GeomVertexFormat::get_column(InternalName const *name) const
    CPT(InternalName) arg_this;
    if (Dtool_ConstCoerce_InternalName(arg, arg_this)) {
      GeomVertexColumn const *return_value = ((*(const GeomVertexFormat*)local_this).get_column)(std::move(arg_this));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
    }
  }

  // No coercion possible: GeomVertexColumn const *GeomVertexFormat::get_column(std::size_t i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_column(GeomVertexFormat self, const InternalName name)\n"
      "get_column(GeomVertexFormat self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_column_207_comment =
  "C++ Interface:\n"
  "get_column(GeomVertexFormat self, const InternalName name)\n"
  "get_column(GeomVertexFormat self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the ith column of the specification, across all arrays.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the specification with the indicated name, or NULL if the name is\n"
  " * not used.  Use get_array_with() to determine which array this column is\n"
  " * associated with.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_column_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexFormat::has_column(InternalName const *name) const
 */
static PyObject *Dtool_GeomVertexFormat_has_column_208(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexFormat::has_column(InternalName const *name) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexFormat.has_column", "InternalName");
  }
  bool return_value = ((*(const GeomVertexFormat*)local_this).has_column)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_column(GeomVertexFormat self, const InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_has_column_208_comment =
  "C++ Interface:\n"
  "has_column(GeomVertexFormat self, const InternalName name)\n"
  "\n"
  "/**\n"
  " * Returns true if the format has the named column, false otherwise.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_has_column_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * InternalName const *GeomVertexFormat::get_column_name(std::size_t i) const
 */
static PyObject *Dtool_GeomVertexFormat_get_column_name_209(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-InternalName const *GeomVertexFormat::get_column_name(std::size_t i) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    InternalName const *return_value = ((*(const GeomVertexFormat*)local_this).get_column_name)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_column_name(GeomVertexFormat self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_column_name_209_comment =
  "C++ Interface:\n"
  "get_column_name(GeomVertexFormat self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the name of the ith column, across all arrays.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_column_name_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::remove_column(InternalName const *name, bool keep_empty_array = false)
 */
static PyObject *Dtool_GeomVertexFormat_remove_column_211(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.remove_column")) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::remove_column(InternalName const *name, bool keep_empty_array = false)
  PyObject *param1;
  PyObject *param2 = Py_False;
  static const char *keyword_list[] = {"name", "keep_empty_array", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:remove_column", (char **)keyword_list, &param1, &param2)) {
    CPT(InternalName) param1_this;
    if (!Dtool_ConstCoerce_InternalName(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GeomVertexFormat.remove_column", "InternalName");
    }
    ((*local_this).remove_column)(std::move(param1_this), (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_column(const GeomVertexFormat self, const InternalName name, bool keep_empty_array)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_remove_column_211_comment =
  "C++ Interface:\n"
  "remove_column(const GeomVertexFormat self, const InternalName name, bool keep_empty_array)\n"
  "\n"
  "/**\n"
  " * Removes the named column from the format, from whichever array it exists\n"
  " * in.  If there are other columns remaining in the array, the array is left\n"
  " * with a gap where the column used to be; if this was the only column in the\n"
  " * array, the array is removed (unless keep_empty_array is true).\n"
  " *\n"
  " * This may not be called once the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_remove_column_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::pack_columns(void)
 */
static PyObject *Dtool_GeomVertexFormat_pack_columns_212(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.pack_columns")) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::pack_columns(void)
  ((*local_this).pack_columns)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_pack_columns_212_comment =
  "C++ Interface:\n"
  "pack_columns(const GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Removes wasted space between columns.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_pack_columns_212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::align_columns_for_animation(void)
 */
static PyObject *Dtool_GeomVertexFormat_align_columns_for_animation_213(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.align_columns_for_animation")) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::align_columns_for_animation(void)
  ((*local_this).align_columns_for_animation)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_align_columns_for_animation_213_comment =
  "C++ Interface:\n"
  "align_columns_for_animation(const GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Reprocesses the columns in the format to align the C_point and C_vector\n"
  " * columns to 16-byte boundaries to allow for the more efficient SSE2\n"
  " * operations (assuming SSE2 is enabled in the build).\n"
  " *\n"
  " * Also see maybe_align_columns_for_animation().\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_align_columns_for_animation_213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::maybe_align_columns_for_animation(void)
 */
static PyObject *Dtool_GeomVertexFormat_maybe_align_columns_for_animation_214(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.maybe_align_columns_for_animation")) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::maybe_align_columns_for_animation(void)
  ((*local_this).maybe_align_columns_for_animation)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_maybe_align_columns_for_animation_214_comment =
  "C++ Interface:\n"
  "maybe_align_columns_for_animation(const GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Calls align_columns_for_animation() if this format's AnimationSpec\n"
  " * indicates that it contains animated vertices, and if vertex-animation-\n"
  " * align-16 is true.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_maybe_align_columns_for_animation_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t GeomVertexFormat::get_num_points(void) const
 */
static PyObject *Dtool_GeomVertexFormat_get_num_points_215(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline std::size_t GeomVertexFormat::get_num_points(void) const
  std::size_t return_value = ((*(const GeomVertexFormat*)local_this).get_num_points)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_num_points_215_comment =
  "C++ Interface:\n"
  "get_num_points(GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the number of columns within the format that represent points in\n"
  " * space.\n"
  " *\n"
  " * This may only be called after the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_num_points_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName const *GeomVertexFormat::get_point(std::size_t n) const
 */
static PyObject *Dtool_GeomVertexFormat_get_point_216(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline InternalName const *GeomVertexFormat::get_point(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    InternalName const *return_value = ((*(const GeomVertexFormat*)local_this).get_point)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(GeomVertexFormat self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_point_216_comment =
  "C++ Interface:\n"
  "get_point(GeomVertexFormat self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth point column.  This represents a point in\n"
  " * space, which should be transformed by any spatial transform matrix.\n"
  " *\n"
  " * This may only be called after the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_point_216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t GeomVertexFormat::get_num_vectors(void) const
 */
static PyObject *Dtool_GeomVertexFormat_get_num_vectors_218(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline std::size_t GeomVertexFormat::get_num_vectors(void) const
  std::size_t return_value = ((*(const GeomVertexFormat*)local_this).get_num_vectors)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_num_vectors_218_comment =
  "C++ Interface:\n"
  "get_num_vectors(GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the number of columns within the format that represent directional\n"
  " * vectors.\n"
  " *\n"
  " * This may only be called after the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_num_vectors_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName const *GeomVertexFormat::get_vector(std::size_t n) const
 */
static PyObject *Dtool_GeomVertexFormat_get_vector_219(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline InternalName const *GeomVertexFormat::get_vector(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    InternalName const *return_value = ((*(const GeomVertexFormat*)local_this).get_vector)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vector(GeomVertexFormat self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_vector_219_comment =
  "C++ Interface:\n"
  "get_vector(GeomVertexFormat self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth vector column.  This represents a directional\n"
  " * vector, which should be transformed by any spatial transform matrix as a\n"
  " * vector.\n"
  " *\n"
  " * This may only be called after the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_vector_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t GeomVertexFormat::get_num_texcoords(void) const
 */
static PyObject *Dtool_GeomVertexFormat_get_num_texcoords_221(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline std::size_t GeomVertexFormat::get_num_texcoords(void) const
  std::size_t return_value = ((*(const GeomVertexFormat*)local_this).get_num_texcoords)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_num_texcoords_221_comment =
  "C++ Interface:\n"
  "get_num_texcoords(GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the number of columns within the format that represent texture\n"
  " * coordinates.\n"
  " *\n"
  " * This may only be called after the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_num_texcoords_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName const *GeomVertexFormat::get_texcoord(std::size_t n) const
 */
static PyObject *Dtool_GeomVertexFormat_get_texcoord_222(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline InternalName const *GeomVertexFormat::get_texcoord(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    InternalName const *return_value = ((*(const GeomVertexFormat*)local_this).get_texcoord)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texcoord(GeomVertexFormat self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_texcoord_222_comment =
  "C++ Interface:\n"
  "get_texcoord(GeomVertexFormat self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth texcoord column.  This represents a texture\n"
  " * coordinate.\n"
  " *\n"
  " * This may only be called after the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_texcoord_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t GeomVertexFormat::get_num_morphs(void) const
 */
static PyObject *Dtool_GeomVertexFormat_get_num_morphs_224(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline std::size_t GeomVertexFormat::get_num_morphs(void) const
  std::size_t return_value = ((*(const GeomVertexFormat*)local_this).get_num_morphs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_num_morphs_224_comment =
  "C++ Interface:\n"
  "get_num_morphs(GeomVertexFormat self)\n"
  "\n"
  "/**\n"
  " * Returns the number of columns within the format that represent morph\n"
  " * deltas.\n"
  " *\n"
  " * This may only be called after the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_num_morphs_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName const *GeomVertexFormat::get_morph_slider(std::size_t n) const
 */
static PyObject *Dtool_GeomVertexFormat_get_morph_slider_225(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline InternalName const *GeomVertexFormat::get_morph_slider(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    InternalName const *return_value = ((*(const GeomVertexFormat*)local_this).get_morph_slider)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_morph_slider(GeomVertexFormat self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_morph_slider_225_comment =
  "C++ Interface:\n"
  "get_morph_slider(GeomVertexFormat self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the slider name associated with the nth morph column.  This is the\n"
  " * name of the slider that will control the morph, and should be defined\n"
  " * within the SliderTable associated with the GeomVertexData.\n"
  " *\n"
  " * This may only be called after the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_morph_slider_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName const *GeomVertexFormat::get_morph_base(std::size_t n) const
 */
static PyObject *Dtool_GeomVertexFormat_get_morph_base_226(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline InternalName const *GeomVertexFormat::get_morph_base(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    InternalName const *return_value = ((*(const GeomVertexFormat*)local_this).get_morph_base)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_morph_base(GeomVertexFormat self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_morph_base_226_comment =
  "C++ Interface:\n"
  "get_morph_base(GeomVertexFormat self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the base column that the nth morph modifies.  This\n"
  " * column will also be defined within the format, and can be retrieved via\n"
  " * get_array_with() and/or get_column().\n"
  " *\n"
  " * This may only be called after the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_morph_base_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName const *GeomVertexFormat::get_morph_delta(std::size_t n) const
 */
static PyObject *Dtool_GeomVertexFormat_get_morph_delta_227(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-inline InternalName const *GeomVertexFormat::get_morph_delta(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    InternalName const *return_value = ((*(const GeomVertexFormat*)local_this).get_morph_delta)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_morph_delta(GeomVertexFormat self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_morph_delta_227_comment =
  "C++ Interface:\n"
  "get_morph_delta(GeomVertexFormat self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the column that defines the nth morph.  This contains\n"
  " * the delta offsets that are to be applied to the column defined by\n"
  " * get_morph_base().  This column will be defined within the format, and can\n"
  " * be retrieved via get_array_with() and/or get_column().\n"
  " *\n"
  " * This may only be called after the format has been registered.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_morph_delta_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::output(std::ostream &out) const
 */
static PyObject *Dtool_GeomVertexFormat_output_239(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GeomVertexFormat.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GeomVertexFormat*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GeomVertexFormat self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_output_239_comment =
  "C++ Interface:\n"
  "output(GeomVertexFormat self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_output_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_GeomVertexFormat_write_240(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "GeomVertexFormat.write", false, true);
    if (param1_this != nullptr) {
      ((*(const GeomVertexFormat*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(GeomVertexFormat self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_write_240_comment =
  "C++ Interface:\n"
  "write(GeomVertexFormat self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_write_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexFormat::write_with_data(std::ostream &out, int indent_level, GeomVertexData const *data) const
 */
static PyObject *Dtool_GeomVertexFormat_write_with_data_241(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexFormat *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexFormat)) {
    return nullptr;
  }
  // 1-void GeomVertexFormat::write_with_data(std::ostream &out, int indent_level, GeomVertexData const *data) const
  PyObject *param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"out", "indent_level", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO:write_with_data", (char **)keyword_list, &param1, &param2, &param3)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "GeomVertexFormat.write_with_data", false, true);
    GeomVertexData const *param3_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_GeomVertexData, 3, "GeomVertexFormat.write_with_data", true, true);
    if (param1_this != nullptr && param3_this != nullptr) {
      ((*(const GeomVertexFormat*)local_this).write_with_data)(*param1_this, (int)param2, param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_with_data(GeomVertexFormat self, ostream out, int indent_level, const GeomVertexData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_write_with_data_241_comment =
  "C++ Interface:\n"
  "write_with_data(GeomVertexFormat self, ostream out, int indent_level, const GeomVertexData data)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_write_with_data_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_empty(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_empty_242(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_empty(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_empty)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_empty_242_comment =
  "C++ Interface:\n"
  "get_empty()\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format containing no arrays at all, useful for\n"
  " * pull-style vertex rendering.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_empty_242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3_243(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3_243_comment =
  "C++ Interface:\n"
  "get_v3()\n"
  "\n"
  "// Some standard vertex formats.  No particular requirement to use one of\n"
  "// these, but the DirectX renderers can use these formats directly, whereas\n"
  "// any other format will have to be converted first.\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with just a 3-component vertex position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3n3_244(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3n3)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3n3_244_comment =
  "C++ Interface:\n"
  "get_v3n3()\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with a 3-component normal and a\n"
  " * 3-component vertex position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3n3_244_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3t2(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3t2_245(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3t2(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3t2)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3t2_245_comment =
  "C++ Interface:\n"
  "get_v3t2()\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with a 2-component texture coordinate pair\n"
  " * and a 3-component vertex position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3t2_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3t2(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3n3t2_246(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3t2(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3n3t2)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3n3t2_246_comment =
  "C++ Interface:\n"
  "get_v3n3t2()\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with a 2-component texture coordinate\n"
  " * pair, a 3-component normal, and a 3-component vertex position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3n3t2_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3cp(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3cp_247(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3cp(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3cp)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3cp_247_comment =
  "C++ Interface:\n"
  "get_v3cp()\n"
  "\n"
  "// These formats, with the DirectX-style packed color, may not be supported\n"
  "// directly by OpenGL.  If you use them and the driver does not support\n"
  "// them, the GLGraphicsStateGuardian will automatically convert to native\n"
  "// OpenGL form (with a small runtime overhead).\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with a packed color and a 3-component\n"
  " * vertex position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3cp_247_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3cpt2(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3cpt2_248(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3cpt2(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3cpt2)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3cpt2_248_comment =
  "C++ Interface:\n"
  "get_v3cpt2()\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with a 2-component texture coordinate\n"
  " * pair, a packed color, and a 3-component vertex position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3cpt2_248_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3cp(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3n3cp_249(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3cp(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3n3cp)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3n3cp_249_comment =
  "C++ Interface:\n"
  "get_v3n3cp()\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with a packed color, a 3-component normal,\n"
  " * and a 3-component vertex position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3n3cp_249_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3cpt2(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3n3cpt2_250(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3cpt2(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3n3cpt2)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3n3cpt2_250_comment =
  "C++ Interface:\n"
  "get_v3n3cpt2()\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with a 2-component texture coordinate\n"
  " * pair, a packed color, a 3-component normal, and a 3-component vertex\n"
  " * position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3n3cpt2_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3c4(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3c4_251(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3c4(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3c4)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3c4_251_comment =
  "C++ Interface:\n"
  "get_v3c4()\n"
  "\n"
  "// These formats, with an OpenGL-style four-byte color, are not supported\n"
  "// directly by DirectX.  If you use them, the DXGraphicsStateGuardian will\n"
  "// automatically convert to DirectX form (with a larger runtime overhead,\n"
  "// since DirectX8, and old DirectX9 drivers, require everything to be\n"
  "// interleaved together).\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with a 4-component color and a 3-component\n"
  " * vertex position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3c4_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3c4t2(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3c4t2_252(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3c4t2(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3c4t2)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3c4t2_252_comment =
  "C++ Interface:\n"
  "get_v3c4t2()\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with a 2-component texture coordinate\n"
  " * pair, a 4-component color, and a 3-component vertex position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3c4t2_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3c4(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3n3c4_253(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3c4(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3n3c4)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3n3c4_253_comment =
  "C++ Interface:\n"
  "get_v3n3c4()\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with a 4-component color, a 3-component\n"
  " * normal, and a 3-component vertex position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3n3c4_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3c4t2(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_v3n3c4t2_254(PyObject *, PyObject *) {
  // 1-static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3c4t2(void)
  GeomVertexFormat const *return_value = (GeomVertexFormat::get_v3n3c4t2)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_v3n3c4t2_254_comment =
  "C++ Interface:\n"
  "get_v3n3c4t2()\n"
  "\n"
  "/**\n"
  " * Returns a standard vertex format with a 2-component texture coordinate\n"
  " * pair, a 4-component color, a 3-component normal, and a 3-component vertex\n"
  " * position.\n"
  " */";
#else
static const char *Dtool_GeomVertexFormat_get_v3n3c4t2_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeomVertexFormat::get_class_type(void)
 */
static PyObject *Dtool_GeomVertexFormat_get_class_type_255(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomVertexFormat::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomVertexFormat::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_get_class_type_255_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomVertexFormat_get_class_type_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *GeomVertexFormat::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_GeomVertexFormat_upcast_to_TypedWritableReferenceCount_178(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.upcast_to_TypedWritableReferenceCount")) {
    return nullptr;
  }
  // 1-TypedWritableReferenceCount *GeomVertexFormat::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_upcast_to_TypedWritableReferenceCount_178_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const GeomVertexFormat self)\n"
  "\n"
  "upcast from GeomVertexFormat to TypedWritableReferenceCount";
#else
static const char *Dtool_GeomVertexFormat_upcast_to_TypedWritableReferenceCount_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomEnums *GeomVertexFormat::upcast_to_GeomEnums(void)
 */
static PyObject *Dtool_GeomVertexFormat_upcast_to_GeomEnums_180(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.upcast_to_GeomEnums")) {
    return nullptr;
  }
  // 1-GeomEnums *GeomVertexFormat::upcast_to_GeomEnums(void)
  GeomEnums *return_value = (GeomEnums *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomEnums, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexFormat_upcast_to_GeomEnums_180_comment =
  "C++ Interface:\n"
  "upcast_to_GeomEnums(const GeomVertexFormat self)\n"
  "\n"
  "upcast from GeomVertexFormat to GeomEnums";
#else
static const char *Dtool_GeomVertexFormat_upcast_to_GeomEnums_180_comment = nullptr;
#endif

static PyObject *Dtool_GeomVertexFormat_registered_Getter(PyObject *self, void *) {
  const GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GeomVertexFormat::is_registered(void) const
  bool return_value = ((*(const GeomVertexFormat*)local_this).is_registered)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomVertexFormat_animation_Getter(PyObject *self, void *) {
  const GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomVertexAnimationSpec const &GeomVertexFormat::get_animation(void) const
  GeomVertexAnimationSpec const *return_value = &(((*(const GeomVertexFormat*)local_this).get_animation)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexAnimationSpec, false, true);
}

static int Dtool_GeomVertexFormat_animation_Setter(PyObject *self, PyObject *arg, void *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.animation")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete animation attribute");
    return -1;
  }
  // 1-inline void GeomVertexFormat::set_animation(GeomVertexAnimationSpec const &animation)
  GeomVertexAnimationSpec const *arg_this = (GeomVertexAnimationSpec *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexAnimationSpec, 1, "GeomVertexFormat.set_animation", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_animation)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_animation(const GeomVertexFormat self, const GeomVertexAnimationSpec animation)\n");
  }
  return -1;
}

/**
 * sequence length function for property GeomVertexFormat::arrays
 */
static Py_ssize_t Dtool_GeomVertexFormat_arrays_Len(PyObject *self) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_arrays)();
}

/**
 * sequence getter for property GeomVertexFormat::arrays
 */
static PyObject *Dtool_GeomVertexFormat_arrays_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_arrays)()) {
    PyErr_SetString(PyExc_IndexError, "GeomVertexFormat.arrays[] index out of range");
    return nullptr;
  }
  // 1-inline GeomVertexArrayFormat const *GeomVertexFormat::get_array(std::size_t array) const
  GeomVertexArrayFormat const *return_value = ((*(const GeomVertexFormat*)local_this).get_array)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexArrayFormat, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_array(GeomVertexFormat self, index)\n");
  }
}

static int Dtool_GeomVertexFormat_arrays_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.arrays")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_arrays)()) {
    PyErr_SetString(PyExc_IndexError, "GeomVertexFormat.arrays[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    local_this->remove_array(index);
    return 0;
  }
  // 1-void GeomVertexFormat::set_array(std::size_t array, GeomVertexArrayFormat const *format)
  CPT(GeomVertexArrayFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexArrayFormat(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 2, "GeomVertexFormat.set_array", "GeomVertexArrayFormat");
    return -1;
  }
  ((*local_this).set_array)(index, std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_array(const GeomVertexFormat self, index, const GeomVertexArrayFormat format)\n");
  }
  return -1;
}

static PyObject *Dtool_GeomVertexFormat_arrays_Sequence_insert(PyObject *self, size_t index, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexFormat, (void **)&local_this, "GeomVertexFormat.arrays")) {
    return nullptr;
  }

  // 1-void GeomVertexFormat::insert_array(std::size_t array, GeomVertexArrayFormat const *array_format)
  CPT(GeomVertexArrayFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexArrayFormat(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 2, "GeomVertexFormat.insert_array", "GeomVertexArrayFormat");
  }
  ((*local_this).insert_array)(index, std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(Py_None);
  return Py_None;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "insert_array(const GeomVertexFormat self, index, const GeomVertexArrayFormat array_format)\n");
  }
  return nullptr;
}

static PyObject *Dtool_GeomVertexFormat_arrays_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "GeomVertexFormat.arrays");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_GeomVertexFormat_arrays_Len;
    wrap->_getitem_func = &Dtool_GeomVertexFormat_arrays_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_GeomVertexFormat_arrays_Sequence_Setitem;
      wrap->_insert_func = &Dtool_GeomVertexFormat_arrays_Sequence_insert;
    }
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property GeomVertexFormat::points
 */
static Py_ssize_t Dtool_GeomVertexFormat_points_Len(PyObject *self) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_points)();
}

/**
 * sequence getter for property GeomVertexFormat::points
 */
static PyObject *Dtool_GeomVertexFormat_points_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_points)()) {
    PyErr_SetString(PyExc_IndexError, "GeomVertexFormat.points[] index out of range");
    return nullptr;
  }
  // 1-inline InternalName const *GeomVertexFormat::get_point(std::size_t n) const
  InternalName const *return_value = ((*(const GeomVertexFormat*)local_this).get_point)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(GeomVertexFormat self, index)\n");
  }
}

static PyObject *Dtool_GeomVertexFormat_points_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "GeomVertexFormat.points");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_GeomVertexFormat_points_Len;
    wrap->_getitem_func = &Dtool_GeomVertexFormat_points_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property GeomVertexFormat::vectors
 */
static Py_ssize_t Dtool_GeomVertexFormat_vectors_Len(PyObject *self) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_vectors)();
}

/**
 * sequence getter for property GeomVertexFormat::vectors
 */
static PyObject *Dtool_GeomVertexFormat_vectors_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_vectors)()) {
    PyErr_SetString(PyExc_IndexError, "GeomVertexFormat.vectors[] index out of range");
    return nullptr;
  }
  // 1-inline InternalName const *GeomVertexFormat::get_vector(std::size_t n) const
  InternalName const *return_value = ((*(const GeomVertexFormat*)local_this).get_vector)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vector(GeomVertexFormat self, index)\n");
  }
}

static PyObject *Dtool_GeomVertexFormat_vectors_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "GeomVertexFormat.vectors");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_GeomVertexFormat_vectors_Len;
    wrap->_getitem_func = &Dtool_GeomVertexFormat_vectors_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property GeomVertexFormat::columns
 */
static Py_ssize_t Dtool_GeomVertexFormat_columns_Len(PyObject *self) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_columns)();
}

/**
 * mapping getitem for property GeomVertexFormat::columns
 */
static PyObject *Dtool_GeomVertexFormat_columns_Mapping_Getitem(PyObject *self, PyObject *arg) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  {
    // 1-inline bool GeomVertexFormat::has_column(InternalName const *name) const
    CPT(InternalName) arg_this;
    if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
      Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexFormat.has_column", "InternalName");
      return nullptr;
    }
    bool return_value = ((*(const GeomVertexFormat*)local_this).has_column)(std::move(arg_this));
    if (!return_value) {
      PyErr_SetObject(PyExc_KeyError, arg);
      return nullptr;
    }
  }
  {
    // -2 GeomVertexColumn const *GeomVertexFormat::get_column(InternalName const *name) const
    InternalName const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_InternalName);
    if (arg_this != nullptr) {
      GeomVertexColumn const *return_value = ((*(const GeomVertexFormat*)local_this).get_column)(arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
    }
  }

  {
    // -2 GeomVertexColumn const *GeomVertexFormat::get_column(std::size_t i) const
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      GeomVertexColumn const *return_value = ((*(const GeomVertexFormat*)local_this).get_column)(arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
    }
  }

  {
    // -2 GeomVertexColumn const *GeomVertexFormat::get_column(InternalName const *name) const
    CPT(InternalName) arg_this;
    if (Dtool_ConstCoerce_InternalName(arg, arg_this)) {
      GeomVertexColumn const *return_value = ((*(const GeomVertexFormat*)local_this).get_column)(std::move(arg_this));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
    }
  }

  // No coercion possible: GeomVertexColumn const *GeomVertexFormat::get_column(std::size_t i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_column(GeomVertexFormat self, const InternalName name)\n"
      "get_column(GeomVertexFormat self, int i)\n");
  }
  return nullptr;
}

/**
 * mapping key-getter for property GeomVertexFormat::columns
 */
static PyObject *Dtool_GeomVertexFormat_columns_Mapping_Getkey(PyObject *self, Py_ssize_t index) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_columns)()) {
    PyErr_SetString(PyExc_IndexError, "GeomVertexFormat.columns[] index out of range");
    return nullptr;
  }
  // 1-InternalName const *GeomVertexFormat::get_column_name(std::size_t i) const
  InternalName const *return_value = ((*(const GeomVertexFormat*)local_this).get_column_name)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_column_name(GeomVertexFormat self, index)\n");
  }
}

static PyObject *Dtool_GeomVertexFormat_columns_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MappingWrapper *wrap = Dtool_NewMappingWrapper(self, "GeomVertexFormat.columns");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_GeomVertexFormat_columns_Mapping_Getitem;
    wrap->_keys._len_func = &Dtool_GeomVertexFormat_columns_Len;
    wrap->_keys._getitem_func = &Dtool_GeomVertexFormat_columns_Mapping_Getkey;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * GeomVertexFormat::GeomVertexFormat(void)
 * GeomVertexFormat::GeomVertexFormat(GeomVertexArrayFormat const *array_format)
 * GeomVertexFormat::GeomVertexFormat(GeomVertexFormat const &copy)
 */
static int Dtool_Init_GeomVertexFormat(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-GeomVertexFormat::GeomVertexFormat(void)
      GeomVertexFormat *return_value = new GeomVertexFormat();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexFormat, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 GeomVertexFormat::GeomVertexFormat(GeomVertexArrayFormat const *array_format)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "array_format")) {
          GeomVertexArrayFormat const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexArrayFormat);
          if (param0_this != nullptr) {
            GeomVertexFormat *return_value = new GeomVertexFormat(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexFormat, true, false);
          }
        }
      }

      {
        // -2 GeomVertexFormat::GeomVertexFormat(GeomVertexFormat const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          GeomVertexFormat const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexFormat);
          if (param0_this != nullptr) {
            GeomVertexFormat *return_value = new GeomVertexFormat(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexFormat, true, false);
          }
        }
      }

      {
        // -2 GeomVertexFormat::GeomVertexFormat(GeomVertexArrayFormat const *array_format)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "array_format")) {
          CPT(GeomVertexArrayFormat) param0_this;
          if (Dtool_ConstCoerce_GeomVertexArrayFormat(param0, param0_this)) {
            GeomVertexFormat *return_value = new GeomVertexFormat(std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexFormat, true, false);
          }
        }
      }

      {
        // -2 GeomVertexFormat::GeomVertexFormat(GeomVertexFormat const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          CPT(GeomVertexFormat) param0_this;
          if (Dtool_ConstCoerce_GeomVertexFormat(param0, param0_this)) {
            GeomVertexFormat *return_value = new GeomVertexFormat(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexFormat, true, false);
          }
        }
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomVertexFormat() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomVertexFormat()\n"
      "GeomVertexFormat(const GeomVertexArrayFormat array_format)\n"
      "GeomVertexFormat(const GeomVertexFormat copy)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_GeomVertexFormat(PyObject *args, CPT(GeomVertexFormat) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_GeomVertexFormat)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-GeomVertexFormat::GeomVertexFormat(GeomVertexArrayFormat const *array_format)
    GeomVertexArrayFormat const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GeomVertexArrayFormat);
    if (arg_this != nullptr) {
      GeomVertexFormat *return_value = new GeomVertexFormat(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_GeomVertexFormat(PyObject *args, PT(GeomVertexFormat) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_GeomVertexFormat)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-GeomVertexFormat::GeomVertexFormat(GeomVertexArrayFormat const *array_format)
    GeomVertexArrayFormat const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GeomVertexArrayFormat);
    if (arg_this != nullptr) {
      GeomVertexFormat *return_value = new GeomVertexFormat(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomVertexFormat_get_arrays(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_arrays)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomVertexFormat_get_array_196(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomVertexFormat_get_columns(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_columns)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomVertexFormat_get_column_207(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomVertexFormat_get_points(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_points)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomVertexFormat_get_point_216(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomVertexFormat_get_vectors(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_vectors)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomVertexFormat_get_vector_219(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomVertexFormat_get_texcoords(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_texcoords)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomVertexFormat_get_texcoord_222(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomVertexFormat_get_morph_sliders(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_morphs)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomVertexFormat_get_morph_slider_225(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomVertexFormat_get_morph_bases(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_morphs)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomVertexFormat_get_morph_base_226(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomVertexFormat_get_morph_deltas(PyObject *self, PyObject *) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_morphs)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomVertexFormat_get_morph_delta_227(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_GeomVertexFormat(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomVertexFormat) {
    printf("GeomVertexFormat ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomVertexFormat *local_this = (GeomVertexFormat *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomVertexFormat) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomVertexFormat(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomVertexFormat) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomVertexFormat*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomVertexFormat*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomVertexFormat*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomVertexFormat*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomVertexFormat*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SimpleLru
 */
/**
 * Python function wrapper for:
 * inline std::size_t SimpleLru::get_total_size(void) const
 */
static PyObject *Dtool_SimpleLru_get_total_size_264(PyObject *self, PyObject *) {
  SimpleLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleLru)) {
    return nullptr;
  }
  // 1-inline std::size_t SimpleLru::get_total_size(void) const
  std::size_t return_value = ((*(const SimpleLru*)local_this).get_total_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleLru_get_total_size_264_comment =
  "C++ Interface:\n"
  "get_total_size(SimpleLru self)\n"
  "\n"
  "/**\n"
  " * Returns the total size of all objects currently active on the LRU.\n"
  " */";
#else
static const char *Dtool_SimpleLru_get_total_size_264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SimpleLru::get_max_size(void) const
 */
static PyObject *Dtool_SimpleLru_get_max_size_265(PyObject *self, PyObject *) {
  SimpleLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleLru)) {
    return nullptr;
  }
  // 1-inline std::size_t SimpleLru::get_max_size(void) const
  std::size_t return_value = ((*(const SimpleLru*)local_this).get_max_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleLru_get_max_size_265_comment =
  "C++ Interface:\n"
  "get_max_size(SimpleLru self)\n"
  "\n"
  "/**\n"
  " * Returns the max size of all objects that are allowed to be active on the\n"
  " * LRU.\n"
  " */";
#else
static const char *Dtool_SimpleLru_get_max_size_265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SimpleLru::set_max_size(std::size_t max_size)
 */
static PyObject *Dtool_SimpleLru_set_max_size_266(PyObject *self, PyObject *arg) {
  SimpleLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleLru, (void **)&local_this, "SimpleLru.set_max_size")) {
    return nullptr;
  }
  // 1-inline void SimpleLru::set_max_size(std::size_t max_size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).set_max_size)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_size(const SimpleLru self, int max_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleLru_set_max_size_266_comment =
  "C++ Interface:\n"
  "set_max_size(const SimpleLru self, int max_size)\n"
  "\n"
  "/**\n"
  " * Changes the max size of all objects that are allowed to be active on the\n"
  " * LRU.\n"
  " *\n"
  " * If the size is (size_t)-1, there is no limit.\n"
  " */";
#else
static const char *Dtool_SimpleLru_set_max_size_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t SimpleLru::count_active_size(void) const
 */
static PyObject *Dtool_SimpleLru_count_active_size_267(PyObject *self, PyObject *) {
  SimpleLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleLru)) {
    return nullptr;
  }
  // 1-std::size_t SimpleLru::count_active_size(void) const
  std::size_t return_value = ((*(const SimpleLru*)local_this).count_active_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleLru_count_active_size_267_comment =
  "C++ Interface:\n"
  "count_active_size(SimpleLru self)\n"
  "\n"
  "/**\n"
  " * Returns the total size of the pages that were enqueued since the last call\n"
  " * to begin_epoch().\n"
  " */";
#else
static const char *Dtool_SimpleLru_count_active_size_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SimpleLru::consider_evict(void)
 */
static PyObject *Dtool_SimpleLru_consider_evict_268(PyObject *self, PyObject *) {
  SimpleLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleLru, (void **)&local_this, "SimpleLru.consider_evict")) {
    return nullptr;
  }
  // 1-inline void SimpleLru::consider_evict(void)
  ((*local_this).consider_evict)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SimpleLru_consider_evict_268_comment =
  "C++ Interface:\n"
  "consider_evict(const SimpleLru self)\n"
  "\n"
  "/**\n"
  " * Evicts a sequence of objects if the queue is full.\n"
  " */";
#else
static const char *Dtool_SimpleLru_consider_evict_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SimpleLru::evict_to(std::size_t target_size)
 */
static PyObject *Dtool_SimpleLru_evict_to_269(PyObject *self, PyObject *arg) {
  SimpleLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleLru, (void **)&local_this, "SimpleLru.evict_to")) {
    return nullptr;
  }
  // 1-inline void SimpleLru::evict_to(std::size_t target_size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).evict_to)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evict_to(const SimpleLru self, int target_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleLru_evict_to_269_comment =
  "C++ Interface:\n"
  "evict_to(const SimpleLru self, int target_size)\n"
  "\n"
  "/**\n"
  " * Evicts a sequence of objects until the queue fits within the indicated\n"
  " * target size, regardless of its normal max size.\n"
  " */";
#else
static const char *Dtool_SimpleLru_evict_to_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SimpleLru::begin_epoch(void)
 */
static PyObject *Dtool_SimpleLru_begin_epoch_270(PyObject *self, PyObject *) {
  SimpleLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleLru, (void **)&local_this, "SimpleLru.begin_epoch")) {
    return nullptr;
  }
  // 1-inline void SimpleLru::begin_epoch(void)
  ((*local_this).begin_epoch)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SimpleLru_begin_epoch_270_comment =
  "C++ Interface:\n"
  "begin_epoch(const SimpleLru self)\n"
  "\n"
  "/**\n"
  " * Marks the end of the previous epoch and the beginning of the next one.\n"
  " * This will evict any objects that are pending eviction, and also update any\n"
  " * internal bookkeeping.\n"
  " */";
#else
static const char *Dtool_SimpleLru_begin_epoch_270_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SimpleLru::validate(void)
 */
static PyObject *Dtool_SimpleLru_validate_271(PyObject *self, PyObject *) {
  SimpleLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleLru, (void **)&local_this, "SimpleLru.validate")) {
    return nullptr;
  }
  // 1-inline bool SimpleLru::validate(void)
  bool return_value = ((*local_this).validate)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleLru_validate_271_comment =
  "C++ Interface:\n"
  "validate(const SimpleLru self)\n"
  "\n"
  "/**\n"
  " * Checks that the LRU is internally self-consistent.  Returns true if\n"
  " * successful, false if there is some problem.\n"
  " */";
#else
static const char *Dtool_SimpleLru_validate_271_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SimpleLru::output(std::ostream &out) const
 */
static PyObject *Dtool_SimpleLru_output_272(PyObject *self, PyObject *arg) {
  SimpleLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleLru)) {
    return nullptr;
  }
  // 1-void SimpleLru::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "SimpleLru.output", false, true);
  if (arg_this != nullptr) {
    ((*(const SimpleLru*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(SimpleLru self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleLru_output_272_comment =
  "C++ Interface:\n"
  "output(SimpleLru self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SimpleLru_output_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SimpleLru::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_SimpleLru_write_273(PyObject *self, PyObject *args, PyObject *kwds) {
  SimpleLru *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleLru)) {
    return nullptr;
  }
  // 1-void SimpleLru::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "SimpleLru.write", false, true);
    if (param1_this != nullptr) {
      ((*(const SimpleLru*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(SimpleLru self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleLru_write_273_comment =
  "C++ Interface:\n"
  "write(SimpleLru self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SimpleLru_write_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *SimpleLru::upcast_to_Namable(void)
 */
static PyObject *Dtool_SimpleLru_upcast_to_Namable_260(PyObject *self, PyObject *) {
  SimpleLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleLru, (void **)&local_this, "SimpleLru.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *SimpleLru::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SimpleLru_upcast_to_Namable_260_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const SimpleLru self)\n"
  "\n"
  "upcast from SimpleLru to Namable";
#else
static const char *Dtool_SimpleLru_upcast_to_Namable_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit SimpleLru::SimpleLru(std::string const &name, std::size_t max_size)
 */
static int Dtool_Init_SimpleLru(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit SimpleLru::SimpleLru(std::string const &name, std::size_t max_size)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  Py_ssize_t param1;
  static const char *keyword_list[] = {"name", "max_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#n:SimpleLru", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      PyErr_Format(PyExc_OverflowError,
                   "can't convert negative value %zd to size_t",
                   param1);
      return -1;
    }
#endif
    SimpleLru *return_value = new SimpleLru(std::string(param0_str, param0_len), (std::size_t)param1);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SimpleLru, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SimpleLru(str name, int max_size)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SimpleLru(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SimpleLru) {
    printf("SimpleLru ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SimpleLru *local_this = (SimpleLru *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SimpleLru) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SimpleLru(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SimpleLru) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SimpleLru*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SimpleLruPage
 */
/**
 * Python function wrapper for:
 * inline void SimpleLruPage::operator =(SimpleLruPage const &copy)
 */
static PyObject *Dtool_SimpleLruPage_operator_278(PyObject *self, PyObject *arg) {
  SimpleLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleLruPage, (void **)&local_this, "SimpleLruPage.assign")) {
    return nullptr;
  }
  // 1-inline void SimpleLruPage::operator =(SimpleLruPage const &copy)
  SimpleLruPage const *arg_this = (SimpleLruPage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SimpleLruPage, 1, "SimpleLruPage.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    SimpleLruPage *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleLruPage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const SimpleLruPage self, const SimpleLruPage copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleLruPage_operator_278_comment =
  "C++ Interface:\n"
  "assign(const SimpleLruPage self, const SimpleLruPage copy)\n";
#else
static const char *Dtool_SimpleLruPage_operator_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SimpleLru *SimpleLruPage::get_lru(void) const
 */
static PyObject *Dtool_SimpleLruPage_get_lru_280(PyObject *self, PyObject *) {
  SimpleLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleLruPage)) {
    return nullptr;
  }
  // 1-inline SimpleLru *SimpleLruPage::get_lru(void) const
  SimpleLru *return_value = ((*(const SimpleLruPage*)local_this).get_lru)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleLru, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SimpleLruPage_get_lru_280_comment =
  "C++ Interface:\n"
  "get_lru(SimpleLruPage self)\n"
  "\n"
  "/**\n"
  " * Returns the LRU that manages this page, or NULL if it is not currently\n"
  " * managed by any LRU.\n"
  " */";
#else
static const char *Dtool_SimpleLruPage_get_lru_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SimpleLruPage::enqueue_lru(SimpleLru *lru)
 */
static PyObject *Dtool_SimpleLruPage_enqueue_lru_281(PyObject *self, PyObject *arg) {
  SimpleLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleLruPage, (void **)&local_this, "SimpleLruPage.enqueue_lru")) {
    return nullptr;
  }
  // 1-void SimpleLruPage::enqueue_lru(SimpleLru *lru)
  SimpleLru *arg_this = (SimpleLru *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SimpleLru, 1, "SimpleLruPage.enqueue_lru", false, true);
  if (arg_this != nullptr) {
    ((*local_this).enqueue_lru)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enqueue_lru(const SimpleLruPage self, SimpleLru lru)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleLruPage_enqueue_lru_281_comment =
  "C++ Interface:\n"
  "enqueue_lru(const SimpleLruPage self, SimpleLru lru)\n"
  "\n"
  "/**\n"
  " * Adds the page to the LRU for the first time, or marks it recently-accessed\n"
  " * if it has already been added.\n"
  " *\n"
  " * If lru is NULL, it means to remove this page from its LRU.\n"
  " */";
#else
static const char *Dtool_SimpleLruPage_enqueue_lru_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SimpleLruPage::dequeue_lru(void)
 */
static PyObject *Dtool_SimpleLruPage_dequeue_lru_282(PyObject *self, PyObject *) {
  SimpleLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleLruPage, (void **)&local_this, "SimpleLruPage.dequeue_lru")) {
    return nullptr;
  }
  // 1-inline void SimpleLruPage::dequeue_lru(void)
  ((*local_this).dequeue_lru)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SimpleLruPage_dequeue_lru_282_comment =
  "C++ Interface:\n"
  "dequeue_lru(const SimpleLruPage self)\n"
  "\n"
  "/**\n"
  " * Removes the page from its SimpleLru.\n"
  " */";
#else
static const char *Dtool_SimpleLruPage_dequeue_lru_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SimpleLruPage::mark_used_lru(void) const
 * inline void SimpleLruPage::mark_used_lru(SimpleLru *lru)
 */
static PyObject *Dtool_SimpleLruPage_mark_used_lru_283(PyObject *self, PyObject *args) {
  SimpleLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleLruPage)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void SimpleLruPage::mark_used_lru(void) const
      ((*(const SimpleLruPage*)local_this).mark_used_lru)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      if (!DtoolInstance_IS_CONST(self)) {
        // 1-inline void SimpleLruPage::mark_used_lru(SimpleLru *lru)
        SimpleLru *arg_this = (SimpleLru *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SimpleLru, 1, "SimpleLruPage.mark_used_lru", false, true);
        if (arg_this != nullptr) {
          ((*local_this).mark_used_lru)(arg_this);
          return Dtool_Return_None();
        }
      } else {
#ifdef NDEBUG
        return Dtool_Raise_TypeError("non-const method called on const object");
#else
        return Dtool_Raise_TypeError("Cannot call SimpleLruPage.mark_used_lru() on a const object.");
#endif
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "mark_used_lru() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mark_used_lru(SimpleLruPage self)\n"
      "mark_used_lru(const SimpleLruPage self, SimpleLru lru)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleLruPage_mark_used_lru_283_comment =
  "C++ Interface:\n"
  "mark_used_lru(SimpleLruPage self)\n"
  "mark_used_lru(const SimpleLruPage self, SimpleLru lru)\n"
  "\n"
  "/**\n"
  " * To be called when the page is used; this will move it to the tail of the\n"
  " * SimpleLru queue it is already on.\n"
  " *\n"
  " * This method is const because it's not technically modifying the contents of\n"
  " * the page itself.\n"
  " */\n"
  "\n"
  "/**\n"
  " * To be called when the page is used; this will move it to the tail of the\n"
  " * specified SimpleLru queue.\n"
  " */";
#else
static const char *Dtool_SimpleLruPage_mark_used_lru_283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SimpleLruPage::get_lru_size(void) const
 */
static PyObject *Dtool_SimpleLruPage_get_lru_size_284(PyObject *self, PyObject *) {
  SimpleLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleLruPage)) {
    return nullptr;
  }
  // 1-inline std::size_t SimpleLruPage::get_lru_size(void) const
  std::size_t return_value = ((*(const SimpleLruPage*)local_this).get_lru_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleLruPage_get_lru_size_284_comment =
  "C++ Interface:\n"
  "get_lru_size(SimpleLruPage self)\n"
  "\n"
  "/**\n"
  " * Returns the size of this page as reported to the LRU, presumably in bytes.\n"
  " */";
#else
static const char *Dtool_SimpleLruPage_get_lru_size_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SimpleLruPage::set_lru_size(std::size_t lru_size)
 */
static PyObject *Dtool_SimpleLruPage_set_lru_size_285(PyObject *self, PyObject *arg) {
  SimpleLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleLruPage, (void **)&local_this, "SimpleLruPage.set_lru_size")) {
    return nullptr;
  }
  // 1-inline void SimpleLruPage::set_lru_size(std::size_t lru_size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).set_lru_size)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lru_size(const SimpleLruPage self, int lru_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleLruPage_set_lru_size_285_comment =
  "C++ Interface:\n"
  "set_lru_size(const SimpleLruPage self, int lru_size)\n"
  "\n"
  "/**\n"
  " * Specifies the size of this page, presumably in bytes, although any unit is\n"
  " * possible.\n"
  " */";
#else
static const char *Dtool_SimpleLruPage_set_lru_size_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void SimpleLruPage::evict_lru(void)
 */
static PyObject *Dtool_SimpleLruPage_evict_lru_286(PyObject *self, PyObject *) {
  SimpleLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleLruPage, (void **)&local_this, "SimpleLruPage.evict_lru")) {
    return nullptr;
  }
  // 1-virtual void SimpleLruPage::evict_lru(void)
  ((*local_this).evict_lru)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SimpleLruPage_evict_lru_286_comment =
  "C++ Interface:\n"
  "evict_lru(const SimpleLruPage self)\n"
  "\n"
  "/**\n"
  " * Evicts the page from the LRU.  Called internally when the LRU determines\n"
  " * that it is full.  May also be called externally when necessary to\n"
  " * explicitly evict the page.\n"
  " *\n"
  " * It is legal for this method to either evict the page as requested, do\n"
  " * nothing (in which case the eviction will be requested again at the next\n"
  " * epoch), or requeue itself on the tail of the queue (in which case the\n"
  " * eviction will be requested again much later).\n"
  " */";
#else
static const char *Dtool_SimpleLruPage_evict_lru_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void SimpleLruPage::output(std::ostream &out) const
 */
static PyObject *Dtool_SimpleLruPage_output_287(PyObject *self, PyObject *arg) {
  SimpleLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleLruPage)) {
    return nullptr;
  }
  // 1-virtual void SimpleLruPage::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "SimpleLruPage.output", false, true);
  if (arg_this != nullptr) {
    ((*(const SimpleLruPage*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(SimpleLruPage self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleLruPage_output_287_comment =
  "C++ Interface:\n"
  "output(SimpleLruPage self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SimpleLruPage_output_287_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void SimpleLruPage::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_SimpleLruPage_write_288(PyObject *self, PyObject *args, PyObject *kwds) {
  SimpleLruPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleLruPage)) {
    return nullptr;
  }
  // 1-virtual void SimpleLruPage::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "SimpleLruPage.write", false, true);
    if (param1_this != nullptr) {
      ((*(const SimpleLruPage*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(SimpleLruPage self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleLruPage_write_288_comment =
  "C++ Interface:\n"
  "write(SimpleLruPage self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SimpleLruPage_write_288_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SimpleLruPage::SimpleLruPage(SimpleLruPage const &copy)
 * inline explicit SimpleLruPage::SimpleLruPage(std::size_t lru_size)
 */
static int Dtool_Init_SimpleLruPage(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SimpleLruPage() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline SimpleLruPage::SimpleLruPage(SimpleLruPage const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      SimpleLruPage const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_SimpleLruPage);
      if (param0_this != nullptr) {
        SimpleLruPage *return_value = new SimpleLruPage(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SimpleLruPage, true, false);
      }
    }
  }

  {
    // -2 inline explicit SimpleLruPage::SimpleLruPage(std::size_t lru_size)
    Py_ssize_t param0;
    static const char *keyword_list[] = {"lru_size", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "n:SimpleLruPage", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
      if (param0 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param0);
        return -1;
      }
#endif
      SimpleLruPage *return_value = new SimpleLruPage((std::size_t)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SimpleLruPage, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline SimpleLruPage::SimpleLruPage(SimpleLruPage const &copy)
  // No coercion possible: inline explicit SimpleLruPage::SimpleLruPage(std::size_t lru_size)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SimpleLruPage(const SimpleLruPage copy)\n"
      "SimpleLruPage(int lru_size)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SimpleLruPage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SimpleLruPage) {
    printf("SimpleLruPage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SimpleLruPage *local_this = (SimpleLruPage *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SimpleLruPage) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SimpleLruPage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SimpleLruPage) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SimpleAllocator
 */
/**
 * Python function wrapper for:
 * inline SimpleAllocatorBlock *SimpleAllocator::alloc(std::size_t size, std::size_t alignment = 1)
 */
static PyObject *Dtool_SimpleAllocator_alloc_294(PyObject *self, PyObject *args, PyObject *kwds) {
  SimpleAllocator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleAllocator, (void **)&local_this, "SimpleAllocator.alloc")) {
    return nullptr;
  }
  // 1-inline SimpleAllocatorBlock *SimpleAllocator::alloc(std::size_t size, std::size_t alignment = 1)
  Py_ssize_t param1;
  Py_ssize_t param2 = 1;
  static const char *keyword_list[] = {"size", "alignment", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "n|n:alloc", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    SimpleAllocatorBlock *return_value = ((*local_this).alloc)((std::size_t)param1, (std::size_t)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleAllocatorBlock, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "alloc(const SimpleAllocator self, int size, int alignment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocator_alloc_294_comment =
  "C++ Interface:\n"
  "alloc(const SimpleAllocator self, int size, int alignment)\n"
  "\n"
  "/**\n"
  " * Allocates a new block.  Returns NULL if a block of the requested size\n"
  " * cannot be allocated.\n"
  " *\n"
  " * To free the allocated block, call block->free(), or simply delete the block\n"
  " * pointer.\n"
  " */";
#else
static const char *Dtool_SimpleAllocator_alloc_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SimpleAllocator::is_empty(void) const
 */
static PyObject *Dtool_SimpleAllocator_is_empty_295(PyObject *self, PyObject *) {
  SimpleAllocator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocator)) {
    return nullptr;
  }
  // 1-inline bool SimpleAllocator::is_empty(void) const
  bool return_value = ((*(const SimpleAllocator*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocator_is_empty_295_comment =
  "C++ Interface:\n"
  "is_empty(SimpleAllocator self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are no blocks allocated on this page, or false if\n"
  " * there is at least one.\n"
  " */";
#else
static const char *Dtool_SimpleAllocator_is_empty_295_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SimpleAllocator::get_total_size(void) const
 */
static PyObject *Dtool_SimpleAllocator_get_total_size_296(PyObject *self, PyObject *) {
  SimpleAllocator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocator)) {
    return nullptr;
  }
  // 1-inline std::size_t SimpleAllocator::get_total_size(void) const
  std::size_t return_value = ((*(const SimpleAllocator*)local_this).get_total_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocator_get_total_size_296_comment =
  "C++ Interface:\n"
  "get_total_size(SimpleAllocator self)\n"
  "\n"
  "/**\n"
  " * Returns the total size of allocated objects.\n"
  " */";
#else
static const char *Dtool_SimpleAllocator_get_total_size_296_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SimpleAllocator::get_max_size(void) const
 */
static PyObject *Dtool_SimpleAllocator_get_max_size_297(PyObject *self, PyObject *) {
  SimpleAllocator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocator)) {
    return nullptr;
  }
  // 1-inline std::size_t SimpleAllocator::get_max_size(void) const
  std::size_t return_value = ((*(const SimpleAllocator*)local_this).get_max_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocator_get_max_size_297_comment =
  "C++ Interface:\n"
  "get_max_size(SimpleAllocator self)\n"
  "\n"
  "/**\n"
  " * Returns the available space for allocated objects.\n"
  " */";
#else
static const char *Dtool_SimpleAllocator_get_max_size_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SimpleAllocator::set_max_size(std::size_t max_size)
 */
static PyObject *Dtool_SimpleAllocator_set_max_size_298(PyObject *self, PyObject *arg) {
  SimpleAllocator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleAllocator, (void **)&local_this, "SimpleAllocator.set_max_size")) {
    return nullptr;
  }
  // 1-inline void SimpleAllocator::set_max_size(std::size_t max_size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).set_max_size)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_size(const SimpleAllocator self, int max_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocator_set_max_size_298_comment =
  "C++ Interface:\n"
  "set_max_size(const SimpleAllocator self, int max_size)\n"
  "\n"
  "/**\n"
  " * Changes the available space for allocated objects.  This will not affect\n"
  " * any already-allocated objects, but will have an effect on future calls to\n"
  " * alloc().\n"
  " */";
#else
static const char *Dtool_SimpleAllocator_set_max_size_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SimpleAllocator::get_contiguous(void) const
 */
static PyObject *Dtool_SimpleAllocator_get_contiguous_299(PyObject *self, PyObject *) {
  SimpleAllocator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocator)) {
    return nullptr;
  }
  // 1-inline std::size_t SimpleAllocator::get_contiguous(void) const
  std::size_t return_value = ((*(const SimpleAllocator*)local_this).get_contiguous)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocator_get_contiguous_299_comment =
  "C++ Interface:\n"
  "get_contiguous(SimpleAllocator self)\n"
  "\n"
  "/**\n"
  " * Returns an upper-bound estimate of the size of the largest contiguous block\n"
  " * that may be allocated.  It is guaranteed that an attempt to allocate a\n"
  " * block larger than this will fail, though it is not guaranteed that an\n"
  " * attempt to allocate a block this size or smaller will succeed.\n"
  " */";
#else
static const char *Dtool_SimpleAllocator_get_contiguous_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SimpleAllocatorBlock *SimpleAllocator::get_first_block(void) const
 */
static PyObject *Dtool_SimpleAllocator_get_first_block_300(PyObject *self, PyObject *) {
  SimpleAllocator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocator)) {
    return nullptr;
  }
  // 1-inline SimpleAllocatorBlock *SimpleAllocator::get_first_block(void) const
  SimpleAllocatorBlock *return_value = ((*(const SimpleAllocator*)local_this).get_first_block)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleAllocatorBlock, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocator_get_first_block_300_comment =
  "C++ Interface:\n"
  "get_first_block(SimpleAllocator self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the first allocated block, or NULL if there are no\n"
  " * allocated blocks.\n"
  " */";
#else
static const char *Dtool_SimpleAllocator_get_first_block_300_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SimpleAllocator::output(std::ostream &out) const
 */
static PyObject *Dtool_SimpleAllocator_output_301(PyObject *self, PyObject *arg) {
  SimpleAllocator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocator)) {
    return nullptr;
  }
  // 1-void SimpleAllocator::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "SimpleAllocator.output", false, true);
  if (arg_this != nullptr) {
    ((*(const SimpleAllocator*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(SimpleAllocator self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocator_output_301_comment =
  "C++ Interface:\n"
  "output(SimpleAllocator self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SimpleAllocator_output_301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SimpleAllocator::write(std::ostream &out) const
 */
static PyObject *Dtool_SimpleAllocator_write_302(PyObject *self, PyObject *arg) {
  SimpleAllocator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocator)) {
    return nullptr;
  }
  // 1-void SimpleAllocator::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "SimpleAllocator.write", false, true);
  if (arg_this != nullptr) {
    ((*(const SimpleAllocator*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(SimpleAllocator self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocator_write_302_comment =
  "C++ Interface:\n"
  "write(SimpleAllocator self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SimpleAllocator_write_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Rejected Remap [SimpleAllocator::SimpleAllocator(SimpleAllocator &&from) noexcept]
 * inline explicit SimpleAllocator::SimpleAllocator(std::size_t max_size, Mutex &lock)
 */
static int Dtool_Init_SimpleAllocator(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline explicit SimpleAllocator::SimpleAllocator(std::size_t max_size, Mutex &lock)
  Py_ssize_t param0;
  PyObject *param1;
  static const char *keyword_list[] = {"max_size", "lock", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:SimpleAllocator", (char **)keyword_list, &param0, &param1)) {
#ifndef NDEBUG
    if (param0 < 0) {
      PyErr_Format(PyExc_OverflowError,
                   "can't convert negative value %zd to size_t",
                   param0);
      return -1;
    }
#endif
    Mutex *param1_this = (Mutex *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Mutex, 1, "SimpleAllocator.SimpleAllocator", false, true);
    if (param1_this != nullptr) {
      SimpleAllocator *return_value = new SimpleAllocator((std::size_t)param0, *param1_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SimpleAllocator, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SimpleAllocator(int max_size, Mutex lock)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SimpleAllocator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SimpleAllocator) {
    printf("SimpleAllocator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SimpleAllocator *local_this = (SimpleAllocator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SimpleAllocator) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SimpleAllocator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SimpleAllocator) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SimpleAllocatorBlock
 */
/**
 * Python function wrapper for:
 * inline void SimpleAllocatorBlock::free(void)
 */
static PyObject *Dtool_SimpleAllocatorBlock_free_305(PyObject *self, PyObject *) {
  SimpleAllocatorBlock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleAllocatorBlock, (void **)&local_this, "SimpleAllocatorBlock.free")) {
    return nullptr;
  }
  // 1-inline void SimpleAllocatorBlock::free(void)
  ((*local_this).free)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocatorBlock_free_305_comment =
  "C++ Interface:\n"
  "free(const SimpleAllocatorBlock self)\n"
  "\n"
  "/**\n"
  " * Releases the allocated space.\n"
  " */";
#else
static const char *Dtool_SimpleAllocatorBlock_free_305_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SimpleAllocator *SimpleAllocatorBlock::get_allocator(void) const
 */
static PyObject *Dtool_SimpleAllocatorBlock_get_allocator_306(PyObject *self, PyObject *) {
  SimpleAllocatorBlock *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocatorBlock)) {
    return nullptr;
  }
  // 1-inline SimpleAllocator *SimpleAllocatorBlock::get_allocator(void) const
  SimpleAllocator *return_value = ((*(const SimpleAllocatorBlock*)local_this).get_allocator)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleAllocator, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocatorBlock_get_allocator_306_comment =
  "C++ Interface:\n"
  "get_allocator(SimpleAllocatorBlock self)\n"
  "\n"
  "/**\n"
  " * Returns the SimpleAllocator object that owns this block.  Returns NULL if\n"
  " * the block has been freed.\n"
  " */";
#else
static const char *Dtool_SimpleAllocatorBlock_get_allocator_306_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SimpleAllocatorBlock::get_start(void) const
 */
static PyObject *Dtool_SimpleAllocatorBlock_get_start_307(PyObject *self, PyObject *) {
  SimpleAllocatorBlock *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocatorBlock)) {
    return nullptr;
  }
  // 1-inline std::size_t SimpleAllocatorBlock::get_start(void) const
  std::size_t return_value = ((*(const SimpleAllocatorBlock*)local_this).get_start)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocatorBlock_get_start_307_comment =
  "C++ Interface:\n"
  "get_start(SimpleAllocatorBlock self)\n"
  "\n"
  "/**\n"
  " * Returns the starting point of this block.  It is an error to call this if\n"
  " * the block has been freed.\n"
  " */";
#else
static const char *Dtool_SimpleAllocatorBlock_get_start_307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SimpleAllocatorBlock::get_size(void) const
 */
static PyObject *Dtool_SimpleAllocatorBlock_get_size_308(PyObject *self, PyObject *) {
  SimpleAllocatorBlock *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocatorBlock)) {
    return nullptr;
  }
  // 1-inline std::size_t SimpleAllocatorBlock::get_size(void) const
  std::size_t return_value = ((*(const SimpleAllocatorBlock*)local_this).get_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocatorBlock_get_size_308_comment =
  "C++ Interface:\n"
  "get_size(SimpleAllocatorBlock self)\n"
  "\n"
  "/**\n"
  " * Returns the size of this block.  It is an error to call this if the block\n"
  " * has been freed.\n"
  " */";
#else
static const char *Dtool_SimpleAllocatorBlock_get_size_308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SimpleAllocatorBlock::is_free(void) const
 */
static PyObject *Dtool_SimpleAllocatorBlock_is_free_309(PyObject *self, PyObject *) {
  SimpleAllocatorBlock *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocatorBlock)) {
    return nullptr;
  }
  // 1-inline bool SimpleAllocatorBlock::is_free(void) const
  bool return_value = ((*(const SimpleAllocatorBlock*)local_this).is_free)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocatorBlock_is_free_309_comment =
  "C++ Interface:\n"
  "is_free(SimpleAllocatorBlock self)\n"
  "\n"
  "/**\n"
  " * Returns true if the block has been freed, false if it is still valid.\n"
  " */";
#else
static const char *Dtool_SimpleAllocatorBlock_is_free_309_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SimpleAllocatorBlock::get_max_size(void) const
 */
static PyObject *Dtool_SimpleAllocatorBlock_get_max_size_310(PyObject *self, PyObject *) {
  SimpleAllocatorBlock *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocatorBlock)) {
    return nullptr;
  }
  // 1-inline std::size_t SimpleAllocatorBlock::get_max_size(void) const
  std::size_t return_value = ((*(const SimpleAllocatorBlock*)local_this).get_max_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocatorBlock_get_max_size_310_comment =
  "C++ Interface:\n"
  "get_max_size(SimpleAllocatorBlock self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum size this block can be reallocated to, as limited by\n"
  " * the following block.\n"
  " */";
#else
static const char *Dtool_SimpleAllocatorBlock_get_max_size_310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SimpleAllocatorBlock::realloc(std::size_t size)
 */
static PyObject *Dtool_SimpleAllocatorBlock_realloc_311(PyObject *self, PyObject *arg) {
  SimpleAllocatorBlock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SimpleAllocatorBlock, (void **)&local_this, "SimpleAllocatorBlock.realloc")) {
    return nullptr;
  }
  // 1-inline bool SimpleAllocatorBlock::realloc(std::size_t size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*local_this).realloc)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "realloc(const SimpleAllocatorBlock self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocatorBlock_realloc_311_comment =
  "C++ Interface:\n"
  "realloc(const SimpleAllocatorBlock self, int size)\n"
  "\n"
  "/**\n"
  " * Changes the size of this block to the specified size.  Returns true if the\n"
  " * change is accepted, false if there was not enough room.\n"
  " */";
#else
static const char *Dtool_SimpleAllocatorBlock_realloc_311_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SimpleAllocatorBlock *SimpleAllocatorBlock::get_next_block(void) const
 */
static PyObject *Dtool_SimpleAllocatorBlock_get_next_block_312(PyObject *self, PyObject *) {
  SimpleAllocatorBlock *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocatorBlock)) {
    return nullptr;
  }
  // 1-inline SimpleAllocatorBlock *SimpleAllocatorBlock::get_next_block(void) const
  SimpleAllocatorBlock *return_value = ((*(const SimpleAllocatorBlock*)local_this).get_next_block)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleAllocatorBlock, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocatorBlock_get_next_block_312_comment =
  "C++ Interface:\n"
  "get_next_block(SimpleAllocatorBlock self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the next allocated block in the chain, or NULL if\n"
  " * there are no more allocated blocks.\n"
  " */";
#else
static const char *Dtool_SimpleAllocatorBlock_get_next_block_312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SimpleAllocatorBlock::output(std::ostream &out) const
 */
static PyObject *Dtool_SimpleAllocatorBlock_output_313(PyObject *self, PyObject *arg) {
  SimpleAllocatorBlock *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SimpleAllocatorBlock)) {
    return nullptr;
  }
  // 1-void SimpleAllocatorBlock::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "SimpleAllocatorBlock.output", false, true);
  if (arg_this != nullptr) {
    ((*(const SimpleAllocatorBlock*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(SimpleAllocatorBlock self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SimpleAllocatorBlock_output_313_comment =
  "C++ Interface:\n"
  "output(SimpleAllocatorBlock self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SimpleAllocatorBlock_output_313_comment = nullptr;
#endif

static int Dtool_Init_SimpleAllocatorBlock(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_SimpleAllocatorBlock(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SimpleAllocatorBlock) {
    printf("SimpleAllocatorBlock ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SimpleAllocatorBlock *local_this = (SimpleAllocatorBlock *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SimpleAllocatorBlock) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SimpleAllocatorBlock(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SimpleAllocatorBlock) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VertexDataSaveFile
 */
/**
 * Python function wrapper for:
 * inline bool VertexDataSaveFile::is_valid(void) const
 */
static PyObject *Dtool_VertexDataSaveFile_is_valid_315(PyObject *self, PyObject *) {
  VertexDataSaveFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataSaveFile)) {
    return nullptr;
  }
  // 1-inline bool VertexDataSaveFile::is_valid(void) const
  bool return_value = ((*(const VertexDataSaveFile*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataSaveFile_is_valid_315_comment =
  "C++ Interface:\n"
  "is_valid(VertexDataSaveFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the save file was successfully created and is ready for\n"
  " * use, false if there was an error.\n"
  " */";
#else
static const char *Dtool_VertexDataSaveFile_is_valid_315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t VertexDataSaveFile::get_total_file_size(void) const
 */
static PyObject *Dtool_VertexDataSaveFile_get_total_file_size_316(PyObject *self, PyObject *) {
  VertexDataSaveFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataSaveFile)) {
    return nullptr;
  }
  // 1-inline std::size_t VertexDataSaveFile::get_total_file_size(void) const
  std::size_t return_value = ((*(const VertexDataSaveFile*)local_this).get_total_file_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataSaveFile_get_total_file_size_316_comment =
  "C++ Interface:\n"
  "get_total_file_size(VertexDataSaveFile self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of space consumed by the save file, including unused\n"
  " * portions.\n"
  " */";
#else
static const char *Dtool_VertexDataSaveFile_get_total_file_size_316_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t VertexDataSaveFile::get_used_file_size(void) const
 */
static PyObject *Dtool_VertexDataSaveFile_get_used_file_size_317(PyObject *self, PyObject *) {
  VertexDataSaveFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataSaveFile)) {
    return nullptr;
  }
  // 1-inline std::size_t VertexDataSaveFile::get_used_file_size(void) const
  std::size_t return_value = ((*(const VertexDataSaveFile*)local_this).get_used_file_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataSaveFile_get_used_file_size_317_comment =
  "C++ Interface:\n"
  "get_used_file_size(VertexDataSaveFile self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of space within the save file that is currently in use.\n"
  " */";
#else
static const char *Dtool_VertexDataSaveFile_get_used_file_size_317_comment = nullptr;
#endif

static int Dtool_Init_VertexDataSaveFile(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VertexDataSaveFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VertexDataSaveFile) {
    printf("VertexDataSaveFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VertexDataSaveFile *local_this = (VertexDataSaveFile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VertexDataSaveFile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_SimpleAllocator) {
    return (SimpleAllocator *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VertexDataSaveFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VertexDataSaveFile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_SimpleAllocator) {
    SimpleAllocator* other_this = (SimpleAllocator*)from_this;
    return (VertexDataSaveFile*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VertexDataPage
 */
/**
 * Python function wrapper for:
 * inline VertexDataPage::RamClass VertexDataPage::get_ram_class(void) const
 */
static PyObject *Dtool_VertexDataPage_get_ram_class_324(PyObject *self, PyObject *) {
  VertexDataPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataPage)) {
    return nullptr;
  }
  // 1-inline VertexDataPage::RamClass VertexDataPage::get_ram_class(void) const
  VertexDataPage::RamClass return_value = ((*(const VertexDataPage*)local_this).get_ram_class)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_get_ram_class_324_comment =
  "C++ Interface:\n"
  "get_ram_class(VertexDataPage self)\n"
  "\n"
  "/**\n"
  " * Returns the current ram class of the array.  If this is other than\n"
  " * RC_resident, the array data is not resident in memory.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_get_ram_class_324_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VertexDataPage::RamClass VertexDataPage::get_pending_ram_class(void) const
 */
static PyObject *Dtool_VertexDataPage_get_pending_ram_class_325(PyObject *self, PyObject *) {
  VertexDataPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataPage)) {
    return nullptr;
  }
  // 1-inline VertexDataPage::RamClass VertexDataPage::get_pending_ram_class(void) const
  VertexDataPage::RamClass return_value = ((*(const VertexDataPage*)local_this).get_pending_ram_class)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_get_pending_ram_class_325_comment =
  "C++ Interface:\n"
  "get_pending_ram_class(VertexDataPage self)\n"
  "\n"
  "/**\n"
  " * Returns the pending ram class of the array.  If this is different from\n"
  " * get_ram_class(), this page has been queued to be processed by the thread.\n"
  " * Eventually the page will be set to this ram class.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_get_pending_ram_class_325_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void VertexDataPage::request_resident(void)
 */
static PyObject *Dtool_VertexDataPage_request_resident_326(PyObject *self, PyObject *) {
  VertexDataPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VertexDataPage, (void **)&local_this, "VertexDataPage.request_resident")) {
    return nullptr;
  }
  // 1-inline void VertexDataPage::request_resident(void)
  ((*local_this).request_resident)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_request_resident_326_comment =
  "C++ Interface:\n"
  "request_resident(const VertexDataPage self)\n"
  "\n"
  "/**\n"
  " * Ensures that the page will become resident soon.  Future calls to\n"
  " * get_page_data() will eventually return non-NULL.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_request_resident_326_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VertexDataBlock *VertexDataPage::alloc(std::size_t size)
 */
static PyObject *Dtool_VertexDataPage_alloc_327(PyObject *self, PyObject *arg) {
  VertexDataPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VertexDataPage, (void **)&local_this, "VertexDataPage.alloc")) {
    return nullptr;
  }
  // 1-inline VertexDataBlock *VertexDataPage::alloc(std::size_t size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    VertexDataBlock *return_value = ((*local_this).alloc)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VertexDataBlock, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "alloc(const VertexDataPage self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_alloc_327_comment =
  "C++ Interface:\n"
  "alloc(const VertexDataPage self, int size)\n"
  "\n"
  "/**\n"
  " * Allocates a new block.  Returns NULL if a block of the requested size\n"
  " * cannot be allocated.\n"
  " *\n"
  " * To free the allocated block, call block->free(), or simply delete the block\n"
  " * pointer.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_alloc_327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VertexDataBlock *VertexDataPage::get_first_block(void) const
 */
static PyObject *Dtool_VertexDataPage_get_first_block_328(PyObject *self, PyObject *) {
  VertexDataPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataPage)) {
    return nullptr;
  }
  // 1-inline VertexDataBlock *VertexDataPage::get_first_block(void) const
  VertexDataBlock *return_value = ((*(const VertexDataPage*)local_this).get_first_block)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VertexDataBlock, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_get_first_block_328_comment =
  "C++ Interface:\n"
  "get_first_block(VertexDataPage self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the first allocated block, or NULL if there are no\n"
  " * allocated blocks.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_get_first_block_328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VertexDataBook *VertexDataPage::get_book(void) const
 */
static PyObject *Dtool_VertexDataPage_get_book_329(PyObject *self, PyObject *) {
  VertexDataPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataPage)) {
    return nullptr;
  }
  // 1-inline VertexDataBook *VertexDataPage::get_book(void) const
  VertexDataBook *return_value = ((*(const VertexDataPage*)local_this).get_book)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VertexDataBook, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_get_book_329_comment =
  "C++ Interface:\n"
  "get_book(VertexDataPage self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the book that owns this page.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_get_book_329_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline SimpleLru *VertexDataPage::get_global_lru(VertexDataPage::RamClass rclass)
 */
static PyObject *Dtool_VertexDataPage_get_global_lru_330(PyObject *, PyObject *arg) {
  // 1-static inline SimpleLru *VertexDataPage::get_global_lru(VertexDataPage::RamClass rclass)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SimpleLru *return_value = (VertexDataPage::get_global_lru)((VertexDataPage::RamClass)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleLru, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_global_lru(int rclass)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_get_global_lru_330_comment =
  "C++ Interface:\n"
  "get_global_lru(int rclass)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global LRU object that manages the\n"
  " * VertexDataPage's with the indicated RamClass.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_get_global_lru_330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline SimpleLru *VertexDataPage::get_pending_lru(void)
 */
static PyObject *Dtool_VertexDataPage_get_pending_lru_331(PyObject *, PyObject *) {
  // 1-static inline SimpleLru *VertexDataPage::get_pending_lru(void)
  SimpleLru *return_value = (VertexDataPage::get_pending_lru)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleLru, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_get_pending_lru_331_comment =
  "C++ Interface:\n"
  "get_pending_lru()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global LRU object that manages the\n"
  " * VertexDataPage's that are pending processing by the thread.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_get_pending_lru_331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline VertexDataSaveFile *VertexDataPage::get_save_file(void)
 */
static PyObject *Dtool_VertexDataPage_get_save_file_332(PyObject *, PyObject *) {
  // 1-static inline VertexDataSaveFile *VertexDataPage::get_save_file(void)
  VertexDataSaveFile *return_value = (VertexDataPage::get_save_file)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VertexDataSaveFile, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_get_save_file_332_comment =
  "C++ Interface:\n"
  "get_save_file()\n"
  "\n"
  "/**\n"
  " * Returns the global VertexDataSaveFile that will be used to save vertex data\n"
  " * buffers to disk when necessary.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_get_save_file_332_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool VertexDataPage::save_to_disk(void)
 */
static PyObject *Dtool_VertexDataPage_save_to_disk_335(PyObject *self, PyObject *) {
  VertexDataPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VertexDataPage, (void **)&local_this, "VertexDataPage.save_to_disk")) {
    return nullptr;
  }
  // 1-inline bool VertexDataPage::save_to_disk(void)
  bool return_value = ((*local_this).save_to_disk)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_save_to_disk_335_comment =
  "C++ Interface:\n"
  "save_to_disk(const VertexDataPage self)\n"
  "\n"
  "/**\n"
  " * Writes the page to disk, but does not evict it from memory or affect its\n"
  " * LRU status.  If it gets evicted later without having been modified, it will\n"
  " * not need to write itself to disk again.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_save_to_disk_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int VertexDataPage::get_num_threads(void)
 */
static PyObject *Dtool_VertexDataPage_get_num_threads_336(PyObject *, PyObject *) {
  // 1-static inline int VertexDataPage::get_num_threads(void)
  int return_value = (VertexDataPage::get_num_threads)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_get_num_threads_336_comment =
  "C++ Interface:\n"
  "get_num_threads()\n"
  "\n"
  "/**\n"
  " * Returns the number of threads that have been spawned to service vertex\n"
  " * paging requests, or 0 if no threads have been spawned (which may mean\n"
  " * either that all paging requests will be handled by the main thread, or\n"
  " * simply that no paging requests have yet been issued).\n"
  " */";
#else
static const char *Dtool_VertexDataPage_get_num_threads_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int VertexDataPage::get_num_pending_reads(void)
 */
static PyObject *Dtool_VertexDataPage_get_num_pending_reads_337(PyObject *, PyObject *) {
  // 1-static inline int VertexDataPage::get_num_pending_reads(void)
  int return_value = (VertexDataPage::get_num_pending_reads)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_get_num_pending_reads_337_comment =
  "C++ Interface:\n"
  "get_num_pending_reads()\n"
  "\n"
  "/**\n"
  " * Returns the number of read requests that are waiting to be serviced by a\n"
  " * thread.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_get_num_pending_reads_337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int VertexDataPage::get_num_pending_writes(void)
 */
static PyObject *Dtool_VertexDataPage_get_num_pending_writes_338(PyObject *, PyObject *) {
  // 1-static inline int VertexDataPage::get_num_pending_writes(void)
  int return_value = (VertexDataPage::get_num_pending_writes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_get_num_pending_writes_338_comment =
  "C++ Interface:\n"
  "get_num_pending_writes()\n"
  "\n"
  "/**\n"
  " * Returns the number of write requests that are waiting to be serviced by a\n"
  " * thread.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_get_num_pending_writes_338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void VertexDataPage::stop_threads(void)
 */
static PyObject *Dtool_VertexDataPage_stop_threads_339(PyObject *, PyObject *) {
  // 1-static void VertexDataPage::stop_threads(void)
  (VertexDataPage::stop_threads)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_stop_threads_339_comment =
  "C++ Interface:\n"
  "stop_threads()\n"
  "\n"
  "/**\n"
  " * Call this to stop the paging threads, if they were started.  This may block\n"
  " * until all of the pending tasks have been completed.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_stop_threads_339_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void VertexDataPage::flush_threads(void)
 */
static PyObject *Dtool_VertexDataPage_flush_threads_340(PyObject *, PyObject *) {
  // 1-static void VertexDataPage::flush_threads(void)
  (VertexDataPage::flush_threads)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_flush_threads_340_comment =
  "C++ Interface:\n"
  "flush_threads()\n"
  "\n"
  "/**\n"
  " * Waits for all of the pending thread tasks to finish before returning.\n"
  " */";
#else
static const char *Dtool_VertexDataPage_flush_threads_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VertexDataPage::output(std::ostream &out) const
 */
static PyObject *Dtool_VertexDataPage_output_341(PyObject *self, PyObject *arg) {
  VertexDataPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataPage)) {
    return nullptr;
  }
  // 1-virtual void VertexDataPage::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "VertexDataPage.output", false, true);
  if (arg_this != nullptr) {
    ((*(const VertexDataPage*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(VertexDataPage self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_output_341_comment =
  "C++ Interface:\n"
  "output(VertexDataPage self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VertexDataPage_output_341_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VertexDataPage::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_VertexDataPage_write_342(PyObject *self, PyObject *args, PyObject *kwds) {
  VertexDataPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataPage)) {
    return nullptr;
  }
  // 1-virtual void VertexDataPage::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "VertexDataPage.write", false, true);
    if (param1_this != nullptr) {
      ((*(const VertexDataPage*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(VertexDataPage self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_write_342_comment =
  "C++ Interface:\n"
  "write(VertexDataPage self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VertexDataPage_write_342_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VertexDataPage::get_class_type(void)
 */
static PyObject *Dtool_VertexDataPage_get_class_type_343(PyObject *, PyObject *) {
  // 1-static TypeHandle VertexDataPage::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VertexDataPage::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_get_class_type_343_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VertexDataPage_get_class_type_343_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SimpleAllocator *VertexDataPage::upcast_to_SimpleAllocator(void)
 */
static PyObject *Dtool_VertexDataPage_upcast_to_SimpleAllocator_319(PyObject *self, PyObject *) {
  VertexDataPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VertexDataPage, (void **)&local_this, "VertexDataPage.upcast_to_SimpleAllocator")) {
    return nullptr;
  }
  // 1-SimpleAllocator *VertexDataPage::upcast_to_SimpleAllocator(void)
  SimpleAllocator *return_value = (SimpleAllocator *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleAllocator, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_upcast_to_SimpleAllocator_319_comment =
  "C++ Interface:\n"
  "upcast_to_SimpleAllocator(const VertexDataPage self)\n"
  "\n"
  "upcast from VertexDataPage to SimpleAllocator";
#else
static const char *Dtool_VertexDataPage_upcast_to_SimpleAllocator_319_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SimpleLruPage *VertexDataPage::upcast_to_SimpleLruPage(void)
 */
static PyObject *Dtool_VertexDataPage_upcast_to_SimpleLruPage_321(PyObject *self, PyObject *) {
  VertexDataPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VertexDataPage, (void **)&local_this, "VertexDataPage.upcast_to_SimpleLruPage")) {
    return nullptr;
  }
  // 1-SimpleLruPage *VertexDataPage::upcast_to_SimpleLruPage(void)
  SimpleLruPage *return_value = (SimpleLruPage *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleLruPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataPage_upcast_to_SimpleLruPage_321_comment =
  "C++ Interface:\n"
  "upcast_to_SimpleLruPage(const VertexDataPage self)\n"
  "\n"
  "upcast from VertexDataPage to SimpleLruPage";
#else
static const char *Dtool_VertexDataPage_upcast_to_SimpleLruPage_321_comment = nullptr;
#endif

static PyObject *Dtool_VertexDataPage_save_file_Getter(PyObject *self, void *) {
  // 1-static inline VertexDataSaveFile *VertexDataPage::get_save_file(void)
  VertexDataSaveFile *return_value = (VertexDataPage::get_save_file)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VertexDataSaveFile, false, false);
}

static int Dtool_Init_VertexDataPage(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VertexDataPage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VertexDataPage) {
    printf("VertexDataPage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VertexDataPage *local_this = (VertexDataPage *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VertexDataPage) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_SimpleAllocator) {
    return (SimpleAllocator *) local_this;
  }
  if (requested_type == Dtool_Ptr_SimpleLruPage) {
    return (SimpleLruPage *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VertexDataPage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VertexDataPage) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_SimpleAllocator) {
    SimpleAllocator* other_this = (SimpleAllocator*)from_this;
    return (VertexDataPage*)other_this;
  }
  if (from_type == Dtool_Ptr_SimpleLruPage) {
    SimpleLruPage* other_this = (SimpleLruPage*)from_this;
    return (VertexDataPage*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VertexDataBook
 */
/**
 * Python function wrapper for:
 * inline VertexDataBlock *VertexDataBook::alloc(std::size_t size)
 */
static PyObject *Dtool_VertexDataBook_alloc_347(PyObject *self, PyObject *arg) {
  VertexDataBook *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VertexDataBook, (void **)&local_this, "VertexDataBook.alloc")) {
    return nullptr;
  }
  // 1-inline VertexDataBlock *VertexDataBook::alloc(std::size_t size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    VertexDataBlock *return_value = ((*local_this).alloc)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VertexDataBlock, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "alloc(const VertexDataBook self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexDataBook_alloc_347_comment =
  "C++ Interface:\n"
  "alloc(const VertexDataBook self, int size)\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new VertexDataBuffer of the requested size.\n"
  " */";
#else
static const char *Dtool_VertexDataBook_alloc_347_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t VertexDataBook::get_num_pages(void) const
 */
static PyObject *Dtool_VertexDataBook_get_num_pages_348(PyObject *self, PyObject *) {
  VertexDataBook *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataBook)) {
    return nullptr;
  }
  // 1-inline std::size_t VertexDataBook::get_num_pages(void) const
  std::size_t return_value = ((*(const VertexDataBook*)local_this).get_num_pages)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataBook_get_num_pages_348_comment =
  "C++ Interface:\n"
  "get_num_pages(VertexDataBook self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pages created for the book.\n"
  " */";
#else
static const char *Dtool_VertexDataBook_get_num_pages_348_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t VertexDataBook::count_total_page_size(void) const
 * std::size_t VertexDataBook::count_total_page_size(VertexDataPage::RamClass ram_class) const
 */
static PyObject *Dtool_VertexDataBook_count_total_page_size_349(PyObject *self, PyObject *args) {
  VertexDataBook *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataBook)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-std::size_t VertexDataBook::count_total_page_size(void) const
      std::size_t return_value = ((*(const VertexDataBook*)local_this).count_total_page_size)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-std::size_t VertexDataBook::count_total_page_size(VertexDataPage::RamClass ram_class) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        std::size_t return_value = ((*(const VertexDataBook*)local_this).count_total_page_size)((VertexDataPage::RamClass)arg_val);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "count_total_page_size() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count_total_page_size(VertexDataBook self)\n"
      "count_total_page_size(VertexDataBook self, int ram_class)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexDataBook_count_total_page_size_349_comment =
  "C++ Interface:\n"
  "count_total_page_size(VertexDataBook self)\n"
  "count_total_page_size(VertexDataBook self, int ram_class)\n"
  "\n"
  "/**\n"
  " * Returns the total size of all bytes owned by all pages owned by this book.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the total size of all bytes owned by all pages owned by this book\n"
  " * that have the indicated ram class.\n"
  " */";
#else
static const char *Dtool_VertexDataBook_count_total_page_size_349_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t VertexDataBook::count_allocated_size(void) const
 * std::size_t VertexDataBook::count_allocated_size(VertexDataPage::RamClass ram_class) const
 */
static PyObject *Dtool_VertexDataBook_count_allocated_size_350(PyObject *self, PyObject *args) {
  VertexDataBook *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataBook)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-std::size_t VertexDataBook::count_allocated_size(void) const
      std::size_t return_value = ((*(const VertexDataBook*)local_this).count_allocated_size)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-std::size_t VertexDataBook::count_allocated_size(VertexDataPage::RamClass ram_class) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        std::size_t return_value = ((*(const VertexDataBook*)local_this).count_allocated_size)((VertexDataPage::RamClass)arg_val);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "count_allocated_size() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count_allocated_size(VertexDataBook self)\n"
      "count_allocated_size(VertexDataBook self, int ram_class)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexDataBook_count_allocated_size_350_comment =
  "C++ Interface:\n"
  "count_allocated_size(VertexDataBook self)\n"
  "count_allocated_size(VertexDataBook self, int ram_class)\n"
  "\n"
  "/**\n"
  " * Returns the total size of all bytes allocated within pages owned by this\n"
  " * book.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the total size of all bytes allocated within pages owned by this\n"
  " * book that have the indicated ram class.\n"
  " */";
#else
static const char *Dtool_VertexDataBook_count_allocated_size_350_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void VertexDataBook::save_to_disk(void)
 */
static PyObject *Dtool_VertexDataBook_save_to_disk_351(PyObject *self, PyObject *) {
  VertexDataBook *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VertexDataBook, (void **)&local_this, "VertexDataBook.save_to_disk")) {
    return nullptr;
  }
  // 1-void VertexDataBook::save_to_disk(void)
  ((*local_this).save_to_disk)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_VertexDataBook_save_to_disk_351_comment =
  "C++ Interface:\n"
  "save_to_disk(const VertexDataBook self)\n"
  "\n"
  "/**\n"
  " * Writes all pages to disk immediately, just in case they get evicted later.\n"
  " * It makes sense to make this call just before taking down a loading screen,\n"
  " * to minimize chugs from saving pages inadvertently later.\n"
  " */";
#else
static const char *Dtool_VertexDataBook_save_to_disk_351_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit VertexDataBook::VertexDataBook(std::size_t block_size)
 */
static int Dtool_Init_VertexDataBook(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VertexDataBook() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "block_size")) {
    // 1-explicit VertexDataBook::VertexDataBook(std::size_t block_size)
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return -1;
      }
#endif
      VertexDataBook *return_value = new VertexDataBook(arg_val);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VertexDataBook, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VertexDataBook(int block_size)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_VertexDataBook(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VertexDataBook) {
    printf("VertexDataBook ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VertexDataBook *local_this = (VertexDataBook *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VertexDataBook) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VertexDataBook(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VertexDataBook) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VertexDataBlock
 */
/**
 * Python function wrapper for:
 * inline VertexDataPage *VertexDataBlock::get_page(void) const
 */
static PyObject *Dtool_VertexDataBlock_get_page_358(PyObject *self, PyObject *) {
  VertexDataBlock *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataBlock)) {
    return nullptr;
  }
  // 1-inline VertexDataPage *VertexDataBlock::get_page(void) const
  VertexDataPage *return_value = ((*(const VertexDataBlock*)local_this).get_page)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VertexDataPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataBlock_get_page_358_comment =
  "C++ Interface:\n"
  "get_page(VertexDataBlock self)\n"
  "\n"
  "/**\n"
  " * Returns the page from which this buffer was allocated.\n"
  " */";
#else
static const char *Dtool_VertexDataBlock_get_page_358_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VertexDataBlock *VertexDataBlock::get_next_block(void) const
 */
static PyObject *Dtool_VertexDataBlock_get_next_block_359(PyObject *self, PyObject *) {
  VertexDataBlock *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexDataBlock)) {
    return nullptr;
  }
  // 1-inline VertexDataBlock *VertexDataBlock::get_next_block(void) const
  VertexDataBlock *return_value = ((*(const VertexDataBlock*)local_this).get_next_block)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VertexDataBlock, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataBlock_get_next_block_359_comment =
  "C++ Interface:\n"
  "get_next_block(VertexDataBlock self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the next allocated block in the chain, or NULL if\n"
  " * there are no more allocated blocks.\n"
  " */";
#else
static const char *Dtool_VertexDataBlock_get_next_block_359_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SimpleAllocatorBlock *VertexDataBlock::upcast_to_SimpleAllocatorBlock(void)
 */
static PyObject *Dtool_VertexDataBlock_upcast_to_SimpleAllocatorBlock_353(PyObject *self, PyObject *) {
  VertexDataBlock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VertexDataBlock, (void **)&local_this, "VertexDataBlock.upcast_to_SimpleAllocatorBlock")) {
    return nullptr;
  }
  // 1-SimpleAllocatorBlock *VertexDataBlock::upcast_to_SimpleAllocatorBlock(void)
  SimpleAllocatorBlock *return_value = (SimpleAllocatorBlock *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleAllocatorBlock, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataBlock_upcast_to_SimpleAllocatorBlock_353_comment =
  "C++ Interface:\n"
  "upcast_to_SimpleAllocatorBlock(const VertexDataBlock self)\n"
  "\n"
  "upcast from VertexDataBlock to SimpleAllocatorBlock";
#else
static const char *Dtool_VertexDataBlock_upcast_to_SimpleAllocatorBlock_353_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *VertexDataBlock::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_VertexDataBlock_upcast_to_ReferenceCount_356(PyObject *self, PyObject *) {
  VertexDataBlock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VertexDataBlock, (void **)&local_this, "VertexDataBlock.upcast_to_ReferenceCount")) {
    return nullptr;
  }
  // 1-ReferenceCount *VertexDataBlock::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexDataBlock_upcast_to_ReferenceCount_356_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const VertexDataBlock self)\n"
  "\n"
  "upcast from VertexDataBlock to ReferenceCount";
#else
static const char *Dtool_VertexDataBlock_upcast_to_ReferenceCount_356_comment = nullptr;
#endif

static int Dtool_Init_VertexDataBlock(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VertexDataBlock(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VertexDataBlock) {
    printf("VertexDataBlock ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VertexDataBlock *local_this = (VertexDataBlock *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VertexDataBlock) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_SimpleAllocatorBlock) {
    return (SimpleAllocatorBlock *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VertexDataBlock(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VertexDataBlock) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VertexDataBlock*)other_this;
  }
  if (from_type == Dtool_Ptr_SimpleAllocatorBlock) {
    SimpleAllocatorBlock* other_this = (SimpleAllocatorBlock*)from_this;
    return (VertexDataBlock*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomVertexArrayData
 */
/**
 * Python function wrapper for:
 * void GeomVertexArrayData::operator =(GeomVertexArrayData const &copy)
 */
static PyObject *Dtool_GeomVertexArrayData_operator_370(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.assign")) {
    return nullptr;
  }
  // 1-void GeomVertexArrayData::operator =(GeomVertexArrayData const &copy)
  GeomVertexArrayData const *arg_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayData, 1, "GeomVertexArrayData.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    GeomVertexArrayData *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexArrayData, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GeomVertexArrayData self, const GeomVertexArrayData copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_operator_370_comment =
  "C++ Interface:\n"
  "assign(const GeomVertexArrayData self, const GeomVertexArrayData copy)\n";
#else
static const char *Dtool_GeomVertexArrayData_operator_370_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomVertexArrayData::compare_to(GeomVertexArrayData const &other) const
 */
static PyObject *Dtool_GeomVertexArrayData_compare_to_375(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-int GeomVertexArrayData::compare_to(GeomVertexArrayData const &other) const
  GeomVertexArrayData const *arg_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayData, 1, "GeomVertexArrayData.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const GeomVertexArrayData*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(GeomVertexArrayData self, const GeomVertexArrayData other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_compare_to_375_comment =
  "C++ Interface:\n"
  "compare_to(GeomVertexArrayData self, const GeomVertexArrayData other)\n"
  "\n"
  "/**\n"
  " * Returns 0 if the two arrays are equivalent, even if they are not the same\n"
  " * pointer.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_compare_to_375_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexArrayFormat const *GeomVertexArrayData::get_array_format(void) const
 */
static PyObject *Dtool_GeomVertexArrayData_get_array_format_376(PyObject *self, PyObject *) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-inline GeomVertexArrayFormat const *GeomVertexArrayData::get_array_format(void) const
  GeomVertexArrayFormat const *return_value = ((*(const GeomVertexArrayData*)local_this).get_array_format)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexArrayFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_get_array_format_376_comment =
  "C++ Interface:\n"
  "get_array_format(GeomVertexArrayData self)\n"
  "\n"
  "/**\n"
  " * Returns the format object that describes this array.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_get_array_format_376_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::UsageHint GeomVertexArrayData::get_usage_hint(void) const
 */
static PyObject *Dtool_GeomVertexArrayData_get_usage_hint_378(PyObject *self, PyObject *) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-inline GeomEnums::UsageHint GeomVertexArrayData::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const GeomVertexArrayData*)local_this).get_usage_hint)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_get_usage_hint_378_comment =
  "C++ Interface:\n"
  "get_usage_hint(GeomVertexArrayData self)\n"
  "\n"
  "/**\n"
  " * Returns the usage hint that describes to the rendering backend how often\n"
  " * the vertex data will be modified and/or rendered.  See geomEnums.h.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_get_usage_hint_378_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayData::set_usage_hint(GeomEnums::UsageHint usage_hint)
 */
static PyObject *Dtool_GeomVertexArrayData_set_usage_hint_379(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.set_usage_hint")) {
    return nullptr;
  }
  // 1-void GeomVertexArrayData::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_usage_hint)((GeomEnums::UsageHint)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const GeomVertexArrayData self, int usage_hint)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_set_usage_hint_379_comment =
  "C++ Interface:\n"
  "set_usage_hint(const GeomVertexArrayData self, int usage_hint)\n"
  "\n"
  "/**\n"
  " * Changes the UsageHint hint for this array.  See get_usage_hint().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_set_usage_hint_379_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexArrayData::has_column(InternalName const *name) const
 */
static PyObject *Dtool_GeomVertexArrayData_has_column_381(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexArrayData::has_column(InternalName const *name) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexArrayData.has_column", "InternalName");
  }
  bool return_value = ((*(const GeomVertexArrayData*)local_this).has_column)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_column(GeomVertexArrayData self, const InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_has_column_381_comment =
  "C++ Interface:\n"
  "has_column(GeomVertexArrayData self, const InternalName name)\n"
  "\n"
  "/**\n"
  " * Returns true if the array has the named column, false otherwise.  This is\n"
  " * really just a shortcut for asking the same thing from the format.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_has_column_381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexArrayData::get_num_rows(void) const
 */
static PyObject *Dtool_GeomVertexArrayData_get_num_rows_382(PyObject *self, PyObject *) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-inline int GeomVertexArrayData::get_num_rows(void) const
  int return_value = ((*(const GeomVertexArrayData*)local_this).get_num_rows)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_get_num_rows_382_comment =
  "C++ Interface:\n"
  "get_num_rows(GeomVertexArrayData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of rows stored in the array, based on the number of\n"
  " * bytes and the stride.  This should be the same for all arrays within a\n"
  " * given GeomVertexData object.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_get_num_rows_382_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexArrayData::set_num_rows(int n)
 */
static PyObject *Dtool_GeomVertexArrayData_set_num_rows_383(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.set_num_rows")) {
    return nullptr;
  }
  // 1-inline bool GeomVertexArrayData::set_num_rows(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).set_num_rows)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_rows(const GeomVertexArrayData self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_set_num_rows_383_comment =
  "C++ Interface:\n"
  "set_num_rows(const GeomVertexArrayData self, int n)\n"
  "\n"
  "/**\n"
  " * Sets the length of the array to n rows.\n"
  " *\n"
  " * Normally, you would not call this directly, since all of the arrays in a\n"
  " * particular GeomVertexData must have the same number of rows; instead, call\n"
  " * GeomVertexData::set_num_rows().\n"
  " *\n"
  " * The return value is true if the number of rows was changed, false if the\n"
  " * object already contained n rows (or if there was some error).\n"
  " *\n"
  " * The new vertex data is initialized to 0, including the \"color\" column (but\n"
  " * see GeomVertexData::set_num_rows()).\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_set_num_rows_383_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexArrayData::unclean_set_num_rows(int n)
 */
static PyObject *Dtool_GeomVertexArrayData_unclean_set_num_rows_384(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.unclean_set_num_rows")) {
    return nullptr;
  }
  // 1-inline bool GeomVertexArrayData::unclean_set_num_rows(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).unclean_set_num_rows)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unclean_set_num_rows(const GeomVertexArrayData self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_unclean_set_num_rows_384_comment =
  "C++ Interface:\n"
  "unclean_set_num_rows(const GeomVertexArrayData self, int n)\n"
  "\n"
  "/**\n"
  " * This method behaves like set_num_rows(), except the new data is not\n"
  " * initialized.  Furthermore, after this call, *any* of the data in the\n"
  " * GeomVertexArrayData may be uninitialized, including the earlier rows.\n"
  " *\n"
  " * Normally, you would not call this directly, since all of the arrays in a\n"
  " * particular GeomVertexData must have the same number of rows; instead, call\n"
  " * GeomVertexData::unclean_set_num_rows().\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_unclean_set_num_rows_384_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexArrayData::reserve_num_rows(int n)
 */
static PyObject *Dtool_GeomVertexArrayData_reserve_num_rows_385(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.reserve_num_rows")) {
    return nullptr;
  }
  // 1-inline bool GeomVertexArrayData::reserve_num_rows(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).reserve_num_rows)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reserve_num_rows(const GeomVertexArrayData self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_reserve_num_rows_385_comment =
  "C++ Interface:\n"
  "reserve_num_rows(const GeomVertexArrayData self, int n)\n"
  "\n"
  "/**\n"
  " * This ensures that enough memory space for n rows is allocated, so that you\n"
  " * may increase the number of rows to n without causing a new memory\n"
  " * allocation.  This is a performance optimization only; it is especially\n"
  " * useful when you know ahead of time that you will be adding n rows to the\n"
  " * data.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_reserve_num_rows_385_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexArrayData::clear_rows(void)
 */
static PyObject *Dtool_GeomVertexArrayData_clear_rows_386(PyObject *self, PyObject *) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.clear_rows")) {
    return nullptr;
  }
  // 1-inline void GeomVertexArrayData::clear_rows(void)
  ((*local_this).clear_rows)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_clear_rows_386_comment =
  "C++ Interface:\n"
  "clear_rows(const GeomVertexArrayData self)\n"
  "\n"
  "/**\n"
  " * Removes all of the rows in the array.  Functionally equivalent to\n"
  " * set_num_rows(0).\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_clear_rows_386_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t GeomVertexArrayData::get_data_size_bytes(void) const
 */
static PyObject *Dtool_GeomVertexArrayData_get_data_size_bytes_387(PyObject *self, PyObject *) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-inline std::size_t GeomVertexArrayData::get_data_size_bytes(void) const
  std::size_t return_value = ((*(const GeomVertexArrayData*)local_this).get_data_size_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_get_data_size_bytes_387_comment =
  "C++ Interface:\n"
  "get_data_size_bytes(GeomVertexArrayData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes stored in the array.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_get_data_size_bytes_387_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq GeomVertexArrayData::get_modified(void) const
 */
static PyObject *Dtool_GeomVertexArrayData_get_modified_388(PyObject *self, PyObject *) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-inline UpdateSeq GeomVertexArrayData::get_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const GeomVertexArrayData*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_get_modified_388_comment =
  "C++ Interface:\n"
  "get_modified(GeomVertexArrayData self)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number which is guaranteed to change at least every time\n"
  " * the array vertex data is modified.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_get_modified_388_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void GeomVertexArrayData::output(std::ostream &out) const
 */
static PyObject *Dtool_GeomVertexArrayData_output_394(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-virtual void GeomVertexArrayData::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GeomVertexArrayData.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GeomVertexArrayData*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GeomVertexArrayData self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_output_394_comment =
  "C++ Interface:\n"
  "output(GeomVertexArrayData self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_output_394_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void GeomVertexArrayData::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_GeomVertexArrayData_write_395(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-virtual void GeomVertexArrayData::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "GeomVertexArrayData.write", false, true);
    if (param1_this != nullptr) {
      ((*(const GeomVertexArrayData*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(GeomVertexArrayData self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_write_395_comment =
  "C++ Interface:\n"
  "write(GeomVertexArrayData self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_write_395_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexArrayData::request_resident(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_GeomVertexArrayData_request_resident_396(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexArrayData::request_resident(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexArrayData.request_resident", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      bool return_value = ((*(const GeomVertexArrayData*)local_this).request_resident)(param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "request_resident(GeomVertexArrayData self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_request_resident_396_comment =
  "C++ Interface:\n"
  "request_resident(GeomVertexArrayData self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex data is currently resident in memory.  If this\n"
  " * returns true, the next call to get_handle()->get_read_pointer() will\n"
  " * probably not block.  If this returns false, the vertex data will be brought\n"
  " * back into memory shortly; try again later.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_request_resident_396_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< GeomVertexArrayDataHandle > GeomVertexArrayData::get_handle(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_GeomVertexArrayData_get_handle_397(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeomVertexArrayDataHandle > GeomVertexArrayData::get_handle(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexArrayData.get_handle", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< GeomVertexArrayDataHandle > return_value = ((*(const GeomVertexArrayData*)local_this).get_handle)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GeomVertexArrayDataHandle const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayDataHandle, true, true);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_handle(GeomVertexArrayData self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_get_handle_397_comment =
  "C++ Interface:\n"
  "get_handle(GeomVertexArrayData self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns an object that can be used to read the actual data bytes stored in\n"
  " * the array.  Calling this method locks the data, and will block any other\n"
  " * threads attempting to read or write the data, until the returned object\n"
  " * destructs.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_get_handle_397_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< GeomVertexArrayDataHandle > GeomVertexArrayData::modify_handle(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_GeomVertexArrayData_modify_handle_398(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.modify_handle")) {
    return nullptr;
  }
  // 1-inline PointerTo< GeomVertexArrayDataHandle > GeomVertexArrayData::modify_handle(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexArrayData.modify_handle", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      PointerTo< GeomVertexArrayDataHandle > return_value = ((*local_this).modify_handle)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GeomVertexArrayDataHandle *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayDataHandle, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_handle(const GeomVertexArrayData self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_modify_handle_398_comment =
  "C++ Interface:\n"
  "modify_handle(const GeomVertexArrayData self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns an object that can be used to read or write the actual data bytes\n"
  " * stored in the array.  Calling this method locks the data, and will block\n"
  " * any other threads attempting to read or write the data, until the returned\n"
  " * object destructs.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_modify_handle_398_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayData::prepare(PreparedGraphicsObjects *prepared_objects)
 */
static PyObject *Dtool_GeomVertexArrayData_prepare_399(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.prepare")) {
    return nullptr;
  }
  // 1-void GeomVertexArrayData::prepare(PreparedGraphicsObjects *prepared_objects)
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "GeomVertexArrayData.prepare", false, true);
  if (arg_this != nullptr) {
    ((*local_this).prepare)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare(const GeomVertexArrayData self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_prepare_399_comment =
  "C++ Interface:\n"
  "prepare(const GeomVertexArrayData self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Indicates that the data should be enqueued to be prepared in the indicated\n"
  " * prepared_objects at the beginning of the next frame.  This will ensure the\n"
  " * data is already loaded into the GSG if it is expected to be rendered soon.\n"
  " *\n"
  " * Use this function instead of prepare_now() to preload datas from a user\n"
  " * interface standpoint.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_prepare_399_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GeomVertexArrayData::is_prepared(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_GeomVertexArrayData_is_prepared_400(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayData)) {
    return nullptr;
  }
  // 1-bool GeomVertexArrayData::is_prepared(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "GeomVertexArrayData.is_prepared", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const GeomVertexArrayData*)local_this).is_prepared)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_prepared(GeomVertexArrayData self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_is_prepared_400_comment =
  "C++ Interface:\n"
  "is_prepared(GeomVertexArrayData self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Returns true if the data has already been prepared or enqueued for\n"
  " * preparation on the indicated GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_is_prepared_400_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * VertexBufferContext *GeomVertexArrayData::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_GeomVertexArrayData_prepare_now_401(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.prepare_now")) {
    return nullptr;
  }
  // 1-VertexBufferContext *GeomVertexArrayData::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"prepared_objects", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:prepare_now", (char **)keyword_list, &param1, &param2)) {
    PreparedGraphicsObjects *param1_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PreparedGraphicsObjects, 1, "GeomVertexArrayData.prepare_now", false, true);
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "GeomVertexArrayData.prepare_now", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      VertexBufferContext *return_value = ((*local_this).prepare_now)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VertexBufferContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_now(const GeomVertexArrayData self, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_prepare_now_401_comment =
  "C++ Interface:\n"
  "prepare_now(const GeomVertexArrayData self, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Creates a context for the data on the particular GSG, if it does not\n"
  " * already exist.  Returns the new (or old) VertexBufferContext.  This assumes\n"
  " * that the GraphicsStateGuardian is the currently active rendering context\n"
  " * and that it is ready to accept new datas.  If this is not necessarily the\n"
  " * case, you should use prepare() instead.\n"
  " *\n"
  " * Normally, this is not called directly except by the GraphicsStateGuardian;\n"
  " * a data does not need to be explicitly prepared by the user before it may be\n"
  " * rendered.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_prepare_now_401_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GeomVertexArrayData::release(PreparedGraphicsObjects *prepared_objects)
 */
static PyObject *Dtool_GeomVertexArrayData_release_402(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.release")) {
    return nullptr;
  }
  // 1-bool GeomVertexArrayData::release(PreparedGraphicsObjects *prepared_objects)
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "GeomVertexArrayData.release", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).release)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release(const GeomVertexArrayData self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_release_402_comment =
  "C++ Interface:\n"
  "release(const GeomVertexArrayData self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Frees the data context only on the indicated object, if it exists there.\n"
  " * Returns true if it was released, false if it had not been prepared.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_release_402_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomVertexArrayData::release_all(void)
 */
static PyObject *Dtool_GeomVertexArrayData_release_all_403(PyObject *self, PyObject *) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.release_all")) {
    return nullptr;
  }
  // 1-int GeomVertexArrayData::release_all(void)
  int return_value = ((*local_this).release_all)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_release_all_403_comment =
  "C++ Interface:\n"
  "release_all(const GeomVertexArrayData self)\n"
  "\n"
  "/**\n"
  " * Frees the context allocated on all objects for which the data has been\n"
  " * declared.  Returns the number of contexts which have been freed.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_release_all_403_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline SimpleLru *GeomVertexArrayData::get_independent_lru(void)
 */
static PyObject *Dtool_GeomVertexArrayData_get_independent_lru_404(PyObject *, PyObject *) {
  // 1-static inline SimpleLru *GeomVertexArrayData::get_independent_lru(void)
  SimpleLru *return_value = (GeomVertexArrayData::get_independent_lru)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleLru, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_get_independent_lru_404_comment =
  "C++ Interface:\n"
  "get_independent_lru()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global LRU object that manages the\n"
  " * GeomVertexArrayData's that have not (yet) been paged out.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_get_independent_lru_404_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline SimpleLru *GeomVertexArrayData::get_small_lru(void)
 */
static PyObject *Dtool_GeomVertexArrayData_get_small_lru_405(PyObject *, PyObject *) {
  // 1-static inline SimpleLru *GeomVertexArrayData::get_small_lru(void)
  SimpleLru *return_value = (GeomVertexArrayData::get_small_lru)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleLru, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_get_small_lru_405_comment =
  "C++ Interface:\n"
  "get_small_lru()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global LRU object that manages the\n"
  " * GeomVertexArrayData's that are deemed too small to be paged out.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_get_small_lru_405_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void GeomVertexArrayData::lru_epoch(void)
 */
static PyObject *Dtool_GeomVertexArrayData_lru_epoch_406(PyObject *, PyObject *) {
  // 1-static void GeomVertexArrayData::lru_epoch(void)
  (GeomVertexArrayData::lru_epoch)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_lru_epoch_406_comment =
  "C++ Interface:\n"
  "lru_epoch()\n"
  "\n"
  "/**\n"
  " * Marks that an epoch has passed in each LRU.  Asks the LRU's to consider\n"
  " * whether they should perform evictions.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_lru_epoch_406_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline VertexDataBook &GeomVertexArrayData::get_book(void)
 */
static PyObject *Dtool_GeomVertexArrayData_get_book_407(PyObject *, PyObject *) {
  // 1-static inline VertexDataBook &GeomVertexArrayData::get_book(void)
  VertexDataBook *return_value = &((GeomVertexArrayData::get_book)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VertexDataBook, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_get_book_407_comment =
  "C++ Interface:\n"
  "get_book()\n"
  "\n"
  "/**\n"
  " * Returns the global VertexDataBook that will be used to allocate vertex data\n"
  " * buffers.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayData_get_book_407_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeomVertexArrayData::get_class_type(void)
 */
static PyObject *Dtool_GeomVertexArrayData_get_class_type_410(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomVertexArrayData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomVertexArrayData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_get_class_type_410_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomVertexArrayData_get_class_type_410_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CopyOnWriteObject *GeomVertexArrayData::upcast_to_CopyOnWriteObject(void)
 */
static PyObject *Dtool_GeomVertexArrayData_upcast_to_CopyOnWriteObject_363(PyObject *self, PyObject *) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.upcast_to_CopyOnWriteObject")) {
    return nullptr;
  }
  // 1-CopyOnWriteObject *GeomVertexArrayData::upcast_to_CopyOnWriteObject(void)
  CopyOnWriteObject *return_value = (CopyOnWriteObject *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CopyOnWriteObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_upcast_to_CopyOnWriteObject_363_comment =
  "C++ Interface:\n"
  "upcast_to_CopyOnWriteObject(const GeomVertexArrayData self)\n"
  "\n"
  "upcast from GeomVertexArrayData to CopyOnWriteObject";
#else
static const char *Dtool_GeomVertexArrayData_upcast_to_CopyOnWriteObject_363_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SimpleLruPage *GeomVertexArrayData::upcast_to_SimpleLruPage(void)
 */
static PyObject *Dtool_GeomVertexArrayData_upcast_to_SimpleLruPage_365(PyObject *self, PyObject *) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.upcast_to_SimpleLruPage")) {
    return nullptr;
  }
  // 1-SimpleLruPage *GeomVertexArrayData::upcast_to_SimpleLruPage(void)
  SimpleLruPage *return_value = (SimpleLruPage *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SimpleLruPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_upcast_to_SimpleLruPage_365_comment =
  "C++ Interface:\n"
  "upcast_to_SimpleLruPage(const GeomVertexArrayData self)\n"
  "\n"
  "upcast from GeomVertexArrayData to SimpleLruPage";
#else
static const char *Dtool_GeomVertexArrayData_upcast_to_SimpleLruPage_365_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomEnums *GeomVertexArrayData::upcast_to_GeomEnums(void)
 */
static PyObject *Dtool_GeomVertexArrayData_upcast_to_GeomEnums_367(PyObject *self, PyObject *) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.upcast_to_GeomEnums")) {
    return nullptr;
  }
  // 1-GeomEnums *GeomVertexArrayData::upcast_to_GeomEnums(void)
  GeomEnums *return_value = (GeomEnums *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomEnums, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayData_upcast_to_GeomEnums_367_comment =
  "C++ Interface:\n"
  "upcast_to_GeomEnums(const GeomVertexArrayData self)\n"
  "\n"
  "upcast from GeomVertexArrayData to GeomEnums";
#else
static const char *Dtool_GeomVertexArrayData_upcast_to_GeomEnums_367_comment = nullptr;
#endif

static PyObject *Dtool_GeomVertexArrayData_array_format_Getter(PyObject *self, void *) {
  const GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomVertexArrayFormat const *GeomVertexArrayData::get_array_format(void) const
  GeomVertexArrayFormat const *return_value = ((*(const GeomVertexArrayData*)local_this).get_array_format)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexArrayFormat, true, true);
}

static PyObject *Dtool_GeomVertexArrayData_usage_hint_Getter(PyObject *self, void *) {
  const GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::UsageHint GeomVertexArrayData::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const GeomVertexArrayData*)local_this).get_usage_hint)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GeomVertexArrayData_usage_hint_Setter(PyObject *self, PyObject *arg, void *) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayData, (void **)&local_this, "GeomVertexArrayData.usage_hint")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete usage_hint attribute");
    return -1;
  }
  // 1-void GeomVertexArrayData::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_usage_hint)((GeomEnums::UsageHint)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const GeomVertexArrayData self, int usage_hint)\n");
  }
  return -1;
}

static PyObject *Dtool_GeomVertexArrayData_data_size_bytes_Getter(PyObject *self, void *) {
  const GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t GeomVertexArrayData::get_data_size_bytes(void) const
  std::size_t return_value = ((*(const GeomVertexArrayData*)local_this).get_data_size_bytes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomVertexArrayData_modified_Getter(PyObject *self, void *) {
  const GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq GeomVertexArrayData::get_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const GeomVertexArrayData*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

/**
 * Python function wrapper for:
 * GeomVertexArrayData::GeomVertexArrayData(GeomVertexArrayData const &copy)
 * explicit GeomVertexArrayData::GeomVertexArrayData(GeomVertexArrayFormat const *array_format, GeomEnums::UsageHint usage_hint)
 */
static int Dtool_Init_GeomVertexArrayData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-GeomVertexArrayData::GeomVertexArrayData(GeomVertexArrayData const &copy)
        GeomVertexArrayData const *arg_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexArrayData.GeomVertexArrayData", true, true);
        if (arg_this != nullptr) {
          GeomVertexArrayData *return_value = new GeomVertexArrayData(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexArrayData, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-explicit GeomVertexArrayData::GeomVertexArrayData(GeomVertexArrayFormat const *array_format, GeomEnums::UsageHint usage_hint)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"array_format", "usage_hint", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:GeomVertexArrayData", (char **)keyword_list, &param0, &param1)) {
        CPT(GeomVertexArrayFormat) param0_this;
        if (!Dtool_ConstCoerce_GeomVertexArrayFormat(param0, param0_this)) {
          Dtool_Raise_ArgTypeError(param0, 0, "GeomVertexArrayData.GeomVertexArrayData", "GeomVertexArrayFormat");
          return -1;
        }
        GeomVertexArrayData *return_value = new GeomVertexArrayData(std::move(param0_this), (GeomEnums::UsageHint)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexArrayData, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomVertexArrayData() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomVertexArrayData(const GeomVertexArrayData copy)\n"
      "GeomVertexArrayData(const GeomVertexArrayFormat array_format, int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomVertexArrayData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomVertexArrayData) {
    printf("GeomVertexArrayData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomVertexArrayData *local_this = (GeomVertexArrayData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomVertexArrayData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_SimpleLruPage) {
    return (SimpleLruPage *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomVertexArrayData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomVertexArrayData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomVertexArrayData*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomVertexArrayData*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomVertexArrayData*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomVertexArrayData*)other_this;
  }
  if (from_type == Dtool_Ptr_SimpleLruPage) {
    SimpleLruPage* other_this = (SimpleLruPage*)from_this;
    return (GeomVertexArrayData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomVertexArrayData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomVertexArrayData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomVertexArrayData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomVertexArrayDataHandle
 */
/**
 * Python function wrapper for:
 * inline GeomVertexArrayData *GeomVertexArrayDataHandle::get_object(void)
 * inline GeomVertexArrayData const *GeomVertexArrayDataHandle::get_object(void) const
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_get_object_417(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayDataHandle)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 inline GeomVertexArrayData *GeomVertexArrayDataHandle::get_object(void)
    GeomVertexArrayData *return_value = ((*local_this).get_object)();
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexArrayData, true, false, return_value->as_typed_object()->get_type_index());
    }
  }

  {
    // -2 inline GeomVertexArrayData const *GeomVertexArrayDataHandle::get_object(void) const
    GeomVertexArrayData const *return_value = ((*(const GeomVertexArrayDataHandle*)local_this).get_object)();
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexArrayData, true, true, return_value->as_typed_object()->get_type_index());
    }
  }

  // No coercion possible: inline GeomVertexArrayData *GeomVertexArrayDataHandle::get_object(void)
  // No coercion possible: inline GeomVertexArrayData const *GeomVertexArrayDataHandle::get_object(void) const
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_get_object_417_comment =
  "C++ Interface:\n"
  "get_object(const GeomVertexArrayDataHandle self)\n"
  "get_object(GeomVertexArrayDataHandle self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_get_object_417_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexArrayFormat const *GeomVertexArrayDataHandle::get_array_format(void) const
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_get_array_format_420(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayDataHandle)) {
    return nullptr;
  }
  // 1-inline GeomVertexArrayFormat const *GeomVertexArrayDataHandle::get_array_format(void) const
  GeomVertexArrayFormat const *return_value = ((*(const GeomVertexArrayDataHandle*)local_this).get_array_format)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexArrayFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_get_array_format_420_comment =
  "C++ Interface:\n"
  "get_array_format(GeomVertexArrayDataHandle self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_get_array_format_420_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::UsageHint GeomVertexArrayDataHandle::get_usage_hint(void) const
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_get_usage_hint_421(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayDataHandle)) {
    return nullptr;
  }
  // 1-inline GeomEnums::UsageHint GeomVertexArrayDataHandle::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const GeomVertexArrayDataHandle*)local_this).get_usage_hint)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_get_usage_hint_421_comment =
  "C++ Interface:\n"
  "get_usage_hint(GeomVertexArrayDataHandle self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_get_usage_hint_421_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexArrayDataHandle::get_num_rows(void) const
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_get_num_rows_424(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayDataHandle)) {
    return nullptr;
  }
  // 1-inline int GeomVertexArrayDataHandle::get_num_rows(void) const
  int return_value = ((*(const GeomVertexArrayDataHandle*)local_this).get_num_rows)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_get_num_rows_424_comment =
  "C++ Interface:\n"
  "get_num_rows(GeomVertexArrayDataHandle self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_get_num_rows_424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GeomVertexArrayDataHandle::set_num_rows(int n)
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_set_num_rows_425(PyObject *self, PyObject *arg) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this, "GeomVertexArrayDataHandle.set_num_rows")) {
    return nullptr;
  }
  // 1-bool GeomVertexArrayDataHandle::set_num_rows(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).set_num_rows)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_rows(const GeomVertexArrayDataHandle self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_set_num_rows_425_comment =
  "C++ Interface:\n"
  "set_num_rows(const GeomVertexArrayDataHandle self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_set_num_rows_425_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GeomVertexArrayDataHandle::unclean_set_num_rows(int n)
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_unclean_set_num_rows_426(PyObject *self, PyObject *arg) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this, "GeomVertexArrayDataHandle.unclean_set_num_rows")) {
    return nullptr;
  }
  // 1-bool GeomVertexArrayDataHandle::unclean_set_num_rows(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).unclean_set_num_rows)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unclean_set_num_rows(const GeomVertexArrayDataHandle self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_unclean_set_num_rows_426_comment =
  "C++ Interface:\n"
  "unclean_set_num_rows(const GeomVertexArrayDataHandle self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_unclean_set_num_rows_426_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GeomVertexArrayDataHandle::reserve_num_rows(int n)
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_reserve_num_rows_427(PyObject *self, PyObject *arg) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this, "GeomVertexArrayDataHandle.reserve_num_rows")) {
    return nullptr;
  }
  // 1-bool GeomVertexArrayDataHandle::reserve_num_rows(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).reserve_num_rows)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reserve_num_rows(const GeomVertexArrayDataHandle self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_reserve_num_rows_427_comment =
  "C++ Interface:\n"
  "reserve_num_rows(const GeomVertexArrayDataHandle self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_reserve_num_rows_427_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexArrayDataHandle::clear_rows(void)
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_clear_rows_428(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this, "GeomVertexArrayDataHandle.clear_rows")) {
    return nullptr;
  }
  // 1-inline void GeomVertexArrayDataHandle::clear_rows(void)
  ((*local_this).clear_rows)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_clear_rows_428_comment =
  "C++ Interface:\n"
  "clear_rows(const GeomVertexArrayDataHandle self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_clear_rows_428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t GeomVertexArrayDataHandle::get_data_size_bytes(void) const
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_get_data_size_bytes_429(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayDataHandle)) {
    return nullptr;
  }
  // 1-inline std::size_t GeomVertexArrayDataHandle::get_data_size_bytes(void) const
  std::size_t return_value = ((*(const GeomVertexArrayDataHandle*)local_this).get_data_size_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_get_data_size_bytes_429_comment =
  "C++ Interface:\n"
  "get_data_size_bytes(GeomVertexArrayDataHandle self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_get_data_size_bytes_429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq GeomVertexArrayDataHandle::get_modified(void) const
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_get_modified_430(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayDataHandle)) {
    return nullptr;
  }
  // 1-inline UpdateSeq GeomVertexArrayDataHandle::get_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const GeomVertexArrayDataHandle*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_get_modified_430_comment =
  "C++ Interface:\n"
  "get_modified(GeomVertexArrayDataHandle self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_get_modified_430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexArrayDataHandle::request_resident(void) const
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_request_resident_433(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayDataHandle)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexArrayDataHandle::request_resident(void) const
  bool return_value = ((*(const GeomVertexArrayDataHandle*)local_this).request_resident)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_request_resident_433_comment =
  "C++ Interface:\n"
  "request_resident(GeomVertexArrayDataHandle self)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex data is currently resident in memory.  If this\n"
  " * returns true, the next call to get_handle()->get_read_pointer() will\n"
  " * probably not block.  If this returns false, the vertex data will be brought\n"
  " * back into memory shortly; try again later.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_request_resident_433_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VertexBufferContext *GeomVertexArrayDataHandle::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg) const
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_prepare_now_434(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayDataHandle)) {
    return nullptr;
  }
  // 1-inline VertexBufferContext *GeomVertexArrayDataHandle::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"prepared_objects", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:prepare_now", (char **)keyword_list, &param1, &param2)) {
    PreparedGraphicsObjects *param1_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PreparedGraphicsObjects, 1, "GeomVertexArrayDataHandle.prepare_now", false, true);
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "GeomVertexArrayDataHandle.prepare_now", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      VertexBufferContext *return_value = ((*(const GeomVertexArrayDataHandle*)local_this).prepare_now)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VertexBufferContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_now(GeomVertexArrayDataHandle self, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_prepare_now_434_comment =
  "C++ Interface:\n"
  "prepare_now(GeomVertexArrayDataHandle self, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Creates a context for the data on the particular GSG, if it does not\n"
  " * already exist.  Returns the new (or old) VertexBufferContext.  This assumes\n"
  " * that the GraphicsStateGuardian is the currently active rendering context\n"
  " * and that it is ready to accept new datas.  If this is not necessarily the\n"
  " * case, you should use prepare() instead.\n"
  " *\n"
  " * Normally, this is not called directly except by the GraphicsStateGuardian;\n"
  " * a data does not need to be explicitly prepared by the user before it may be\n"
  " * rendered.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_prepare_now_434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayDataHandle::copy_data_from(GeomVertexArrayDataHandle const *other)
 * void GeomVertexArrayDataHandle::copy_data_from(PyObject *buffer)
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_copy_data_from_435(PyObject *self, PyObject *arg) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this, "GeomVertexArrayDataHandle.copy_data_from")) {
    return nullptr;
  }
  {
    // -2 void GeomVertexArrayDataHandle::copy_data_from(GeomVertexArrayDataHandle const *other)
    GeomVertexArrayDataHandle const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GeomVertexArrayDataHandle);
    if (arg_this != nullptr) {
      ((*local_this).copy_data_from)(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void GeomVertexArrayDataHandle::copy_data_from(PyObject *buffer)
    invoke_extension(local_this).copy_data_from(arg);
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      return nullptr;
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  }

  // No coercion possible: void GeomVertexArrayDataHandle::copy_data_from(GeomVertexArrayDataHandle const *other)
  // No coercion possible: void GeomVertexArrayDataHandle::copy_data_from(PyObject *buffer)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_data_from(const GeomVertexArrayDataHandle self, const GeomVertexArrayDataHandle other)\n"
      "copy_data_from(const GeomVertexArrayDataHandle self, object buffer)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_copy_data_from_435_comment =
  "C++ Interface:\n"
  "copy_data_from(const GeomVertexArrayDataHandle self, const GeomVertexArrayDataHandle other)\n"
  "copy_data_from(const GeomVertexArrayDataHandle self, object buffer)\n"
  "\n"
  "/**\n"
  " * Copies the entire data array from the other object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies the entire data array from the buffer.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_copy_data_from_435_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, GeomVertexArrayDataHandle const *other, std::size_t from_start, std::size_t from_size)
 * void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, PyObject *buffer)
 * void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, PyObject *buffer, std::size_t from_start, std::size_t from_size)
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_copy_subdata_from_436(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this, "GeomVertexArrayDataHandle.copy_subdata_from")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, PyObject *buffer)
      Py_ssize_t param1;
      Py_ssize_t param2;
      PyObject *param3;
      static const char *keyword_list[] = {"to_start", "to_size", "buffer", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nnO:copy_subdata_from", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
#ifndef NDEBUG
        if (param2 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param2);
        }
#endif
        invoke_extension(local_this).copy_subdata_from((std::size_t)param1, (std::size_t)param2, param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 5:
    {
      {
        // -2 void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, GeomVertexArrayDataHandle const *other, std::size_t from_start, std::size_t from_size)
        Py_ssize_t param1;
        Py_ssize_t param2;
        PyObject *param3;
        Py_ssize_t param4;
        Py_ssize_t param5;
        static const char *keyword_list[] = {"to_start", "to_size", "other", "from_start", "from_size", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "nnOnn:copy_subdata_from", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
#ifndef NDEBUG
          if (param1 < 0) {
            return PyErr_Format(PyExc_OverflowError,
                                "can't convert negative value %zd to size_t",
                                param1);
          }
#endif
#ifndef NDEBUG
          if (param2 < 0) {
            return PyErr_Format(PyExc_OverflowError,
                                "can't convert negative value %zd to size_t",
                                param2);
          }
#endif
          GeomVertexArrayDataHandle const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_GeomVertexArrayDataHandle);
#ifndef NDEBUG
          if (param4 < 0) {
            return PyErr_Format(PyExc_OverflowError,
                                "can't convert negative value %zd to size_t",
                                param4);
          }
#endif
#ifndef NDEBUG
          if (param5 < 0) {
            return PyErr_Format(PyExc_OverflowError,
                                "can't convert negative value %zd to size_t",
                                param5);
          }
#endif
          if (param3_this != nullptr) {
            ((*local_this).copy_subdata_from)((std::size_t)param1, (std::size_t)param2, param3_this, (std::size_t)param4, (std::size_t)param5);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, PyObject *buffer, std::size_t from_start, std::size_t from_size)
        Py_ssize_t param1;
        Py_ssize_t param2;
        PyObject *param3;
        Py_ssize_t param4;
        Py_ssize_t param5;
        static const char *keyword_list[] = {"to_start", "to_size", "buffer", "from_start", "from_size", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "nnOnn:copy_subdata_from", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
#ifndef NDEBUG
          if (param1 < 0) {
            return PyErr_Format(PyExc_OverflowError,
                                "can't convert negative value %zd to size_t",
                                param1);
          }
#endif
#ifndef NDEBUG
          if (param2 < 0) {
            return PyErr_Format(PyExc_OverflowError,
                                "can't convert negative value %zd to size_t",
                                param2);
          }
#endif
#ifndef NDEBUG
          if (param4 < 0) {
            return PyErr_Format(PyExc_OverflowError,
                                "can't convert negative value %zd to size_t",
                                param4);
          }
#endif
#ifndef NDEBUG
          if (param5 < 0) {
            return PyErr_Format(PyExc_OverflowError,
                                "can't convert negative value %zd to size_t",
                                param5);
          }
#endif
          invoke_extension(local_this).copy_subdata_from((std::size_t)param1, (std::size_t)param2, param3, (std::size_t)param4, (std::size_t)param5);
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            return nullptr;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              return Dtool_Raise_AssertionError();
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, GeomVertexArrayDataHandle const *other, std::size_t from_start, std::size_t from_size)
      // No coercion possible: void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, PyObject *buffer, std::size_t from_start, std::size_t from_size)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "copy_subdata_from() takes 4 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_subdata_from(const GeomVertexArrayDataHandle self, int to_start, int to_size, object buffer)\n"
      "copy_subdata_from(const GeomVertexArrayDataHandle self, int to_start, int to_size, const GeomVertexArrayDataHandle other, int from_start, int from_size)\n"
      "copy_subdata_from(const GeomVertexArrayDataHandle self, int to_start, int to_size, object buffer, int from_start, int from_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_copy_subdata_from_436_comment =
  "C++ Interface:\n"
  "copy_subdata_from(const GeomVertexArrayDataHandle self, int to_start, int to_size, object buffer)\n"
  "copy_subdata_from(const GeomVertexArrayDataHandle self, int to_start, int to_size, const GeomVertexArrayDataHandle other, int from_start, int from_size)\n"
  "copy_subdata_from(const GeomVertexArrayDataHandle self, int to_start, int to_size, object buffer, int from_start, int from_size)\n"
  "\n"
  "/**\n"
  " * Copies a portion of the data array from the other object into a portion of\n"
  " * the data array of this object.  If to_size != from_size, the size of this\n"
  " * data array is adjusted accordingly.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies a portion of the data array from the buffer into a portion of the\n"
  " * data array of this object.  If to_size != from_size, the size of this data\n"
  " * array is adjusted accordingly.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_copy_subdata_from_436_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar GeomVertexArrayDataHandle::get_data(void) const
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_get_data_437(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayDataHandle)) {
    return nullptr;
  }
  // 1-inline vector_uchar GeomVertexArrayDataHandle::get_data(void) const
  vector_uchar return_value = ((*(const GeomVertexArrayDataHandle*)local_this).get_data)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_get_data_437_comment =
  "C++ Interface:\n"
  "get_data(GeomVertexArrayDataHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the entire raw data of the GeomVertexArrayData object, formatted as\n"
  " * a string.  This is primarily for the benefit of high-level languages such\n"
  " * as Python.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_get_data_437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayDataHandle::set_data(vector_uchar const &data)
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_set_data_438(PyObject *self, PyObject *arg) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this, "GeomVertexArrayDataHandle.set_data")) {
    return nullptr;
  }
  // 1-void GeomVertexArrayDataHandle::set_data(vector_uchar const &data)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    ((*local_this).set_data)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const GeomVertexArrayDataHandle self, bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_set_data_438_comment =
  "C++ Interface:\n"
  "set_data(const GeomVertexArrayDataHandle self, bytes data)\n"
  "\n"
  "/**\n"
  " * Replaces the entire raw data array with the contents of the indicated\n"
  " * string.  This is primarily for the benefit of high-level languages like\n"
  " * Python.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_set_data_438_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar GeomVertexArrayDataHandle::get_subdata(std::size_t start, std::size_t size) const
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_get_subdata_439(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayDataHandle)) {
    return nullptr;
  }
  // 1-inline vector_uchar GeomVertexArrayDataHandle::get_subdata(std::size_t start, std::size_t size) const
  Py_ssize_t param1;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"start", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nn:get_subdata", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    vector_uchar return_value = ((*(const GeomVertexArrayDataHandle*)local_this).get_subdata)((std::size_t)param1, (std::size_t)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(GeomVertexArrayDataHandle self, int start, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_get_subdata_439_comment =
  "C++ Interface:\n"
  "get_subdata(GeomVertexArrayDataHandle self, int start, int size)\n"
  "\n"
  "/**\n"
  " * Returns a subset of the raw data of the GeomVertexArrayData object,\n"
  " * formatted as a string.  This is primarily for the benefit of high-level\n"
  " * languages such as Python.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_get_subdata_439_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexArrayDataHandle::set_subdata(std::size_t start, std::size_t size, vector_uchar const &data)
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_set_subdata_440(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this, "GeomVertexArrayDataHandle.set_subdata")) {
    return nullptr;
  }
  // 1-void GeomVertexArrayDataHandle::set_subdata(std::size_t start, std::size_t size, vector_uchar const &data)
  Py_ssize_t param1;
  Py_ssize_t param2;
  unsigned char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"start", "size", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nn" FMTCHAR_BYTES "#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    ((*local_this).set_subdata)((std::size_t)param1, (std::size_t)param2, vector_uchar(param3_str, param3_str + param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const GeomVertexArrayDataHandle self, int start, int size, bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_set_subdata_440_comment =
  "C++ Interface:\n"
  "set_subdata(const GeomVertexArrayDataHandle self, int start, int size, bytes data)\n"
  "\n"
  "/**\n"
  " * Replaces a portion of the data array from the indicated string.  If size !=\n"
  " * data.size(), the size of this data array is adjusted accordingly.\n"
  " *\n"
  " * This is primarily for the benefit of high-level languages like Python.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_set_subdata_440_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexArrayDataHandle::mark_used(void) const
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_mark_used_441(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexArrayDataHandle)) {
    return nullptr;
  }
  // 1-inline void GeomVertexArrayDataHandle::mark_used(void) const
  ((*(const GeomVertexArrayDataHandle*)local_this).mark_used)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_mark_used_441_comment =
  "C++ Interface:\n"
  "mark_used(GeomVertexArrayDataHandle self)\n"
  "\n"
  "/**\n"
  " * Marks the array data recently-used.\n"
  " */";
#else
static const char *Dtool_GeomVertexArrayDataHandle_mark_used_441_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeomVertexArrayDataHandle::get_class_type(void)
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_get_class_type_442(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomVertexArrayDataHandle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomVertexArrayDataHandle::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_get_class_type_442_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomVertexArrayDataHandle_get_class_type_442_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *GeomVertexArrayDataHandle::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_upcast_to_ReferenceCount_412(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this, "GeomVertexArrayDataHandle.upcast_to_ReferenceCount")) {
    return nullptr;
  }
  // 1-ReferenceCount *GeomVertexArrayDataHandle::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_upcast_to_ReferenceCount_412_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const GeomVertexArrayDataHandle self)\n"
  "\n"
  "upcast from GeomVertexArrayDataHandle to ReferenceCount";
#else
static const char *Dtool_GeomVertexArrayDataHandle_upcast_to_ReferenceCount_412_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomEnums *GeomVertexArrayDataHandle::upcast_to_GeomEnums(void)
 */
static PyObject *Dtool_GeomVertexArrayDataHandle_upcast_to_GeomEnums_414(PyObject *self, PyObject *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this, "GeomVertexArrayDataHandle.upcast_to_GeomEnums")) {
    return nullptr;
  }
  // 1-GeomEnums *GeomVertexArrayDataHandle::upcast_to_GeomEnums(void)
  GeomEnums *return_value = (GeomEnums *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomEnums, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexArrayDataHandle_upcast_to_GeomEnums_414_comment =
  "C++ Interface:\n"
  "upcast_to_GeomEnums(const GeomVertexArrayDataHandle self)\n"
  "\n"
  "upcast from GeomVertexArrayDataHandle to GeomEnums";
#else
static const char *Dtool_GeomVertexArrayDataHandle_upcast_to_GeomEnums_414_comment = nullptr;
#endif

static PyObject *Dtool_GeomVertexArrayDataHandle_object_Getter(PyObject *self, void *) {
  GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this, "GeomVertexArrayDataHandle.object")) {
    return nullptr;
  }

  // 1-inline GeomVertexArrayData *GeomVertexArrayDataHandle::get_object(void)
  GeomVertexArrayData *return_value = ((*local_this).get_object)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexArrayData, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_GeomVertexArrayDataHandle_array_format_Getter(PyObject *self, void *) {
  const GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomVertexArrayFormat const *GeomVertexArrayDataHandle::get_array_format(void) const
  GeomVertexArrayFormat const *return_value = ((*(const GeomVertexArrayDataHandle*)local_this).get_array_format)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexArrayFormat, true, true);
}

static PyObject *Dtool_GeomVertexArrayDataHandle_usage_hint_Getter(PyObject *self, void *) {
  const GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::UsageHint GeomVertexArrayDataHandle::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const GeomVertexArrayDataHandle*)local_this).get_usage_hint)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomVertexArrayDataHandle_data_size_bytes_Getter(PyObject *self, void *) {
  const GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t GeomVertexArrayDataHandle::get_data_size_bytes(void) const
  std::size_t return_value = ((*(const GeomVertexArrayDataHandle*)local_this).get_data_size_bytes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomVertexArrayDataHandle_modified_Getter(PyObject *self, void *) {
  const GeomVertexArrayDataHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayDataHandle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq GeomVertexArrayDataHandle::get_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const GeomVertexArrayDataHandle*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

static int Dtool_Init_GeomVertexArrayDataHandle(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GeomVertexArrayDataHandle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomVertexArrayDataHandle) {
    printf("GeomVertexArrayDataHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomVertexArrayDataHandle *local_this = (GeomVertexArrayDataHandle *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomVertexArrayDataHandle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomVertexArrayDataHandle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomVertexArrayDataHandle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomVertexArrayDataHandle*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomVertexArrayDataHandle*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomCacheManager
 */
/**
 * Python function wrapper for:
 * inline void GeomCacheManager::set_max_size(int max_size) const
 */
static PyObject *Dtool_GeomCacheManager_set_max_size_444(PyObject *self, PyObject *arg) {
  GeomCacheManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomCacheManager)) {
    return nullptr;
  }
  // 1-inline void GeomCacheManager::set_max_size(int max_size) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*(const GeomCacheManager*)local_this).set_max_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_size(GeomCacheManager self, int max_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomCacheManager_set_max_size_444_comment =
  "C++ Interface:\n"
  "set_max_size(GeomCacheManager self, int max_size)\n"
  "\n"
  "/**\n"
  " * Specifies the maximum number of entries in the cache for storing pre-\n"
  " * processed data for rendering vertices.  This limit is flexible, and may be\n"
  " * temporarily exceeded if many different Geoms are pre-processed during the\n"
  " * space of a single frame.\n"
  " *\n"
  " * This is not a limit on the actual vertex data, which is what it is; it is\n"
  " * also not a limit on the amount of memory used by the video driver or the\n"
  " * system graphics interface, which Panda has no control over.\n"
  " */";
#else
static const char *Dtool_GeomCacheManager_set_max_size_444_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomCacheManager::get_max_size(void) const
 */
static PyObject *Dtool_GeomCacheManager_get_max_size_445(PyObject *self, PyObject *) {
  GeomCacheManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomCacheManager)) {
    return nullptr;
  }
  // 1-inline int GeomCacheManager::get_max_size(void) const
  int return_value = ((*(const GeomCacheManager*)local_this).get_max_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomCacheManager_get_max_size_445_comment =
  "C++ Interface:\n"
  "get_max_size(GeomCacheManager self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of entries in the cache for storing pre-\n"
  " * processed data for rendering vertices.  See set_max_size().\n"
  " */";
#else
static const char *Dtool_GeomCacheManager_get_max_size_445_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomCacheManager::get_total_size(void) const
 */
static PyObject *Dtool_GeomCacheManager_get_total_size_446(PyObject *self, PyObject *) {
  GeomCacheManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomCacheManager)) {
    return nullptr;
  }
  // 1-inline int GeomCacheManager::get_total_size(void) const
  int return_value = ((*(const GeomCacheManager*)local_this).get_total_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomCacheManager_get_total_size_446_comment =
  "C++ Interface:\n"
  "get_total_size(GeomCacheManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of entries currently in the cache.\n"
  " */";
#else
static const char *Dtool_GeomCacheManager_get_total_size_446_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomCacheManager::flush(void)
 */
static PyObject *Dtool_GeomCacheManager_flush_447(PyObject *self, PyObject *) {
  GeomCacheManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomCacheManager, (void **)&local_this, "GeomCacheManager.flush")) {
    return nullptr;
  }
  // 1-void GeomCacheManager::flush(void)
  ((*local_this).flush)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomCacheManager_flush_447_comment =
  "C++ Interface:\n"
  "flush(const GeomCacheManager self)\n"
  "\n"
  "/**\n"
  " * Immediately empties all elements in the cache.\n"
  " */";
#else
static const char *Dtool_GeomCacheManager_flush_447_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static GeomCacheManager *GeomCacheManager::get_global_ptr(void)
 */
static PyObject *Dtool_GeomCacheManager_get_global_ptr_448(PyObject *, PyObject *) {
  // 1-static GeomCacheManager *GeomCacheManager::get_global_ptr(void)
  GeomCacheManager *return_value = (GeomCacheManager::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomCacheManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomCacheManager_get_global_ptr_448_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns the global cache manager pointer.\n"
  " */";
#else
static const char *Dtool_GeomCacheManager_get_global_ptr_448_comment = nullptr;
#endif

static int Dtool_Init_GeomCacheManager(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GeomCacheManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomCacheManager) {
    printf("GeomCacheManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomCacheManager *local_this = (GeomCacheManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomCacheManager) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomCacheManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomCacheManager) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VertexTransform
 */
/**
 * Python function wrapper for:
 * virtual void VertexTransform::get_matrix(LMatrix4 &matrix) const = 0
 */
static PyObject *Dtool_VertexTransform_get_matrix_450(PyObject *self, PyObject *arg) {
  VertexTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexTransform)) {
    return nullptr;
  }
  // 1-virtual void VertexTransform::get_matrix(LMatrix4 &matrix) const = 0
  LMatrix4f arg_local;
  LMatrix4 *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VertexTransform.get_matrix", "LMatrix4f");
  }
  ((*(const VertexTransform*)local_this).get_matrix)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_matrix(VertexTransform self, LMatrix4f matrix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexTransform_get_matrix_450_comment =
  "C++ Interface:\n"
  "get_matrix(VertexTransform self, LMatrix4f matrix)\n";
#else
static const char *Dtool_VertexTransform_get_matrix_450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VertexTransform::mult_matrix(LMatrix4 &result, LMatrix4 const &previous) const
 */
static PyObject *Dtool_VertexTransform_mult_matrix_451(PyObject *self, PyObject *args, PyObject *kwds) {
  VertexTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexTransform)) {
    return nullptr;
  }
  // 1-virtual void VertexTransform::mult_matrix(LMatrix4 &result, LMatrix4 const &previous) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"result", "previous", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:mult_matrix", (char **)keyword_list, &param1, &param2)) {
    LMatrix4f param1_local;
    LMatrix4 *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VertexTransform.mult_matrix", "LMatrix4f");
    }
    LMatrix4f param2_local;
    LMatrix4 const *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VertexTransform.mult_matrix", "LMatrix4f");
    }
    ((*(const VertexTransform*)local_this).mult_matrix)(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mult_matrix(VertexTransform self, LMatrix4f result, const LMatrix4f previous)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexTransform_mult_matrix_451_comment =
  "C++ Interface:\n"
  "mult_matrix(VertexTransform self, LMatrix4f result, const LMatrix4f previous)\n"
  "\n"
  "/**\n"
  " * Premultiplies this transform's matrix with the indicated previous matrix,\n"
  " * so that the result is the net composition of the given transform with this\n"
  " * transform.  The result is stored in the parameter \"result\", which should\n"
  " * not be the same matrix as previous.\n"
  " */";
#else
static const char *Dtool_VertexTransform_mult_matrix_451_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VertexTransform::accumulate_matrix(LMatrix4 &accum, PN_stdfloat weight) const
 */
static PyObject *Dtool_VertexTransform_accumulate_matrix_452(PyObject *self, PyObject *args, PyObject *kwds) {
  VertexTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexTransform)) {
    return nullptr;
  }
  // 1-virtual void VertexTransform::accumulate_matrix(LMatrix4 &accum, PN_stdfloat weight) const
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"accum", "weight", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:accumulate_matrix", (char **)keyword_list, &param1, &param2)) {
    LMatrix4f param1_local;
    LMatrix4 *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VertexTransform.accumulate_matrix", "LMatrix4f");
    }
    ((*(const VertexTransform*)local_this).accumulate_matrix)(*param1_this, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "accumulate_matrix(VertexTransform self, LMatrix4f accum, float weight)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexTransform_accumulate_matrix_452_comment =
  "C++ Interface:\n"
  "accumulate_matrix(VertexTransform self, LMatrix4f accum, float weight)\n"
  "\n"
  "/**\n"
  " * Adds the value of this transform's matrix, modified by the indicated\n"
  " * weight, into the indicated accumulation matrix.  This is used to compute\n"
  " * the result of several blended transforms.\n"
  " */";
#else
static const char *Dtool_VertexTransform_accumulate_matrix_452_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq VertexTransform::get_modified(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_VertexTransform_get_modified_453(PyObject *self, PyObject *args, PyObject *kwds) {
  VertexTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexTransform)) {
    return nullptr;
  }
  // 1-inline UpdateSeq VertexTransform::get_modified(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "VertexTransform.get_modified", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      UpdateSeq *return_value = new UpdateSeq(((*(const VertexTransform*)local_this).get_modified)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_modified(VertexTransform self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexTransform_get_modified_453_comment =
  "C++ Interface:\n"
  "get_modified(VertexTransform self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number that's guaranteed to change at least every time\n"
  " * the value reported by get_matrix() changes.\n"
  " */";
#else
static const char *Dtool_VertexTransform_get_modified_453_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VertexTransform::output(std::ostream &out) const
 */
static PyObject *Dtool_VertexTransform_output_455(PyObject *self, PyObject *arg) {
  VertexTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexTransform)) {
    return nullptr;
  }
  // 1-virtual void VertexTransform::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "VertexTransform.output", false, true);
  if (arg_this != nullptr) {
    ((*(const VertexTransform*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(VertexTransform self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexTransform_output_455_comment =
  "C++ Interface:\n"
  "output(VertexTransform self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VertexTransform_output_455_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VertexTransform::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_VertexTransform_write_456(PyObject *self, PyObject *args, PyObject *kwds) {
  VertexTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexTransform)) {
    return nullptr;
  }
  // 1-virtual void VertexTransform::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "VertexTransform.write", false, true);
    if (param1_this != nullptr) {
      ((*(const VertexTransform*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(VertexTransform self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexTransform_write_456_comment =
  "C++ Interface:\n"
  "write(VertexTransform self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VertexTransform_write_456_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static UpdateSeq VertexTransform::get_next_modified(Thread *current_thread)
 */
static PyObject *Dtool_VertexTransform_get_next_modified_457(PyObject *, PyObject *arg) {
  // 1-static UpdateSeq VertexTransform::get_next_modified(Thread *current_thread)
  Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 0, "VertexTransform.get_next_modified", false, true);
  if (arg_this != nullptr) {
    UpdateSeq *return_value = new UpdateSeq((VertexTransform::get_next_modified)(arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_modified(Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexTransform_get_next_modified_457_comment =
  "C++ Interface:\n"
  "get_next_modified(Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a monotonically increasing sequence.  Each time this is called, a\n"
  " * new sequence number is returned, higher than the previous value.\n"
  " *\n"
  " * This is used to ensure that all VertexTransform::get_modified() calls\n"
  " * return an increasing number in the same space, so that\n"
  " * TransformBlend::get_modified() is easy to determine.  It is similar to\n"
  " * Geom::get_modified(), but it is in a different space.\n"
  " */";
#else
static const char *Dtool_VertexTransform_get_next_modified_457_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline UpdateSeq VertexTransform::get_global_modified(Thread *current_thread)
 */
static PyObject *Dtool_VertexTransform_get_global_modified_458(PyObject *, PyObject *arg) {
  // 1-static inline UpdateSeq VertexTransform::get_global_modified(Thread *current_thread)
  Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 0, "VertexTransform.get_global_modified", false, true);
  if (arg_this != nullptr) {
    UpdateSeq *return_value = new UpdateSeq((VertexTransform::get_global_modified)(arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_global_modified(Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexTransform_get_global_modified_458_comment =
  "C++ Interface:\n"
  "get_global_modified(Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the currently highest VertexTransform::get_modified() value in the\n"
  " * world.  This can be used as a quick way to determine if any\n"
  " * VertexTransforms have changed value recently.\n"
  " */";
#else
static const char *Dtool_VertexTransform_get_global_modified_458_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VertexTransform::get_class_type(void)
 */
static PyObject *Dtool_VertexTransform_get_class_type_459(PyObject *, PyObject *) {
  // 1-static TypeHandle VertexTransform::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VertexTransform::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexTransform_get_class_type_459_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VertexTransform_get_class_type_459_comment = nullptr;
#endif

static PyObject *Dtool_VertexTransform_modified_Getter(PyObject *self, void *) {
  const VertexTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VertexTransform, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq VertexTransform::get_modified(Thread *current_thread) const
  UpdateSeq *return_value = new UpdateSeq(((*(const VertexTransform*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

static int Dtool_Init_VertexTransform(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VertexTransform(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VertexTransform) {
    printf("VertexTransform ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VertexTransform *local_this = (VertexTransform *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VertexTransform) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VertexTransform(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VertexTransform) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (VertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (VertexTransform*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TransformTable
 */
/**
 * Python function wrapper for:
 * void TransformTable::operator =(TransformTable const &copy)
 */
static PyObject *Dtool_TransformTable_operator_462(PyObject *self, PyObject *arg) {
  TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformTable, (void **)&local_this, "TransformTable.assign")) {
    return nullptr;
  }
  // 1-void TransformTable::operator =(TransformTable const &copy)
  TransformTable const *arg_this = (TransformTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformTable, 1, "TransformTable.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    TransformTable *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TransformTable, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TransformTable self, const TransformTable copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_operator_462_comment =
  "C++ Interface:\n"
  "assign(const TransformTable self, const TransformTable copy)\n";
#else
static const char *Dtool_TransformTable_operator_462_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TransformTable::is_registered(void) const
 */
static PyObject *Dtool_TransformTable_is_registered_463(PyObject *self, PyObject *) {
  TransformTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformTable)) {
    return nullptr;
  }
  // 1-inline bool TransformTable::is_registered(void) const
  bool return_value = ((*(const TransformTable*)local_this).is_registered)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_is_registered_463_comment =
  "C++ Interface:\n"
  "is_registered(TransformTable self)\n"
  "\n"
  "/**\n"
  " * Returns true if this table has been registered.  Once it has been\n"
  " * registered, the set of transforms in a TransformTable may not be further\n"
  " * modified; but it must be registered before it can be assigned to a Geom.\n"
  " */";
#else
static const char *Dtool_TransformTable_is_registered_463_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< TransformTable > TransformTable::register_table(TransformTable const *table)
 */
static PyObject *Dtool_TransformTable_register_table_464(PyObject *, PyObject *arg) {
  // 1-static inline ConstPointerTo< TransformTable > TransformTable::register_table(TransformTable const *table)
  TransformTable const *arg_this = (TransformTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformTable, 0, "TransformTable.register_table", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< TransformTable > return_value = (TransformTable::register_table)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TransformTable const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TransformTable, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_table(const TransformTable table)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_register_table_464_comment =
  "C++ Interface:\n"
  "register_table(const TransformTable table)\n"
  "\n"
  "/**\n"
  " * Registers a TransformTable for use.  This is similar to\n"
  " * GeomVertexFormat::register_format().  Once registered, a TransformTable may\n"
  " * no longer be modified (although the individual VertexTransform objects may\n"
  " * modify their reported transforms).\n"
  " *\n"
  " * This must be called before a table may be used in a Geom.  After this call,\n"
  " * you should discard the original pointer you passed in (which may or may not\n"
  " * now be invalid) and let its reference count decrement normally; you should\n"
  " * use only the returned value from this point on.\n"
  " */";
#else
static const char *Dtool_TransformTable_register_table_464_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TransformTable::get_num_transforms(void) const
 */
static PyObject *Dtool_TransformTable_get_num_transforms_465(PyObject *self, PyObject *) {
  TransformTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformTable)) {
    return nullptr;
  }
  // 1-inline std::size_t TransformTable::get_num_transforms(void) const
  std::size_t return_value = ((*(const TransformTable*)local_this).get_num_transforms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_get_num_transforms_465_comment =
  "C++ Interface:\n"
  "get_num_transforms(TransformTable self)\n"
  "\n"
  "/**\n"
  " * Returns the number of transforms in the table.\n"
  " */";
#else
static const char *Dtool_TransformTable_get_num_transforms_465_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VertexTransform const *TransformTable::get_transform(std::size_t n) const
 */
static PyObject *Dtool_TransformTable_get_transform_466(PyObject *self, PyObject *arg) {
  TransformTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformTable)) {
    return nullptr;
  }
  // 1-inline VertexTransform const *TransformTable::get_transform(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    VertexTransform const *return_value = ((*(const TransformTable*)local_this).get_transform)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VertexTransform, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_transform(TransformTable self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_get_transform_466_comment =
  "C++ Interface:\n"
  "get_transform(TransformTable self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth transform in the table.\n"
  " */";
#else
static const char *Dtool_TransformTable_get_transform_466_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq TransformTable::get_modified(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_TransformTable_get_modified_468(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformTable)) {
    return nullptr;
  }
  // 1-inline UpdateSeq TransformTable::get_modified(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "TransformTable.get_modified", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      UpdateSeq *return_value = new UpdateSeq(((*(const TransformTable*)local_this).get_modified)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_modified(TransformTable self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_get_modified_468_comment =
  "C++ Interface:\n"
  "get_modified(TransformTable self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number that's guaranteed to change at least when any\n"
  " * VertexTransforms in the table change.  (However, this is only true for a\n"
  " * registered table.  An unregistered table may or may not reflect an update\n"
  " * here when a VertexTransform changes.)\n"
  " */";
#else
static const char *Dtool_TransformTable_get_modified_468_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformTable::set_transform(std::size_t n, VertexTransform const *transform)
 */
static PyObject *Dtool_TransformTable_set_transform_469(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformTable, (void **)&local_this, "TransformTable.set_transform")) {
    return nullptr;
  }
  // 1-void TransformTable::set_transform(std::size_t n, VertexTransform const *transform)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "transform", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_transform", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    VertexTransform const *param2_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_VertexTransform, 2, "TransformTable.set_transform", true, true);
    if (param2_this != nullptr) {
      ((*local_this).set_transform)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform(const TransformTable self, int n, const VertexTransform transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_set_transform_469_comment =
  "C++ Interface:\n"
  "set_transform(const TransformTable self, int n, const VertexTransform transform)\n"
  "\n"
  "/**\n"
  " * Replaces the nth transform.  Only valid for unregistered tables.\n"
  " */";
#else
static const char *Dtool_TransformTable_set_transform_469_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformTable::insert_transform(std::size_t n, VertexTransform const *transform)
 */
static PyObject *Dtool_TransformTable_insert_transform_470(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformTable, (void **)&local_this, "TransformTable.insert_transform")) {
    return nullptr;
  }
  // 1-void TransformTable::insert_transform(std::size_t n, VertexTransform const *transform)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "transform", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:insert_transform", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    VertexTransform const *param2_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_VertexTransform, 2, "TransformTable.insert_transform", true, true);
    if (param2_this != nullptr) {
      ((*local_this).insert_transform)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_transform(const TransformTable self, int n, const VertexTransform transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_insert_transform_470_comment =
  "C++ Interface:\n"
  "insert_transform(const TransformTable self, int n, const VertexTransform transform)\n"
  "\n"
  "/**\n"
  " * Inserts a new transform to the table at the given index position.  If the\n"
  " * index is beyond the end of the table, appends it to the end.  Only valid\n"
  " * for unregistered tables.\n"
  " *\n"
  " * This does not automatically uniquify the pointer; if the transform is\n"
  " * already present in the table, it will be added twice.\n"
  " */";
#else
static const char *Dtool_TransformTable_insert_transform_470_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformTable::remove_transform(std::size_t n)
 */
static PyObject *Dtool_TransformTable_remove_transform_471(PyObject *self, PyObject *arg) {
  TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformTable, (void **)&local_this, "TransformTable.remove_transform")) {
    return nullptr;
  }
  // 1-void TransformTable::remove_transform(std::size_t n)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).remove_transform)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_transform(const TransformTable self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_remove_transform_471_comment =
  "C++ Interface:\n"
  "remove_transform(const TransformTable self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the nth transform.  Only valid for unregistered tables.\n"
  " */";
#else
static const char *Dtool_TransformTable_remove_transform_471_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t TransformTable::add_transform(VertexTransform const *transform)
 */
static PyObject *Dtool_TransformTable_add_transform_472(PyObject *self, PyObject *arg) {
  TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformTable, (void **)&local_this, "TransformTable.add_transform")) {
    return nullptr;
  }
  // 1-std::size_t TransformTable::add_transform(VertexTransform const *transform)
  VertexTransform const *arg_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VertexTransform, 1, "TransformTable.add_transform", true, true);
  if (arg_this != nullptr) {
    std::size_t return_value = ((*local_this).add_transform)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_transform(const TransformTable self, const VertexTransform transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_add_transform_472_comment =
  "C++ Interface:\n"
  "add_transform(const TransformTable self, const VertexTransform transform)\n"
  "\n"
  "/**\n"
  " * Adds a new transform to the table and returns the index number of the new\n"
  " * transform.  Only valid for unregistered tables.\n"
  " *\n"
  " * This does not automatically uniquify the pointer; if the transform is\n"
  " * already present in the table, it will be added twice.\n"
  " */";
#else
static const char *Dtool_TransformTable_add_transform_472_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformTable::write(std::ostream &out) const
 */
static PyObject *Dtool_TransformTable_write_473(PyObject *self, PyObject *arg) {
  TransformTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformTable)) {
    return nullptr;
  }
  // 1-void TransformTable::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "TransformTable.write", false, true);
  if (arg_this != nullptr) {
    ((*(const TransformTable*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TransformTable self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_write_473_comment =
  "C++ Interface:\n"
  "write(TransformTable self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TransformTable_write_473_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TransformTable::get_class_type(void)
 */
static PyObject *Dtool_TransformTable_get_class_type_479(PyObject *, PyObject *) {
  // 1-static TypeHandle TransformTable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TransformTable::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TransformTable_get_class_type_479_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TransformTable_get_class_type_479_comment = nullptr;
#endif

static PyObject *Dtool_TransformTable_registered_Getter(PyObject *self, void *) {
  const TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformTable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool TransformTable::is_registered(void) const
  bool return_value = ((*(const TransformTable*)local_this).is_registered)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TransformTable_modified_Getter(PyObject *self, void *) {
  const TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformTable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq TransformTable::get_modified(Thread *current_thread) const
  UpdateSeq *return_value = new UpdateSeq(((*(const TransformTable*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

/**
 * sequence length function for property TransformTable::transforms
 */
static Py_ssize_t Dtool_TransformTable_transforms_Len(PyObject *self) {
  TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformTable, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_transforms)();
}

/**
 * sequence getter for property TransformTable::transforms
 */
static PyObject *Dtool_TransformTable_transforms_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformTable, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_transforms)()) {
    PyErr_SetString(PyExc_IndexError, "TransformTable.transforms[] index out of range");
    return nullptr;
  }
  // 1-inline VertexTransform const *TransformTable::get_transform(std::size_t n) const
  VertexTransform const *return_value = ((*(const TransformTable*)local_this).get_transform)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VertexTransform, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_transform(TransformTable self, index)\n");
  }
}

static int Dtool_TransformTable_transforms_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformTable, (void **)&local_this, "TransformTable.transforms")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_transforms)()) {
    PyErr_SetString(PyExc_IndexError, "TransformTable.transforms[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    local_this->remove_transform(index);
    return 0;
  }
  // 1-void TransformTable::set_transform(std::size_t n, VertexTransform const *transform)
  VertexTransform const *arg_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VertexTransform, 2, "TransformTable.set_transform", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_transform)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_transform(const TransformTable self, index, const VertexTransform transform)\n");
  }
  return -1;
}

static PyObject *Dtool_TransformTable_transforms_Sequence_insert(PyObject *self, size_t index, PyObject *arg) {
  TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformTable, (void **)&local_this, "TransformTable.transforms")) {
    return nullptr;
  }

  // 1-void TransformTable::insert_transform(std::size_t n, VertexTransform const *transform)
  VertexTransform const *arg_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VertexTransform, 2, "TransformTable.insert_transform", true, true);
  if (arg_this != nullptr) {
    ((*local_this).insert_transform)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "insert_transform(const TransformTable self, index, const VertexTransform transform)\n");
  }
  return nullptr;
}

static PyObject *Dtool_TransformTable_transforms_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "TransformTable.transforms");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_TransformTable_transforms_Len;
    wrap->_getitem_func = &Dtool_TransformTable_transforms_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_TransformTable_transforms_Sequence_Setitem;
      wrap->_insert_func = &Dtool_TransformTable_transforms_Sequence_insert;
    }
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * TransformTable::TransformTable(void)
 * TransformTable::TransformTable(TransformTable const &copy)
 */
static int Dtool_Init_TransformTable(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TransformTable::TransformTable(void)
      TransformTable *return_value = new TransformTable();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TransformTable, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-TransformTable::TransformTable(TransformTable const &copy)
        TransformTable const *arg_this = (TransformTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformTable, 0, "TransformTable.TransformTable", true, true);
        if (arg_this != nullptr) {
          TransformTable *return_value = new TransformTable(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TransformTable, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TransformTable() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TransformTable()\n"
      "TransformTable(const TransformTable copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TransformTable_get_transforms(PyObject *self, PyObject *) {
  TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformTable, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_transforms)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TransformTable_get_transform_466(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_TransformTable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TransformTable) {
    printf("TransformTable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TransformTable *local_this = (TransformTable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TransformTable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TransformTable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TransformTable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TransformTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TransformTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TransformTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TransformTable*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TransformBlend
 */
/**
 * Python function wrapper for:
 * inline void TransformBlend::operator =(TransformBlend const &copy)
 */
static PyObject *Dtool_TransformBlend_operator_482(PyObject *self, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlend, (void **)&local_this, "TransformBlend.assign")) {
    return nullptr;
  }
  // 1-inline void TransformBlend::operator =(TransformBlend const &copy)
  TransformBlend arg_local;
  TransformBlend const *arg_this = Dtool_Coerce_TransformBlend(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TransformBlend.assign", "TransformBlend");
  }
  ((*local_this).operator =)(*arg_this);
  TransformBlend *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformBlend, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TransformBlend self, const TransformBlend copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_operator_482_comment =
  "C++ Interface:\n"
  "assign(const TransformBlend self, const TransformBlend copy)\n";
#else
static const char *Dtool_TransformBlend_operator_482_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TransformBlend::compare_to(TransformBlend const &other) const
 */
static PyObject *Dtool_TransformBlend_compare_to_484(PyObject *self, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  // 1-int TransformBlend::compare_to(TransformBlend const &other) const
  TransformBlend arg_local;
  TransformBlend const *arg_this = Dtool_Coerce_TransformBlend(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TransformBlend.compare_to", "TransformBlend");
  }
  int return_value = ((*(const TransformBlend*)local_this).compare_to)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(TransformBlend self, const TransformBlend other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_compare_to_484_comment =
  "C++ Interface:\n"
  "compare_to(TransformBlend self, const TransformBlend other)\n"
  "\n"
  "/**\n"
  " * Defines an arbitrary ordering for TransformBlend objects.\n"
  " */";
#else
static const char *Dtool_TransformBlend_compare_to_484_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformBlend::add_transform(VertexTransform const *transform, PN_stdfloat weight)
 */
static PyObject *Dtool_TransformBlend_add_transform_488(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlend, (void **)&local_this, "TransformBlend.add_transform")) {
    return nullptr;
  }
  // 1-void TransformBlend::add_transform(VertexTransform const *transform, PN_stdfloat weight)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"transform", "weight", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:add_transform", (char **)keyword_list, &param1, &param2)) {
    VertexTransform const *param1_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_VertexTransform, 1, "TransformBlend.add_transform", true, true);
    if (param1_this != nullptr) {
      ((*local_this).add_transform)(param1_this, (PN_stdfloat)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_transform(const TransformBlend self, const VertexTransform transform, float weight)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_add_transform_488_comment =
  "C++ Interface:\n"
  "add_transform(const TransformBlend self, const VertexTransform transform, float weight)\n"
  "\n"
  "/**\n"
  " * Adds a new transform to the blend.  If the transform already existed,\n"
  " * increases its weight factor.\n"
  " */";
#else
static const char *Dtool_TransformBlend_add_transform_488_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformBlend::remove_transform(VertexTransform const *transform)
 * inline void TransformBlend::remove_transform(std::size_t n)
 */
static PyObject *Dtool_TransformBlend_remove_transform_489(PyObject *self, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlend, (void **)&local_this, "TransformBlend.remove_transform")) {
    return nullptr;
  }
  {
    // -2 void TransformBlend::remove_transform(VertexTransform const *transform)
    VertexTransform const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_VertexTransform);
    if (arg_this != nullptr) {
      ((*local_this).remove_transform)(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void TransformBlend::remove_transform(std::size_t n)
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      ((*local_this).remove_transform)(arg_val);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void TransformBlend::remove_transform(VertexTransform const *transform)
  // No coercion possible: inline void TransformBlend::remove_transform(std::size_t n)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_transform(const TransformBlend self, const VertexTransform transform)\n"
      "remove_transform(const TransformBlend self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_remove_transform_489_comment =
  "C++ Interface:\n"
  "remove_transform(const TransformBlend self, const VertexTransform transform)\n"
  "remove_transform(const TransformBlend self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the nth transform stored in the blend object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the indicated transform from the blend.\n"
  " */";
#else
static const char *Dtool_TransformBlend_remove_transform_489_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformBlend::limit_transforms(int max_transforms)
 */
static PyObject *Dtool_TransformBlend_limit_transforms_490(PyObject *self, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlend, (void **)&local_this, "TransformBlend.limit_transforms")) {
    return nullptr;
  }
  // 1-void TransformBlend::limit_transforms(int max_transforms)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).limit_transforms)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "limit_transforms(const TransformBlend self, int max_transforms)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_limit_transforms_490_comment =
  "C++ Interface:\n"
  "limit_transforms(const TransformBlend self, int max_transforms)\n"
  "\n"
  "/**\n"
  " * If the total number of transforms in the blend exceeds max_transforms,\n"
  " * removes the n least-important transforms as needed to reduce the number of\n"
  " * transforms to max_transforms.\n"
  " */";
#else
static const char *Dtool_TransformBlend_limit_transforms_490_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformBlend::normalize_weights(void)
 */
static PyObject *Dtool_TransformBlend_normalize_weights_491(PyObject *self, PyObject *) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlend, (void **)&local_this, "TransformBlend.normalize_weights")) {
    return nullptr;
  }
  // 1-void TransformBlend::normalize_weights(void)
  ((*local_this).normalize_weights)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_normalize_weights_491_comment =
  "C++ Interface:\n"
  "normalize_weights(const TransformBlend self)\n"
  "\n"
  "/**\n"
  " * Rescales all of the weights on the various transforms so that they sum to\n"
  " * 1.0.  It is generally a good idea to call this after adding or removing\n"
  " * transforms from the blend.\n"
  " */";
#else
static const char *Dtool_TransformBlend_normalize_weights_491_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TransformBlend::has_transform(VertexTransform const *transform) const
 */
static PyObject *Dtool_TransformBlend_has_transform_492(PyObject *self, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  // 1-bool TransformBlend::has_transform(VertexTransform const *transform) const
  VertexTransform const *arg_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VertexTransform, 1, "TransformBlend.has_transform", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const TransformBlend*)local_this).has_transform)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_transform(TransformBlend self, const VertexTransform transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_has_transform_492_comment =
  "C++ Interface:\n"
  "has_transform(TransformBlend self, const VertexTransform transform)\n"
  "\n"
  "/**\n"
  " * Returns true if the blend has the indicated transform, false otherwise.\n"
  " */";
#else
static const char *Dtool_TransformBlend_has_transform_492_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat TransformBlend::get_weight(VertexTransform const *transform) const
 * inline PN_stdfloat TransformBlend::get_weight(std::size_t n) const
 */
static PyObject *Dtool_TransformBlend_get_weight_493(PyObject *self, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  {
    // -2 PN_stdfloat TransformBlend::get_weight(VertexTransform const *transform) const
    VertexTransform const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_VertexTransform);
    if (arg_this != nullptr) {
      PN_stdfloat return_value = ((*(const TransformBlend*)local_this).get_weight)(arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline PN_stdfloat TransformBlend::get_weight(std::size_t n) const
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      PN_stdfloat return_value = ((*(const TransformBlend*)local_this).get_weight)(arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: PN_stdfloat TransformBlend::get_weight(VertexTransform const *transform) const
  // No coercion possible: inline PN_stdfloat TransformBlend::get_weight(std::size_t n) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_weight(TransformBlend self, const VertexTransform transform)\n"
      "get_weight(TransformBlend self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_get_weight_493_comment =
  "C++ Interface:\n"
  "get_weight(TransformBlend self, const VertexTransform transform)\n"
  "get_weight(TransformBlend self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the weight associated with the nth transform stored in the blend\n"
  " * object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the weight associated with the indicated transform, or 0 if there\n"
  " * is no entry for the transform.\n"
  " */";
#else
static const char *Dtool_TransformBlend_get_weight_493_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TransformBlend::get_num_transforms(void) const
 */
static PyObject *Dtool_TransformBlend_get_num_transforms_494(PyObject *self, PyObject *) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  // 1-inline std::size_t TransformBlend::get_num_transforms(void) const
  std::size_t return_value = ((*(const TransformBlend*)local_this).get_num_transforms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_get_num_transforms_494_comment =
  "C++ Interface:\n"
  "get_num_transforms(TransformBlend self)\n"
  "\n"
  "/**\n"
  " * Returns the number of transforms stored in the blend object.\n"
  " */";
#else
static const char *Dtool_TransformBlend_get_num_transforms_494_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VertexTransform const *TransformBlend::get_transform(std::size_t n) const
 */
static PyObject *Dtool_TransformBlend_get_transform_495(PyObject *self, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  // 1-inline VertexTransform const *TransformBlend::get_transform(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    VertexTransform const *return_value = ((*(const TransformBlend*)local_this).get_transform)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VertexTransform, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_transform(TransformBlend self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_get_transform_495_comment =
  "C++ Interface:\n"
  "get_transform(TransformBlend self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth transform stored in the blend object.\n"
  " */";
#else
static const char *Dtool_TransformBlend_get_transform_495_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TransformBlend::set_transform(std::size_t n, VertexTransform const *transform)
 */
static PyObject *Dtool_TransformBlend_set_transform_497(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlend, (void **)&local_this, "TransformBlend.set_transform")) {
    return nullptr;
  }
  // 1-inline void TransformBlend::set_transform(std::size_t n, VertexTransform const *transform)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "transform", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_transform", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    VertexTransform const *param2_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_VertexTransform, 2, "TransformBlend.set_transform", true, true);
    if (param2_this != nullptr) {
      ((*local_this).set_transform)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform(const TransformBlend self, int n, const VertexTransform transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_set_transform_497_comment =
  "C++ Interface:\n"
  "set_transform(const TransformBlend self, int n, const VertexTransform transform)\n"
  "\n"
  "/**\n"
  " * Replaces the nth transform stored in the blend object.\n"
  " */";
#else
static const char *Dtool_TransformBlend_set_transform_497_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TransformBlend::set_weight(std::size_t n, PN_stdfloat weight)
 */
static PyObject *Dtool_TransformBlend_set_weight_498(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlend, (void **)&local_this, "TransformBlend.set_weight")) {
    return nullptr;
  }
  // 1-inline void TransformBlend::set_weight(std::size_t n, PN_stdfloat weight)
  Py_ssize_t param1;
  float param2;
  static const char *keyword_list[] = {"n", "weight", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nf:set_weight", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_weight)((std::size_t)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_weight(const TransformBlend self, int n, float weight)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_set_weight_498_comment =
  "C++ Interface:\n"
  "set_weight(const TransformBlend self, int n, float weight)\n"
  "\n"
  "/**\n"
  " * Replaces the weight associated with the nth transform stored in the blend\n"
  " * object.\n"
  " */";
#else
static const char *Dtool_TransformBlend_set_weight_498_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TransformBlend::update_blend(Thread *current_thread) const
 */
static PyObject *Dtool_TransformBlend_update_blend_503(PyObject *self, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  // 1-inline void TransformBlend::update_blend(Thread *current_thread) const
  Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "TransformBlend.update_blend", false, true);
  if (arg_this != nullptr) {
    ((*(const TransformBlend*)local_this).update_blend)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update_blend(TransformBlend self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_update_blend_503_comment =
  "C++ Interface:\n"
  "update_blend(TransformBlend self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Recomputes the internal representation of the blend value, if necessary.\n"
  " * You should call this before calling get_blend() or transform_point().\n"
  " */";
#else
static const char *Dtool_TransformBlend_update_blend_503_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TransformBlend::get_blend(LMatrix4 &result, Thread *current_thread) const
 */
static PyObject *Dtool_TransformBlend_get_blend_504(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  // 1-inline void TransformBlend::get_blend(LMatrix4 &result, Thread *current_thread) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"result", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_blend", (char **)keyword_list, &param1, &param2)) {
    LMatrix4f param1_local;
    LMatrix4 *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TransformBlend.get_blend", "LMatrix4f");
    }
    Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.get_blend", false, true);
    if (param2_this != nullptr) {
      ((*(const TransformBlend*)local_this).get_blend)(*param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_blend(TransformBlend self, LMatrix4f result, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_get_blend_504_comment =
  "C++ Interface:\n"
  "get_blend(TransformBlend self, LMatrix4f result, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the current value of the blend, based on the current value of all\n"
  " * of the nested transform objects and their associated weights.\n"
  " *\n"
  " * You should call update_blend() to ensure that the cache is up-to-date\n"
  " * before calling this.\n"
  " */";
#else
static const char *Dtool_TransformBlend_get_blend_504_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TransformBlend::transform_point(LPoint3d &point, Thread *current_thread) const
 * inline void TransformBlend::transform_point(LPoint3f &point, Thread *current_thread) const
 * inline void TransformBlend::transform_point(LPoint4d &point, Thread *current_thread) const
 * inline void TransformBlend::transform_point(LPoint4f &point, Thread *current_thread) const
 */
static PyObject *Dtool_TransformBlend_transform_point_505(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  {
    // -2 inline void TransformBlend::transform_point(LPoint3d &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_point", (char **)keyword_list, &param1, &param2)) {
      LPoint3d *param1_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LPoint3d, 1, "TransformBlend.transform_point", false, false);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_point", false, false);
      if (param1_this != nullptr && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_point)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TransformBlend::transform_point(LPoint3f &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_point", (char **)keyword_list, &param1, &param2)) {
      LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LPoint3f, 1, "TransformBlend.transform_point", false, false);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_point", false, false);
      if (param1_this != nullptr && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_point)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TransformBlend::transform_point(LPoint4d &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_point", (char **)keyword_list, &param1, &param2)) {
      LPoint4d *param1_this = (LPoint4d *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LPoint4d, 1, "TransformBlend.transform_point", false, false);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_point", false, false);
      if (param1_this != nullptr && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_point)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TransformBlend::transform_point(LPoint4f &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_point", (char **)keyword_list, &param1, &param2)) {
      LPoint4f *param1_this = (LPoint4f *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LPoint4f, 1, "TransformBlend.transform_point", false, false);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_point", false, false);
      if (param1_this != nullptr && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_point)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TransformBlend::transform_point(LPoint3d &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_point", (char **)keyword_list, &param1, &param2)) {
      LPoint3d param1_local;
      LPoint3d *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_point", false, false);
      if ((param1_this != nullptr) && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_point)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TransformBlend::transform_point(LPoint3f &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_point", (char **)keyword_list, &param1, &param2)) {
      LPoint3f param1_local;
      LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_point", false, false);
      if ((param1_this != nullptr) && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_point)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TransformBlend::transform_point(LPoint4d &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_point", (char **)keyword_list, &param1, &param2)) {
      LPoint4d param1_local;
      LPoint4d *param1_this = Dtool_Coerce_LPoint4d(param1, param1_local);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_point", false, false);
      if ((param1_this != nullptr) && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_point)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TransformBlend::transform_point(LPoint4f &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_point", (char **)keyword_list, &param1, &param2)) {
      LPoint4f param1_local;
      LPoint4f *param1_this = Dtool_Coerce_LPoint4f(param1, param1_local);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_point", false, false);
      if ((param1_this != nullptr) && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_point)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform_point(TransformBlend self, LPoint3d point, Thread current_thread)\n"
      "transform_point(TransformBlend self, LPoint3f point, Thread current_thread)\n"
      "transform_point(TransformBlend self, LPoint4d point, Thread current_thread)\n"
      "transform_point(TransformBlend self, LPoint4f point, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_transform_point_505_comment =
  "C++ Interface:\n"
  "transform_point(TransformBlend self, LPoint3d point, Thread current_thread)\n"
  "transform_point(TransformBlend self, LPoint3f point, Thread current_thread)\n"
  "transform_point(TransformBlend self, LPoint4d point, Thread current_thread)\n"
  "transform_point(TransformBlend self, LPoint4f point, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Transforms the indicated point by the blend matrix.\n"
  " *\n"
  " * You should call update_blend() to ensure that the cache is up-to-date\n"
  " * before calling this.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Transforms the indicated point by the blend matrix.\n"
  " *\n"
  " * You should call update_blend() to ensure that the cache is up-to-date\n"
  " * before calling this.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Transforms the indicated point by the blend matrix.\n"
  " *\n"
  " * You should call update_blend() to ensure that the cache is up-to-date\n"
  " * before calling this.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Transforms the indicated point by the blend matrix.\n"
  " *\n"
  " * You should call update_blend() to ensure that the cache is up-to-date\n"
  " * before calling this.\n"
  " */";
#else
static const char *Dtool_TransformBlend_transform_point_505_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TransformBlend::transform_vector(LVector3d &point, Thread *current_thread) const
 * inline void TransformBlend::transform_vector(LVector3f &point, Thread *current_thread) const
 */
static PyObject *Dtool_TransformBlend_transform_vector_506(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  {
    // -2 inline void TransformBlend::transform_vector(LVector3d &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_vector", (char **)keyword_list, &param1, &param2)) {
      LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVector3d, 1, "TransformBlend.transform_vector", false, false);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_vector", false, false);
      if (param1_this != nullptr && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_vector)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TransformBlend::transform_vector(LVector3f &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_vector", (char **)keyword_list, &param1, &param2)) {
      LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVector3f, 1, "TransformBlend.transform_vector", false, false);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_vector", false, false);
      if (param1_this != nullptr && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_vector)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TransformBlend::transform_vector(LVector3d &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_vector", (char **)keyword_list, &param1, &param2)) {
      LVector3d param1_local;
      LVector3d *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_vector", false, false);
      if ((param1_this != nullptr) && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_vector)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TransformBlend::transform_vector(LVector3f &point, Thread *current_thread) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point", "current_thread", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_vector", (char **)keyword_list, &param1, &param2)) {
      LVector3f param1_local;
      LVector3f *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
      Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "TransformBlend.transform_vector", false, false);
      if ((param1_this != nullptr) && param2_this != nullptr) {
        ((*(const TransformBlend*)local_this).transform_vector)(*param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform_vector(TransformBlend self, LVector3d point, Thread current_thread)\n"
      "transform_vector(TransformBlend self, LVector3f point, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_transform_vector_506_comment =
  "C++ Interface:\n"
  "transform_vector(TransformBlend self, LVector3d point, Thread current_thread)\n"
  "transform_vector(TransformBlend self, LVector3f point, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Transforms the indicated vector by the blend matrix.\n"
  " *\n"
  " * You should call update_blend() to ensure that the cache is up-to-date\n"
  " * before calling this.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Transforms the indicated vector by the blend matrix.\n"
  " *\n"
  " * You should call update_blend() to ensure that the cache is up-to-date\n"
  " * before calling this.\n"
  " */";
#else
static const char *Dtool_TransformBlend_transform_vector_506_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq TransformBlend::get_modified(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_TransformBlend_get_modified_507(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  // 1-inline UpdateSeq TransformBlend::get_modified(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "TransformBlend.get_modified", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      UpdateSeq *return_value = new UpdateSeq(((*(const TransformBlend*)local_this).get_modified)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_modified(TransformBlend self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_get_modified_507_comment =
  "C++ Interface:\n"
  "get_modified(TransformBlend self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a counter which is guaranteed to increment at least as often as the\n"
  " * result of get_blend() changes.\n"
  " */";
#else
static const char *Dtool_TransformBlend_get_modified_507_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformBlend::output(std::ostream &out) const
 */
static PyObject *Dtool_TransformBlend_output_509(PyObject *self, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  // 1-void TransformBlend::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "TransformBlend.output", false, true);
  if (arg_this != nullptr) {
    ((*(const TransformBlend*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(TransformBlend self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_output_509_comment =
  "C++ Interface:\n"
  "output(TransformBlend self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TransformBlend_output_509_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformBlend::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_TransformBlend_write_510(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformBlend *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlend)) {
    return nullptr;
  }
  // 1-void TransformBlend::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "TransformBlend.write", false, true);
    if (param1_this != nullptr) {
      ((*(const TransformBlend*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TransformBlend self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_write_510_comment =
  "C++ Interface:\n"
  "write(TransformBlend self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TransformBlend_write_510_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TransformBlend::get_class_type(void)
 */
static PyObject *Dtool_TransformBlend_get_class_type_511(PyObject *, PyObject *) {
  // 1-static TypeHandle TransformBlend::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TransformBlend::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TransformBlend_get_class_type_511_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TransformBlend_get_class_type_511_comment = nullptr;
#endif

/**
 * sequence length function for property TransformBlend::transforms
 */
static Py_ssize_t Dtool_TransformBlend_transforms_Len(PyObject *self) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlend, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_transforms)();
}

/**
 * sequence getter for property TransformBlend::transforms
 */
static PyObject *Dtool_TransformBlend_transforms_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlend, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_transforms)()) {
    PyErr_SetString(PyExc_IndexError, "TransformBlend.transforms[] index out of range");
    return nullptr;
  }
  // 1-inline VertexTransform const *TransformBlend::get_transform(std::size_t n) const
  VertexTransform const *return_value = ((*(const TransformBlend*)local_this).get_transform)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VertexTransform, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_transform(TransformBlend self, index)\n");
  }
}

static int Dtool_TransformBlend_transforms_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlend, (void **)&local_this, "TransformBlend.transforms")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_transforms)()) {
    PyErr_SetString(PyExc_IndexError, "TransformBlend.transforms[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    local_this->remove_transform(index);
    return 0;
  }
  // 1-inline void TransformBlend::set_transform(std::size_t n, VertexTransform const *transform)
  VertexTransform const *arg_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VertexTransform, 2, "TransformBlend.set_transform", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_transform)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_transform(const TransformBlend self, index, const VertexTransform transform)\n");
  }
  return -1;
}

static PyObject *Dtool_TransformBlend_transforms_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "TransformBlend.transforms");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_TransformBlend_transforms_Len;
    wrap->_getitem_func = &Dtool_TransformBlend_transforms_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_TransformBlend_transforms_Sequence_Setitem;
    }
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property TransformBlend::weights
 */
static Py_ssize_t Dtool_TransformBlend_weights_Len(PyObject *self) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlend, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_transforms)();
}

/**
 * mapping getitem for property TransformBlend::weights
 */
static PyObject *Dtool_TransformBlend_weights_Mapping_Getitem(PyObject *self, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlend, (void **)&local_this)) {
    return nullptr;
  }
  {
    // 1-bool TransformBlend::has_transform(VertexTransform const *transform) const
    VertexTransform const *arg_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VertexTransform, 1, "TransformBlend.has_transform", true, true);
    if (arg_this != nullptr) {
      bool return_value = ((*(const TransformBlend*)local_this).has_transform)(arg_this);
      if (!return_value) {
        PyErr_SetObject(PyExc_KeyError, arg);
        return nullptr;
      }
    }
  }
  {
    // -2 PN_stdfloat TransformBlend::get_weight(VertexTransform const *transform) const
    VertexTransform const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_VertexTransform);
    if (arg_this != nullptr) {
      PN_stdfloat return_value = ((*(const TransformBlend*)local_this).get_weight)(arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline PN_stdfloat TransformBlend::get_weight(std::size_t n) const
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      PN_stdfloat return_value = ((*(const TransformBlend*)local_this).get_weight)(arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: PN_stdfloat TransformBlend::get_weight(VertexTransform const *transform) const
  // No coercion possible: inline PN_stdfloat TransformBlend::get_weight(std::size_t n) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_weight(TransformBlend self, const VertexTransform transform)\n"
      "get_weight(TransformBlend self, int n)\n");
  }
  return nullptr;
}

/**
 * mapping key-getter for property TransformBlend::weights
 */
static PyObject *Dtool_TransformBlend_weights_Mapping_Getkey(PyObject *self, Py_ssize_t index) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlend, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_transforms)()) {
    PyErr_SetString(PyExc_IndexError, "TransformBlend.weights[] index out of range");
    return nullptr;
  }
  // 1-inline VertexTransform const *TransformBlend::get_transform(std::size_t n) const
  VertexTransform const *return_value = ((*(const TransformBlend*)local_this).get_transform)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VertexTransform, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_transform(TransformBlend self, index)\n");
  }
}

static PyObject *Dtool_TransformBlend_weights_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MappingWrapper *wrap = Dtool_NewMappingWrapper(self, "TransformBlend.weights");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_TransformBlend_weights_Mapping_Getitem;
    wrap->_keys._len_func = &Dtool_TransformBlend_weights_Len;
    wrap->_keys._getitem_func = &Dtool_TransformBlend_weights_Mapping_Getkey;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_TransformBlend_modified_Getter(PyObject *self, void *) {
  const TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlend, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq TransformBlend::get_modified(Thread *current_thread) const
  UpdateSeq *return_value = new UpdateSeq(((*(const TransformBlend*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

/**
 * Python function wrapper for:
 * inline TransformBlend::TransformBlend(void)
 * inline TransformBlend::TransformBlend(TransformBlend const &copy)
 * inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0)
 * inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1)
 * inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1, VertexTransform const *transform2, PN_stdfloat weight2)
 * inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1, VertexTransform const *transform2, PN_stdfloat weight2, VertexTransform const *transform3, PN_stdfloat weight3)
 */
static int Dtool_Init_TransformBlend(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TransformBlend::TransformBlend(void)
      TransformBlend *return_value = new TransformBlend();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TransformBlend, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline TransformBlend::TransformBlend(TransformBlend const &copy)
        TransformBlend arg_local;
        TransformBlend const *arg_this = Dtool_Coerce_TransformBlend(arg, arg_local);
        if (!(arg_this != nullptr)) {
          Dtool_Raise_ArgTypeError(arg, 0, "TransformBlend.TransformBlend", "TransformBlend");
          return -1;
        }
        TransformBlend *return_value = new TransformBlend(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TransformBlend, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"transform0", "weight0", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:TransformBlend", (char **)keyword_list, &param0, &param1)) {
        VertexTransform const *param0_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_VertexTransform, 0, "TransformBlend.TransformBlend", true, true);
        if (param0_this != nullptr) {
          TransformBlend *return_value = new TransformBlend(param0_this, (PN_stdfloat)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TransformBlend, true, false);
        }
      }
    }
    break;
  case 4:
    {
      // 1-inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1)
      PyObject *param0;
      float param1;
      PyObject *param2;
      float param3;
      static const char *keyword_list[] = {"transform0", "weight0", "transform1", "weight1", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OfOf:TransformBlend", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        VertexTransform const *param0_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_VertexTransform, 0, "TransformBlend.TransformBlend", true, true);
        VertexTransform const *param2_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_VertexTransform, 2, "TransformBlend.TransformBlend", true, true);
        if (param0_this != nullptr && param2_this != nullptr) {
          TransformBlend *return_value = new TransformBlend(param0_this, (PN_stdfloat)param1, param2_this, (PN_stdfloat)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TransformBlend, true, false);
        }
      }
    }
    break;
  case 6:
    {
      // 1-inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1, VertexTransform const *transform2, PN_stdfloat weight2)
      PyObject *param0;
      float param1;
      PyObject *param2;
      float param3;
      PyObject *param4;
      float param5;
      static const char *keyword_list[] = {"transform0", "weight0", "transform1", "weight1", "transform2", "weight2", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OfOfOf:TransformBlend", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        VertexTransform const *param0_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_VertexTransform, 0, "TransformBlend.TransformBlend", true, true);
        VertexTransform const *param2_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_VertexTransform, 2, "TransformBlend.TransformBlend", true, true);
        VertexTransform const *param4_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_VertexTransform, 4, "TransformBlend.TransformBlend", true, true);
        if (param0_this != nullptr && param2_this != nullptr && param4_this != nullptr) {
          TransformBlend *return_value = new TransformBlend(param0_this, (PN_stdfloat)param1, param2_this, (PN_stdfloat)param3, param4_this, (PN_stdfloat)param5);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TransformBlend, true, false);
        }
      }
    }
    break;
  case 8:
    {
      // 1-inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1, VertexTransform const *transform2, PN_stdfloat weight2, VertexTransform const *transform3, PN_stdfloat weight3)
      PyObject *param0;
      float param1;
      PyObject *param2;
      float param3;
      PyObject *param4;
      float param5;
      PyObject *param6;
      float param7;
      static const char *keyword_list[] = {"transform0", "weight0", "transform1", "weight1", "transform2", "weight2", "transform3", "weight3", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OfOfOfOf:TransformBlend", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        VertexTransform const *param0_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_VertexTransform, 0, "TransformBlend.TransformBlend", true, true);
        VertexTransform const *param2_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_VertexTransform, 2, "TransformBlend.TransformBlend", true, true);
        VertexTransform const *param4_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_VertexTransform, 4, "TransformBlend.TransformBlend", true, true);
        VertexTransform const *param6_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param6, Dtool_Ptr_VertexTransform, 6, "TransformBlend.TransformBlend", true, true);
        if (param0_this != nullptr && param2_this != nullptr && param4_this != nullptr && param6_this != nullptr) {
          TransformBlend *return_value = new TransformBlend(param0_this, (PN_stdfloat)param1, param2_this, (PN_stdfloat)param3, param4_this, (PN_stdfloat)param5, param6_this, (PN_stdfloat)param7);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TransformBlend, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TransformBlend() takes 0, 1, 2, 4, 6 or 8 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TransformBlend()\n"
      "TransformBlend(const TransformBlend copy)\n"
      "TransformBlend(const VertexTransform transform0, float weight0)\n"
      "TransformBlend(const VertexTransform transform0, float weight0, const VertexTransform transform1, float weight1)\n"
      "TransformBlend(const VertexTransform transform0, float weight0, const VertexTransform transform1, float weight1, const VertexTransform transform2, float weight2)\n"
      "TransformBlend(const VertexTransform transform0, float weight0, const VertexTransform transform1, float weight1, const VertexTransform transform2, float weight2, const VertexTransform transform3, float weight3)\n");
  }
  return -1;
}

TransformBlend *Dtool_Coerce_TransformBlend(PyObject *args, TransformBlend &coerced) {
  TransformBlend *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_TransformBlend)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const TransformBlend *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:TransformBlend", &param0, &param1)) {
          VertexTransform const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_VertexTransform);
          if (param0_this != nullptr) {
            coerced = TransformBlend(param0_this, (PN_stdfloat)param1);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1)
        PyObject *param0;
        float param1;
        PyObject *param2;
        float param3;
        if (PyArg_ParseTuple(args, "OfOf:TransformBlend", &param0, &param1, &param2, &param3)) {
          VertexTransform const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_VertexTransform);
          VertexTransform const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_VertexTransform);
          if (param0_this != nullptr && param2_this != nullptr) {
            coerced = TransformBlend(param0_this, (PN_stdfloat)param1, param2_this, (PN_stdfloat)param3);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1, VertexTransform const *transform2, PN_stdfloat weight2)
        PyObject *param0;
        float param1;
        PyObject *param2;
        float param3;
        PyObject *param4;
        float param5;
        if (PyArg_ParseTuple(args, "OfOfOf:TransformBlend", &param0, &param1, &param2, &param3, &param4, &param5)) {
          VertexTransform const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_VertexTransform);
          VertexTransform const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_VertexTransform);
          VertexTransform const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_VertexTransform);
          if (param0_this != nullptr && param2_this != nullptr && param4_this != nullptr) {
            coerced = TransformBlend(param0_this, (PN_stdfloat)param1, param2_this, (PN_stdfloat)param3, param4_this, (PN_stdfloat)param5);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 8: {
        // 1-inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1, VertexTransform const *transform2, PN_stdfloat weight2, VertexTransform const *transform3, PN_stdfloat weight3)
        PyObject *param0;
        float param1;
        PyObject *param2;
        float param3;
        PyObject *param4;
        float param5;
        PyObject *param6;
        float param7;
        if (PyArg_ParseTuple(args, "OfOfOfOf:TransformBlend", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
          VertexTransform const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_VertexTransform);
          VertexTransform const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_VertexTransform);
          VertexTransform const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_VertexTransform);
          VertexTransform const *param6_this = nullptr;
          DtoolInstance_GetPointer(param6, param6_this, *Dtool_Ptr_VertexTransform);
          if (param0_this != nullptr && param2_this != nullptr && param4_this != nullptr && param6_this != nullptr) {
            coerced = TransformBlend(param0_this, (PN_stdfloat)param1, param2_this, (PN_stdfloat)param3, param4_this, (PN_stdfloat)param5, param6_this, (PN_stdfloat)param7);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return nullptr;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TransformBlend_get_transforms(PyObject *self, PyObject *) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlend, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_transforms)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TransformBlend_get_transform_495(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_TransformBlend(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TransformBlend) {
    printf("TransformBlend ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TransformBlend *local_this = (TransformBlend *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TransformBlend) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TransformBlend(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TransformBlend) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TransformBlendTable
 */
/**
 * Python function wrapper for:
 * void TransformBlendTable::operator =(TransformBlendTable const &copy)
 */
static PyObject *Dtool_TransformBlendTable_operator_514(PyObject *self, PyObject *arg) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlendTable, (void **)&local_this, "TransformBlendTable.assign")) {
    return nullptr;
  }
  // 1-void TransformBlendTable::operator =(TransformBlendTable const &copy)
  TransformBlendTable const *arg_this = (TransformBlendTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformBlendTable, 1, "TransformBlendTable.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    TransformBlendTable *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TransformBlendTable, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TransformBlendTable self, const TransformBlendTable copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_operator_514_comment =
  "C++ Interface:\n"
  "assign(const TransformBlendTable self, const TransformBlendTable copy)\n";
#else
static const char *Dtool_TransformBlendTable_operator_514_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TransformBlendTable::get_num_blends(void) const
 */
static PyObject *Dtool_TransformBlendTable_get_num_blends_515(PyObject *self, PyObject *) {
  TransformBlendTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlendTable)) {
    return nullptr;
  }
  // 1-inline std::size_t TransformBlendTable::get_num_blends(void) const
  std::size_t return_value = ((*(const TransformBlendTable*)local_this).get_num_blends)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_get_num_blends_515_comment =
  "C++ Interface:\n"
  "get_num_blends(TransformBlendTable self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of different blend combinations in the table.\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_get_num_blends_515_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformBlend const &TransformBlendTable::get_blend(std::size_t n) const
 */
static PyObject *Dtool_TransformBlendTable_get_blend_516(PyObject *self, PyObject *arg) {
  TransformBlendTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlendTable)) {
    return nullptr;
  }
  // 1-inline TransformBlend const &TransformBlendTable::get_blend(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    TransformBlend const *return_value = &(((*(const TransformBlendTable*)local_this).get_blend)(arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformBlend, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_blend(TransformBlendTable self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_get_blend_516_comment =
  "C++ Interface:\n"
  "get_blend(TransformBlendTable self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth blend in the table.\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_get_blend_516_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq TransformBlendTable::get_modified(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_TransformBlendTable_get_modified_518(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformBlendTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlendTable)) {
    return nullptr;
  }
  // 1-inline UpdateSeq TransformBlendTable::get_modified(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "TransformBlendTable.get_modified", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      UpdateSeq *return_value = new UpdateSeq(((*(const TransformBlendTable*)local_this).get_modified)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_modified(TransformBlendTable self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_get_modified_518_comment =
  "C++ Interface:\n"
  "get_modified(TransformBlendTable self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a counter which is guaranteed to increment at least when any\n"
  " * TransformBlends within the table have changed.\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_get_modified_518_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformBlendTable::set_blend(std::size_t n, TransformBlend const &blend)
 */
static PyObject *Dtool_TransformBlendTable_set_blend_519(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlendTable, (void **)&local_this, "TransformBlendTable.set_blend")) {
    return nullptr;
  }
  // 1-void TransformBlendTable::set_blend(std::size_t n, TransformBlend const &blend)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "blend", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_blend", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    TransformBlend param2_local;
    TransformBlend const *param2_this = Dtool_Coerce_TransformBlend(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TransformBlendTable.set_blend", "TransformBlend");
    }
    ((*local_this).set_blend)((std::size_t)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend(const TransformBlendTable self, int n, const TransformBlend blend)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_set_blend_519_comment =
  "C++ Interface:\n"
  "set_blend(const TransformBlendTable self, int n, const TransformBlend blend)\n"
  "\n"
  "/**\n"
  " * Replaces the blend at the nth position with the indicated value.\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_set_blend_519_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformBlendTable::remove_blend(std::size_t n)
 */
static PyObject *Dtool_TransformBlendTable_remove_blend_520(PyObject *self, PyObject *arg) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlendTable, (void **)&local_this, "TransformBlendTable.remove_blend")) {
    return nullptr;
  }
  // 1-void TransformBlendTable::remove_blend(std::size_t n)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).remove_blend)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_blend(const TransformBlendTable self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_remove_blend_520_comment =
  "C++ Interface:\n"
  "remove_blend(const TransformBlendTable self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the blend at the nth position.\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_remove_blend_520_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t TransformBlendTable::add_blend(TransformBlend const &blend)
 */
static PyObject *Dtool_TransformBlendTable_add_blend_521(PyObject *self, PyObject *arg) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlendTable, (void **)&local_this, "TransformBlendTable.add_blend")) {
    return nullptr;
  }
  // 1-std::size_t TransformBlendTable::add_blend(TransformBlend const &blend)
  TransformBlend arg_local;
  TransformBlend const *arg_this = Dtool_Coerce_TransformBlend(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TransformBlendTable.add_blend", "TransformBlend");
  }
  std::size_t return_value = ((*local_this).add_blend)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_blend(const TransformBlendTable self, const TransformBlend blend)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_add_blend_521_comment =
  "C++ Interface:\n"
  "add_blend(const TransformBlendTable self, const TransformBlend blend)\n"
  "\n"
  "/**\n"
  " * Adds a new blend to the table, and returns its index number.  If there is\n"
  " * already an identical blend in the table, simply returns that number\n"
  " * instead.\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_add_blend_521_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TransformBlendTable::get_num_transforms(void) const
 */
static PyObject *Dtool_TransformBlendTable_get_num_transforms_522(PyObject *self, PyObject *) {
  TransformBlendTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlendTable)) {
    return nullptr;
  }
  // 1-inline int TransformBlendTable::get_num_transforms(void) const
  int return_value = ((*(const TransformBlendTable*)local_this).get_num_transforms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_get_num_transforms_522_comment =
  "C++ Interface:\n"
  "get_num_transforms(TransformBlendTable self)\n"
  "\n"
  "/**\n"
  " * Returns the number of unique VertexTransform objects represented in the\n"
  " * table.  This will correspond to the size of the TransformTable object that\n"
  " * would represent the same table.  This is also the same limit reflected by\n"
  " * GraphicsStateGuardian::get_max_vertex_transform_indices().\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_get_num_transforms_522_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TransformBlendTable::get_max_simultaneous_transforms(void) const
 */
static PyObject *Dtool_TransformBlendTable_get_max_simultaneous_transforms_523(PyObject *self, PyObject *) {
  TransformBlendTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlendTable)) {
    return nullptr;
  }
  // 1-inline int TransformBlendTable::get_max_simultaneous_transforms(void) const
  int return_value = ((*(const TransformBlendTable*)local_this).get_max_simultaneous_transforms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_get_max_simultaneous_transforms_523_comment =
  "C++ Interface:\n"
  "get_max_simultaneous_transforms(TransformBlendTable self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of unique VertexTransform objects that are\n"
  " * applied to any one vertex simultaneously.  This is the same limit reflected\n"
  " * by GraphicsStateGuardian::get_max_vertex_transforms().\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_get_max_simultaneous_transforms_523_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TransformBlendTable::set_rows(SparseArray const &rows)
 */
static PyObject *Dtool_TransformBlendTable_set_rows_524(PyObject *self, PyObject *arg) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlendTable, (void **)&local_this, "TransformBlendTable.set_rows")) {
    return nullptr;
  }
  // 1-inline void TransformBlendTable::set_rows(SparseArray const &rows)
  SparseArray arg_local;
  SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TransformBlendTable.set_rows", "SparseArray");
  }
  ((*local_this).set_rows)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rows(const TransformBlendTable self, const SparseArray rows)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_set_rows_524_comment =
  "C++ Interface:\n"
  "set_rows(const TransformBlendTable self, const SparseArray rows)\n"
  "\n"
  "/**\n"
  " * Specifies the subset of rows (vertices) in the associated GeomVertexData\n"
  " * that this TransformBlendTable actually affects.\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_set_rows_524_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SparseArray const &TransformBlendTable::get_rows(void) const
 */
static PyObject *Dtool_TransformBlendTable_get_rows_525(PyObject *self, PyObject *) {
  TransformBlendTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlendTable)) {
    return nullptr;
  }
  // 1-inline SparseArray const &TransformBlendTable::get_rows(void) const
  SparseArray const *return_value = &(((*(const TransformBlendTable*)local_this).get_rows)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_get_rows_525_comment =
  "C++ Interface:\n"
  "get_rows(TransformBlendTable self)\n"
  "\n"
  "/**\n"
  " * Returns the subset of rows (vertices) in the associated GeomVertexData that\n"
  " * this TransformBlendTable actually affects.\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_get_rows_525_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SparseArray &TransformBlendTable::modify_rows(void)
 */
static PyObject *Dtool_TransformBlendTable_modify_rows_526(PyObject *self, PyObject *) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlendTable, (void **)&local_this, "TransformBlendTable.modify_rows")) {
    return nullptr;
  }
  // 1-inline SparseArray &TransformBlendTable::modify_rows(void)
  SparseArray *return_value = &(((*local_this).modify_rows)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_modify_rows_526_comment =
  "C++ Interface:\n"
  "modify_rows(const TransformBlendTable self)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable reference to the SparseArray that specifies the subset\n"
  " * of rows (vertices) in the associated GeomVertexData that this\n"
  " * TransformBlendTable actually affects.\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_modify_rows_526_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TransformBlendTable::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_TransformBlendTable_write_527(PyObject *self, PyObject *args, PyObject *kwds) {
  TransformBlendTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TransformBlendTable)) {
    return nullptr;
  }
  // 1-void TransformBlendTable::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "TransformBlendTable.write", false, true);
    if (param1_this != nullptr) {
      ((*(const TransformBlendTable*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TransformBlendTable self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_write_527_comment =
  "C++ Interface:\n"
  "write(TransformBlendTable self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TransformBlendTable_write_527_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TransformBlendTable::get_class_type(void)
 */
static PyObject *Dtool_TransformBlendTable_get_class_type_536(PyObject *, PyObject *) {
  // 1-static TypeHandle TransformBlendTable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TransformBlendTable::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TransformBlendTable_get_class_type_536_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TransformBlendTable_get_class_type_536_comment = nullptr;
#endif

/**
 * sequence length function for property TransformBlendTable::blends
 */
static Py_ssize_t Dtool_TransformBlendTable_blends_Len(PyObject *self) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlendTable, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_blends)();
}

/**
 * sequence getter for property TransformBlendTable::blends
 */
static PyObject *Dtool_TransformBlendTable_blends_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlendTable, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_blends)()) {
    PyErr_SetString(PyExc_IndexError, "TransformBlendTable.blends[] index out of range");
    return nullptr;
  }
  // 1-inline TransformBlend const &TransformBlendTable::get_blend(std::size_t n) const
  TransformBlend const *return_value = &(((*(const TransformBlendTable*)local_this).get_blend)(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformBlend, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_blend(TransformBlendTable self, index)\n");
  }
}

static int Dtool_TransformBlendTable_blends_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlendTable, (void **)&local_this, "TransformBlendTable.blends")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_blends)()) {
    PyErr_SetString(PyExc_IndexError, "TransformBlendTable.blends[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    local_this->remove_blend(index);
    return 0;
  }
  // 1-void TransformBlendTable::set_blend(std::size_t n, TransformBlend const &blend)
  TransformBlend arg_local;
  TransformBlend const *arg_this = Dtool_Coerce_TransformBlend(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 2, "TransformBlendTable.set_blend", "TransformBlend");
    return -1;
  }
  ((*local_this).set_blend)(index, *arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blend(const TransformBlendTable self, index, const TransformBlend blend)\n");
  }
  return -1;
}

static PyObject *Dtool_TransformBlendTable_blends_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "TransformBlendTable.blends");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_TransformBlendTable_blends_Len;
    wrap->_getitem_func = &Dtool_TransformBlendTable_blends_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_TransformBlendTable_blends_Sequence_Setitem;
    }
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_TransformBlendTable_modified_Getter(PyObject *self, void *) {
  const TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlendTable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq TransformBlendTable::get_modified(Thread *current_thread) const
  UpdateSeq *return_value = new UpdateSeq(((*(const TransformBlendTable*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

static PyObject *Dtool_TransformBlendTable_num_transforms_Getter(PyObject *self, void *) {
  const TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlendTable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TransformBlendTable::get_num_transforms(void) const
  int return_value = ((*(const TransformBlendTable*)local_this).get_num_transforms)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TransformBlendTable_max_simultaneous_transforms_Getter(PyObject *self, void *) {
  const TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlendTable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TransformBlendTable::get_max_simultaneous_transforms(void) const
  int return_value = ((*(const TransformBlendTable*)local_this).get_max_simultaneous_transforms)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TransformBlendTable_rows_Getter(PyObject *self, void *) {
  const TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlendTable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SparseArray const &TransformBlendTable::get_rows(void) const
  SparseArray const *return_value = &(((*(const TransformBlendTable*)local_this).get_rows)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, false, true);
}

static int Dtool_TransformBlendTable_rows_Setter(PyObject *self, PyObject *arg, void *) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TransformBlendTable, (void **)&local_this, "TransformBlendTable.rows")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete rows attribute");
    return -1;
  }
  // 1-inline void TransformBlendTable::set_rows(SparseArray const &rows)
  SparseArray arg_local;
  SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TransformBlendTable.set_rows", "SparseArray");
    return -1;
  }
  ((*local_this).set_rows)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_rows(const TransformBlendTable self, const SparseArray rows)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * TransformBlendTable::TransformBlendTable(void)
 * TransformBlendTable::TransformBlendTable(TransformBlendTable const &copy)
 */
static int Dtool_Init_TransformBlendTable(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TransformBlendTable::TransformBlendTable(void)
      TransformBlendTable *return_value = new TransformBlendTable();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TransformBlendTable, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-TransformBlendTable::TransformBlendTable(TransformBlendTable const &copy)
        TransformBlendTable const *arg_this = (TransformBlendTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformBlendTable, 0, "TransformBlendTable.TransformBlendTable", true, true);
        if (arg_this != nullptr) {
          TransformBlendTable *return_value = new TransformBlendTable(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TransformBlendTable, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TransformBlendTable() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TransformBlendTable()\n"
      "TransformBlendTable(const TransformBlendTable copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TransformBlendTable_get_blends(PyObject *self, PyObject *) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlendTable, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_blends)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TransformBlendTable_get_blend_516(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_TransformBlendTable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TransformBlendTable) {
    printf("TransformBlendTable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TransformBlendTable *local_this = (TransformBlendTable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TransformBlendTable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TransformBlendTable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TransformBlendTable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (TransformBlendTable*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (TransformBlendTable*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TransformBlendTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TransformBlendTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TransformBlendTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TransformBlendTable*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VertexSlider
 */
/**
 * Python function wrapper for:
 * inline InternalName const *VertexSlider::get_name(void) const
 */
static PyObject *Dtool_VertexSlider_get_name_538(PyObject *self, PyObject *) {
  VertexSlider *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexSlider)) {
    return nullptr;
  }
  // 1-inline InternalName const *VertexSlider::get_name(void) const
  InternalName const *return_value = ((*(const VertexSlider*)local_this).get_name)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
}

#ifndef NDEBUG
static const char *Dtool_VertexSlider_get_name_538_comment =
  "C++ Interface:\n"
  "get_name(VertexSlider self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this particular slider.  Every unique blend shape\n"
  " * within a particular Geom must be identified with a different name, which is\n"
  " * shared by the slider that controls it.\n"
  " */";
#else
static const char *Dtool_VertexSlider_get_name_538_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat VertexSlider::get_slider(void) const = 0
 */
static PyObject *Dtool_VertexSlider_get_slider_540(PyObject *self, PyObject *) {
  VertexSlider *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexSlider)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat VertexSlider::get_slider(void) const = 0
  PN_stdfloat return_value = ((*(const VertexSlider*)local_this).get_slider)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VertexSlider_get_slider_540_comment =
  "C++ Interface:\n"
  "get_slider(VertexSlider self)\n";
#else
static const char *Dtool_VertexSlider_get_slider_540_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq VertexSlider::get_modified(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_VertexSlider_get_modified_541(PyObject *self, PyObject *args, PyObject *kwds) {
  VertexSlider *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexSlider)) {
    return nullptr;
  }
  // 1-inline UpdateSeq VertexSlider::get_modified(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "VertexSlider.get_modified", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      UpdateSeq *return_value = new UpdateSeq(((*(const VertexSlider*)local_this).get_modified)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_modified(VertexSlider self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexSlider_get_modified_541_comment =
  "C++ Interface:\n"
  "get_modified(VertexSlider self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number that's guaranteed to change at least every time\n"
  " * the value reported by get_slider() changes.\n"
  " */";
#else
static const char *Dtool_VertexSlider_get_modified_541_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VertexSlider::output(std::ostream &out) const
 */
static PyObject *Dtool_VertexSlider_output_544(PyObject *self, PyObject *arg) {
  VertexSlider *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexSlider)) {
    return nullptr;
  }
  // 1-virtual void VertexSlider::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "VertexSlider.output", false, true);
  if (arg_this != nullptr) {
    ((*(const VertexSlider*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(VertexSlider self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexSlider_output_544_comment =
  "C++ Interface:\n"
  "output(VertexSlider self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VertexSlider_output_544_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VertexSlider::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_VertexSlider_write_545(PyObject *self, PyObject *args, PyObject *kwds) {
  VertexSlider *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexSlider)) {
    return nullptr;
  }
  // 1-virtual void VertexSlider::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "VertexSlider.write", false, true);
    if (param1_this != nullptr) {
      ((*(const VertexSlider*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(VertexSlider self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexSlider_write_545_comment =
  "C++ Interface:\n"
  "write(VertexSlider self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VertexSlider_write_545_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VertexSlider::get_class_type(void)
 */
static PyObject *Dtool_VertexSlider_get_class_type_546(PyObject *, PyObject *) {
  // 1-static TypeHandle VertexSlider::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VertexSlider::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexSlider_get_class_type_546_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VertexSlider_get_class_type_546_comment = nullptr;
#endif

static PyObject *Dtool_VertexSlider_name_Getter(PyObject *self, void *) {
  const VertexSlider *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VertexSlider, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline InternalName const *VertexSlider::get_name(void) const
  InternalName const *return_value = ((*(const VertexSlider*)local_this).get_name)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, true);
}

static PyObject *Dtool_VertexSlider_slider_Getter(PyObject *self, void *) {
  const VertexSlider *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VertexSlider, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual PN_stdfloat VertexSlider::get_slider(void) const = 0
  PN_stdfloat return_value = ((*(const VertexSlider*)local_this).get_slider)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_VertexSlider_modified_Getter(PyObject *self, void *) {
  const VertexSlider *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VertexSlider, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq VertexSlider::get_modified(Thread *current_thread) const
  UpdateSeq *return_value = new UpdateSeq(((*(const VertexSlider*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

static int Dtool_Init_VertexSlider(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VertexSlider(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VertexSlider) {
    printf("VertexSlider ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VertexSlider *local_this = (VertexSlider *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VertexSlider) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VertexSlider(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VertexSlider) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (VertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (VertexSlider*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SliderTable
 */
/**
 * Python function wrapper for:
 * void SliderTable::operator =(SliderTable const &copy)
 */
static PyObject *Dtool_SliderTable_operator_549(PyObject *self, PyObject *arg) {
  SliderTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SliderTable, (void **)&local_this, "SliderTable.assign")) {
    return nullptr;
  }
  // 1-void SliderTable::operator =(SliderTable const &copy)
  SliderTable const *arg_this = (SliderTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SliderTable, 1, "SliderTable.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    SliderTable *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SliderTable, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const SliderTable self, const SliderTable copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_operator_549_comment =
  "C++ Interface:\n"
  "assign(const SliderTable self, const SliderTable copy)\n";
#else
static const char *Dtool_SliderTable_operator_549_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SliderTable::is_registered(void) const
 */
static PyObject *Dtool_SliderTable_is_registered_550(PyObject *self, PyObject *) {
  SliderTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SliderTable)) {
    return nullptr;
  }
  // 1-inline bool SliderTable::is_registered(void) const
  bool return_value = ((*(const SliderTable*)local_this).is_registered)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_is_registered_550_comment =
  "C++ Interface:\n"
  "is_registered(SliderTable self)\n"
  "\n"
  "/**\n"
  " * Returns true if this table has been registered.  Once it has been\n"
  " * registered, the set of sliders in a SliderTable may not be further\n"
  " * modified; but it must be registered before it can be assigned to a Geom.\n"
  " */";
#else
static const char *Dtool_SliderTable_is_registered_550_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ConstPointerTo< SliderTable > SliderTable::register_table(SliderTable const *table)
 */
static PyObject *Dtool_SliderTable_register_table_551(PyObject *, PyObject *arg) {
  // 1-static inline ConstPointerTo< SliderTable > SliderTable::register_table(SliderTable const *table)
  SliderTable const *arg_this = (SliderTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SliderTable, 0, "SliderTable.register_table", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< SliderTable > return_value = (SliderTable::register_table)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    SliderTable const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_SliderTable, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_table(const SliderTable table)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_register_table_551_comment =
  "C++ Interface:\n"
  "register_table(const SliderTable table)\n"
  "\n"
  "/**\n"
  " * Registers a SliderTable for use.  This is similar to\n"
  " * GeomVertexFormat::register_format().  Once registered, a SliderTable may no\n"
  " * longer be modified (although the individual VertexSlider objects may modify\n"
  " * their reported sliders).\n"
  " *\n"
  " * This must be called before a table may be used in a Geom.  After this call,\n"
  " * you should discard the original pointer you passed in (which may or may not\n"
  " * now be invalid) and let its reference count decrement normally; you should\n"
  " * use only the returned value from this point on.\n"
  " */";
#else
static const char *Dtool_SliderTable_register_table_551_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SliderTable::get_num_sliders(void) const
 */
static PyObject *Dtool_SliderTable_get_num_sliders_552(PyObject *self, PyObject *) {
  SliderTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SliderTable)) {
    return nullptr;
  }
  // 1-inline std::size_t SliderTable::get_num_sliders(void) const
  std::size_t return_value = ((*(const SliderTable*)local_this).get_num_sliders)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_get_num_sliders_552_comment =
  "C++ Interface:\n"
  "get_num_sliders(SliderTable self)\n"
  "\n"
  "/**\n"
  " * Returns the number of sliders in the table.\n"
  " */";
#else
static const char *Dtool_SliderTable_get_num_sliders_552_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VertexSlider const *SliderTable::get_slider(std::size_t n) const
 */
static PyObject *Dtool_SliderTable_get_slider_553(PyObject *self, PyObject *arg) {
  SliderTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SliderTable)) {
    return nullptr;
  }
  // 1-inline VertexSlider const *SliderTable::get_slider(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    VertexSlider const *return_value = ((*(const SliderTable*)local_this).get_slider)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VertexSlider, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_slider(SliderTable self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_get_slider_553_comment =
  "C++ Interface:\n"
  "get_slider(SliderTable self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth slider in the table.\n"
  " */";
#else
static const char *Dtool_SliderTable_get_slider_553_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SparseArray const &SliderTable::get_slider_rows(std::size_t n) const
 */
static PyObject *Dtool_SliderTable_get_slider_rows_555(PyObject *self, PyObject *arg) {
  SliderTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SliderTable)) {
    return nullptr;
  }
  // 1-inline SparseArray const &SliderTable::get_slider_rows(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    SparseArray const *return_value = &(((*(const SliderTable*)local_this).get_slider_rows)(arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_slider_rows(SliderTable self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_get_slider_rows_555_comment =
  "C++ Interface:\n"
  "get_slider_rows(SliderTable self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the set of rows (vertices) governed by the nth slider in the table.\n"
  " */";
#else
static const char *Dtool_SliderTable_get_slider_rows_555_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SparseArray const &SliderTable::find_sliders(InternalName const *name) const
 */
static PyObject *Dtool_SliderTable_find_sliders_556(PyObject *self, PyObject *arg) {
  SliderTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SliderTable)) {
    return nullptr;
  }
  // 1-inline SparseArray const &SliderTable::find_sliders(InternalName const *name) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SliderTable.find_sliders", "InternalName");
  }
  SparseArray const *return_value = &(((*(const SliderTable*)local_this).find_sliders)(std::move(arg_this)));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_sliders(SliderTable self, const InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_find_sliders_556_comment =
  "C++ Interface:\n"
  "find_sliders(SliderTable self, const InternalName name)\n"
  "\n"
  "/**\n"
  " * Returns a list of slider indices that represent the list of sliders with\n"
  " * the indicated name, or an empty SparseArray if no slider in the table has\n"
  " * that name.\n"
  " */";
#else
static const char *Dtool_SliderTable_find_sliders_556_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SliderTable::has_slider(InternalName const *name) const
 */
static PyObject *Dtool_SliderTable_has_slider_557(PyObject *self, PyObject *arg) {
  SliderTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SliderTable)) {
    return nullptr;
  }
  // 1-inline bool SliderTable::has_slider(InternalName const *name) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SliderTable.has_slider", "InternalName");
  }
  bool return_value = ((*(const SliderTable*)local_this).has_slider)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_slider(SliderTable self, const InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_has_slider_557_comment =
  "C++ Interface:\n"
  "has_slider(SliderTable self, const InternalName name)\n"
  "\n"
  "/**\n"
  " * Returns true if the table has at least one slider by the indicated name,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_SliderTable_has_slider_557_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SliderTable::is_empty(void) const
 */
static PyObject *Dtool_SliderTable_is_empty_558(PyObject *self, PyObject *) {
  SliderTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SliderTable)) {
    return nullptr;
  }
  // 1-inline bool SliderTable::is_empty(void) const
  bool return_value = ((*(const SliderTable*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_is_empty_558_comment =
  "C++ Interface:\n"
  "is_empty(SliderTable self)\n"
  "\n"
  "/**\n"
  " * Returns true if the table has no sliders, false if it has at least one.\n"
  " */";
#else
static const char *Dtool_SliderTable_is_empty_558_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq SliderTable::get_modified(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_SliderTable_get_modified_559(PyObject *self, PyObject *args, PyObject *kwds) {
  SliderTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SliderTable)) {
    return nullptr;
  }
  // 1-inline UpdateSeq SliderTable::get_modified(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "SliderTable.get_modified", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      UpdateSeq *return_value = new UpdateSeq(((*(const SliderTable*)local_this).get_modified)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_modified(SliderTable self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_get_modified_559_comment =
  "C++ Interface:\n"
  "get_modified(SliderTable self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number that's guaranteed to change at least when any\n"
  " * VertexSliders in the table change.  (However, this is only true for a\n"
  " * registered table.  An unregistered table may or may not reflect an update\n"
  " * here when a VertexSlider changes.)\n"
  " */";
#else
static const char *Dtool_SliderTable_get_modified_559_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SliderTable::set_slider(std::size_t n, VertexSlider const *slider)
 */
static PyObject *Dtool_SliderTable_set_slider_561(PyObject *self, PyObject *args, PyObject *kwds) {
  SliderTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SliderTable, (void **)&local_this, "SliderTable.set_slider")) {
    return nullptr;
  }
  // 1-void SliderTable::set_slider(std::size_t n, VertexSlider const *slider)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "slider", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_slider", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    VertexSlider const *param2_this = (VertexSlider *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_VertexSlider, 2, "SliderTable.set_slider", true, true);
    if (param2_this != nullptr) {
      ((*local_this).set_slider)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slider(const SliderTable self, int n, const VertexSlider slider)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_set_slider_561_comment =
  "C++ Interface:\n"
  "set_slider(const SliderTable self, int n, const VertexSlider slider)\n"
  "\n"
  "/**\n"
  " * Replaces the nth slider.  Only valid for unregistered tables.\n"
  " */";
#else
static const char *Dtool_SliderTable_set_slider_561_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SliderTable::set_slider_rows(std::size_t n, SparseArray const &rows)
 */
static PyObject *Dtool_SliderTable_set_slider_rows_562(PyObject *self, PyObject *args, PyObject *kwds) {
  SliderTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SliderTable, (void **)&local_this, "SliderTable.set_slider_rows")) {
    return nullptr;
  }
  // 1-void SliderTable::set_slider_rows(std::size_t n, SparseArray const &rows)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "rows", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_slider_rows", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    SparseArray param2_local;
    SparseArray const *param2_this = Dtool_Coerce_SparseArray(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "SliderTable.set_slider_rows", "SparseArray");
    }
    ((*local_this).set_slider_rows)((std::size_t)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slider_rows(const SliderTable self, int n, const SparseArray rows)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_set_slider_rows_562_comment =
  "C++ Interface:\n"
  "set_slider_rows(const SliderTable self, int n, const SparseArray rows)\n"
  "\n"
  "/**\n"
  " * Replaces the rows affected by the nth slider.  Only valid for unregistered\n"
  " * tables.\n"
  " */";
#else
static const char *Dtool_SliderTable_set_slider_rows_562_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SliderTable::remove_slider(std::size_t n)
 */
static PyObject *Dtool_SliderTable_remove_slider_563(PyObject *self, PyObject *arg) {
  SliderTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SliderTable, (void **)&local_this, "SliderTable.remove_slider")) {
    return nullptr;
  }
  // 1-void SliderTable::remove_slider(std::size_t n)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).remove_slider)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_slider(const SliderTable self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_remove_slider_563_comment =
  "C++ Interface:\n"
  "remove_slider(const SliderTable self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the nth slider.  Only valid for unregistered tables.\n"
  " */";
#else
static const char *Dtool_SliderTable_remove_slider_563_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t SliderTable::add_slider(VertexSlider const *slider, SparseArray const &rows)
 */
static PyObject *Dtool_SliderTable_add_slider_564(PyObject *self, PyObject *args, PyObject *kwds) {
  SliderTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SliderTable, (void **)&local_this, "SliderTable.add_slider")) {
    return nullptr;
  }
  // 1-std::size_t SliderTable::add_slider(VertexSlider const *slider, SparseArray const &rows)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"slider", "rows", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_slider", (char **)keyword_list, &param1, &param2)) {
    VertexSlider const *param1_this = (VertexSlider *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_VertexSlider, 1, "SliderTable.add_slider", true, true);
    SparseArray param2_local;
    SparseArray const *param2_this = Dtool_Coerce_SparseArray(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "SliderTable.add_slider", "SparseArray");
    }
    if (param1_this != nullptr) {
      std::size_t return_value = ((*local_this).add_slider)(param1_this, *param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_slider(const SliderTable self, const VertexSlider slider, const SparseArray rows)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_add_slider_564_comment =
  "C++ Interface:\n"
  "add_slider(const SliderTable self, const VertexSlider slider, const SparseArray rows)\n"
  "\n"
  "/**\n"
  " * Adds a new slider to the table, and returns the index number of the new\n"
  " * slider.  Only valid for unregistered tables.\n"
  " */";
#else
static const char *Dtool_SliderTable_add_slider_564_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SliderTable::write(std::ostream &out) const
 */
static PyObject *Dtool_SliderTable_write_565(PyObject *self, PyObject *arg) {
  SliderTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SliderTable)) {
    return nullptr;
  }
  // 1-void SliderTable::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "SliderTable.write", false, true);
  if (arg_this != nullptr) {
    ((*(const SliderTable*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(SliderTable self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_write_565_comment =
  "C++ Interface:\n"
  "write(SliderTable self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SliderTable_write_565_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SliderTable::get_class_type(void)
 */
static PyObject *Dtool_SliderTable_get_class_type_566(PyObject *, PyObject *) {
  // 1-static TypeHandle SliderTable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((SliderTable::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SliderTable_get_class_type_566_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SliderTable_get_class_type_566_comment = nullptr;
#endif

static PyObject *Dtool_SliderTable_modified_Getter(PyObject *self, void *) {
  const SliderTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SliderTable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq SliderTable::get_modified(Thread *current_thread) const
  UpdateSeq *return_value = new UpdateSeq(((*(const SliderTable*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

/**
 * Python function wrapper for:
 * SliderTable::SliderTable(void)
 * SliderTable::SliderTable(SliderTable const &copy)
 */
static int Dtool_Init_SliderTable(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-SliderTable::SliderTable(void)
      SliderTable *return_value = new SliderTable();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SliderTable, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-SliderTable::SliderTable(SliderTable const &copy)
        SliderTable const *arg_this = (SliderTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SliderTable, 0, "SliderTable.SliderTable", true, true);
        if (arg_this != nullptr) {
          SliderTable *return_value = new SliderTable(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SliderTable, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SliderTable() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SliderTable()\n"
      "SliderTable(const SliderTable copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_SliderTable_get_sliders(PyObject *self, PyObject *) {
  SliderTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SliderTable, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_sliders)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_SliderTable_get_slider_553(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_SliderTable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SliderTable) {
    printf("SliderTable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SliderTable *local_this = (SliderTable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SliderTable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SliderTable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SliderTable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SliderTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SliderTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SliderTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SliderTable*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomVertexData
 */
/**
 * Python function wrapper for:
 * void GeomVertexData::operator =(GeomVertexData const &copy)
 */
static PyObject *Dtool_GeomVertexData_operator_573(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.assign")) {
    return nullptr;
  }
  // 1-void GeomVertexData::operator =(GeomVertexData const &copy)
  GeomVertexData const *arg_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexData, 1, "GeomVertexData.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    GeomVertexData *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexData, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GeomVertexData self, const GeomVertexData copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_operator_573_comment =
  "C++ Interface:\n"
  "assign(const GeomVertexData self, const GeomVertexData copy)\n";
#else
static const char *Dtool_GeomVertexData_operator_573_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomVertexData::compare_to(GeomVertexData const &other) const
 */
static PyObject *Dtool_GeomVertexData_compare_to_578(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-int GeomVertexData::compare_to(GeomVertexData const &other) const
  GeomVertexData const *arg_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexData, 1, "GeomVertexData.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const GeomVertexData*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(GeomVertexData self, const GeomVertexData other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_compare_to_578_comment =
  "C++ Interface:\n"
  "compare_to(GeomVertexData self, const GeomVertexData other)\n"
  "\n"
  "/**\n"
  " * Returns 0 if the two objects are equivalent, even if they are not the same\n"
  " * pointer.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_compare_to_578_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &GeomVertexData::get_name(void) const
 */
static PyObject *Dtool_GeomVertexData_get_name_579(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline std::string const &GeomVertexData::get_name(void) const
  std::string const &return_value = ((*(const GeomVertexData*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_name_579_comment =
  "C++ Interface:\n"
  "get_name(GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns the name passed to the constructor, if any.  This name is reported\n"
  " * on the PStats graph for vertex computations.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_name_579_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::set_name(std::string const &name)
 */
static PyObject *Dtool_GeomVertexData_set_name_580(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.set_name")) {
    return nullptr;
  }
  // 1-void GeomVertexData::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const GeomVertexData self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_set_name_580_comment =
  "C++ Interface:\n"
  "set_name(const GeomVertexData self, str name)\n"
  "\n"
  "/**\n"
  " * Changes the name of the vertex data.  This name is reported on the PStats\n"
  " * graph for vertex computations.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_set_name_580_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::UsageHint GeomVertexData::get_usage_hint(void) const
 */
static PyObject *Dtool_GeomVertexData_get_usage_hint_582(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline GeomEnums::UsageHint GeomVertexData::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const GeomVertexData*)local_this).get_usage_hint)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_usage_hint_582_comment =
  "C++ Interface:\n"
  "get_usage_hint(GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns the usage hint that was passed to the constructor, and which will\n"
  " * be passed to each array data object created initially, and arrays created\n"
  " * as the result of a convert_to() operation.  See geomEnums.h.\n"
  " *\n"
  " * However, each individual array may be replaced with a different array\n"
  " * object with an independent usage hint specified, so there is no guarantee\n"
  " * that the individual arrays all have the same usage_hint.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_usage_hint_582_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::set_usage_hint(GeomEnums::UsageHint usage_hint)
 */
static PyObject *Dtool_GeomVertexData_set_usage_hint_583(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.set_usage_hint")) {
    return nullptr;
  }
  // 1-void GeomVertexData::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_usage_hint)((GeomEnums::UsageHint)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const GeomVertexData self, int usage_hint)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_set_usage_hint_583_comment =
  "C++ Interface:\n"
  "set_usage_hint(const GeomVertexData self, int usage_hint)\n"
  "\n"
  "/**\n"
  " * Changes the UsageHint hint for this vertex data, and for all of the arrays\n"
  " * that share this data.  See get_usage_hint().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_set_usage_hint_583_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexFormat const *GeomVertexData::get_format(void) const
 */
static PyObject *Dtool_GeomVertexData_get_format_585(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline GeomVertexFormat const *GeomVertexData::get_format(void) const
  GeomVertexFormat const *return_value = ((*(const GeomVertexData*)local_this).get_format)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_format_585_comment =
  "C++ Interface:\n"
  "get_format(GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the GeomVertexFormat structure that defines this data.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_format_585_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::set_format(GeomVertexFormat const *format)
 */
static PyObject *Dtool_GeomVertexData_set_format_586(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.set_format")) {
    return nullptr;
  }
  // 1-void GeomVertexData::set_format(GeomVertexFormat const *format)
  CPT(GeomVertexFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexFormat(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexData.set_format", "GeomVertexFormat");
  }
  ((*local_this).set_format)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_format(const GeomVertexData self, const GeomVertexFormat format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_set_format_586_comment =
  "C++ Interface:\n"
  "set_format(const GeomVertexData self, const GeomVertexFormat format)\n"
  "\n"
  "/**\n"
  " * Changes the format of the vertex data.  If the data is not empty, this will\n"
  " * implicitly change every row to match the new format.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_set_format_586_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::unclean_set_format(GeomVertexFormat const *format)
 */
static PyObject *Dtool_GeomVertexData_unclean_set_format_587(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.unclean_set_format")) {
    return nullptr;
  }
  // 1-void GeomVertexData::unclean_set_format(GeomVertexFormat const *format)
  CPT(GeomVertexFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexFormat(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexData.unclean_set_format", "GeomVertexFormat");
  }
  ((*local_this).unclean_set_format)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unclean_set_format(const GeomVertexData self, const GeomVertexFormat format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_unclean_set_format_587_comment =
  "C++ Interface:\n"
  "unclean_set_format(const GeomVertexData self, const GeomVertexFormat format)\n"
  "\n"
  "/**\n"
  " * Changes the format of the vertex data, without reformatting the data to\n"
  " * match.  The data is exactly the same after this operation, but will be\n"
  " * reinterpreted according to the new format.  This assumes that the new\n"
  " * format is fundamentally compatible with the old format; in particular, it\n"
  " * must have the same number of arrays with the same stride in each one.  No\n"
  " * checking is performed that the data remains sensible.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_unclean_set_format_587_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexData::has_column(InternalName const *name) const
 */
static PyObject *Dtool_GeomVertexData_has_column_591(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexData::has_column(InternalName const *name) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexData.has_column", "InternalName");
  }
  bool return_value = ((*(const GeomVertexData*)local_this).has_column)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_column(GeomVertexData self, const InternalName name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_has_column_591_comment =
  "C++ Interface:\n"
  "has_column(GeomVertexData self, const InternalName name)\n"
  "\n"
  "/**\n"
  " * Returns true if the data has the named column, false otherwise.  This is\n"
  " * really just a shortcut for asking the same thing from the format.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_has_column_591_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexData::get_num_rows(void) const
 */
static PyObject *Dtool_GeomVertexData_get_num_rows_592(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline int GeomVertexData::get_num_rows(void) const
  int return_value = ((*(const GeomVertexData*)local_this).get_num_rows)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_num_rows_592_comment =
  "C++ Interface:\n"
  "get_num_rows(GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of rows stored within all the arrays.  All arrays store\n"
  " * data for the same n rows.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_num_rows_592_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexData::set_num_rows(int n)
 */
static PyObject *Dtool_GeomVertexData_set_num_rows_593(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.set_num_rows")) {
    return nullptr;
  }
  // 1-inline bool GeomVertexData::set_num_rows(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).set_num_rows)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_rows(const GeomVertexData self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_set_num_rows_593_comment =
  "C++ Interface:\n"
  "set_num_rows(const GeomVertexData self, int n)\n"
  "\n"
  "/**\n"
  " * Sets the length of the array to n rows in all of the various arrays\n"
  " * (presumably by adding rows).\n"
  " *\n"
  " * The new vertex data is initialized to 0, except for the \"color\" column,\n"
  " * which is initialized to (1, 1, 1, 1).\n"
  " *\n"
  " * The return value is true if the number of rows was changed, false if the\n"
  " * object already contained n rows (or if there was some error).\n"
  " *\n"
  " * This can be used when you know exactly how many rows you will be needing.\n"
  " * It is faster than reserve_num_rows().  Also see unclean_set_num_rows() if\n"
  " * you are planning to fill in all the data yourself.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_set_num_rows_593_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexData::unclean_set_num_rows(int n)
 */
static PyObject *Dtool_GeomVertexData_unclean_set_num_rows_594(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.unclean_set_num_rows")) {
    return nullptr;
  }
  // 1-inline bool GeomVertexData::unclean_set_num_rows(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).unclean_set_num_rows)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unclean_set_num_rows(const GeomVertexData self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_unclean_set_num_rows_594_comment =
  "C++ Interface:\n"
  "unclean_set_num_rows(const GeomVertexData self, int n)\n"
  "\n"
  "/**\n"
  " * This method behaves like set_num_rows(), except the new data is not\n"
  " * initialized.  Furthermore, after this call, *any* of the data in the\n"
  " * GeomVertexData may be uninitialized, including the earlier rows.\n"
  " *\n"
  " * This is intended for applications that are about to completely fill the\n"
  " * GeomVertexData with new data anyway; it provides a tiny performance boost\n"
  " * over set_num_rows().\n"
  " *\n"
  " * This can be used when you know exactly how many rows you will be needing.\n"
  " * It is faster than reserve_num_rows().\n"
  " */";
#else
static const char *Dtool_GeomVertexData_unclean_set_num_rows_594_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexData::reserve_num_rows(int n)
 */
static PyObject *Dtool_GeomVertexData_reserve_num_rows_595(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.reserve_num_rows")) {
    return nullptr;
  }
  // 1-inline bool GeomVertexData::reserve_num_rows(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).reserve_num_rows)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reserve_num_rows(const GeomVertexData self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_reserve_num_rows_595_comment =
  "C++ Interface:\n"
  "reserve_num_rows(const GeomVertexData self, int n)\n"
  "\n"
  "/**\n"
  " * This ensures that enough memory space for n rows is allocated, so that you\n"
  " * may increase the number of rows to n without causing a new memory\n"
  " * allocation.  This is a performance optimization only; it is especially\n"
  " * useful when you know ahead of time that you will be adding n rows to the\n"
  " * data.\n"
  " *\n"
  " * If you know exactly how many rows you will be needing, it is significantly\n"
  " * faster to use set_num_rows() or unclean_set_num_rows() instead.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_reserve_num_rows_595_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::clear_rows(void)
 */
static PyObject *Dtool_GeomVertexData_clear_rows_596(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.clear_rows")) {
    return nullptr;
  }
  // 1-void GeomVertexData::clear_rows(void)
  ((*local_this).clear_rows)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_clear_rows_596_comment =
  "C++ Interface:\n"
  "clear_rows(const GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Removes all of the rows from the arrays; functionally equivalent to\n"
  " * set_num_rows(0) (but faster).\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_clear_rows_596_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t GeomVertexData::get_num_arrays(void) const
 */
static PyObject *Dtool_GeomVertexData_get_num_arrays_597(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline std::size_t GeomVertexData::get_num_arrays(void) const
  std::size_t return_value = ((*(const GeomVertexData*)local_this).get_num_arrays)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_num_arrays_597_comment =
  "C++ Interface:\n"
  "get_num_arrays(GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of individual arrays stored within the data.  This must\n"
  " * match get_format()->get_num_arrays().\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_num_arrays_597_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< GeomVertexArrayData > GeomVertexData::get_array(std::size_t i) const
 */
static PyObject *Dtool_GeomVertexData_get_array_598(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeomVertexArrayData > GeomVertexData::get_array(std::size_t i) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConstPointerTo< GeomVertexArrayData > return_value = ((*(const GeomVertexData*)local_this).get_array)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GeomVertexArrayData const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayData, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_array(GeomVertexData self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_array_598_comment =
  "C++ Interface:\n"
  "get_array(GeomVertexData self, int i)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the vertex data for the indicated array, for\n"
  " * application code to directly examine (but not modify) the underlying vertex\n"
  " * data.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_array_598_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< GeomVertexArrayDataHandle > GeomVertexData::get_array_handle(std::size_t i) const
 */
static PyObject *Dtool_GeomVertexData_get_array_handle_599(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeomVertexArrayDataHandle > GeomVertexData::get_array_handle(std::size_t i) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConstPointerTo< GeomVertexArrayDataHandle > return_value = ((*(const GeomVertexData*)local_this).get_array_handle)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GeomVertexArrayDataHandle const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayDataHandle, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_array_handle(GeomVertexData self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_array_handle_599_comment =
  "C++ Interface:\n"
  "get_array_handle(GeomVertexData self, int i)\n"
  "\n"
  "/**\n"
  " * Equivalent to get_array(i).get_handle().\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_array_handle_599_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< GeomVertexArrayData > GeomVertexData::modify_array(std::size_t i)
 */
static PyObject *Dtool_GeomVertexData_modify_array_601(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.modify_array")) {
    return nullptr;
  }
  // 1-inline PointerTo< GeomVertexArrayData > GeomVertexData::modify_array(std::size_t i)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    PointerTo< GeomVertexArrayData > return_value = ((*local_this).modify_array)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GeomVertexArrayData *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayData, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_array(const GeomVertexData self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_modify_array_601_comment =
  "C++ Interface:\n"
  "modify_array(const GeomVertexData self, int i)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the indicated vertex array, so that\n"
  " * application code may directly manipulate the data.  You should avoid\n"
  " * changing the length of this array, since all of the arrays should be kept\n"
  " * in sync--use set_num_rows() instead.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_modify_array_601_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< GeomVertexArrayDataHandle > GeomVertexData::modify_array_handle(std::size_t i)
 */
static PyObject *Dtool_GeomVertexData_modify_array_handle_602(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.modify_array_handle")) {
    return nullptr;
  }
  // 1-inline PointerTo< GeomVertexArrayDataHandle > GeomVertexData::modify_array_handle(std::size_t i)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    PointerTo< GeomVertexArrayDataHandle > return_value = ((*local_this).modify_array_handle)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GeomVertexArrayDataHandle *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayDataHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_array_handle(const GeomVertexData self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_modify_array_handle_602_comment =
  "C++ Interface:\n"
  "modify_array_handle(const GeomVertexData self, int i)\n"
  "\n"
  "/**\n"
  " * Equivalent to modify_array(i).modify_handle().\n"
  " */";
#else
static const char *Dtool_GeomVertexData_modify_array_handle_602_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexData::set_array(std::size_t i, GeomVertexArrayData const *array)
 */
static PyObject *Dtool_GeomVertexData_set_array_603(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.set_array")) {
    return nullptr;
  }
  // 1-inline void GeomVertexData::set_array(std::size_t i, GeomVertexArrayData const *array)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"i", "array", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_array", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    GeomVertexArrayData const *param2_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeomVertexArrayData, 2, "GeomVertexData.set_array", true, true);
    if (param2_this != nullptr) {
      ((*local_this).set_array)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_array(const GeomVertexData self, int i, const GeomVertexArrayData array)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_set_array_603_comment =
  "C++ Interface:\n"
  "set_array(const GeomVertexData self, int i, const GeomVertexArrayData array)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated vertex data array with a completely new array.  You\n"
  " * should be careful that the new array has the same length and format as the\n"
  " * old one, unless you know what you are doing.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_set_array_603_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformTable const *GeomVertexData::get_transform_table(void) const
 */
static PyObject *Dtool_GeomVertexData_get_transform_table_606(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline TransformTable const *GeomVertexData::get_transform_table(void) const
  TransformTable const *return_value = ((*(const GeomVertexData*)local_this).get_transform_table)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TransformTable, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_transform_table_606_comment =
  "C++ Interface:\n"
  "get_transform_table(GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the TransformTable assigned to this data.\n"
  " * Vertices within the table will index into this table to indicate their\n"
  " * dynamic skinning information; this table is used when the vertex animation\n"
  " * is to be performed by the graphics hardware (but also see\n"
  " * get_transform_blend_table()).\n"
  " *\n"
  " * This will return NULL if the vertex data does not have a TransformTable\n"
  " * assigned (which implies the vertices will not be animated by the graphics\n"
  " * hardware).\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_transform_table_606_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::set_transform_table(TransformTable const *table)
 */
static PyObject *Dtool_GeomVertexData_set_transform_table_607(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.set_transform_table")) {
    return nullptr;
  }
  // 1-void GeomVertexData::set_transform_table(TransformTable const *table)
  TransformTable const *arg_this = (TransformTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformTable, 1, "GeomVertexData.set_transform_table", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_transform_table)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform_table(const GeomVertexData self, const TransformTable table)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_set_transform_table_607_comment =
  "C++ Interface:\n"
  "set_transform_table(const GeomVertexData self, const TransformTable table)\n"
  "\n"
  "/**\n"
  " * Replaces the TransformTable on this vertex data with the indicated table.\n"
  " * The length of this table should be consistent with the maximum table index\n"
  " * assigned to the vertices under the \"transform_index\" name.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_set_transform_table_607_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexData::clear_transform_table(void)
 */
static PyObject *Dtool_GeomVertexData_clear_transform_table_608(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.clear_transform_table")) {
    return nullptr;
  }
  // 1-inline void GeomVertexData::clear_transform_table(void)
  ((*local_this).clear_transform_table)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_clear_transform_table_608_comment =
  "C++ Interface:\n"
  "clear_transform_table(const GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Sets the TransformTable pointer to NULL, removing the table from the vertex\n"
  " * data.  This disables hardware-driven vertex animation.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_clear_transform_table_608_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< TransformBlendTable > GeomVertexData::get_transform_blend_table(void) const
 */
static PyObject *Dtool_GeomVertexData_get_transform_blend_table_612(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< TransformBlendTable > GeomVertexData::get_transform_blend_table(void) const
  ConstPointerTo< TransformBlendTable > return_value = ((*(const GeomVertexData*)local_this).get_transform_blend_table)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformBlendTable const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TransformBlendTable, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_transform_blend_table_612_comment =
  "C++ Interface:\n"
  "get_transform_blend_table(GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the TransformBlendTable assigned to this data.\n"
  " * Vertices within the table will index into this table to indicate their\n"
  " * dynamic skinning information; this table is used when the vertex animation\n"
  " * is to be performed by the CPU (but also see get_transform_table()).\n"
  " *\n"
  " * This will return NULL if the vertex data does not have a\n"
  " * TransformBlendTable assigned (which implies the vertices will not be\n"
  " * animated by the CPU).\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_transform_blend_table_612_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< TransformBlendTable > GeomVertexData::modify_transform_blend_table(void)
 */
static PyObject *Dtool_GeomVertexData_modify_transform_blend_table_613(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.modify_transform_blend_table")) {
    return nullptr;
  }
  // 1-PointerTo< TransformBlendTable > GeomVertexData::modify_transform_blend_table(void)
  PointerTo< TransformBlendTable > return_value = ((*local_this).modify_transform_blend_table)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformBlendTable *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TransformBlendTable, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_modify_transform_blend_table_613_comment =
  "C++ Interface:\n"
  "modify_transform_blend_table(const GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the current TransformBlendTable on this\n"
  " * vertex data, if any, or NULL if there is not a TransformBlendTable.  See\n"
  " * get_transform_blend_table().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_modify_transform_blend_table_613_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::set_transform_blend_table(TransformBlendTable const *table)
 */
static PyObject *Dtool_GeomVertexData_set_transform_blend_table_614(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.set_transform_blend_table")) {
    return nullptr;
  }
  // 1-void GeomVertexData::set_transform_blend_table(TransformBlendTable const *table)
  TransformBlendTable const *arg_this = (TransformBlendTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformBlendTable, 1, "GeomVertexData.set_transform_blend_table", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_transform_blend_table)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform_blend_table(const GeomVertexData self, const TransformBlendTable table)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_set_transform_blend_table_614_comment =
  "C++ Interface:\n"
  "set_transform_blend_table(const GeomVertexData self, const TransformBlendTable table)\n"
  "\n"
  "/**\n"
  " * Replaces the TransformBlendTable on this vertex data with the indicated\n"
  " * table.  The length of this table should be consistent with the maximum\n"
  " * table index assigned to the vertices under the \"transform_blend\" name.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_set_transform_blend_table_614_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexData::clear_transform_blend_table(void)
 */
static PyObject *Dtool_GeomVertexData_clear_transform_blend_table_615(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.clear_transform_blend_table")) {
    return nullptr;
  }
  // 1-inline void GeomVertexData::clear_transform_blend_table(void)
  ((*local_this).clear_transform_blend_table)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_clear_transform_blend_table_615_comment =
  "C++ Interface:\n"
  "clear_transform_blend_table(const GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Sets the TransformBlendTable pointer to NULL, removing the table from the\n"
  " * vertex data.  This disables CPU-driven vertex animation.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_clear_transform_blend_table_615_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SliderTable const *GeomVertexData::get_slider_table(void) const
 */
static PyObject *Dtool_GeomVertexData_get_slider_table_616(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline SliderTable const *GeomVertexData::get_slider_table(void) const
  SliderTable const *return_value = ((*(const GeomVertexData*)local_this).get_slider_table)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SliderTable, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_slider_table_616_comment =
  "C++ Interface:\n"
  "get_slider_table(GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the SliderTable assigned to this data.  Vertices\n"
  " * within the vertex data will look up their morph offsets, if any, within\n"
  " * this table.\n"
  " *\n"
  " * This will return NULL if the vertex data does not have a SliderTable\n"
  " * assigned.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_slider_table_616_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::set_slider_table(SliderTable const *table)
 */
static PyObject *Dtool_GeomVertexData_set_slider_table_617(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.set_slider_table")) {
    return nullptr;
  }
  // 1-void GeomVertexData::set_slider_table(SliderTable const *table)
  SliderTable const *arg_this = (SliderTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SliderTable, 1, "GeomVertexData.set_slider_table", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_slider_table)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slider_table(const GeomVertexData self, const SliderTable table)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_set_slider_table_617_comment =
  "C++ Interface:\n"
  "set_slider_table(const GeomVertexData self, const SliderTable table)\n"
  "\n"
  "/**\n"
  " * Replaces the SliderTable on this vertex data with the indicated table.\n"
  " * There should be an entry in this table for each kind of morph offset\n"
  " * defined in the vertex data.\n"
  " *\n"
  " * The SliderTable object must have been registered prior to setting it on the\n"
  " * GeomVertexData.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_set_slider_table_617_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexData::clear_slider_table(void)
 */
static PyObject *Dtool_GeomVertexData_clear_slider_table_618(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.clear_slider_table")) {
    return nullptr;
  }
  // 1-inline void GeomVertexData::clear_slider_table(void)
  ((*local_this).clear_slider_table)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_clear_slider_table_618_comment =
  "C++ Interface:\n"
  "clear_slider_table(const GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Sets the SliderTable pointer to NULL, removing the table from the vertex\n"
  " * data.  This disables morph (blend shape) animation.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_clear_slider_table_618_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexData::get_num_bytes(void) const
 */
static PyObject *Dtool_GeomVertexData_get_num_bytes_622(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline int GeomVertexData::get_num_bytes(void) const
  int return_value = ((*(const GeomVertexData*)local_this).get_num_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_num_bytes_622_comment =
  "C++ Interface:\n"
  "get_num_bytes(GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes consumed by the different arrays of the\n"
  " * vertex data.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_num_bytes_622_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq GeomVertexData::get_modified(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_GeomVertexData_get_modified_623(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-inline UpdateSeq GeomVertexData::get_modified(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexData.get_modified", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      UpdateSeq *return_value = new UpdateSeq(((*(const GeomVertexData*)local_this).get_modified)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_modified(GeomVertexData self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_modified_623_comment =
  "C++ Interface:\n"
  "get_modified(GeomVertexData self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number which is guaranteed to change at least every time\n"
  " * the vertex data is modified.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_get_modified_623_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GeomVertexData::request_resident(void) const
 */
static PyObject *Dtool_GeomVertexData_request_resident_626(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-bool GeomVertexData::request_resident(void) const
  bool return_value = ((*(const GeomVertexData*)local_this).request_resident)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_request_resident_626_comment =
  "C++ Interface:\n"
  "request_resident(GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex data is currently resident in memory.  If this\n"
  " * returns false, the vertex data will be brought back into memory shortly;\n"
  " * try again later.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_request_resident_626_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::copy_from(GeomVertexData const *source, bool keep_data_objects, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_GeomVertexData_copy_from_627(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.copy_from")) {
    return nullptr;
  }
  // 1-void GeomVertexData::copy_from(GeomVertexData const *source, bool keep_data_objects, Thread *current_thread = Thread::get_current_thread())
  PyObject *param1;
  PyObject *param2;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"source", "keep_data_objects", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:copy_from", (char **)keyword_list, &param1, &param2, &param3)) {
    GeomVertexData const *param1_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GeomVertexData, 1, "GeomVertexData.copy_from", true, true);
    Thread *param3_this;
    if (param3 == nullptr) {
      param3_this = Thread::get_current_thread();
    } else {
      param3_this = (Thread *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Thread, 3, "GeomVertexData.copy_from", false, true);
    }
    if (param1_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
      ((*local_this).copy_from)(param1_this, (PyObject_IsTrue(param2) != 0), param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_from(const GeomVertexData self, const GeomVertexData source, bool keep_data_objects, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_copy_from_627_comment =
  "C++ Interface:\n"
  "copy_from(const GeomVertexData self, const GeomVertexData source, bool keep_data_objects, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Copies all the data from the other array into the corresponding data types\n"
  " * in this array, by matching data types name-by-name.\n"
  " *\n"
  " * keep_data_objects specifies what to do when one or more of the arrays can\n"
  " * be copied without the need to apply any conversion operation.  If it is\n"
  " * true, the original GeomVertexArrayData objects in this object are retained,\n"
  " * and their data arrays are copied byte-by-byte from the source; if it is\n"
  " * false, then the GeomVertexArrayData objects are copied pointerwise from the\n"
  " * source.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_copy_from_627_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::copy_row_from(int dest_row, GeomVertexData const *source, int source_row, Thread *current_thread)
 */
static PyObject *Dtool_GeomVertexData_copy_row_from_628(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.copy_row_from")) {
    return nullptr;
  }
  // 1-void GeomVertexData::copy_row_from(int dest_row, GeomVertexData const *source, int source_row, Thread *current_thread)
  int param1;
  PyObject *param2;
  int param3;
  PyObject *param4;
  static const char *keyword_list[] = {"dest_row", "source", "source_row", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOiO:copy_row_from", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    GeomVertexData const *param2_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeomVertexData, 2, "GeomVertexData.copy_row_from", true, true);
    Thread *param4_this = (Thread *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_Thread, 4, "GeomVertexData.copy_row_from", false, true);
    if (param2_this != nullptr && param4_this != nullptr) {
      ((*local_this).copy_row_from)((int)param1, param2_this, (int)param3, param4_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_row_from(const GeomVertexData self, int dest_row, const GeomVertexData source, int source_row, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_copy_row_from_628_comment =
  "C++ Interface:\n"
  "copy_row_from(const GeomVertexData self, int dest_row, const GeomVertexData source, int source_row, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Copies a single row of the data from the other array into the indicated row\n"
  " * of this array.  In this case, the source format must exactly match the\n"
  " * destination format.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_copy_row_from_628_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomVertexData > GeomVertexData::convert_to(GeomVertexFormat const *new_format) const
 */
static PyObject *Dtool_GeomVertexData_convert_to_629(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomVertexData > GeomVertexData::convert_to(GeomVertexFormat const *new_format) const
  CPT(GeomVertexFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexFormat(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexData.convert_to", "GeomVertexFormat");
  }
  ConstPointerTo< GeomVertexData > return_value = ((*(const GeomVertexData*)local_this).convert_to)(std::move(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomVertexData const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexData, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "convert_to(GeomVertexData self, const GeomVertexFormat new_format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_convert_to_629_comment =
  "C++ Interface:\n"
  "convert_to(GeomVertexData self, const GeomVertexFormat new_format)\n"
  "\n"
  "/**\n"
  " * Returns a new GeomVertexData that represents the same contents as this one,\n"
  " * with all data types matched up name-by-name to the indicated new format.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_convert_to_629_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomVertexData > GeomVertexData::scale_color(LVecBase4 const &color_scale) const
 * ConstPointerTo< GeomVertexData > GeomVertexData::scale_color(LVecBase4 const &color_scale, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const
 */
static PyObject *Dtool_GeomVertexData_scale_color_630(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "color_scale")) {
        // 1-ConstPointerTo< GeomVertexData > GeomVertexData::scale_color(LVecBase4 const &color_scale) const
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexData.scale_color", "LVecBase4f");
        }
        ConstPointerTo< GeomVertexData > return_value = ((*(const GeomVertexData*)local_this).scale_color)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        GeomVertexData const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexData, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 4:
    {
      // 1-ConstPointerTo< GeomVertexData > GeomVertexData::scale_color(LVecBase4 const &color_scale, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const
      PyObject *param1;
      int param2;
      int param3;
      int param4;
      static const char *keyword_list[] = {"color_scale", "num_components", "numeric_type", "contents", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiii:scale_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        LVecBase4f param1_local;
        LVecBase4 const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "GeomVertexData.scale_color", "LVecBase4f");
        }
        ConstPointerTo< GeomVertexData > return_value = ((*(const GeomVertexData*)local_this).scale_color)(*param1_this, (int)param2, (GeomEnums::NumericType)param3, (GeomEnums::Contents)param4);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        GeomVertexData const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexData, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "scale_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scale_color(GeomVertexData self, const LVecBase4f color_scale)\n"
      "scale_color(GeomVertexData self, const LVecBase4f color_scale, int num_components, int numeric_type, int contents)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_scale_color_630_comment =
  "C++ Interface:\n"
  "scale_color(GeomVertexData self, const LVecBase4f color_scale)\n"
  "scale_color(GeomVertexData self, const LVecBase4f color_scale, int num_components, int numeric_type, int contents)\n"
  "\n"
  "/**\n"
  " * Returns a new GeomVertexData object with the color table modified in-place\n"
  " * to apply the indicated scale.\n"
  " *\n"
  " * If the vertex data does not include a color column, a new one will not be\n"
  " * added.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a new GeomVertexData object with the color table replaced with a\n"
  " * new color table that has been scaled by the indicated value.  The new color\n"
  " * table will be added as a new array; if the old color table was interleaved\n"
  " * with a previous array, the previous array will not be repacked.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_scale_color_630_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomVertexData > GeomVertexData::set_color(LColor const &color) const
 * ConstPointerTo< GeomVertexData > GeomVertexData::set_color(LColor const &color, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const
 */
static PyObject *Dtool_GeomVertexData_set_color_631(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "color")) {
        // 1-ConstPointerTo< GeomVertexData > GeomVertexData::set_color(LColor const &color) const
        LVecBase4f arg_local;
        LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexData.set_color", "LVecBase4f");
        }
        ConstPointerTo< GeomVertexData > return_value = ((*(const GeomVertexData*)local_this).set_color)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        GeomVertexData const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexData, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 4:
    {
      // 1-ConstPointerTo< GeomVertexData > GeomVertexData::set_color(LColor const &color, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const
      PyObject *param1;
      int param2;
      int param3;
      int param4;
      static const char *keyword_list[] = {"color", "num_components", "numeric_type", "contents", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiii:set_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        LVecBase4f param1_local;
        LColor const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "GeomVertexData.set_color", "LVecBase4f");
        }
        ConstPointerTo< GeomVertexData > return_value = ((*(const GeomVertexData*)local_this).set_color)(*param1_this, (int)param2, (GeomEnums::NumericType)param3, (GeomEnums::Contents)param4);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        GeomVertexData const *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexData, true, true, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(GeomVertexData self, const LVecBase4f color)\n"
      "set_color(GeomVertexData self, const LVecBase4f color, int num_components, int numeric_type, int contents)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_set_color_631_comment =
  "C++ Interface:\n"
  "set_color(GeomVertexData self, const LVecBase4f color)\n"
  "set_color(GeomVertexData self, const LVecBase4f color, int num_components, int numeric_type, int contents)\n"
  "\n"
  "/**\n"
  " * Returns a new GeomVertexData object with the color data modified in-place\n"
  " * with the new value.\n"
  " *\n"
  " * If the vertex data does not include a color column, a new one will not be\n"
  " * added.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a new GeomVertexData object with the color table replaced with a\n"
  " * new color table for which each vertex has the indicated value.  The new\n"
  " * color table will be added as a new array; if the old color table was\n"
  " * interleaved with a previous array, the previous array will not be repacked.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_set_color_631_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomVertexData > GeomVertexData::reverse_normals(void) const
 */
static PyObject *Dtool_GeomVertexData_reverse_normals_632(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomVertexData > GeomVertexData::reverse_normals(void) const
  ConstPointerTo< GeomVertexData > return_value = ((*(const GeomVertexData*)local_this).reverse_normals)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomVertexData const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexData, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_reverse_normals_632_comment =
  "C++ Interface:\n"
  "reverse_normals(GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Returns a new GeomVertexData object with the normal data modified in-place,\n"
  " * so that each lighting normal is now facing in the opposite direction.\n"
  " *\n"
  " * If the vertex data does not include a normal column, this returns the\n"
  " * original GeomVertexData object, unchanged.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_reverse_normals_632_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomVertexData > GeomVertexData::animate_vertices(bool force, Thread *current_thread) const
 */
static PyObject *Dtool_GeomVertexData_animate_vertices_633(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomVertexData > GeomVertexData::animate_vertices(bool force, Thread *current_thread) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"force", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:animate_vertices", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexData.animate_vertices", false, true);
    if (param2_this != nullptr) {
      ConstPointerTo< GeomVertexData > return_value = ((*(const GeomVertexData*)local_this).animate_vertices)((PyObject_IsTrue(param1) != 0), param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GeomVertexData const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexData, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "animate_vertices(GeomVertexData self, bool force, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_animate_vertices_633_comment =
  "C++ Interface:\n"
  "animate_vertices(GeomVertexData self, bool force, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a GeomVertexData that represents the results of computing the\n"
  " * vertex animation on the CPU for this GeomVertexData.\n"
  " *\n"
  " * If there is no CPU-defined vertex animation on this object, this just\n"
  " * returns the original object.\n"
  " *\n"
  " * If there is vertex animation, but the VertexTransform values have not\n"
  " * changed since last time, this may return the same pointer it returned\n"
  " * previously.  Even if the VertexTransform values have changed, it may still\n"
  " * return the same pointer, but with its contents modified (this is preferred,\n"
  " * since it allows the graphics backend to update vertex buffers optimally).\n"
  " *\n"
  " * If force is false, this method may return immediately with stale data, if\n"
  " * the vertex data is not completely resident.  If force is true, this method\n"
  " * will never return stale data, but may block until the data is available.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_animate_vertices_633_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::clear_animated_vertices(void)
 */
static PyObject *Dtool_GeomVertexData_clear_animated_vertices_634(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.clear_animated_vertices")) {
    return nullptr;
  }
  // 1-void GeomVertexData::clear_animated_vertices(void)
  ((*local_this).clear_animated_vertices)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_clear_animated_vertices_634_comment =
  "C++ Interface:\n"
  "clear_animated_vertices(const GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Removes the cache of animated vertices computed by a previous call to\n"
  " * animate_vertices() within the same frame.  This will force the next call to\n"
  " * animate_vertices() to recompute these values from scratch.  Normally it is\n"
  " * not necessary to call this.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_clear_animated_vertices_634_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::transform_vertices(LMatrix4 const &mat)
 * void GeomVertexData::transform_vertices(LMatrix4 const &mat, SparseArray const &rows)
 * void GeomVertexData::transform_vertices(LMatrix4 const &mat, int begin_row, int end_row)
 */
static PyObject *Dtool_GeomVertexData_transform_vertices_635(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.transform_vertices")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "mat")) {
        // 1-void GeomVertexData::transform_vertices(LMatrix4 const &mat)
        LMatrix4f arg_local;
        LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexData.transform_vertices", "LMatrix4f");
        }
        ((*local_this).transform_vertices)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void GeomVertexData::transform_vertices(LMatrix4 const &mat, SparseArray const &rows)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"mat", "rows", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:transform_vertices", (char **)keyword_list, &param1, &param2)) {
        LMatrix4f param1_local;
        LMatrix4 const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "GeomVertexData.transform_vertices", "LMatrix4f");
        }
        SparseArray param2_local;
        SparseArray const *param2_this = Dtool_Coerce_SparseArray(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "GeomVertexData.transform_vertices", "SparseArray");
        }
        ((*local_this).transform_vertices)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-void GeomVertexData::transform_vertices(LMatrix4 const &mat, int begin_row, int end_row)
      PyObject *param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"mat", "begin_row", "end_row", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:transform_vertices", (char **)keyword_list, &param1, &param2, &param3)) {
        LMatrix4f param1_local;
        LMatrix4 const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "GeomVertexData.transform_vertices", "LMatrix4f");
        }
        ((*local_this).transform_vertices)(*param1_this, (int)param2, (int)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "transform_vertices() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform_vertices(const GeomVertexData self, const LMatrix4f mat)\n"
      "transform_vertices(const GeomVertexData self, const LMatrix4f mat, const SparseArray rows)\n"
      "transform_vertices(const GeomVertexData self, const LMatrix4f mat, int begin_row, int end_row)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_transform_vertices_635_comment =
  "C++ Interface:\n"
  "transform_vertices(const GeomVertexData self, const LMatrix4f mat)\n"
  "transform_vertices(const GeomVertexData self, const LMatrix4f mat, const SparseArray rows)\n"
  "transform_vertices(const GeomVertexData self, const LMatrix4f mat, int begin_row, int end_row)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transform matrix to all of the vertices in the\n"
  " * GeomVertexData.  The transform is applied to all \"point\" and \"vector\" type\n"
  " * columns described in the format.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Applies the indicated transform matrix to all of the vertices from\n"
  " * begin_row up to but not including end_row.  The transform is applied to all\n"
  " * \"point\" and \"vector\" type columns described in the format.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Applies the indicated transform matrix to all of the vertices mentioned in\n"
  " * the sparse array.  The transform is applied to all \"point\" and \"vector\"\n"
  " * type columns described in the format.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_transform_vertices_635_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< GeomVertexData > GeomVertexData::replace_column(InternalName *name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const
 */
static PyObject *Dtool_GeomVertexData_replace_column_636(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-PointerTo< GeomVertexData > GeomVertexData::replace_column(InternalName *name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const
  PyObject *param1;
  int param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"name", "num_components", "numeric_type", "contents", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiii:replace_column", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    PT(InternalName) param1_this;
    if (!Dtool_Coerce_InternalName(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GeomVertexData.replace_column", "InternalName");
    }
    PointerTo< GeomVertexData > return_value = ((*(const GeomVertexData*)local_this).replace_column)(std::move(param1_this), (int)param2, (GeomEnums::NumericType)param3, (GeomEnums::Contents)param4);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GeomVertexData *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexData, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "replace_column(GeomVertexData self, InternalName name, int num_components, int numeric_type, int contents)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_replace_column_636_comment =
  "C++ Interface:\n"
  "replace_column(GeomVertexData self, InternalName name, int num_components, int numeric_type, int contents)\n"
  "\n"
  "/**\n"
  " * Returns a new GeomVertexData object, suitable for modification, with the\n"
  " * indicated data type replaced with a new table filled with undefined values.\n"
  " * The new table will be added as a new array; if the old table was\n"
  " * interleaved with a previous array, the previous array will not be repacked.\n"
  " *\n"
  " * If num_components is 0, the indicated name is simply removed from the type,\n"
  " * without replacing it with anything else.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_replace_column_636_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::output(std::ostream &out) const
 */
static PyObject *Dtool_GeomVertexData_output_637(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-void GeomVertexData::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GeomVertexData.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GeomVertexData*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GeomVertexData self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_output_637_comment =
  "C++ Interface:\n"
  "output(GeomVertexData self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexData_output_637_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_GeomVertexData_write_638(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-void GeomVertexData::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "GeomVertexData.write", false, true);
    if (param1_this != nullptr) {
      ((*(const GeomVertexData*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(GeomVertexData self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_write_638_comment =
  "C++ Interface:\n"
  "write(GeomVertexData self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexData_write_638_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::describe_vertex(std::ostream &out, int row) const
 */
static PyObject *Dtool_GeomVertexData_describe_vertex_639(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexData)) {
    return nullptr;
  }
  // 1-void GeomVertexData::describe_vertex(std::ostream &out, int row) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "row", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:describe_vertex", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "GeomVertexData.describe_vertex", false, true);
    if (param1_this != nullptr) {
      ((*(const GeomVertexData*)local_this).describe_vertex)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "describe_vertex(GeomVertexData self, ostream out, int row)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_describe_vertex_639_comment =
  "C++ Interface:\n"
  "describe_vertex(GeomVertexData self, ostream out, int row)\n"
  "\n"
  "/**\n"
  " * Writes a verbose, human-friendly description of the indicated vertex\n"
  " * number.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_describe_vertex_639_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::clear_cache(void)
 */
static PyObject *Dtool_GeomVertexData_clear_cache_640(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.clear_cache")) {
    return nullptr;
  }
  // 1-void GeomVertexData::clear_cache(void)
  ((*local_this).clear_cache)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_clear_cache_640_comment =
  "C++ Interface:\n"
  "clear_cache(const GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Removes all of the previously-cached results of convert_to().\n"
  " *\n"
  " * This blows away the entire cache, upstream and downstream the pipeline.\n"
  " * Use clear_cache_stage() instead if you only want to blow away the cache at\n"
  " * the current stage and upstream.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_clear_cache_640_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexData::clear_cache_stage(void)
 */
static PyObject *Dtool_GeomVertexData_clear_cache_stage_641(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.clear_cache_stage")) {
    return nullptr;
  }
  // 1-void GeomVertexData::clear_cache_stage(void)
  ((*local_this).clear_cache_stage)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_clear_cache_stage_641_comment =
  "C++ Interface:\n"
  "clear_cache_stage(const GeomVertexData self)\n"
  "\n"
  "/**\n"
  " * Removes all of the previously-cached results of convert_to(), at the\n"
  " * current pipeline stage and upstream.  Does not affect the downstream cache.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomVertexData_clear_cache_stage_641_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeomVertexData::get_class_type(void)
 */
static PyObject *Dtool_GeomVertexData_get_class_type_642(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomVertexData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomVertexData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_get_class_type_642_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomVertexData_get_class_type_642_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CopyOnWriteObject *GeomVertexData::upcast_to_CopyOnWriteObject(void)
 */
static PyObject *Dtool_GeomVertexData_upcast_to_CopyOnWriteObject_568(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.upcast_to_CopyOnWriteObject")) {
    return nullptr;
  }
  // 1-CopyOnWriteObject *GeomVertexData::upcast_to_CopyOnWriteObject(void)
  CopyOnWriteObject *return_value = (CopyOnWriteObject *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CopyOnWriteObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_upcast_to_CopyOnWriteObject_568_comment =
  "C++ Interface:\n"
  "upcast_to_CopyOnWriteObject(const GeomVertexData self)\n"
  "\n"
  "upcast from GeomVertexData to CopyOnWriteObject";
#else
static const char *Dtool_GeomVertexData_upcast_to_CopyOnWriteObject_568_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomEnums *GeomVertexData::upcast_to_GeomEnums(void)
 */
static PyObject *Dtool_GeomVertexData_upcast_to_GeomEnums_570(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.upcast_to_GeomEnums")) {
    return nullptr;
  }
  // 1-GeomEnums *GeomVertexData::upcast_to_GeomEnums(void)
  GeomEnums *return_value = (GeomEnums *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomEnums, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexData_upcast_to_GeomEnums_570_comment =
  "C++ Interface:\n"
  "upcast_to_GeomEnums(const GeomVertexData self)\n"
  "\n"
  "upcast from GeomVertexData to GeomEnums";
#else
static const char *Dtool_GeomVertexData_upcast_to_GeomEnums_570_comment = nullptr;
#endif

static PyObject *Dtool_GeomVertexData_name_Getter(PyObject *self, void *) {
  const GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &GeomVertexData::get_name(void) const
  std::string const &return_value = ((*(const GeomVertexData*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GeomVertexData_name_Setter(PyObject *self, PyObject *arg, void *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete name attribute");
    return -1;
  }
  // 1-void GeomVertexData::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_name(const GeomVertexData self, str name)\n");
  }
  return -1;
}

static PyObject *Dtool_GeomVertexData_usage_hint_Getter(PyObject *self, void *) {
  const GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::UsageHint GeomVertexData::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const GeomVertexData*)local_this).get_usage_hint)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GeomVertexData_usage_hint_Setter(PyObject *self, PyObject *arg, void *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.usage_hint")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete usage_hint attribute");
    return -1;
  }
  // 1-void GeomVertexData::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_usage_hint)((GeomEnums::UsageHint)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const GeomVertexData self, int usage_hint)\n");
  }
  return -1;
}

static PyObject *Dtool_GeomVertexData_format_Getter(PyObject *self, void *) {
  const GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomVertexFormat const *GeomVertexData::get_format(void) const
  GeomVertexFormat const *return_value = ((*(const GeomVertexData*)local_this).get_format)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexFormat, true, true);
}

static int Dtool_GeomVertexData_format_Setter(PyObject *self, PyObject *arg, void *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.format")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete format attribute");
    return -1;
  }
  // 1-void GeomVertexData::set_format(GeomVertexFormat const *format)
  CPT(GeomVertexFormat) arg_this;
  if (!Dtool_ConstCoerce_GeomVertexFormat(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexData.set_format", "GeomVertexFormat");
    return -1;
  }
  ((*local_this).set_format)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_format(const GeomVertexData self, const GeomVertexFormat format)\n");
  }
  return -1;
}

/**
 * sequence length function for property GeomVertexData::arrays
 */
static Py_ssize_t Dtool_GeomVertexData_arrays_Len(PyObject *self) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_arrays)();
}

/**
 * sequence getter for property GeomVertexData::arrays
 */
static PyObject *Dtool_GeomVertexData_arrays_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_arrays)()) {
    PyErr_SetString(PyExc_IndexError, "GeomVertexData.arrays[] index out of range");
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeomVertexArrayData > GeomVertexData::get_array(std::size_t i) const
  ConstPointerTo< GeomVertexArrayData > return_value = ((*(const GeomVertexData*)local_this).get_array)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  GeomVertexArrayData const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayData, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_array(GeomVertexData self, index)\n");
  }
}

static int Dtool_GeomVertexData_arrays_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.arrays")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_arrays)()) {
    PyErr_SetString(PyExc_IndexError, "GeomVertexData.arrays[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete arrays[] attribute");
    return -1;
  }
  // 1-inline void GeomVertexData::set_array(std::size_t i, GeomVertexArrayData const *array)
  GeomVertexArrayData const *arg_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayData, 2, "GeomVertexData.set_array", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_array)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_array(const GeomVertexData self, index, const GeomVertexArrayData array)\n");
  }
  return -1;
}

static PyObject *Dtool_GeomVertexData_arrays_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "GeomVertexData.arrays");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_GeomVertexData_arrays_Len;
    wrap->_getitem_func = &Dtool_GeomVertexData_arrays_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_GeomVertexData_arrays_Sequence_Setitem;
    }
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_GeomVertexData_transform_table_Getter(PyObject *self, void *) {
  const GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline TransformTable const *GeomVertexData::get_transform_table(void) const
  TransformTable const *return_value = ((*(const GeomVertexData*)local_this).get_transform_table)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TransformTable, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_GeomVertexData_transform_table_Setter(PyObject *self, PyObject *arg, void *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.transform_table")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete transform_table attribute");
    return -1;
  }
  // 1-void GeomVertexData::set_transform_table(TransformTable const *table)
  TransformTable const *arg_this = (TransformTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformTable, 1, "GeomVertexData.set_transform_table", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_transform_table)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_transform_table(const GeomVertexData self, const TransformTable table)\n");
  }
  return -1;
}

static PyObject *Dtool_GeomVertexData_slider_table_Getter(PyObject *self, void *) {
  const GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SliderTable const *GeomVertexData::get_slider_table(void) const
  SliderTable const *return_value = ((*(const GeomVertexData*)local_this).get_slider_table)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SliderTable, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_GeomVertexData_slider_table_Setter(PyObject *self, PyObject *arg, void *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexData, (void **)&local_this, "GeomVertexData.slider_table")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete slider_table attribute");
    return -1;
  }
  // 1-void GeomVertexData::set_slider_table(SliderTable const *table)
  SliderTable const *arg_this = (SliderTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SliderTable, 1, "GeomVertexData.set_slider_table", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_slider_table)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_slider_table(const GeomVertexData self, const SliderTable table)\n");
  }
  return -1;
}

static PyObject *Dtool_GeomVertexData_num_bytes_Getter(PyObject *self, void *) {
  const GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GeomVertexData::get_num_bytes(void) const
  int return_value = ((*(const GeomVertexData*)local_this).get_num_bytes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomVertexData_modified_Getter(PyObject *self, void *) {
  const GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq GeomVertexData::get_modified(Thread *current_thread) const
  UpdateSeq *return_value = new UpdateSeq(((*(const GeomVertexData*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

/**
 * Python function wrapper for:
 * GeomVertexData::GeomVertexData(GeomVertexData const &copy)
 * explicit GeomVertexData::GeomVertexData(GeomVertexData const &copy, GeomVertexFormat const *format)
 * explicit GeomVertexData::GeomVertexData(std::string const &name, GeomVertexFormat const *format, GeomEnums::UsageHint usage_hint)
 */
static int Dtool_Init_GeomVertexData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-GeomVertexData::GeomVertexData(GeomVertexData const &copy)
        GeomVertexData const *arg_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexData, 0, "GeomVertexData.GeomVertexData", true, true);
        if (arg_this != nullptr) {
          GeomVertexData *return_value = new GeomVertexData(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexData, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-explicit GeomVertexData::GeomVertexData(GeomVertexData const &copy, GeomVertexFormat const *format)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"copy", "format", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:GeomVertexData", (char **)keyword_list, &param0, &param1)) {
        GeomVertexData const *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexData.GeomVertexData", true, true);
        CPT(GeomVertexFormat) param1_this;
        if (!Dtool_ConstCoerce_GeomVertexFormat(param1, param1_this)) {
          Dtool_Raise_ArgTypeError(param1, 1, "GeomVertexData.GeomVertexData", "GeomVertexFormat");
          return -1;
        }
        if (param0_this != nullptr) {
          GeomVertexData *return_value = new GeomVertexData(*param0_this, std::move(param1_this));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexData, true, false);
        }
      }
    }
    break;
  case 3:
    {
      // 1-explicit GeomVertexData::GeomVertexData(std::string const &name, GeomVertexFormat const *format, GeomEnums::UsageHint usage_hint)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"name", "format", "usage_hint", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oi:GeomVertexData", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2)) {
        CPT(GeomVertexFormat) param1_this;
        if (!Dtool_ConstCoerce_GeomVertexFormat(param1, param1_this)) {
          Dtool_Raise_ArgTypeError(param1, 1, "GeomVertexData.GeomVertexData", "GeomVertexFormat");
          return -1;
        }
        GeomVertexData *return_value = new GeomVertexData(std::string(param0_str, param0_len), std::move(param1_this), (GeomEnums::UsageHint)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexData, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomVertexData() takes 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomVertexData(const GeomVertexData copy)\n"
      "GeomVertexData(const GeomVertexData copy, const GeomVertexFormat format)\n"
      "GeomVertexData(str name, const GeomVertexFormat format, int usage_hint)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomVertexData_get_arrays(PyObject *self, PyObject *) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_arrays)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomVertexData_get_array_598(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_GeomVertexData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomVertexData) {
    printf("GeomVertexData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomVertexData *local_this = (GeomVertexData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomVertexData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomVertexData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomVertexData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomVertexData*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomVertexData*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomVertexData*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomVertexData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomVertexData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomVertexData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomVertexData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimateVerticesRequest
 */
/**
 * Python function wrapper for:
 * inline bool AnimateVerticesRequest::is_ready(void) const
 */
static PyObject *Dtool_AnimateVerticesRequest_is_ready_646(PyObject *self, PyObject *) {
  AnimateVerticesRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimateVerticesRequest)) {
    return nullptr;
  }
  // 1-inline bool AnimateVerticesRequest::is_ready(void) const
  bool return_value = ((*(const AnimateVerticesRequest*)local_this).is_ready)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimateVerticesRequest_is_ready_646_comment =
  "C++ Interface:\n"
  "is_ready(AnimateVerticesRequest self)\n"
  "\n"
  "/**\n"
  " * Returns true if this request has completed, false if it is still pending.\n"
  " * Equivalent to `req.done() and not req.cancelled()`.\n"
  " * @see done()\n"
  " */";
#else
static const char *Dtool_AnimateVerticesRequest_is_ready_646_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimateVerticesRequest::get_class_type(void)
 */
static PyObject *Dtool_AnimateVerticesRequest_get_class_type_647(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimateVerticesRequest::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimateVerticesRequest::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimateVerticesRequest_get_class_type_647_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimateVerticesRequest_get_class_type_647_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AnimateVerticesRequest::AnimateVerticesRequest(AnimateVerticesRequest const &) = default
 * inline explicit AnimateVerticesRequest::AnimateVerticesRequest(GeomVertexData *geom_vertex_data)
 */
static int Dtool_Init_AnimateVerticesRequest(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AnimateVerticesRequest() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline AnimateVerticesRequest::AnimateVerticesRequest(AnimateVerticesRequest const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      AnimateVerticesRequest const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_AnimateVerticesRequest);
      if (param0_this != nullptr) {
        AnimateVerticesRequest *return_value = new AnimateVerticesRequest(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimateVerticesRequest, true, false);
      }
    }
  }

  {
    // -2 inline explicit AnimateVerticesRequest::AnimateVerticesRequest(GeomVertexData *geom_vertex_data)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "geom_vertex_data")) {
      GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "AnimateVerticesRequest.AnimateVerticesRequest", false, false);
      if (param0_this != nullptr) {
        AnimateVerticesRequest *return_value = new AnimateVerticesRequest(param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimateVerticesRequest, true, false);
      }
    }
  }

  // No coercion possible: inline AnimateVerticesRequest::AnimateVerticesRequest(AnimateVerticesRequest const &) = default
  // No coercion possible: inline explicit AnimateVerticesRequest::AnimateVerticesRequest(GeomVertexData *geom_vertex_data)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimateVerticesRequest(const AnimateVerticesRequest param0)\n"
      "AnimateVerticesRequest(GeomVertexData geom_vertex_data)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AnimateVerticesRequest(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimateVerticesRequest) {
    printf("AnimateVerticesRequest ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimateVerticesRequest *local_this = (AnimateVerticesRequest *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimateVerticesRequest) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncFuture) {
    return (AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimateVerticesRequest(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimateVerticesRequest) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    AsyncFuture* other_this = (AsyncFuture*)from_this;
    return (AnimateVerticesRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (AnimateVerticesRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimateVerticesRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimateVerticesRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimateVerticesRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AnimateVerticesRequest*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SavedContext
 */
/**
 * Python function wrapper for:
 * static TypeHandle SavedContext::get_class_type(void)
 */
static PyObject *Dtool_SavedContext_get_class_type_651(PyObject *, PyObject *) {
  // 1-static TypeHandle SavedContext::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((SavedContext::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SavedContext_get_class_type_651_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SavedContext_get_class_type_651_comment = nullptr;
#endif

static int Dtool_Init_SavedContext(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_SavedContext(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SavedContext) {
    printf("SavedContext ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SavedContext *local_this = (SavedContext *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SavedContext) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SavedContext(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SavedContext) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SavedContext*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BufferContext
 */
/**
 * Python function wrapper for:
 * inline std::size_t BufferContext::get_data_size_bytes(void) const
 */
static PyObject *Dtool_BufferContext_get_data_size_bytes_657(PyObject *self, PyObject *) {
  BufferContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BufferContext)) {
    return nullptr;
  }
  // 1-inline std::size_t BufferContext::get_data_size_bytes(void) const
  std::size_t return_value = ((*(const BufferContext*)local_this).get_data_size_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BufferContext_get_data_size_bytes_657_comment =
  "C++ Interface:\n"
  "get_data_size_bytes(BufferContext self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes previously reported for the data object.  This\n"
  " * is used to track changes in the data object's allocated size; if it changes\n"
  " * from this, we need to create a new buffer.  This is also used to track\n"
  " * memory utilization in PStats.\n"
  " */";
#else
static const char *Dtool_BufferContext_get_data_size_bytes_657_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq BufferContext::get_modified(void) const
 */
static PyObject *Dtool_BufferContext_get_modified_658(PyObject *self, PyObject *) {
  BufferContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BufferContext)) {
    return nullptr;
  }
  // 1-inline UpdateSeq BufferContext::get_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const BufferContext*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BufferContext_get_modified_658_comment =
  "C++ Interface:\n"
  "get_modified(BufferContext self)\n"
  "\n"
  "/**\n"
  " * Returns the UpdateSeq that was recorded the last time mark_loaded() was\n"
  " * called.\n"
  " */";
#else
static const char *Dtool_BufferContext_get_modified_658_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BufferContext::get_active(void) const
 */
static PyObject *Dtool_BufferContext_get_active_659(PyObject *self, PyObject *) {
  BufferContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BufferContext)) {
    return nullptr;
  }
  // 1-inline bool BufferContext::get_active(void) const
  bool return_value = ((*(const BufferContext*)local_this).get_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BufferContext_get_active_659_comment =
  "C++ Interface:\n"
  "get_active(BufferContext self)\n"
  "\n"
  "/**\n"
  " * Returns the active flag associated with this object.  An object is\n"
  " * considered \"active\" if it was rendered in the current frame.\n"
  " */";
#else
static const char *Dtool_BufferContext_get_active_659_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BufferContext::get_resident(void) const
 */
static PyObject *Dtool_BufferContext_get_resident_660(PyObject *self, PyObject *) {
  BufferContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BufferContext)) {
    return nullptr;
  }
  // 1-inline bool BufferContext::get_resident(void) const
  bool return_value = ((*(const BufferContext*)local_this).get_resident)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BufferContext_get_resident_660_comment =
  "C++ Interface:\n"
  "get_resident(BufferContext self)\n"
  "\n"
  "/**\n"
  " * Returns the resident flag associated with this object.  An object is\n"
  " * considered \"resident\" if it appears to be resident in texture memory.\n"
  " */";
#else
static const char *Dtool_BufferContext_get_resident_660_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BufferContext::get_class_type(void)
 */
static PyObject *Dtool_BufferContext_get_class_type_668(PyObject *, PyObject *) {
  // 1-static TypeHandle BufferContext::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BufferContext::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BufferContext_get_class_type_668_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BufferContext_get_class_type_668_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SavedContext *BufferContext::upcast_to_SavedContext(void)
 */
static PyObject *Dtool_BufferContext_upcast_to_SavedContext_654(PyObject *self, PyObject *) {
  BufferContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BufferContext, (void **)&local_this, "BufferContext.upcast_to_SavedContext")) {
    return nullptr;
  }
  // 1-SavedContext *BufferContext::upcast_to_SavedContext(void)
  SavedContext *return_value = (SavedContext *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SavedContext, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BufferContext_upcast_to_SavedContext_654_comment =
  "C++ Interface:\n"
  "upcast_to_SavedContext(const BufferContext self)\n"
  "\n"
  "upcast from BufferContext to SavedContext";
#else
static const char *Dtool_BufferContext_upcast_to_SavedContext_654_comment = nullptr;
#endif

static PyObject *Dtool_BufferContext_object_Getter(PyObject *self, void *) {
  const BufferContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BufferContext, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline TypedWritableReferenceCount *BufferContext::get_object(void) const
  TypedWritableReferenceCount *return_value = ((*(const BufferContext*)local_this).get_object)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_BufferContext_data_size_bytes_Getter(PyObject *self, void *) {
  const BufferContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BufferContext, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t BufferContext::get_data_size_bytes(void) const
  std::size_t return_value = ((*(const BufferContext*)local_this).get_data_size_bytes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BufferContext_modified_Getter(PyObject *self, void *) {
  const BufferContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BufferContext, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq BufferContext::get_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const BufferContext*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

static PyObject *Dtool_BufferContext_active_Getter(PyObject *self, void *) {
  const BufferContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BufferContext, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool BufferContext::get_active(void) const
  bool return_value = ((*(const BufferContext*)local_this).get_active)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BufferContext_resident_Getter(PyObject *self, void *) {
  const BufferContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BufferContext, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool BufferContext::get_resident(void) const
  bool return_value = ((*(const BufferContext*)local_this).get_resident)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_BufferContext(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BufferContext(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BufferContext) {
    printf("BufferContext ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BufferContext *local_this = (BufferContext *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BufferContext) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_SavedContext) {
    return (SavedContext *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(SavedContext *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BufferContext(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BufferContext) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_SavedContext) {
    SavedContext* other_this = (SavedContext*)from_this;
    return (BufferContext*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BufferContext*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomPrimitive
 */
/**
 * Python function wrapper for:
 * void GeomPrimitive::operator =(GeomPrimitive const &copy)
 */
static PyObject *Dtool_GeomPrimitive_operator_674(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.assign")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::operator =(GeomPrimitive const &copy)
  GeomPrimitive const *arg_this = (GeomPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomPrimitive, 1, "GeomPrimitive.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    GeomPrimitive *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomPrimitive, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GeomPrimitive self, const GeomPrimitive copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_operator_674_comment =
  "C++ Interface:\n"
  "assign(const GeomPrimitive self, const GeomPrimitive copy)\n";
#else
static const char *Dtool_GeomPrimitive_operator_674_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PointerTo< GeomPrimitive > GeomPrimitive::make_copy(void) const = 0
 */
static PyObject *Dtool_GeomPrimitive_make_copy_679(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-virtual PointerTo< GeomPrimitive > GeomPrimitive::make_copy(void) const = 0
  PointerTo< GeomPrimitive > return_value = ((*(const GeomPrimitive*)local_this).make_copy)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomPrimitive *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_make_copy_679_comment =
  "C++ Interface:\n"
  "make_copy(GeomPrimitive self)\n";
#else
static const char *Dtool_GeomPrimitive_make_copy_679_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual GeomEnums::PrimitiveType GeomPrimitive::get_primitive_type(void) const = 0
 */
static PyObject *Dtool_GeomPrimitive_get_primitive_type_680(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-virtual GeomEnums::PrimitiveType GeomPrimitive::get_primitive_type(void) const = 0
  GeomEnums::PrimitiveType return_value = ((*(const GeomPrimitive*)local_this).get_primitive_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_primitive_type_680_comment =
  "C++ Interface:\n"
  "get_primitive_type(GeomPrimitive self)\n";
#else
static const char *Dtool_GeomPrimitive_get_primitive_type_680_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int GeomPrimitive::get_geom_rendering(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_geom_rendering_681(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-virtual int GeomPrimitive::get_geom_rendering(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_geom_rendering)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_geom_rendering_681_comment =
  "C++ Interface:\n"
  "get_geom_rendering(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the set of GeomRendering bits that represent the rendering\n"
  " * properties required to properly render this primitive.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_geom_rendering_681_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::ShadeModel GeomPrimitive::get_shade_model(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_shade_model_684(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline GeomEnums::ShadeModel GeomPrimitive::get_shade_model(void) const
  GeomEnums::ShadeModel return_value = ((*(const GeomPrimitive*)local_this).get_shade_model)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_shade_model_684_comment =
  "C++ Interface:\n"
  "get_shade_model(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the ShadeModel hint for this primitive.  This is intended as a hint\n"
  " * to the renderer to tell it how the per-vertex colors and normals are\n"
  " * applied.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_shade_model_684_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomPrimitive::set_shade_model(GeomEnums::ShadeModel shade_model)
 */
static PyObject *Dtool_GeomPrimitive_set_shade_model_685(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.set_shade_model")) {
    return nullptr;
  }
  // 1-inline void GeomPrimitive::set_shade_model(GeomEnums::ShadeModel shade_model)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_shade_model)((GeomEnums::ShadeModel)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shade_model(const GeomPrimitive self, int shade_model)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_set_shade_model_685_comment =
  "C++ Interface:\n"
  "set_shade_model(const GeomPrimitive self, int shade_model)\n"
  "\n"
  "/**\n"
  " * Changes the ShadeModel hint for this primitive.  This is different from the\n"
  " * ShadeModelAttrib that might also be applied from the scene graph.  This\n"
  " * does not affect the shade model that is in effect when rendering, but\n"
  " * rather serves as a hint to the renderer to tell it how the per-vertex\n"
  " * colors and normals on this primitive are applied.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_set_shade_model_685_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::UsageHint GeomPrimitive::get_usage_hint(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_usage_hint_687(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline GeomEnums::UsageHint GeomPrimitive::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const GeomPrimitive*)local_this).get_usage_hint)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_usage_hint_687_comment =
  "C++ Interface:\n"
  "get_usage_hint(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the usage hint for this primitive.  See geomEnums.h.  This has\n"
  " * nothing to do with the usage hint associated with the primitive's vertices;\n"
  " * this only specifies how often the vertex indices that define the primitive\n"
  " * will be modified.\n"
  " *\n"
  " * It is perfectly legal (and, in fact, common) for a GeomPrimitive to have\n"
  " * UH_static on itself, while referencing vertex data with UH_dynamic.  This\n"
  " * means that the vertices themselves will be animated, but the primitive will\n"
  " * always reference the same set of vertices from the pool.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_usage_hint_687_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::set_usage_hint(GeomEnums::UsageHint usage_hint)
 */
static PyObject *Dtool_GeomPrimitive_set_usage_hint_688(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.set_usage_hint")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_usage_hint)((GeomEnums::UsageHint)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const GeomPrimitive self, int usage_hint)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_set_usage_hint_688_comment =
  "C++ Interface:\n"
  "set_usage_hint(const GeomPrimitive self, int usage_hint)\n"
  "\n"
  "/**\n"
  " * Changes the UsageHint hint for this primitive.  See get_usage_hint().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_set_usage_hint_688_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::NumericType GeomPrimitive::get_index_type(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_index_type_690(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline GeomEnums::NumericType GeomPrimitive::get_index_type(void) const
  GeomEnums::NumericType return_value = ((*(const GeomPrimitive*)local_this).get_index_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_index_type_690_comment =
  "C++ Interface:\n"
  "get_index_type(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the numeric type of the index column.  Normally, this will be\n"
  " * either NT_uint16 or NT_uint32.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_index_type_690_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::set_index_type(GeomEnums::NumericType index_type)
 */
static PyObject *Dtool_GeomPrimitive_set_index_type_691(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.set_index_type")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::set_index_type(GeomEnums::NumericType index_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_index_type)((GeomEnums::NumericType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_index_type(const GeomPrimitive self, int index_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_set_index_type_691_comment =
  "C++ Interface:\n"
  "set_index_type(const GeomPrimitive self, int index_type)\n"
  "\n"
  "/**\n"
  " * Changes the numeric type of the index column.  Normally, this should be\n"
  " * either NT_uint16 or NT_uint32.\n"
  " *\n"
  " * The index type must be large enough to include all of the index values in\n"
  " * the primitive.  It may be automatically elevated, if necessary, to a larger\n"
  " * index type, by a subsequent call to add_index() that names an index value\n"
  " * that does not fit in the index type you specify.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_set_index_type_691_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomPrimitive::is_composite(void) const
 */
static PyObject *Dtool_GeomPrimitive_is_composite_693(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline bool GeomPrimitive::is_composite(void) const
  bool return_value = ((*(const GeomPrimitive*)local_this).is_composite)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_is_composite_693_comment =
  "C++ Interface:\n"
  "is_composite(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if the primitive is a composite primitive such as a tristrip\n"
  " * or trifan, or false if it is a fundamental primitive such as a collection\n"
  " * of triangles.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_is_composite_693_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomPrimitive::is_indexed(void) const
 */
static PyObject *Dtool_GeomPrimitive_is_indexed_694(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline bool GeomPrimitive::is_indexed(void) const
  bool return_value = ((*(const GeomPrimitive*)local_this).is_indexed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_is_indexed_694_comment =
  "C++ Interface:\n"
  "is_indexed(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if the primitive is indexed, false otherwise.  An indexed\n"
  " * primitive stores a table of index numbers into its GeomVertexData, so that\n"
  " * it can reference the vertices in any order.  A nonindexed primitive, on the\n"
  " * other hand, stores only the first vertex number and number of vertices\n"
  " * used, so that it can only reference the vertices consecutively.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_is_indexed_694_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomPrimitive::get_first_vertex(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_first_vertex_695(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline int GeomPrimitive::get_first_vertex(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_first_vertex)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_first_vertex_695_comment =
  "C++ Interface:\n"
  "get_first_vertex(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the first vertex number referenced by the primitive.  This is\n"
  " * particularly important in the case of a nonindexed primitive, in which case\n"
  " * get_first_vertex() and get_num_vertices() completely define the extent of\n"
  " * the vertex range.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_first_vertex_695_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomPrimitive::get_num_vertices(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_num_vertices_696(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline int GeomPrimitive::get_num_vertices(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_num_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_num_vertices_696_comment =
  "C++ Interface:\n"
  "get_num_vertices(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the number of indices used by all the primitives in this object.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_num_vertices_696_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomPrimitive::get_vertex(int i) const
 */
static PyObject *Dtool_GeomPrimitive_get_vertex_697(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline int GeomPrimitive::get_vertex(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const GeomPrimitive*)local_this).get_vertex)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(GeomPrimitive self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_vertex_697_comment =
  "C++ Interface:\n"
  "get_vertex(GeomPrimitive self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the ith vertex index in the table.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_vertex_697_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::add_vertex(int vertex)
 */
static PyObject *Dtool_GeomPrimitive_add_vertex_699(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.add_vertex")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::add_vertex(int vertex)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).add_vertex)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const GeomPrimitive self, int vertex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_add_vertex_699_comment =
  "C++ Interface:\n"
  "add_vertex(const GeomPrimitive self, int vertex)\n"
  "\n"
  "/**\n"
  " * Adds the indicated vertex to the list of vertex indices used by the\n"
  " * graphics primitive type.  To define a primitive, you must call add_vertex()\n"
  " * for each vertex of the new primitive, and then call close_primitive() after\n"
  " * you have specified the last vertex of each primitive.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_add_vertex_699_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomPrimitive::add_vertices(int v1, int v2)
 * inline void GeomPrimitive::add_vertices(int v1, int v2, int v3)
 * inline void GeomPrimitive::add_vertices(int v1, int v2, int v3, int v4)
 */
static PyObject *Dtool_GeomPrimitive_add_vertices_700(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.add_vertices")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void GeomPrimitive::add_vertices(int v1, int v2)
      int param1;
      int param2;
      static const char *keyword_list[] = {"v1", "v2", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:add_vertices", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).add_vertices)((int)param1, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void GeomPrimitive::add_vertices(int v1, int v2, int v3)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"v1", "v2", "v3", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:add_vertices", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).add_vertices)((int)param1, (int)param2, (int)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void GeomPrimitive::add_vertices(int v1, int v2, int v3, int v4)
      int param1;
      int param2;
      int param3;
      int param4;
      static const char *keyword_list[] = {"v1", "v2", "v3", "v4", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:add_vertices", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).add_vertices)((int)param1, (int)param2, (int)param3, (int)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_vertices() takes 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertices(const GeomPrimitive self, int v1, int v2)\n"
      "add_vertices(const GeomPrimitive self, int v1, int v2, int v3)\n"
      "add_vertices(const GeomPrimitive self, int v1, int v2, int v3, int v4)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_add_vertices_700_comment =
  "C++ Interface:\n"
  "add_vertices(const GeomPrimitive self, int v1, int v2)\n"
  "add_vertices(const GeomPrimitive self, int v1, int v2, int v3)\n"
  "add_vertices(const GeomPrimitive self, int v1, int v2, int v3, int v4)\n"
  "\n"
  "/**\n"
  " * Adds several vertices in a row.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds several vertices in a row.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds several vertices in a row.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_add_vertices_700_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::add_consecutive_vertices(int start, int num_vertices)
 */
static PyObject *Dtool_GeomPrimitive_add_consecutive_vertices_701(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.add_consecutive_vertices")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::add_consecutive_vertices(int start, int num_vertices)
  int param1;
  int param2;
  static const char *keyword_list[] = {"start", "num_vertices", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:add_consecutive_vertices", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).add_consecutive_vertices)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_consecutive_vertices(const GeomPrimitive self, int start, int num_vertices)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_add_consecutive_vertices_701_comment =
  "C++ Interface:\n"
  "add_consecutive_vertices(const GeomPrimitive self, int start, int num_vertices)\n"
  "\n"
  "/**\n"
  " * Adds a consecutive sequence of vertices, beginning at start, to the\n"
  " * primitive.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_add_consecutive_vertices_701_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::add_next_vertices(int num_vertices)
 */
static PyObject *Dtool_GeomPrimitive_add_next_vertices_702(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.add_next_vertices")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::add_next_vertices(int num_vertices)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).add_next_vertices)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_next_vertices(const GeomPrimitive self, int num_vertices)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_add_next_vertices_702_comment =
  "C++ Interface:\n"
  "add_next_vertices(const GeomPrimitive self, int num_vertices)\n"
  "\n"
  "/**\n"
  " * Adds the next n vertices in sequence, beginning from the last vertex added\n"
  " * to the primitive + 1.\n"
  " *\n"
  " * This is most useful when you are building up a primitive and a\n"
  " * GeomVertexData at the same time, and you just want the primitive to\n"
  " * reference the first n vertices from the data, then the next n, and so on.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_add_next_vertices_702_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::reserve_num_vertices(int num_vertices)
 */
static PyObject *Dtool_GeomPrimitive_reserve_num_vertices_703(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.reserve_num_vertices")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::reserve_num_vertices(int num_vertices)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).reserve_num_vertices)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reserve_num_vertices(const GeomPrimitive self, int num_vertices)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_reserve_num_vertices_703_comment =
  "C++ Interface:\n"
  "reserve_num_vertices(const GeomPrimitive self, int num_vertices)\n"
  "\n"
  "/**\n"
  " * This ensures that enough memory space for n vertices is allocated, so that\n"
  " * you may increase the number of vertices to n without causing a new memory\n"
  " * allocation.  This is a performance optimization only; it is especially\n"
  " * useful when you know ahead of time that you will be adding n vertices to\n"
  " * the primitive.\n"
  " *\n"
  " * Note that the total you specify here should also include implicit vertices\n"
  " * which may be added at each close_primitive() call, according to\n"
  " * get_num_unused_vertices_per_primitive().\n"
  " *\n"
  " * Note also that making this call will implicitly make the primitive indexed\n"
  " * if it is not already, which could result in a performance *penalty*.  If\n"
  " * you would prefer not to lose the nonindexed nature of your existing\n"
  " * GeomPrimitives, check is_indexed() before making this call.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_reserve_num_vertices_703_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GeomPrimitive::close_primitive(void)
 */
static PyObject *Dtool_GeomPrimitive_close_primitive_704(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.close_primitive")) {
    return nullptr;
  }
  // 1-bool GeomPrimitive::close_primitive(void)
  bool return_value = ((*local_this).close_primitive)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_close_primitive_704_comment =
  "C++ Interface:\n"
  "close_primitive(const GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Indicates that the previous n calls to add_vertex(), since the last call to\n"
  " * close_primitive(), have fully defined a new primitive.  Returns true if\n"
  " * successful, false otherwise.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_close_primitive_704_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::clear_vertices(void)
 */
static PyObject *Dtool_GeomPrimitive_clear_vertices_705(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.clear_vertices")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::clear_vertices(void)
  ((*local_this).clear_vertices)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_clear_vertices_705_comment =
  "C++ Interface:\n"
  "clear_vertices(const GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Removes all of the vertices and primitives from the object, so they can be\n"
  " * re-added.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_clear_vertices_705_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::offset_vertices(int offset)
 * void GeomPrimitive::offset_vertices(int offset, int begin_row, int end_row)
 */
static PyObject *Dtool_GeomPrimitive_offset_vertices_706(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.offset_vertices")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "offset")) {
        // 1-void GeomPrimitive::offset_vertices(int offset)
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          ((*local_this).offset_vertices)((int)arg_val);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-void GeomPrimitive::offset_vertices(int offset, int begin_row, int end_row)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"offset", "begin_row", "end_row", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:offset_vertices", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).offset_vertices)((int)param1, (int)param2, (int)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "offset_vertices() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "offset_vertices(const GeomPrimitive self, int offset)\n"
      "offset_vertices(const GeomPrimitive self, int offset, int begin_row, int end_row)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_offset_vertices_706_comment =
  "C++ Interface:\n"
  "offset_vertices(const GeomPrimitive self, int offset)\n"
  "offset_vertices(const GeomPrimitive self, int offset, int begin_row, int end_row)\n"
  "\n"
  "/**\n"
  " * Adds the indicated offset to all vertices used by the primitive.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the indicated offset to the indicated segment of vertices used by the\n"
  " * primitive.  Unlike the other version of offset_vertices, this makes the\n"
  " * geometry indexed if it isn't already.\n"
  " *\n"
  " * Note that end_row indicates one past the last row that should be offset.\n"
  " * In other words, the number of vertices touched is (end_row - begin_row).\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_offset_vertices_706_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::make_nonindexed(GeomVertexData *dest, GeomVertexData const *source)
 */
static PyObject *Dtool_GeomPrimitive_make_nonindexed_707(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.make_nonindexed")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::make_nonindexed(GeomVertexData *dest, GeomVertexData const *source)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"dest", "source", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_nonindexed", (char **)keyword_list, &param1, &param2)) {
    GeomVertexData *param1_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GeomVertexData, 1, "GeomPrimitive.make_nonindexed", false, true);
    GeomVertexData const *param2_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeomVertexData, 2, "GeomPrimitive.make_nonindexed", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).make_nonindexed)(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_nonindexed(const GeomPrimitive self, GeomVertexData dest, const GeomVertexData source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_make_nonindexed_707_comment =
  "C++ Interface:\n"
  "make_nonindexed(const GeomPrimitive self, GeomVertexData dest, const GeomVertexData source)\n"
  "\n"
  "/**\n"
  " * Converts the primitive from indexed to nonindexed by duplicating vertices\n"
  " * as necessary into the indicated dest GeomVertexData.  Note: does not\n"
  " * support primitives with strip cut indices.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_make_nonindexed_707_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::pack_vertices(GeomVertexData *dest, GeomVertexData const *source)
 */
static PyObject *Dtool_GeomPrimitive_pack_vertices_708(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.pack_vertices")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::pack_vertices(GeomVertexData *dest, GeomVertexData const *source)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"dest", "source", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:pack_vertices", (char **)keyword_list, &param1, &param2)) {
    GeomVertexData *param1_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GeomVertexData, 1, "GeomPrimitive.pack_vertices", false, true);
    GeomVertexData const *param2_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeomVertexData, 2, "GeomPrimitive.pack_vertices", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).pack_vertices)(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_vertices(const GeomPrimitive self, GeomVertexData dest, const GeomVertexData source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_pack_vertices_708_comment =
  "C++ Interface:\n"
  "pack_vertices(const GeomPrimitive self, GeomVertexData dest, const GeomVertexData source)\n"
  "\n"
  "/**\n"
  " * Packs the vertices used by the primitive from the indicated source array\n"
  " * onto the end of the indicated destination array.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_pack_vertices_708_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::make_indexed(void)
 */
static PyObject *Dtool_GeomPrimitive_make_indexed_709(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.make_indexed")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::make_indexed(void)
  ((*local_this).make_indexed)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_make_indexed_709_comment =
  "C++ Interface:\n"
  "make_indexed(const GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Converts the primitive from nonindexed form to indexed form.  This will\n"
  " * simply create an index table that is numbered consecutively from\n"
  " * get_first_vertex(); it does not automatically collapse together identical\n"
  " * vertices that may have been split apart by a previous call to\n"
  " * make_nonindexed().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_make_indexed_709_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomPrimitive::get_num_primitives(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_num_primitives_710(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline int GeomPrimitive::get_num_primitives(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_num_primitives)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_num_primitives_710_comment =
  "C++ Interface:\n"
  "get_num_primitives(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the number of individual primitives stored within this object.  All\n"
  " * primitives are the same type.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_num_primitives_710_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomPrimitive::get_primitive_start(int n) const
 */
static PyObject *Dtool_GeomPrimitive_get_primitive_start_711(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-int GeomPrimitive::get_primitive_start(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const GeomPrimitive*)local_this).get_primitive_start)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_primitive_start(GeomPrimitive self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_primitive_start_711_comment =
  "C++ Interface:\n"
  "get_primitive_start(GeomPrimitive self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the element within the _vertices list at which the nth primitive\n"
  " * starts.\n"
  " *\n"
  " * If i is one more than the highest valid primitive vertex, the return value\n"
  " * will be one more than the last valid vertex.  Thus, it is generally true\n"
  " * that the vertices used by a particular primitive i are the set\n"
  " * get_primitive_start(n) <= vi < get_primitive_start(n + 1) (although this\n"
  " * range also includes the unused vertices between primitives).\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_primitive_start_711_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomPrimitive::get_primitive_end(int n) const
 */
static PyObject *Dtool_GeomPrimitive_get_primitive_end_712(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-int GeomPrimitive::get_primitive_end(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const GeomPrimitive*)local_this).get_primitive_end)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_primitive_end(GeomPrimitive self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_primitive_end_712_comment =
  "C++ Interface:\n"
  "get_primitive_end(GeomPrimitive self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the element within the _vertices list at which the nth primitive\n"
  " * ends.  This is one past the last valid element for the nth primitive.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_primitive_end_712_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomPrimitive::get_primitive_num_vertices(int n) const
 */
static PyObject *Dtool_GeomPrimitive_get_primitive_num_vertices_713(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-int GeomPrimitive::get_primitive_num_vertices(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const GeomPrimitive*)local_this).get_primitive_num_vertices)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_primitive_num_vertices(GeomPrimitive self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_primitive_num_vertices_713_comment =
  "C++ Interface:\n"
  "get_primitive_num_vertices(GeomPrimitive self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices used by the nth primitive.  This is the same\n"
  " * thing as get_primitive_end(n) - get_primitive_start(n).\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_primitive_num_vertices_713_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomPrimitive::get_num_used_vertices(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_num_used_vertices_714(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-int GeomPrimitive::get_num_used_vertices(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_num_used_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_num_used_vertices_714_comment =
  "C++ Interface:\n"
  "get_num_used_vertices(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices used by all of the primitives.  This is the\n"
  " * same as summing get_primitive_num_vertices(n) for n in\n"
  " * get_num_primitives().  It is like get_num_vertices except that it excludes\n"
  " * all of the degenerate vertices and strip-cut indices.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_num_used_vertices_714_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomPrimitive::get_num_faces(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_num_faces_715(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline int GeomPrimitive::get_num_faces(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_num_faces)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_num_faces_715_comment =
  "C++ Interface:\n"
  "get_num_faces(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the number of triangles or other fundamental type (such as line\n"
  " * segments) represented by all the primitives in this object.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_num_faces_715_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomPrimitive::get_primitive_num_faces(int n) const
 */
static PyObject *Dtool_GeomPrimitive_get_primitive_num_faces_716(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline int GeomPrimitive::get_primitive_num_faces(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const GeomPrimitive*)local_this).get_primitive_num_faces)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_primitive_num_faces(GeomPrimitive self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_primitive_num_faces_716_comment =
  "C++ Interface:\n"
  "get_primitive_num_faces(GeomPrimitive self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of triangles or other fundamental type (such as line\n"
  " * segments) represented by the nth primitive in this object.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_primitive_num_faces_716_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomPrimitive::get_min_vertex(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_min_vertex_717(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline int GeomPrimitive::get_min_vertex(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_min_vertex)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_min_vertex_717_comment =
  "C++ Interface:\n"
  "get_min_vertex(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum vertex index number used by all the primitives in this\n"
  " * object.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_min_vertex_717_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomPrimitive::get_primitive_min_vertex(int n) const
 */
static PyObject *Dtool_GeomPrimitive_get_primitive_min_vertex_718(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-int GeomPrimitive::get_primitive_min_vertex(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const GeomPrimitive*)local_this).get_primitive_min_vertex)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_primitive_min_vertex(GeomPrimitive self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_primitive_min_vertex_718_comment =
  "C++ Interface:\n"
  "get_primitive_min_vertex(GeomPrimitive self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the minimum vertex index number used by the nth primitive in this\n"
  " * object.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_primitive_min_vertex_718_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomPrimitive::get_max_vertex(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_max_vertex_719(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline int GeomPrimitive::get_max_vertex(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_max_vertex)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_max_vertex_719_comment =
  "C++ Interface:\n"
  "get_max_vertex(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum vertex index number used by all the primitives in this\n"
  " * object.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_max_vertex_719_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomPrimitive::get_primitive_max_vertex(int n) const
 */
static PyObject *Dtool_GeomPrimitive_get_primitive_max_vertex_720(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-int GeomPrimitive::get_primitive_max_vertex(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const GeomPrimitive*)local_this).get_primitive_max_vertex)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_primitive_max_vertex(GeomPrimitive self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_primitive_max_vertex_720_comment =
  "C++ Interface:\n"
  "get_primitive_max_vertex(GeomPrimitive self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the maximum vertex index number used by the nth primitive in this\n"
  " * object.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_primitive_max_vertex_720_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomPrimitive > GeomPrimitive::decompose(void) const
 */
static PyObject *Dtool_GeomPrimitive_decompose_721(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomPrimitive > GeomPrimitive::decompose(void) const
  ConstPointerTo< GeomPrimitive > return_value = ((*(const GeomPrimitive*)local_this).decompose)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomPrimitive const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_decompose_721_comment =
  "C++ Interface:\n"
  "decompose(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Decomposes a complex primitive type into a simpler primitive type, for\n"
  " * instance triangle strips to triangles, and returns a pointer to the new\n"
  " * primitive definition.  If the decomposition cannot be performed, this might\n"
  " * return the original object.\n"
  " *\n"
  " * This method is useful for application code that wants to iterate through\n"
  " * the set of triangles on the primitive without having to write handlers for\n"
  " * each possible kind of primitive type.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_decompose_721_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomPrimitive > GeomPrimitive::rotate(void) const
 */
static PyObject *Dtool_GeomPrimitive_rotate_722(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomPrimitive > GeomPrimitive::rotate(void) const
  ConstPointerTo< GeomPrimitive > return_value = ((*(const GeomPrimitive*)local_this).rotate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomPrimitive const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_rotate_722_comment =
  "C++ Interface:\n"
  "rotate(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns a new primitive with the shade_model reversed (if it is flat\n"
  " * shaded), if possible.  If the primitive type cannot be rotated, returns the\n"
  " * original primitive, unrotated.\n"
  " *\n"
  " * If the current shade_model indicates flat_vertex_last, this should bring\n"
  " * the last vertex to the first position; if it indicates flat_vertex_first,\n"
  " * this should bring the first vertex to the last position.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_rotate_722_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomPrimitive > GeomPrimitive::doubleside(void) const
 */
static PyObject *Dtool_GeomPrimitive_doubleside_723(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomPrimitive > GeomPrimitive::doubleside(void) const
  ConstPointerTo< GeomPrimitive > return_value = ((*(const GeomPrimitive*)local_this).doubleside)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomPrimitive const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_doubleside_723_comment =
  "C++ Interface:\n"
  "doubleside(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Duplicates triangles in the primitive so that each triangle is back-to-back\n"
  " * with another triangle facing in the opposite direction.  Note that this\n"
  " * doesn't affect vertex normals, so this operation alone won't work in the\n"
  " * presence of lighting (but see SceneGraphReducer::doubleside()).\n"
  " *\n"
  " * Also see CullFaceAttrib, which can enable rendering of both sides of a\n"
  " * triangle without having to duplicate it (but which doesn't necessarily work\n"
  " * in the presence of lighting).\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_doubleside_723_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomPrimitive > GeomPrimitive::reverse(void) const
 */
static PyObject *Dtool_GeomPrimitive_reverse_724(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomPrimitive > GeomPrimitive::reverse(void) const
  ConstPointerTo< GeomPrimitive > return_value = ((*(const GeomPrimitive*)local_this).reverse)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomPrimitive const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_reverse_724_comment =
  "C++ Interface:\n"
  "reverse(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Reverses the winding order in the primitive so that each triangle is facing\n"
  " * in the opposite direction it was originally.  Note that this doesn't affect\n"
  " * vertex normals, so this operation alone won't work in the presence of\n"
  " * lighting (but see SceneGraphReducer::reverse()).\n"
  " *\n"
  " * Also see CullFaceAttrib, which can change the visible direction of a\n"
  " * triangle without having to duplicate it (but which doesn't necessarily work\n"
  " * in the presence of lighting).\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_reverse_724_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomPrimitive > GeomPrimitive::match_shade_model(GeomEnums::ShadeModel shade_model) const
 */
static PyObject *Dtool_GeomPrimitive_match_shade_model_725(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomPrimitive > GeomPrimitive::match_shade_model(GeomEnums::ShadeModel shade_model) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< GeomPrimitive > return_value = ((*(const GeomPrimitive*)local_this).match_shade_model)((GeomEnums::ShadeModel)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GeomPrimitive const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "match_shade_model(GeomPrimitive self, int shade_model)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_match_shade_model_725_comment =
  "C++ Interface:\n"
  "match_shade_model(GeomPrimitive self, int shade_model)\n"
  "\n"
  "/**\n"
  " * Returns a new primitive that is compatible with the indicated shade model,\n"
  " * if possible, or NULL if this is not possible.\n"
  " *\n"
  " * In most cases, this will return either NULL or the original primitive.  In\n"
  " * the case of a SM_flat_first_vertex vs.  a SM_flat_last_vertex (or vice-\n"
  " * versa), however, it will return a rotated primitive.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_match_shade_model_725_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomPrimitive > GeomPrimitive::make_points(void) const
 */
static PyObject *Dtool_GeomPrimitive_make_points_726(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomPrimitive > GeomPrimitive::make_points(void) const
  ConstPointerTo< GeomPrimitive > return_value = ((*(const GeomPrimitive*)local_this).make_points)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomPrimitive const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_make_points_726_comment =
  "C++ Interface:\n"
  "make_points(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns a new GeomPoints primitive that represents each of the vertices in\n"
  " * the original primitive, rendered exactly once.  If the original primitive\n"
  " * is already a GeomPoints primitive, returns the original primitive\n"
  " * unchanged.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_make_points_726_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomPrimitive > GeomPrimitive::make_lines(void) const
 */
static PyObject *Dtool_GeomPrimitive_make_lines_727(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomPrimitive > GeomPrimitive::make_lines(void) const
  ConstPointerTo< GeomPrimitive > return_value = ((*(const GeomPrimitive*)local_this).make_lines)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomPrimitive const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_make_lines_727_comment =
  "C++ Interface:\n"
  "make_lines(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns a new GeomLines primitive that represents each of the edges in the\n"
  " * original primitive rendered as a line.  If the original primitive is\n"
  " * already a GeomLines primitive, returns the original primitive unchanged.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_make_lines_727_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomPrimitive > GeomPrimitive::make_patches(void) const
 */
static PyObject *Dtool_GeomPrimitive_make_patches_728(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomPrimitive > GeomPrimitive::make_patches(void) const
  ConstPointerTo< GeomPrimitive > return_value = ((*(const GeomPrimitive*)local_this).make_patches)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomPrimitive const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_make_patches_728_comment =
  "C++ Interface:\n"
  "make_patches(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Decomposes a complex primitive type into a simpler primitive type, for\n"
  " * instance triangle strips to triangles, puts these in a new GeomPatches\n"
  " * object and returns a pointer to the new primitive definition.  If the\n"
  " * decomposition cannot be performed, this might return the original object.\n"
  " *\n"
  " * This method is useful for application code that wants to use tesselation\n"
  " * shaders on arbitrary geometry.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_make_patches_728_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual ConstPointerTo< GeomPrimitive > GeomPrimitive::make_adjacency(void) const
 */
static PyObject *Dtool_GeomPrimitive_make_adjacency_729(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-virtual ConstPointerTo< GeomPrimitive > GeomPrimitive::make_adjacency(void) const
  ConstPointerTo< GeomPrimitive > return_value = ((*(const GeomPrimitive*)local_this).make_adjacency)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomPrimitive const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_make_adjacency_729_comment =
  "C++ Interface:\n"
  "make_adjacency(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Adds adjacency information to this primitive.  May return null if this type\n"
  " * of geometry does not support adjacency information.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_make_adjacency_729_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GeomPrimitive::get_num_bytes(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_num_bytes_730(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-int GeomPrimitive::get_num_bytes(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_num_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_num_bytes_730_comment =
  "C++ Interface:\n"
  "get_num_bytes(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes consumed by the primitive and its index\n"
  " * table(s).\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_num_bytes_730_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomPrimitive::get_data_size_bytes(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_data_size_bytes_731(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline int GeomPrimitive::get_data_size_bytes(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_data_size_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_data_size_bytes_731_comment =
  "C++ Interface:\n"
  "get_data_size_bytes(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes stored in the vertices array.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_data_size_bytes_731_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq GeomPrimitive::get_modified(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_modified_732(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline UpdateSeq GeomPrimitive::get_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const GeomPrimitive*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_modified_732_comment =
  "C++ Interface:\n"
  "get_modified(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number which is guaranteed to change at least every time\n"
  " * the vertex index array is modified.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_modified_732_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GeomPrimitive::request_resident(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_GeomPrimitive_request_resident_736(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-bool GeomPrimitive::request_resident(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomPrimitive.request_resident", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      bool return_value = ((*(const GeomPrimitive*)local_this).request_resident)(param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "request_resident(GeomPrimitive self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_request_resident_736_comment =
  "C++ Interface:\n"
  "request_resident(GeomPrimitive self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns true if the primitive data is currently resident in memory.  If\n"
  " * this returns false, the primitive data will be brought back into memory\n"
  " * shortly; try again later.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_request_resident_736_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomPrimitive::check_valid(GeomVertexData const *vertex_data) const
 * Rejected Remap [inline bool GeomPrimitive::check_valid(GeomVertexDataPipelineReader const *data_reader) const]
 */
static PyObject *Dtool_GeomPrimitive_check_valid_737(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline bool GeomPrimitive::check_valid(GeomVertexData const *vertex_data) const
  GeomVertexData const *arg_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexData, 1, "GeomPrimitive.check_valid", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const GeomPrimitive*)local_this).check_valid)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "check_valid(GeomPrimitive self, const GeomVertexData vertex_data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_check_valid_737_comment =
  "C++ Interface:\n"
  "check_valid(GeomPrimitive self, const GeomVertexData vertex_data)\n"
  "\n"
  "/**\n"
  " * Verifies that the primitive only references vertices that actually exist\n"
  " * within the indicated GeomVertexData.  Returns true if the primitive appears\n"
  " * to be valid, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_check_valid_737_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void GeomPrimitive::output(std::ostream &out) const
 */
static PyObject *Dtool_GeomPrimitive_output_738(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-virtual void GeomPrimitive::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GeomPrimitive.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GeomPrimitive*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GeomPrimitive self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_output_738_comment =
  "C++ Interface:\n"
  "output(GeomPrimitive self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_output_738_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void GeomPrimitive::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_GeomPrimitive_write_739(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-virtual void GeomPrimitive::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "GeomPrimitive.write", false, true);
    if (param1_this != nullptr) {
      ((*(const GeomPrimitive*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(GeomPrimitive self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_write_739_comment =
  "C++ Interface:\n"
  "write(GeomPrimitive self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_write_739_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< GeomVertexArrayData > GeomPrimitive::get_vertices(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_vertices_740(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeomVertexArrayData > GeomPrimitive::get_vertices(void) const
  ConstPointerTo< GeomVertexArrayData > return_value = ((*(const GeomPrimitive*)local_this).get_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomVertexArrayData const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayData, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_vertices_740_comment =
  "C++ Interface:\n"
  "get_vertices(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the vertex index array so application code can\n"
  " * read it directly.  This might return NULL if the primitive is nonindexed.\n"
  " * Do not attempt to modify the returned array; use modify_vertices() or\n"
  " * set_vertices() for this.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_vertices_740_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< GeomVertexArrayDataHandle > GeomPrimitive::get_vertices_handle(Thread *current_thread) const
 */
static PyObject *Dtool_GeomPrimitive_get_vertices_handle_741(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeomVertexArrayDataHandle > GeomPrimitive::get_vertices_handle(Thread *current_thread) const
  Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "GeomPrimitive.get_vertices_handle", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< GeomVertexArrayDataHandle > return_value = ((*(const GeomPrimitive*)local_this).get_vertices_handle)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GeomVertexArrayDataHandle const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayDataHandle, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertices_handle(GeomPrimitive self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_vertices_handle_741_comment =
  "C++ Interface:\n"
  "get_vertices_handle(GeomPrimitive self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Equivalent to get_vertices().get_handle().\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_vertices_handle_741_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< GeomVertexArrayData > GeomPrimitive::modify_vertices(int num_vertices = -1)
 */
static PyObject *Dtool_GeomPrimitive_modify_vertices_742(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.modify_vertices")) {
    return nullptr;
  }
  // 1-PointerTo< GeomVertexArrayData > GeomPrimitive::modify_vertices(int num_vertices = -1)
  int param1 = -1;
  static const char *keyword_list[] = {"num_vertices", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:modify_vertices", (char **)keyword_list, &param1)) {
    PointerTo< GeomVertexArrayData > return_value = ((*local_this).modify_vertices)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GeomVertexArrayData *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayData, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_vertices(const GeomPrimitive self, int num_vertices)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_modify_vertices_742_comment =
  "C++ Interface:\n"
  "modify_vertices(const GeomPrimitive self, int num_vertices)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the vertex index list, so application code\n"
  " * can directly fiddle with this data.  Use with caution, since there are no\n"
  " * checks that the data will be left in a stable state.\n"
  " *\n"
  " * If this is called on a nonindexed primitive, it will implicitly be\n"
  " * converted to an indexed primitive.\n"
  " *\n"
  " * If num_vertices is not -1, it specifies an artificial limit to the number\n"
  " * of vertices in the array.  Otherwise, all of the vertices in the array will\n"
  " * be used.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_modify_vertices_742_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< GeomVertexArrayDataHandle > GeomPrimitive::modify_vertices_handle(Thread *current_thread)
 */
static PyObject *Dtool_GeomPrimitive_modify_vertices_handle_743(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.modify_vertices_handle")) {
    return nullptr;
  }
  // 1-inline PointerTo< GeomVertexArrayDataHandle > GeomPrimitive::modify_vertices_handle(Thread *current_thread)
  Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "GeomPrimitive.modify_vertices_handle", false, true);
  if (arg_this != nullptr) {
    PointerTo< GeomVertexArrayDataHandle > return_value = ((*local_this).modify_vertices_handle)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GeomVertexArrayDataHandle *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayDataHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_vertices_handle(const GeomPrimitive self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_modify_vertices_handle_743_comment =
  "C++ Interface:\n"
  "modify_vertices_handle(const GeomPrimitive self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Equivalent to modify_vertices().get_handle().\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_modify_vertices_handle_743_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::set_vertices(GeomVertexArrayData const *vertices, int num_vertices = -1)
 */
static PyObject *Dtool_GeomPrimitive_set_vertices_744(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.set_vertices")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::set_vertices(GeomVertexArrayData const *vertices, int num_vertices = -1)
  PyObject *param1;
  int param2 = -1;
  static const char *keyword_list[] = {"vertices", "num_vertices", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_vertices", (char **)keyword_list, &param1, &param2)) {
    GeomVertexArrayData const *param1_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GeomVertexArrayData, 1, "GeomPrimitive.set_vertices", true, true);
    if (param1_this != nullptr) {
      ((*local_this).set_vertices)(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertices(const GeomPrimitive self, const GeomVertexArrayData vertices, int num_vertices)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_set_vertices_744_comment =
  "C++ Interface:\n"
  "set_vertices(const GeomPrimitive self, const GeomVertexArrayData vertices, int num_vertices)\n"
  "\n"
  "/**\n"
  " * Completely replaces the vertex index list with a new table.  Chances are\n"
  " * good that you should also replace the ends list with set_ends() at the same\n"
  " * time.\n"
  " *\n"
  " * If num_vertices is not -1, it specifies an artificial limit to the number\n"
  " * of vertices in the array.  Otherwise, all of the vertices in the array will\n"
  " * be used.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_set_vertices_744_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::set_nonindexed_vertices(int first_vertex, int num_vertices)
 */
static PyObject *Dtool_GeomPrimitive_set_nonindexed_vertices_745(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.set_nonindexed_vertices")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::set_nonindexed_vertices(int first_vertex, int num_vertices)
  int param1;
  int param2;
  static const char *keyword_list[] = {"first_vertex", "num_vertices", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_nonindexed_vertices", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_nonindexed_vertices)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_nonindexed_vertices(const GeomPrimitive self, int first_vertex, int num_vertices)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_set_nonindexed_vertices_745_comment =
  "C++ Interface:\n"
  "set_nonindexed_vertices(const GeomPrimitive self, int first_vertex, int num_vertices)\n"
  "\n"
  "/**\n"
  " * Sets the primitive up as a nonindexed primitive, using the indicated vertex\n"
  " * range.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_set_nonindexed_vertices_745_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomPrimitive::get_index_stride(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_index_stride_746(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline int GeomPrimitive::get_index_stride(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_index_stride)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_index_stride_746_comment =
  "C++ Interface:\n"
  "get_index_stride(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * A convenience function to return the gap between successive index numbers,\n"
  " * in bytes, of the index data.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_index_stride_746_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomPrimitive::get_strip_cut_index(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_strip_cut_index_747(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline int GeomPrimitive::get_strip_cut_index(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_strip_cut_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_strip_cut_index_747_comment =
  "C++ Interface:\n"
  "get_strip_cut_index(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * If relevant, returns the index value that may be used in some cases to\n"
  " * signify the end of a primitive.  This is typically the highest value that\n"
  " * the numeric type can store.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the index of the indicated type that is reserved for use as a strip\n"
  " * cut index, if enabled for the primitive.  When the renderer encounters this\n"
  " * index, it will restart the primitive.  This is guaranteed not to point to\n"
  " * an actual vertex.\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_strip_cut_index_747_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CPTA_int GeomPrimitive::get_ends(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_ends_750(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline CPTA_int GeomPrimitive::get_ends(void) const
  CPTA_int *return_value = new CPTA_int(((*(const GeomPrimitive*)local_this).get_ends)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_int, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_ends_750_comment =
  "C++ Interface:\n"
  "get_ends(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the primitive ends array so application code can\n"
  " * read it directly.  Do not attempt to modify the returned array; use\n"
  " * modify_ends() or set_ends() for this.\n"
  " *\n"
  " * Note that simple primitive types, like triangles, do not have a ends array:\n"
  " * since all the primitives have the same number of vertices, it is not\n"
  " * needed.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_ends_750_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PTA_int GeomPrimitive::modify_ends(void)
 */
static PyObject *Dtool_GeomPrimitive_modify_ends_751(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.modify_ends")) {
    return nullptr;
  }
  // 1-PTA_int GeomPrimitive::modify_ends(void)
  PTA_int *return_value = new PTA_int(((*local_this).modify_ends)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_int, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_modify_ends_751_comment =
  "C++ Interface:\n"
  "modify_ends(const GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the primitive ends array, so application\n"
  " * code can directly fiddle with this data.  Use with caution, since there are\n"
  " * no checks that the data will be left in a stable state.\n"
  " *\n"
  " * Note that simple primitive types, like triangles, do not have a ends array:\n"
  " * since all the primitives have the same number of vertices, it is not\n"
  " * needed.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_modify_ends_751_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::set_ends(PTA_int ends)
 */
static PyObject *Dtool_GeomPrimitive_set_ends_752(PyObject *self, PyObject *arg) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.set_ends")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::set_ends(PTA_int ends)
  PointerToArray< int > arg_local;
  PTA_int *arg_this = Dtool_Coerce_PointerToArray_int(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomPrimitive.set_ends", "PointerToArray");
  }
  ((*local_this).set_ends)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ends(const GeomPrimitive self, PointerToArray ends)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_set_ends_752_comment =
  "C++ Interface:\n"
  "set_ends(const GeomPrimitive self, PointerToArray ends)\n"
  "\n"
  "/**\n"
  " * Completely replaces the primitive ends array with a new table.  Chances are\n"
  " * good that you should also replace the vertices list with set_vertices() at\n"
  " * the same time.\n"
  " *\n"
  " * Note that simple primitive types, like triangles, do not have a ends array:\n"
  " * since all the primitives have the same number of vertices, it is not\n"
  " * needed.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_set_ends_752_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< GeomVertexArrayData > GeomPrimitive::get_mins(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_mins_753(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeomVertexArrayData > GeomPrimitive::get_mins(void) const
  ConstPointerTo< GeomVertexArrayData > return_value = ((*(const GeomPrimitive*)local_this).get_mins)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomVertexArrayData const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayData, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_mins_753_comment =
  "C++ Interface:\n"
  "get_mins(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the primitive mins array so application code can\n"
  " * read it directly.  Do not attempt to modify the returned array; use\n"
  " * set_minmax() for this.\n"
  " *\n"
  " * Note that simple primitive types, like triangles, do not have a mins array.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_mins_753_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< GeomVertexArrayData > GeomPrimitive::get_maxs(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_maxs_754(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeomVertexArrayData > GeomPrimitive::get_maxs(void) const
  ConstPointerTo< GeomVertexArrayData > return_value = ((*(const GeomPrimitive*)local_this).get_maxs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomVertexArrayData const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayData, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_maxs_754_comment =
  "C++ Interface:\n"
  "get_maxs(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the primitive maxs array so application code can\n"
  " * read it directly.  Do not attempt to modify the returned array; use\n"
  " * set_minmax().\n"
  " *\n"
  " * Note that simple primitive types, like triangles, do not have a maxs array.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_maxs_754_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::set_minmax(int min_vertex, int max_vertex, GeomVertexArrayData *mins, GeomVertexArrayData *maxs)
 */
static PyObject *Dtool_GeomPrimitive_set_minmax_757(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.set_minmax")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::set_minmax(int min_vertex, int max_vertex, GeomVertexArrayData *mins, GeomVertexArrayData *maxs)
  int param1;
  int param2;
  PyObject *param3;
  PyObject *param4;
  static const char *keyword_list[] = {"min_vertex", "max_vertex", "mins", "maxs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiOO:set_minmax", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    GeomVertexArrayData *param3_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_GeomVertexArrayData, 3, "GeomPrimitive.set_minmax", false, true);
    GeomVertexArrayData *param4_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_GeomVertexArrayData, 4, "GeomPrimitive.set_minmax", false, true);
    if (param3_this != nullptr && param4_this != nullptr) {
      ((*local_this).set_minmax)((int)param1, (int)param2, param3_this, param4_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_minmax(const GeomPrimitive self, int min_vertex, int max_vertex, GeomVertexArrayData mins, GeomVertexArrayData maxs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_set_minmax_757_comment =
  "C++ Interface:\n"
  "set_minmax(const GeomPrimitive self, int min_vertex, int max_vertex, GeomVertexArrayData mins, GeomVertexArrayData maxs)\n"
  "\n"
  "/**\n"
  " * Explicitly specifies the minimum and maximum vertices, as well as the lists\n"
  " * of per-component min and max.\n"
  " *\n"
  " * Use this method with extreme caution.  It's generally better to let the\n"
  " * GeomPrimitive compute these explicitly, unless for some reason you can do\n"
  " * it faster and you absolutely need the speed improvement.\n"
  " *\n"
  " * Note that any modification to the vertex array will normally cause this to\n"
  " * be recomputed, unless you set it immediately again.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_set_minmax_757_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomPrimitive::clear_minmax(void)
 */
static PyObject *Dtool_GeomPrimitive_clear_minmax_758(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.clear_minmax")) {
    return nullptr;
  }
  // 1-void GeomPrimitive::clear_minmax(void)
  ((*local_this).clear_minmax)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_clear_minmax_758_comment =
  "C++ Interface:\n"
  "clear_minmax(const GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Undoes a previous call to set_minmax(), and allows the minimum and maximum\n"
  " * values to be recomputed normally.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_clear_minmax_758_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int GeomPrimitive::get_num_vertices_per_primitive(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_num_vertices_per_primitive_759(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-virtual int GeomPrimitive::get_num_vertices_per_primitive(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_num_vertices_per_primitive)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_num_vertices_per_primitive_759_comment =
  "C++ Interface:\n"
  "get_num_vertices_per_primitive(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * If the primitive type is a simple type in which all primitives have the\n"
  " * same number of vertices, like triangles, returns the number of vertices per\n"
  " * primitive.  If the primitive type is a more complex type in which different\n"
  " * primitives might have different numbers of vertices, for instance a\n"
  " * triangle strip, returns 0.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_num_vertices_per_primitive_759_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int GeomPrimitive::get_min_num_vertices_per_primitive(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_min_num_vertices_per_primitive_760(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-virtual int GeomPrimitive::get_min_num_vertices_per_primitive(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_min_num_vertices_per_primitive)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_min_num_vertices_per_primitive_760_comment =
  "C++ Interface:\n"
  "get_min_num_vertices_per_primitive(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum number of vertices that must be added before\n"
  " * close_primitive() may legally be called.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_min_num_vertices_per_primitive_760_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int GeomPrimitive::get_num_unused_vertices_per_primitive(void) const
 */
static PyObject *Dtool_GeomPrimitive_get_num_unused_vertices_per_primitive_761(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomPrimitive)) {
    return nullptr;
  }
  // 1-virtual int GeomPrimitive::get_num_unused_vertices_per_primitive(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_num_unused_vertices_per_primitive)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_num_unused_vertices_per_primitive_761_comment =
  "C++ Interface:\n"
  "get_num_unused_vertices_per_primitive(GeomPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices that are added between primitives that\n"
  " * aren't, strictly speaking, part of the primitives themselves.  This is\n"
  " * used, for instance, to define degenerate triangles to connect otherwise\n"
  " * disconnected triangle strips.\n"
  " *\n"
  " * This method is intended for low-level usage only.  There are higher-level\n"
  " * methods for more common usage.  We recommend you do not use this method\n"
  " * directly.  If you do, be sure you know what you are doing!\n"
  " */";
#else
static const char *Dtool_GeomPrimitive_get_num_unused_vertices_per_primitive_761_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeomPrimitive::get_class_type(void)
 */
static PyObject *Dtool_GeomPrimitive_get_class_type_765(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomPrimitive::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomPrimitive::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_get_class_type_765_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomPrimitive_get_class_type_765_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CopyOnWriteObject *GeomPrimitive::upcast_to_CopyOnWriteObject(void)
 */
static PyObject *Dtool_GeomPrimitive_upcast_to_CopyOnWriteObject_670(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.upcast_to_CopyOnWriteObject")) {
    return nullptr;
  }
  // 1-CopyOnWriteObject *GeomPrimitive::upcast_to_CopyOnWriteObject(void)
  CopyOnWriteObject *return_value = (CopyOnWriteObject *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CopyOnWriteObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_upcast_to_CopyOnWriteObject_670_comment =
  "C++ Interface:\n"
  "upcast_to_CopyOnWriteObject(const GeomPrimitive self)\n"
  "\n"
  "upcast from GeomPrimitive to CopyOnWriteObject";
#else
static const char *Dtool_GeomPrimitive_upcast_to_CopyOnWriteObject_670_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomEnums *GeomPrimitive::upcast_to_GeomEnums(void)
 */
static PyObject *Dtool_GeomPrimitive_upcast_to_GeomEnums_672(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomPrimitive, (void **)&local_this, "GeomPrimitive.upcast_to_GeomEnums")) {
    return nullptr;
  }
  // 1-GeomEnums *GeomPrimitive::upcast_to_GeomEnums(void)
  GeomEnums *return_value = (GeomEnums *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomEnums, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomPrimitive_upcast_to_GeomEnums_672_comment =
  "C++ Interface:\n"
  "upcast_to_GeomEnums(const GeomPrimitive self)\n"
  "\n"
  "upcast from GeomPrimitive to GeomEnums";
#else
static const char *Dtool_GeomPrimitive_upcast_to_GeomEnums_672_comment = nullptr;
#endif

static PyObject *Dtool_GeomPrimitive_primitive_type_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual GeomEnums::PrimitiveType GeomPrimitive::get_primitive_type(void) const = 0
  GeomEnums::PrimitiveType return_value = ((*(const GeomPrimitive*)local_this).get_primitive_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomPrimitive_geom_rendering_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual int GeomPrimitive::get_geom_rendering(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_geom_rendering)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomPrimitive_shade_model_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::ShadeModel GeomPrimitive::get_shade_model(void) const
  GeomEnums::ShadeModel return_value = ((*(const GeomPrimitive*)local_this).get_shade_model)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomPrimitive_usage_hint_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::UsageHint GeomPrimitive::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const GeomPrimitive*)local_this).get_usage_hint)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomPrimitive_index_type_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::NumericType GeomPrimitive::get_index_type(void) const
  GeomEnums::NumericType return_value = ((*(const GeomPrimitive*)local_this).get_index_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomPrimitive_num_bytes_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int GeomPrimitive::get_num_bytes(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_num_bytes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomPrimitive_data_size_bytes_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GeomPrimitive::get_data_size_bytes(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_data_size_bytes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomPrimitive_modified_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq GeomPrimitive::get_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const GeomPrimitive*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

static PyObject *Dtool_GeomPrimitive_index_stride_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GeomPrimitive::get_index_stride(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_index_stride)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomPrimitive_strip_cut_index_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GeomPrimitive::get_strip_cut_index(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_strip_cut_index)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomPrimitive_mins_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConstPointerTo< GeomVertexArrayData > GeomPrimitive::get_mins(void) const
  ConstPointerTo< GeomVertexArrayData > return_value = ((*(const GeomPrimitive*)local_this).get_mins)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  GeomVertexArrayData const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayData, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_GeomPrimitive_maxs_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConstPointerTo< GeomVertexArrayData > GeomPrimitive::get_maxs(void) const
  ConstPointerTo< GeomVertexArrayData > return_value = ((*(const GeomPrimitive*)local_this).get_maxs)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  GeomVertexArrayData const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexArrayData, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_GeomPrimitive_num_vertices_per_primitive_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual int GeomPrimitive::get_num_vertices_per_primitive(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_num_vertices_per_primitive)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomPrimitive_min_num_vertices_per_primitive_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual int GeomPrimitive::get_min_num_vertices_per_primitive(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_min_num_vertices_per_primitive)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GeomPrimitive_num_unused_vertices_per_primitive_Getter(PyObject *self, void *) {
  const GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual int GeomPrimitive::get_num_unused_vertices_per_primitive(void) const
  int return_value = ((*(const GeomPrimitive*)local_this).get_num_unused_vertices_per_primitive)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_GeomPrimitive(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GeomPrimitive_get_vertex_list(PyObject *self, PyObject *) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_vertices)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GeomPrimitive_get_vertex_697(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_GeomPrimitive(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomPrimitive) {
    printf("GeomPrimitive ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomPrimitive *local_this = (GeomPrimitive *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomPrimitive) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomPrimitive(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomPrimitive*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextureStage
 */
/**
 * Python function wrapper for:
 * void TextureStage::operator =(TextureStage const &copy)
 */
static PyObject *Dtool_TextureStage_operator_768(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.assign")) {
    return nullptr;
  }
  // 1-void TextureStage::operator =(TextureStage const &copy)
  TextureStage const *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureStage.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    TextureStage *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TextureStage self, const TextureStage copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_operator_768_comment =
  "C++ Interface:\n"
  "assign(const TextureStage self, const TextureStage copy)\n";
#else
static const char *Dtool_TextureStage_operator_768_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_name(std::string const &name)
 */
static PyObject *Dtool_TextureStage_set_name_773(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_name")) {
    return nullptr;
  }
  // 1-inline void TextureStage::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const TextureStage self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_name_773_comment =
  "C++ Interface:\n"
  "set_name(const TextureStage self, str name)\n"
  "\n"
  "/**\n"
  " * Changes the name of this texture stage\n"
  " */";
#else
static const char *Dtool_TextureStage_set_name_773_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &TextureStage::get_name(void) const
 */
static PyObject *Dtool_TextureStage_get_name_774(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline std::string const &TextureStage::get_name(void) const
  std::string const &return_value = ((*(const TextureStage*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_name_774_comment =
  "C++ Interface:\n"
  "get_name(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this texture stage\n"
  " */";
#else
static const char *Dtool_TextureStage_get_name_774_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_sort(int sort)
 */
static PyObject *Dtool_TextureStage_set_sort_775(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_sort")) {
    return nullptr;
  }
  // 1-inline void TextureStage::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_sort)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sort(const TextureStage self, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_sort_775_comment =
  "C++ Interface:\n"
  "set_sort(const TextureStage self, int sort)\n"
  "\n"
  "/**\n"
  " * Changes the order in which the texture associated with this stage is\n"
  " * rendered relative to the other texture stages.  When geometry is rendered\n"
  " * with multiple textures, the textures are rendered in order from the lowest\n"
  " * sort number to the highest sort number.\n"
  " *\n"
  " * Also see set_priority(), which is used to select the most important\n"
  " * textures for rendering when some must be omitted because of hardware\n"
  " * limitations.\n"
  " */";
#else
static const char *Dtool_TextureStage_set_sort_775_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureStage::get_sort(void) const
 */
static PyObject *Dtool_TextureStage_get_sort_776(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline int TextureStage::get_sort(void) const
  int return_value = ((*(const TextureStage*)local_this).get_sort)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_sort_776_comment =
  "C++ Interface:\n"
  "get_sort(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns the sort order of this texture stage.\n"
  " */";
#else
static const char *Dtool_TextureStage_get_sort_776_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_priority(int priority)
 */
static PyObject *Dtool_TextureStage_set_priority_777(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_priority")) {
    return nullptr;
  }
  // 1-inline void TextureStage::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_priority)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_priority(const TextureStage self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_priority_777_comment =
  "C++ Interface:\n"
  "set_priority(const TextureStage self, int priority)\n"
  "\n"
  "/**\n"
  " * Changes the relative importance of the texture associated with this stage\n"
  " * relative to the other texture stages that are applied simultaneously.\n"
  " *\n"
  " * This is unrelated to set_sort(), which controls the order in which multiple\n"
  " * textures are applied.  The priority number is used to decide which of the\n"
  " * requested textures are to be selected for rendering when more textures are\n"
  " * requested than the hardware will support.  The highest-priority n textures\n"
  " * are selected for rendering, and then rendered in order by their sort\n"
  " * factor.\n"
  " */";
#else
static const char *Dtool_TextureStage_set_priority_777_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureStage::get_priority(void) const
 */
static PyObject *Dtool_TextureStage_get_priority_778(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline int TextureStage::get_priority(void) const
  int return_value = ((*(const TextureStage*)local_this).get_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_priority_778_comment =
  "C++ Interface:\n"
  "get_priority(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns the priority associated with this stage.\n"
  " *\n"
  " * This is specially helpful for cards that do not support more than n stages\n"
  " * of multi-texturing.\n"
  " */";
#else
static const char *Dtool_TextureStage_get_priority_778_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_texcoord_name(InternalName *name)
 * inline void TextureStage::set_texcoord_name(std::string const &texcoord_name)
 */
static PyObject *Dtool_TextureStage_set_texcoord_name_779(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_texcoord_name")) {
    return nullptr;
  }
  {
    // -2 inline void TextureStage::set_texcoord_name(InternalName *name)
    InternalName *arg_this = (InternalName *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InternalName, 1, "TextureStage.set_texcoord_name", false, false);
    if (arg_this != nullptr) {
      ((*local_this).set_texcoord_name)(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void TextureStage::set_texcoord_name(std::string const &texcoord_name)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).set_texcoord_name)(std::string(param1_str, param1_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TextureStage::set_texcoord_name(InternalName *name)
    PT(InternalName) arg_this;
    if (Dtool_Coerce_InternalName(arg, arg_this)) {
      ((*local_this).set_texcoord_name)(std::move(arg_this));
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void TextureStage::set_texcoord_name(std::string const &texcoord_name)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texcoord_name(const TextureStage self, InternalName name)\n"
      "set_texcoord_name(const TextureStage self, str texcoord_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_texcoord_name_779_comment =
  "C++ Interface:\n"
  "set_texcoord_name(const TextureStage self, InternalName name)\n"
  "set_texcoord_name(const TextureStage self, str texcoord_name)\n"
  "\n"
  "/**\n"
  " * Indicate which set of UV's this texture stage will use.  Geometry may have\n"
  " * any number of associated UV sets, each of which must have a unique name.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Indicate which set of UV's this texture stage will use.  Geometry may have\n"
  " * any number of associated UV sets, each of which must have a unique name.\n"
  " */";
#else
static const char *Dtool_TextureStage_set_texcoord_name_779_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName *TextureStage::get_texcoord_name(void) const
 */
static PyObject *Dtool_TextureStage_get_texcoord_name_780(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline InternalName *TextureStage::get_texcoord_name(void) const
  InternalName *return_value = ((*(const TextureStage*)local_this).get_texcoord_name)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_texcoord_name_780_comment =
  "C++ Interface:\n"
  "get_texcoord_name(TextureStage self)\n"
  "\n"
  "/**\n"
  " * See set_texcoord_name.  The default is InternalName::get_texcoord().\n"
  " */";
#else
static const char *Dtool_TextureStage_get_texcoord_name_780_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName *TextureStage::get_tangent_name(void) const
 */
static PyObject *Dtool_TextureStage_get_tangent_name_781(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline InternalName *TextureStage::get_tangent_name(void) const
  InternalName *return_value = ((*(const TextureStage*)local_this).get_tangent_name)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_tangent_name_781_comment =
  "C++ Interface:\n"
  "get_tangent_name(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tangents this texture stage will use.  This is the same\n"
  " * as get_texcoord_name(), except that the first part is \"tangent\".\n"
  " */";
#else
static const char *Dtool_TextureStage_get_tangent_name_781_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InternalName *TextureStage::get_binormal_name(void) const
 */
static PyObject *Dtool_TextureStage_get_binormal_name_782(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline InternalName *TextureStage::get_binormal_name(void) const
  InternalName *return_value = ((*(const TextureStage*)local_this).get_binormal_name)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_binormal_name_782_comment =
  "C++ Interface:\n"
  "get_binormal_name(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns the set of binormals this texture stage will use.  This is the same\n"
  " * as get_binormal_name(), except that the first part is \"binormal\".\n"
  " */";
#else
static const char *Dtool_TextureStage_get_binormal_name_782_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_mode(TextureStage::Mode mode)
 */
static PyObject *Dtool_TextureStage_set_mode_783(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_mode")) {
    return nullptr;
  }
  // 1-inline void TextureStage::set_mode(TextureStage::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_mode)((TextureStage::Mode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mode(const TextureStage self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_mode_783_comment =
  "C++ Interface:\n"
  "set_mode(const TextureStage self, int mode)\n"
  "\n"
  "/**\n"
  " * Set the mode of this texture stage\n"
  " */";
#else
static const char *Dtool_TextureStage_set_mode_783_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::Mode TextureStage::get_mode(void) const
 */
static PyObject *Dtool_TextureStage_get_mode_784(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::Mode TextureStage::get_mode(void) const
  TextureStage::Mode return_value = ((*(const TextureStage*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_mode_784_comment =
  "C++ Interface:\n"
  "get_mode(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Return the mode of this stage\n"
  " */";
#else
static const char *Dtool_TextureStage_get_mode_784_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureStage::is_fixed_function(void) const
 */
static PyObject *Dtool_TextureStage_is_fixed_function_785(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline bool TextureStage::is_fixed_function(void) const
  bool return_value = ((*(const TextureStage*)local_this).is_fixed_function)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_is_fixed_function_785_comment =
  "C++ Interface:\n"
  "is_fixed_function(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns true if the TextureStage is relevant to the classic fixed function\n"
  " * pipeline.  This excludes texture stages such as normal mapping and the\n"
  " * like.\n"
  " */";
#else
static const char *Dtool_TextureStage_is_fixed_function_785_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_color(LColor const &color)
 */
static PyObject *Dtool_TextureStage_set_color_786(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_color")) {
    return nullptr;
  }
  // 1-inline void TextureStage::set_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TextureStage.set_color", "LVecBase4f");
  }
  ((*local_this).set_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const TextureStage self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_color_786_comment =
  "C++ Interface:\n"
  "set_color(const TextureStage self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Set the color for this stage\n"
  " */";
#else
static const char *Dtool_TextureStage_set_color_786_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor TextureStage::get_color(void) const
 */
static PyObject *Dtool_TextureStage_get_color_787(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline LColor TextureStage::get_color(void) const
  LColor *return_value = new LColor(((*(const TextureStage*)local_this).get_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_color_787_comment =
  "C++ Interface:\n"
  "get_color(TextureStage self)\n"
  "\n"
  "/**\n"
  " * return the color for this stage\n"
  " */";
#else
static const char *Dtool_TextureStage_get_color_787_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_rgb_scale(int rgb_scale)
 */
static PyObject *Dtool_TextureStage_set_rgb_scale_788(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_rgb_scale")) {
    return nullptr;
  }
  // 1-inline void TextureStage::set_rgb_scale(int rgb_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_rgb_scale)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rgb_scale(const TextureStage self, int rgb_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_rgb_scale_788_comment =
  "C++ Interface:\n"
  "set_rgb_scale(const TextureStage self, int rgb_scale)\n"
  "\n"
  "/**\n"
  " * Sets an additional factor that will scale all three r, g, b components\n"
  " * after the texture has been applied.  This is used only when the mode is\n"
  " * CM_combine.\n"
  " *\n"
  " * The only legal values are 1, 2, or 4.\n"
  " */";
#else
static const char *Dtool_TextureStage_set_rgb_scale_788_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureStage::get_rgb_scale(void) const
 */
static PyObject *Dtool_TextureStage_get_rgb_scale_789(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline int TextureStage::get_rgb_scale(void) const
  int return_value = ((*(const TextureStage*)local_this).get_rgb_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_rgb_scale_789_comment =
  "C++ Interface:\n"
  "get_rgb_scale(TextureStage self)\n"
  "\n"
  "/**\n"
  " * See set_rgb_scale().\n"
  " */";
#else
static const char *Dtool_TextureStage_get_rgb_scale_789_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_alpha_scale(int alpha_scale)
 */
static PyObject *Dtool_TextureStage_set_alpha_scale_790(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_alpha_scale")) {
    return nullptr;
  }
  // 1-inline void TextureStage::set_alpha_scale(int alpha_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_alpha_scale)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_scale(const TextureStage self, int alpha_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_alpha_scale_790_comment =
  "C++ Interface:\n"
  "set_alpha_scale(const TextureStage self, int alpha_scale)\n"
  "\n"
  "/**\n"
  " * Sets an additional factor that will scale the alpha component after the\n"
  " * texture has been applied.  This is used only when the mode is CM_combine.\n"
  " *\n"
  " * The only legal values are 1, 2, or 4.\n"
  " */";
#else
static const char *Dtool_TextureStage_set_alpha_scale_790_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureStage::get_alpha_scale(void) const
 */
static PyObject *Dtool_TextureStage_get_alpha_scale_791(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline int TextureStage::get_alpha_scale(void) const
  int return_value = ((*(const TextureStage*)local_this).get_alpha_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_alpha_scale_791_comment =
  "C++ Interface:\n"
  "get_alpha_scale(TextureStage self)\n"
  "\n"
  "/**\n"
  " * See set_alpha_scale().\n"
  " */";
#else
static const char *Dtool_TextureStage_get_alpha_scale_791_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_saved_result(bool saved_result)
 */
static PyObject *Dtool_TextureStage_set_saved_result_792(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_saved_result")) {
    return nullptr;
  }
  // 1-inline void TextureStage::set_saved_result(bool saved_result)
  ((*local_this).set_saved_result)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_saved_result(const TextureStage self, bool saved_result)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_saved_result_792_comment =
  "C++ Interface:\n"
  "set_saved_result(const TextureStage self, bool saved_result)\n"
  "\n"
  "/**\n"
  " * Sets the saved_result flag.  When this is true, the output of this stage\n"
  " * will be supplied as the \"last_saved_result\" source for any future stages,\n"
  " * until the next TextureStage with a saved_result set true is encountered.\n"
  " *\n"
  " * This can be used to reuse the results of this texture stage as input to\n"
  " * more than one stage later in the pipeline.\n"
  " *\n"
  " * The last texture in the pipeline (the one with the highest sort value)\n"
  " * should not have this flag set.\n"
  " */";
#else
static const char *Dtool_TextureStage_set_saved_result_792_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureStage::get_saved_result(void) const
 */
static PyObject *Dtool_TextureStage_get_saved_result_793(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline bool TextureStage::get_saved_result(void) const
  bool return_value = ((*(const TextureStage*)local_this).get_saved_result)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_saved_result_793_comment =
  "C++ Interface:\n"
  "get_saved_result(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the saved_result flag.  See\n"
  " * set_saved_result().\n"
  " */";
#else
static const char *Dtool_TextureStage_get_saved_result_793_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_tex_view_offset(int tex_view_offset)
 */
static PyObject *Dtool_TextureStage_set_tex_view_offset_794(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_tex_view_offset")) {
    return nullptr;
  }
  // 1-inline void TextureStage::set_tex_view_offset(int tex_view_offset)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_tex_view_offset)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_view_offset(const TextureStage self, int tex_view_offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_tex_view_offset_794_comment =
  "C++ Interface:\n"
  "set_tex_view_offset(const TextureStage self, int tex_view_offset)\n"
  "\n"
  "/**\n"
  " * Sets the tex_view_offset value.  This is used only when a special multiview\n"
  " * texture is bound to the TextureStage, and it selects the particular view of\n"
  " * the texture that is to be used.\n"
  " *\n"
  " * This value is added to the similar parameter on DisplayRegion to derive the\n"
  " * final texture view index that is selected for rendering.\n"
  " */";
#else
static const char *Dtool_TextureStage_set_tex_view_offset_794_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureStage::get_tex_view_offset(void) const
 */
static PyObject *Dtool_TextureStage_get_tex_view_offset_795(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline int TextureStage::get_tex_view_offset(void) const
  int return_value = ((*(const TextureStage*)local_this).get_tex_view_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_tex_view_offset_795_comment =
  "C++ Interface:\n"
  "get_tex_view_offset(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the tex_view_offset.  See\n"
  " * set_tex_view_offset().\n"
  " */";
#else
static const char *Dtool_TextureStage_get_tex_view_offset_795_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0)
 * inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1)
 * inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1, TextureStage::CombineSource source2, TextureStage::CombineOperand operand2)
 */
static PyObject *Dtool_TextureStage_set_combine_rgb_796(PyObject *self, PyObject *args, PyObject *kwds) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_combine_rgb")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"mode", "source0", "operand0", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:set_combine_rgb", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_combine_rgb)((TextureStage::CombineMode)param1, (TextureStage::CombineSource)param2, (TextureStage::CombineOperand)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 5:
    {
      // 1-inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1)
      int param1;
      int param2;
      int param3;
      int param4;
      int param5;
      static const char *keyword_list[] = {"mode", "source0", "operand0", "source1", "operand1", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiii:set_combine_rgb", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).set_combine_rgb)((TextureStage::CombineMode)param1, (TextureStage::CombineSource)param2, (TextureStage::CombineOperand)param3, (TextureStage::CombineSource)param4, (TextureStage::CombineOperand)param5);
        return Dtool_Return_None();
      }
    }
    break;
  case 7:
    {
      // 1-inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1, TextureStage::CombineSource source2, TextureStage::CombineOperand operand2)
      int param1;
      int param2;
      int param3;
      int param4;
      int param5;
      int param6;
      int param7;
      static const char *keyword_list[] = {"mode", "source0", "operand0", "source1", "operand1", "source2", "operand2", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiiiii:set_combine_rgb", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        ((*local_this).set_combine_rgb)((TextureStage::CombineMode)param1, (TextureStage::CombineSource)param2, (TextureStage::CombineOperand)param3, (TextureStage::CombineSource)param4, (TextureStage::CombineOperand)param5, (TextureStage::CombineSource)param6, (TextureStage::CombineOperand)param7);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_combine_rgb() takes 4, 6 or 8 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_combine_rgb(const TextureStage self, int mode, int source0, int operand0)\n"
      "set_combine_rgb(const TextureStage self, int mode, int source0, int operand0, int source1, int operand1)\n"
      "set_combine_rgb(const TextureStage self, int mode, int source0, int operand0, int source1, int operand1, int source2, int operand2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_combine_rgb_796_comment =
  "C++ Interface:\n"
  "set_combine_rgb(const TextureStage self, int mode, int source0, int operand0)\n"
  "set_combine_rgb(const TextureStage self, int mode, int source0, int operand0, int source1, int operand1)\n"
  "set_combine_rgb(const TextureStage self, int mode, int source0, int operand0, int source1, int operand1, int source2, int operand2)\n"
  "\n"
  "/**\n"
  " * Specifies any of the CombineMode values that represent a one-parameter\n"
  " * operation.  Specifically, this is CM_replace only.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies any of the CombineMode values that represent a two-parameter\n"
  " * operation.  Specifically, this is everything except for CM_replace and\n"
  " * CM_interpolate.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies any of the CombineMode values that represent a one-parameter\n"
  " * operation.  Specifically, this is CM_interpolate only.\n"
  " */";
#else
static const char *Dtool_TextureStage_set_combine_rgb_796_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineMode TextureStage::get_combine_rgb_mode(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_rgb_mode_797(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineMode TextureStage::get_combine_rgb_mode(void) const
  TextureStage::CombineMode return_value = ((*(const TextureStage*)local_this).get_combine_rgb_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_rgb_mode_797_comment =
  "C++ Interface:\n"
  "get_combine_rgb_mode(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get the combine_rgb_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_rgb_mode_797_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureStage::get_num_combine_rgb_operands(void) const
 */
static PyObject *Dtool_TextureStage_get_num_combine_rgb_operands_798(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline int TextureStage::get_num_combine_rgb_operands(void) const
  int return_value = ((*(const TextureStage*)local_this).get_num_combine_rgb_operands)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_num_combine_rgb_operands_798_comment =
  "C++ Interface:\n"
  "get_num_combine_rgb_operands(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns the number of meaningful operands that may be retrieved via\n"
  " * get_combine_rgb_sourceN() and get_combine_rgb_operandN().\n"
  " */";
#else
static const char *Dtool_TextureStage_get_num_combine_rgb_operands_798_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineSource TextureStage::get_combine_rgb_source0(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_rgb_source0_799(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineSource TextureStage::get_combine_rgb_source0(void) const
  TextureStage::CombineSource return_value = ((*(const TextureStage*)local_this).get_combine_rgb_source0)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_rgb_source0_799_comment =
  "C++ Interface:\n"
  "get_combine_rgb_source0(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get source0 of combine_rgb_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_rgb_source0_799_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand0(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_rgb_operand0_800(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand0(void) const
  TextureStage::CombineOperand return_value = ((*(const TextureStage*)local_this).get_combine_rgb_operand0)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_rgb_operand0_800_comment =
  "C++ Interface:\n"
  "get_combine_rgb_operand0(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get operand0 of combine_rgb_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_rgb_operand0_800_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineSource TextureStage::get_combine_rgb_source1(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_rgb_source1_801(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineSource TextureStage::get_combine_rgb_source1(void) const
  TextureStage::CombineSource return_value = ((*(const TextureStage*)local_this).get_combine_rgb_source1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_rgb_source1_801_comment =
  "C++ Interface:\n"
  "get_combine_rgb_source1(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get source1 of combine_rgb_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_rgb_source1_801_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand1(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_rgb_operand1_802(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand1(void) const
  TextureStage::CombineOperand return_value = ((*(const TextureStage*)local_this).get_combine_rgb_operand1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_rgb_operand1_802_comment =
  "C++ Interface:\n"
  "get_combine_rgb_operand1(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get operand1 of combine_rgb_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_rgb_operand1_802_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineSource TextureStage::get_combine_rgb_source2(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_rgb_source2_803(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineSource TextureStage::get_combine_rgb_source2(void) const
  TextureStage::CombineSource return_value = ((*(const TextureStage*)local_this).get_combine_rgb_source2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_rgb_source2_803_comment =
  "C++ Interface:\n"
  "get_combine_rgb_source2(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get source2 of combine_rgb_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_rgb_source2_803_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand2(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_rgb_operand2_804(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand2(void) const
  TextureStage::CombineOperand return_value = ((*(const TextureStage*)local_this).get_combine_rgb_operand2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_rgb_operand2_804_comment =
  "C++ Interface:\n"
  "get_combine_rgb_operand2(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get operand2 of combine_rgb_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_rgb_operand2_804_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0)
 * inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1)
 * inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1, TextureStage::CombineSource source2, TextureStage::CombineOperand operand2)
 */
static PyObject *Dtool_TextureStage_set_combine_alpha_805(PyObject *self, PyObject *args, PyObject *kwds) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.set_combine_alpha")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"mode", "source0", "operand0", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:set_combine_alpha", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_combine_alpha)((TextureStage::CombineMode)param1, (TextureStage::CombineSource)param2, (TextureStage::CombineOperand)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 5:
    {
      // 1-inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1)
      int param1;
      int param2;
      int param3;
      int param4;
      int param5;
      static const char *keyword_list[] = {"mode", "source0", "operand0", "source1", "operand1", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiii:set_combine_alpha", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).set_combine_alpha)((TextureStage::CombineMode)param1, (TextureStage::CombineSource)param2, (TextureStage::CombineOperand)param3, (TextureStage::CombineSource)param4, (TextureStage::CombineOperand)param5);
        return Dtool_Return_None();
      }
    }
    break;
  case 7:
    {
      // 1-inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1, TextureStage::CombineSource source2, TextureStage::CombineOperand operand2)
      int param1;
      int param2;
      int param3;
      int param4;
      int param5;
      int param6;
      int param7;
      static const char *keyword_list[] = {"mode", "source0", "operand0", "source1", "operand1", "source2", "operand2", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiiiii:set_combine_alpha", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        ((*local_this).set_combine_alpha)((TextureStage::CombineMode)param1, (TextureStage::CombineSource)param2, (TextureStage::CombineOperand)param3, (TextureStage::CombineSource)param4, (TextureStage::CombineOperand)param5, (TextureStage::CombineSource)param6, (TextureStage::CombineOperand)param7);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_combine_alpha() takes 4, 6 or 8 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_combine_alpha(const TextureStage self, int mode, int source0, int operand0)\n"
      "set_combine_alpha(const TextureStage self, int mode, int source0, int operand0, int source1, int operand1)\n"
      "set_combine_alpha(const TextureStage self, int mode, int source0, int operand0, int source1, int operand1, int source2, int operand2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_set_combine_alpha_805_comment =
  "C++ Interface:\n"
  "set_combine_alpha(const TextureStage self, int mode, int source0, int operand0)\n"
  "set_combine_alpha(const TextureStage self, int mode, int source0, int operand0, int source1, int operand1)\n"
  "set_combine_alpha(const TextureStage self, int mode, int source0, int operand0, int source1, int operand1, int source2, int operand2)\n"
  "\n"
  "/**\n"
  " * Specifies any of the CombineMode values that represent a one-parameter\n"
  " * operation.  Specifically, this is CM_replace only.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies any of the CombineMode values that represent a two-parameter\n"
  " * operation.  Specifically, this is everything except for CM_replace and\n"
  " * CM_interpolate.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies any of the CombineMode values that represent a one-parameter\n"
  " * operation.  Specifically, this is CM_interpolate only.\n"
  " */";
#else
static const char *Dtool_TextureStage_set_combine_alpha_805_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineMode TextureStage::get_combine_alpha_mode(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_alpha_mode_806(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineMode TextureStage::get_combine_alpha_mode(void) const
  TextureStage::CombineMode return_value = ((*(const TextureStage*)local_this).get_combine_alpha_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_alpha_mode_806_comment =
  "C++ Interface:\n"
  "get_combine_alpha_mode(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get combine_alpha_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_alpha_mode_806_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureStage::get_num_combine_alpha_operands(void) const
 */
static PyObject *Dtool_TextureStage_get_num_combine_alpha_operands_807(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline int TextureStage::get_num_combine_alpha_operands(void) const
  int return_value = ((*(const TextureStage*)local_this).get_num_combine_alpha_operands)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_num_combine_alpha_operands_807_comment =
  "C++ Interface:\n"
  "get_num_combine_alpha_operands(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns the number of meaningful operands that may be retrieved via\n"
  " * get_combine_alpha_sourceN() and get_combine_alpha_operandN().\n"
  " */";
#else
static const char *Dtool_TextureStage_get_num_combine_alpha_operands_807_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineSource TextureStage::get_combine_alpha_source0(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_alpha_source0_808(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineSource TextureStage::get_combine_alpha_source0(void) const
  TextureStage::CombineSource return_value = ((*(const TextureStage*)local_this).get_combine_alpha_source0)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_alpha_source0_808_comment =
  "C++ Interface:\n"
  "get_combine_alpha_source0(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get source0 of combine_alpha_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_alpha_source0_808_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand0(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_alpha_operand0_809(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand0(void) const
  TextureStage::CombineOperand return_value = ((*(const TextureStage*)local_this).get_combine_alpha_operand0)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_alpha_operand0_809_comment =
  "C++ Interface:\n"
  "get_combine_alpha_operand0(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get operand0 of combine_alpha_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_alpha_operand0_809_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineSource TextureStage::get_combine_alpha_source1(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_alpha_source1_810(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineSource TextureStage::get_combine_alpha_source1(void) const
  TextureStage::CombineSource return_value = ((*(const TextureStage*)local_this).get_combine_alpha_source1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_alpha_source1_810_comment =
  "C++ Interface:\n"
  "get_combine_alpha_source1(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get source1 of combine_alpha_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_alpha_source1_810_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand1(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_alpha_operand1_811(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand1(void) const
  TextureStage::CombineOperand return_value = ((*(const TextureStage*)local_this).get_combine_alpha_operand1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_alpha_operand1_811_comment =
  "C++ Interface:\n"
  "get_combine_alpha_operand1(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get operand1 of combine_alpha_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_alpha_operand1_811_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineSource TextureStage::get_combine_alpha_source2(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_alpha_source2_812(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineSource TextureStage::get_combine_alpha_source2(void) const
  TextureStage::CombineSource return_value = ((*(const TextureStage*)local_this).get_combine_alpha_source2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_alpha_source2_812_comment =
  "C++ Interface:\n"
  "get_combine_alpha_source2(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get source2 of combine_alpha_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_alpha_source2_812_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand2(void) const
 */
static PyObject *Dtool_TextureStage_get_combine_alpha_operand2_813(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand2(void) const
  TextureStage::CombineOperand return_value = ((*(const TextureStage*)local_this).get_combine_alpha_operand2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_combine_alpha_operand2_813_comment =
  "C++ Interface:\n"
  "get_combine_alpha_operand2(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Get operand2 of combine_alpha_mode\n"
  " */";
#else
static const char *Dtool_TextureStage_get_combine_alpha_operand2_813_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureStage::involves_color_scale(void) const
 */
static PyObject *Dtool_TextureStage_involves_color_scale_814(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline bool TextureStage::involves_color_scale(void) const
  bool return_value = ((*(const TextureStage*)local_this).involves_color_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_involves_color_scale_814_comment =
  "C++ Interface:\n"
  "involves_color_scale(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns true if the TextureStage is affected by the setting of the current\n"
  " * ColorScaleAttrib, false otherwise.\n"
  " */";
#else
static const char *Dtool_TextureStage_involves_color_scale_814_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureStage::uses_color(void) const
 */
static PyObject *Dtool_TextureStage_uses_color_815(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline bool TextureStage::uses_color(void) const
  bool return_value = ((*(const TextureStage*)local_this).uses_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_uses_color_815_comment =
  "C++ Interface:\n"
  "uses_color(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns true if the TextureStage makes use of whatever color is specified\n"
  " * in set_color(), false otherwise.\n"
  " */";
#else
static const char *Dtool_TextureStage_uses_color_815_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureStage::uses_primary_color(void) const
 */
static PyObject *Dtool_TextureStage_uses_primary_color_816(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline bool TextureStage::uses_primary_color(void) const
  bool return_value = ((*(const TextureStage*)local_this).uses_primary_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_uses_primary_color_816_comment =
  "C++ Interface:\n"
  "uses_primary_color(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns true if the TextureStage makes use of the CS_primary_color combine\n"
  " * source.\n"
  " */";
#else
static const char *Dtool_TextureStage_uses_primary_color_816_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureStage::uses_last_saved_result(void) const
 */
static PyObject *Dtool_TextureStage_uses_last_saved_result_817(PyObject *self, PyObject *) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-inline bool TextureStage::uses_last_saved_result(void) const
  bool return_value = ((*(const TextureStage*)local_this).uses_last_saved_result)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_uses_last_saved_result_817_comment =
  "C++ Interface:\n"
  "uses_last_saved_result(TextureStage self)\n"
  "\n"
  "/**\n"
  " * Returns true if the TextureStage makes use of the CS_primary_color combine\n"
  " * source.\n"
  " */";
#else
static const char *Dtool_TextureStage_uses_last_saved_result_817_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TextureStage::compare_to(TextureStage const &other) const
 */
static PyObject *Dtool_TextureStage_compare_to_821(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-int TextureStage::compare_to(TextureStage const &other) const
  TextureStage const *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureStage.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const TextureStage*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(TextureStage self, const TextureStage other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_compare_to_821_comment =
  "C++ Interface:\n"
  "compare_to(TextureStage self, const TextureStage other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this TextureStage sorts before the other\n"
  " * one, greater than zero if it sorts after, or zero if they are equivalent.\n"
  " * The sorting order is arbitrary and largely meaningless, except to\n"
  " * differentiate different stages.\n"
  " */";
#else
static const char *Dtool_TextureStage_compare_to_821_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureStage::write(std::ostream &out) const
 */
static PyObject *Dtool_TextureStage_write_822(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-void TextureStage::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "TextureStage.write", false, true);
  if (arg_this != nullptr) {
    ((*(const TextureStage*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TextureStage self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_write_822_comment =
  "C++ Interface:\n"
  "write(TextureStage self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes the details of this stage\n"
  " */";
#else
static const char *Dtool_TextureStage_write_822_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureStage::output(std::ostream &out) const
 */
static PyObject *Dtool_TextureStage_output_823(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureStage)) {
    return nullptr;
  }
  // 1-void TextureStage::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "TextureStage.output", false, true);
  if (arg_this != nullptr) {
    ((*(const TextureStage*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(TextureStage self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_output_823_comment =
  "C++ Interface:\n"
  "output(TextureStage self, ostream out)\n"
  "\n"
  "/**\n"
  " * Just a single line output\n"
  " */";
#else
static const char *Dtool_TextureStage_output_823_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline TextureStage *TextureStage::get_default(void)
 */
static PyObject *Dtool_TextureStage_get_default_824(PyObject *, PyObject *) {
  // 1-static inline TextureStage *TextureStage::get_default(void)
  TextureStage *return_value = (TextureStage::get_default)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_default_824_comment =
  "C++ Interface:\n"
  "get_default()\n"
  "\n"
  "/**\n"
  " * Returns the default TextureStage that will be used for all texturing that\n"
  " * does not name a particular stage.  This generally handles the normal\n"
  " * single-texture case.\n"
  " */";
#else
static const char *Dtool_TextureStage_get_default_824_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextureStage::get_class_type(void)
 */
static PyObject *Dtool_TextureStage_get_class_type_842(PyObject *, PyObject *) {
  // 1-static TypeHandle TextureStage::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TextureStage::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureStage_get_class_type_842_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextureStage_get_class_type_842_comment = nullptr;
#endif

static PyObject *Dtool_TextureStage_name_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &TextureStage::get_name(void) const
  std::string const &return_value = ((*(const TextureStage*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextureStage_name_Setter(PyObject *self, PyObject *arg, void *) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete name attribute");
    return -1;
  }
  // 1-inline void TextureStage::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_name(const TextureStage self, str name)\n");
  }
  return -1;
}

static PyObject *Dtool_TextureStage_sort_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TextureStage::get_sort(void) const
  int return_value = ((*(const TextureStage*)local_this).get_sort)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextureStage_sort_Setter(PyObject *self, PyObject *arg, void *) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.sort")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete sort attribute");
    return -1;
  }
  // 1-inline void TextureStage::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_sort)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_sort(const TextureStage self, int sort)\n");
  }
  return -1;
}

static PyObject *Dtool_TextureStage_priority_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TextureStage::get_priority(void) const
  int return_value = ((*(const TextureStage*)local_this).get_priority)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextureStage_priority_Setter(PyObject *self, PyObject *arg, void *) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.priority")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete priority attribute");
    return -1;
  }
  // 1-inline void TextureStage::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_priority)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_priority(const TextureStage self, int priority)\n");
  }
  return -1;
}

static PyObject *Dtool_TextureStage_texcoord_name_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline InternalName *TextureStage::get_texcoord_name(void) const
  InternalName *return_value = ((*(const TextureStage*)local_this).get_texcoord_name)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, false);
}

static int Dtool_TextureStage_texcoord_name_Setter(PyObject *self, PyObject *arg, void *) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.texcoord_name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete texcoord_name attribute");
    return -1;
  }
  {
    // -2 inline void TextureStage::set_texcoord_name(InternalName *name)
    InternalName *arg_this = (InternalName *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InternalName, 1, "TextureStage.set_texcoord_name", false, false);
    if (arg_this != nullptr) {
      ((*local_this).set_texcoord_name)(arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void TextureStage::set_texcoord_name(std::string const &texcoord_name)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).set_texcoord_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
    PyErr_Clear();
  }

  {
    // -2 inline void TextureStage::set_texcoord_name(InternalName *name)
    PT(InternalName) arg_this;
    if (Dtool_Coerce_InternalName(arg, arg_this)) {
      ((*local_this).set_texcoord_name)(std::move(arg_this));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  // No coercion possible: inline void TextureStage::set_texcoord_name(std::string const &texcoord_name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texcoord_name(const TextureStage self, InternalName name)\n"
      "set_texcoord_name(const TextureStage self, str texcoord_name)\n");
  }
  return -1;
}

static PyObject *Dtool_TextureStage_tangent_name_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline InternalName *TextureStage::get_tangent_name(void) const
  InternalName *return_value = ((*(const TextureStage*)local_this).get_tangent_name)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, false);
}

static PyObject *Dtool_TextureStage_binormal_name_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline InternalName *TextureStage::get_binormal_name(void) const
  InternalName *return_value = ((*(const TextureStage*)local_this).get_binormal_name)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InternalName, true, false);
}

static PyObject *Dtool_TextureStage_mode_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline TextureStage::Mode TextureStage::get_mode(void) const
  TextureStage::Mode return_value = ((*(const TextureStage*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextureStage_mode_Setter(PyObject *self, PyObject *arg, void *) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete mode attribute");
    return -1;
  }
  // 1-inline void TextureStage::set_mode(TextureStage::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_mode)((TextureStage::Mode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_mode(const TextureStage self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_TextureStage_color_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor TextureStage::get_color(void) const
  LColor *return_value = new LColor(((*(const TextureStage*)local_this).get_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextureStage_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete color attribute");
    return -1;
  }
  // 1-inline void TextureStage::set_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextureStage.set_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_color(const TextureStage self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextureStage_rgb_scale_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TextureStage::get_rgb_scale(void) const
  int return_value = ((*(const TextureStage*)local_this).get_rgb_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextureStage_rgb_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.rgb_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete rgb_scale attribute");
    return -1;
  }
  // 1-inline void TextureStage::set_rgb_scale(int rgb_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_rgb_scale)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_rgb_scale(const TextureStage self, int rgb_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_TextureStage_alpha_scale_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TextureStage::get_alpha_scale(void) const
  int return_value = ((*(const TextureStage*)local_this).get_alpha_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextureStage_alpha_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.alpha_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete alpha_scale attribute");
    return -1;
  }
  // 1-inline void TextureStage::set_alpha_scale(int alpha_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_alpha_scale)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_scale(const TextureStage self, int alpha_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_TextureStage_saved_result_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool TextureStage::get_saved_result(void) const
  bool return_value = ((*(const TextureStage*)local_this).get_saved_result)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextureStage_saved_result_Setter(PyObject *self, PyObject *arg, void *) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.saved_result")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete saved_result attribute");
    return -1;
  }
  // 1-inline void TextureStage::set_saved_result(bool saved_result)
  ((*local_this).set_saved_result)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_saved_result(const TextureStage self, bool saved_result)\n");
  }
  return -1;
}

static PyObject *Dtool_TextureStage_tex_view_offset_Getter(PyObject *self, void *) {
  const TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TextureStage::get_tex_view_offset(void) const
  int return_value = ((*(const TextureStage*)local_this).get_tex_view_offset)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextureStage_tex_view_offset_Setter(PyObject *self, PyObject *arg, void *) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureStage, (void **)&local_this, "TextureStage.tex_view_offset")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete tex_view_offset attribute");
    return -1;
  }
  // 1-inline void TextureStage::set_tex_view_offset(int tex_view_offset)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_tex_view_offset)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tex_view_offset(const TextureStage self, int tex_view_offset)\n");
  }
  return -1;
}

static PyObject *Dtool_TextureStage_default_Getter(PyObject *self, void *) {
  // 1-static inline TextureStage *TextureStage::get_default(void)
  TextureStage *return_value = (TextureStage::get_default)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * inline TextureStage::TextureStage(TextureStage const &copy)
 * explicit TextureStage::TextureStage(std::string const &name)
 */
static int Dtool_Init_TextureStage(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TextureStage() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline TextureStage::TextureStage(TextureStage const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      TextureStage const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TextureStage);
      if (param0_this != nullptr) {
        TextureStage *return_value = new TextureStage(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureStage, true, false);
      }
    }
  }

  {
    // -2 explicit TextureStage::TextureStage(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:TextureStage", (char **)keyword_list, &param0_str, &param0_len)) {
      TextureStage *return_value = new TextureStage(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureStage, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline TextureStage::TextureStage(TextureStage const &copy)
  // No coercion possible: explicit TextureStage::TextureStage(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextureStage(const TextureStage copy)\n"
      "TextureStage(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextureStage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextureStage) {
    printf("TextureStage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextureStage *local_this = (TextureStage *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextureStage) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextureStage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextureStage) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TextureStage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TextureStage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TextureStage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TextureStage*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Geom
 */
/**
 * Python function wrapper for:
 * void Geom::operator =(Geom const &copy)
 */
static PyObject *Dtool_Geom_operator_849(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.assign")) {
    return nullptr;
  }
  // 1-void Geom::operator =(Geom const &copy)
  Geom const *arg_this = (Geom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Geom, 1, "Geom.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    Geom *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Geom, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Geom self, const Geom copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_operator_849_comment =
  "C++ Interface:\n"
  "assign(const Geom self, const Geom copy)\n";
#else
static const char *Dtool_Geom_operator_849_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual Geom *Geom::make_copy(void) const
 */
static PyObject *Dtool_Geom_make_copy_854(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-virtual Geom *Geom::make_copy(void) const
  Geom *return_value = ((*(const Geom*)local_this).make_copy)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Geom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Geom_make_copy_854_comment =
  "C++ Interface:\n"
  "make_copy(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns a newly-allocated Geom that is a shallow copy of this one.  It will\n"
  " * be a different Geom pointer, but its internal data may or may not be shared\n"
  " * with that of the original Geom.\n"
  " */";
#else
static const char *Dtool_Geom_make_copy_854_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::PrimitiveType Geom::get_primitive_type(void) const
 */
static PyObject *Dtool_Geom_get_primitive_type_855(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline GeomEnums::PrimitiveType Geom::get_primitive_type(void) const
  GeomEnums::PrimitiveType return_value = ((*(const Geom*)local_this).get_primitive_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_primitive_type_855_comment =
  "C++ Interface:\n"
  "get_primitive_type(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns the fundamental primitive type that is common to all GeomPrimitives\n"
  " * added within the Geom.  All nested primitives within a particular Geom must\n"
  " * be the same type (that is, you can mix triangles and tristrips, because\n"
  " * they are both the same fundamental type PT_polygons, but you cannot mix\n"
  " * triangles and points withn the same Geom).\n"
  " */";
#else
static const char *Dtool_Geom_get_primitive_type_855_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::ShadeModel Geom::get_shade_model(void) const
 */
static PyObject *Dtool_Geom_get_shade_model_856(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline GeomEnums::ShadeModel Geom::get_shade_model(void) const
  GeomEnums::ShadeModel return_value = ((*(const Geom*)local_this).get_shade_model)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_shade_model_856_comment =
  "C++ Interface:\n"
  "get_shade_model(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns the shade model common to all of the individual GeomPrimitives that\n"
  " * have been added to the geom.\n"
  " */";
#else
static const char *Dtool_Geom_get_shade_model_856_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Geom::get_geom_rendering(void) const
 */
static PyObject *Dtool_Geom_get_geom_rendering_857(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline int Geom::get_geom_rendering(void) const
  int return_value = ((*(const Geom*)local_this).get_geom_rendering)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_geom_rendering_857_comment =
  "C++ Interface:\n"
  "get_geom_rendering(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns the set of GeomRendering bits that represent the rendering\n"
  " * properties required to properly render this Geom.\n"
  " */";
#else
static const char *Dtool_Geom_get_geom_rendering_857_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomEnums::UsageHint Geom::get_usage_hint(void) const
 */
static PyObject *Dtool_Geom_get_usage_hint_861(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-GeomEnums::UsageHint Geom::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const Geom*)local_this).get_usage_hint)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_usage_hint_861_comment =
  "C++ Interface:\n"
  "get_usage_hint(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum (i.e.  most dynamic) usage_hint among all of the\n"
  " * individual GeomPrimitives that have been added to the geom.\n"
  " * @deprecated  This is no longer very useful.\n"
  " */";
#else
static const char *Dtool_Geom_get_usage_hint_861_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::set_usage_hint(GeomEnums::UsageHint usage_hint)
 */
static PyObject *Dtool_Geom_set_usage_hint_862(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.set_usage_hint")) {
    return nullptr;
  }
  // 1-void Geom::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_usage_hint)((GeomEnums::UsageHint)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const Geom self, int usage_hint)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_set_usage_hint_862_comment =
  "C++ Interface:\n"
  "set_usage_hint(const Geom self, int usage_hint)\n"
  "\n"
  "/**\n"
  " * Changes the UsageHint hint for all of the primitives on this Geom to the\n"
  " * same value.  See get_usage_hint().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_set_usage_hint_862_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< GeomVertexData > Geom::get_vertex_data(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_Geom_get_vertex_data_863(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeomVertexData > Geom::get_vertex_data(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "Geom.get_vertex_data", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< GeomVertexData > return_value = ((*(const Geom*)local_this).get_vertex_data)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GeomVertexData const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexData, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex_data(Geom self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_vertex_data_863_comment =
  "C++ Interface:\n"
  "get_vertex_data(Geom self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the GeomVertexData, for application code to\n"
  " * directly examine (but not modify) the geom's underlying data.\n"
  " */";
#else
static const char *Dtool_Geom_get_vertex_data_863_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< GeomVertexData > Geom::modify_vertex_data(void)
 */
static PyObject *Dtool_Geom_modify_vertex_data_864(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.modify_vertex_data")) {
    return nullptr;
  }
  // 1-PointerTo< GeomVertexData > Geom::modify_vertex_data(void)
  PointerTo< GeomVertexData > return_value = ((*local_this).modify_vertex_data)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GeomVertexData *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexData, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Geom_modify_vertex_data_864_comment =
  "C++ Interface:\n"
  "modify_vertex_data(const Geom self)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the GeomVertexData, so that application\n"
  " * code may directly maniuplate the geom's underlying data.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_modify_vertex_data_864_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::set_vertex_data(GeomVertexData const *data)
 */
static PyObject *Dtool_Geom_set_vertex_data_865(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.set_vertex_data")) {
    return nullptr;
  }
  // 1-void Geom::set_vertex_data(GeomVertexData const *data)
  GeomVertexData const *arg_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexData, 1, "Geom.set_vertex_data", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_vertex_data)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex_data(const Geom self, const GeomVertexData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_set_vertex_data_865_comment =
  "C++ Interface:\n"
  "set_vertex_data(const Geom self, const GeomVertexData data)\n"
  "\n"
  "/**\n"
  " * Replaces the Geom's underlying vertex data table with a completely new\n"
  " * table.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_set_vertex_data_865_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::offset_vertices(GeomVertexData const *data, int offset)
 */
static PyObject *Dtool_Geom_offset_vertices_866(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.offset_vertices")) {
    return nullptr;
  }
  // 1-void Geom::offset_vertices(GeomVertexData const *data, int offset)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"data", "offset", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:offset_vertices", (char **)keyword_list, &param1, &param2)) {
    GeomVertexData const *param1_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GeomVertexData, 1, "Geom.offset_vertices", true, true);
    if (param1_this != nullptr) {
      ((*local_this).offset_vertices)(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "offset_vertices(const Geom self, const GeomVertexData data, int offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_offset_vertices_866_comment =
  "C++ Interface:\n"
  "offset_vertices(const Geom self, const GeomVertexData data, int offset)\n"
  "\n"
  "/**\n"
  " * Replaces a Geom's vertex table with a new table, and simultaneously adds\n"
  " * the indicated offset to all vertex references within the Geom's primitives.\n"
  " * This is intended to be used to combine multiple GeomVertexDatas from\n"
  " * different Geoms into a single big buffer, with each Geom referencing a\n"
  " * subset of the vertices in the buffer.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_offset_vertices_866_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Geom::make_nonindexed(bool composite_only)
 */
static PyObject *Dtool_Geom_make_nonindexed_867(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.make_nonindexed")) {
    return nullptr;
  }
  // 1-int Geom::make_nonindexed(bool composite_only)
  int return_value = ((*local_this).make_nonindexed)((PyObject_IsTrue(arg) != 0));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_nonindexed(const Geom self, bool composite_only)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_make_nonindexed_867_comment =
  "C++ Interface:\n"
  "make_nonindexed(const Geom self, bool composite_only)\n"
  "\n"
  "/**\n"
  " * Converts the geom from indexed to nonindexed by duplicating vertices as\n"
  " * necessary.  If composite_only is true, then only composite primitives such\n"
  " * as trifans and tristrips are converted.  Returns the number of\n"
  " * GeomPrimitive objects converted.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_make_nonindexed_867_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeomVertexData > Geom::get_animated_vertex_data(bool force, Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_Geom_get_animated_vertex_data_868(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeomVertexData > Geom::get_animated_vertex_data(bool force, Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"force", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:get_animated_vertex_data", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "Geom.get_animated_vertex_data", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      ConstPointerTo< GeomVertexData > return_value = ((*(const Geom*)local_this).get_animated_vertex_data)((PyObject_IsTrue(param1) != 0), param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GeomVertexData const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomVertexData, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_animated_vertex_data(Geom self, bool force, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_animated_vertex_data_868_comment =
  "C++ Interface:\n"
  "get_animated_vertex_data(Geom self, bool force, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a GeomVertexData that represents the results of computing the\n"
  " * vertex animation on the CPU for this Geom's vertex data.\n"
  " *\n"
  " * If there is no CPU-defined vertex animation on this object, this just\n"
  " * returns the original object.\n"
  " *\n"
  " * If there is vertex animation, but the VertexTransform values have not\n"
  " * changed since last time, this may return the same pointer it returned\n"
  " * previously.  Even if the VertexTransform values have changed, it may still\n"
  " * return the same pointer, but with its contents modified (this is preferred,\n"
  " * since it allows the graphics backend to update vertex buffers optimally).\n"
  " *\n"
  " * If force is false, this method may return immediately with stale data, if\n"
  " * the vertex data is not completely resident.  If force is true, this method\n"
  " * will never return stale data, but may block until the data is available.\n"
  " */";
#else
static const char *Dtool_Geom_get_animated_vertex_data_868_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Geom::is_empty(void) const
 */
static PyObject *Dtool_Geom_is_empty_869(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline bool Geom::is_empty(void) const
  bool return_value = ((*(const Geom*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Geom_is_empty_869_comment =
  "C++ Interface:\n"
  "is_empty(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns true if there appear to be no vertices to be rendered by this Geom,\n"
  " * false if has some actual data.\n"
  " */";
#else
static const char *Dtool_Geom_is_empty_869_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Geom::get_num_primitives(void) const
 */
static PyObject *Dtool_Geom_get_num_primitives_870(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline std::size_t Geom::get_num_primitives(void) const
  std::size_t return_value = ((*(const Geom*)local_this).get_num_primitives)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_num_primitives_870_comment =
  "C++ Interface:\n"
  "get_num_primitives(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns the number of GeomPrimitive objects stored within the Geom, each of\n"
  " * which represents a number of primitives of a particular type.\n"
  " */";
#else
static const char *Dtool_Geom_get_num_primitives_870_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< GeomPrimitive > Geom::get_primitive(std::size_t i) const
 */
static PyObject *Dtool_Geom_get_primitive_871(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeomPrimitive > Geom::get_primitive(std::size_t i) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConstPointerTo< GeomPrimitive > return_value = ((*(const Geom*)local_this).get_primitive)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GeomPrimitive const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_primitive(Geom self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_primitive_871_comment =
  "C++ Interface:\n"
  "get_primitive(Geom self, int i)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the ith GeomPrimitive object stored within the\n"
  " * Geom.  Use this call only to inspect the ith object; use modify_primitive()\n"
  " * or set_primitive() if you want to modify it.\n"
  " */";
#else
static const char *Dtool_Geom_get_primitive_871_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< GeomPrimitive > Geom::modify_primitive(std::size_t i)
 */
static PyObject *Dtool_Geom_modify_primitive_873(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.modify_primitive")) {
    return nullptr;
  }
  // 1-inline PointerTo< GeomPrimitive > Geom::modify_primitive(std::size_t i)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    PointerTo< GeomPrimitive > return_value = ((*local_this).modify_primitive)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GeomPrimitive *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_primitive(const Geom self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_modify_primitive_873_comment =
  "C++ Interface:\n"
  "modify_primitive(const Geom self, int i)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the ith GeomPrimitive object stored within\n"
  " * the Geom, so application code can directly manipulate the properties of\n"
  " * this primitive.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_modify_primitive_873_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::set_primitive(std::size_t i, GeomPrimitive const *primitive)
 */
static PyObject *Dtool_Geom_set_primitive_874(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.set_primitive")) {
    return nullptr;
  }
  // 1-void Geom::set_primitive(std::size_t i, GeomPrimitive const *primitive)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"i", "primitive", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_primitive", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    GeomPrimitive const *param2_this = (GeomPrimitive *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeomPrimitive, 2, "Geom.set_primitive", true, true);
    if (param2_this != nullptr) {
      ((*local_this).set_primitive)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_primitive(const Geom self, int i, const GeomPrimitive primitive)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_set_primitive_874_comment =
  "C++ Interface:\n"
  "set_primitive(const Geom self, int i, const GeomPrimitive primitive)\n"
  "\n"
  "/**\n"
  " * Replaces the ith GeomPrimitive object stored within the Geom with the new\n"
  " * object.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_set_primitive_874_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::insert_primitive(std::size_t i, GeomPrimitive const *primitive)
 */
static PyObject *Dtool_Geom_insert_primitive_875(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.insert_primitive")) {
    return nullptr;
  }
  // 1-void Geom::insert_primitive(std::size_t i, GeomPrimitive const *primitive)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"i", "primitive", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:insert_primitive", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    GeomPrimitive const *param2_this = (GeomPrimitive *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeomPrimitive, 2, "Geom.insert_primitive", true, true);
    if (param2_this != nullptr) {
      ((*local_this).insert_primitive)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_primitive(const Geom self, int i, const GeomPrimitive primitive)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_insert_primitive_875_comment =
  "C++ Interface:\n"
  "insert_primitive(const Geom self, int i, const GeomPrimitive primitive)\n"
  "\n"
  "/**\n"
  " * Inserts a new GeomPrimitive structure to the Geom object.  This specifies a\n"
  " * particular subset of vertices that are used to define geometric primitives\n"
  " * of the indicated type.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_insert_primitive_875_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Geom::add_primitive(GeomPrimitive const *primitive)
 */
static PyObject *Dtool_Geom_add_primitive_876(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.add_primitive")) {
    return nullptr;
  }
  // 1-inline void Geom::add_primitive(GeomPrimitive const *primitive)
  GeomPrimitive const *arg_this = (GeomPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomPrimitive, 1, "Geom.add_primitive", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_primitive)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_primitive(const Geom self, const GeomPrimitive primitive)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_add_primitive_876_comment =
  "C++ Interface:\n"
  "add_primitive(const Geom self, const GeomPrimitive primitive)\n"
  "\n"
  "/**\n"
  " * Inserts a new GeomPrimitive structure to the Geom object.  This specifies a\n"
  " * particular subset of vertices that are used to define geometric primitives\n"
  " * of the indicated type.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_add_primitive_876_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::remove_primitive(std::size_t i)
 */
static PyObject *Dtool_Geom_remove_primitive_877(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.remove_primitive")) {
    return nullptr;
  }
  // 1-void Geom::remove_primitive(std::size_t i)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).remove_primitive)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_primitive(const Geom self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_remove_primitive_877_comment =
  "C++ Interface:\n"
  "remove_primitive(const Geom self, int i)\n"
  "\n"
  "/**\n"
  " * Removes the ith primitive from the list.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_remove_primitive_877_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::clear_primitives(void)
 */
static PyObject *Dtool_Geom_clear_primitives_878(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.clear_primitives")) {
    return nullptr;
  }
  // 1-void Geom::clear_primitives(void)
  ((*local_this).clear_primitives)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_clear_primitives_878_comment =
  "C++ Interface:\n"
  "clear_primitives(const Geom self)\n"
  "\n"
  "/**\n"
  " * Removes all the primitives from the Geom object (but keeps the same table\n"
  " * of vertices).  You may then re-add primitives one at a time via calls to\n"
  " * add_primitive().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_clear_primitives_878_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Geom > Geom::decompose(void) const
 */
static PyObject *Dtool_Geom_decompose_881(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline PointerTo< Geom > Geom::decompose(void) const
  PointerTo< Geom > return_value = ((*(const Geom*)local_this).decompose)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Geom *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Geom_decompose_881_comment =
  "C++ Interface:\n"
  "decompose(Geom self)\n"
  "\n"
  "/**\n"
  " * Decomposes all of the primitives within this Geom, returning the result.\n"
  " * See GeomPrimitive::decompose().\n"
  " */";
#else
static const char *Dtool_Geom_decompose_881_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Geom > Geom::doubleside(void) const
 */
static PyObject *Dtool_Geom_doubleside_882(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline PointerTo< Geom > Geom::doubleside(void) const
  PointerTo< Geom > return_value = ((*(const Geom*)local_this).doubleside)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Geom *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Geom_doubleside_882_comment =
  "C++ Interface:\n"
  "doubleside(Geom self)\n"
  "\n"
  "/**\n"
  " * Doublesides all of the primitives within this Geom, returning the result.\n"
  " * See GeomPrimitive::doubleside().\n"
  " */";
#else
static const char *Dtool_Geom_doubleside_882_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Geom > Geom::reverse(void) const
 */
static PyObject *Dtool_Geom_reverse_883(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline PointerTo< Geom > Geom::reverse(void) const
  PointerTo< Geom > return_value = ((*(const Geom*)local_this).reverse)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Geom *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Geom_reverse_883_comment =
  "C++ Interface:\n"
  "reverse(Geom self)\n"
  "\n"
  "/**\n"
  " * Reverses all of the primitives within this Geom, returning the result.  See\n"
  " * GeomPrimitive::reverse().\n"
  " */";
#else
static const char *Dtool_Geom_reverse_883_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Geom > Geom::rotate(void) const
 */
static PyObject *Dtool_Geom_rotate_884(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline PointerTo< Geom > Geom::rotate(void) const
  PointerTo< Geom > return_value = ((*(const Geom*)local_this).rotate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Geom *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Geom_rotate_884_comment =
  "C++ Interface:\n"
  "rotate(Geom self)\n"
  "\n"
  "/**\n"
  " * Rotates all of the primitives within this Geom, returning the result.  See\n"
  " * GeomPrimitive::rotate().\n"
  " */";
#else
static const char *Dtool_Geom_rotate_884_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Geom > Geom::unify(int max_indices, bool preserve_order) const
 */
static PyObject *Dtool_Geom_unify_885(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline PointerTo< Geom > Geom::unify(int max_indices, bool preserve_order) const
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"max_indices", "preserve_order", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:unify", (char **)keyword_list, &param1, &param2)) {
    PointerTo< Geom > return_value = ((*(const Geom*)local_this).unify)((int)param1, (PyObject_IsTrue(param2) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    Geom *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unify(Geom self, int max_indices, bool preserve_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_unify_885_comment =
  "C++ Interface:\n"
  "unify(Geom self, int max_indices, bool preserve_order)\n"
  "\n"
  "/**\n"
  " * Unifies all of the primitives contained within this Geom into a single (or\n"
  " * as few as possible, within the constraints of max_indices) primitive\n"
  " * objects.  This may require decomposing the primitives if, for instance, the\n"
  " * Geom contains both triangle strips and triangle fans.\n"
  " *\n"
  " * max_indices represents the maximum number of indices that will be put in\n"
  " * any one GeomPrimitive.  If preserve_order is true, then the primitives will\n"
  " * not be reordered during the operation, even if this results in a suboptimal\n"
  " * result.\n"
  " */";
#else
static const char *Dtool_Geom_unify_885_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Geom > Geom::make_points(void) const
 */
static PyObject *Dtool_Geom_make_points_886(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline PointerTo< Geom > Geom::make_points(void) const
  PointerTo< Geom > return_value = ((*(const Geom*)local_this).make_points)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Geom *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Geom_make_points_886_comment =
  "C++ Interface:\n"
  "make_points(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns a new Geom with points at all the vertices.  See\n"
  " * GeomPrimitive::make_points().\n"
  " */";
#else
static const char *Dtool_Geom_make_points_886_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Geom > Geom::make_lines(void) const
 */
static PyObject *Dtool_Geom_make_lines_887(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline PointerTo< Geom > Geom::make_lines(void) const
  PointerTo< Geom > return_value = ((*(const Geom*)local_this).make_lines)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Geom *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Geom_make_lines_887_comment =
  "C++ Interface:\n"
  "make_lines(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns a new Geom with lines at all the edges.  See\n"
  " * GeomPrimitive::make_lines().\n"
  " */";
#else
static const char *Dtool_Geom_make_lines_887_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Geom > Geom::make_patches(void) const
 */
static PyObject *Dtool_Geom_make_patches_888(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline PointerTo< Geom > Geom::make_patches(void) const
  PointerTo< Geom > return_value = ((*(const Geom*)local_this).make_patches)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Geom *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Geom_make_patches_888_comment =
  "C++ Interface:\n"
  "make_patches(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns a new Geom with each primitive converted into a patch.  Calls\n"
  " * decompose() first.\n"
  " */";
#else
static const char *Dtool_Geom_make_patches_888_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Geom > Geom::make_adjacency(void) const
 */
static PyObject *Dtool_Geom_make_adjacency_889(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline PointerTo< Geom > Geom::make_adjacency(void) const
  PointerTo< Geom > return_value = ((*(const Geom*)local_this).make_adjacency)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Geom *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Geom_make_adjacency_889_comment =
  "C++ Interface:\n"
  "make_adjacency(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns a new Geom with each primitive converted into a corresponding\n"
  " * version with adjacency information.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_Geom_make_adjacency_889_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::decompose_in_place(void)
 */
static PyObject *Dtool_Geom_decompose_in_place_890(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.decompose_in_place")) {
    return nullptr;
  }
  // 1-void Geom::decompose_in_place(void)
  ((*local_this).decompose_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_decompose_in_place_890_comment =
  "C++ Interface:\n"
  "decompose_in_place(const Geom self)\n"
  "\n"
  "/**\n"
  " * Decomposes all of the primitives within this Geom, leaving the results in\n"
  " * place.  See GeomPrimitive::decompose().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_decompose_in_place_890_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::doubleside_in_place(void)
 */
static PyObject *Dtool_Geom_doubleside_in_place_891(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.doubleside_in_place")) {
    return nullptr;
  }
  // 1-void Geom::doubleside_in_place(void)
  ((*local_this).doubleside_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_doubleside_in_place_891_comment =
  "C++ Interface:\n"
  "doubleside_in_place(const Geom self)\n"
  "\n"
  "/**\n"
  " * Doublesides all of the primitives within this Geom, leaving the results in\n"
  " * place.  See GeomPrimitive::doubleside().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_doubleside_in_place_891_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::reverse_in_place(void)
 */
static PyObject *Dtool_Geom_reverse_in_place_892(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.reverse_in_place")) {
    return nullptr;
  }
  // 1-void Geom::reverse_in_place(void)
  ((*local_this).reverse_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_reverse_in_place_892_comment =
  "C++ Interface:\n"
  "reverse_in_place(const Geom self)\n"
  "\n"
  "/**\n"
  " * Reverses all of the primitives within this Geom, leaving the results in\n"
  " * place.  See GeomPrimitive::reverse().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_reverse_in_place_892_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::rotate_in_place(void)
 */
static PyObject *Dtool_Geom_rotate_in_place_893(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.rotate_in_place")) {
    return nullptr;
  }
  // 1-void Geom::rotate_in_place(void)
  ((*local_this).rotate_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_rotate_in_place_893_comment =
  "C++ Interface:\n"
  "rotate_in_place(const Geom self)\n"
  "\n"
  "/**\n"
  " * Rotates all of the primitives within this Geom, leaving the results in\n"
  " * place.  See GeomPrimitive::rotate().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_rotate_in_place_893_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::unify_in_place(int max_indices, bool preserve_order)
 */
static PyObject *Dtool_Geom_unify_in_place_894(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.unify_in_place")) {
    return nullptr;
  }
  // 1-void Geom::unify_in_place(int max_indices, bool preserve_order)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"max_indices", "preserve_order", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:unify_in_place", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).unify_in_place)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unify_in_place(const Geom self, int max_indices, bool preserve_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_unify_in_place_894_comment =
  "C++ Interface:\n"
  "unify_in_place(const Geom self, int max_indices, bool preserve_order)\n"
  "\n"
  "/**\n"
  " * Unifies all of the primitives contained within this Geom into a single (or\n"
  " * as few as possible, within the constraints of max_indices) primitive\n"
  " * objects.  This may require decomposing the primitives if, for instance, the\n"
  " * Geom contains both triangle strips and triangle fans.\n"
  " *\n"
  " * max_indices represents the maximum number of indices that will be put in\n"
  " * any one GeomPrimitive.  If preserve_order is true, then the primitives will\n"
  " * not be reordered during the operation, even if this results in a suboptimal\n"
  " * result.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_unify_in_place_894_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::make_points_in_place(void)
 */
static PyObject *Dtool_Geom_make_points_in_place_895(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.make_points_in_place")) {
    return nullptr;
  }
  // 1-void Geom::make_points_in_place(void)
  ((*local_this).make_points_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_make_points_in_place_895_comment =
  "C++ Interface:\n"
  "make_points_in_place(const Geom self)\n"
  "\n"
  "/**\n"
  " * Replaces the GeomPrimitives within this Geom with corresponding GeomPoints.\n"
  " * See GeomPrimitive::make_points().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_make_points_in_place_895_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::make_lines_in_place(void)
 */
static PyObject *Dtool_Geom_make_lines_in_place_896(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.make_lines_in_place")) {
    return nullptr;
  }
  // 1-void Geom::make_lines_in_place(void)
  ((*local_this).make_lines_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_make_lines_in_place_896_comment =
  "C++ Interface:\n"
  "make_lines_in_place(const Geom self)\n"
  "\n"
  "/**\n"
  " * Replaces the GeomPrimitives within this Geom with corresponding GeomLines,\n"
  " * representing a wireframe of the primitives.  See\n"
  " * GeomPrimitive::make_lines().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_make_lines_in_place_896_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::make_patches_in_place(void)
 */
static PyObject *Dtool_Geom_make_patches_in_place_897(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.make_patches_in_place")) {
    return nullptr;
  }
  // 1-void Geom::make_patches_in_place(void)
  ((*local_this).make_patches_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_make_patches_in_place_897_comment =
  "C++ Interface:\n"
  "make_patches_in_place(const Geom self)\n"
  "\n"
  "/**\n"
  " * Replaces the GeomPrimitives within this Geom with corresponding\n"
  " * GeomPatches.  See GeomPrimitive::make_patches().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_make_patches_in_place_897_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::make_adjacency_in_place(void)
 */
static PyObject *Dtool_Geom_make_adjacency_in_place_898(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.make_adjacency_in_place")) {
    return nullptr;
  }
  // 1-void Geom::make_adjacency_in_place(void)
  ((*local_this).make_adjacency_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_make_adjacency_in_place_898_comment =
  "C++ Interface:\n"
  "make_adjacency_in_place(const Geom self)\n"
  "\n"
  "/**\n"
  " * Replaces the GeomPrimitives within this Geom with corresponding versions\n"
  " * with adjacency information.  See GeomPrimitive::make_adjacency().\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_Geom_make_adjacency_in_place_898_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool Geom::copy_primitives_from(Geom const *other)
 */
static PyObject *Dtool_Geom_copy_primitives_from_899(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.copy_primitives_from")) {
    return nullptr;
  }
  // 1-virtual bool Geom::copy_primitives_from(Geom const *other)
  Geom const *arg_this = (Geom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Geom, 1, "Geom.copy_primitives_from", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).copy_primitives_from)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_primitives_from(const Geom self, const Geom other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_copy_primitives_from_899_comment =
  "C++ Interface:\n"
  "copy_primitives_from(const Geom self, const Geom other)\n"
  "\n"
  "/**\n"
  " * Copies the primitives from the indicated Geom into this one.  This does\n"
  " * require that both Geoms contain the same fundamental type primitives, both\n"
  " * have a compatible shade model, and both use the same GeomVertexData.  Both\n"
  " * Geoms must also be the same specific class type (i.e.  if one is a\n"
  " * GeomTextGlyph, they both must be.)\n"
  " *\n"
  " * Returns true if the copy is successful, or false otherwise (because the\n"
  " * Geoms were mismatched).\n"
  " */";
#else
static const char *Dtool_Geom_copy_primitives_from_899_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Geom::get_num_bytes(void) const
 */
static PyObject *Dtool_Geom_get_num_bytes_900(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-int Geom::get_num_bytes(void) const
  int return_value = ((*(const Geom*)local_this).get_num_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_num_bytes_900_comment =
  "C++ Interface:\n"
  "get_num_bytes(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes consumed by the geom and its primitives (but\n"
  " * not including its vertex table).\n"
  " */";
#else
static const char *Dtool_Geom_get_num_bytes_900_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq Geom::get_modified(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_Geom_get_modified_901(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline UpdateSeq Geom::get_modified(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "Geom.get_modified", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      UpdateSeq *return_value = new UpdateSeq(((*(const Geom*)local_this).get_modified)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_modified(Geom self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_modified_901_comment =
  "C++ Interface:\n"
  "get_modified(Geom self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number which is guaranteed to change at least every time\n"
  " * any of the primitives in the Geom is modified, or the set of primitives is\n"
  " * modified.  However, this does not include modifications to the vertex data,\n"
  " * which should be tested separately.\n"
  " */";
#else
static const char *Dtool_Geom_get_modified_901_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Geom::request_resident(void) const
 */
static PyObject *Dtool_Geom_request_resident_904(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-bool Geom::request_resident(void) const
  bool return_value = ((*(const Geom*)local_this).request_resident)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Geom_request_resident_904_comment =
  "C++ Interface:\n"
  "request_resident(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns true if all the primitive arrays are currently resident in memory.\n"
  " * If this returns false, the data will be brought back into memory shortly;\n"
  " * try again later.\n"
  " *\n"
  " * This does not also test the Geom's associated GeomVertexData.  That must be\n"
  " * tested separately.\n"
  " */";
#else
static const char *Dtool_Geom_request_resident_904_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::transform_vertices(LMatrix4 const &mat)
 */
static PyObject *Dtool_Geom_transform_vertices_905(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.transform_vertices")) {
    return nullptr;
  }
  // 1-void Geom::transform_vertices(LMatrix4 const &mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Geom.transform_vertices", "LMatrix4f");
  }
  ((*local_this).transform_vertices)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform_vertices(const Geom self, const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_transform_vertices_905_comment =
  "C++ Interface:\n"
  "transform_vertices(const Geom self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transform to all of the vertices in the Geom.  If the\n"
  " * Geom happens to share a vertex table with another Geom, this operation will\n"
  " * duplicate the vertex table instead of breaking the other Geom; however, if\n"
  " * multiple Geoms with shared tables are transformed by the same matrix, they\n"
  " * will no longer share tables after the operation.  Consider using the\n"
  " * GeomTransformer if you will be applying the same transform to multiple\n"
  " * Geoms.\n"
  " */";
#else
static const char *Dtool_Geom_transform_vertices_905_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Geom::check_valid(void) const
 * bool Geom::check_valid(GeomVertexData const *vertex_data) const
 */
static PyObject *Dtool_Geom_check_valid_906(PyObject *self, PyObject *args) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-bool Geom::check_valid(void) const
      bool return_value = ((*(const Geom*)local_this).check_valid)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool Geom::check_valid(GeomVertexData const *vertex_data) const
      GeomVertexData const *arg_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexData, 1, "Geom.check_valid", true, true);
      if (arg_this != nullptr) {
        bool return_value = ((*(const Geom*)local_this).check_valid)(arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "check_valid() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "check_valid(Geom self)\n"
      "check_valid(Geom self, const GeomVertexData vertex_data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_check_valid_906_comment =
  "C++ Interface:\n"
  "check_valid(Geom self)\n"
  "check_valid(Geom self, const GeomVertexData vertex_data)\n"
  "\n"
  "/**\n"
  " * Verifies that the all of the primitives within the geom reference vertices\n"
  " * that actually exist within the geom's GeomVertexData.  Returns true if the\n"
  " * geom appears to be valid, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Verifies that the all of the primitives within the geom reference vertices\n"
  " * that actually exist within the indicated GeomVertexData.  Returns true if\n"
  " * the geom appears to be valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_Geom_check_valid_906_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< BoundingVolume > Geom::get_bounds(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_Geom_get_bounds_907(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-ConstPointerTo< BoundingVolume > Geom::get_bounds(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "Geom.get_bounds", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ConstPointerTo< BoundingVolume > return_value = ((*(const Geom*)local_this).get_bounds)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      BoundingVolume const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bounds(Geom self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_bounds_907_comment =
  "C++ Interface:\n"
  "get_bounds(Geom self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the bounding volume for the Geom.\n"
  " */";
#else
static const char *Dtool_Geom_get_bounds_907_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Geom::get_nested_vertices(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_Geom_get_nested_vertices_908(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-int Geom::get_nested_vertices(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "Geom.get_nested_vertices", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*(const Geom*)local_this).get_nested_vertices)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_nested_vertices(Geom self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_nested_vertices_908_comment =
  "C++ Interface:\n"
  "get_nested_vertices(Geom self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices rendered by all primitives within the Geom.\n"
  " */";
#else
static const char *Dtool_Geom_get_nested_vertices_908_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Geom::mark_bounds_stale(void) const
 */
static PyObject *Dtool_Geom_mark_bounds_stale_909(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline void Geom::mark_bounds_stale(void) const
  ((*(const Geom*)local_this).mark_bounds_stale)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_mark_bounds_stale_909_comment =
  "C++ Interface:\n"
  "mark_bounds_stale(Geom self)\n"
  "\n"
  "/**\n"
  " * Marks the bounding volume of the Geom as stale so that it should be\n"
  " * recomputed.  Usually it is not necessary to call this explicitly.\n"
  " */";
#else
static const char *Dtool_Geom_mark_bounds_stale_909_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Geom::set_bounds_type(BoundingVolume::BoundsType bounds_type)
 */
static PyObject *Dtool_Geom_set_bounds_type_910(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.set_bounds_type")) {
    return nullptr;
  }
  // 1-inline void Geom::set_bounds_type(BoundingVolume::BoundsType bounds_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_bounds_type)((BoundingVolume::BoundsType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bounds_type(const Geom self, int bounds_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_set_bounds_type_910_comment =
  "C++ Interface:\n"
  "set_bounds_type(const Geom self, int bounds_type)\n"
  "\n"
  "/**\n"
  " * Specifies the desired type of bounding volume that will be created for this\n"
  " * Geom.  This is normally BoundingVolume::BT_default, which means to set the\n"
  " * type according to the config variable \"bounds-type\".\n"
  " *\n"
  " * If this is BT_sphere or BT_box, a BoundingSphere or BoundingBox is\n"
  " * explicitly created.  If it is BT_best, a BoundingBox is created.\n"
  " *\n"
  " * This affects the implicit bounding volume only.  If an explicit bounding\n"
  " * volume is set on the Geom with set_bounds(), that bounding volume type is\n"
  " * used.  (This is different behavior from the similar method on PandaNode.)\n"
  " */";
#else
static const char *Dtool_Geom_set_bounds_type_910_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BoundingVolume::BoundsType Geom::get_bounds_type(void) const
 */
static PyObject *Dtool_Geom_get_bounds_type_911(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-inline BoundingVolume::BoundsType Geom::get_bounds_type(void) const
  BoundingVolume::BoundsType return_value = ((*(const Geom*)local_this).get_bounds_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_bounds_type_911_comment =
  "C++ Interface:\n"
  "get_bounds_type(Geom self)\n"
  "\n"
  "/**\n"
  " * Returns the bounding volume type set with set_bounds_type().\n"
  " */";
#else
static const char *Dtool_Geom_get_bounds_type_911_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Geom::set_bounds(BoundingVolume const *volume)
 */
static PyObject *Dtool_Geom_set_bounds_912(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.set_bounds")) {
    return nullptr;
  }
  // 1-inline void Geom::set_bounds(BoundingVolume const *volume)
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "Geom.set_bounds", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_bounds)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bounds(const Geom self, const BoundingVolume volume)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_set_bounds_912_comment =
  "C++ Interface:\n"
  "set_bounds(const Geom self, const BoundingVolume volume)\n"
  "\n"
  "/**\n"
  " * Resets the bounding volume so that it is the indicated volume.  When it is\n"
  " * explicitly set, the bounding volume will no longer be automatically\n"
  " * computed; call clear_bounds() if you would like to return the bounding\n"
  " * volume to its default behavior.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_set_bounds_912_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Geom::clear_bounds(void)
 */
static PyObject *Dtool_Geom_clear_bounds_913(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.clear_bounds")) {
    return nullptr;
  }
  // 1-inline void Geom::clear_bounds(void)
  ((*local_this).clear_bounds)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_clear_bounds_913_comment =
  "C++ Interface:\n"
  "clear_bounds(const Geom self)\n"
  "\n"
  "/**\n"
  " * Reverses the effect of a previous call to set_bounds(), and allows the\n"
  " * bounding volume to be automatically computed once more based on the\n"
  " * vertices.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_clear_bounds_913_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Geom::output(std::ostream &out) const
 */
static PyObject *Dtool_Geom_output_917(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-virtual void Geom::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Geom.output", false, true);
  if (arg_this != nullptr) {
    ((*(const Geom*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Geom self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_output_917_comment =
  "C++ Interface:\n"
  "output(Geom self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Geom_output_917_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Geom::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_Geom_write_918(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-virtual void Geom::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Geom.write", false, true);
    if (param1_this != nullptr) {
      ((*(const Geom*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(Geom self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_write_918_comment =
  "C++ Interface:\n"
  "write(Geom self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Geom_write_918_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::clear_cache(void)
 */
static PyObject *Dtool_Geom_clear_cache_919(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.clear_cache")) {
    return nullptr;
  }
  // 1-void Geom::clear_cache(void)
  ((*local_this).clear_cache)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Geom_clear_cache_919_comment =
  "C++ Interface:\n"
  "clear_cache(const Geom self)\n"
  "\n"
  "/**\n"
  " * Removes all of the previously-cached results of munge_geom().\n"
  " *\n"
  " * This blows away the entire cache, upstream and downstream the pipeline.\n"
  " * Use clear_cache_stage() instead if you only want to blow away the cache at\n"
  " * the current stage and upstream.\n"
  " */";
#else
static const char *Dtool_Geom_clear_cache_919_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::clear_cache_stage(Thread *current_thread)
 */
static PyObject *Dtool_Geom_clear_cache_stage_920(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.clear_cache_stage")) {
    return nullptr;
  }
  // 1-void Geom::clear_cache_stage(Thread *current_thread)
  Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "Geom.clear_cache_stage", false, true);
  if (arg_this != nullptr) {
    ((*local_this).clear_cache_stage)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_cache_stage(const Geom self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_clear_cache_stage_920_comment =
  "C++ Interface:\n"
  "clear_cache_stage(const Geom self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Removes all of the previously-cached results of munge_geom(), at the\n"
  " * current pipeline stage and upstream.  Does not affect the downstream cache.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_Geom_clear_cache_stage_920_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Geom::prepare(PreparedGraphicsObjects *prepared_objects)
 */
static PyObject *Dtool_Geom_prepare_921(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.prepare")) {
    return nullptr;
  }
  // 1-void Geom::prepare(PreparedGraphicsObjects *prepared_objects)
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Geom.prepare", false, true);
  if (arg_this != nullptr) {
    ((*local_this).prepare)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare(const Geom self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_prepare_921_comment =
  "C++ Interface:\n"
  "prepare(const Geom self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Indicates that the geom should be enqueued to be prepared in the indicated\n"
  " * prepared_objects at the beginning of the next frame.  This will ensure the\n"
  " * geom is already loaded into geom memory if it is expected to be rendered\n"
  " * soon.\n"
  " *\n"
  " * Use this function instead of prepare_now() to preload geoms from a user\n"
  " * interface standpoint.\n"
  " */";
#else
static const char *Dtool_Geom_prepare_921_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Geom::is_prepared(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_Geom_is_prepared_922(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Geom)) {
    return nullptr;
  }
  // 1-bool Geom::is_prepared(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Geom.is_prepared", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const Geom*)local_this).is_prepared)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_prepared(Geom self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_is_prepared_922_comment =
  "C++ Interface:\n"
  "is_prepared(Geom self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Returns true if the geom has already been prepared or enqueued for\n"
  " * preparation on the indicated GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_Geom_is_prepared_922_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Geom::release(PreparedGraphicsObjects *prepared_objects)
 */
static PyObject *Dtool_Geom_release_923(PyObject *self, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.release")) {
    return nullptr;
  }
  // 1-bool Geom::release(PreparedGraphicsObjects *prepared_objects)
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Geom.release", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).release)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release(const Geom self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_release_923_comment =
  "C++ Interface:\n"
  "release(const Geom self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Frees the geom context only on the indicated object, if it exists there.\n"
  " * Returns true if it was released, false if it had not been prepared.\n"
  " */";
#else
static const char *Dtool_Geom_release_923_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Geom::release_all(void)
 */
static PyObject *Dtool_Geom_release_all_924(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.release_all")) {
    return nullptr;
  }
  // 1-int Geom::release_all(void)
  int return_value = ((*local_this).release_all)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Geom_release_all_924_comment =
  "C++ Interface:\n"
  "release_all(const Geom self)\n"
  "\n"
  "/**\n"
  " * Frees the context allocated on all objects for which the geom has been\n"
  " * declared.  Returns the number of contexts which have been freed.\n"
  " */";
#else
static const char *Dtool_Geom_release_all_924_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomContext *Geom::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_Geom_prepare_now_925(PyObject *self, PyObject *args, PyObject *kwds) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.prepare_now")) {
    return nullptr;
  }
  // 1-GeomContext *Geom::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"prepared_objects", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:prepare_now", (char **)keyword_list, &param1, &param2)) {
    PreparedGraphicsObjects *param1_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PreparedGraphicsObjects, 1, "Geom.prepare_now", false, true);
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "Geom.prepare_now", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      GeomContext *return_value = ((*local_this).prepare_now)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_now(const Geom self, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Geom_prepare_now_925_comment =
  "C++ Interface:\n"
  "prepare_now(const Geom self, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Creates a context for the geom on the particular GSG, if it does not\n"
  " * already exist.  Returns the new (or old) GeomContext.  This assumes that\n"
  " * the GraphicsStateGuardian is the currently active rendering context and\n"
  " * that it is ready to accept new geoms.  If this is not necessarily the case,\n"
  " * you should use prepare() instead.\n"
  " *\n"
  " * Normally, this is not called directly except by the GraphicsStateGuardian;\n"
  " * a geom does not need to be explicitly prepared by the user before it may be\n"
  " * rendered.\n"
  " */";
#else
static const char *Dtool_Geom_prepare_now_925_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Geom::get_class_type(void)
 */
static PyObject *Dtool_Geom_get_class_type_926(PyObject *, PyObject *) {
  // 1-static TypeHandle Geom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Geom::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Geom_get_class_type_926_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Geom_get_class_type_926_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CopyOnWriteObject *Geom::upcast_to_CopyOnWriteObject(void)
 */
static PyObject *Dtool_Geom_upcast_to_CopyOnWriteObject_844(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.upcast_to_CopyOnWriteObject")) {
    return nullptr;
  }
  // 1-CopyOnWriteObject *Geom::upcast_to_CopyOnWriteObject(void)
  CopyOnWriteObject *return_value = (CopyOnWriteObject *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CopyOnWriteObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Geom_upcast_to_CopyOnWriteObject_844_comment =
  "C++ Interface:\n"
  "upcast_to_CopyOnWriteObject(const Geom self)\n"
  "\n"
  "upcast from Geom to CopyOnWriteObject";
#else
static const char *Dtool_Geom_upcast_to_CopyOnWriteObject_844_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomEnums *Geom::upcast_to_GeomEnums(void)
 */
static PyObject *Dtool_Geom_upcast_to_GeomEnums_846(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.upcast_to_GeomEnums")) {
    return nullptr;
  }
  // 1-GeomEnums *Geom::upcast_to_GeomEnums(void)
  GeomEnums *return_value = (GeomEnums *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomEnums, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Geom_upcast_to_GeomEnums_846_comment =
  "C++ Interface:\n"
  "upcast_to_GeomEnums(const Geom self)\n"
  "\n"
  "upcast from Geom to GeomEnums";
#else
static const char *Dtool_Geom_upcast_to_GeomEnums_846_comment = nullptr;
#endif

static PyObject *Dtool_Geom_primitive_type_Getter(PyObject *self, void *) {
  const Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Geom, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::PrimitiveType Geom::get_primitive_type(void) const
  GeomEnums::PrimitiveType return_value = ((*(const Geom*)local_this).get_primitive_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Geom_shade_model_Getter(PyObject *self, void *) {
  const Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Geom, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::ShadeModel Geom::get_shade_model(void) const
  GeomEnums::ShadeModel return_value = ((*(const Geom*)local_this).get_shade_model)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Geom_geom_rendering_Getter(PyObject *self, void *) {
  const Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Geom, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Geom::get_geom_rendering(void) const
  int return_value = ((*(const Geom*)local_this).get_geom_rendering)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property Geom::primitives
 */
static Py_ssize_t Dtool_Geom_primitives_Len(PyObject *self) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Geom, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_primitives)();
}

/**
 * sequence getter for property Geom::primitives
 */
static PyObject *Dtool_Geom_primitives_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Geom, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_primitives)()) {
    PyErr_SetString(PyExc_IndexError, "Geom.primitives[] index out of range");
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeomPrimitive > Geom::get_primitive(std::size_t i) const
  ConstPointerTo< GeomPrimitive > return_value = ((*(const Geom*)local_this).get_primitive)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  GeomPrimitive const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomPrimitive, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_primitive(Geom self, index)\n");
  }
}

static int Dtool_Geom_primitives_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.primitives")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_primitives)()) {
    PyErr_SetString(PyExc_IndexError, "Geom.primitives[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    local_this->remove_primitive(index);
    return 0;
  }
  // 1-void Geom::set_primitive(std::size_t i, GeomPrimitive const *primitive)
  GeomPrimitive const *arg_this = (GeomPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomPrimitive, 2, "Geom.set_primitive", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_primitive)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_primitive(const Geom self, index, const GeomPrimitive primitive)\n");
  }
  return -1;
}

static PyObject *Dtool_Geom_primitives_Sequence_insert(PyObject *self, size_t index, PyObject *arg) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.primitives")) {
    return nullptr;
  }

  // 1-void Geom::insert_primitive(std::size_t i, GeomPrimitive const *primitive)
  GeomPrimitive const *arg_this = (GeomPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomPrimitive, 2, "Geom.insert_primitive", true, true);
  if (arg_this != nullptr) {
    ((*local_this).insert_primitive)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "insert_primitive(const Geom self, index, const GeomPrimitive primitive)\n");
  }
  return nullptr;
}

static PyObject *Dtool_Geom_primitives_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "Geom.primitives");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_Geom_primitives_Len;
    wrap->_getitem_func = &Dtool_Geom_primitives_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_Geom_primitives_Sequence_Setitem;
      wrap->_insert_func = &Dtool_Geom_primitives_Sequence_insert;
    }
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_Geom_num_bytes_Getter(PyObject *self, void *) {
  const Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Geom, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int Geom::get_num_bytes(void) const
  int return_value = ((*(const Geom*)local_this).get_num_bytes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Geom_modified_Getter(PyObject *self, void *) {
  const Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Geom, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq Geom::get_modified(Thread *current_thread) const
  UpdateSeq *return_value = new UpdateSeq(((*(const Geom*)local_this).get_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

static PyObject *Dtool_Geom_bounds_type_Getter(PyObject *self, void *) {
  const Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Geom, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline BoundingVolume::BoundsType Geom::get_bounds_type(void) const
  BoundingVolume::BoundsType return_value = ((*(const Geom*)local_this).get_bounds_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Geom_bounds_type_Setter(PyObject *self, PyObject *arg, void *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Geom, (void **)&local_this, "Geom.bounds_type")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bounds_type attribute");
    return -1;
  }
  // 1-inline void Geom::set_bounds_type(BoundingVolume::BoundsType bounds_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_bounds_type)((BoundingVolume::BoundsType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bounds_type(const Geom self, int bounds_type)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit Geom::Geom(GeomVertexData const *data)
 */
static int Dtool_Init_Geom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Geom() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
    // 1-explicit Geom::Geom(GeomVertexData const *data)
    GeomVertexData const *arg_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexData, 0, "Geom.Geom", true, true);
    if (arg_this != nullptr) {
      Geom *return_value = new Geom(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Geom, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Geom(const GeomVertexData data)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Geom_get_primitives(PyObject *self, PyObject *) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Geom, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_primitives)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Geom_get_primitive_871(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Geom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Geom) {
    printf("Geom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Geom *local_this = (Geom *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Geom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Geom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Geom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (Geom*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (Geom*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (Geom*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Geom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Geom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Geom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Geom*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomContext
 */
/**
 * Python function wrapper for:
 * inline Geom *GeomContext::get_geom(void) const
 */
static PyObject *Dtool_GeomContext_get_geom_928(PyObject *self, PyObject *) {
  GeomContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomContext)) {
    return nullptr;
  }
  // 1-inline Geom *GeomContext::get_geom(void) const
  Geom *return_value = ((*(const GeomContext*)local_this).get_geom)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Geom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomContext_get_geom_928_comment =
  "C++ Interface:\n"
  "get_geom(GeomContext self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomContext_get_geom_928_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeomContext::get_class_type(void)
 */
static PyObject *Dtool_GeomContext_get_class_type_931(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomContext::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomContext::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomContext_get_class_type_931_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomContext_get_class_type_931_comment = nullptr;
#endif

static PyObject *Dtool_GeomContext_geom_Getter(PyObject *self, void *) {
  const GeomContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomContext, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Geom *GeomContext::get_geom(void) const
  Geom *return_value = ((*(const GeomContext*)local_this).get_geom)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Geom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Init_GeomContext(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GeomContext(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomContext) {
    printf("GeomContext ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomContext *local_this = (GeomContext *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomContext) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_SavedContext) {
    return (SavedContext *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(SavedContext *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomContext(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomContext) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_SavedContext) {
    SavedContext* other_this = (SavedContext*)from_this;
    return (GeomContext*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomContext*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomLines
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomLines::get_class_type(void)
 */
static PyObject *Dtool_GeomLines_get_class_type_938(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomLines::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomLines::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomLines_get_class_type_938_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomLines_get_class_type_938_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit GeomLines::GeomLines(GeomEnums::UsageHint usage_hint)
 * GeomLines::GeomLines(GeomLines const &copy)
 */
static int Dtool_Init_GeomLines(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeomLines() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 GeomLines::GeomLines(GeomLines const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      GeomLines const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomLines);
      if (param0_this != nullptr) {
        GeomLines *return_value = new GeomLines(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomLines, true, false);
      }
    }
  }

  {
    // -2 explicit GeomLines::GeomLines(GeomEnums::UsageHint usage_hint)
    int param0;
    static const char *keyword_list[] = {"usage_hint", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i:GeomLines", (char **)keyword_list, &param0)) {
      GeomLines *return_value = new GeomLines((GeomEnums::UsageHint)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomLines, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: GeomLines::GeomLines(GeomLines const &copy)
  // No coercion possible: explicit GeomLines::GeomLines(GeomEnums::UsageHint usage_hint)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomLines(const GeomLines copy)\n"
      "GeomLines(int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomLines(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomLines) {
    printf("GeomLines ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomLines *local_this = (GeomLines *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomLines) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomPrimitive) {
    return (GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomLines(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomLines) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomLines*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomLines*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomLines*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    GeomPrimitive* other_this = (GeomPrimitive*)from_this;
    return (GeomLines*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomLines*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomLines*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomLines*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomLines*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomLinesAdjacency
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomLinesAdjacency::get_class_type(void)
 */
static PyObject *Dtool_GeomLinesAdjacency_get_class_type_944(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomLinesAdjacency::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomLinesAdjacency::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomLinesAdjacency_get_class_type_944_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomLinesAdjacency_get_class_type_944_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit GeomLinesAdjacency::GeomLinesAdjacency(GeomEnums::UsageHint usage_hint)
 * GeomLinesAdjacency::GeomLinesAdjacency(GeomLinesAdjacency const &copy)
 */
static int Dtool_Init_GeomLinesAdjacency(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeomLinesAdjacency() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 GeomLinesAdjacency::GeomLinesAdjacency(GeomLinesAdjacency const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      GeomLinesAdjacency const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomLinesAdjacency);
      if (param0_this != nullptr) {
        GeomLinesAdjacency *return_value = new GeomLinesAdjacency(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomLinesAdjacency, true, false);
      }
    }
  }

  {
    // -2 explicit GeomLinesAdjacency::GeomLinesAdjacency(GeomEnums::UsageHint usage_hint)
    int param0;
    static const char *keyword_list[] = {"usage_hint", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i:GeomLinesAdjacency", (char **)keyword_list, &param0)) {
      GeomLinesAdjacency *return_value = new GeomLinesAdjacency((GeomEnums::UsageHint)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomLinesAdjacency, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: GeomLinesAdjacency::GeomLinesAdjacency(GeomLinesAdjacency const &copy)
  // No coercion possible: explicit GeomLinesAdjacency::GeomLinesAdjacency(GeomEnums::UsageHint usage_hint)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomLinesAdjacency(const GeomLinesAdjacency copy)\n"
      "GeomLinesAdjacency(int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomLinesAdjacency(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomLinesAdjacency) {
    printf("GeomLinesAdjacency ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomLinesAdjacency *local_this = (GeomLinesAdjacency *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomLinesAdjacency) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomPrimitive) {
    return (GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomLinesAdjacency(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomLinesAdjacency) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomLinesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomLinesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomLinesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    GeomPrimitive* other_this = (GeomPrimitive*)from_this;
    return (GeomLinesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomLinesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomLinesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomLinesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomLinesAdjacency*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomLinestrips
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomLinestrips::get_class_type(void)
 */
static PyObject *Dtool_GeomLinestrips_get_class_type_950(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomLinestrips::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomLinestrips::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomLinestrips_get_class_type_950_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomLinestrips_get_class_type_950_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit GeomLinestrips::GeomLinestrips(GeomEnums::UsageHint usage_hint)
 * GeomLinestrips::GeomLinestrips(GeomLinestrips const &copy)
 */
static int Dtool_Init_GeomLinestrips(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeomLinestrips() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 GeomLinestrips::GeomLinestrips(GeomLinestrips const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      GeomLinestrips const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomLinestrips);
      if (param0_this != nullptr) {
        GeomLinestrips *return_value = new GeomLinestrips(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomLinestrips, true, false);
      }
    }
  }

  {
    // -2 explicit GeomLinestrips::GeomLinestrips(GeomEnums::UsageHint usage_hint)
    int param0;
    static const char *keyword_list[] = {"usage_hint", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i:GeomLinestrips", (char **)keyword_list, &param0)) {
      GeomLinestrips *return_value = new GeomLinestrips((GeomEnums::UsageHint)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomLinestrips, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: GeomLinestrips::GeomLinestrips(GeomLinestrips const &copy)
  // No coercion possible: explicit GeomLinestrips::GeomLinestrips(GeomEnums::UsageHint usage_hint)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomLinestrips(const GeomLinestrips copy)\n"
      "GeomLinestrips(int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomLinestrips(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomLinestrips) {
    printf("GeomLinestrips ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomLinestrips *local_this = (GeomLinestrips *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomLinestrips) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomPrimitive) {
    return (GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomLinestrips(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomLinestrips) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomLinestrips*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomLinestrips*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomLinestrips*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    GeomPrimitive* other_this = (GeomPrimitive*)from_this;
    return (GeomLinestrips*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomLinestrips*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomLinestrips*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomLinestrips*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomLinestrips*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomLinestripsAdjacency
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomLinestripsAdjacency::get_class_type(void)
 */
static PyObject *Dtool_GeomLinestripsAdjacency_get_class_type_956(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomLinestripsAdjacency::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomLinestripsAdjacency::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomLinestripsAdjacency_get_class_type_956_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomLinestripsAdjacency_get_class_type_956_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit GeomLinestripsAdjacency::GeomLinestripsAdjacency(GeomEnums::UsageHint usage_hint)
 * GeomLinestripsAdjacency::GeomLinestripsAdjacency(GeomLinestripsAdjacency const &copy)
 */
static int Dtool_Init_GeomLinestripsAdjacency(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeomLinestripsAdjacency() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 GeomLinestripsAdjacency::GeomLinestripsAdjacency(GeomLinestripsAdjacency const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      GeomLinestripsAdjacency const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomLinestripsAdjacency);
      if (param0_this != nullptr) {
        GeomLinestripsAdjacency *return_value = new GeomLinestripsAdjacency(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomLinestripsAdjacency, true, false);
      }
    }
  }

  {
    // -2 explicit GeomLinestripsAdjacency::GeomLinestripsAdjacency(GeomEnums::UsageHint usage_hint)
    int param0;
    static const char *keyword_list[] = {"usage_hint", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i:GeomLinestripsAdjacency", (char **)keyword_list, &param0)) {
      GeomLinestripsAdjacency *return_value = new GeomLinestripsAdjacency((GeomEnums::UsageHint)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomLinestripsAdjacency, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: GeomLinestripsAdjacency::GeomLinestripsAdjacency(GeomLinestripsAdjacency const &copy)
  // No coercion possible: explicit GeomLinestripsAdjacency::GeomLinestripsAdjacency(GeomEnums::UsageHint usage_hint)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomLinestripsAdjacency(const GeomLinestripsAdjacency copy)\n"
      "GeomLinestripsAdjacency(int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomLinestripsAdjacency(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomLinestripsAdjacency) {
    printf("GeomLinestripsAdjacency ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomLinestripsAdjacency *local_this = (GeomLinestripsAdjacency *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomLinestripsAdjacency) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomPrimitive) {
    return (GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomLinestripsAdjacency(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomLinestripsAdjacency) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomLinestripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomLinestripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomLinestripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    GeomPrimitive* other_this = (GeomPrimitive*)from_this;
    return (GeomLinestripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomLinestripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomLinestripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomLinestripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomLinestripsAdjacency*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomPatches
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomPatches::get_class_type(void)
 */
static PyObject *Dtool_GeomPatches_get_class_type_962(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomPatches::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomPatches::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomPatches_get_class_type_962_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomPatches_get_class_type_962_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomPatches::GeomPatches(GeomPatches const &copy)
 * explicit GeomPatches::GeomPatches(int num_vertices_per_patch, GeomEnums::UsageHint usage_hint)
 */
static int Dtool_Init_GeomPatches(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-GeomPatches::GeomPatches(GeomPatches const &copy)
        GeomPatches const *arg_this = (GeomPatches *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomPatches, 0, "GeomPatches.GeomPatches", true, true);
        if (arg_this != nullptr) {
          GeomPatches *return_value = new GeomPatches(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomPatches, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-explicit GeomPatches::GeomPatches(int num_vertices_per_patch, GeomEnums::UsageHint usage_hint)
      int param0;
      int param1;
      static const char *keyword_list[] = {"num_vertices_per_patch", "usage_hint", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:GeomPatches", (char **)keyword_list, &param0, &param1)) {
        GeomPatches *return_value = new GeomPatches((int)param0, (GeomEnums::UsageHint)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomPatches, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomPatches() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomPatches(const GeomPatches copy)\n"
      "GeomPatches(int num_vertices_per_patch, int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomPatches(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomPatches) {
    printf("GeomPatches ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomPatches *local_this = (GeomPatches *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomPatches) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomPrimitive) {
    return (GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomPatches(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomPatches) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomPatches*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomPatches*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomPatches*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    GeomPrimitive* other_this = (GeomPrimitive*)from_this;
    return (GeomPatches*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomPatches*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomPatches*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomPatches*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomPatches*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomPoints
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomPoints::get_class_type(void)
 */
static PyObject *Dtool_GeomPoints_get_class_type_968(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomPoints::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomPoints::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomPoints_get_class_type_968_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomPoints_get_class_type_968_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit GeomPoints::GeomPoints(GeomEnums::UsageHint usage_hint)
 * GeomPoints::GeomPoints(GeomPoints const &copy)
 */
static int Dtool_Init_GeomPoints(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeomPoints() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 GeomPoints::GeomPoints(GeomPoints const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      GeomPoints const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomPoints);
      if (param0_this != nullptr) {
        GeomPoints *return_value = new GeomPoints(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomPoints, true, false);
      }
    }
  }

  {
    // -2 explicit GeomPoints::GeomPoints(GeomEnums::UsageHint usage_hint)
    int param0;
    static const char *keyword_list[] = {"usage_hint", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i:GeomPoints", (char **)keyword_list, &param0)) {
      GeomPoints *return_value = new GeomPoints((GeomEnums::UsageHint)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomPoints, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: GeomPoints::GeomPoints(GeomPoints const &copy)
  // No coercion possible: explicit GeomPoints::GeomPoints(GeomEnums::UsageHint usage_hint)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomPoints(const GeomPoints copy)\n"
      "GeomPoints(int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomPoints(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomPoints) {
    printf("GeomPoints ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomPoints *local_this = (GeomPoints *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomPoints) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomPrimitive) {
    return (GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomPoints(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomPoints) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomPoints*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomPoints*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomPoints*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    GeomPrimitive* other_this = (GeomPrimitive*)from_this;
    return (GeomPoints*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomPoints*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomPoints*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomPoints*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomPoints*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomTriangles
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomTriangles::get_class_type(void)
 */
static PyObject *Dtool_GeomTriangles_get_class_type_974(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomTriangles::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomTriangles::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomTriangles_get_class_type_974_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomTriangles_get_class_type_974_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit GeomTriangles::GeomTriangles(GeomEnums::UsageHint usage_hint)
 * GeomTriangles::GeomTriangles(GeomTriangles const &copy)
 */
static int Dtool_Init_GeomTriangles(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeomTriangles() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 GeomTriangles::GeomTriangles(GeomTriangles const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      GeomTriangles const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomTriangles);
      if (param0_this != nullptr) {
        GeomTriangles *return_value = new GeomTriangles(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomTriangles, true, false);
      }
    }
  }

  {
    // -2 explicit GeomTriangles::GeomTriangles(GeomEnums::UsageHint usage_hint)
    int param0;
    static const char *keyword_list[] = {"usage_hint", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i:GeomTriangles", (char **)keyword_list, &param0)) {
      GeomTriangles *return_value = new GeomTriangles((GeomEnums::UsageHint)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomTriangles, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: GeomTriangles::GeomTriangles(GeomTriangles const &copy)
  // No coercion possible: explicit GeomTriangles::GeomTriangles(GeomEnums::UsageHint usage_hint)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomTriangles(const GeomTriangles copy)\n"
      "GeomTriangles(int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomTriangles(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomTriangles) {
    printf("GeomTriangles ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomTriangles *local_this = (GeomTriangles *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomTriangles) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomPrimitive) {
    return (GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomTriangles(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomTriangles) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomTriangles*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomTriangles*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomTriangles*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    GeomPrimitive* other_this = (GeomPrimitive*)from_this;
    return (GeomTriangles*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomTriangles*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomTriangles*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomTriangles*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomTriangles*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomTrianglesAdjacency
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomTrianglesAdjacency::get_class_type(void)
 */
static PyObject *Dtool_GeomTrianglesAdjacency_get_class_type_980(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomTrianglesAdjacency::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomTrianglesAdjacency::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomTrianglesAdjacency_get_class_type_980_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomTrianglesAdjacency_get_class_type_980_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit GeomTrianglesAdjacency::GeomTrianglesAdjacency(GeomEnums::UsageHint usage_hint)
 * GeomTrianglesAdjacency::GeomTrianglesAdjacency(GeomTrianglesAdjacency const &copy)
 */
static int Dtool_Init_GeomTrianglesAdjacency(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeomTrianglesAdjacency() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 GeomTrianglesAdjacency::GeomTrianglesAdjacency(GeomTrianglesAdjacency const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      GeomTrianglesAdjacency const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomTrianglesAdjacency);
      if (param0_this != nullptr) {
        GeomTrianglesAdjacency *return_value = new GeomTrianglesAdjacency(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomTrianglesAdjacency, true, false);
      }
    }
  }

  {
    // -2 explicit GeomTrianglesAdjacency::GeomTrianglesAdjacency(GeomEnums::UsageHint usage_hint)
    int param0;
    static const char *keyword_list[] = {"usage_hint", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i:GeomTrianglesAdjacency", (char **)keyword_list, &param0)) {
      GeomTrianglesAdjacency *return_value = new GeomTrianglesAdjacency((GeomEnums::UsageHint)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomTrianglesAdjacency, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: GeomTrianglesAdjacency::GeomTrianglesAdjacency(GeomTrianglesAdjacency const &copy)
  // No coercion possible: explicit GeomTrianglesAdjacency::GeomTrianglesAdjacency(GeomEnums::UsageHint usage_hint)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomTrianglesAdjacency(const GeomTrianglesAdjacency copy)\n"
      "GeomTrianglesAdjacency(int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomTrianglesAdjacency(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomTrianglesAdjacency) {
    printf("GeomTrianglesAdjacency ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomTrianglesAdjacency *local_this = (GeomTrianglesAdjacency *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomTrianglesAdjacency) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomPrimitive) {
    return (GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomTrianglesAdjacency(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomTrianglesAdjacency) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomTrianglesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomTrianglesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomTrianglesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    GeomPrimitive* other_this = (GeomPrimitive*)from_this;
    return (GeomTrianglesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomTrianglesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomTrianglesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomTrianglesAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomTrianglesAdjacency*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomTrifans
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomTrifans::get_class_type(void)
 */
static PyObject *Dtool_GeomTrifans_get_class_type_986(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomTrifans::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomTrifans::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomTrifans_get_class_type_986_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomTrifans_get_class_type_986_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit GeomTrifans::GeomTrifans(GeomEnums::UsageHint usage_hint)
 * GeomTrifans::GeomTrifans(GeomTrifans const &copy)
 */
static int Dtool_Init_GeomTrifans(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeomTrifans() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 GeomTrifans::GeomTrifans(GeomTrifans const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      GeomTrifans const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomTrifans);
      if (param0_this != nullptr) {
        GeomTrifans *return_value = new GeomTrifans(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomTrifans, true, false);
      }
    }
  }

  {
    // -2 explicit GeomTrifans::GeomTrifans(GeomEnums::UsageHint usage_hint)
    int param0;
    static const char *keyword_list[] = {"usage_hint", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i:GeomTrifans", (char **)keyword_list, &param0)) {
      GeomTrifans *return_value = new GeomTrifans((GeomEnums::UsageHint)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomTrifans, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: GeomTrifans::GeomTrifans(GeomTrifans const &copy)
  // No coercion possible: explicit GeomTrifans::GeomTrifans(GeomEnums::UsageHint usage_hint)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomTrifans(const GeomTrifans copy)\n"
      "GeomTrifans(int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomTrifans(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomTrifans) {
    printf("GeomTrifans ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomTrifans *local_this = (GeomTrifans *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomTrifans) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomPrimitive) {
    return (GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomTrifans(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomTrifans) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomTrifans*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomTrifans*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomTrifans*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    GeomPrimitive* other_this = (GeomPrimitive*)from_this;
    return (GeomTrifans*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomTrifans*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomTrifans*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomTrifans*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomTrifans*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomTristrips
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomTristrips::get_class_type(void)
 */
static PyObject *Dtool_GeomTristrips_get_class_type_992(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomTristrips::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomTristrips::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomTristrips_get_class_type_992_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomTristrips_get_class_type_992_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit GeomTristrips::GeomTristrips(GeomEnums::UsageHint usage_hint)
 * GeomTristrips::GeomTristrips(GeomTristrips const &copy)
 */
static int Dtool_Init_GeomTristrips(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeomTristrips() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 GeomTristrips::GeomTristrips(GeomTristrips const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      GeomTristrips const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomTristrips);
      if (param0_this != nullptr) {
        GeomTristrips *return_value = new GeomTristrips(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomTristrips, true, false);
      }
    }
  }

  {
    // -2 explicit GeomTristrips::GeomTristrips(GeomEnums::UsageHint usage_hint)
    int param0;
    static const char *keyword_list[] = {"usage_hint", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i:GeomTristrips", (char **)keyword_list, &param0)) {
      GeomTristrips *return_value = new GeomTristrips((GeomEnums::UsageHint)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomTristrips, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: GeomTristrips::GeomTristrips(GeomTristrips const &copy)
  // No coercion possible: explicit GeomTristrips::GeomTristrips(GeomEnums::UsageHint usage_hint)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomTristrips(const GeomTristrips copy)\n"
      "GeomTristrips(int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomTristrips(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomTristrips) {
    printf("GeomTristrips ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomTristrips *local_this = (GeomTristrips *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomTristrips) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomPrimitive) {
    return (GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomTristrips(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomTristrips) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomTristrips*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomTristrips*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomTristrips*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    GeomPrimitive* other_this = (GeomPrimitive*)from_this;
    return (GeomTristrips*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomTristrips*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomTristrips*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomTristrips*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomTristrips*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomTristripsAdjacency
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomTristripsAdjacency::get_class_type(void)
 */
static PyObject *Dtool_GeomTristripsAdjacency_get_class_type_998(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomTristripsAdjacency::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomTristripsAdjacency::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomTristripsAdjacency_get_class_type_998_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomTristripsAdjacency_get_class_type_998_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit GeomTristripsAdjacency::GeomTristripsAdjacency(GeomEnums::UsageHint usage_hint)
 * GeomTristripsAdjacency::GeomTristripsAdjacency(GeomTristripsAdjacency const &copy)
 */
static int Dtool_Init_GeomTristripsAdjacency(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeomTristripsAdjacency() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 GeomTristripsAdjacency::GeomTristripsAdjacency(GeomTristripsAdjacency const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      GeomTristripsAdjacency const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomTristripsAdjacency);
      if (param0_this != nullptr) {
        GeomTristripsAdjacency *return_value = new GeomTristripsAdjacency(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomTristripsAdjacency, true, false);
      }
    }
  }

  {
    // -2 explicit GeomTristripsAdjacency::GeomTristripsAdjacency(GeomEnums::UsageHint usage_hint)
    int param0;
    static const char *keyword_list[] = {"usage_hint", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i:GeomTristripsAdjacency", (char **)keyword_list, &param0)) {
      GeomTristripsAdjacency *return_value = new GeomTristripsAdjacency((GeomEnums::UsageHint)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomTristripsAdjacency, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: GeomTristripsAdjacency::GeomTristripsAdjacency(GeomTristripsAdjacency const &copy)
  // No coercion possible: explicit GeomTristripsAdjacency::GeomTristripsAdjacency(GeomEnums::UsageHint usage_hint)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomTristripsAdjacency(const GeomTristripsAdjacency copy)\n"
      "GeomTristripsAdjacency(int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GeomTristripsAdjacency(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomTristripsAdjacency) {
    printf("GeomTristripsAdjacency ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomTristripsAdjacency *local_this = (GeomTristripsAdjacency *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomTristripsAdjacency) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomPrimitive) {
    return (GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(GeomPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomTristripsAdjacency(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomTristripsAdjacency) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomTristripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomTristripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomTristripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomPrimitive) {
    GeomPrimitive* other_this = (GeomPrimitive*)from_this;
    return (GeomTristripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomTristripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomTristripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomTristripsAdjacency*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomTristripsAdjacency*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomVertexReader
 */
/**
 * Python function wrapper for:
 * inline void GeomVertexReader::operator =(GeomVertexReader const &copy)
 */
static PyObject *Dtool_GeomVertexReader_operator_1001(PyObject *self, PyObject *arg) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.assign")) {
    return nullptr;
  }
  // 1-inline void GeomVertexReader::operator =(GeomVertexReader const &copy)
  GeomVertexReader arg_local;
  GeomVertexReader const *arg_this = Dtool_Coerce_GeomVertexReader(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexReader.assign", "GeomVertexReader");
  }
  ((*local_this).operator =)(*arg_this);
  GeomVertexReader *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexReader, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GeomVertexReader self, const GeomVertexReader copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_operator_1001_comment =
  "C++ Interface:\n"
  "assign(const GeomVertexReader self, const GeomVertexReader copy)\n";
#else
static const char *Dtool_GeomVertexReader_operator_1001_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexData const *GeomVertexReader::get_vertex_data(void) const
 */
static PyObject *Dtool_GeomVertexReader_get_vertex_data_1003(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline GeomVertexData const *GeomVertexReader::get_vertex_data(void) const
  GeomVertexData const *return_value = ((*(const GeomVertexReader*)local_this).get_vertex_data)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexData, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_vertex_data_1003_comment =
  "C++ Interface:\n"
  "get_vertex_data(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex data object that the reader is processing.  This may\n"
  " * return NULL if the reader was constructed with just an array pointer.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_vertex_data_1003_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexArrayData const *GeomVertexReader::get_array_data(void) const
 */
static PyObject *Dtool_GeomVertexReader_get_array_data_1004(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline GeomVertexArrayData const *GeomVertexReader::get_array_data(void) const
  GeomVertexArrayData const *return_value = ((*(const GeomVertexReader*)local_this).get_array_data)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexArrayData, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_array_data_1004_comment =
  "C++ Interface:\n"
  "get_array_data(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the particular array object that the reader is currently\n"
  " * processing.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_array_data_1004_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexArrayDataHandle const *GeomVertexReader::get_array_handle(void) const
 */
static PyObject *Dtool_GeomVertexReader_get_array_handle_1005(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline GeomVertexArrayDataHandle const *GeomVertexReader::get_array_handle(void) const
  GeomVertexArrayDataHandle const *return_value = ((*(const GeomVertexReader*)local_this).get_array_handle)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexArrayDataHandle, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_array_handle_1005_comment =
  "C++ Interface:\n"
  "get_array_handle(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the read handle to the array object that the read is currently\n"
  " * processing.  This low-level call should be used with caution.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_array_handle_1005_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t GeomVertexReader::get_stride(void) const
 */
static PyObject *Dtool_GeomVertexReader_get_stride_1006(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline std::size_t GeomVertexReader::get_stride(void) const
  std::size_t return_value = ((*(const GeomVertexReader*)local_this).get_stride)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_stride_1006_comment =
  "C++ Interface:\n"
  "get_stride(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the per-row stride (bytes between consecutive rows) of the\n"
  " * underlying vertex array.  This low-level information is normally not needed\n"
  " * to use the GeomVertexReader directly.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_stride_1006_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Thread *GeomVertexReader::get_current_thread(void) const
 */
static PyObject *Dtool_GeomVertexReader_get_current_thread_1007(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline Thread *GeomVertexReader::get_current_thread(void) const
  Thread *return_value = ((*(const GeomVertexReader*)local_this).get_current_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_current_thread_1007_comment =
  "C++ Interface:\n"
  "get_current_thread(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the Thread pointer of the currently-executing thread, as passed to\n"
  " * the constructor of this object.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_current_thread_1007_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexReader::set_force(bool force)
 */
static PyObject *Dtool_GeomVertexReader_set_force_1008(PyObject *self, PyObject *arg) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.set_force")) {
    return nullptr;
  }
  // 1-inline void GeomVertexReader::set_force(bool force)
  ((*local_this).set_force)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_force(const GeomVertexReader self, bool force)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_set_force_1008_comment =
  "C++ Interface:\n"
  "set_force(const GeomVertexReader self, bool force)\n"
  "\n"
  "/**\n"
  " * Sets the value of the force flag.  When this is true (the default), vertex\n"
  " * data will be paged in from disk if necessary.  When this is false, the\n"
  " * GeomVertexData will simply return a failure code when attempting to read\n"
  " * vertex data that is not resident (but will put it on the queue to become\n"
  " * resident later).\n"
  " *\n"
  " * Normally, vertex data is always resident, so this will not be an issue.  It\n"
  " * is only possible for vertex data to be nonresident if you have enabled\n"
  " * vertex paging via the GeomVertexArrayData and VertexDataPage interfaces.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_set_force_1008_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexReader::get_force(void) const
 */
static PyObject *Dtool_GeomVertexReader_get_force_1009(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexReader::get_force(void) const
  bool return_value = ((*(const GeomVertexReader*)local_this).get_force)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_force_1009_comment =
  "C++ Interface:\n"
  "get_force(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the value of the force flag.  See set_force().\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_force_1009_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexReader::set_column(CPT_InternalName name)
 * inline bool GeomVertexReader::set_column(int column)
 * bool GeomVertexReader::set_column(int array, GeomVertexColumn const *column)
 */
static PyObject *Dtool_GeomVertexReader_set_column_1010(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.set_column")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline bool GeomVertexReader::set_column(CPT_InternalName name)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "name")) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          if (param1_this != nullptr) {
            bool return_value = ((*local_this).set_column)(param1_this);
            return Dtool_Return_Bool(return_value);
          }
        }
      }

      {
        // -2 inline bool GeomVertexReader::set_column(int column)
        int param1;
        static const char *keyword_list[] = {"column", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:set_column", (char **)keyword_list, &param1)) {
          bool return_value = ((*local_this).set_column)((int)param1);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool GeomVertexReader::set_column(CPT_InternalName name)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "name")) {
          CPT(InternalName) param1_this;
          if (Dtool_ConstCoerce_InternalName(param1, param1_this)) {
            bool return_value = ((*local_this).set_column)(std::move(param1_this));
            return Dtool_Return_Bool(return_value);
          }
        }
      }

      // No coercion possible: inline bool GeomVertexReader::set_column(int column)
    }
    break;
  case 2:
    {
      // 1-bool GeomVertexReader::set_column(int array, GeomVertexColumn const *column)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"array", "column", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_column", (char **)keyword_list, &param1, &param2)) {
        GeomVertexColumn const *param2_this = (GeomVertexColumn *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeomVertexColumn, 2, "GeomVertexReader.set_column", true, true);
        if (param2_this != nullptr) {
          bool return_value = ((*local_this).set_column)((int)param1, param2_this);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_column() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_column(const GeomVertexReader self, const InternalName name)\n"
      "set_column(const GeomVertexReader self, int column)\n"
      "set_column(const GeomVertexReader self, int array, const GeomVertexColumn column)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_set_column_1010_comment =
  "C++ Interface:\n"
  "set_column(const GeomVertexReader self, const InternalName name)\n"
  "set_column(const GeomVertexReader self, int column)\n"
  "set_column(const GeomVertexReader self, int array, const GeomVertexColumn column)\n"
  "\n"
  "/**\n"
  " * Sets up the reader to use the nth data type of the GeomVertexFormat,\n"
  " * numbering from 0.\n"
  " *\n"
  " * This also resets the read row number to the start row (the same value\n"
  " * passed to a previous call to set_row(), or 0 if set_row() was never\n"
  " * called.)\n"
  " *\n"
  " * The return value is true if the data type is valid, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the reader to use the data type with the indicated name.\n"
  " *\n"
  " * This also resets the read row number to the start row (the same value\n"
  " * passed to a previous call to set_row(), or 0 if set_row() was never\n"
  " * called.)\n"
  " *\n"
  " * The return value is true if the data type is valid, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the reader to use the indicated column description on the given\n"
  " * array.\n"
  " *\n"
  " * This also resets the current read row number to the start row (the same\n"
  " * value passed to a previous call to set_row(), or 0 if set_row() was never\n"
  " * called.)\n"
  " *\n"
  " * The return value is true if the data type is valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_set_column_1010_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexReader::clear(void)
 */
static PyObject *Dtool_GeomVertexReader_clear_1011(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.clear")) {
    return nullptr;
  }
  // 1-inline void GeomVertexReader::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_clear_1011_comment =
  "C++ Interface:\n"
  "clear(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Resets the GeomVertexReader to the initial state.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_clear_1011_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexReader::has_column(void) const
 */
static PyObject *Dtool_GeomVertexReader_has_column_1012(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexReader::has_column(void) const
  bool return_value = ((*(const GeomVertexReader*)local_this).has_column)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_has_column_1012_comment =
  "C++ Interface:\n"
  "has_column(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if a valid data type has been successfully set, or false if\n"
  " * the data type does not exist (or if get_force() is false and the vertex\n"
  " * data is nonresident).\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_has_column_1012_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexReader::get_array(void) const
 */
static PyObject *Dtool_GeomVertexReader_get_array_1013(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline int GeomVertexReader::get_array(void) const
  int return_value = ((*(const GeomVertexReader*)local_this).get_array)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_array_1013_comment =
  "C++ Interface:\n"
  "get_array(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the array index containing the data type that the reader is working\n"
  " * on.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_array_1013_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexColumn const *GeomVertexReader::get_column(void) const
 */
static PyObject *Dtool_GeomVertexReader_get_column_1014(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline GeomVertexColumn const *GeomVertexReader::get_column(void) const
  GeomVertexColumn const *return_value = ((*(const GeomVertexReader*)local_this).get_column)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_column_1014_comment =
  "C++ Interface:\n"
  "get_column(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the description of the data type that the reader is working on.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_column_1014_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexReader::set_row_unsafe(int row)
 */
static PyObject *Dtool_GeomVertexReader_set_row_unsafe_1015(PyObject *self, PyObject *arg) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.set_row_unsafe")) {
    return nullptr;
  }
  // 1-inline void GeomVertexReader::set_row_unsafe(int row)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_row_unsafe)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_row_unsafe(const GeomVertexReader self, int row)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_set_row_unsafe_1015_comment =
  "C++ Interface:\n"
  "set_row_unsafe(const GeomVertexReader self, int row)\n"
  "\n"
  "/**\n"
  " * Sets the start row to the indicated value, without internal checks.  This\n"
  " * is the same as set_row(), but it does not check for the possibility that\n"
  " * the array has been reallocated internally for some reason; use only when\n"
  " * you are confident that the array is unchanged and you really need every bit\n"
  " * of available performance.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_set_row_unsafe_1015_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexReader::set_row(int row)
 */
static PyObject *Dtool_GeomVertexReader_set_row_1016(PyObject *self, PyObject *arg) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.set_row")) {
    return nullptr;
  }
  // 1-inline void GeomVertexReader::set_row(int row)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_row)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_row(const GeomVertexReader self, int row)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_set_row_1016_comment =
  "C++ Interface:\n"
  "set_row(const GeomVertexReader self, int row)\n"
  "\n"
  "/**\n"
  " * Sets the start row to the indicated value.  The reader will begin reading\n"
  " * from the indicated row; each subsequent get_data*() call will return the\n"
  " * data from the subsequent row.  If set_column() is called, the reader will\n"
  " * return to this row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_set_row_1016_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexReader::get_start_row(void) const
 */
static PyObject *Dtool_GeomVertexReader_get_start_row_1017(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline int GeomVertexReader::get_start_row(void) const
  int return_value = ((*(const GeomVertexReader*)local_this).get_start_row)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_start_row_1017_comment =
  "C++ Interface:\n"
  "get_start_row(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the row index at which the reader started.  It will return to this\n"
  " * row if you reset the current column.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_start_row_1017_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexReader::get_read_row(void) const
 */
static PyObject *Dtool_GeomVertexReader_get_read_row_1018(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline int GeomVertexReader::get_read_row(void) const
  int return_value = ((*(const GeomVertexReader*)local_this).get_read_row)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_read_row_1018_comment =
  "C++ Interface:\n"
  "get_read_row(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the row index from which the data will be retrieved by the next\n"
  " * call to get_data*().\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_read_row_1018_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexReader::is_at_end(void) const
 */
static PyObject *Dtool_GeomVertexReader_is_at_end_1019(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexReader::is_at_end(void) const
  bool return_value = ((*(const GeomVertexReader*)local_this).is_at_end)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_is_at_end_1019_comment =
  "C++ Interface:\n"
  "is_at_end(GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if the reader is currently at the end of the list of vertices,\n"
  " * false otherwise.  If this is true, another call to get_data*() will result\n"
  " * in a crash.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_is_at_end_1019_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float GeomVertexReader::get_data1f(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data1f_1020(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data1f")) {
    return nullptr;
  }
  // 1-inline float GeomVertexReader::get_data1f(void)
  float return_value = ((*local_this).get_data1f)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data1f_1020_comment =
  "C++ Interface:\n"
  "get_data1f(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 1-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data1f_1020_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f const &GeomVertexReader::get_data2f(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data2f_1021(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data2f")) {
    return nullptr;
  }
  // 1-inline LVecBase2f const &GeomVertexReader::get_data2f(void)
  LVecBase2f const *return_value = &(((*local_this).get_data2f)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data2f_1021_comment =
  "C++ Interface:\n"
  "get_data2f(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 2-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data2f_1021_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &GeomVertexReader::get_data3f(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data3f_1022(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data3f")) {
    return nullptr;
  }
  // 1-inline LVecBase3f const &GeomVertexReader::get_data3f(void)
  LVecBase3f const *return_value = &(((*local_this).get_data3f)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data3f_1022_comment =
  "C++ Interface:\n"
  "get_data3f(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 3-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data3f_1022_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f const &GeomVertexReader::get_data4f(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data4f_1023(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data4f")) {
    return nullptr;
  }
  // 1-inline LVecBase4f const &GeomVertexReader::get_data4f(void)
  LVecBase4f const *return_value = &(((*local_this).get_data4f)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data4f_1023_comment =
  "C++ Interface:\n"
  "get_data4f(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 4-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data4f_1023_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f GeomVertexReader::get_matrix3f(void)
 */
static PyObject *Dtool_GeomVertexReader_get_matrix3f_1024(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_matrix3f")) {
    return nullptr;
  }
  // 1-inline LMatrix3f GeomVertexReader::get_matrix3f(void)
  LMatrix3f *return_value = new LMatrix3f(((*local_this).get_matrix3f)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_matrix3f_1024_comment =
  "C++ Interface:\n"
  "get_matrix3f(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the 3-by-3 matrix associated with the read row and advances the\n"
  " * read row.  This is a special method that only works when the column in\n"
  " * question contains a matrix of an appropriate size.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_matrix3f_1024_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4f GeomVertexReader::get_matrix4f(void)
 */
static PyObject *Dtool_GeomVertexReader_get_matrix4f_1025(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_matrix4f")) {
    return nullptr;
  }
  // 1-inline LMatrix4f GeomVertexReader::get_matrix4f(void)
  LMatrix4f *return_value = new LMatrix4f(((*local_this).get_matrix4f)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_matrix4f_1025_comment =
  "C++ Interface:\n"
  "get_matrix4f(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the 4-by-4 matrix associated with the read row and advances the\n"
  " * read row.  This is a special method that only works when the column in\n"
  " * question contains a matrix of an appropriate size.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_matrix4f_1025_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double GeomVertexReader::get_data1d(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data1d_1026(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data1d")) {
    return nullptr;
  }
  // 1-inline double GeomVertexReader::get_data1d(void)
  double return_value = ((*local_this).get_data1d)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data1d_1026_comment =
  "C++ Interface:\n"
  "get_data1d(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 1-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data1d_1026_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d const &GeomVertexReader::get_data2d(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data2d_1027(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data2d")) {
    return nullptr;
  }
  // 1-inline LVecBase2d const &GeomVertexReader::get_data2d(void)
  LVecBase2d const *return_value = &(((*local_this).get_data2d)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data2d_1027_comment =
  "C++ Interface:\n"
  "get_data2d(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 2-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data2d_1027_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &GeomVertexReader::get_data3d(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data3d_1028(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data3d")) {
    return nullptr;
  }
  // 1-inline LVecBase3d const &GeomVertexReader::get_data3d(void)
  LVecBase3d const *return_value = &(((*local_this).get_data3d)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data3d_1028_comment =
  "C++ Interface:\n"
  "get_data3d(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 3-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data3d_1028_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d const &GeomVertexReader::get_data4d(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data4d_1029(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data4d")) {
    return nullptr;
  }
  // 1-inline LVecBase4d const &GeomVertexReader::get_data4d(void)
  LVecBase4d const *return_value = &(((*local_this).get_data4d)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data4d_1029_comment =
  "C++ Interface:\n"
  "get_data4d(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 4-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data4d_1029_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d GeomVertexReader::get_matrix3d(void)
 */
static PyObject *Dtool_GeomVertexReader_get_matrix3d_1030(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_matrix3d")) {
    return nullptr;
  }
  // 1-inline LMatrix3d GeomVertexReader::get_matrix3d(void)
  LMatrix3d *return_value = new LMatrix3d(((*local_this).get_matrix3d)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_matrix3d_1030_comment =
  "C++ Interface:\n"
  "get_matrix3d(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the 3-by-3 matrix associated with the read row and advances the\n"
  " * read row.  This is a special method that only works when the column in\n"
  " * question contains a matrix of an appropriate size.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_matrix3d_1030_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d GeomVertexReader::get_matrix4d(void)
 */
static PyObject *Dtool_GeomVertexReader_get_matrix4d_1031(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_matrix4d")) {
    return nullptr;
  }
  // 1-inline LMatrix4d GeomVertexReader::get_matrix4d(void)
  LMatrix4d *return_value = new LMatrix4d(((*local_this).get_matrix4d)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_matrix4d_1031_comment =
  "C++ Interface:\n"
  "get_matrix4d(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the 4-by-4 matrix associated with the read row and advances the\n"
  " * read row.  This is a special method that only works when the column in\n"
  " * question contains a matrix of an appropriate size.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_matrix4d_1031_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat GeomVertexReader::get_data1(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data1_1032(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data1")) {
    return nullptr;
  }
  // 1-inline PN_stdfloat GeomVertexReader::get_data1(void)
  PN_stdfloat return_value = ((*local_this).get_data1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data1_1032_comment =
  "C++ Interface:\n"
  "get_data1(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 1-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data1_1032_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 const &GeomVertexReader::get_data2(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data2_1033(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data2")) {
    return nullptr;
  }
  // 1-inline LVecBase2 const &GeomVertexReader::get_data2(void)
  LVecBase2 const *return_value = &(((*local_this).get_data2)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data2_1033_comment =
  "C++ Interface:\n"
  "get_data2(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 2-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data2_1033_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &GeomVertexReader::get_data3(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data3_1034(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data3")) {
    return nullptr;
  }
  // 1-inline LVecBase3 const &GeomVertexReader::get_data3(void)
  LVecBase3 const *return_value = &(((*local_this).get_data3)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data3_1034_comment =
  "C++ Interface:\n"
  "get_data3(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 3-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data3_1034_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &GeomVertexReader::get_data4(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data4_1035(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data4")) {
    return nullptr;
  }
  // 1-inline LVecBase4 const &GeomVertexReader::get_data4(void)
  LVecBase4 const *return_value = &(((*local_this).get_data4)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data4_1035_comment =
  "C++ Interface:\n"
  "get_data4(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 4-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data4_1035_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3 GeomVertexReader::get_matrix3(void)
 */
static PyObject *Dtool_GeomVertexReader_get_matrix3_1036(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_matrix3")) {
    return nullptr;
  }
  // 1-inline LMatrix3 GeomVertexReader::get_matrix3(void)
  LMatrix3 *return_value = new LMatrix3(((*local_this).get_matrix3)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_matrix3_1036_comment =
  "C++ Interface:\n"
  "get_matrix3(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the 3-by-3 matrix associated with the read row and advances the\n"
  " * read row.  This is a special method that only works when the column in\n"
  " * question contains a matrix of an appropriate size.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_matrix3_1036_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 GeomVertexReader::get_matrix4(void)
 */
static PyObject *Dtool_GeomVertexReader_get_matrix4_1037(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_matrix4")) {
    return nullptr;
  }
  // 1-inline LMatrix4 GeomVertexReader::get_matrix4(void)
  LMatrix4 *return_value = new LMatrix4(((*local_this).get_matrix4)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_matrix4_1037_comment =
  "C++ Interface:\n"
  "get_matrix4(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the 4-by-4 matrix associated with the read row and advances the\n"
  " * read row.  This is a special method that only works when the column in\n"
  " * question contains a matrix of an appropriate size.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_matrix4_1037_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexReader::get_data1i(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data1i_1038(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data1i")) {
    return nullptr;
  }
  // 1-inline int GeomVertexReader::get_data1i(void)
  int return_value = ((*local_this).get_data1i)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data1i_1038_comment =
  "C++ Interface:\n"
  "get_data1i(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 1-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data1i_1038_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i const &GeomVertexReader::get_data2i(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data2i_1039(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data2i")) {
    return nullptr;
  }
  // 1-inline LVecBase2i const &GeomVertexReader::get_data2i(void)
  LVecBase2i const *return_value = &(((*local_this).get_data2i)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data2i_1039_comment =
  "C++ Interface:\n"
  "get_data2i(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 2-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data2i_1039_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i const &GeomVertexReader::get_data3i(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data3i_1040(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data3i")) {
    return nullptr;
  }
  // 1-inline LVecBase3i const &GeomVertexReader::get_data3i(void)
  LVecBase3i const *return_value = &(((*local_this).get_data3i)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data3i_1040_comment =
  "C++ Interface:\n"
  "get_data3i(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 3-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data3i_1040_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4i const &GeomVertexReader::get_data4i(void)
 */
static PyObject *Dtool_GeomVertexReader_get_data4i_1041(PyObject *self, PyObject *) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexReader, (void **)&local_this, "GeomVertexReader.get_data4i")) {
    return nullptr;
  }
  // 1-inline LVecBase4i const &GeomVertexReader::get_data4i(void)
  LVecBase4i const *return_value = &(((*local_this).get_data4i)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_get_data4i_1041_comment =
  "C++ Interface:\n"
  "get_data4i(const GeomVertexReader self)\n"
  "\n"
  "/**\n"
  " * Returns the data associated with the read row, expressed as a 4-component\n"
  " * value, and advances the read row.\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_get_data4i_1041_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexReader::output(std::ostream &out) const
 */
static PyObject *Dtool_GeomVertexReader_output_1042(PyObject *self, PyObject *arg) {
  GeomVertexReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexReader)) {
    return nullptr;
  }
  // 1-void GeomVertexReader::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GeomVertexReader.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GeomVertexReader*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GeomVertexReader self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexReader_output_1042_comment =
  "C++ Interface:\n"
  "output(GeomVertexReader self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexReader_output_1042_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, int column, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexReader::GeomVertexReader(GeomVertexReader const &copy)
 * inline GeomVertexReader::GeomVertexReader(Thread *current_thread = Thread::get_current_thread())
 */
static int Dtool_Init_GeomVertexReader(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline GeomVertexReader::GeomVertexReader(Thread *current_thread)
      GeomVertexReader *return_value = new GeomVertexReader();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexReader, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, Thread *current_thread)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "array_data")) {
          GeomVertexArrayData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexArrayData);
          if (param0_this != nullptr) {
            GeomVertexReader *return_value = new GeomVertexReader(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexReader, true, false);
          }
        }
      }

      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, Thread *current_thread)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "vertex_data")) {
          GeomVertexData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexData);
          if (param0_this != nullptr) {
            GeomVertexReader *return_value = new GeomVertexReader(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexReader, true, false);
          }
        }
      }

      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexReader const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          GeomVertexReader const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexReader);
          if (param0_this != nullptr) {
            GeomVertexReader *return_value = new GeomVertexReader(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexReader, true, false);
          }
        }
      }

      {
        // -2 inline GeomVertexReader::GeomVertexReader(Thread *current_thread)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "current_thread")) {
          Thread *param0_this = (Thread *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Thread, 0, "GeomVertexReader.GeomVertexReader", false, false);
          if (param0_this != nullptr) {
            GeomVertexReader *return_value = new GeomVertexReader(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexReader, true, false);
          }
        }
      }

      // No coercion possible: inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, Thread *current_thread)
      // No coercion possible: inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, Thread *current_thread)
      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexReader const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          GeomVertexReader param0_local;
          GeomVertexReader const *param0_this = Dtool_Coerce_GeomVertexReader(param0, param0_local);
          if ((param0_this != nullptr)) {
            GeomVertexReader *return_value = new GeomVertexReader(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexReader, true, false);
          }
        }
      }

      // No coercion possible: inline GeomVertexReader::GeomVertexReader(Thread *current_thread)
    }
    break;
  case 2:
  case 3:
    {
      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, int column, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        int param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"array_data", "column", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi|O:GeomVertexReader", (char **)keyword_list, &param0, &param1, &param2)) {
          GeomVertexArrayData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexArrayData);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexReader.GeomVertexReader", false, false);
          }
          if (param0_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            GeomVertexReader *return_value = new GeomVertexReader(param0_this, (int)param1, param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexReader, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"vertex_data", "name", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:GeomVertexReader", (char **)keyword_list, &param0, &param1, &param2)) {
          GeomVertexData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexData);
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexReader.GeomVertexReader", false, false);
          }
          if (param0_this != nullptr && param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            GeomVertexReader *return_value = new GeomVertexReader(param0_this, param1_this, param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexReader, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"array_data", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:GeomVertexReader", (char **)keyword_list, &param0, &param1)) {
          GeomVertexArrayData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexArrayData);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexReader.GeomVertexReader", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            GeomVertexReader *return_value = new GeomVertexReader(param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexReader, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"vertex_data", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:GeomVertexReader", (char **)keyword_list, &param0, &param1)) {
          GeomVertexData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexData);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexReader.GeomVertexReader", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            GeomVertexReader *return_value = new GeomVertexReader(param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexReader, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, int column, Thread *current_thread = Thread::get_current_thread())
      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"vertex_data", "name", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:GeomVertexReader", (char **)keyword_list, &param0, &param1, &param2)) {
          GeomVertexData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexData);
          CPT(InternalName) param1_this;
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexReader.GeomVertexReader", false, false);
          }
          if (param0_this != nullptr && Dtool_ConstCoerce_InternalName(param1, param1_this) && (param2 == nullptr || param2_this != nullptr)) {
            GeomVertexReader *return_value = new GeomVertexReader(param0_this, std::move(param1_this), param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexReader, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, Thread *current_thread = Thread::get_current_thread())
      // No coercion possible: inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, Thread *current_thread = Thread::get_current_thread())
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomVertexReader() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomVertexReader()\n"
      "GeomVertexReader(const GeomVertexArrayData array_data)\n"
      "GeomVertexReader(const GeomVertexData vertex_data)\n"
      "GeomVertexReader(const GeomVertexReader copy)\n"
      "GeomVertexReader(Thread current_thread)\n"
      "GeomVertexReader(const GeomVertexArrayData array_data, int column, Thread current_thread)\n"
      "GeomVertexReader(const GeomVertexData vertex_data, const InternalName name, Thread current_thread)\n"
      "GeomVertexReader(const GeomVertexArrayData array_data, Thread current_thread)\n"
      "GeomVertexReader(const GeomVertexData vertex_data, Thread current_thread)\n");
  }
  return -1;
}

GeomVertexReader *Dtool_Coerce_GeomVertexReader(PyObject *args, GeomVertexReader &coerced) {
  GeomVertexReader *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_GeomVertexReader)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const GeomVertexReader *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, Thread *current_thread)
      GeomVertexArrayData const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GeomVertexArrayData);
      if (arg_this != nullptr) {
        coerced = GeomVertexReader(arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, Thread *current_thread)
      GeomVertexData const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GeomVertexData);
      if (arg_this != nullptr) {
        coerced = GeomVertexReader(arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline GeomVertexReader::GeomVertexReader(Thread *current_thread)
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 0, "GeomVertexReader.GeomVertexReader", false, false);
      if (arg_this != nullptr) {
        coerced = GeomVertexReader(arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, int column, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        int param1;
        PyObject *param2 = nullptr;
        if (PyArg_ParseTuple(args, "Oi|O:GeomVertexReader", &param0, &param1, &param2)) {
          GeomVertexArrayData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexArrayData);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexReader.GeomVertexReader", false, false);
          }
          if (param0_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            coerced = GeomVertexReader(param0_this, (int)param1, param2_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        PyObject *param2 = nullptr;
        if (PyArg_UnpackTuple(args, "GeomVertexReader", 2, 3, &param0, &param1, &param2)) {
          GeomVertexData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexData);
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexReader.GeomVertexReader", false, false);
          }
          if (param0_this != nullptr && param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            coerced = GeomVertexReader(param0_this, param1_this, param2_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "GeomVertexReader", 2, 2, &param0, &param1)) {
          GeomVertexArrayData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexArrayData);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexReader.GeomVertexReader", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            coerced = GeomVertexReader(param0_this, param1_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "GeomVertexReader", 2, 2, &param0, &param1)) {
          GeomVertexData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexData);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexReader.GeomVertexReader", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            coerced = GeomVertexReader(param0_this, param1_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_GeomVertexReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomVertexReader) {
    printf("GeomVertexReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomVertexReader *local_this = (GeomVertexReader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomVertexReader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomVertexReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomVertexReader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomVertexReader*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomVertexWriter
 */
/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::operator =(GeomVertexWriter const &copy)
 */
static PyObject *Dtool_GeomVertexWriter_operator_1045(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.assign")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::operator =(GeomVertexWriter const &copy)
  GeomVertexWriter arg_local;
  GeomVertexWriter const *arg_this = Dtool_Coerce_GeomVertexWriter(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.assign", "GeomVertexWriter");
  }
  ((*local_this).operator =)(*arg_this);
  GeomVertexWriter *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexWriter, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GeomVertexWriter self, const GeomVertexWriter copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_operator_1045_comment =
  "C++ Interface:\n"
  "assign(const GeomVertexWriter self, const GeomVertexWriter copy)\n";
#else
static const char *Dtool_GeomVertexWriter_operator_1045_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexData *GeomVertexWriter::get_vertex_data(void) const
 */
static PyObject *Dtool_GeomVertexWriter_get_vertex_data_1047(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-inline GeomVertexData *GeomVertexWriter::get_vertex_data(void) const
  GeomVertexData *return_value = ((*(const GeomVertexWriter*)local_this).get_vertex_data)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexData, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_get_vertex_data_1047_comment =
  "C++ Interface:\n"
  "get_vertex_data(GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex data object that the writer is processing.  This may\n"
  " * return NULL if the writer was constructed with just an array pointer.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_get_vertex_data_1047_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexArrayData *GeomVertexWriter::get_array_data(void) const
 */
static PyObject *Dtool_GeomVertexWriter_get_array_data_1048(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-inline GeomVertexArrayData *GeomVertexWriter::get_array_data(void) const
  GeomVertexArrayData *return_value = ((*(const GeomVertexWriter*)local_this).get_array_data)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexArrayData, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_get_array_data_1048_comment =
  "C++ Interface:\n"
  "get_array_data(GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the particular array object that the writer is currently\n"
  " * processing.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_get_array_data_1048_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexArrayDataHandle *GeomVertexWriter::get_array_handle(void) const
 */
static PyObject *Dtool_GeomVertexWriter_get_array_handle_1049(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-inline GeomVertexArrayDataHandle *GeomVertexWriter::get_array_handle(void) const
  GeomVertexArrayDataHandle *return_value = ((*(const GeomVertexWriter*)local_this).get_array_handle)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexArrayDataHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_get_array_handle_1049_comment =
  "C++ Interface:\n"
  "get_array_handle(GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the write handle to the array object that the writer is currently\n"
  " * processing.  This low-level call should be used with caution; be careful\n"
  " * with modifying the data in the handle out from under the GeomVertexWriter.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_get_array_handle_1049_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t GeomVertexWriter::get_stride(void) const
 */
static PyObject *Dtool_GeomVertexWriter_get_stride_1050(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-inline std::size_t GeomVertexWriter::get_stride(void) const
  std::size_t return_value = ((*(const GeomVertexWriter*)local_this).get_stride)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_get_stride_1050_comment =
  "C++ Interface:\n"
  "get_stride(GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the per-row stride (bytes between consecutive rows) of the\n"
  " * underlying vertex array.  This low-level information is normally not needed\n"
  " * to use the GeomVertexWriter directly.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_get_stride_1050_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Thread *GeomVertexWriter::get_current_thread(void) const
 */
static PyObject *Dtool_GeomVertexWriter_get_current_thread_1051(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-inline Thread *GeomVertexWriter::get_current_thread(void) const
  Thread *return_value = ((*(const GeomVertexWriter*)local_this).get_current_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_get_current_thread_1051_comment =
  "C++ Interface:\n"
  "get_current_thread(GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the Thread pointer of the currently-executing thread, as passed to\n"
  " * the constructor of this object.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_get_current_thread_1051_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexWriter::set_column(CPT_InternalName name)
 * inline bool GeomVertexWriter::set_column(int column)
 * bool GeomVertexWriter::set_column(int array, GeomVertexColumn const *column)
 */
static PyObject *Dtool_GeomVertexWriter_set_column_1052(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_column")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline bool GeomVertexWriter::set_column(CPT_InternalName name)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "name")) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          if (param1_this != nullptr) {
            bool return_value = ((*local_this).set_column)(param1_this);
            return Dtool_Return_Bool(return_value);
          }
        }
      }

      {
        // -2 inline bool GeomVertexWriter::set_column(int column)
        int param1;
        static const char *keyword_list[] = {"column", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:set_column", (char **)keyword_list, &param1)) {
          bool return_value = ((*local_this).set_column)((int)param1);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool GeomVertexWriter::set_column(CPT_InternalName name)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "name")) {
          CPT(InternalName) param1_this;
          if (Dtool_ConstCoerce_InternalName(param1, param1_this)) {
            bool return_value = ((*local_this).set_column)(std::move(param1_this));
            return Dtool_Return_Bool(return_value);
          }
        }
      }

      // No coercion possible: inline bool GeomVertexWriter::set_column(int column)
    }
    break;
  case 2:
    {
      // 1-bool GeomVertexWriter::set_column(int array, GeomVertexColumn const *column)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"array", "column", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_column", (char **)keyword_list, &param1, &param2)) {
        GeomVertexColumn const *param2_this = (GeomVertexColumn *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeomVertexColumn, 2, "GeomVertexWriter.set_column", true, true);
        if (param2_this != nullptr) {
          bool return_value = ((*local_this).set_column)((int)param1, param2_this);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_column() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_column(const GeomVertexWriter self, const InternalName name)\n"
      "set_column(const GeomVertexWriter self, int column)\n"
      "set_column(const GeomVertexWriter self, int array, const GeomVertexColumn column)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_column_1052_comment =
  "C++ Interface:\n"
  "set_column(const GeomVertexWriter self, const InternalName name)\n"
  "set_column(const GeomVertexWriter self, int column)\n"
  "set_column(const GeomVertexWriter self, int array, const GeomVertexColumn column)\n"
  "\n"
  "/**\n"
  " * Sets up the writer to use the nth data type of the GeomVertexFormat,\n"
  " * numbering from 0.\n"
  " *\n"
  " * This also resets the write row number to the start row (the same value\n"
  " * passed to a previous call to set_row(), or 0 if set_row() was never\n"
  " * called.)\n"
  " *\n"
  " * The return value is true if the data type is valid, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the writer to use the data type with the indicated name.\n"
  " *\n"
  " * This also resets the write number to the start row (the same value passed\n"
  " * to a previous call to set_row(), or 0 if set_row() was never called.)\n"
  " *\n"
  " * The return value is true if the data type is valid, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the writer to use the indicated column description on the given\n"
  " * array.\n"
  " *\n"
  " * This also resets the current write row number to the start row (the same\n"
  " * value passed to a previous call to set_row(), or 0 if set_row() was never\n"
  " * called.)\n"
  " *\n"
  " * The return value is true if the data type is valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_column_1052_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::clear(void)
 */
static PyObject *Dtool_GeomVertexWriter_clear_1053(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.clear")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_clear_1053_comment =
  "C++ Interface:\n"
  "clear(const GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Resets the GeomVertexWriter to the initial state.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_clear_1053_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GeomVertexWriter::reserve_num_rows(int num_rows)
 */
static PyObject *Dtool_GeomVertexWriter_reserve_num_rows_1054(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.reserve_num_rows")) {
    return nullptr;
  }
  // 1-bool GeomVertexWriter::reserve_num_rows(int num_rows)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).reserve_num_rows)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reserve_num_rows(const GeomVertexWriter self, int num_rows)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_reserve_num_rows_1054_comment =
  "C++ Interface:\n"
  "reserve_num_rows(const GeomVertexWriter self, int num_rows)\n"
  "\n"
  "/**\n"
  " * This ensures that enough memory space for num_rows is allocated, so that\n"
  " * you may add up to num_rows rows without causing a new memory allocation.\n"
  " * This is a performance optimization only; it is especially useful when you\n"
  " * know the number of rows you will be adding ahead of time.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_reserve_num_rows_1054_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexWriter::has_column(void) const
 */
static PyObject *Dtool_GeomVertexWriter_has_column_1055(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexWriter::has_column(void) const
  bool return_value = ((*(const GeomVertexWriter*)local_this).has_column)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_has_column_1055_comment =
  "C++ Interface:\n"
  "has_column(GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Returns true if a valid data type has been successfully set, or false if\n"
  " * the data type does not exist.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_has_column_1055_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexWriter::get_array(void) const
 */
static PyObject *Dtool_GeomVertexWriter_get_array_1056(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-inline int GeomVertexWriter::get_array(void) const
  int return_value = ((*(const GeomVertexWriter*)local_this).get_array)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_get_array_1056_comment =
  "C++ Interface:\n"
  "get_array(GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the array index containing the data type that the writer is working\n"
  " * on.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_get_array_1056_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexColumn const *GeomVertexWriter::get_column(void) const
 */
static PyObject *Dtool_GeomVertexWriter_get_column_1057(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-inline GeomVertexColumn const *GeomVertexWriter::get_column(void) const
  GeomVertexColumn const *return_value = ((*(const GeomVertexWriter*)local_this).get_column)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_get_column_1057_comment =
  "C++ Interface:\n"
  "get_column(GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the description of the data type that the writer is working on.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_get_column_1057_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_row_unsafe(int row)
 */
static PyObject *Dtool_GeomVertexWriter_set_row_unsafe_1058(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_row_unsafe")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_row_unsafe(int row)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_row_unsafe)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_row_unsafe(const GeomVertexWriter self, int row)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_row_unsafe_1058_comment =
  "C++ Interface:\n"
  "set_row_unsafe(const GeomVertexWriter self, int row)\n"
  "\n"
  "/**\n"
  " * Sets the start row to the indicated value, without internal checks.  This\n"
  " * is the same as set_row(), but it does not check for the possibility that\n"
  " * the array has been reallocated internally for some reason; use only when\n"
  " * you are confident that the array is unchanged and you really need every bit\n"
  " * of available performance.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_row_unsafe_1058_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_row(int row)
 */
static PyObject *Dtool_GeomVertexWriter_set_row_1059(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_row")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_row(int row)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_row)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_row(const GeomVertexWriter self, int row)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_row_1059_comment =
  "C++ Interface:\n"
  "set_row(const GeomVertexWriter self, int row)\n"
  "\n"
  "/**\n"
  " * Sets the start row to the indicated value.  The writer will begin writing\n"
  " * to the indicated row; each subsequent set_data*() call will store the data\n"
  " * into the subsequent row.  If set_column() is called, the writer will return\n"
  " * to this row.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_row_1059_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexWriter::get_start_row(void) const
 */
static PyObject *Dtool_GeomVertexWriter_get_start_row_1060(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-inline int GeomVertexWriter::get_start_row(void) const
  int return_value = ((*(const GeomVertexWriter*)local_this).get_start_row)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_get_start_row_1060_comment =
  "C++ Interface:\n"
  "get_start_row(GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the row index at which the writer started.  It will return to this\n"
  " * row if you reset the current column.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_get_start_row_1060_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexWriter::get_write_row(void) const
 */
static PyObject *Dtool_GeomVertexWriter_get_write_row_1061(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-inline int GeomVertexWriter::get_write_row(void) const
  int return_value = ((*(const GeomVertexWriter*)local_this).get_write_row)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_get_write_row_1061_comment =
  "C++ Interface:\n"
  "get_write_row(GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the row index to which the data will be written at the next call to\n"
  " * set_data*() or add_data*().\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_get_write_row_1061_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexWriter::is_at_end(void) const
 */
static PyObject *Dtool_GeomVertexWriter_is_at_end_1062(PyObject *self, PyObject *) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexWriter::is_at_end(void) const
  bool return_value = ((*(const GeomVertexWriter*)local_this).is_at_end)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_is_at_end_1062_comment =
  "C++ Interface:\n"
  "is_at_end(GeomVertexWriter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the writer is currently at the end of the list of vertices,\n"
  " * false otherwise.  If this is true, another call to set_data*() will result\n"
  " * in a crash, but another call to add_data*() will add a new row.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_is_at_end_1062_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data1f(float data)
 */
static PyObject *Dtool_GeomVertexWriter_set_data1f_1063(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data1f")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_data1f(float data)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_data1f)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data1f(const GeomVertexWriter self, float data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data1f_1063_comment =
  "C++ Interface:\n"
  "set_data1f(const GeomVertexWriter self, float data)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 1-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data1f_1063_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data2f(LVecBase2f const &data)
 * inline void GeomVertexWriter::set_data2f(float x, float y)
 */
static PyObject *Dtool_GeomVertexWriter_set_data2f_1064(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data2f")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data2f(LVecBase2f const &data)
        LVecBase2f arg_local;
        LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data2f", "LVecBase2f");
        }
        ((*local_this).set_data2f)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void GeomVertexWriter::set_data2f(float x, float y)
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_data2f", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_data2f)((float)param1, (float)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data2f() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data2f(const GeomVertexWriter self, const LVecBase2f data)\n"
      "set_data2f(const GeomVertexWriter self, float x, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data2f_1064_comment =
  "C++ Interface:\n"
  "set_data2f(const GeomVertexWriter self, const LVecBase2f data)\n"
  "set_data2f(const GeomVertexWriter self, float x, float y)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data2f_1064_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data3f(LVecBase3f const &data)
 * inline void GeomVertexWriter::set_data3f(float x, float y, float z)
 */
static PyObject *Dtool_GeomVertexWriter_set_data3f_1065(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data3f")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data3f(LVecBase3f const &data)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data3f", "LVecBase3f");
        }
        ((*local_this).set_data3f)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void GeomVertexWriter::set_data3f(float x, float y, float z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_data3f", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_data3f)((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data3f() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data3f(const GeomVertexWriter self, const LVecBase3f data)\n"
      "set_data3f(const GeomVertexWriter self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data3f_1065_comment =
  "C++ Interface:\n"
  "set_data3f(const GeomVertexWriter self, const LVecBase3f data)\n"
  "set_data3f(const GeomVertexWriter self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data3f_1065_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data4f(LVecBase4f const &data)
 * inline void GeomVertexWriter::set_data4f(float x, float y, float z, float w)
 */
static PyObject *Dtool_GeomVertexWriter_set_data4f_1066(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data4f")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data4f(LVecBase4f const &data)
        LVecBase4f arg_local;
        LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data4f", "LVecBase4f");
        }
        ((*local_this).set_data4f)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void GeomVertexWriter::set_data4f(float x, float y, float z, float w)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"x", "y", "z", "w", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_data4f", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_data4f)((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data4f() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data4f(const GeomVertexWriter self, const LVecBase4f data)\n"
      "set_data4f(const GeomVertexWriter self, float x, float y, float z, float w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data4f_1066_comment =
  "C++ Interface:\n"
  "set_data4f(const GeomVertexWriter self, const LVecBase4f data)\n"
  "set_data4f(const GeomVertexWriter self, float x, float y, float z, float w)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data4f_1066_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_matrix3f(LMatrix3f const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_set_matrix3f_1067(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_matrix3f")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_matrix3f(LMatrix3f const &mat)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_matrix3f", "LMatrix3f");
  }
  ((*local_this).set_matrix3f)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_matrix3f(const GeomVertexWriter self, const LMatrix3f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_matrix3f_1067_comment =
  "C++ Interface:\n"
  "set_matrix3f(const GeomVertexWriter self, const LMatrix3f mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 3-by-3 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_matrix3f_1067_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_matrix4f(LMatrix4f const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_set_matrix4f_1068(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_matrix4f")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_matrix4f(LMatrix4f const &mat)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_matrix4f", "LMatrix4f");
  }
  ((*local_this).set_matrix4f)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_matrix4f(const GeomVertexWriter self, const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_matrix4f_1068_comment =
  "C++ Interface:\n"
  "set_matrix4f(const GeomVertexWriter self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 4-by-4 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_matrix4f_1068_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data1d(double data)
 */
static PyObject *Dtool_GeomVertexWriter_set_data1d_1069(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data1d")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_data1d(double data)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_data1d)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data1d(const GeomVertexWriter self, double data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data1d_1069_comment =
  "C++ Interface:\n"
  "set_data1d(const GeomVertexWriter self, double data)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 1-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data1d_1069_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data2d(LVecBase2d const &data)
 * inline void GeomVertexWriter::set_data2d(double x, double y)
 */
static PyObject *Dtool_GeomVertexWriter_set_data2d_1070(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data2d")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data2d(LVecBase2d const &data)
        LVecBase2d arg_local;
        LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data2d", "LVecBase2d");
        }
        ((*local_this).set_data2d)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void GeomVertexWriter::set_data2d(double x, double y)
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:set_data2d", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_data2d)((double)param1, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data2d() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data2d(const GeomVertexWriter self, const LVecBase2d data)\n"
      "set_data2d(const GeomVertexWriter self, double x, double y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data2d_1070_comment =
  "C++ Interface:\n"
  "set_data2d(const GeomVertexWriter self, const LVecBase2d data)\n"
  "set_data2d(const GeomVertexWriter self, double x, double y)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data2d_1070_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data3d(LVecBase3d const &data)
 * inline void GeomVertexWriter::set_data3d(double x, double y, double z)
 */
static PyObject *Dtool_GeomVertexWriter_set_data3d_1071(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data3d")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data3d(LVecBase3d const &data)
        LVecBase3d arg_local;
        LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data3d", "LVecBase3d");
        }
        ((*local_this).set_data3d)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void GeomVertexWriter::set_data3d(double x, double y, double z)
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:set_data3d", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_data3d)((double)param1, (double)param2, (double)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data3d() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data3d(const GeomVertexWriter self, const LVecBase3d data)\n"
      "set_data3d(const GeomVertexWriter self, double x, double y, double z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data3d_1071_comment =
  "C++ Interface:\n"
  "set_data3d(const GeomVertexWriter self, const LVecBase3d data)\n"
  "set_data3d(const GeomVertexWriter self, double x, double y, double z)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data3d_1071_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data4d(LVecBase4d const &data)
 * inline void GeomVertexWriter::set_data4d(double x, double y, double z, double w)
 */
static PyObject *Dtool_GeomVertexWriter_set_data4d_1072(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data4d")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data4d(LVecBase4d const &data)
        LVecBase4d arg_local;
        LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data4d", "LVecBase4d");
        }
        ((*local_this).set_data4d)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void GeomVertexWriter::set_data4d(double x, double y, double z, double w)
      double param1;
      double param2;
      double param3;
      double param4;
      static const char *keyword_list[] = {"x", "y", "z", "w", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:set_data4d", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_data4d)((double)param1, (double)param2, (double)param3, (double)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data4d() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data4d(const GeomVertexWriter self, const LVecBase4d data)\n"
      "set_data4d(const GeomVertexWriter self, double x, double y, double z, double w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data4d_1072_comment =
  "C++ Interface:\n"
  "set_data4d(const GeomVertexWriter self, const LVecBase4d data)\n"
  "set_data4d(const GeomVertexWriter self, double x, double y, double z, double w)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data4d_1072_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_matrix3d(LMatrix3d const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_set_matrix3d_1073(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_matrix3d")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_matrix3d(LMatrix3d const &mat)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_matrix3d", "LMatrix3d");
  }
  ((*local_this).set_matrix3d)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_matrix3d(const GeomVertexWriter self, const LMatrix3d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_matrix3d_1073_comment =
  "C++ Interface:\n"
  "set_matrix3d(const GeomVertexWriter self, const LMatrix3d mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 3-by-3 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_matrix3d_1073_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_matrix4d(LMatrix4d const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_set_matrix4d_1074(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_matrix4d")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_matrix4d(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_matrix4d", "LMatrix4d");
  }
  ((*local_this).set_matrix4d)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_matrix4d(const GeomVertexWriter self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_matrix4d_1074_comment =
  "C++ Interface:\n"
  "set_matrix4d(const GeomVertexWriter self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 4-by-4 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_matrix4d_1074_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data1(PN_stdfloat data)
 */
static PyObject *Dtool_GeomVertexWriter_set_data1_1075(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data1")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_data1(PN_stdfloat data)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_data1)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data1(const GeomVertexWriter self, float data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data1_1075_comment =
  "C++ Interface:\n"
  "set_data1(const GeomVertexWriter self, float data)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 1-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data1_1075_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data2(LVecBase2 const &data)
 * inline void GeomVertexWriter::set_data2(PN_stdfloat x, PN_stdfloat y)
 */
static PyObject *Dtool_GeomVertexWriter_set_data2_1076(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data2")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data2(LVecBase2 const &data)
        LVecBase2f arg_local;
        LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data2", "LVecBase2f");
        }
        ((*local_this).set_data2)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void GeomVertexWriter::set_data2(PN_stdfloat x, PN_stdfloat y)
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_data2", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_data2)((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data2() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data2(const GeomVertexWriter self, const LVecBase2f data)\n"
      "set_data2(const GeomVertexWriter self, float x, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data2_1076_comment =
  "C++ Interface:\n"
  "set_data2(const GeomVertexWriter self, const LVecBase2f data)\n"
  "set_data2(const GeomVertexWriter self, float x, float y)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data2_1076_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data3(LVecBase3 const &data)
 * inline void GeomVertexWriter::set_data3(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_GeomVertexWriter_set_data3_1077(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data3")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data3(LVecBase3 const &data)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data3", "LVecBase3f");
        }
        ((*local_this).set_data3)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void GeomVertexWriter::set_data3(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_data3", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_data3)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data3() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data3(const GeomVertexWriter self, const LVecBase3f data)\n"
      "set_data3(const GeomVertexWriter self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data3_1077_comment =
  "C++ Interface:\n"
  "set_data3(const GeomVertexWriter self, const LVecBase3f data)\n"
  "set_data3(const GeomVertexWriter self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data3_1077_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data4(LVecBase4 const &data)
 * inline void GeomVertexWriter::set_data4(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat w)
 */
static PyObject *Dtool_GeomVertexWriter_set_data4_1078(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data4")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data4(LVecBase4 const &data)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data4", "LVecBase4f");
        }
        ((*local_this).set_data4)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void GeomVertexWriter::set_data4(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat w)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"x", "y", "z", "w", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_data4", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_data4)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data4() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data4(const GeomVertexWriter self, const LVecBase4f data)\n"
      "set_data4(const GeomVertexWriter self, float x, float y, float z, float w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data4_1078_comment =
  "C++ Interface:\n"
  "set_data4(const GeomVertexWriter self, const LVecBase4f data)\n"
  "set_data4(const GeomVertexWriter self, float x, float y, float z, float w)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data4_1078_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_matrix3(LMatrix3 const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_set_matrix3_1079(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_matrix3")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_matrix3(LMatrix3 const &mat)
  LMatrix3f arg_local;
  LMatrix3 const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_matrix3", "LMatrix3f");
  }
  ((*local_this).set_matrix3)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_matrix3(const GeomVertexWriter self, const LMatrix3f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_matrix3_1079_comment =
  "C++ Interface:\n"
  "set_matrix3(const GeomVertexWriter self, const LMatrix3f mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 3-by-3 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_matrix3_1079_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_matrix4(LMatrix4 const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_set_matrix4_1080(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_matrix4")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_matrix4(LMatrix4 const &mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_matrix4", "LMatrix4f");
  }
  ((*local_this).set_matrix4)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_matrix4(const GeomVertexWriter self, const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_matrix4_1080_comment =
  "C++ Interface:\n"
  "set_matrix4(const GeomVertexWriter self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 4-by-4 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_matrix4_1080_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data1i(int data)
 */
static PyObject *Dtool_GeomVertexWriter_set_data1i_1081(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data1i")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::set_data1i(int data)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_data1i)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data1i(const GeomVertexWriter self, int data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data1i_1081_comment =
  "C++ Interface:\n"
  "set_data1i(const GeomVertexWriter self, int data)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 1-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data1i_1081_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data2i(LVecBase2i const &data)
 * inline void GeomVertexWriter::set_data2i(int a, int b)
 */
static PyObject *Dtool_GeomVertexWriter_set_data2i_1082(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data2i")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data2i(LVecBase2i const &data)
        LVecBase2i arg_local;
        LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data2i", "LVecBase2i");
        }
        ((*local_this).set_data2i)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void GeomVertexWriter::set_data2i(int a, int b)
      int param1;
      int param2;
      static const char *keyword_list[] = {"a", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_data2i", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_data2i)((int)param1, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data2i() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data2i(const GeomVertexWriter self, const LVecBase2i data)\n"
      "set_data2i(const GeomVertexWriter self, int a, int b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data2i_1082_comment =
  "C++ Interface:\n"
  "set_data2i(const GeomVertexWriter self, const LVecBase2i data)\n"
  "set_data2i(const GeomVertexWriter self, int a, int b)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data2i_1082_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data3i(LVecBase3i const &data)
 * inline void GeomVertexWriter::set_data3i(int a, int b, int c)
 */
static PyObject *Dtool_GeomVertexWriter_set_data3i_1083(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data3i")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data3i(LVecBase3i const &data)
        LVecBase3i arg_local;
        LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data3i", "LVecBase3i");
        }
        ((*local_this).set_data3i)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void GeomVertexWriter::set_data3i(int a, int b, int c)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"a", "b", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:set_data3i", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_data3i)((int)param1, (int)param2, (int)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data3i() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data3i(const GeomVertexWriter self, const LVecBase3i data)\n"
      "set_data3i(const GeomVertexWriter self, int a, int b, int c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data3i_1083_comment =
  "C++ Interface:\n"
  "set_data3i(const GeomVertexWriter self, const LVecBase3i data)\n"
  "set_data3i(const GeomVertexWriter self, int a, int b, int c)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data3i_1083_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::set_data4i(LVecBase4i const &data)
 * inline void GeomVertexWriter::set_data4i(int a, int b, int c, int d)
 */
static PyObject *Dtool_GeomVertexWriter_set_data4i_1084(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.set_data4i")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::set_data4i(LVecBase4i const &data)
        LVecBase4i arg_local;
        LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.set_data4i", "LVecBase4i");
        }
        ((*local_this).set_data4i)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void GeomVertexWriter::set_data4i(int a, int b, int c, int d)
      int param1;
      int param2;
      int param3;
      int param4;
      static const char *keyword_list[] = {"a", "b", "c", "d", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:set_data4i", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_data4i)((int)param1, (int)param2, (int)param3, (int)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data4i() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data4i(const GeomVertexWriter self, const LVecBase4i data)\n"
      "set_data4i(const GeomVertexWriter self, int a, int b, int c, int d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_set_data4i_1084_comment =
  "C++ Interface:\n"
  "set_data4i(const GeomVertexWriter self, const LVecBase4i data)\n"
  "set_data4i(const GeomVertexWriter self, int a, int b, int c, int d)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * It is an error for the write row to advance past the end of data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_set_data4i_1084_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data1f(float data)
 */
static PyObject *Dtool_GeomVertexWriter_add_data1f_1085(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data1f")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::add_data1f(float data)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_data1f)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data1f(const GeomVertexWriter self, float data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data1f_1085_comment =
  "C++ Interface:\n"
  "add_data1f(const GeomVertexWriter self, float data)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 1-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data1f_1085_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data2f(LVecBase2f const &data)
 * inline void GeomVertexWriter::add_data2f(float x, float y)
 */
static PyObject *Dtool_GeomVertexWriter_add_data2f_1086(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data2f")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data2f(LVecBase2f const &data)
        LVecBase2f arg_local;
        LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data2f", "LVecBase2f");
        }
        ((*local_this).add_data2f)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void GeomVertexWriter::add_data2f(float x, float y)
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_data2f", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).add_data2f)((float)param1, (float)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data2f() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data2f(const GeomVertexWriter self, const LVecBase2f data)\n"
      "add_data2f(const GeomVertexWriter self, float x, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data2f_1086_comment =
  "C++ Interface:\n"
  "add_data2f(const GeomVertexWriter self, const LVecBase2f data)\n"
  "add_data2f(const GeomVertexWriter self, float x, float y)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data2f_1086_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data3f(LVecBase3f const &data)
 * inline void GeomVertexWriter::add_data3f(float x, float y, float z)
 */
static PyObject *Dtool_GeomVertexWriter_add_data3f_1087(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data3f")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data3f(LVecBase3f const &data)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data3f", "LVecBase3f");
        }
        ((*local_this).add_data3f)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void GeomVertexWriter::add_data3f(float x, float y, float z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_data3f", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).add_data3f)((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data3f() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data3f(const GeomVertexWriter self, const LVecBase3f data)\n"
      "add_data3f(const GeomVertexWriter self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data3f_1087_comment =
  "C++ Interface:\n"
  "add_data3f(const GeomVertexWriter self, const LVecBase3f data)\n"
  "add_data3f(const GeomVertexWriter self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data3f_1087_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data4f(LVecBase4f const &data)
 * inline void GeomVertexWriter::add_data4f(float x, float y, float z, float w)
 */
static PyObject *Dtool_GeomVertexWriter_add_data4f_1088(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data4f")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data4f(LVecBase4f const &data)
        LVecBase4f arg_local;
        LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data4f", "LVecBase4f");
        }
        ((*local_this).add_data4f)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void GeomVertexWriter::add_data4f(float x, float y, float z, float w)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"x", "y", "z", "w", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:add_data4f", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).add_data4f)((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data4f() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data4f(const GeomVertexWriter self, const LVecBase4f data)\n"
      "add_data4f(const GeomVertexWriter self, float x, float y, float z, float w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data4f_1088_comment =
  "C++ Interface:\n"
  "add_data4f(const GeomVertexWriter self, const LVecBase4f data)\n"
  "add_data4f(const GeomVertexWriter self, float x, float y, float z, float w)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data4f_1088_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_matrix3f(LMatrix3f const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_add_matrix3f_1089(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_matrix3f")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::add_matrix3f(LMatrix3f const &mat)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_matrix3f", "LMatrix3f");
  }
  ((*local_this).add_matrix3f)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_matrix3f(const GeomVertexWriter self, const LMatrix3f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_matrix3f_1089_comment =
  "C++ Interface:\n"
  "add_matrix3f(const GeomVertexWriter self, const LMatrix3f mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 3-by-3 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_matrix3f_1089_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_matrix4f(LMatrix4f const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_add_matrix4f_1090(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_matrix4f")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::add_matrix4f(LMatrix4f const &mat)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_matrix4f", "LMatrix4f");
  }
  ((*local_this).add_matrix4f)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_matrix4f(const GeomVertexWriter self, const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_matrix4f_1090_comment =
  "C++ Interface:\n"
  "add_matrix4f(const GeomVertexWriter self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 4-by-4 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_matrix4f_1090_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data1d(double data)
 */
static PyObject *Dtool_GeomVertexWriter_add_data1d_1091(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data1d")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::add_data1d(double data)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_data1d)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data1d(const GeomVertexWriter self, double data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data1d_1091_comment =
  "C++ Interface:\n"
  "add_data1d(const GeomVertexWriter self, double data)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 1-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data1d_1091_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data2d(LVecBase2d const &data)
 * inline void GeomVertexWriter::add_data2d(double x, double y)
 */
static PyObject *Dtool_GeomVertexWriter_add_data2d_1092(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data2d")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data2d(LVecBase2d const &data)
        LVecBase2d arg_local;
        LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data2d", "LVecBase2d");
        }
        ((*local_this).add_data2d)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void GeomVertexWriter::add_data2d(double x, double y)
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:add_data2d", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).add_data2d)((double)param1, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data2d() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data2d(const GeomVertexWriter self, const LVecBase2d data)\n"
      "add_data2d(const GeomVertexWriter self, double x, double y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data2d_1092_comment =
  "C++ Interface:\n"
  "add_data2d(const GeomVertexWriter self, const LVecBase2d data)\n"
  "add_data2d(const GeomVertexWriter self, double x, double y)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data2d_1092_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data3d(LVecBase3d const &data)
 * inline void GeomVertexWriter::add_data3d(double x, double y, double z)
 */
static PyObject *Dtool_GeomVertexWriter_add_data3d_1093(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data3d")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data3d(LVecBase3d const &data)
        LVecBase3d arg_local;
        LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data3d", "LVecBase3d");
        }
        ((*local_this).add_data3d)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void GeomVertexWriter::add_data3d(double x, double y, double z)
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:add_data3d", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).add_data3d)((double)param1, (double)param2, (double)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data3d() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data3d(const GeomVertexWriter self, const LVecBase3d data)\n"
      "add_data3d(const GeomVertexWriter self, double x, double y, double z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data3d_1093_comment =
  "C++ Interface:\n"
  "add_data3d(const GeomVertexWriter self, const LVecBase3d data)\n"
  "add_data3d(const GeomVertexWriter self, double x, double y, double z)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data3d_1093_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data4d(LVecBase4d const &data)
 * inline void GeomVertexWriter::add_data4d(double x, double y, double z, double w)
 */
static PyObject *Dtool_GeomVertexWriter_add_data4d_1094(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data4d")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data4d(LVecBase4d const &data)
        LVecBase4d arg_local;
        LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data4d", "LVecBase4d");
        }
        ((*local_this).add_data4d)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void GeomVertexWriter::add_data4d(double x, double y, double z, double w)
      double param1;
      double param2;
      double param3;
      double param4;
      static const char *keyword_list[] = {"x", "y", "z", "w", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:add_data4d", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).add_data4d)((double)param1, (double)param2, (double)param3, (double)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data4d() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data4d(const GeomVertexWriter self, const LVecBase4d data)\n"
      "add_data4d(const GeomVertexWriter self, double x, double y, double z, double w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data4d_1094_comment =
  "C++ Interface:\n"
  "add_data4d(const GeomVertexWriter self, const LVecBase4d data)\n"
  "add_data4d(const GeomVertexWriter self, double x, double y, double z, double w)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data4d_1094_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_matrix3d(LMatrix3d const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_add_matrix3d_1095(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_matrix3d")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::add_matrix3d(LMatrix3d const &mat)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_matrix3d", "LMatrix3d");
  }
  ((*local_this).add_matrix3d)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_matrix3d(const GeomVertexWriter self, const LMatrix3d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_matrix3d_1095_comment =
  "C++ Interface:\n"
  "add_matrix3d(const GeomVertexWriter self, const LMatrix3d mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 3-by-3 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_matrix3d_1095_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_matrix4d(LMatrix4d const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_add_matrix4d_1096(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_matrix4d")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::add_matrix4d(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_matrix4d", "LMatrix4d");
  }
  ((*local_this).add_matrix4d)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_matrix4d(const GeomVertexWriter self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_matrix4d_1096_comment =
  "C++ Interface:\n"
  "add_matrix4d(const GeomVertexWriter self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 4-by-4 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_matrix4d_1096_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data1(PN_stdfloat data)
 */
static PyObject *Dtool_GeomVertexWriter_add_data1_1097(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data1")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::add_data1(PN_stdfloat data)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_data1)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data1(const GeomVertexWriter self, float data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data1_1097_comment =
  "C++ Interface:\n"
  "add_data1(const GeomVertexWriter self, float data)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 1-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data1_1097_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data2(LVecBase2 const &data)
 * inline void GeomVertexWriter::add_data2(PN_stdfloat x, PN_stdfloat y)
 */
static PyObject *Dtool_GeomVertexWriter_add_data2_1098(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data2")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data2(LVecBase2 const &data)
        LVecBase2f arg_local;
        LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data2", "LVecBase2f");
        }
        ((*local_this).add_data2)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void GeomVertexWriter::add_data2(PN_stdfloat x, PN_stdfloat y)
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_data2", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).add_data2)((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data2() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data2(const GeomVertexWriter self, const LVecBase2f data)\n"
      "add_data2(const GeomVertexWriter self, float x, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data2_1098_comment =
  "C++ Interface:\n"
  "add_data2(const GeomVertexWriter self, const LVecBase2f data)\n"
  "add_data2(const GeomVertexWriter self, float x, float y)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data2_1098_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data3(LVecBase3 const &data)
 * inline void GeomVertexWriter::add_data3(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_GeomVertexWriter_add_data3_1099(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data3")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data3(LVecBase3 const &data)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data3", "LVecBase3f");
        }
        ((*local_this).add_data3)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void GeomVertexWriter::add_data3(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_data3", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).add_data3)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data3() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data3(const GeomVertexWriter self, const LVecBase3f data)\n"
      "add_data3(const GeomVertexWriter self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data3_1099_comment =
  "C++ Interface:\n"
  "add_data3(const GeomVertexWriter self, const LVecBase3f data)\n"
  "add_data3(const GeomVertexWriter self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data3_1099_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data4(LVecBase4 const &data)
 * inline void GeomVertexWriter::add_data4(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat w)
 */
static PyObject *Dtool_GeomVertexWriter_add_data4_1100(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data4")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data4(LVecBase4 const &data)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data4", "LVecBase4f");
        }
        ((*local_this).add_data4)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void GeomVertexWriter::add_data4(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat w)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"x", "y", "z", "w", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:add_data4", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).add_data4)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data4() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data4(const GeomVertexWriter self, const LVecBase4f data)\n"
      "add_data4(const GeomVertexWriter self, float x, float y, float z, float w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data4_1100_comment =
  "C++ Interface:\n"
  "add_data4(const GeomVertexWriter self, const LVecBase4f data)\n"
  "add_data4(const GeomVertexWriter self, float x, float y, float z, float w)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data4_1100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_matrix3(LMatrix3 const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_add_matrix3_1101(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_matrix3")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::add_matrix3(LMatrix3 const &mat)
  LMatrix3f arg_local;
  LMatrix3 const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_matrix3", "LMatrix3f");
  }
  ((*local_this).add_matrix3)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_matrix3(const GeomVertexWriter self, const LMatrix3f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_matrix3_1101_comment =
  "C++ Interface:\n"
  "add_matrix3(const GeomVertexWriter self, const LMatrix3f mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 3-by-3 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_matrix3_1101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_matrix4(LMatrix4 const &mat)
 */
static PyObject *Dtool_GeomVertexWriter_add_matrix4_1102(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_matrix4")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::add_matrix4(LMatrix4 const &mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_matrix4", "LMatrix4f");
  }
  ((*local_this).add_matrix4)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_matrix4(const GeomVertexWriter self, const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_matrix4_1102_comment =
  "C++ Interface:\n"
  "add_matrix4(const GeomVertexWriter self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a 4-by-4 matrix, and advances the write row.  This is\n"
  " * a special method that can only be used on matrix columns.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_matrix4_1102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data1i(int data)
 */
static PyObject *Dtool_GeomVertexWriter_add_data1i_1103(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data1i")) {
    return nullptr;
  }
  // 1-inline void GeomVertexWriter::add_data1i(int data)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).add_data1i)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data1i(const GeomVertexWriter self, int data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data1i_1103_comment =
  "C++ Interface:\n"
  "add_data1i(const GeomVertexWriter self, int data)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 1-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data1i_1103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data2i(LVecBase2i const &data)
 * inline void GeomVertexWriter::add_data2i(int a, int b)
 */
static PyObject *Dtool_GeomVertexWriter_add_data2i_1104(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data2i")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data2i(LVecBase2i const &data)
        LVecBase2i arg_local;
        LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data2i", "LVecBase2i");
        }
        ((*local_this).add_data2i)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void GeomVertexWriter::add_data2i(int a, int b)
      int param1;
      int param2;
      static const char *keyword_list[] = {"a", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:add_data2i", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).add_data2i)((int)param1, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data2i() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data2i(const GeomVertexWriter self, const LVecBase2i data)\n"
      "add_data2i(const GeomVertexWriter self, int a, int b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data2i_1104_comment =
  "C++ Interface:\n"
  "add_data2i(const GeomVertexWriter self, const LVecBase2i data)\n"
  "add_data2i(const GeomVertexWriter self, int a, int b)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 2-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data2i_1104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data3i(LVecBase3i const &data)
 * inline void GeomVertexWriter::add_data3i(int a, int b, int c)
 */
static PyObject *Dtool_GeomVertexWriter_add_data3i_1105(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data3i")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data3i(LVecBase3i const &data)
        LVecBase3i arg_local;
        LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data3i", "LVecBase3i");
        }
        ((*local_this).add_data3i)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void GeomVertexWriter::add_data3i(int a, int b, int c)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"a", "b", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:add_data3i", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).add_data3i)((int)param1, (int)param2, (int)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data3i() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data3i(const GeomVertexWriter self, const LVecBase3i data)\n"
      "add_data3i(const GeomVertexWriter self, int a, int b, int c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data3i_1105_comment =
  "C++ Interface:\n"
  "add_data3i(const GeomVertexWriter self, const LVecBase3i data)\n"
  "add_data3i(const GeomVertexWriter self, int a, int b, int c)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 3-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data3i_1105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexWriter::add_data4i(LVecBase4i const &data)
 * inline void GeomVertexWriter::add_data4i(int a, int b, int c, int d)
 */
static PyObject *Dtool_GeomVertexWriter_add_data4i_1106(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexWriter, (void **)&local_this, "GeomVertexWriter.add_data4i")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline void GeomVertexWriter::add_data4i(LVecBase4i const &data)
        LVecBase4i arg_local;
        LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexWriter.add_data4i", "LVecBase4i");
        }
        ((*local_this).add_data4i)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void GeomVertexWriter::add_data4i(int a, int b, int c, int d)
      int param1;
      int param2;
      int param3;
      int param4;
      static const char *keyword_list[] = {"a", "b", "c", "d", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:add_data4i", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).add_data4i)((int)param1, (int)param2, (int)param3, (int)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_data4i() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data4i(const GeomVertexWriter self, const LVecBase4i data)\n"
      "add_data4i(const GeomVertexWriter self, int a, int b, int c, int d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_add_data4i_1106_comment =
  "C++ Interface:\n"
  "add_data4i(const GeomVertexWriter self, const LVecBase4i data)\n"
  "add_data4i(const GeomVertexWriter self, int a, int b, int c, int d)\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the write row to a particular 4-component value, and advances the\n"
  " * write row.\n"
  " *\n"
  " * If the write row advances past the end of data, implicitly adds a new row\n"
  " * to the data.\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_add_data4i_1106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexWriter::output(std::ostream &out) const
 */
static PyObject *Dtool_GeomVertexWriter_output_1107(PyObject *self, PyObject *arg) {
  GeomVertexWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexWriter)) {
    return nullptr;
  }
  // 1-void GeomVertexWriter::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GeomVertexWriter.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GeomVertexWriter*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GeomVertexWriter self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexWriter_output_1107_comment =
  "C++ Interface:\n"
  "output(GeomVertexWriter self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexWriter_output_1107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexWriter::GeomVertexWriter(GeomVertexWriter const &copy)
 * inline GeomVertexWriter::GeomVertexWriter(Thread *current_thread = Thread::get_current_thread())
 */
static int Dtool_Init_GeomVertexWriter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline GeomVertexWriter::GeomVertexWriter(Thread *current_thread)
      GeomVertexWriter *return_value = new GeomVertexWriter();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexWriter, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, Thread *current_thread)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "array_data")) {
          GeomVertexArrayData *param0_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          if (param0_this != nullptr) {
            GeomVertexWriter *return_value = new GeomVertexWriter(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexWriter, true, false);
          }
        }
      }

      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, Thread *current_thread)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "vertex_data")) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          if (param0_this != nullptr) {
            GeomVertexWriter *return_value = new GeomVertexWriter(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexWriter, true, false);
          }
        }
      }

      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexWriter const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          GeomVertexWriter const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexWriter);
          if (param0_this != nullptr) {
            GeomVertexWriter *return_value = new GeomVertexWriter(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexWriter, true, false);
          }
        }
      }

      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(Thread *current_thread)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "current_thread")) {
          Thread *param0_this = (Thread *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Thread, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          if (param0_this != nullptr) {
            GeomVertexWriter *return_value = new GeomVertexWriter(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexWriter, true, false);
          }
        }
      }

      // No coercion possible: inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, Thread *current_thread)
      // No coercion possible: inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, Thread *current_thread)
      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexWriter const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          GeomVertexWriter param0_local;
          GeomVertexWriter const *param0_this = Dtool_Coerce_GeomVertexWriter(param0, param0_local);
          if ((param0_this != nullptr)) {
            GeomVertexWriter *return_value = new GeomVertexWriter(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexWriter, true, false);
          }
        }
      }

      // No coercion possible: inline GeomVertexWriter::GeomVertexWriter(Thread *current_thread)
    }
    break;
  case 2:
  case 3:
    {
      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        int param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"array_data", "column", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi|O:GeomVertexWriter", (char **)keyword_list, &param0, &param1, &param2)) {
          GeomVertexArrayData *param0_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexWriter.GeomVertexWriter", false, false);
          }
          if (param0_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            GeomVertexWriter *return_value = new GeomVertexWriter(param0_this, (int)param1, param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexWriter, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"vertex_data", "name", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:GeomVertexWriter", (char **)keyword_list, &param0, &param1, &param2)) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexWriter.GeomVertexWriter", false, false);
          }
          if (param0_this != nullptr && param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            GeomVertexWriter *return_value = new GeomVertexWriter(param0_this, param1_this, param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexWriter, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"array_data", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:GeomVertexWriter", (char **)keyword_list, &param0, &param1)) {
          GeomVertexArrayData *param0_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexWriter.GeomVertexWriter", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            GeomVertexWriter *return_value = new GeomVertexWriter(param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexWriter, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"vertex_data", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:GeomVertexWriter", (char **)keyword_list, &param0, &param1)) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexWriter.GeomVertexWriter", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            GeomVertexWriter *return_value = new GeomVertexWriter(param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexWriter, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = Thread::get_current_thread())
      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"vertex_data", "name", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:GeomVertexWriter", (char **)keyword_list, &param0, &param1, &param2)) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          CPT(InternalName) param1_this;
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexWriter.GeomVertexWriter", false, false);
          }
          if (param0_this != nullptr && Dtool_ConstCoerce_InternalName(param1, param1_this) && (param2 == nullptr || param2_this != nullptr)) {
            GeomVertexWriter *return_value = new GeomVertexWriter(param0_this, std::move(param1_this), param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexWriter, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, Thread *current_thread = Thread::get_current_thread())
      // No coercion possible: inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, Thread *current_thread = Thread::get_current_thread())
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomVertexWriter() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomVertexWriter()\n"
      "GeomVertexWriter(GeomVertexArrayData array_data)\n"
      "GeomVertexWriter(GeomVertexData vertex_data)\n"
      "GeomVertexWriter(const GeomVertexWriter copy)\n"
      "GeomVertexWriter(Thread current_thread)\n"
      "GeomVertexWriter(GeomVertexArrayData array_data, int column, Thread current_thread)\n"
      "GeomVertexWriter(GeomVertexData vertex_data, const InternalName name, Thread current_thread)\n"
      "GeomVertexWriter(GeomVertexArrayData array_data, Thread current_thread)\n"
      "GeomVertexWriter(GeomVertexData vertex_data, Thread current_thread)\n");
  }
  return -1;
}

GeomVertexWriter *Dtool_Coerce_GeomVertexWriter(PyObject *args, GeomVertexWriter &coerced) {
  GeomVertexWriter *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_GeomVertexWriter)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const GeomVertexWriter *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, Thread *current_thread)
      GeomVertexArrayData *arg_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
      if (arg_this != nullptr) {
        coerced = GeomVertexWriter(arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, Thread *current_thread)
      GeomVertexData *arg_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
      if (arg_this != nullptr) {
        coerced = GeomVertexWriter(arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline GeomVertexWriter::GeomVertexWriter(Thread *current_thread)
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
      if (arg_this != nullptr) {
        coerced = GeomVertexWriter(arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        int param1;
        PyObject *param2 = nullptr;
        if (PyArg_ParseTuple(args, "Oi|O:GeomVertexWriter", &param0, &param1, &param2)) {
          GeomVertexArrayData *param0_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexWriter.GeomVertexWriter", false, false);
          }
          if (param0_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            coerced = GeomVertexWriter(param0_this, (int)param1, param2_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        PyObject *param2 = nullptr;
        if (PyArg_UnpackTuple(args, "GeomVertexWriter", 2, 3, &param0, &param1, &param2)) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexWriter.GeomVertexWriter", false, false);
          }
          if (param0_this != nullptr && param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            coerced = GeomVertexWriter(param0_this, param1_this, param2_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "GeomVertexWriter", 2, 2, &param0, &param1)) {
          GeomVertexArrayData *param0_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexWriter.GeomVertexWriter", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            coerced = GeomVertexWriter(param0_this, param1_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "GeomVertexWriter", 2, 2, &param0, &param1)) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexWriter.GeomVertexWriter", false, false);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexWriter.GeomVertexWriter", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            coerced = GeomVertexWriter(param0_this, param1_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_GeomVertexWriter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomVertexWriter) {
    printf("GeomVertexWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomVertexWriter *local_this = (GeomVertexWriter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomVertexWriter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomVertexWriter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomVertexWriter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomVertexWriter*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomVertexRewriter
 */
/**
 * Python function wrapper for:
 * inline void GeomVertexRewriter::operator =(GeomVertexRewriter const &copy)
 */
static PyObject *Dtool_GeomVertexRewriter_operator_1114(PyObject *self, PyObject *arg) {
  GeomVertexRewriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexRewriter, (void **)&local_this, "GeomVertexRewriter.assign")) {
    return nullptr;
  }
  // 1-inline void GeomVertexRewriter::operator =(GeomVertexRewriter const &copy)
  GeomVertexRewriter arg_local;
  GeomVertexRewriter const *arg_this = Dtool_Coerce_GeomVertexRewriter(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeomVertexRewriter.assign", "GeomVertexRewriter");
  }
  ((*local_this).operator =)(*arg_this);
  GeomVertexRewriter *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexRewriter, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GeomVertexRewriter self, const GeomVertexRewriter copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_operator_1114_comment =
  "C++ Interface:\n"
  "assign(const GeomVertexRewriter self, const GeomVertexRewriter copy)\n";
#else
static const char *Dtool_GeomVertexRewriter_operator_1114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexData *GeomVertexRewriter::get_vertex_data(void) const
 */
static PyObject *Dtool_GeomVertexRewriter_get_vertex_data_1116(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexRewriter)) {
    return nullptr;
  }
  // 1-inline GeomVertexData *GeomVertexRewriter::get_vertex_data(void) const
  GeomVertexData *return_value = ((*(const GeomVertexRewriter*)local_this).get_vertex_data)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexData, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_get_vertex_data_1116_comment =
  "C++ Interface:\n"
  "get_vertex_data(GeomVertexRewriter self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex data object that the rewriter is processing.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_get_vertex_data_1116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexArrayData *GeomVertexRewriter::get_array_data(void) const
 */
static PyObject *Dtool_GeomVertexRewriter_get_array_data_1117(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexRewriter)) {
    return nullptr;
  }
  // 1-inline GeomVertexArrayData *GeomVertexRewriter::get_array_data(void) const
  GeomVertexArrayData *return_value = ((*(const GeomVertexRewriter*)local_this).get_array_data)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexArrayData, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_get_array_data_1117_comment =
  "C++ Interface:\n"
  "get_array_data(GeomVertexRewriter self)\n"
  "\n"
  "/**\n"
  " * Returns the particular array object that the rewriter is currently\n"
  " * processing.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_get_array_data_1117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexArrayDataHandle *GeomVertexRewriter::get_array_handle(void) const
 */
static PyObject *Dtool_GeomVertexRewriter_get_array_handle_1118(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexRewriter)) {
    return nullptr;
  }
  // 1-inline GeomVertexArrayDataHandle *GeomVertexRewriter::get_array_handle(void) const
  GeomVertexArrayDataHandle *return_value = ((*(const GeomVertexRewriter*)local_this).get_array_handle)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexArrayDataHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_get_array_handle_1118_comment =
  "C++ Interface:\n"
  "get_array_handle(GeomVertexRewriter self)\n"
  "\n"
  "/**\n"
  " * Returns the write handle to the array object that the rewriter is currently\n"
  " * processing.  This low-level call should be used with caution; be careful\n"
  " * with modifying the data in the handle out from under the\n"
  " * GeomVertexRewriter.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_get_array_handle_1118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t GeomVertexRewriter::get_stride(void) const
 */
static PyObject *Dtool_GeomVertexRewriter_get_stride_1119(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexRewriter)) {
    return nullptr;
  }
  // 1-inline std::size_t GeomVertexRewriter::get_stride(void) const
  std::size_t return_value = ((*(const GeomVertexRewriter*)local_this).get_stride)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_get_stride_1119_comment =
  "C++ Interface:\n"
  "get_stride(GeomVertexRewriter self)\n"
  "\n"
  "/**\n"
  " * Returns the per-row stride (bytes between consecutive rows) of the\n"
  " * underlying vertex array.  This low-level information is normally not needed\n"
  " * to use the GeomVertexRewriter directly.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_get_stride_1119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Thread *GeomVertexRewriter::get_current_thread(void) const
 */
static PyObject *Dtool_GeomVertexRewriter_get_current_thread_1120(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexRewriter)) {
    return nullptr;
  }
  // 1-inline Thread *GeomVertexRewriter::get_current_thread(void) const
  Thread *return_value = ((*(const GeomVertexRewriter*)local_this).get_current_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_get_current_thread_1120_comment =
  "C++ Interface:\n"
  "get_current_thread(GeomVertexRewriter self)\n"
  "\n"
  "/**\n"
  " * Returns the Thread pointer of the currently-executing thread, as passed to\n"
  " * the constructor of this object.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_get_current_thread_1120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexRewriter::set_column(CPT_InternalName name)
 * inline bool GeomVertexRewriter::set_column(int column)
 * inline bool GeomVertexRewriter::set_column(int array, GeomVertexColumn const *column)
 */
static PyObject *Dtool_GeomVertexRewriter_set_column_1121(PyObject *self, PyObject *args, PyObject *kwds) {
  GeomVertexRewriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexRewriter, (void **)&local_this, "GeomVertexRewriter.set_column")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline bool GeomVertexRewriter::set_column(CPT_InternalName name)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "name")) {
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          if (param1_this != nullptr) {
            bool return_value = ((*local_this).set_column)(param1_this);
            return Dtool_Return_Bool(return_value);
          }
        }
      }

      {
        // -2 inline bool GeomVertexRewriter::set_column(int column)
        int param1;
        static const char *keyword_list[] = {"column", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:set_column", (char **)keyword_list, &param1)) {
          bool return_value = ((*local_this).set_column)((int)param1);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool GeomVertexRewriter::set_column(CPT_InternalName name)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "name")) {
          CPT(InternalName) param1_this;
          if (Dtool_ConstCoerce_InternalName(param1, param1_this)) {
            bool return_value = ((*local_this).set_column)(std::move(param1_this));
            return Dtool_Return_Bool(return_value);
          }
        }
      }

      // No coercion possible: inline bool GeomVertexRewriter::set_column(int column)
    }
    break;
  case 2:
    {
      // 1-inline bool GeomVertexRewriter::set_column(int array, GeomVertexColumn const *column)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"array", "column", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_column", (char **)keyword_list, &param1, &param2)) {
        GeomVertexColumn const *param2_this = (GeomVertexColumn *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeomVertexColumn, 2, "GeomVertexRewriter.set_column", true, true);
        if (param2_this != nullptr) {
          bool return_value = ((*local_this).set_column)((int)param1, param2_this);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_column() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_column(const GeomVertexRewriter self, const InternalName name)\n"
      "set_column(const GeomVertexRewriter self, int column)\n"
      "set_column(const GeomVertexRewriter self, int array, const GeomVertexColumn column)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_set_column_1121_comment =
  "C++ Interface:\n"
  "set_column(const GeomVertexRewriter self, const InternalName name)\n"
  "set_column(const GeomVertexRewriter self, int column)\n"
  "set_column(const GeomVertexRewriter self, int array, const GeomVertexColumn column)\n"
  "\n"
  "/**\n"
  " * Sets up the rewriter to use the nth data type of the GeomVertexFormat,\n"
  " * numbering from 0.\n"
  " *\n"
  " * This also resets both the read and write row numbers to the start row (the\n"
  " * same value passed to a previous call to set_row(), or 0 if set_row() was\n"
  " * never called.)\n"
  " *\n"
  " * The return value is true if the data type is valid, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the rewriter to use the data type with the indicated name.\n"
  " *\n"
  " * This also resets both the read and write row numbers to the start row (the\n"
  " * same value passed to a previous call to set_row(), or 0 if set_row() was\n"
  " * never called.)\n"
  " *\n"
  " * The return value is true if the data type is valid, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the rewriter to use the indicated column description on the given\n"
  " * array.\n"
  " *\n"
  " * This also resets both the read and write row numbers to the start row (the\n"
  " * same value passed to a previous call to set_row(), or 0 if set_row() was\n"
  " * never called.)\n"
  " *\n"
  " * The return value is true if the data type is valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_set_column_1121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexRewriter::clear(void)
 */
static PyObject *Dtool_GeomVertexRewriter_clear_1122(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexRewriter, (void **)&local_this, "GeomVertexRewriter.clear")) {
    return nullptr;
  }
  // 1-inline void GeomVertexRewriter::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_clear_1122_comment =
  "C++ Interface:\n"
  "clear(const GeomVertexRewriter self)\n"
  "\n"
  "/**\n"
  " * Resets the GeomVertexRewriter to the initial state.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_clear_1122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexRewriter::has_column(void) const
 */
static PyObject *Dtool_GeomVertexRewriter_has_column_1123(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexRewriter)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexRewriter::has_column(void) const
  bool return_value = ((*(const GeomVertexRewriter*)local_this).has_column)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_has_column_1123_comment =
  "C++ Interface:\n"
  "has_column(GeomVertexRewriter self)\n"
  "\n"
  "/**\n"
  " * Returns true if a valid data type has been successfully set, or false if\n"
  " * the data type does not exist.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_has_column_1123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexRewriter::get_array(void) const
 */
static PyObject *Dtool_GeomVertexRewriter_get_array_1124(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexRewriter)) {
    return nullptr;
  }
  // 1-inline int GeomVertexRewriter::get_array(void) const
  int return_value = ((*(const GeomVertexRewriter*)local_this).get_array)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_get_array_1124_comment =
  "C++ Interface:\n"
  "get_array(GeomVertexRewriter self)\n"
  "\n"
  "/**\n"
  " * Returns the array index containing the data type that the rewriter is\n"
  " * working on.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_get_array_1124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexColumn const *GeomVertexRewriter::get_column(void) const
 */
static PyObject *Dtool_GeomVertexRewriter_get_column_1125(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexRewriter)) {
    return nullptr;
  }
  // 1-inline GeomVertexColumn const *GeomVertexRewriter::get_column(void) const
  GeomVertexColumn const *return_value = ((*(const GeomVertexRewriter*)local_this).get_column)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexColumn, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_get_column_1125_comment =
  "C++ Interface:\n"
  "get_column(GeomVertexRewriter self)\n"
  "\n"
  "/**\n"
  " * Returns the description of the data type that the rewriter is working on.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_get_column_1125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexRewriter::set_row_unsafe(int row)
 */
static PyObject *Dtool_GeomVertexRewriter_set_row_unsafe_1126(PyObject *self, PyObject *arg) {
  GeomVertexRewriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexRewriter, (void **)&local_this, "GeomVertexRewriter.set_row_unsafe")) {
    return nullptr;
  }
  // 1-inline void GeomVertexRewriter::set_row_unsafe(int row)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_row_unsafe)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_row_unsafe(const GeomVertexRewriter self, int row)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_set_row_unsafe_1126_comment =
  "C++ Interface:\n"
  "set_row_unsafe(const GeomVertexRewriter self, int row)\n"
  "\n"
  "/**\n"
  " * Sets the start row to the indicated value, without internal checks.  This\n"
  " * is the same as set_row(), but it does not check for the possibility that\n"
  " * the array has been reallocated internally for some reason; use only when\n"
  " * you are confident that the array is unchanged and you really need every bit\n"
  " * of available performance.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_set_row_unsafe_1126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GeomVertexRewriter::set_row(int row)
 */
static PyObject *Dtool_GeomVertexRewriter_set_row_1127(PyObject *self, PyObject *arg) {
  GeomVertexRewriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexRewriter, (void **)&local_this, "GeomVertexRewriter.set_row")) {
    return nullptr;
  }
  // 1-inline void GeomVertexRewriter::set_row(int row)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_row)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_row(const GeomVertexRewriter self, int row)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_set_row_1127_comment =
  "C++ Interface:\n"
  "set_row(const GeomVertexRewriter self, int row)\n"
  "\n"
  "/**\n"
  " * Sets the start, write, and write index to the indicated value.  The\n"
  " * rewriter will begin traversing from the given row.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_set_row_1127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeomVertexRewriter::get_start_row(void) const
 */
static PyObject *Dtool_GeomVertexRewriter_get_start_row_1128(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexRewriter)) {
    return nullptr;
  }
  // 1-inline int GeomVertexRewriter::get_start_row(void) const
  int return_value = ((*(const GeomVertexRewriter*)local_this).get_start_row)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_get_start_row_1128_comment =
  "C++ Interface:\n"
  "get_start_row(GeomVertexRewriter self)\n"
  "\n"
  "/**\n"
  " * Returns the row index at which the rewriter started.  It will return to\n"
  " * this row if you reset the current column.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_get_start_row_1128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomVertexRewriter::is_at_end(void) const
 */
static PyObject *Dtool_GeomVertexRewriter_is_at_end_1129(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexRewriter)) {
    return nullptr;
  }
  // 1-inline bool GeomVertexRewriter::is_at_end(void) const
  bool return_value = ((*(const GeomVertexRewriter*)local_this).is_at_end)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_is_at_end_1129_comment =
  "C++ Interface:\n"
  "is_at_end(GeomVertexRewriter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the reader or writer is currently at the end of the list of\n"
  " * vertices, false otherwise.\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_is_at_end_1129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GeomVertexRewriter::output(std::ostream &out) const
 */
static PyObject *Dtool_GeomVertexRewriter_output_1130(PyObject *self, PyObject *arg) {
  GeomVertexRewriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeomVertexRewriter)) {
    return nullptr;
  }
  // 1-void GeomVertexRewriter::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GeomVertexRewriter.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GeomVertexRewriter*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GeomVertexRewriter self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_output_1130_comment =
  "C++ Interface:\n"
  "output(GeomVertexRewriter self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GeomVertexRewriter_output_1130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomVertexWriter *GeomVertexRewriter::upcast_to_GeomVertexWriter(void)
 */
static PyObject *Dtool_GeomVertexRewriter_upcast_to_GeomVertexWriter_1109(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexRewriter, (void **)&local_this, "GeomVertexRewriter.upcast_to_GeomVertexWriter")) {
    return nullptr;
  }
  // 1-GeomVertexWriter *GeomVertexRewriter::upcast_to_GeomVertexWriter(void)
  GeomVertexWriter *return_value = (GeomVertexWriter *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexWriter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_upcast_to_GeomVertexWriter_1109_comment =
  "C++ Interface:\n"
  "upcast_to_GeomVertexWriter(const GeomVertexRewriter self)\n"
  "\n"
  "upcast from GeomVertexRewriter to GeomVertexWriter";
#else
static const char *Dtool_GeomVertexRewriter_upcast_to_GeomVertexWriter_1109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomVertexReader *GeomVertexRewriter::upcast_to_GeomVertexReader(void)
 */
static PyObject *Dtool_GeomVertexRewriter_upcast_to_GeomVertexReader_1111(PyObject *self, PyObject *) {
  GeomVertexRewriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomVertexRewriter, (void **)&local_this, "GeomVertexRewriter.upcast_to_GeomVertexReader")) {
    return nullptr;
  }
  // 1-GeomVertexReader *GeomVertexRewriter::upcast_to_GeomVertexReader(void)
  GeomVertexReader *return_value = (GeomVertexReader *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomVertexReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomVertexRewriter_upcast_to_GeomVertexReader_1111_comment =
  "C++ Interface:\n"
  "upcast_to_GeomVertexReader(const GeomVertexRewriter self)\n"
  "\n"
  "upcast from GeomVertexRewriter to GeomVertexReader";
#else
static const char *Dtool_GeomVertexRewriter_upcast_to_GeomVertexReader_1111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, Thread *current_thread = Thread::get_current_thread())
 * inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexRewriter const &copy)
 * inline GeomVertexRewriter::GeomVertexRewriter(Thread *current_thread = Thread::get_current_thread())
 */
static int Dtool_Init_GeomVertexRewriter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline GeomVertexRewriter::GeomVertexRewriter(Thread *current_thread)
      GeomVertexRewriter *return_value = new GeomVertexRewriter();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexRewriter, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, Thread *current_thread)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "array_data")) {
          GeomVertexArrayData *param0_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          if (param0_this != nullptr) {
            GeomVertexRewriter *return_value = new GeomVertexRewriter(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexRewriter, true, false);
          }
        }
      }

      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, Thread *current_thread)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "vertex_data")) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          if (param0_this != nullptr) {
            GeomVertexRewriter *return_value = new GeomVertexRewriter(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexRewriter, true, false);
          }
        }
      }

      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexRewriter const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          GeomVertexRewriter const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomVertexRewriter);
          if (param0_this != nullptr) {
            GeomVertexRewriter *return_value = new GeomVertexRewriter(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexRewriter, true, false);
          }
        }
      }

      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(Thread *current_thread)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "current_thread")) {
          Thread *param0_this = (Thread *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Thread, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          if (param0_this != nullptr) {
            GeomVertexRewriter *return_value = new GeomVertexRewriter(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexRewriter, true, false);
          }
        }
      }

      // No coercion possible: inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, Thread *current_thread)
      // No coercion possible: inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, Thread *current_thread)
      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexRewriter const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          GeomVertexRewriter param0_local;
          GeomVertexRewriter const *param0_this = Dtool_Coerce_GeomVertexRewriter(param0, param0_local);
          if ((param0_this != nullptr)) {
            GeomVertexRewriter *return_value = new GeomVertexRewriter(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexRewriter, true, false);
          }
        }
      }

      // No coercion possible: inline GeomVertexRewriter::GeomVertexRewriter(Thread *current_thread)
    }
    break;
  case 2:
  case 3:
    {
      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        int param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"array_data", "column", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi|O:GeomVertexRewriter", (char **)keyword_list, &param0, &param1, &param2)) {
          GeomVertexArrayData *param0_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          }
          if (param0_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            GeomVertexRewriter *return_value = new GeomVertexRewriter(param0_this, (int)param1, param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexRewriter, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"vertex_data", "name", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:GeomVertexRewriter", (char **)keyword_list, &param0, &param1, &param2)) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          }
          if (param0_this != nullptr && param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            GeomVertexRewriter *return_value = new GeomVertexRewriter(param0_this, param1_this, param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexRewriter, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"array_data", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:GeomVertexRewriter", (char **)keyword_list, &param0, &param1)) {
          GeomVertexArrayData *param0_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            GeomVertexRewriter *return_value = new GeomVertexRewriter(param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexRewriter, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"vertex_data", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:GeomVertexRewriter", (char **)keyword_list, &param0, &param1)) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            GeomVertexRewriter *return_value = new GeomVertexRewriter(param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexRewriter, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = Thread::get_current_thread())
      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        PyObject *param2 = nullptr;
        static const char *keyword_list[] = {"vertex_data", "name", "current_thread", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:GeomVertexRewriter", (char **)keyword_list, &param0, &param1, &param2)) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          CPT(InternalName) param1_this;
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          }
          if (param0_this != nullptr && Dtool_ConstCoerce_InternalName(param1, param1_this) && (param2 == nullptr || param2_this != nullptr)) {
            GeomVertexRewriter *return_value = new GeomVertexRewriter(param0_this, std::move(param1_this), param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomVertexRewriter, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, Thread *current_thread = Thread::get_current_thread())
      // No coercion possible: inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, Thread *current_thread = Thread::get_current_thread())
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomVertexRewriter() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomVertexRewriter()\n"
      "GeomVertexRewriter(GeomVertexArrayData array_data)\n"
      "GeomVertexRewriter(GeomVertexData vertex_data)\n"
      "GeomVertexRewriter(const GeomVertexRewriter copy)\n"
      "GeomVertexRewriter(Thread current_thread)\n"
      "GeomVertexRewriter(GeomVertexArrayData array_data, int column, Thread current_thread)\n"
      "GeomVertexRewriter(GeomVertexData vertex_data, const InternalName name, Thread current_thread)\n"
      "GeomVertexRewriter(GeomVertexArrayData array_data, Thread current_thread)\n"
      "GeomVertexRewriter(GeomVertexData vertex_data, Thread current_thread)\n");
  }
  return -1;
}

GeomVertexRewriter *Dtool_Coerce_GeomVertexRewriter(PyObject *args, GeomVertexRewriter &coerced) {
  GeomVertexRewriter *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_GeomVertexRewriter)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const GeomVertexRewriter *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, Thread *current_thread)
      GeomVertexArrayData *arg_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
      if (arg_this != nullptr) {
        coerced = GeomVertexRewriter(arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, Thread *current_thread)
      GeomVertexData *arg_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
      if (arg_this != nullptr) {
        coerced = GeomVertexRewriter(arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline GeomVertexRewriter::GeomVertexRewriter(Thread *current_thread)
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
      if (arg_this != nullptr) {
        coerced = GeomVertexRewriter(arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        int param1;
        PyObject *param2 = nullptr;
        if (PyArg_ParseTuple(args, "Oi|O:GeomVertexRewriter", &param0, &param1, &param2)) {
          GeomVertexArrayData *param0_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          }
          if (param0_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            coerced = GeomVertexRewriter(param0_this, (int)param1, param2_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        PyObject *param2 = nullptr;
        if (PyArg_UnpackTuple(args, "GeomVertexRewriter", 2, 3, &param0, &param1, &param2)) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          InternalName const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_InternalName);
          Thread *param2_this;
          if (param2 == nullptr) {
            param2_this = Thread::get_current_thread();
          } else {
            param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          }
          if (param0_this != nullptr && param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
            coerced = GeomVertexRewriter(param0_this, param1_this, param2_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "GeomVertexRewriter", 2, 2, &param0, &param1)) {
          GeomVertexArrayData *param0_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexArrayData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            coerced = GeomVertexRewriter(param0_this, param1_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, Thread *current_thread = Thread::get_current_thread())
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "GeomVertexRewriter", 2, 2, &param0, &param1)) {
          GeomVertexData *param0_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GeomVertexData, 0, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "GeomVertexRewriter.GeomVertexRewriter", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            coerced = GeomVertexRewriter(param0_this, param1_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_GeomVertexRewriter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomVertexRewriter) {
    printf("GeomVertexRewriter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomVertexRewriter *local_this = (GeomVertexRewriter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomVertexRewriter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(GeomVertexWriter *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomVertexReader) {
    return (GeomVertexReader *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomVertexWriter) {
    return (GeomVertexWriter *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomVertexRewriter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomVertexRewriter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GeomVertexReader) {
    GeomVertexReader* other_this = (GeomVertexReader*)from_this;
    return (GeomVertexRewriter*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomVertexWriter) {
    GeomVertexWriter* other_this = (GeomVertexWriter*)from_this;
    return (GeomVertexRewriter*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SamplerState
 */
/**
 * Python function wrapper for:
 * static inline SamplerState const &SamplerState::get_default(void)
 */
static PyObject *Dtool_SamplerState_get_default_1135(PyObject *, PyObject *) {
  // 1-static inline SamplerState const &SamplerState::get_default(void)
  SamplerState const *return_value = &((SamplerState::get_default)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SamplerState, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_default_1135_comment =
  "C++ Interface:\n"
  "get_default()\n"
  "\n"
  "/**\n"
  " * Returns a reference to the global default immutable SamplerState object.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_default_1135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SamplerState::set_wrap_u(SamplerState::WrapMode wrap)
 */
static PyObject *Dtool_SamplerState_set_wrap_u_1136(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.set_wrap_u")) {
    return nullptr;
  }
  // 1-inline void SamplerState::set_wrap_u(SamplerState::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_wrap_u)((SamplerState::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_u(const SamplerState self, int wrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_set_wrap_u_1136_comment =
  "C++ Interface:\n"
  "set_wrap_u(const SamplerState self, int wrap)\n"
  "\n"
  "/**\n"
  " * This setting determines what happens when the SamplerState is sampled with\n"
  " * a U value outside the range 0.0-1.0.  The default is WM_repeat, which\n"
  " * indicates that the SamplerState should repeat indefinitely.\n"
  " */";
#else
static const char *Dtool_SamplerState_set_wrap_u_1136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SamplerState::set_wrap_v(SamplerState::WrapMode wrap)
 */
static PyObject *Dtool_SamplerState_set_wrap_v_1137(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.set_wrap_v")) {
    return nullptr;
  }
  // 1-inline void SamplerState::set_wrap_v(SamplerState::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_wrap_v)((SamplerState::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_v(const SamplerState self, int wrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_set_wrap_v_1137_comment =
  "C++ Interface:\n"
  "set_wrap_v(const SamplerState self, int wrap)\n"
  "\n"
  "/**\n"
  " * This setting determines what happens when the SamplerState is sampled with\n"
  " * a V value outside the range 0.0-1.0.  The default is WM_repeat, which\n"
  " * indicates that the SamplerState should repeat indefinitely.\n"
  " */";
#else
static const char *Dtool_SamplerState_set_wrap_v_1137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SamplerState::set_wrap_w(SamplerState::WrapMode wrap)
 */
static PyObject *Dtool_SamplerState_set_wrap_w_1138(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.set_wrap_w")) {
    return nullptr;
  }
  // 1-inline void SamplerState::set_wrap_w(SamplerState::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_wrap_w)((SamplerState::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_w(const SamplerState self, int wrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_set_wrap_w_1138_comment =
  "C++ Interface:\n"
  "set_wrap_w(const SamplerState self, int wrap)\n"
  "\n"
  "/**\n"
  " * The W wrap direction is only used for 3-d SamplerStates.\n"
  " */";
#else
static const char *Dtool_SamplerState_set_wrap_w_1138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SamplerState::set_minfilter(SamplerState::FilterType filter)
 */
static PyObject *Dtool_SamplerState_set_minfilter_1139(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.set_minfilter")) {
    return nullptr;
  }
  // 1-inline void SamplerState::set_minfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_minfilter)((SamplerState::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_minfilter(const SamplerState self, int filter)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_set_minfilter_1139_comment =
  "C++ Interface:\n"
  "set_minfilter(const SamplerState self, int filter)\n"
  "\n"
  "/**\n"
  " * Sets the filtering method that should be used when viewing the SamplerState\n"
  " * from a distance.\n"
  " */";
#else
static const char *Dtool_SamplerState_set_minfilter_1139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SamplerState::set_magfilter(SamplerState::FilterType filter)
 */
static PyObject *Dtool_SamplerState_set_magfilter_1140(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.set_magfilter")) {
    return nullptr;
  }
  // 1-inline void SamplerState::set_magfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_magfilter)((SamplerState::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_magfilter(const SamplerState self, int filter)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_set_magfilter_1140_comment =
  "C++ Interface:\n"
  "set_magfilter(const SamplerState self, int filter)\n"
  "\n"
  "/**\n"
  " * Sets the filtering method that should be used when viewing the SamplerState\n"
  " * up close.\n"
  " */";
#else
static const char *Dtool_SamplerState_set_magfilter_1140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SamplerState::set_anisotropic_degree(int anisotropic_degree)
 */
static PyObject *Dtool_SamplerState_set_anisotropic_degree_1141(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.set_anisotropic_degree")) {
    return nullptr;
  }
  // 1-inline void SamplerState::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_anisotropic_degree)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const SamplerState self, int anisotropic_degree)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_set_anisotropic_degree_1141_comment =
  "C++ Interface:\n"
  "set_anisotropic_degree(const SamplerState self, int anisotropic_degree)\n"
  "\n"
  "/**\n"
  " * Specifies the level of anisotropic filtering to apply to the SamplerState.\n"
  " * Set this 0 to indicate the default value, which is specified in the\n"
  " * SamplerState-anisotropic-degree config variable.\n"
  " *\n"
  " * To explicitly disable anisotropic filtering, set this value to 1.  To\n"
  " * explicitly enable anisotropic filtering, set it to a value higher than 1;\n"
  " * larger numbers indicate greater degrees of filtering.\n"
  " */";
#else
static const char *Dtool_SamplerState_set_anisotropic_degree_1141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SamplerState::set_border_color(LColor const &color)
 */
static PyObject *Dtool_SamplerState_set_border_color_1142(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.set_border_color")) {
    return nullptr;
  }
  // 1-inline void SamplerState::set_border_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SamplerState.set_border_color", "LVecBase4f");
  }
  ((*local_this).set_border_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_border_color(const SamplerState self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_set_border_color_1142_comment =
  "C++ Interface:\n"
  "set_border_color(const SamplerState self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Specifies the solid color of the SamplerState's border.  Some OpenGL\n"
  " * implementations use a border for tiling SamplerStates; in Panda, it is only\n"
  " * used for specifying the clamp color.\n"
  " */";
#else
static const char *Dtool_SamplerState_set_border_color_1142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SamplerState::set_min_lod(PN_stdfloat min_lod)
 */
static PyObject *Dtool_SamplerState_set_min_lod_1143(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.set_min_lod")) {
    return nullptr;
  }
  // 1-inline void SamplerState::set_min_lod(PN_stdfloat min_lod)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_min_lod)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_lod(const SamplerState self, float min_lod)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_set_min_lod_1143_comment =
  "C++ Interface:\n"
  "set_min_lod(const SamplerState self, float min_lod)\n"
  "\n"
  "/**\n"
  " * Sets the minimum level of detail that will be used when sampling this\n"
  " * texture.  This may be a negative value.\n"
  " */";
#else
static const char *Dtool_SamplerState_set_min_lod_1143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SamplerState::set_max_lod(PN_stdfloat max_lod)
 */
static PyObject *Dtool_SamplerState_set_max_lod_1144(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.set_max_lod")) {
    return nullptr;
  }
  // 1-inline void SamplerState::set_max_lod(PN_stdfloat max_lod)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_lod)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_lod(const SamplerState self, float max_lod)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_set_max_lod_1144_comment =
  "C++ Interface:\n"
  "set_max_lod(const SamplerState self, float max_lod)\n"
  "\n"
  "/**\n"
  " * Sets the maximum level of detail that will be used when sampling this\n"
  " * texture.  This may exceed the number of mipmap levels that the texture has.\n"
  " */";
#else
static const char *Dtool_SamplerState_set_max_lod_1144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SamplerState::set_lod_bias(PN_stdfloat lod_bias)
 */
static PyObject *Dtool_SamplerState_set_lod_bias_1145(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.set_lod_bias")) {
    return nullptr;
  }
  // 1-inline void SamplerState::set_lod_bias(PN_stdfloat lod_bias)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_lod_bias)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod_bias(const SamplerState self, float lod_bias)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_set_lod_bias_1145_comment =
  "C++ Interface:\n"
  "set_lod_bias(const SamplerState self, float lod_bias)\n"
  "\n"
  "/**\n"
  " * Sets the value that will be added to the level of detail when sampling the\n"
  " * texture.  This may be a negative value, although some graphics hardware may\n"
  " * not support the use of negative LOD values.\n"
  " */";
#else
static const char *Dtool_SamplerState_set_lod_bias_1145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::WrapMode SamplerState::get_wrap_u(void) const
 */
static PyObject *Dtool_SamplerState_get_wrap_u_1146(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline SamplerState::WrapMode SamplerState::get_wrap_u(void) const
  SamplerState::WrapMode return_value = ((*(const SamplerState*)local_this).get_wrap_u)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_wrap_u_1146_comment =
  "C++ Interface:\n"
  "get_wrap_u(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the wrap mode of the texture in the U direction.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_wrap_u_1146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::WrapMode SamplerState::get_wrap_v(void) const
 */
static PyObject *Dtool_SamplerState_get_wrap_v_1147(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline SamplerState::WrapMode SamplerState::get_wrap_v(void) const
  SamplerState::WrapMode return_value = ((*(const SamplerState*)local_this).get_wrap_v)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_wrap_v_1147_comment =
  "C++ Interface:\n"
  "get_wrap_v(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the wrap mode of the texture in the V direction.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_wrap_v_1147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::WrapMode SamplerState::get_wrap_w(void) const
 */
static PyObject *Dtool_SamplerState_get_wrap_w_1148(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline SamplerState::WrapMode SamplerState::get_wrap_w(void) const
  SamplerState::WrapMode return_value = ((*(const SamplerState*)local_this).get_wrap_w)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_wrap_w_1148_comment =
  "C++ Interface:\n"
  "get_wrap_w(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the wrap mode of the texture in the W direction.  This is the depth\n"
  " * direction of 3-d textures.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_wrap_w_1148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::FilterType SamplerState::get_minfilter(void) const
 */
static PyObject *Dtool_SamplerState_get_minfilter_1149(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline SamplerState::FilterType SamplerState::get_minfilter(void) const
  SamplerState::FilterType return_value = ((*(const SamplerState*)local_this).get_minfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_minfilter_1149_comment =
  "C++ Interface:\n"
  "get_minfilter(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the filter mode of the texture for minification.  If this is one of\n"
  " * the mipmap constants, then the texture requires mipmaps.  This may return\n"
  " * FT_default; see also get_effective_minfilter().\n"
  " */";
#else
static const char *Dtool_SamplerState_get_minfilter_1149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::FilterType SamplerState::get_magfilter(void) const
 */
static PyObject *Dtool_SamplerState_get_magfilter_1150(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline SamplerState::FilterType SamplerState::get_magfilter(void) const
  SamplerState::FilterType return_value = ((*(const SamplerState*)local_this).get_magfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_magfilter_1150_comment =
  "C++ Interface:\n"
  "get_magfilter(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the filter mode of the texture for magnification.  The mipmap\n"
  " * constants are invalid here.  This may return FT_default; see also\n"
  " * get_effective_minfilter().\n"
  " */";
#else
static const char *Dtool_SamplerState_get_magfilter_1150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SamplerState::FilterType SamplerState::get_effective_minfilter(void) const
 */
static PyObject *Dtool_SamplerState_get_effective_minfilter_1151(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-SamplerState::FilterType SamplerState::get_effective_minfilter(void) const
  SamplerState::FilterType return_value = ((*(const SamplerState*)local_this).get_effective_minfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_effective_minfilter_1151_comment =
  "C++ Interface:\n"
  "get_effective_minfilter(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the filter mode of the texture for minification, with special\n"
  " * treatment for FT_default.  This will normally not return FT_default, unless\n"
  " * there is an error in the config file.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_effective_minfilter_1151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SamplerState::FilterType SamplerState::get_effective_magfilter(void) const
 */
static PyObject *Dtool_SamplerState_get_effective_magfilter_1152(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-SamplerState::FilterType SamplerState::get_effective_magfilter(void) const
  SamplerState::FilterType return_value = ((*(const SamplerState*)local_this).get_effective_magfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_effective_magfilter_1152_comment =
  "C++ Interface:\n"
  "get_effective_magfilter(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the filter mode of the texture for magnification, with special\n"
  " * treatment for FT_default.  This will normally not return FT_default, unless\n"
  " * there is an error in the config file.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_effective_magfilter_1152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SamplerState::get_anisotropic_degree(void) const
 */
static PyObject *Dtool_SamplerState_get_anisotropic_degree_1153(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline int SamplerState::get_anisotropic_degree(void) const
  int return_value = ((*(const SamplerState*)local_this).get_anisotropic_degree)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_anisotropic_degree_1153_comment =
  "C++ Interface:\n"
  "get_anisotropic_degree(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the degree of anisotropic filtering that should be applied to the\n"
  " * texture.  This value may return 0, indicating the default value; see also\n"
  " * get_effective_anisotropic_degree.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_anisotropic_degree_1153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SamplerState::get_effective_anisotropic_degree(void) const
 */
static PyObject *Dtool_SamplerState_get_effective_anisotropic_degree_1154(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline int SamplerState::get_effective_anisotropic_degree(void) const
  int return_value = ((*(const SamplerState*)local_this).get_effective_anisotropic_degree)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_effective_anisotropic_degree_1154_comment =
  "C++ Interface:\n"
  "get_effective_anisotropic_degree(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the degree of anisotropic filtering that should be applied to the\n"
  " * texture.  This value will normally not return 0, unless there is an error\n"
  " * in the config file.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_effective_anisotropic_degree_1154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &SamplerState::get_border_color(void) const
 */
static PyObject *Dtool_SamplerState_get_border_color_1155(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline LColor const &SamplerState::get_border_color(void) const
  LColor const *return_value = &(((*(const SamplerState*)local_this).get_border_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_border_color_1155_comment =
  "C++ Interface:\n"
  "get_border_color(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the solid color of the texture's border.  Some OpenGL\n"
  " * implementations use a border for tiling textures; in Panda, it is only used\n"
  " * for specifying the clamp color.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_border_color_1155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SamplerState::get_min_lod(void) const
 */
static PyObject *Dtool_SamplerState_get_min_lod_1156(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat SamplerState::get_min_lod(void) const
  PN_stdfloat return_value = ((*(const SamplerState*)local_this).get_min_lod)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_min_lod_1156_comment =
  "C++ Interface:\n"
  "get_min_lod(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum level of detail that will be observed when sampling\n"
  " * this texture.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_min_lod_1156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SamplerState::get_max_lod(void) const
 */
static PyObject *Dtool_SamplerState_get_max_lod_1157(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat SamplerState::get_max_lod(void) const
  PN_stdfloat return_value = ((*(const SamplerState*)local_this).get_max_lod)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_max_lod_1157_comment =
  "C++ Interface:\n"
  "get_max_lod(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum level of detail that will be observed when sampling\n"
  " * this texture.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_max_lod_1157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SamplerState::get_lod_bias(void) const
 */
static PyObject *Dtool_SamplerState_get_lod_bias_1158(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat SamplerState::get_lod_bias(void) const
  PN_stdfloat return_value = ((*(const SamplerState*)local_this).get_lod_bias)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_lod_bias_1158_comment =
  "C++ Interface:\n"
  "get_lod_bias(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns the bias that will be added to the texture level of detail when\n"
  " * sampling this texture.\n"
  " */";
#else
static const char *Dtool_SamplerState_get_lod_bias_1158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SamplerState::uses_mipmaps(void) const
 */
static PyObject *Dtool_SamplerState_uses_mipmaps_1173(PyObject *self, PyObject *) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-inline bool SamplerState::uses_mipmaps(void) const
  bool return_value = ((*(const SamplerState*)local_this).uses_mipmaps)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_uses_mipmaps_1173_comment =
  "C++ Interface:\n"
  "uses_mipmaps(SamplerState self)\n"
  "\n"
  "/**\n"
  " * Returns true if the minfilter settings on this sampler indicate the use of\n"
  " * mipmapping, false otherwise.\n"
  " */";
#else
static const char *Dtool_SamplerState_uses_mipmaps_1173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool SamplerState::is_mipmap(SamplerState::FilterType type)
 */
static PyObject *Dtool_SamplerState_is_mipmap_1174(PyObject *, PyObject *arg) {
  // 1-static inline bool SamplerState::is_mipmap(SamplerState::FilterType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (SamplerState::is_mipmap)((SamplerState::FilterType)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_mipmap(int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_is_mipmap_1174_comment =
  "C++ Interface:\n"
  "is_mipmap(int type)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated filter type requires the use of mipmaps, or\n"
  " * false if it does not.\n"
  " */";
#else
static const char *Dtool_SamplerState_is_mipmap_1174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string SamplerState::format_filter_type(SamplerState::FilterType ft)
 */
static PyObject *Dtool_SamplerState_format_filter_type_1175(PyObject *, PyObject *arg) {
  // 1-static std::string SamplerState::format_filter_type(SamplerState::FilterType ft)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (SamplerState::format_filter_type)((SamplerState::FilterType)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_filter_type(int ft)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_format_filter_type_1175_comment =
  "C++ Interface:\n"
  "format_filter_type(int ft)\n"
  "\n"
  "/**\n"
  " * Returns the indicated FilterType converted to a string word.\n"
  " */";
#else
static const char *Dtool_SamplerState_format_filter_type_1175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static SamplerState::FilterType SamplerState::string_filter_type(std::string const &str)
 */
static PyObject *Dtool_SamplerState_string_filter_type_1176(PyObject *, PyObject *arg) {
  // 1-static SamplerState::FilterType SamplerState::string_filter_type(std::string const &str)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    SamplerState::FilterType return_value = (SamplerState::string_filter_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_filter_type(str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_string_filter_type_1176_comment =
  "C++ Interface:\n"
  "string_filter_type(str str)\n"
  "\n"
  "/**\n"
  " * Returns the FilterType value associated with the given string\n"
  " * representation, or FT_invalid if the string does not match any known\n"
  " * FilterType value.\n"
  " */";
#else
static const char *Dtool_SamplerState_string_filter_type_1176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string SamplerState::format_wrap_mode(SamplerState::WrapMode wm)
 */
static PyObject *Dtool_SamplerState_format_wrap_mode_1177(PyObject *, PyObject *arg) {
  // 1-static std::string SamplerState::format_wrap_mode(SamplerState::WrapMode wm)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (SamplerState::format_wrap_mode)((SamplerState::WrapMode)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_wrap_mode(int wm)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_format_wrap_mode_1177_comment =
  "C++ Interface:\n"
  "format_wrap_mode(int wm)\n"
  "\n"
  "/**\n"
  " * Returns the indicated WrapMode converted to a string word.\n"
  " */";
#else
static const char *Dtool_SamplerState_format_wrap_mode_1177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static SamplerState::WrapMode SamplerState::string_wrap_mode(std::string const &str)
 */
static PyObject *Dtool_SamplerState_string_wrap_mode_1178(PyObject *, PyObject *arg) {
  // 1-static SamplerState::WrapMode SamplerState::string_wrap_mode(std::string const &str)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    SamplerState::WrapMode return_value = (SamplerState::string_wrap_mode)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_wrap_mode(str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_string_wrap_mode_1178_comment =
  "C++ Interface:\n"
  "string_wrap_mode(str str)\n"
  "\n"
  "/**\n"
  " * Returns the WrapMode value associated with the given string representation,\n"
  " * or WM_invalid if the string does not match any known WrapMode value.\n"
  " */";
#else
static const char *Dtool_SamplerState_string_wrap_mode_1178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SamplerState::prepare(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_SamplerState_prepare_1182(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-void SamplerState::prepare(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "SamplerState.prepare", false, true);
  if (arg_this != nullptr) {
    ((*(const SamplerState*)local_this).prepare)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare(SamplerState self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_prepare_1182_comment =
  "C++ Interface:\n"
  "prepare(SamplerState self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Indicates that the sampler should be enqueued to be prepared in the\n"
  " * indicated prepared_objects at the beginning of the next frame.\n"
  " *\n"
  " * Use this function instead of prepare_now() to preload samplers from a user\n"
  " * interface standpoint.\n"
  " */";
#else
static const char *Dtool_SamplerState_prepare_1182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool SamplerState::is_prepared(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_SamplerState_is_prepared_1183(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-bool SamplerState::is_prepared(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "SamplerState.is_prepared", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const SamplerState*)local_this).is_prepared)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_prepared(SamplerState self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_is_prepared_1183_comment =
  "C++ Interface:\n"
  "is_prepared(SamplerState self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Returns true if the sampler has already been prepared or enqueued for\n"
  " * preparation on the indicated GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_SamplerState_is_prepared_1183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SamplerState::release(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_SamplerState_release_1184(PyObject *self, PyObject *arg) {
  SamplerState *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SamplerState)) {
    return nullptr;
  }
  // 1-void SamplerState::release(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "SamplerState.release", false, true);
  if (arg_this != nullptr) {
    ((*(const SamplerState*)local_this).release)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release(SamplerState self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_release_1184_comment =
  "C++ Interface:\n"
  "release(SamplerState self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Frees the texture context only on the indicated object, if it exists there.\n"
  " * Returns true if it was released, false if it had not been prepared.\n"
  " */";
#else
static const char *Dtool_SamplerState_release_1184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SamplerState::get_class_type(void)
 */
static PyObject *Dtool_SamplerState_get_class_type_1186(PyObject *, PyObject *) {
  // 1-static TypeHandle SamplerState::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((SamplerState::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SamplerState_get_class_type_1186_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SamplerState_get_class_type_1186_comment = nullptr;
#endif

static PyObject *Dtool_SamplerState_wrap_u_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::WrapMode SamplerState::get_wrap_u(void) const
  SamplerState::WrapMode return_value = ((*(const SamplerState*)local_this).get_wrap_u)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SamplerState_wrap_u_Setter(PyObject *self, PyObject *arg, void *) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.wrap_u")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wrap_u attribute");
    return -1;
  }
  // 1-inline void SamplerState::set_wrap_u(SamplerState::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_wrap_u)((SamplerState::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_u(const SamplerState self, int wrap)\n");
  }
  return -1;
}

static PyObject *Dtool_SamplerState_wrap_v_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::WrapMode SamplerState::get_wrap_v(void) const
  SamplerState::WrapMode return_value = ((*(const SamplerState*)local_this).get_wrap_v)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SamplerState_wrap_v_Setter(PyObject *self, PyObject *arg, void *) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.wrap_v")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wrap_v attribute");
    return -1;
  }
  // 1-inline void SamplerState::set_wrap_v(SamplerState::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_wrap_v)((SamplerState::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_v(const SamplerState self, int wrap)\n");
  }
  return -1;
}

static PyObject *Dtool_SamplerState_wrap_w_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::WrapMode SamplerState::get_wrap_w(void) const
  SamplerState::WrapMode return_value = ((*(const SamplerState*)local_this).get_wrap_w)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SamplerState_wrap_w_Setter(PyObject *self, PyObject *arg, void *) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.wrap_w")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wrap_w attribute");
    return -1;
  }
  // 1-inline void SamplerState::set_wrap_w(SamplerState::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_wrap_w)((SamplerState::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_w(const SamplerState self, int wrap)\n");
  }
  return -1;
}

static PyObject *Dtool_SamplerState_minfilter_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::FilterType SamplerState::get_minfilter(void) const
  SamplerState::FilterType return_value = ((*(const SamplerState*)local_this).get_minfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SamplerState_minfilter_Setter(PyObject *self, PyObject *arg, void *) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.minfilter")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete minfilter attribute");
    return -1;
  }
  // 1-inline void SamplerState::set_minfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_minfilter)((SamplerState::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_minfilter(const SamplerState self, int filter)\n");
  }
  return -1;
}

static PyObject *Dtool_SamplerState_magfilter_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::FilterType SamplerState::get_magfilter(void) const
  SamplerState::FilterType return_value = ((*(const SamplerState*)local_this).get_magfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SamplerState_magfilter_Setter(PyObject *self, PyObject *arg, void *) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.magfilter")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete magfilter attribute");
    return -1;
  }
  // 1-inline void SamplerState::set_magfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_magfilter)((SamplerState::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_magfilter(const SamplerState self, int filter)\n");
  }
  return -1;
}

static PyObject *Dtool_SamplerState_effective_minfilter_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-SamplerState::FilterType SamplerState::get_effective_minfilter(void) const
  SamplerState::FilterType return_value = ((*(const SamplerState*)local_this).get_effective_minfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_SamplerState_effective_magfilter_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-SamplerState::FilterType SamplerState::get_effective_magfilter(void) const
  SamplerState::FilterType return_value = ((*(const SamplerState*)local_this).get_effective_magfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_SamplerState_anisotropic_degree_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int SamplerState::get_anisotropic_degree(void) const
  int return_value = ((*(const SamplerState*)local_this).get_anisotropic_degree)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SamplerState_anisotropic_degree_Setter(PyObject *self, PyObject *arg, void *) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.anisotropic_degree")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete anisotropic_degree attribute");
    return -1;
  }
  // 1-inline void SamplerState::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_anisotropic_degree)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const SamplerState self, int anisotropic_degree)\n");
  }
  return -1;
}

static PyObject *Dtool_SamplerState_effective_anisotropic_degree_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int SamplerState::get_effective_anisotropic_degree(void) const
  int return_value = ((*(const SamplerState*)local_this).get_effective_anisotropic_degree)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_SamplerState_border_color_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor const &SamplerState::get_border_color(void) const
  LColor const *return_value = &(((*(const SamplerState*)local_this).get_border_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_SamplerState_border_color_Setter(PyObject *self, PyObject *arg, void *) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.border_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete border_color attribute");
    return -1;
  }
  // 1-inline void SamplerState::set_border_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "SamplerState.set_border_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_border_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_border_color(const SamplerState self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_SamplerState_min_lod_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat SamplerState::get_min_lod(void) const
  PN_stdfloat return_value = ((*(const SamplerState*)local_this).get_min_lod)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SamplerState_min_lod_Setter(PyObject *self, PyObject *arg, void *) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.min_lod")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete min_lod attribute");
    return -1;
  }
  // 1-inline void SamplerState::set_min_lod(PN_stdfloat min_lod)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_min_lod)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_min_lod(const SamplerState self, float min_lod)\n");
  }
  return -1;
}

static PyObject *Dtool_SamplerState_max_lod_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat SamplerState::get_max_lod(void) const
  PN_stdfloat return_value = ((*(const SamplerState*)local_this).get_max_lod)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SamplerState_max_lod_Setter(PyObject *self, PyObject *arg, void *) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.max_lod")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_lod attribute");
    return -1;
  }
  // 1-inline void SamplerState::set_max_lod(PN_stdfloat max_lod)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_lod)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_lod(const SamplerState self, float max_lod)\n");
  }
  return -1;
}

static PyObject *Dtool_SamplerState_lod_bias_Getter(PyObject *self, void *) {
  const SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat SamplerState::get_lod_bias(void) const
  PN_stdfloat return_value = ((*(const SamplerState*)local_this).get_lod_bias)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SamplerState_lod_bias_Setter(PyObject *self, PyObject *arg, void *) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SamplerState, (void **)&local_this, "SamplerState.lod_bias")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete lod_bias attribute");
    return -1;
  }
  // 1-inline void SamplerState::set_lod_bias(PN_stdfloat lod_bias)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_lod_bias)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_lod_bias(const SamplerState self, float lod_bias)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline SamplerState::SamplerState(void)
 * inline SamplerState::SamplerState(SamplerState const &) = default
 */
static int Dtool_Init_SamplerState(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("SamplerState() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline SamplerState::SamplerState(void)
      SamplerState *return_value = new SamplerState();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SamplerState, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline SamplerState::SamplerState(SamplerState const &) = default
      SamplerState const *arg_this = (SamplerState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SamplerState, 0, "SamplerState.SamplerState", true, true);
      if (arg_this != nullptr) {
        SamplerState *return_value = new SamplerState(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SamplerState, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SamplerState() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SamplerState()\n"
      "SamplerState(const SamplerState param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SamplerState(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SamplerState) {
    printf("SamplerState ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SamplerState *local_this = (SamplerState *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SamplerState) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SamplerState(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SamplerState) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Texture
 */
/**
 * Python function wrapper for:
 * inline PointerTo< Texture > Texture::make_copy(void) const
 */
static PyObject *Dtool_Texture_make_copy_1202(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline PointerTo< Texture > Texture::make_copy(void) const
  PointerTo< Texture > return_value = ((*(const Texture*)local_this).make_copy)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Texture *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Texture, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Texture_make_copy_1202_comment =
  "C++ Interface:\n"
  "make_copy(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns a new copy of the same Texture.  This copy, if applied to geometry,\n"
  " * will be copied into texture as a separate texture from the original, so it\n"
  " * will be duplicated in texture memory (and may be independently modified if\n"
  " * desired).\n"
  " *\n"
  " * If the Texture is a VideoTexture, the resulting duplicate may be animated\n"
  " * independently of the original.\n"
  " */";
#else
static const char *Dtool_Texture_make_copy_1202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::clear(void)
 */
static PyObject *Dtool_Texture_clear_1203(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear")) {
    return nullptr;
  }
  // 1-inline void Texture::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_1203_comment =
  "C++ Interface:\n"
  "clear(const Texture self)\n"
  "\n"
  "/**\n"
  " * Reinitializes the texture to its default, empty state (except for the\n"
  " * name).\n"
  " */";
#else
static const char *Dtool_Texture_clear_1203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::setup_texture(Texture::TextureType texture_type, int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format)
 */
static PyObject *Dtool_Texture_setup_texture_1204(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.setup_texture")) {
    return nullptr;
  }
  // 1-inline void Texture::setup_texture(Texture::TextureType texture_type, int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format)
  int param1;
  int param2;
  int param3;
  int param4;
  int param5;
  int param6;
  static const char *keyword_list[] = {"texture_type", "x_size", "y_size", "z_size", "component_type", "format", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiiii:setup_texture", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
    ((*local_this).setup_texture)((Texture::TextureType)param1, (int)param2, (int)param3, (int)param4, (Texture::ComponentType)param5, (Texture::Format)param6);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_texture(const Texture self, int texture_type, int x_size, int y_size, int z_size, int component_type, int format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_setup_texture_1204_comment =
  "C++ Interface:\n"
  "setup_texture(const Texture self, int texture_type, int x_size, int y_size, int z_size, int component_type, int format)\n"
  "\n"
  "/**\n"
  " * Sets the texture to the indicated type and dimensions, presumably in\n"
  " * preparation for calling read() or load(), or set_ram_image() or\n"
  " * modify_ram_image(), or use set_clear_color to let the texture be cleared to\n"
  " * a solid color.\n"
  " */";
#else
static const char *Dtool_Texture_setup_texture_1204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::setup_1d_texture(void)
 * inline void Texture::setup_1d_texture(int x_size, Texture::ComponentType component_type, Texture::Format format)
 */
static PyObject *Dtool_Texture_setup_1d_texture_1205(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.setup_1d_texture")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void Texture::setup_1d_texture(void)
      ((*local_this).setup_1d_texture)();
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void Texture::setup_1d_texture(int x_size, Texture::ComponentType component_type, Texture::Format format)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"x_size", "component_type", "format", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:setup_1d_texture", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).setup_1d_texture)((int)param1, (Texture::ComponentType)param2, (Texture::Format)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "setup_1d_texture() takes 1 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_1d_texture(const Texture self)\n"
      "setup_1d_texture(const Texture self, int x_size, int component_type, int format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_setup_1d_texture_1205_comment =
  "C++ Interface:\n"
  "setup_1d_texture(const Texture self)\n"
  "setup_1d_texture(const Texture self, int x_size, int component_type, int format)\n"
  "\n"
  "/**\n"
  " * Sets the texture as an empty 1-d texture with no dimensions.  Follow up\n"
  " * with read() or load() to fill the texture properties and image data, or use\n"
  " * set_clear_color to let the texture be cleared to a solid color.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the texture as an empty 1-d texture with the specified dimensions and\n"
  " * properties.  Follow up with set_ram_image() or modify_ram_image() to fill\n"
  " * the image data, or use set_clear_color to let the texture be cleared to a\n"
  " * solid color.\n"
  " */";
#else
static const char *Dtool_Texture_setup_1d_texture_1205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::setup_2d_texture(void)
 * inline void Texture::setup_2d_texture(int x_size, int y_size, Texture::ComponentType component_type, Texture::Format format)
 */
static PyObject *Dtool_Texture_setup_2d_texture_1206(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.setup_2d_texture")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void Texture::setup_2d_texture(void)
      ((*local_this).setup_2d_texture)();
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void Texture::setup_2d_texture(int x_size, int y_size, Texture::ComponentType component_type, Texture::Format format)
      int param1;
      int param2;
      int param3;
      int param4;
      static const char *keyword_list[] = {"x_size", "y_size", "component_type", "format", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:setup_2d_texture", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).setup_2d_texture)((int)param1, (int)param2, (Texture::ComponentType)param3, (Texture::Format)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "setup_2d_texture() takes 1 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_2d_texture(const Texture self)\n"
      "setup_2d_texture(const Texture self, int x_size, int y_size, int component_type, int format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_setup_2d_texture_1206_comment =
  "C++ Interface:\n"
  "setup_2d_texture(const Texture self)\n"
  "setup_2d_texture(const Texture self, int x_size, int y_size, int component_type, int format)\n"
  "\n"
  "/**\n"
  " * Sets the texture as an empty 2-d texture with no dimensions.  Follow up\n"
  " * with read() or load() to fill the texture properties and image data, or use\n"
  " * set_clear_color to let the texture be cleared to a solid color.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the texture as an empty 2-d texture with the specified dimensions and\n"
  " * properties.  Follow up with set_ram_image() or modify_ram_image() to fill\n"
  " * the image data, or use set_clear_color to let the texture be cleared to a\n"
  " * solid color.\n"
  " */";
#else
static const char *Dtool_Texture_setup_2d_texture_1206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::setup_3d_texture(int z_size = 1)
 * inline void Texture::setup_3d_texture(int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format)
 */
static PyObject *Dtool_Texture_setup_3d_texture_1207(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.setup_3d_texture")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void Texture::setup_3d_texture(int z_size)
      ((*local_this).setup_3d_texture)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "z_size")) {
        // 1-inline void Texture::setup_3d_texture(int z_size)
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          ((*local_this).setup_3d_texture)((int)arg_val);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 5:
    {
      // 1-inline void Texture::setup_3d_texture(int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format)
      int param1;
      int param2;
      int param3;
      int param4;
      int param5;
      static const char *keyword_list[] = {"x_size", "y_size", "z_size", "component_type", "format", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiii:setup_3d_texture", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).setup_3d_texture)((int)param1, (int)param2, (int)param3, (Texture::ComponentType)param4, (Texture::Format)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "setup_3d_texture() takes 1, 2 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_3d_texture(const Texture self)\n"
      "setup_3d_texture(const Texture self, int z_size)\n"
      "setup_3d_texture(const Texture self, int x_size, int y_size, int z_size, int component_type, int format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_setup_3d_texture_1207_comment =
  "C++ Interface:\n"
  "setup_3d_texture(const Texture self)\n"
  "setup_3d_texture(const Texture self, int z_size)\n"
  "setup_3d_texture(const Texture self, int x_size, int y_size, int z_size, int component_type, int format)\n"
  "\n"
  "/**\n"
  " * Sets the texture as an empty 3-d texture with no dimensions (though if you\n"
  " * know the depth ahead of time, it saves a bit of reallocation later). Follow\n"
  " * up with read() or load() to fill the texture properties and image data, or\n"
  " * use set_clear_color to let the texture be cleared to a solid color.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the texture as an empty 3-d texture with the specified dimensions and\n"
  " * properties.  Follow up with set_ram_image() or modify_ram_image() to fill\n"
  " * the image data.\n"
  " */";
#else
static const char *Dtool_Texture_setup_3d_texture_1207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::setup_cube_map(void)
 * inline void Texture::setup_cube_map(int size, Texture::ComponentType component_type, Texture::Format format)
 */
static PyObject *Dtool_Texture_setup_cube_map_1208(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.setup_cube_map")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void Texture::setup_cube_map(void)
      ((*local_this).setup_cube_map)();
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void Texture::setup_cube_map(int size, Texture::ComponentType component_type, Texture::Format format)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"size", "component_type", "format", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:setup_cube_map", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).setup_cube_map)((int)param1, (Texture::ComponentType)param2, (Texture::Format)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "setup_cube_map() takes 1 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_cube_map(const Texture self)\n"
      "setup_cube_map(const Texture self, int size, int component_type, int format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_setup_cube_map_1208_comment =
  "C++ Interface:\n"
  "setup_cube_map(const Texture self)\n"
  "setup_cube_map(const Texture self, int size, int component_type, int format)\n"
  "\n"
  "/**\n"
  " * Sets the texture as an empty cube map texture with no dimensions.  Follow\n"
  " * up with read() or load() to fill the texture properties and image data, or\n"
  " * use set_clear_color to let the texture be cleared to a solid color.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the texture as an empty cube map texture with the specified dimensions\n"
  " * and properties.  Follow up with set_ram_image() or modify_ram_image() to\n"
  " * fill the image data, or use set_clear_color to let the texture be cleared\n"
  " * to a solid color.\n"
  " *\n"
  " * Note that a cube map should always consist of six square images, so x_size\n"
  " * and y_size will be the same, and z_size is always 6.\n"
  " */";
#else
static const char *Dtool_Texture_setup_cube_map_1208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::setup_2d_texture_array(int z_size = 1)
 * inline void Texture::setup_2d_texture_array(int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format)
 */
static PyObject *Dtool_Texture_setup_2d_texture_array_1209(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.setup_2d_texture_array")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void Texture::setup_2d_texture_array(int z_size)
      ((*local_this).setup_2d_texture_array)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "z_size")) {
        // 1-inline void Texture::setup_2d_texture_array(int z_size)
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          ((*local_this).setup_2d_texture_array)((int)arg_val);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 5:
    {
      // 1-inline void Texture::setup_2d_texture_array(int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format)
      int param1;
      int param2;
      int param3;
      int param4;
      int param5;
      static const char *keyword_list[] = {"x_size", "y_size", "z_size", "component_type", "format", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiii:setup_2d_texture_array", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).setup_2d_texture_array)((int)param1, (int)param2, (int)param3, (Texture::ComponentType)param4, (Texture::Format)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "setup_2d_texture_array() takes 1, 2 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_2d_texture_array(const Texture self)\n"
      "setup_2d_texture_array(const Texture self, int z_size)\n"
      "setup_2d_texture_array(const Texture self, int x_size, int y_size, int z_size, int component_type, int format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_setup_2d_texture_array_1209_comment =
  "C++ Interface:\n"
  "setup_2d_texture_array(const Texture self)\n"
  "setup_2d_texture_array(const Texture self, int z_size)\n"
  "setup_2d_texture_array(const Texture self, int x_size, int y_size, int z_size, int component_type, int format)\n"
  "\n"
  "/**\n"
  " * Sets the texture as an empty 2-d texture array with no dimensions (though\n"
  " * if you know the depth ahead of time, it saves a bit of reallocation later).\n"
  " * Follow up with read() or load() to fill the texture properties and image\n"
  " * data, or use set_clear_color to let the texture be cleared to a solid\n"
  " * color.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the texture as an empty 2-d texture array with the specified\n"
  " * dimensions and properties.  Follow up with set_ram_image() or\n"
  " * modify_ram_image() to fill the image data, or use set_clear_color to let\n"
  " * the texture be cleared to a solid color.\n"
  " */";
#else
static const char *Dtool_Texture_setup_2d_texture_array_1209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::setup_cube_map_array(int num_cube_maps)
 * inline void Texture::setup_cube_map_array(int size, int num_cube_maps, Texture::ComponentType component_type, Texture::Format format)
 */
static PyObject *Dtool_Texture_setup_cube_map_array_1210(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.setup_cube_map_array")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "num_cube_maps")) {
        // 1-inline void Texture::setup_cube_map_array(int num_cube_maps)
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          ((*local_this).setup_cube_map_array)((int)arg_val);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 4:
    {
      // 1-inline void Texture::setup_cube_map_array(int size, int num_cube_maps, Texture::ComponentType component_type, Texture::Format format)
      int param1;
      int param2;
      int param3;
      int param4;
      static const char *keyword_list[] = {"size", "num_cube_maps", "component_type", "format", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:setup_cube_map_array", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).setup_cube_map_array)((int)param1, (int)param2, (Texture::ComponentType)param3, (Texture::Format)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "setup_cube_map_array() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_cube_map_array(const Texture self, int num_cube_maps)\n"
      "setup_cube_map_array(const Texture self, int size, int num_cube_maps, int component_type, int format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_setup_cube_map_array_1210_comment =
  "C++ Interface:\n"
  "setup_cube_map_array(const Texture self, int num_cube_maps)\n"
  "setup_cube_map_array(const Texture self, int size, int num_cube_maps, int component_type, int format)\n"
  "\n"
  "/**\n"
  " * Sets the texture as cube map array with N cube maps.  Note that this number\n"
  " * is not the same as the z_size.  Follow up with read() or load() to fill the\n"
  " * texture properties and image data, or use set_clear_color to let the\n"
  " * texture be cleared to a solid color.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the texture as cube map array with N cube maps with the specified\n"
  " * dimensions and format.  Follow up with set_ram_image() or\n"
  " * modify_ram_image() to fill the image data, or use set_clear_color to let\n"
  " * the texture be cleared to a solid color.\n"
  " *\n"
  " * The num_cube_maps given here is multiplied by six to become the z_size of\n"
  " * the image.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_Texture_setup_cube_map_array_1210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::setup_buffer_texture(int size, Texture::ComponentType component_type, Texture::Format format, GeomEnums::UsageHint usage)
 */
static PyObject *Dtool_Texture_setup_buffer_texture_1211(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.setup_buffer_texture")) {
    return nullptr;
  }
  // 1-inline void Texture::setup_buffer_texture(int size, Texture::ComponentType component_type, Texture::Format format, GeomEnums::UsageHint usage)
  int param1;
  int param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"size", "component_type", "format", "usage", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:setup_buffer_texture", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).setup_buffer_texture)((int)param1, (Texture::ComponentType)param2, (Texture::Format)param3, (GeomEnums::UsageHint)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_buffer_texture(const Texture self, int size, int component_type, int format, int usage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_setup_buffer_texture_1211_comment =
  "C++ Interface:\n"
  "setup_buffer_texture(const Texture self, int size, int component_type, int format, int usage)\n"
  "\n"
  "/**\n"
  " * Sets the texture as an empty buffer texture with the specified size and\n"
  " * properties.  Follow up with set_ram_image() or modify_ram_image() to fill\n"
  " * the image data, or use set_clear_color to let the texture be cleared to a\n"
  " * solid color.\n"
  " *\n"
  " * Note that a buffer texture's format needs to match the component type.\n"
  " */";
#else
static const char *Dtool_Texture_setup_buffer_texture_1211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::generate_normalization_cube_map(int size)
 */
static PyObject *Dtool_Texture_generate_normalization_cube_map_1212(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.generate_normalization_cube_map")) {
    return nullptr;
  }
  // 1-void Texture::generate_normalization_cube_map(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).generate_normalization_cube_map)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generate_normalization_cube_map(const Texture self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_generate_normalization_cube_map_1212_comment =
  "C++ Interface:\n"
  "generate_normalization_cube_map(const Texture self, int size)\n"
  "\n"
  "/**\n"
  " * Generates a special cube map image in the texture that can be used to apply\n"
  " * bump mapping effects: for each texel in the cube map that is indexed by the\n"
  " * 3-d texture coordinates (x, y, z), the resulting value is the normalized\n"
  " * vector (x, y, z) (compressed from -1..1 into 0..1).\n"
  " */";
#else
static const char *Dtool_Texture_generate_normalization_cube_map_1212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::generate_alpha_scale_map(void)
 */
static PyObject *Dtool_Texture_generate_alpha_scale_map_1213(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.generate_alpha_scale_map")) {
    return nullptr;
  }
  // 1-void Texture::generate_alpha_scale_map(void)
  ((*local_this).generate_alpha_scale_map)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_generate_alpha_scale_map_1213_comment =
  "C++ Interface:\n"
  "generate_alpha_scale_map(const Texture self)\n"
  "\n"
  "/**\n"
  " * Generates a special 256x1 1-d texture that can be used to apply an\n"
  " * arbitrary alpha scale to objects by judicious use of texture matrix.  The\n"
  " * texture is a gradient, with an alpha of 0 on the left (U = 0), and 255 on\n"
  " * the right (U = 1).\n"
  " */";
#else
static const char *Dtool_Texture_generate_alpha_scale_map_1213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::clear_image(void)
 */
static PyObject *Dtool_Texture_clear_image_1214(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_image")) {
    return nullptr;
  }
  // 1-inline void Texture::clear_image(void)
  ((*local_this).clear_image)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_image_1214_comment =
  "C++ Interface:\n"
  "clear_image(const Texture self)\n"
  "\n"
  "/**\n"
  " * Clears the texture data without changing its format or resolution.  The\n"
  " * texture is cleared on both the graphics hardware and from RAM, unlike\n"
  " * clear_ram_image, which only removes the data from RAM.\n"
  " *\n"
  " * If a clear color has been specified using set_clear_color, the texture will\n"
  " * be cleared using a solid color.\n"
  " *\n"
  " * The texture data will be cleared the first time in which the texture is\n"
  " * used after this method is called.\n"
  " */";
#else
static const char *Dtool_Texture_clear_image_1214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_clear_color(void) const
 */
static PyObject *Dtool_Texture_has_clear_color_1215(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_clear_color(void) const
  bool return_value = ((*(const Texture*)local_this).has_clear_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_clear_color_1215_comment =
  "C++ Interface:\n"
  "has_clear_color(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a color was previously set using set_clear_color.\n"
  " */";
#else
static const char *Dtool_Texture_has_clear_color_1215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor Texture::get_clear_color(void) const
 */
static PyObject *Dtool_Texture_get_clear_color_1216(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline LColor Texture::get_clear_color(void) const
  LColor *return_value = new LColor(((*(const Texture*)local_this).get_clear_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_clear_color_1216_comment =
  "C++ Interface:\n"
  "get_clear_color(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the color that was previously set using set_clear_color.\n"
  " */";
#else
static const char *Dtool_Texture_get_clear_color_1216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_clear_color(LColor const &color)
 */
static PyObject *Dtool_Texture_set_clear_color_1217(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_clear_color")) {
    return nullptr;
  }
  // 1-inline void Texture::set_clear_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_clear_color", "LVecBase4f");
  }
  ((*local_this).set_clear_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clear_color(const Texture self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_clear_color_1217_comment =
  "C++ Interface:\n"
  "set_clear_color(const Texture self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Sets the color that will be used to fill the texture image in absence of\n"
  " * any image data.  It is used when any of the setup_texture functions or\n"
  " * clear_image is called and image data is not provided using read() or\n"
  " * modify_ram_image().\n"
  " *\n"
  " * This does not affect a texture that has already been cleared; call\n"
  " * clear_image to clear it again.\n"
  " */";
#else
static const char *Dtool_Texture_set_clear_color_1217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::clear_clear_color(void)
 */
static PyObject *Dtool_Texture_clear_clear_color_1218(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_clear_color")) {
    return nullptr;
  }
  // 1-inline void Texture::clear_clear_color(void)
  ((*local_this).clear_clear_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_clear_color_1218_comment =
  "C++ Interface:\n"
  "clear_clear_color(const Texture self)\n"
  "\n"
  "/**\n"
  " * The opposite of set_clear_color.  If the image is cleared after setting\n"
  " * this, its contents may be undefined (or may in fact not be cleared at all).\n"
  " */";
#else
static const char *Dtool_Texture_clear_clear_color_1218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar Texture::get_clear_data(void) const
 */
static PyObject *Dtool_Texture_get_clear_data_1219(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline vector_uchar Texture::get_clear_data(void) const
  vector_uchar return_value = ((*(const Texture*)local_this).get_clear_data)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_clear_data_1219_comment =
  "C++ Interface:\n"
  "get_clear_data(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the raw image data for a single pixel if it were set to the clear\n"
  " * color.\n"
  " */";
#else
static const char *Dtool_Texture_get_clear_data_1219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Texture::read(Filename const &fullpath, Filename const &alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, LoaderOptions const &options = LoaderOptions())
 * bool Texture::read(Filename const &fullpath, Filename const &alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, int z, int n, bool read_pages, bool read_mipmaps, BamCacheRecord *record = nullptr, LoaderOptions const &options = LoaderOptions())
 * bool Texture::read(Filename const &fullpath, LoaderOptions const &options = LoaderOptions())
 * bool Texture::read(Filename const &fullpath, int z, int n, bool read_pages, bool read_mipmaps, LoaderOptions const &options = LoaderOptions())
 */
static PyObject *Dtool_Texture_read_1221(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.read")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "fullpath")) {
        // 1-bool Texture::read(Filename const &fullpath, LoaderOptions const &options)
        Filename arg_local;
        Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "Texture.read", "Filename");
        }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-bool Texture::read(Filename const &fullpath, LoaderOptions const &options)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"fullpath", "options", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:read", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Texture.read", "Filename");
        }
        LoaderOptions param2_local;
        LoaderOptions const *param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Texture.read", "LoaderOptions");
        }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-bool Texture::read(Filename const &fullpath, Filename const &alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, LoaderOptions const &options)
      PyObject *param1;
      PyObject *param2;
      int param3;
      int param4;
      static const char *keyword_list[] = {"fullpath", "alpha_fullpath", "primary_file_num_channels", "alpha_file_channel", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOii:read", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Texture.read", "Filename");
        }
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Texture.read", "Filename");
        }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read)(*param1_this, *param2_this, (int)param3, (int)param4);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 5:
    {
      {
        // -2 bool Texture::read(Filename const &fullpath, int z, int n, bool read_pages, bool read_mipmaps, LoaderOptions const &options)
        PyObject *param1;
        int param2;
        int param3;
        PyObject *param4;
        PyObject *param5;
        static const char *keyword_list[] = {"fullpath", "z", "n", "read_pages", "read_mipmaps", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OiiOO:read", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
          Filename const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
          if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).read)(*param1_this, (int)param2, (int)param3, (PyObject_IsTrue(param4) != 0), (PyObject_IsTrue(param5) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool Texture::read(Filename const &fullpath, Filename const &alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, LoaderOptions const &options)
        PyObject *param1;
        PyObject *param2;
        int param3;
        int param4;
        PyObject *param5;
        static const char *keyword_list[] = {"fullpath", "alpha_fullpath", "primary_file_num_channels", "alpha_file_channel", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOiiO:read", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
          Filename const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
          Filename const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Filename);
          LoaderOptions const *param5_this = nullptr;
          DtoolInstance_GetPointer(param5, param5_this, *Dtool_Ptr_LoaderOptions);
          if (param1_this != nullptr && param2_this != nullptr && param5_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).read)(*param1_this, *param2_this, (int)param3, (int)param4, *param5_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool Texture::read(Filename const &fullpath, int z, int n, bool read_pages, bool read_mipmaps, LoaderOptions const &options)
        PyObject *param1;
        int param2;
        int param3;
        PyObject *param4;
        PyObject *param5;
        static const char *keyword_list[] = {"fullpath", "z", "n", "read_pages", "read_mipmaps", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OiiOO:read", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
          Filename param1_local;
          Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
          if ((param1_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).read)(*param1_this, (int)param2, (int)param3, (PyObject_IsTrue(param4) != 0), (PyObject_IsTrue(param5) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool Texture::read(Filename const &fullpath, Filename const &alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, LoaderOptions const &options)
        PyObject *param1;
        PyObject *param2;
        int param3;
        int param4;
        PyObject *param5;
        static const char *keyword_list[] = {"fullpath", "alpha_fullpath", "primary_file_num_channels", "alpha_file_channel", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOiiO:read", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
          Filename param1_local;
          Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
          Filename param2_local;
          Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
          LoaderOptions param5_local;
          LoaderOptions const *param5_this = Dtool_Coerce_LoaderOptions(param5, param5_local);
          if ((param1_this != nullptr) && (param2_this != nullptr) && (param5_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).read)(*param1_this, *param2_this, (int)param3, (int)param4, *param5_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 6:
    {
      // 1-bool Texture::read(Filename const &fullpath, int z, int n, bool read_pages, bool read_mipmaps, LoaderOptions const &options)
      PyObject *param1;
      int param2;
      int param3;
      PyObject *param4;
      PyObject *param5;
      PyObject *param6;
      static const char *keyword_list[] = {"fullpath", "z", "n", "read_pages", "read_mipmaps", "options", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OiiOOO:read", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Texture.read", "Filename");
        }
        LoaderOptions param6_local;
        LoaderOptions const *param6_this = Dtool_Coerce_LoaderOptions(param6, param6_local);
        if (!(param6_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param6, 6, "Texture.read", "LoaderOptions");
        }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read)(*param1_this, (int)param2, (int)param3, (PyObject_IsTrue(param4) != 0), (PyObject_IsTrue(param5) != 0), *param6_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 8:
  case 9:
  case 10:
    {
      // 1-bool Texture::read(Filename const &fullpath, Filename const &alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, int z, int n, bool read_pages, bool read_mipmaps, BamCacheRecord *record = nullptr, LoaderOptions const &options = LoaderOptions())
      PyObject *param1;
      PyObject *param2;
      int param3;
      int param4;
      int param5;
      int param6;
      PyObject *param7;
      PyObject *param8;
      PyObject *param9 = nullptr;
      PyObject *param10 = nullptr;
      static const char *keyword_list[] = {"fullpath", "alpha_fullpath", "primary_file_num_channels", "alpha_file_channel", "z", "n", "read_pages", "read_mipmaps", "record", "options", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOiiiiOO|OO:read", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Texture.read", "Filename");
        }
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Texture.read", "Filename");
        }
        BamCacheRecord *param9_this = nullptr;
        if (param9 != nullptr && param9 != Py_None) {
          param9_this = (BamCacheRecord *)DTOOL_Call_GetPointerThisClass(param9, Dtool_Ptr_BamCacheRecord, 9, "Texture.read", false, true);
        }
        LoaderOptions param10_local;
        LoaderOptions const *param10_this;
        if (param10 != nullptr) {
          param10_this = Dtool_Coerce_LoaderOptions(param10, param10_local);
        } else {
          param10_local = LoaderOptions();
          param10_this = &param10_local;
        }
        if (param10 != nullptr && !(param10_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param10, 10, "Texture.read", "LoaderOptions");
        }
        if ((param9 == nullptr || param9 == Py_None || param9_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          bool return_value = ((*local_this).read)(*param1_this, *param2_this, (int)param3, (int)param4, (int)param5, (int)param6, (PyObject_IsTrue(param7) != 0), (PyObject_IsTrue(param8) != 0), param9_this, *param10_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "read() takes 2, 3, 5, 6, 7, 9, 10 or 11 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const Texture self, const Filename fullpath)\n"
      "read(const Texture self, const Filename fullpath, const LoaderOptions options)\n"
      "read(const Texture self, const Filename fullpath, const Filename alpha_fullpath, int primary_file_num_channels, int alpha_file_channel)\n"
      "read(const Texture self, const Filename fullpath, int z, int n, bool read_pages, bool read_mipmaps)\n"
      "read(const Texture self, const Filename fullpath, const Filename alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, const LoaderOptions options)\n"
      "read(const Texture self, const Filename fullpath, int z, int n, bool read_pages, bool read_mipmaps, const LoaderOptions options)\n"
      "read(const Texture self, const Filename fullpath, const Filename alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, int z, int n, bool read_pages, bool read_mipmaps, BamCacheRecord record, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_read_1221_comment =
  "C++ Interface:\n"
  "read(const Texture self, const Filename fullpath)\n"
  "read(const Texture self, const Filename fullpath, const LoaderOptions options)\n"
  "read(const Texture self, const Filename fullpath, const Filename alpha_fullpath, int primary_file_num_channels, int alpha_file_channel)\n"
  "read(const Texture self, const Filename fullpath, int z, int n, bool read_pages, bool read_mipmaps)\n"
  "read(const Texture self, const Filename fullpath, const Filename alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, const LoaderOptions options)\n"
  "read(const Texture self, const Filename fullpath, int z, int n, bool read_pages, bool read_mipmaps, const LoaderOptions options)\n"
  "read(const Texture self, const Filename fullpath, const Filename alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, int z, int n, bool read_pages, bool read_mipmaps, BamCacheRecord record, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Reads the named filename into the texture.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Combine a 3-component image with a grayscale image to get a 4-component\n"
  " * image.\n"
  " *\n"
  " * See the description of the full-parameter read() method for the meaning of\n"
  " * the primary_file_num_channels and alpha_file_channel parameters.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads a single file into a single page or mipmap level, or automatically\n"
  " * reads a series of files into a series of pages and/or mipmap levels.\n"
  " *\n"
  " * See the description of the full-parameter read() method for the meaning of\n"
  " * the various parameters.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads the texture from the indicated filename.  If\n"
  " * primary_file_num_channels is not 0, it specifies the number of components\n"
  " * to downgrade the image to if it is greater than this number.\n"
  " *\n"
  " * If the filename has the extension .txo, this implicitly reads a texture\n"
  " * object instead of a filename (which replaces all of the texture\n"
  " * properties).  In this case, all the rest of the parameters are ignored, and\n"
  " * the filename should not contain any hash marks; just the one named file\n"
  " * will be read, since a single .txo file can contain all pages and mipmaps\n"
  " * necessary to define a texture.\n"
  " *\n"
  " * If alpha_fullpath is not empty, it specifies the name of a file from which\n"
  " * to retrieve the alpha.  In this case, alpha_file_channel represents the\n"
  " * numeric channel of this image file to use as the resulting texture's alpha\n"
  " * channel; usually, this is 0 to indicate the grayscale combination of r, g,\n"
  " * b; or it may be a one-based channel number, e.g.  1 for the red channel, 2\n"
  " * for the green channel, and so on.\n"
  " *\n"
  " * If read pages is false, then z indicates the page number into which this\n"
  " * image will be assigned.  Normally this is 0 for the first (or only) page of\n"
  " * the texture.  3-D textures have one page for each level of depth, and cube\n"
  " * map textures always have six pages.\n"
  " *\n"
  " * If read_pages is true, multiple images will be read at once, one for each\n"
  " * page of a cube map or a 3-D texture.  In this case, the filename should\n"
  " * contain a sequence of one or more hash marks (\"#\") which will be filled in\n"
  " * with the z value of each page, zero-based.  In this case, the z parameter\n"
  " * indicates the maximum z value that will be loaded, or 0 to load all\n"
  " * filenames that exist.\n"
  " *\n"
  " * If read_mipmaps is false, then n indicates the mipmap level to which this\n"
  " * image will be assigned.  Normally this is 0 for the base texture image, but\n"
  " * it is possible to load custom mipmap levels into the later images.  After\n"
  " * the base texture image is loaded (thus defining the size of the texture),\n"
  " * you can call get_expected_num_mipmap_levels() to determine the maximum\n"
  " * sensible value for n.\n"
  " *\n"
  " * If read_mipmaps is true, multiple images will be read as above, but this\n"
  " * time the images represent the different mipmap levels of the texture image.\n"
  " * In this case, the n parameter indicates the maximum n value that will be\n"
  " * loaded, or 0 to load all filenames that exist (up to the expected number of\n"
  " * mipmap levels).\n"
  " *\n"
  " * If both read_pages and read_mipmaps is true, then both sequences will be\n"
  " * read; the filename should contain two sequences of hash marks, separated by\n"
  " * some character such as a hyphen, underscore, or dot.  The first hash mark\n"
  " * sequence will be filled in with the mipmap level, while the second hash\n"
  " * mark sequence will be the page index.\n"
  " *\n"
  " * This method implicitly sets keep_ram_image to false.\n"
  " */";
#else
static const char *Dtool_Texture_read_1221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::write(Filename const &fullpath)
 * inline bool Texture::write(Filename const &fullpath, int z, int n, bool write_pages, bool write_mipmaps)
 * void Texture::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_Texture_write_1222(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        PyObject *arg;
        if (Dtool_ExtractArg(&arg, args, kwds, "fullpath")) {
          // 1-inline bool Texture::write(Filename const &fullpath)
          Filename arg_local;
          Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
          if (!(arg_this != nullptr)) {
            return Dtool_Raise_ArgTypeError(arg, 1, "Texture.write", "Filename");
          }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          bool return_value = ((*local_this).write)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          return Dtool_Return_Bool(return_value);
        }
      } else {
#ifdef NDEBUG
        return Dtool_Raise_TypeError("non-const method called on const object");
#else
        return Dtool_Raise_TypeError("Cannot call Texture.write() on a const object.");
#endif
      }
    }
    break;
  case 2:
    {
      // 1-void Texture::write(std::ostream &out, int indent_level) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"out", "indent_level", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
        std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Texture.write", false, true);
        if (param1_this != nullptr) {
          ((*(const Texture*)local_this).write)(*param1_this, (int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 5:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        // 1-inline bool Texture::write(Filename const &fullpath, int z, int n, bool write_pages, bool write_mipmaps)
        PyObject *param1;
        int param2;
        int param3;
        PyObject *param4;
        PyObject *param5;
        static const char *keyword_list[] = {"fullpath", "z", "n", "write_pages", "write_mipmaps", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OiiOO:write", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
          Filename param1_local;
          Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
          if (!(param1_this != nullptr)) {
            return Dtool_Raise_ArgTypeError(param1, 1, "Texture.write", "Filename");
          }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          bool return_value = ((*local_this).write)(*param1_this, (int)param2, (int)param3, (PyObject_IsTrue(param4) != 0), (PyObject_IsTrue(param5) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          return Dtool_Return_Bool(return_value);
        }
      } else {
#ifdef NDEBUG
        return Dtool_Raise_TypeError("non-const method called on const object");
#else
        return Dtool_Raise_TypeError("Cannot call Texture.write() on a const object.");
#endif
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write() takes 2, 3 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(const Texture self, const Filename fullpath)\n"
      "write(Texture self, ostream out, int indent_level)\n"
      "write(const Texture self, const Filename fullpath, int z, int n, bool write_pages, bool write_mipmaps)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_write_1222_comment =
  "C++ Interface:\n"
  "write(const Texture self, const Filename fullpath)\n"
  "write(Texture self, ostream out, int indent_level)\n"
  "write(const Texture self, const Filename fullpath, int z, int n, bool write_pages, bool write_mipmaps)\n"
  "\n"
  "/**\n"
  " * Writes the texture to the named filename.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes a single page or mipmap level to a single file, or automatically\n"
  " * writes a series of pages and/or mipmap levels to a numbered series of\n"
  " * files.\n"
  " *\n"
  " * If the filename ends in the extension .txo, this implicitly writes a Panda\n"
  " * texture object (.txo) instead of an image file.  In this case, the\n"
  " * remaining parameters are ignored, and only one file is written, which will\n"
  " * contain all of the pages and resident mipmap levels in the texture.\n"
  " *\n"
  " * If write_pages is false, then z indicates the page number to write.  3-D\n"
  " * textures have one page number for each level of depth; cube maps have six\n"
  " * pages number 0 through 5.  Other kinds of textures have only one page,\n"
  " * numbered 0.  If there are multiple views, the range of z is increased; the\n"
  " * total range is [0, get_num_pages()).\n"
  " *\n"
  " * If write_pages is true, then all pages of the texture will be written.  In\n"
  " * this case z is ignored, and the filename should contain a sequence of hash\n"
  " * marks (\"#\") which will be filled in with the page index number.\n"
  " *\n"
  " * If write_mipmaps is false, then n indicates the mipmap level number to\n"
  " * write.  Normally, this is 0, for the base texture image.  Normally, the\n"
  " * mipmap levels of a texture are not available in RAM (they are generated\n"
  " * automatically by the graphics card). However, if you have the mipmap levels\n"
  " * available, for instance because you called generate_ram_mipmap_images() to\n"
  " * generate them internally, or you called\n"
  " * GraphicsEngine::extract_texture_data() to retrieve them from the graphics\n"
  " * card, then you may write out each mipmap level with this parameter.\n"
  " *\n"
  " * If write_mipmaps is true, then all mipmap levels of the texture will be\n"
  " * written.  In this case n is ignored, and the filename should contain a\n"
  " * sequence of hash marks (\"#\") which will be filled in with the mipmap level\n"
  " * number.\n"
  " *\n"
  " * If both write_pages and write_mipmaps is true, then all pages and all\n"
  " * mipmap levels will be written.  In this case, the filename should contain\n"
  " * two different sequences of hash marks, separated by a character such as a\n"
  " * hyphen, underscore, or dot.  The first hash mark sequence will be filled in\n"
  " * with the mipmap level, while the second hash mark sequence will be the page\n"
  " * index.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Not to be confused with write(Filename), this method simply describes the\n"
  " * texture properties.\n"
  " */";
#else
static const char *Dtool_Texture_write_1222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Texture::read_txo(std::istream &in, std::string const &filename = "")
 */
static PyObject *Dtool_Texture_read_txo_1223(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.read_txo")) {
    return nullptr;
  }
  // 1-bool Texture::read_txo(std::istream &in, std::string const &filename = "")
  PyObject *param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"in", "filename", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:read_txo", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "Texture.read_txo", false, true);
    if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*local_this).read_txo)(*param1_this, std::string(param2_str, param2_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_txo(const Texture self, istream in, str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_read_txo_1223_comment =
  "C++ Interface:\n"
  "read_txo(const Texture self, istream in, str filename)\n"
  "\n"
  "/**\n"
  " * Reads the texture from a Panda texture object.  This defines the complete\n"
  " * Texture specification, including the image data as well as all texture\n"
  " * properties.  This only works if the txo file contains a static Texture\n"
  " * image, as opposed to a subclass of Texture such as a movie texture.\n"
  " *\n"
  " * Pass a real filename if it is available, or empty string if it is not.\n"
  " */";
#else
static const char *Dtool_Texture_read_txo_1223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< Texture > Texture::make_from_txo(std::istream &in, std::string const &filename = "")
 */
static PyObject *Dtool_Texture_make_from_txo_1224(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< Texture > Texture::make_from_txo(std::istream &in, std::string const &filename = "")
  PyObject *param0;
  const char *param1_str = "";
  Py_ssize_t param1_len = 0;
  static const char *keyword_list[] = {"in", "filename", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:make_from_txo", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    std::istream *param0_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_istream, 0, "Texture.make_from_txo", false, true);
    if (param0_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      PointerTo< Texture > return_value = (Texture::make_from_txo)(*param0_this, std::string(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      Texture *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Texture, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_from_txo(istream in, str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_make_from_txo_1224_comment =
  "C++ Interface:\n"
  "make_from_txo(istream in, str filename)\n"
  "\n"
  "/**\n"
  " * Constructs a new Texture object from the txo file.  This is similar to\n"
  " * Texture::read_txo(), but it constructs and returns a new object, which\n"
  " * allows it to return a subclass of Texture (for instance, a movie texture).\n"
  " *\n"
  " * Pass a real filename if it is available, or empty string if it is not.\n"
  " */";
#else
static const char *Dtool_Texture_make_from_txo_1224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Texture::write_txo(std::ostream &out, std::string const &filename = "") const
 */
static PyObject *Dtool_Texture_write_txo_1225(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-bool Texture::write_txo(std::ostream &out, std::string const &filename = "") const
  PyObject *param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"out", "filename", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:write_txo", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Texture.write_txo", false, true);
    if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*(const Texture*)local_this).write_txo)(*param1_this, std::string(param2_str, param2_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_txo(Texture self, ostream out, str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_write_txo_1225_comment =
  "C++ Interface:\n"
  "write_txo(Texture self, ostream out, str filename)\n"
  "\n"
  "/**\n"
  " * Writes the texture to a Panda texture object.  This defines the complete\n"
  " * Texture specification, including the image data as well as all texture\n"
  " * properties.\n"
  " *\n"
  " * The filename is just for reference.\n"
  " */";
#else
static const char *Dtool_Texture_write_txo_1225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Texture::read_dds(std::istream &in, std::string const &filename = "", bool header_only = false)
 */
static PyObject *Dtool_Texture_read_dds_1226(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.read_dds")) {
    return nullptr;
  }
  // 1-bool Texture::read_dds(std::istream &in, std::string const &filename = "", bool header_only = false)
  PyObject *param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  PyObject *param3 = Py_False;
  static const char *keyword_list[] = {"in", "filename", "header_only", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#O:read_dds", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
    std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "Texture.read_dds", false, true);
    if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*local_this).read_dds)(*param1_this, std::string(param2_str, param2_len), (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_dds(const Texture self, istream in, str filename, bool header_only)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_read_dds_1226_comment =
  "C++ Interface:\n"
  "read_dds(const Texture self, istream in, str filename, bool header_only)\n"
  "\n"
  "/**\n"
  " * Reads the texture from a DDS file object.  This is a Microsoft-defined file\n"
  " * format; it is similar in principle to a txo object, in that it is designed\n"
  " * to contain the texture image in a form as similar as possible to its\n"
  " * runtime image, and it can contain mipmaps, pre-compressed textures, and so\n"
  " * on.\n"
  " *\n"
  " * As with read_txo, the filename is just for reference.\n"
  " */";
#else
static const char *Dtool_Texture_read_dds_1226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Texture::read_ktx(std::istream &in, std::string const &filename = "", bool header_only = false)
 */
static PyObject *Dtool_Texture_read_ktx_1227(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.read_ktx")) {
    return nullptr;
  }
  // 1-bool Texture::read_ktx(std::istream &in, std::string const &filename = "", bool header_only = false)
  PyObject *param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  PyObject *param3 = Py_False;
  static const char *keyword_list[] = {"in", "filename", "header_only", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#O:read_ktx", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
    std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "Texture.read_ktx", false, true);
    if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*local_this).read_ktx)(*param1_this, std::string(param2_str, param2_len), (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_ktx(const Texture self, istream in, str filename, bool header_only)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_read_ktx_1227_comment =
  "C++ Interface:\n"
  "read_ktx(const Texture self, istream in, str filename, bool header_only)\n"
  "\n"
  "/**\n"
  " * Reads the texture from a KTX file object.  This is a Khronos-defined file\n"
  " * format; it is similar in principle to a dds object, in that it is designed\n"
  " * to contain the texture image in a form as similar as possible to its\n"
  " * runtime image, and it can contain mipmaps, pre-compressed textures, and so\n"
  " * on.\n"
  " *\n"
  " * As with read_dds, the filename is just for reference.\n"
  " */";
#else
static const char *Dtool_Texture_read_ktx_1227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::load(PNMImage const &pnmimage, LoaderOptions const &options = LoaderOptions())
 * inline bool Texture::load(PNMImage const &pnmimage, int z, int n, LoaderOptions const &options = LoaderOptions())
 * inline bool Texture::load(PfmFile const &pfm, LoaderOptions const &options = LoaderOptions())
 * inline bool Texture::load(PfmFile const &pfm, int z, int n, LoaderOptions const &options = LoaderOptions())
 */
static PyObject *Dtool_Texture_load_1228(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.load")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline bool Texture::load(PNMImage const &pnmimage, LoaderOptions const &options)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "pnmimage")) {
          PNMImage const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PNMImage);
          if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
      }

      {
        // -2 inline bool Texture::load(PfmFile const &pfm, LoaderOptions const &options)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "pfm")) {
          PfmFile const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PfmFile);
          if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
      }

      {
        // -2 inline bool Texture::load(PNMImage const &pnmimage, LoaderOptions const &options)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "pnmimage")) {
          PNMImage const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PNMImage);
          if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
      }

      {
        // -2 inline bool Texture::load(PfmFile const &pfm, LoaderOptions const &options)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "pfm")) {
          PfmFile const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PfmFile);
          if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
      }

    }
    break;
  case 2:
    {
      {
        // -2 inline bool Texture::load(PNMImage const &pnmimage, LoaderOptions const &options)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"pnmimage", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:load", (char **)keyword_list, &param1, &param2)) {
          PNMImage const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PNMImage);
          LoaderOptions const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LoaderOptions);
          if (param1_this != nullptr && param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool Texture::load(PfmFile const &pfm, LoaderOptions const &options)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"pfm", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:load", (char **)keyword_list, &param1, &param2)) {
          PfmFile const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PfmFile);
          LoaderOptions const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LoaderOptions);
          if (param1_this != nullptr && param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool Texture::load(PNMImage const &pnmimage, LoaderOptions const &options)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"pnmimage", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:load", (char **)keyword_list, &param1, &param2)) {
          PNMImage const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PNMImage);
          LoaderOptions param2_local;
          LoaderOptions const *param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
          if (param1_this != nullptr && (param2_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool Texture::load(PfmFile const &pfm, LoaderOptions const &options)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"pfm", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:load", (char **)keyword_list, &param1, &param2)) {
          PfmFile const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PfmFile);
          LoaderOptions param2_local;
          LoaderOptions const *param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
          if (param1_this != nullptr && (param2_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 inline bool Texture::load(PNMImage const &pnmimage, int z, int n, LoaderOptions const &options = LoaderOptions())
        PyObject *param1;
        int param2;
        int param3;
        PyObject *param4 = nullptr;
        static const char *keyword_list[] = {"pnmimage", "z", "n", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|O:load", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          PNMImage const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PNMImage);
          LoaderOptions const *param4_this;
          const LoaderOptions &param4_ref = LoaderOptions();
          if (param4 == nullptr) {
            param4_this = &param4_ref;
          } else {
            param4_this = nullptr;
            DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_LoaderOptions);
          }
          if (param1_this != nullptr && (param4 == nullptr || param4_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this, (int)param2, (int)param3, *param4_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool Texture::load(PfmFile const &pfm, int z, int n, LoaderOptions const &options = LoaderOptions())
        PyObject *param1;
        int param2;
        int param3;
        PyObject *param4 = nullptr;
        static const char *keyword_list[] = {"pfm", "z", "n", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|O:load", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          PfmFile const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PfmFile);
          LoaderOptions const *param4_this;
          const LoaderOptions &param4_ref = LoaderOptions();
          if (param4 == nullptr) {
            param4_this = &param4_ref;
          } else {
            param4_this = nullptr;
            DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_LoaderOptions);
          }
          if (param1_this != nullptr && (param4 == nullptr || param4_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this, (int)param2, (int)param3, *param4_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool Texture::load(PNMImage const &pnmimage, int z, int n, LoaderOptions const &options = LoaderOptions())
        PyObject *param1;
        int param2;
        int param3;
        PyObject *param4 = nullptr;
        static const char *keyword_list[] = {"pnmimage", "z", "n", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|O:load", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          PNMImage const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PNMImage);
          LoaderOptions param4_local;
          LoaderOptions const *param4_this;
          if (param4 != nullptr) {
            param4_this = Dtool_Coerce_LoaderOptions(param4, param4_local);
          } else {
            param4_local = LoaderOptions();
            param4_this = &param4_local;
          }
          if (param1_this != nullptr && (param4 == nullptr || (param4_this != nullptr))) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this, (int)param2, (int)param3, *param4_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool Texture::load(PfmFile const &pfm, int z, int n, LoaderOptions const &options = LoaderOptions())
        PyObject *param1;
        int param2;
        int param3;
        PyObject *param4 = nullptr;
        static const char *keyword_list[] = {"pfm", "z", "n", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|O:load", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          PfmFile const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_PfmFile);
          LoaderOptions param4_local;
          LoaderOptions const *param4_this;
          if (param4 != nullptr) {
            param4_this = Dtool_Coerce_LoaderOptions(param4, param4_local);
          } else {
            param4_local = LoaderOptions();
            param4_this = &param4_local;
          }
          if (param1_this != nullptr && (param4 == nullptr || (param4_this != nullptr))) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).load)(*param1_this, (int)param2, (int)param3, *param4_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "load() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load(const Texture self, const PNMImage pnmimage)\n"
      "load(const Texture self, const PfmFile pfm)\n"
      "load(const Texture self, const PNMImage pnmimage, const LoaderOptions options)\n"
      "load(const Texture self, const PfmFile pfm, const LoaderOptions options)\n"
      "load(const Texture self, const PNMImage pnmimage, int z, int n, const LoaderOptions options)\n"
      "load(const Texture self, const PfmFile pfm, int z, int n, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_load_1228_comment =
  "C++ Interface:\n"
  "load(const Texture self, const PNMImage pnmimage)\n"
  "load(const Texture self, const PfmFile pfm)\n"
  "load(const Texture self, const PNMImage pnmimage, const LoaderOptions options)\n"
  "load(const Texture self, const PfmFile pfm, const LoaderOptions options)\n"
  "load(const Texture self, const PNMImage pnmimage, int z, int n, const LoaderOptions options)\n"
  "load(const Texture self, const PfmFile pfm, int z, int n, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Replaces the texture with the indicated image.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stores the indicated image in the given page and mipmap level.  See read().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the texture with the indicated image.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stores the indicated image in the given page and mipmap level.  See read().\n"
  " */";
#else
static const char *Dtool_Texture_load_1228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::load_sub_image(PNMImage const &pnmimage, int x, int y, int z = 0, int n = 0)
 */
static PyObject *Dtool_Texture_load_sub_image_1229(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.load_sub_image")) {
    return nullptr;
  }
  // 1-inline bool Texture::load_sub_image(PNMImage const &pnmimage, int x, int y, int z = 0, int n = 0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  static const char *keyword_list[] = {"pnmimage", "x", "y", "z", "n", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|ii:load_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "Texture.load_sub_image", true, true);
    if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*local_this).load_sub_image)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_sub_image(const Texture self, const PNMImage pnmimage, int x, int y, int z, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_load_sub_image_1229_comment =
  "C++ Interface:\n"
  "load_sub_image(const Texture self, const PNMImage pnmimage, int x, int y, int z, int n)\n"
  "\n"
  "/**\n"
  " * Stores the indicated image in a region of the texture.  The texture\n"
  " * properties remain unchanged.  This can be more efficient than updating an\n"
  " * entire texture, but has a few restrictions: for one, you must ensure that\n"
  " * the texture is still in RAM (eg.  using set_keep_ram_image) and it may not\n"
  " * be compressed.\n"
  " */";
#else
static const char *Dtool_Texture_load_sub_image_1229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::store(PNMImage &pnmimage) const
 * inline bool Texture::store(PNMImage &pnmimage, int z, int n) const
 * inline bool Texture::store(PfmFile &pfm) const
 * inline bool Texture::store(PfmFile &pfm, int z, int n) const
 */
static PyObject *Dtool_Texture_store_1230(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline bool Texture::store(PfmFile &pfm) const
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "pfm")) {
          PfmFile *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "Texture.store", false, false);
          if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*(const Texture*)local_this).store)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
      }

      {
        // -2 inline bool Texture::store(PNMImage &pnmimage) const
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "pnmimage")) {
          PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "Texture.store", false, false);
          if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*(const Texture*)local_this).store)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
      }

      // No coercion possible: inline bool Texture::store(PfmFile &pfm) const
      // No coercion possible: inline bool Texture::store(PNMImage &pnmimage) const
    }
    break;
  case 3:
    {
      {
        // -2 inline bool Texture::store(PNMImage &pnmimage, int z, int n) const
        PyObject *param1;
        int param2;
        int param3;
        static const char *keyword_list[] = {"pnmimage", "z", "n", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:store", (char **)keyword_list, &param1, &param2, &param3)) {
          PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "Texture.store", false, false);
          if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*(const Texture*)local_this).store)(*param1_this, (int)param2, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool Texture::store(PfmFile &pfm, int z, int n) const
        PyObject *param1;
        int param2;
        int param3;
        static const char *keyword_list[] = {"pfm", "z", "n", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:store", (char **)keyword_list, &param1, &param2, &param3)) {
          PfmFile *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "Texture.store", false, false);
          if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*(const Texture*)local_this).store)(*param1_this, (int)param2, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline bool Texture::store(PNMImage &pnmimage, int z, int n) const
      // No coercion possible: inline bool Texture::store(PfmFile &pfm, int z, int n) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "store() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(Texture self, PfmFile pfm)\n"
      "store(Texture self, PNMImage pnmimage)\n"
      "store(Texture self, PNMImage pnmimage, int z, int n)\n"
      "store(Texture self, PfmFile pfm, int z, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_store_1230_comment =
  "C++ Interface:\n"
  "store(Texture self, PfmFile pfm)\n"
  "store(Texture self, PNMImage pnmimage)\n"
  "store(Texture self, PNMImage pnmimage, int z, int n)\n"
  "store(Texture self, PfmFile pfm, int z, int n)\n"
  "\n"
  "/**\n"
  " * Saves the texture to the indicated PNMImage, but does not write it to disk.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Saves the indicated page and mipmap level of the texture to the PNMImage.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Saves the texture to the indicated PfmFile, but does not write it to disk.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Saves the indicated page and mipmap level of the texture to the PfmFile.\n"
  " */";
#else
static const char *Dtool_Texture_store_1230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::reload(void)
 */
static PyObject *Dtool_Texture_reload_1231(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.reload")) {
    return nullptr;
  }
  // 1-inline bool Texture::reload(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).reload)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_reload_1231_comment =
  "C++ Interface:\n"
  "reload(const Texture self)\n"
  "\n"
  "/**\n"
  " * Re-reads the Texture from its disk file.  Useful when you know the image on\n"
  " * disk has recently changed, and you want to update the Texture image.\n"
  " *\n"
  " * Returns true on success, false on failure (in which case, the Texture may\n"
  " * or may not still be valid).\n"
  " */";
#else
static const char *Dtool_Texture_reload_1231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *Texture::load_related(InternalName const *suffix) const
 */
static PyObject *Dtool_Texture_load_related_1232(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-Texture *Texture::load_related(InternalName const *suffix) const
  CPT(InternalName) arg_this;
  if (!Dtool_ConstCoerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Texture.load_related", "InternalName");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  Texture *return_value = ((*(const Texture*)local_this).load_related)(std::move(arg_this));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_related(Texture self, const InternalName suffix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_load_related_1232_comment =
  "C++ Interface:\n"
  "load_related(Texture self, const InternalName suffix)\n"
  "\n"
  "/**\n"
  " * Loads a texture whose filename is derived by concatenating a suffix to the\n"
  " * filename of this texture.  May return NULL, for example, if this texture\n"
  " * doesn't have a filename.\n"
  " */";
#else
static const char *Dtool_Texture_load_related_1232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_filename(void) const
 */
static PyObject *Dtool_Texture_has_filename_1233(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_filename(void) const
  bool return_value = ((*(const Texture*)local_this).has_filename)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_filename_1233_comment =
  "C++ Interface:\n"
  "has_filename(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename has been set and is available.  See\n"
  " * set_filename().\n"
  " */";
#else
static const char *Dtool_Texture_has_filename_1233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &Texture::get_filename(void) const
 */
static PyObject *Dtool_Texture_get_filename_1234(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline Filename const &Texture::get_filename(void) const
  Filename const *return_value = &(((*(const Texture*)local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_filename_1234_comment =
  "C++ Interface:\n"
  "get_filename(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the filename that has been set.  This is the name of the file as it\n"
  " * was requested.  Also see get_fullpath().\n"
  " */";
#else
static const char *Dtool_Texture_get_filename_1234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_filename(Filename const &filename)
 */
static PyObject *Dtool_Texture_set_filename_1235(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_filename")) {
    return nullptr;
  }
  // 1-inline void Texture::set_filename(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_filename", "Filename");
  }
  ((*local_this).set_filename)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_filename(const Texture self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_filename_1235_comment =
  "C++ Interface:\n"
  "set_filename(const Texture self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Sets the name of the file that contains the image's contents.  Normally,\n"
  " * this is set automatically when the image is loaded, for instance via\n"
  " * Texture::read().\n"
  " *\n"
  " * The Texture's get_name() function used to return the filename, but now\n"
  " * returns just the basename (without the extension), which is a more useful\n"
  " * name for identifying an image in show code.\n"
  " */";
#else
static const char *Dtool_Texture_set_filename_1235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::clear_filename(void)
 */
static PyObject *Dtool_Texture_clear_filename_1236(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_filename")) {
    return nullptr;
  }
  // 1-inline void Texture::clear_filename(void)
  ((*local_this).clear_filename)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_filename_1236_comment =
  "C++ Interface:\n"
  "clear_filename(const Texture self)\n"
  "\n"
  "/**\n"
  " * Removes the alpha filename, if it was previously set.  See set_filename().\n"
  " */";
#else
static const char *Dtool_Texture_clear_filename_1236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_alpha_filename(void) const
 */
static PyObject *Dtool_Texture_has_alpha_filename_1240(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_alpha_filename(void) const
  bool return_value = ((*(const Texture*)local_this).has_alpha_filename)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_alpha_filename_1240_comment =
  "C++ Interface:\n"
  "has_alpha_filename(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the alpha_filename has been set and is available.  See\n"
  " * set_alpha_filename().\n"
  " */";
#else
static const char *Dtool_Texture_has_alpha_filename_1240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &Texture::get_alpha_filename(void) const
 */
static PyObject *Dtool_Texture_get_alpha_filename_1241(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline Filename const &Texture::get_alpha_filename(void) const
  Filename const *return_value = &(((*(const Texture*)local_this).get_alpha_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_alpha_filename_1241_comment =
  "C++ Interface:\n"
  "get_alpha_filename(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the alpha_filename that has been set.  If this is set, it\n"
  " * represents the name of the alpha component, which is stored in a separate\n"
  " * file.  See also get_filename(), and get_alpha_fullpath().\n"
  " */";
#else
static const char *Dtool_Texture_get_alpha_filename_1241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_alpha_filename(Filename const &alpha_filename)
 */
static PyObject *Dtool_Texture_set_alpha_filename_1242(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_alpha_filename")) {
    return nullptr;
  }
  // 1-inline void Texture::set_alpha_filename(Filename const &alpha_filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_alpha_filename", "Filename");
  }
  ((*local_this).set_alpha_filename)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_filename(const Texture self, const Filename alpha_filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_alpha_filename_1242_comment =
  "C++ Interface:\n"
  "set_alpha_filename(const Texture self, const Filename alpha_filename)\n"
  "\n"
  "/**\n"
  " * Sets the name of the file that contains the image's alpha channel contents.\n"
  " * Normally, this is set automatically when the image is loaded, for instance\n"
  " * via Texture::read().\n"
  " *\n"
  " * The Texture's get_filename() function returns the name of the image file\n"
  " * that was loaded into the buffer.  In the case where a texture specified two\n"
  " * separate files to load, a 1- or 3-channel color image and a 1-channel alpha\n"
  " * image, this Filename is update to contain the name of the image file that\n"
  " * was loaded into the buffer's alpha channel.\n"
  " */";
#else
static const char *Dtool_Texture_set_alpha_filename_1242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::clear_alpha_filename(void)
 */
static PyObject *Dtool_Texture_clear_alpha_filename_1243(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_alpha_filename")) {
    return nullptr;
  }
  // 1-inline void Texture::clear_alpha_filename(void)
  ((*local_this).clear_alpha_filename)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_alpha_filename_1243_comment =
  "C++ Interface:\n"
  "clear_alpha_filename(const Texture self)\n"
  "\n"
  "/**\n"
  " * Removes the alpha filename, if it was previously set.  See\n"
  " * set_alpha_filename().\n"
  " */";
#else
static const char *Dtool_Texture_clear_alpha_filename_1243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_fullpath(void) const
 */
static PyObject *Dtool_Texture_has_fullpath_1245(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_fullpath(void) const
  bool return_value = ((*(const Texture*)local_this).has_fullpath)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_fullpath_1245_comment =
  "C++ Interface:\n"
  "has_fullpath(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the fullpath has been set and is available.  See\n"
  " * set_fullpath().\n"
  " */";
#else
static const char *Dtool_Texture_has_fullpath_1245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &Texture::get_fullpath(void) const
 */
static PyObject *Dtool_Texture_get_fullpath_1246(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline Filename const &Texture::get_fullpath(void) const
  Filename const *return_value = &(((*(const Texture*)local_this).get_fullpath)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_fullpath_1246_comment =
  "C++ Interface:\n"
  "get_fullpath(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the fullpath that has been set.  This is the full path to the file\n"
  " * as it was found along the texture search path.\n"
  " */";
#else
static const char *Dtool_Texture_get_fullpath_1246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_fullpath(Filename const &fullpath)
 */
static PyObject *Dtool_Texture_set_fullpath_1247(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_fullpath")) {
    return nullptr;
  }
  // 1-inline void Texture::set_fullpath(Filename const &fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_fullpath", "Filename");
  }
  ((*local_this).set_fullpath)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fullpath(const Texture self, const Filename fullpath)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_fullpath_1247_comment =
  "C++ Interface:\n"
  "set_fullpath(const Texture self, const Filename fullpath)\n"
  "\n"
  "/**\n"
  " * Sets the full pathname to the file that contains the image's contents, as\n"
  " * found along the search path.  Normally, this is set automatically when the\n"
  " * image is loaded, for instance via Texture::read().\n"
  " */";
#else
static const char *Dtool_Texture_set_fullpath_1247_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::clear_fullpath(void)
 */
static PyObject *Dtool_Texture_clear_fullpath_1248(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_fullpath")) {
    return nullptr;
  }
  // 1-inline void Texture::clear_fullpath(void)
  ((*local_this).clear_fullpath)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_fullpath_1248_comment =
  "C++ Interface:\n"
  "clear_fullpath(const Texture self)\n"
  "\n"
  "/**\n"
  " * Removes the alpha fullpath, if it was previously set.  See set_fullpath().\n"
  " */";
#else
static const char *Dtool_Texture_clear_fullpath_1248_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_alpha_fullpath(void) const
 */
static PyObject *Dtool_Texture_has_alpha_fullpath_1250(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_alpha_fullpath(void) const
  bool return_value = ((*(const Texture*)local_this).has_alpha_fullpath)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_alpha_fullpath_1250_comment =
  "C++ Interface:\n"
  "has_alpha_fullpath(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the alpha_fullpath has been set and is available.  See\n"
  " * set_alpha_fullpath().\n"
  " */";
#else
static const char *Dtool_Texture_has_alpha_fullpath_1250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &Texture::get_alpha_fullpath(void) const
 */
static PyObject *Dtool_Texture_get_alpha_fullpath_1251(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline Filename const &Texture::get_alpha_fullpath(void) const
  Filename const *return_value = &(((*(const Texture*)local_this).get_alpha_fullpath)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_alpha_fullpath_1251_comment =
  "C++ Interface:\n"
  "get_alpha_fullpath(Texture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " * Returns the alpha_fullpath that has been set.  This is the full path to the\n"
  " * alpha part of the image file as it was found along the texture search path.\n"
  " */";
#else
static const char *Dtool_Texture_get_alpha_fullpath_1251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_alpha_fullpath(Filename const &alpha_fullpath)
 */
static PyObject *Dtool_Texture_set_alpha_fullpath_1252(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_alpha_fullpath")) {
    return nullptr;
  }
  // 1-inline void Texture::set_alpha_fullpath(Filename const &alpha_fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_alpha_fullpath", "Filename");
  }
  ((*local_this).set_alpha_fullpath)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_fullpath(const Texture self, const Filename alpha_fullpath)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_alpha_fullpath_1252_comment =
  "C++ Interface:\n"
  "set_alpha_fullpath(const Texture self, const Filename alpha_fullpath)\n"
  "\n"
  "/**\n"
  " * Sets the full pathname to the file that contains the image's alpha channel\n"
  " * contents, as found along the search path.  Normally, this is set\n"
  " * automatically when the image is loaded, for instance via Texture::read().\n"
  " */";
#else
static const char *Dtool_Texture_set_alpha_fullpath_1252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::clear_alpha_fullpath(void)
 */
static PyObject *Dtool_Texture_clear_alpha_fullpath_1253(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_alpha_fullpath")) {
    return nullptr;
  }
  // 1-inline void Texture::clear_alpha_fullpath(void)
  ((*local_this).clear_alpha_fullpath)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_alpha_fullpath_1253_comment =
  "C++ Interface:\n"
  "clear_alpha_fullpath(const Texture self)\n"
  "\n"
  "/**\n"
  " * Removes the alpha fullpath, if it was previously set.  See\n"
  " * set_alpha_fullpath().\n"
  " */";
#else
static const char *Dtool_Texture_clear_alpha_fullpath_1253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_x_size(void) const
 */
static PyObject *Dtool_Texture_get_x_size_1255(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_x_size(void) const
  int return_value = ((*(const Texture*)local_this).get_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_x_size_1255_comment =
  "C++ Interface:\n"
  "get_x_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the width of the texture image in texels.\n"
  " */";
#else
static const char *Dtool_Texture_get_x_size_1255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_x_size(int x_size)
 */
static PyObject *Dtool_Texture_set_x_size_1256(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_x_size")) {
    return nullptr;
  }
  // 1-inline void Texture::set_x_size(int x_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_x_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x_size(const Texture self, int x_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_x_size_1256_comment =
  "C++ Interface:\n"
  "set_x_size(const Texture self, int x_size)\n"
  "\n"
  "/**\n"
  " * Changes the x size indicated for the texture.  This also implicitly unloads\n"
  " * the texture if it has already been loaded.\n"
  " */";
#else
static const char *Dtool_Texture_set_x_size_1256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_y_size(void) const
 */
static PyObject *Dtool_Texture_get_y_size_1258(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_y_size(void) const
  int return_value = ((*(const Texture*)local_this).get_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_y_size_1258_comment =
  "C++ Interface:\n"
  "get_y_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the height of the texture image in texels.  For a 1-d texture, this\n"
  " * will be 1.\n"
  " */";
#else
static const char *Dtool_Texture_get_y_size_1258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_y_size(int y_size)
 */
static PyObject *Dtool_Texture_set_y_size_1259(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_y_size")) {
    return nullptr;
  }
  // 1-inline void Texture::set_y_size(int y_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_y_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y_size(const Texture self, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_y_size_1259_comment =
  "C++ Interface:\n"
  "set_y_size(const Texture self, int y_size)\n"
  "\n"
  "/**\n"
  " * Changes the y size indicated for the texture.  This also implicitly unloads\n"
  " * the texture if it has already been loaded.\n"
  " */";
#else
static const char *Dtool_Texture_set_y_size_1259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_z_size(void) const
 */
static PyObject *Dtool_Texture_get_z_size_1261(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_z_size(void) const
  int return_value = ((*(const Texture*)local_this).get_z_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_z_size_1261_comment =
  "C++ Interface:\n"
  "get_z_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the depth of the texture image in texels.  For a 1-d texture or 2-d\n"
  " * texture, this will be 1. For a cube map texture, this will be 6.\n"
  " */";
#else
static const char *Dtool_Texture_get_z_size_1261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_z_size(int z_size)
 */
static PyObject *Dtool_Texture_set_z_size_1262(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_z_size")) {
    return nullptr;
  }
  // 1-inline void Texture::set_z_size(int z_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_z_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z_size(const Texture self, int z_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_z_size_1262_comment =
  "C++ Interface:\n"
  "set_z_size(const Texture self, int z_size)\n"
  "\n"
  "/**\n"
  " * Changes the z size indicated for the texture.  This also implicitly unloads\n"
  " * the texture if it has already been loaded.\n"
  " */";
#else
static const char *Dtool_Texture_set_z_size_1262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_num_views(void) const
 */
static PyObject *Dtool_Texture_get_num_views_1264(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_num_views(void) const
  int return_value = ((*(const Texture*)local_this).get_num_views)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_num_views_1264_comment =
  "C++ Interface:\n"
  "get_num_views(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the number of \"views\" in the texture.  A view is a completely\n"
  " * separate image stored within the Texture object.  Most textures have only\n"
  " * one view, but a stereo texture, for instance, may have two views, a left\n"
  " * and a right image.  Other uses for multiple views are not yet defined.\n"
  " *\n"
  " * If this value is greater than one, the additional views are accessed as\n"
  " * additional pages beyond get_z_size().\n"
  " */";
#else
static const char *Dtool_Texture_get_num_views_1264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_num_views(int num_views)
 */
static PyObject *Dtool_Texture_set_num_views_1265(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_num_views")) {
    return nullptr;
  }
  // 1-inline void Texture::set_num_views(int num_views)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_views)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_views(const Texture self, int num_views)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_num_views_1265_comment =
  "C++ Interface:\n"
  "set_num_views(const Texture self, int num_views)\n"
  "\n"
  "/**\n"
  " * Sets the number of \"views\" within a texture.  A view is a completely\n"
  " * separate image stored within the Texture object.  Most textures have only\n"
  " * one view, but a stereo texture, for instance, may have two views, a left\n"
  " * and a right image.  Other uses for multiple views are not yet defined.\n"
  " *\n"
  " * If this value is greater than one, the additional views are accessed as\n"
  " * additional pages beyond get_z_size().\n"
  " *\n"
  " * This also implicitly unloads the texture if it has already been loaded.\n"
  " */";
#else
static const char *Dtool_Texture_set_num_views_1265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_num_pages(void) const
 */
static PyObject *Dtool_Texture_get_num_pages_1267(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_num_pages(void) const
  int return_value = ((*(const Texture*)local_this).get_num_pages)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_num_pages_1267_comment =
  "C++ Interface:\n"
  "get_num_pages(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of pages in the texture.  Each \"page\" is a 2-d\n"
  " * texture image within the larger image--a face of a cube map, or a level of\n"
  " * a 3-d texture.  Normally, get_num_pages() is the same as get_z_size().\n"
  " * However, in a multiview texture, this returns get_z_size() *\n"
  " * get_num_views().\n"
  " */";
#else
static const char *Dtool_Texture_get_num_pages_1267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_num_components(void) const
 */
static PyObject *Dtool_Texture_get_num_components_1268(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_num_components(void) const
  int return_value = ((*(const Texture*)local_this).get_num_components)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_num_components_1268_comment =
  "C++ Interface:\n"
  "get_num_components(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the number of color components for each texel of the texture image.\n"
  " * This is 3 for an rgb texture or 4 for an rgba texture; it may also be 1 or\n"
  " * 2 for a grayscale texture.\n"
  " */";
#else
static const char *Dtool_Texture_get_num_components_1268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_component_width(void) const
 */
static PyObject *Dtool_Texture_get_component_width_1269(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_component_width(void) const
  int return_value = ((*(const Texture*)local_this).get_component_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_component_width_1269_comment =
  "C++ Interface:\n"
  "get_component_width(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes stored for each color component of a texel.\n"
  " * Typically this is 1, but it may be 2 for 16-bit texels.\n"
  " */";
#else
static const char *Dtool_Texture_get_component_width_1269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture::TextureType Texture::get_texture_type(void) const
 */
static PyObject *Dtool_Texture_get_texture_type_1270(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline Texture::TextureType Texture::get_texture_type(void) const
  Texture::TextureType return_value = ((*(const Texture*)local_this).get_texture_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_texture_type_1270_comment =
  "C++ Interface:\n"
  "get_texture_type(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the overall interpretation of the texture.\n"
  " */";
#else
static const char *Dtool_Texture_get_texture_type_1270_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::UsageHint Texture::get_usage_hint(void) const
 */
static PyObject *Dtool_Texture_get_usage_hint_1271(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline GeomEnums::UsageHint Texture::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const Texture*)local_this).get_usage_hint)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_usage_hint_1271_comment =
  "C++ Interface:\n"
  "get_usage_hint(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the usage hint specified for buffer textures, or UH_unspecified for\n"
  " * all other texture types.\n"
  " */";
#else
static const char *Dtool_Texture_get_usage_hint_1271_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture::Format Texture::get_format(void) const
 */
static PyObject *Dtool_Texture_get_format_1277(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline Texture::Format Texture::get_format(void) const
  Texture::Format return_value = ((*(const Texture*)local_this).get_format)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_format_1277_comment =
  "C++ Interface:\n"
  "get_format(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the format of the texture, which represents both the semantic\n"
  " * meaning of the texels and, to some extent, their storage information.\n"
  " */";
#else
static const char *Dtool_Texture_get_format_1277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_format(Texture::Format format)
 */
static PyObject *Dtool_Texture_set_format_1278(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_format")) {
    return nullptr;
  }
  // 1-inline void Texture::set_format(Texture::Format format)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_format)((Texture::Format)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_format(const Texture self, int format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_format_1278_comment =
  "C++ Interface:\n"
  "set_format(const Texture self, int format)\n"
  "\n"
  "/**\n"
  " * Changes the format value for the texture components.  This implicitly sets\n"
  " * num_components as well.\n"
  " */";
#else
static const char *Dtool_Texture_set_format_1278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture::ComponentType Texture::get_component_type(void) const
 */
static PyObject *Dtool_Texture_get_component_type_1280(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline Texture::ComponentType Texture::get_component_type(void) const
  Texture::ComponentType return_value = ((*(const Texture*)local_this).get_component_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_component_type_1280_comment =
  "C++ Interface:\n"
  "get_component_type(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the numeric interpretation of each component of the texture.\n"
  " */";
#else
static const char *Dtool_Texture_get_component_type_1280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_component_type(Texture::ComponentType component_type)
 */
static PyObject *Dtool_Texture_set_component_type_1281(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_component_type")) {
    return nullptr;
  }
  // 1-inline void Texture::set_component_type(Texture::ComponentType component_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_component_type)((Texture::ComponentType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_component_type(const Texture self, int component_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_component_type_1281_comment =
  "C++ Interface:\n"
  "set_component_type(const Texture self, int component_type)\n"
  "\n"
  "/**\n"
  " * Changes the data value for the texture components.  This implicitly sets\n"
  " * component_width as well.\n"
  " */";
#else
static const char *Dtool_Texture_set_component_type_1281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::WrapMode Texture::get_wrap_u(void) const
 */
static PyObject *Dtool_Texture_get_wrap_u_1283(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline SamplerState::WrapMode Texture::get_wrap_u(void) const
  SamplerState::WrapMode return_value = ((*(const Texture*)local_this).get_wrap_u)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_wrap_u_1283_comment =
  "C++ Interface:\n"
  "get_wrap_u(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the wrap mode of the texture in the U direction.\n"
  " *\n"
  " * This returns the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_get_wrap_u_1283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_wrap_u(Texture::WrapMode wrap)
 */
static PyObject *Dtool_Texture_set_wrap_u_1284(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_wrap_u")) {
    return nullptr;
  }
  // 1-inline void Texture::set_wrap_u(Texture::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_wrap_u)((Texture::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_u(const Texture self, int wrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_wrap_u_1284_comment =
  "C++ Interface:\n"
  "set_wrap_u(const Texture self, int wrap)\n"
  "\n"
  "/**\n"
  " * This setting determines what happens when the texture is sampled with a U\n"
  " * value outside the range 0.0-1.0.  The default is WM_repeat, which indicates\n"
  " * that the texture should repeat indefinitely.\n"
  " *\n"
  " * This sets the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_set_wrap_u_1284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::WrapMode Texture::get_wrap_v(void) const
 */
static PyObject *Dtool_Texture_get_wrap_v_1286(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline SamplerState::WrapMode Texture::get_wrap_v(void) const
  SamplerState::WrapMode return_value = ((*(const Texture*)local_this).get_wrap_v)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_wrap_v_1286_comment =
  "C++ Interface:\n"
  "get_wrap_v(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the wrap mode of the texture in the V direction.\n"
  " *\n"
  " * This returns the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_get_wrap_v_1286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_wrap_v(Texture::WrapMode wrap)
 */
static PyObject *Dtool_Texture_set_wrap_v_1287(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_wrap_v")) {
    return nullptr;
  }
  // 1-inline void Texture::set_wrap_v(Texture::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_wrap_v)((Texture::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_v(const Texture self, int wrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_wrap_v_1287_comment =
  "C++ Interface:\n"
  "set_wrap_v(const Texture self, int wrap)\n"
  "\n"
  "/**\n"
  " * This setting determines what happens when the texture is sampled with a V\n"
  " * value outside the range 0.0-1.0.  The default is WM_repeat, which indicates\n"
  " * that the texture should repeat indefinitely.\n"
  " *\n"
  " * This sets the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_set_wrap_v_1287_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::WrapMode Texture::get_wrap_w(void) const
 */
static PyObject *Dtool_Texture_get_wrap_w_1289(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline SamplerState::WrapMode Texture::get_wrap_w(void) const
  SamplerState::WrapMode return_value = ((*(const Texture*)local_this).get_wrap_w)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_wrap_w_1289_comment =
  "C++ Interface:\n"
  "get_wrap_w(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the wrap mode of the texture in the W direction.  This is the depth\n"
  " * direction of 3-d textures.\n"
  " *\n"
  " * This returns the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_get_wrap_w_1289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_wrap_w(Texture::WrapMode wrap)
 */
static PyObject *Dtool_Texture_set_wrap_w_1290(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_wrap_w")) {
    return nullptr;
  }
  // 1-inline void Texture::set_wrap_w(Texture::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_wrap_w)((Texture::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_w(const Texture self, int wrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_wrap_w_1290_comment =
  "C++ Interface:\n"
  "set_wrap_w(const Texture self, int wrap)\n"
  "\n"
  "/**\n"
  " * The W wrap direction is only used for 3-d textures.\n"
  " *\n"
  " * This sets the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_set_wrap_w_1290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::FilterType Texture::get_minfilter(void) const
 */
static PyObject *Dtool_Texture_get_minfilter_1292(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline SamplerState::FilterType Texture::get_minfilter(void) const
  SamplerState::FilterType return_value = ((*(const Texture*)local_this).get_minfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_minfilter_1292_comment =
  "C++ Interface:\n"
  "get_minfilter(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the filter mode of the texture for minification.  If this is one of\n"
  " * the mipmap constants, then the texture requires mipmaps.  This may return\n"
  " * FT_default; see also get_effective_minfilter().\n"
  " *\n"
  " * This returns the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_get_minfilter_1292_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::FilterType Texture::get_effective_minfilter(void) const
 */
static PyObject *Dtool_Texture_get_effective_minfilter_1293(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline SamplerState::FilterType Texture::get_effective_minfilter(void) const
  SamplerState::FilterType return_value = ((*(const Texture*)local_this).get_effective_minfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_effective_minfilter_1293_comment =
  "C++ Interface:\n"
  "get_effective_minfilter(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the filter mode of the texture for minification, with special\n"
  " * treatment for FT_default.  This will normally not return FT_default, unless\n"
  " * there is an error in the config file.\n"
  " *\n"
  " * This returns the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_get_effective_minfilter_1293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_minfilter(Texture::FilterType filter)
 */
static PyObject *Dtool_Texture_set_minfilter_1294(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_minfilter")) {
    return nullptr;
  }
  // 1-inline void Texture::set_minfilter(Texture::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_minfilter)((Texture::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_minfilter(const Texture self, int filter)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_minfilter_1294_comment =
  "C++ Interface:\n"
  "set_minfilter(const Texture self, int filter)\n"
  "\n"
  "/**\n"
  " * Sets the filtering method that should be used when viewing the texture from\n"
  " * a distance.\n"
  " *\n"
  " * This sets the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_set_minfilter_1294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::FilterType Texture::get_magfilter(void) const
 */
static PyObject *Dtool_Texture_get_magfilter_1297(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline SamplerState::FilterType Texture::get_magfilter(void) const
  SamplerState::FilterType return_value = ((*(const Texture*)local_this).get_magfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_magfilter_1297_comment =
  "C++ Interface:\n"
  "get_magfilter(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the filter mode of the texture for magnification.  The mipmap\n"
  " * constants are invalid here.  This may return FT_default; see also\n"
  " * get_effective_minfilter().\n"
  " *\n"
  " * This returns the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_get_magfilter_1297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::FilterType Texture::get_effective_magfilter(void) const
 */
static PyObject *Dtool_Texture_get_effective_magfilter_1298(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline SamplerState::FilterType Texture::get_effective_magfilter(void) const
  SamplerState::FilterType return_value = ((*(const Texture*)local_this).get_effective_magfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_effective_magfilter_1298_comment =
  "C++ Interface:\n"
  "get_effective_magfilter(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the filter mode of the texture for magnification, with special\n"
  " * treatment for FT_default.  This will normally not return FT_default, unless\n"
  " * there is an error in the config file.\n"
  " *\n"
  " * This returns the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_get_effective_magfilter_1298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_magfilter(Texture::FilterType filter)
 */
static PyObject *Dtool_Texture_set_magfilter_1299(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_magfilter")) {
    return nullptr;
  }
  // 1-inline void Texture::set_magfilter(Texture::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_magfilter)((Texture::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_magfilter(const Texture self, int filter)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_magfilter_1299_comment =
  "C++ Interface:\n"
  "set_magfilter(const Texture self, int filter)\n"
  "\n"
  "/**\n"
  " * Sets the filtering method that should be used when viewing the texture up\n"
  " * close.\n"
  " *\n"
  " * This sets the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_set_magfilter_1299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_anisotropic_degree(void) const
 */
static PyObject *Dtool_Texture_get_anisotropic_degree_1302(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_anisotropic_degree(void) const
  int return_value = ((*(const Texture*)local_this).get_anisotropic_degree)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_anisotropic_degree_1302_comment =
  "C++ Interface:\n"
  "get_anisotropic_degree(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the degree of anisotropic filtering that should be applied to the\n"
  " * texture.  This value may return 0, indicating the default value; see also\n"
  " * get_effective_anisotropic_degree.\n"
  " *\n"
  " * This returns the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_get_anisotropic_degree_1302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_effective_anisotropic_degree(void) const
 */
static PyObject *Dtool_Texture_get_effective_anisotropic_degree_1303(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_effective_anisotropic_degree(void) const
  int return_value = ((*(const Texture*)local_this).get_effective_anisotropic_degree)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_effective_anisotropic_degree_1303_comment =
  "C++ Interface:\n"
  "get_effective_anisotropic_degree(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the degree of anisotropic filtering that should be applied to the\n"
  " * texture.  This value will normally not return 0, unless there is an error\n"
  " * in the config file.\n"
  " *\n"
  " * This returns the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_get_effective_anisotropic_degree_1303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_anisotropic_degree(int anisotropic_degree)
 */
static PyObject *Dtool_Texture_set_anisotropic_degree_1304(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_anisotropic_degree")) {
    return nullptr;
  }
  // 1-inline void Texture::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_anisotropic_degree)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const Texture self, int anisotropic_degree)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_anisotropic_degree_1304_comment =
  "C++ Interface:\n"
  "set_anisotropic_degree(const Texture self, int anisotropic_degree)\n"
  "\n"
  "/**\n"
  " * Specifies the level of anisotropic filtering to apply to the texture.  Set\n"
  " * this 0 to indicate the default value, which is specified in the texture-\n"
  " * anisotropic-degree config variable.\n"
  " *\n"
  " * To explicitly disable anisotropic filtering, set this value to 1.  To\n"
  " * explicitly enable anisotropic filtering, set it to a value higher than 1;\n"
  " * larger numbers indicate greater degrees of filtering.\n"
  " *\n"
  " * This sets the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_set_anisotropic_degree_1304_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor Texture::get_border_color(void) const
 */
static PyObject *Dtool_Texture_get_border_color_1307(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline LColor Texture::get_border_color(void) const
  LColor *return_value = new LColor(((*(const Texture*)local_this).get_border_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_border_color_1307_comment =
  "C++ Interface:\n"
  "get_border_color(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the solid color of the texture's border.  Some OpenGL\n"
  " * implementations use a border for tiling textures; in Panda, it is only used\n"
  " * for specifying the clamp color.\n"
  " *\n"
  " * This returns the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_get_border_color_1307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_border_color(LColor const &color)
 */
static PyObject *Dtool_Texture_set_border_color_1308(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_border_color")) {
    return nullptr;
  }
  // 1-inline void Texture::set_border_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_border_color", "LVecBase4f");
  }
  ((*local_this).set_border_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_border_color(const Texture self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_border_color_1308_comment =
  "C++ Interface:\n"
  "set_border_color(const Texture self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Specifies the solid color of the texture's border.  Some OpenGL\n"
  " * implementations use a border for tiling textures; in Panda, it is only used\n"
  " * for specifying the clamp color.\n"
  " *\n"
  " * This sets the default sampler state for this texture; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_set_border_color_1308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_compression(void) const
 */
static PyObject *Dtool_Texture_has_compression_1310(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_compression(void) const
  bool return_value = ((*(const Texture*)local_this).has_compression)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_compression_1310_comment =
  "C++ Interface:\n"
  "has_compression(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture indicates it wants to be compressed, either\n"
  " * with CM_on or higher, or CM_default and compressed-textures is true.\n"
  " *\n"
  " * If true returned, this is not a guarantee that the texture is actually\n"
  " * successfully compressed on the GSG.  It may be that the GSG does not\n"
  " * support the requested compression mode, in which case the texture may\n"
  " * actually be stored uncompressed in texture memory.\n"
  " */";
#else
static const char *Dtool_Texture_has_compression_1310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture::CompressionMode Texture::get_compression(void) const
 */
static PyObject *Dtool_Texture_get_compression_1311(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline Texture::CompressionMode Texture::get_compression(void) const
  Texture::CompressionMode return_value = ((*(const Texture*)local_this).get_compression)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_compression_1311_comment =
  "C++ Interface:\n"
  "get_compression(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the compression mode requested for this particular texture, or\n"
  " * CM_off if the texture is not to be compressed.\n"
  " *\n"
  " * If a value other than CM_off is returned, this is not a guarantee that the\n"
  " * texture is actually successfully compressed on the GSG.  It may be that the\n"
  " * GSG does not support the requested compression mode, in which case the\n"
  " * texture may actually be stored uncompressed in texture memory.\n"
  " */";
#else
static const char *Dtool_Texture_get_compression_1311_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_compression(Texture::CompressionMode compression)
 */
static PyObject *Dtool_Texture_set_compression_1312(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_compression")) {
    return nullptr;
  }
  // 1-inline void Texture::set_compression(Texture::CompressionMode compression)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_compression)((Texture::CompressionMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_compression(const Texture self, int compression)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_compression_1312_comment =
  "C++ Interface:\n"
  "set_compression(const Texture self, int compression)\n"
  "\n"
  "/**\n"
  " * Requests that this particular Texture be compressed when it is loaded into\n"
  " * texture memory.\n"
  " *\n"
  " * This refers to the internal compression of the texture image within texture\n"
  " * memory; it is not related to jpeg or png compression, which are disk file\n"
  " * compression formats.  The actual disk file that generated this texture may\n"
  " * be stored in a compressed or uncompressed format supported by Panda; it\n"
  " * will be decompressed on load, and then recompressed by the graphics API if\n"
  " * this parameter is not CM_off.\n"
  " *\n"
  " * If the GSG does not support this texture compression mode, the texture will\n"
  " * silently be loaded uncompressed.\n"
  " */";
#else
static const char *Dtool_Texture_set_compression_1312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::get_render_to_texture(void) const
 */
static PyObject *Dtool_Texture_get_render_to_texture_1314(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::get_render_to_texture(void) const
  bool return_value = ((*(const Texture*)local_this).get_render_to_texture)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_render_to_texture_1314_comment =
  "C++ Interface:\n"
  "get_render_to_texture(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns a flag on the texture that indicates whether the texture is\n"
  " * intended to be used as a direct-render target, by binding a framebuffer to\n"
  " * a texture and rendering directly into the texture.\n"
  " *\n"
  " * Normally, a user should not need to set this flag directly; it is set\n"
  " * automatically by the low-level display code when a texture is bound to a\n"
  " * framebuffer.\n"
  " */";
#else
static const char *Dtool_Texture_get_render_to_texture_1314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_render_to_texture(bool render_to_texture)
 */
static PyObject *Dtool_Texture_set_render_to_texture_1315(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_render_to_texture")) {
    return nullptr;
  }
  // 1-inline void Texture::set_render_to_texture(bool render_to_texture)
  ((*local_this).set_render_to_texture)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_to_texture(const Texture self, bool render_to_texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_render_to_texture_1315_comment =
  "C++ Interface:\n"
  "set_render_to_texture(const Texture self, bool render_to_texture)\n"
  "\n"
  "/**\n"
  " * Sets a flag on the texture that indicates whether the texture is intended\n"
  " * to be used as a direct-render target, by binding a framebuffer to a texture\n"
  " * and rendering directly into the texture.\n"
  " *\n"
  " * This controls some low-level choices made about the texture object itself.\n"
  " * For instance, compressed textures are disallowed when this flag is set\n"
  " * true.\n"
  " *\n"
  " * Normally, a user should not need to set this flag directly; it is set\n"
  " * automatically by the low-level display code when a texture is bound to a\n"
  " * framebuffer.\n"
  " */";
#else
static const char *Dtool_Texture_set_render_to_texture_1315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState const &Texture::get_default_sampler(void) const
 */
static PyObject *Dtool_Texture_get_default_sampler_1317(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline SamplerState const &Texture::get_default_sampler(void) const
  SamplerState const *return_value = &(((*(const Texture*)local_this).get_default_sampler)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SamplerState, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_default_sampler_1317_comment =
  "C++ Interface:\n"
  "get_default_sampler(Texture self)\n"
  "\n"
  "/**\n"
  " * This returns the default sampler state for this texture, containing the\n"
  " * wrap and filter properties specified on the texture level; it may still be\n"
  " * overridden by a sampler state specified at a higher level.\n"
  " */";
#else
static const char *Dtool_Texture_get_default_sampler_1317_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_default_sampler(SamplerState const &sampler)
 */
static PyObject *Dtool_Texture_set_default_sampler_1318(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_default_sampler")) {
    return nullptr;
  }
  // 1-inline void Texture::set_default_sampler(SamplerState const &sampler)
  SamplerState const *arg_this = (SamplerState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SamplerState, 1, "Texture.set_default_sampler", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_default_sampler)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_sampler(const Texture self, const SamplerState sampler)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_default_sampler_1318_comment =
  "C++ Interface:\n"
  "set_default_sampler(const Texture self, const SamplerState sampler)\n"
  "\n"
  "/**\n"
  " * This sets the default sampler state for this texture, containing the wrap\n"
  " * and filter properties specified on the texture level; it may still be\n"
  " * overridden by a sampler state specified at a higher level.  This\n"
  " * encompasses the settings for get_wrap_u, get_minfilter,\n"
  " * get_anisotropic_degree, etc.\n"
  " *\n"
  " * This makes a copy of the SamplerState object, so future modifications of\n"
  " * the same SamplerState will have no effect on this texture unless you call\n"
  " * set_default_sampler again.\n"
  " */";
#else
static const char *Dtool_Texture_set_default_sampler_1318_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::uses_mipmaps(void) const
 */
static PyObject *Dtool_Texture_uses_mipmaps_1321(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::uses_mipmaps(void) const
  bool return_value = ((*(const Texture*)local_this).uses_mipmaps)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_uses_mipmaps_1321_comment =
  "C++ Interface:\n"
  "uses_mipmaps(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the minfilter settings on this texture indicate the use of\n"
  " * mipmapping, false otherwise.\n"
  " */";
#else
static const char *Dtool_Texture_uses_mipmaps_1321_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture::QualityLevel Texture::get_quality_level(void) const
 */
static PyObject *Dtool_Texture_get_quality_level_1322(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline Texture::QualityLevel Texture::get_quality_level(void) const
  Texture::QualityLevel return_value = ((*(const Texture*)local_this).get_quality_level)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_quality_level_1322_comment =
  "C++ Interface:\n"
  "get_quality_level(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the current quality_level hint.  See set_quality_level().  This\n"
  " * value may return QL_default; see get_effective_quality_level().\n"
  " */";
#else
static const char *Dtool_Texture_get_quality_level_1322_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture::QualityLevel Texture::get_effective_quality_level(void) const
 */
static PyObject *Dtool_Texture_get_effective_quality_level_1323(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline Texture::QualityLevel Texture::get_effective_quality_level(void) const
  Texture::QualityLevel return_value = ((*(const Texture*)local_this).get_effective_quality_level)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_effective_quality_level_1323_comment =
  "C++ Interface:\n"
  "get_effective_quality_level(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the current quality_level hint, or the global default quality_level\n"
  " * if this texture doesn't specify a quality level.  This value will not\n"
  " * normally return QL_default (unless there is an error in the config file)\n"
  " */";
#else
static const char *Dtool_Texture_get_effective_quality_level_1323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_quality_level(Texture::QualityLevel quality_level)
 */
static PyObject *Dtool_Texture_set_quality_level_1324(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_quality_level")) {
    return nullptr;
  }
  // 1-inline void Texture::set_quality_level(Texture::QualityLevel quality_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_quality_level)((Texture::QualityLevel)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quality_level(const Texture self, int quality_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_quality_level_1324_comment =
  "C++ Interface:\n"
  "set_quality_level(const Texture self, int quality_level)\n"
  "\n"
  "/**\n"
  " * Sets a hint to the renderer about the desired performance / quality\n"
  " * tradeoff for this particular texture.  This is most useful for the\n"
  " * tinydisplay software renderer; for normal, hardware-accelerated renderers,\n"
  " * this may have little or no effect.\n"
  " */";
#else
static const char *Dtool_Texture_set_quality_level_1324_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_expected_num_mipmap_levels(void) const
 */
static PyObject *Dtool_Texture_get_expected_num_mipmap_levels_1327(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_expected_num_mipmap_levels(void) const
  int return_value = ((*(const Texture*)local_this).get_expected_num_mipmap_levels)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_expected_num_mipmap_levels_1327_comment =
  "C++ Interface:\n"
  "get_expected_num_mipmap_levels(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the number of mipmap levels that should be defined for this\n"
  " * texture, given the texture's size.\n"
  " *\n"
  " * Note that this returns a number appropriate for mipmapping, even if the\n"
  " * texture does not currently have mipmapping enabled.\n"
  " */";
#else
static const char *Dtool_Texture_get_expected_num_mipmap_levels_1327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_expected_mipmap_x_size(int n) const
 */
static PyObject *Dtool_Texture_get_expected_mipmap_x_size_1328(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_expected_mipmap_x_size(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const Texture*)local_this).get_expected_mipmap_x_size)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_expected_mipmap_x_size(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_expected_mipmap_x_size_1328_comment =
  "C++ Interface:\n"
  "get_expected_mipmap_x_size(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the x_size that the nth mipmap level should have, based on the\n"
  " * texture's size.\n"
  " */";
#else
static const char *Dtool_Texture_get_expected_mipmap_x_size_1328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_expected_mipmap_y_size(int n) const
 */
static PyObject *Dtool_Texture_get_expected_mipmap_y_size_1329(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_expected_mipmap_y_size(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const Texture*)local_this).get_expected_mipmap_y_size)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_expected_mipmap_y_size(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_expected_mipmap_y_size_1329_comment =
  "C++ Interface:\n"
  "get_expected_mipmap_y_size(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the y_size that the nth mipmap level should have, based on the\n"
  " * texture's size.\n"
  " */";
#else
static const char *Dtool_Texture_get_expected_mipmap_y_size_1329_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_expected_mipmap_z_size(int n) const
 */
static PyObject *Dtool_Texture_get_expected_mipmap_z_size_1330(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_expected_mipmap_z_size(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const Texture*)local_this).get_expected_mipmap_z_size)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_expected_mipmap_z_size(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_expected_mipmap_z_size_1330_comment =
  "C++ Interface:\n"
  "get_expected_mipmap_z_size(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the z_size that the nth mipmap level should have, based on the\n"
  " * texture's size.\n"
  " */";
#else
static const char *Dtool_Texture_get_expected_mipmap_z_size_1330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_expected_mipmap_num_pages(int n) const
 */
static PyObject *Dtool_Texture_get_expected_mipmap_num_pages_1331(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_expected_mipmap_num_pages(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const Texture*)local_this).get_expected_mipmap_num_pages)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_expected_mipmap_num_pages(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_expected_mipmap_num_pages_1331_comment =
  "C++ Interface:\n"
  "get_expected_mipmap_num_pages(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the total number of pages that the nth mipmap level should have,\n"
  " * based on the texture's size.  This is usually the same as\n"
  " * get_expected_mipmap_z_size(), except for a multiview texture, in which case\n"
  " * it is get_expected_mipmap_z_size() * get_num_views().\n"
  " */";
#else
static const char *Dtool_Texture_get_expected_mipmap_num_pages_1331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_ram_image(void) const
 */
static PyObject *Dtool_Texture_has_ram_image_1333(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_ram_image(void) const
  bool return_value = ((*(const Texture*)local_this).has_ram_image)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_ram_image_1333_comment =
  "C++ Interface:\n"
  "has_ram_image(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Texture has its image contents available in main RAM,\n"
  " * false if it exists only in texture memory or in the prepared GSG context.\n"
  " *\n"
  " * Note that this has nothing to do with whether get_ram_image() will fail or\n"
  " * not.  Even if has_ram_image() returns false, get_ram_image() may still\n"
  " * return a valid RAM image, because get_ram_image() will automatically load\n"
  " * the texture from disk if necessary.  The only thing has_ram_image() tells\n"
  " * you is whether the texture is available right now without hitting the disk\n"
  " * first.\n"
  " *\n"
  " * Note also that if an application uses only one GSG, it may appear that\n"
  " * has_ram_image() returns true if the texture has not yet been loaded by the\n"
  " * GSG, but this correlation is not true in general and should not be depended\n"
  " * on.  Specifically, if an application ever uses multiple GSG's in its\n"
  " * lifetime (for instance, by opening more than one window, or by closing its\n"
  " * window and opening another one later), then has_ram_image() may well return\n"
  " * false on textures that have never been loaded on the current GSG.\n"
  " */";
#else
static const char *Dtool_Texture_has_ram_image_1333_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_uncompressed_ram_image(void) const
 */
static PyObject *Dtool_Texture_has_uncompressed_ram_image_1334(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_uncompressed_ram_image(void) const
  bool return_value = ((*(const Texture*)local_this).has_uncompressed_ram_image)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_uncompressed_ram_image_1334_comment =
  "C++ Interface:\n"
  "has_uncompressed_ram_image(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Texture has its image contents available in main RAM\n"
  " * and is uncompressed, false otherwise.  See has_ram_image().\n"
  " */";
#else
static const char *Dtool_Texture_has_uncompressed_ram_image_1334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::might_have_ram_image(void) const
 */
static PyObject *Dtool_Texture_might_have_ram_image_1335(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::might_have_ram_image(void) const
  bool return_value = ((*(const Texture*)local_this).might_have_ram_image)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_might_have_ram_image_1335_comment =
  "C++ Interface:\n"
  "might_have_ram_image(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture's image contents are currently available in\n"
  " * main RAM, or there is reason to believe it can be loaded on demand.  That\n"
  " * is, this function returns a \"best guess\" as to whether get_ram_image() will\n"
  " * succeed without actually calling it first.\n"
  " */";
#else
static const char *Dtool_Texture_might_have_ram_image_1335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_ram_image_size(void) const
 */
static PyObject *Dtool_Texture_get_ram_image_size_1336(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_ram_image_size(void) const
  std::size_t return_value = ((*(const Texture*)local_this).get_ram_image_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_ram_image_size_1336_comment =
  "C++ Interface:\n"
  "get_ram_image_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes used by the in-memory image, across all\n"
  " * pages and views, or 0 if there is no in-memory image.\n"
  " */";
#else
static const char *Dtool_Texture_get_ram_image_size_1336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_ram_view_size(void) const
 */
static PyObject *Dtool_Texture_get_ram_view_size_1337(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_ram_view_size(void) const
  std::size_t return_value = ((*(const Texture*)local_this).get_ram_view_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_ram_view_size_1337_comment =
  "C++ Interface:\n"
  "get_ram_view_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes used by the in-memory image per view, or 0 if\n"
  " * there is no in-memory image.  Since each view is a stack of z_size pages,\n"
  " * this is get_z_size() * get_ram_page_size().\n"
  " */";
#else
static const char *Dtool_Texture_get_ram_view_size_1337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_ram_page_size(void) const
 */
static PyObject *Dtool_Texture_get_ram_page_size_1338(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_ram_page_size(void) const
  std::size_t return_value = ((*(const Texture*)local_this).get_ram_page_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_ram_page_size_1338_comment =
  "C++ Interface:\n"
  "get_ram_page_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes used by the in-memory image per page, or 0 if\n"
  " * there is no in-memory image.\n"
  " *\n"
  " * For a non-compressed texture, this is the same as\n"
  " * get_expected_ram_page_size().  For a compressed texture, this may be a\n"
  " * smaller value.  (We do assume that all pages will be the same size on a\n"
  " * compressed texture).\n"
  " */";
#else
static const char *Dtool_Texture_get_ram_page_size_1338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_expected_ram_image_size(void) const
 */
static PyObject *Dtool_Texture_get_expected_ram_image_size_1339(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_expected_ram_image_size(void) const
  std::size_t return_value = ((*(const Texture*)local_this).get_expected_ram_image_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_expected_ram_image_size_1339_comment =
  "C++ Interface:\n"
  "get_expected_ram_image_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes that *ought* to be used by the in-memory image,\n"
  " * based on the texture parameters.\n"
  " */";
#else
static const char *Dtool_Texture_get_expected_ram_image_size_1339_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_expected_ram_page_size(void) const
 */
static PyObject *Dtool_Texture_get_expected_ram_page_size_1340(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_expected_ram_page_size(void) const
  std::size_t return_value = ((*(const Texture*)local_this).get_expected_ram_page_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_expected_ram_page_size_1340_comment =
  "C++ Interface:\n"
  "get_expected_ram_page_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes that should be used per each Z page of the 3-d\n"
  " * texture.  For a 2-d or 1-d texture, this is the same as\n"
  " * get_expected_ram_image_size().\n"
  " */";
#else
static const char *Dtool_Texture_get_expected_ram_page_size_1340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CPTA_uchar Texture::get_ram_image(void)
 */
static PyObject *Dtool_Texture_get_ram_image_1346(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.get_ram_image")) {
    return nullptr;
  }
  // 1-inline CPTA_uchar Texture::get_ram_image(void)
  CPTA_uchar *return_value = new CPTA_uchar(((*local_this).get_ram_image)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_unsigned_char, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_ram_image_1346_comment =
  "C++ Interface:\n"
  "get_ram_image(const Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the system-RAM image data associated with the texture.  If the\n"
  " * texture does not currently have an associated RAM image, and the texture\n"
  " * was generated by loading an image from a disk file (the most common case),\n"
  " * this forces the reload of the same texture.  This can happen if\n"
  " * keep_texture_ram is configured to false, and we have previously prepared\n"
  " * this texture with a GSG.\n"
  " *\n"
  " * Note that it is not correct to call has_ram_image() first to test whether\n"
  " * this function will fail.  A false return value from has_ram_image()\n"
  " * indicates only that get_ram_image() may need to reload the texture from\n"
  " * disk, which it will do automatically.  However, you can call\n"
  " * might_have_ram_image(), which will return true if the ram image exists, or\n"
  " * there is a reasonable reason to believe it can be loaded.\n"
  " *\n"
  " * On the other hand, it is possible that the texture cannot be found on disk\n"
  " * or is otherwise unavailable.  If that happens, this function will return\n"
  " * NULL. There is no way to predict with 100% accuracy whether get_ram_image()\n"
  " * will return NULL without calling it first; might_have_ram_image() is the\n"
  " * closest.\n"
  " */";
#else
static const char *Dtool_Texture_get_ram_image_1346_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture::CompressionMode Texture::get_ram_image_compression(void) const
 */
static PyObject *Dtool_Texture_get_ram_image_compression_1347(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline Texture::CompressionMode Texture::get_ram_image_compression(void) const
  Texture::CompressionMode return_value = ((*(const Texture*)local_this).get_ram_image_compression)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_ram_image_compression_1347_comment =
  "C++ Interface:\n"
  "get_ram_image_compression(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the compression mode in which the ram image is already stored pre-\n"
  " * compressed.  If this is other than CM_off, you cannot rely on the contents\n"
  " * of the ram image to be anything predicatable (it will not be an array of x\n"
  " * by y pixels, and it probably won't have the same length as\n"
  " * get_expected_ram_image_size()).\n"
  " */";
#else
static const char *Dtool_Texture_get_ram_image_compression_1347_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CPTA_uchar Texture::get_uncompressed_ram_image(void)
 */
static PyObject *Dtool_Texture_get_uncompressed_ram_image_1348(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.get_uncompressed_ram_image")) {
    return nullptr;
  }
  // 1-inline CPTA_uchar Texture::get_uncompressed_ram_image(void)
  CPTA_uchar *return_value = new CPTA_uchar(((*local_this).get_uncompressed_ram_image)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_unsigned_char, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_uncompressed_ram_image_1348_comment =
  "C++ Interface:\n"
  "get_uncompressed_ram_image(const Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the system-RAM image associated with the texture, in an\n"
  " * uncompressed form if at all possible.\n"
  " *\n"
  " * If get_ram_image_compression() is CM_off, then the system-RAM image is\n"
  " * already uncompressed, and this returns the same thing as get_ram_image().\n"
  " *\n"
  " * If get_ram_image_compression() is anything else, then the system-RAM image\n"
  " * is compressed.  In this case, the image will be reloaded from the\n"
  " * *original* file (not from the cache), in the hopes that an uncompressed\n"
  " * image will be found there.\n"
  " *\n"
  " * If an uncompressed image cannot be found, returns NULL.\n"
  " */";
#else
static const char *Dtool_Texture_get_uncompressed_ram_image_1348_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CPTA_uchar Texture::get_ram_image_as(std::string const &requested_format)
 */
static PyObject *Dtool_Texture_get_ram_image_as_1349(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.get_ram_image_as")) {
    return nullptr;
  }
  // 1-CPTA_uchar Texture::get_ram_image_as(std::string const &requested_format)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    CPTA_uchar *return_value = new CPTA_uchar(((*local_this).get_ram_image_as)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_unsigned_char, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ram_image_as(const Texture self, str requested_format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_ram_image_as_1349_comment =
  "C++ Interface:\n"
  "get_ram_image_as(const Texture self, str requested_format)\n"
  "\n"
  "/**\n"
  " * Returns the uncompressed system-RAM image data associated with the texture.\n"
  " * Rather than just returning a pointer to the data, like\n"
  " * get_uncompressed_ram_image, this function first processes the data and\n"
  " * reorders the components using the specified format string, and places these\n"
  " * into a new char array.\n"
  " *\n"
  " * The 'format' argument should specify in which order the components of the\n"
  " * texture must be.  For example, valid format strings are \"RGBA\", \"GA\",\n"
  " * \"ABRG\" or \"AAA\".  A component can also be written as \"0\" or \"1\", which\n"
  " * means an empty/black or a full/white channel, respectively.\n"
  " *\n"
  " * This function is particularly useful to copy an image in-memory to a\n"
  " * different library (for example, PIL or wxWidgets) that require a different\n"
  " * component order than Panda's internal format, BGRA. Note, however, that\n"
  " * this conversion can still be too slow if you want to do it every frame, and\n"
  " * should thus be avoided for that purpose.\n"
  " *\n"
  " * The only requirement for the reordering is that an uncompressed image must\n"
  " * be available.  If the RAM image is compressed, it will attempt to re-load\n"
  " * the texture from disk, if it doesn't find an uncompressed image there, it\n"
  " * will return NULL.\n"
  " */";
#else
static const char *Dtool_Texture_get_ram_image_as_1349_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PTA_uchar Texture::modify_ram_image(void)
 */
static PyObject *Dtool_Texture_modify_ram_image_1350(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.modify_ram_image")) {
    return nullptr;
  }
  // 1-inline PTA_uchar Texture::modify_ram_image(void)
  PTA_uchar *return_value = new PTA_uchar(((*local_this).modify_ram_image)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_unsigned_char, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_modify_ram_image_1350_comment =
  "C++ Interface:\n"
  "modify_ram_image(const Texture self)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the system-RAM image.  This assumes the RAM\n"
  " * image should be uncompressed.  If the RAM image has been dumped, or is\n"
  " * stored compressed, creates a new one.\n"
  " *\n"
  " * This does *not* affect keep_ram_image.\n"
  " */";
#else
static const char *Dtool_Texture_modify_ram_image_1350_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PTA_uchar Texture::make_ram_image(void)
 */
static PyObject *Dtool_Texture_make_ram_image_1351(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.make_ram_image")) {
    return nullptr;
  }
  // 1-inline PTA_uchar Texture::make_ram_image(void)
  PTA_uchar *return_value = new PTA_uchar(((*local_this).make_ram_image)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_unsigned_char, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_make_ram_image_1351_comment =
  "C++ Interface:\n"
  "make_ram_image(const Texture self)\n"
  "\n"
  "/**\n"
  " * Discards the current system-RAM image for the texture, if any, and\n"
  " * allocates a new buffer of the appropriate size.  Returns the new buffer.\n"
  " *\n"
  " * This does *not* affect keep_ram_image.\n"
  " */";
#else
static const char *Dtool_Texture_make_ram_image_1351_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::set_ram_image(PyObject *image, Texture::CompressionMode compression = ::Texture::CM_off, std::size_t page_size = 0)
 */
static PyObject *Dtool_Texture_set_ram_image_1352(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_ram_image")) {
    return nullptr;
  }
  // 1-void Texture::set_ram_image(PyObject *image, Texture::CompressionMode compression = ::Texture::CM_off, std::size_t page_size = 0)
  PyObject *param1;
  int param2 = Texture::CM_off;
  Py_ssize_t param3 = 0;
  static const char *keyword_list[] = {"image", "compression", "page_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|in:set_ram_image", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param3 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param3);
    }
#endif
    invoke_extension(local_this).set_ram_image(param1, (Texture::CompressionMode)param2, (std::size_t)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ram_image(const Texture self, object image, int compression, int page_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_ram_image_1352_comment =
  "C++ Interface:\n"
  "set_ram_image(const Texture self, object image, int compression, int page_size)\n"
  "\n"
  "/**\n"
  " * Replaces the current system-RAM image with the new data.  If compression is\n"
  " * not CM_off, it indicates that the new data is already pre-compressed in the\n"
  " * indicated format.\n"
  " *\n"
  " * This does *not* affect keep_ram_image.\n"
  " */";
#else
static const char *Dtool_Texture_set_ram_image_1352_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::set_ram_image_as(PyObject *image, std::string const &provided_format)
 */
static PyObject *Dtool_Texture_set_ram_image_as_1353(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_ram_image_as")) {
    return nullptr;
  }
  // 1-void Texture::set_ram_image_as(PyObject *image, std::string const &provided_format)
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"image", "provided_format", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:set_ram_image_as", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    invoke_extension(local_this).set_ram_image_as(param1, std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ram_image_as(const Texture self, object image, str provided_format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_ram_image_as_1353_comment =
  "C++ Interface:\n"
  "set_ram_image_as(const Texture self, object image, str provided_format)\n"
  "\n"
  "/**\n"
  " * Replaces the current system-RAM image with the new data, converting it\n"
  " * first if necessary from the indicated component-order format.  See\n"
  " * get_ram_image_as() for specifications about the format.  This method cannot\n"
  " * support compressed image data or sub-pages; use set_ram_image() for that.\n"
  " */";
#else
static const char *Dtool_Texture_set_ram_image_as_1353_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::clear_ram_image(void)
 */
static PyObject *Dtool_Texture_clear_ram_image_1354(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_ram_image")) {
    return nullptr;
  }
  // 1-inline void Texture::clear_ram_image(void)
  ((*local_this).clear_ram_image)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_ram_image_1354_comment =
  "C++ Interface:\n"
  "clear_ram_image(const Texture self)\n"
  "\n"
  "/**\n"
  " * Discards the current system-RAM image.\n"
  " */";
#else
static const char *Dtool_Texture_clear_ram_image_1354_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_keep_ram_image(bool keep_ram_image)
 */
static PyObject *Dtool_Texture_set_keep_ram_image_1355(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_keep_ram_image")) {
    return nullptr;
  }
  // 1-inline void Texture::set_keep_ram_image(bool keep_ram_image)
  ((*local_this).set_keep_ram_image)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_keep_ram_image(const Texture self, bool keep_ram_image)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_keep_ram_image_1355_comment =
  "C++ Interface:\n"
  "set_keep_ram_image(const Texture self, bool keep_ram_image)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates whether this Texture is eligible to have its\n"
  " * main RAM copy of the texture memory dumped when the texture is prepared for\n"
  " * rendering.\n"
  " *\n"
  " * This will be false for most textures, which can reload their images if\n"
  " * needed by rereading the input file.  However, textures that were generated\n"
  " * dynamically and cannot be easily reloaded will want to set this flag to\n"
  " * true, so that the texture will always keep its image copy around.\n"
  " */";
#else
static const char *Dtool_Texture_set_keep_ram_image_1355_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool Texture::get_keep_ram_image(void) const
 */
static PyObject *Dtool_Texture_get_keep_ram_image_1356(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-virtual bool Texture::get_keep_ram_image(void) const
  bool return_value = ((*(const Texture*)local_this).get_keep_ram_image)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_keep_ram_image_1356_comment =
  "C++ Interface:\n"
  "get_keep_ram_image(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the flag that indicates whether this Texture is eligible to have\n"
  " * its main RAM copy of the texture memory dumped when the texture is prepared\n"
  " * for rendering.  See set_keep_ram_image().\n"
  " */";
#else
static const char *Dtool_Texture_get_keep_ram_image_1356_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool Texture::is_cacheable(void) const
 */
static PyObject *Dtool_Texture_is_cacheable_1357(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-virtual bool Texture::is_cacheable(void) const
  bool return_value = ((*(const Texture*)local_this).is_cacheable)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_is_cacheable_1357_comment =
  "C++ Interface:\n"
  "is_cacheable(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is enough information in this Texture object to write\n"
  " * it to the bam cache successfully, false otherwise.  For most textures, this\n"
  " * is the same as has_ram_image().\n"
  " */";
#else
static const char *Dtool_Texture_is_cacheable_1357_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::compress_ram_image(Texture::CompressionMode compression = ::Texture::CM_on, Texture::QualityLevel quality_level = ::Texture::QL_default, GraphicsStateGuardianBase *gsg = nullptr)
 */
static PyObject *Dtool_Texture_compress_ram_image_1361(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.compress_ram_image")) {
    return nullptr;
  }
  // 1-inline bool Texture::compress_ram_image(Texture::CompressionMode compression = ::Texture::CM_on, Texture::QualityLevel quality_level = ::Texture::QL_default, GraphicsStateGuardianBase *gsg = nullptr)
  int param1 = Texture::CM_on;
  int param2 = Texture::QL_default;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"compression", "quality_level", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|iiO:compress_ram_image", (char **)keyword_list, &param1, &param2, &param3)) {
    GraphicsStateGuardianBase *param3_this = nullptr;
    if (param3 != nullptr && param3 != Py_None) {
      param3_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_GraphicsStateGuardianBase, 3, "Texture.compress_ram_image", false, true);
    }
    if ((param3 == nullptr || param3 == Py_None || param3_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*local_this).compress_ram_image)((Texture::CompressionMode)param1, (Texture::QualityLevel)param2, param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compress_ram_image(const Texture self, int compression, int quality_level, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_compress_ram_image_1361_comment =
  "C++ Interface:\n"
  "compress_ram_image(const Texture self, int compression, int quality_level, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Attempts to compress the texture's RAM image internally, to a format\n"
  " * supported by the indicated GSG.  In order for this to work, the squish\n"
  " * library must have been compiled into Panda.\n"
  " *\n"
  " * If compression is CM_on, then an appropriate compression method that is\n"
  " * supported by the indicated GSG is automatically chosen.  If the GSG pointer\n"
  " * is NULL, any of the standard DXT1/3/5 compression methods will be used,\n"
  " * regardless of whether it is supported.\n"
  " *\n"
  " * If compression is any specific compression method, that method is used\n"
  " * regardless of whether the GSG supports it.\n"
  " *\n"
  " * quality_level determines the speed/quality tradeoff of the compression.  If\n"
  " * it is QL_default, the texture's own quality_level parameter is used.\n"
  " *\n"
  " * Returns true if successful, false otherwise.\n"
  " */";
#else
static const char *Dtool_Texture_compress_ram_image_1361_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::uncompress_ram_image(void)
 */
static PyObject *Dtool_Texture_uncompress_ram_image_1362(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.uncompress_ram_image")) {
    return nullptr;
  }
  // 1-inline bool Texture::uncompress_ram_image(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).uncompress_ram_image)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_uncompress_ram_image_1362_comment =
  "C++ Interface:\n"
  "uncompress_ram_image(const Texture self)\n"
  "\n"
  "/**\n"
  " * Attempts to uncompress the texture's RAM image internally.  In order for\n"
  " * this to work, the squish library must have been compiled into Panda, and\n"
  " * the ram image must be compressed in a format supported by squish.\n"
  " *\n"
  " * Returns true if successful, false otherwise.\n"
  " */";
#else
static const char *Dtool_Texture_uncompress_ram_image_1362_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_num_ram_mipmap_images(void) const
 */
static PyObject *Dtool_Texture_get_num_ram_mipmap_images_1363(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_num_ram_mipmap_images(void) const
  int return_value = ((*(const Texture*)local_this).get_num_ram_mipmap_images)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_num_ram_mipmap_images_1363_comment =
  "C++ Interface:\n"
  "get_num_ram_mipmap_images(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of mipmap level images available in system\n"
  " * memory.  The actual number may be less than this (that is, there might be\n"
  " * gaps in the sequence); use has_ram_mipmap_image() to verify each level.\n"
  " *\n"
  " * Also see get_num_loadable_ram_mipmap_images().\n"
  " */";
#else
static const char *Dtool_Texture_get_num_ram_mipmap_images_1363_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_ram_mipmap_image(int n) const
 */
static PyObject *Dtool_Texture_has_ram_mipmap_image_1364(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_ram_mipmap_image(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const Texture*)local_this).has_ram_mipmap_image)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_ram_mipmap_image(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_ram_mipmap_image_1364_comment =
  "C++ Interface:\n"
  "has_ram_mipmap_image(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the Texture has the nth mipmap level available in system\n"
  " * memory, false otherwise.  If the texture's minfilter mode requires\n"
  " * mipmapping (see uses_mipmaps()), and all the texture's mipmap levels are\n"
  " * not available when the texture is rendered, they will be generated\n"
  " * automatically.\n"
  " */";
#else
static const char *Dtool_Texture_has_ram_mipmap_image_1364_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Texture::get_num_loadable_ram_mipmap_images(void) const
 */
static PyObject *Dtool_Texture_get_num_loadable_ram_mipmap_images_1365(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-int Texture::get_num_loadable_ram_mipmap_images(void) const
  int return_value = ((*(const Texture*)local_this).get_num_loadable_ram_mipmap_images)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_num_loadable_ram_mipmap_images_1365_comment =
  "C++ Interface:\n"
  "get_num_loadable_ram_mipmap_images(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the number of contiguous mipmap levels that exist in RAM, up until\n"
  " * the first gap in the sequence.  It is guaranteed that at least mipmap\n"
  " * levels [0, get_num_ram_mipmap_images()) exist.\n"
  " *\n"
  " * The number returned will never exceed the number of required mipmap images\n"
  " * based on the size of the texture and its filter mode.\n"
  " *\n"
  " * This method is different from get_num_ram_mipmap_images() in that it\n"
  " * returns only the number of mipmap levels that can actually be usefully\n"
  " * loaded, regardless of the actual number that may be stored.\n"
  " */";
#else
static const char *Dtool_Texture_get_num_loadable_ram_mipmap_images_1365_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_all_ram_mipmap_images(void) const
 */
static PyObject *Dtool_Texture_has_all_ram_mipmap_images_1366(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_all_ram_mipmap_images(void) const
  bool return_value = ((*(const Texture*)local_this).has_all_ram_mipmap_images)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_all_ram_mipmap_images_1366_comment =
  "C++ Interface:\n"
  "has_all_ram_mipmap_images(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if all expected mipmap levels have been defined and exist in\n"
  " * the system RAM, or false if even one mipmap level is missing.\n"
  " */";
#else
static const char *Dtool_Texture_has_all_ram_mipmap_images_1366_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_ram_mipmap_image_size(int n) const
 */
static PyObject *Dtool_Texture_get_ram_mipmap_image_size_1367(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_ram_mipmap_image_size(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = ((*(const Texture*)local_this).get_ram_mipmap_image_size)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ram_mipmap_image_size(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_ram_mipmap_image_size_1367_comment =
  "C++ Interface:\n"
  "get_ram_mipmap_image_size(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes used by the in-memory image for mipmap level n,\n"
  " * or 0 if there is no in-memory image for this mipmap level.\n"
  " */";
#else
static const char *Dtool_Texture_get_ram_mipmap_image_size_1367_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_ram_mipmap_view_size(int n) const
 */
static PyObject *Dtool_Texture_get_ram_mipmap_view_size_1368(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_ram_mipmap_view_size(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = ((*(const Texture*)local_this).get_ram_mipmap_view_size)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ram_mipmap_view_size(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_ram_mipmap_view_size_1368_comment =
  "C++ Interface:\n"
  "get_ram_mipmap_view_size(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes used by the in-memory image per view for mipmap\n"
  " * level n, or 0 if there is no in-memory image for this mipmap level.\n"
  " *\n"
  " * A \"view\" is a collection of z_size pages for each mipmap level.  Most\n"
  " * textures have only one view, except for multiview or stereo textures.\n"
  " *\n"
  " * For a non-compressed texture, this is the same as\n"
  " * get_expected_ram_mipmap_view_size().  For a compressed texture, this may be\n"
  " * a smaller value.  (We do assume that all pages will be the same size on a\n"
  " * compressed texture).\n"
  " */";
#else
static const char *Dtool_Texture_get_ram_mipmap_view_size_1368_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_ram_mipmap_page_size(int n) const
 */
static PyObject *Dtool_Texture_get_ram_mipmap_page_size_1369(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_ram_mipmap_page_size(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = ((*(const Texture*)local_this).get_ram_mipmap_page_size)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ram_mipmap_page_size(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_ram_mipmap_page_size_1369_comment =
  "C++ Interface:\n"
  "get_ram_mipmap_page_size(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes used by the in-memory image per page for mipmap\n"
  " * level n, or 0 if there is no in-memory image for this mipmap level.\n"
  " *\n"
  " * For a non-compressed texture, this is the same as\n"
  " * get_expected_ram_mipmap_page_size().  For a compressed texture, this may be\n"
  " * a smaller value.  (We do assume that all pages will be the same size on a\n"
  " * compressed texture).\n"
  " */";
#else
static const char *Dtool_Texture_get_ram_mipmap_page_size_1369_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_expected_ram_mipmap_image_size(int n) const
 */
static PyObject *Dtool_Texture_get_expected_ram_mipmap_image_size_1370(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_expected_ram_mipmap_image_size(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = ((*(const Texture*)local_this).get_expected_ram_mipmap_image_size)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_expected_ram_mipmap_image_size(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_expected_ram_mipmap_image_size_1370_comment =
  "C++ Interface:\n"
  "get_expected_ram_mipmap_image_size(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes that *ought* to be used by the in-memory image\n"
  " * for mipmap level n, based on the texture parameters.\n"
  " */";
#else
static const char *Dtool_Texture_get_expected_ram_mipmap_image_size_1370_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_expected_ram_mipmap_view_size(int n) const
 */
static PyObject *Dtool_Texture_get_expected_ram_mipmap_view_size_1371(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_expected_ram_mipmap_view_size(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = ((*(const Texture*)local_this).get_expected_ram_mipmap_view_size)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_expected_ram_mipmap_view_size(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_expected_ram_mipmap_view_size_1371_comment =
  "C++ Interface:\n"
  "get_expected_ram_mipmap_view_size(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes that *ought* to be used by each view of the in-\n"
  " * memory image for mipmap level n, based on the texture parameters.  For a\n"
  " * normal, non-multiview texture, this is the same as\n"
  " * get_expected_ram_mipmap_image_size(n).\n"
  " */";
#else
static const char *Dtool_Texture_get_expected_ram_mipmap_view_size_1371_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_expected_ram_mipmap_page_size(int n) const
 */
static PyObject *Dtool_Texture_get_expected_ram_mipmap_page_size_1372(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_expected_ram_mipmap_page_size(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = ((*(const Texture*)local_this).get_expected_ram_mipmap_page_size)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_expected_ram_mipmap_page_size(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_expected_ram_mipmap_page_size_1372_comment =
  "C++ Interface:\n"
  "get_expected_ram_mipmap_page_size(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes that should be used per each Z page of the 3-d\n"
  " * texture, for mipmap level n.  For a 2-d or 1-d texture, this is the same as\n"
  " * get_expected_ram_mipmap_view_size(n).\n"
  " */";
#else
static const char *Dtool_Texture_get_expected_ram_mipmap_page_size_1372_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CPTA_uchar Texture::get_ram_mipmap_image(int n) const
 */
static PyObject *Dtool_Texture_get_ram_mipmap_image_1373(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-CPTA_uchar Texture::get_ram_mipmap_image(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CPTA_uchar *return_value = new CPTA_uchar(((*(const Texture*)local_this).get_ram_mipmap_image)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_unsigned_char, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ram_mipmap_image(Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_ram_mipmap_image_1373_comment =
  "C++ Interface:\n"
  "get_ram_mipmap_image(Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the system-RAM image data associated with the nth mipmap level, if\n"
  " * present.  Returns NULL if the nth mipmap level is not present.\n"
  " */";
#else
static const char *Dtool_Texture_get_ram_mipmap_image_1373_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PTA_uchar Texture::modify_ram_mipmap_image(int n)
 */
static PyObject *Dtool_Texture_modify_ram_mipmap_image_1375(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.modify_ram_mipmap_image")) {
    return nullptr;
  }
  // 1-inline PTA_uchar Texture::modify_ram_mipmap_image(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PTA_uchar *return_value = new PTA_uchar(((*local_this).modify_ram_mipmap_image)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_unsigned_char, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_ram_mipmap_image(const Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_modify_ram_mipmap_image_1375_comment =
  "C++ Interface:\n"
  "modify_ram_mipmap_image(const Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the system-RAM image for the nth mipmap\n"
  " * level.  This assumes the RAM image is uncompressed; if this is not the\n"
  " * case, raises an assertion.\n"
  " *\n"
  " * This does *not* affect keep_ram_image.\n"
  " */";
#else
static const char *Dtool_Texture_modify_ram_mipmap_image_1375_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PTA_uchar Texture::make_ram_mipmap_image(int n)
 */
static PyObject *Dtool_Texture_make_ram_mipmap_image_1376(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.make_ram_mipmap_image")) {
    return nullptr;
  }
  // 1-inline PTA_uchar Texture::make_ram_mipmap_image(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PTA_uchar *return_value = new PTA_uchar(((*local_this).make_ram_mipmap_image)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_unsigned_char, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_ram_mipmap_image(const Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_make_ram_mipmap_image_1376_comment =
  "C++ Interface:\n"
  "make_ram_mipmap_image(const Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Discards the current system-RAM image for the nth mipmap level, if any, and\n"
  " * allocates a new buffer of the appropriate size.  Returns the new buffer.\n"
  " *\n"
  " * This does *not* affect keep_ram_image.\n"
  " */";
#else
static const char *Dtool_Texture_make_ram_mipmap_image_1376_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::set_ram_mipmap_pointer_from_int(long long int pointer, int n, int page_size)
 */
static PyObject *Dtool_Texture_set_ram_mipmap_pointer_from_int_1378(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_ram_mipmap_pointer_from_int")) {
    return nullptr;
  }
  // 1-void Texture::set_ram_mipmap_pointer_from_int(long long int pointer, int n, int page_size)
  PY_LONG_LONG param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"pointer", "n", "page_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Lii:set_ram_mipmap_pointer_from_int", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_ram_mipmap_pointer_from_int)((long long int)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ram_mipmap_pointer_from_int(const Texture self, long pointer, int n, int page_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_ram_mipmap_pointer_from_int_1378_comment =
  "C++ Interface:\n"
  "set_ram_mipmap_pointer_from_int(const Texture self, long pointer, int n, int page_size)\n"
  "\n"
  "/**\n"
  " * Accepts a raw pointer cast as an int, which is then passed to\n"
  " * set_ram_mipmap_pointer(); see the documentation for that method.\n"
  " *\n"
  " * This variant is particularly useful to set an external pointer from a\n"
  " * language like Python, which doesn't support void pointers directly.\n"
  " */";
#else
static const char *Dtool_Texture_set_ram_mipmap_pointer_from_int_1378_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_ram_mipmap_image(int n, CPTA_uchar image, std::size_t page_size = 0)
 */
static PyObject *Dtool_Texture_set_ram_mipmap_image_1379(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_ram_mipmap_image")) {
    return nullptr;
  }
  // 1-inline void Texture::set_ram_mipmap_image(int n, CPTA_uchar image, std::size_t page_size = 0)
  int param1;
  PyObject *param2;
  Py_ssize_t param3 = 0;
  static const char *keyword_list[] = {"n", "image", "page_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO|n:set_ram_mipmap_image", (char **)keyword_list, &param1, &param2, &param3)) {
    ConstPointerToArray< unsigned char > param2_local;
    CPTA_uchar *param2_this = Dtool_Coerce_ConstPointerToArray_unsigned_char(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Texture.set_ram_mipmap_image", "ConstPointerToArray");
    }
#ifndef NDEBUG
    if (param3 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param3);
    }
#endif
    ((*local_this).set_ram_mipmap_image)((int)param1, *param2_this, (std::size_t)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ram_mipmap_image(const Texture self, int n, ConstPointerToArray image, int page_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_ram_mipmap_image_1379_comment =
  "C++ Interface:\n"
  "set_ram_mipmap_image(const Texture self, int n, ConstPointerToArray image, int page_size)\n"
  "\n"
  "/**\n"
  " * Replaces the current system-RAM image for the indicated mipmap level with\n"
  " * the new data.  If compression is not CM_off, it indicates that the new data\n"
  " * is already pre-compressed in the indicated format.\n"
  " *\n"
  " * This does *not* affect keep_ram_image.\n"
  " */";
#else
static const char *Dtool_Texture_set_ram_mipmap_image_1379_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::clear_ram_mipmap_image(int n)
 */
static PyObject *Dtool_Texture_clear_ram_mipmap_image_1380(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_ram_mipmap_image")) {
    return nullptr;
  }
  // 1-void Texture::clear_ram_mipmap_image(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).clear_ram_mipmap_image)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_ram_mipmap_image(const Texture self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_ram_mipmap_image_1380_comment =
  "C++ Interface:\n"
  "clear_ram_mipmap_image(const Texture self, int n)\n"
  "\n"
  "/**\n"
  " * Discards the current system-RAM image for the nth mipmap level.\n"
  " */";
#else
static const char *Dtool_Texture_clear_ram_mipmap_image_1380_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::clear_ram_mipmap_images(void)
 */
static PyObject *Dtool_Texture_clear_ram_mipmap_images_1381(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_ram_mipmap_images")) {
    return nullptr;
  }
  // 1-inline void Texture::clear_ram_mipmap_images(void)
  ((*local_this).clear_ram_mipmap_images)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_ram_mipmap_images_1381_comment =
  "C++ Interface:\n"
  "clear_ram_mipmap_images(const Texture self)\n"
  "\n"
  "/**\n"
  " * Discards the current system-RAM image for all mipmap levels, except level 0\n"
  " * (the base image).\n"
  " */";
#else
static const char *Dtool_Texture_clear_ram_mipmap_images_1381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::generate_ram_mipmap_images(void)
 */
static PyObject *Dtool_Texture_generate_ram_mipmap_images_1382(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.generate_ram_mipmap_images")) {
    return nullptr;
  }
  // 1-inline void Texture::generate_ram_mipmap_images(void)
  ((*local_this).generate_ram_mipmap_images)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_generate_ram_mipmap_images_1382_comment =
  "C++ Interface:\n"
  "generate_ram_mipmap_images(const Texture self)\n"
  "\n"
  "/**\n"
  " * Automatically fills in the n mipmap levels of the Texture, based on the\n"
  " * texture's source image.  This requires the texture's uncompressed ram image\n"
  " * to be available in system memory.  If it is not already, it will be fetched\n"
  " * if possible.\n"
  " *\n"
  " * This call is not normally necessary, since the mipmap levels will be\n"
  " * generated automatically if needed.  But there may be certain cases in which\n"
  " * you would like to call this explicitly.\n"
  " */";
#else
static const char *Dtool_Texture_generate_ram_mipmap_images_1382_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_simple_x_size(void) const
 */
static PyObject *Dtool_Texture_get_simple_x_size_1385(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_simple_x_size(void) const
  int return_value = ((*(const Texture*)local_this).get_simple_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_simple_x_size_1385_comment =
  "C++ Interface:\n"
  "get_simple_x_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the width of the \"simple\" image in texels.\n"
  " */";
#else
static const char *Dtool_Texture_get_simple_x_size_1385_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_simple_y_size(void) const
 */
static PyObject *Dtool_Texture_get_simple_y_size_1386(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_simple_y_size(void) const
  int return_value = ((*(const Texture*)local_this).get_simple_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_simple_y_size_1386_comment =
  "C++ Interface:\n"
  "get_simple_y_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the height of the \"simple\" image in texels.\n"
  " */";
#else
static const char *Dtool_Texture_get_simple_y_size_1386_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_simple_ram_image(void) const
 */
static PyObject *Dtool_Texture_has_simple_ram_image_1387(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_simple_ram_image(void) const
  bool return_value = ((*(const Texture*)local_this).has_simple_ram_image)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_simple_ram_image_1387_comment =
  "C++ Interface:\n"
  "has_simple_ram_image(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Texture has a \"simple\" image available in main RAM.\n"
  " */";
#else
static const char *Dtool_Texture_has_simple_ram_image_1387_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Texture::get_simple_ram_image_size(void) const
 */
static PyObject *Dtool_Texture_get_simple_ram_image_size_1388(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline std::size_t Texture::get_simple_ram_image_size(void) const
  std::size_t return_value = ((*(const Texture*)local_this).get_simple_ram_image_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_simple_ram_image_size_1388_comment =
  "C++ Interface:\n"
  "get_simple_ram_image_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes used by the \"simple\" image, or 0 if there is no\n"
  " * simple image.\n"
  " */";
#else
static const char *Dtool_Texture_get_simple_ram_image_size_1388_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CPTA_uchar Texture::get_simple_ram_image(void) const
 */
static PyObject *Dtool_Texture_get_simple_ram_image_1389(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline CPTA_uchar Texture::get_simple_ram_image(void) const
  CPTA_uchar *return_value = new CPTA_uchar(((*(const Texture*)local_this).get_simple_ram_image)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_unsigned_char, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_simple_ram_image_1389_comment =
  "C++ Interface:\n"
  "get_simple_ram_image(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the image data associated with the \"simple\" texture image.  This is\n"
  " * provided for some textures as an option to display while the main texture\n"
  " * image is being loaded from disk.\n"
  " *\n"
  " * Unlike get_ram_image(), this function will always return immediately.\n"
  " * Either the simple image is available, or it is not.\n"
  " *\n"
  " * The \"simple\" image is always 4 components, 1 byte each, regardless of the\n"
  " * parameters of the full texture.  The simple image is only supported for\n"
  " * ordinary 2-d textures.\n"
  " */";
#else
static const char *Dtool_Texture_get_simple_ram_image_1389_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_simple_ram_image(CPTA_uchar image, int x_size, int y_size)
 */
static PyObject *Dtool_Texture_set_simple_ram_image_1390(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_simple_ram_image")) {
    return nullptr;
  }
  // 1-inline void Texture::set_simple_ram_image(CPTA_uchar image, int x_size, int y_size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"image", "x_size", "y_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_simple_ram_image", (char **)keyword_list, &param1, &param2, &param3)) {
    ConstPointerToArray< unsigned char > param1_local;
    CPTA_uchar *param1_this = Dtool_Coerce_ConstPointerToArray_unsigned_char(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Texture.set_simple_ram_image", "ConstPointerToArray");
    }
    ((*local_this).set_simple_ram_image)(*param1_this, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_simple_ram_image(const Texture self, ConstPointerToArray image, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_simple_ram_image_1390_comment =
  "C++ Interface:\n"
  "set_simple_ram_image(const Texture self, ConstPointerToArray image, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Replaces the internal \"simple\" texture image.  This can be used as an\n"
  " * option to display while the main texture image is being loaded from disk.\n"
  " * It is normally a very small image, 16x16 or smaller (and maybe even 1x1),\n"
  " * that is designed to give just enough sense of color to serve as a\n"
  " * placeholder until the full texture is available.\n"
  " *\n"
  " * The \"simple\" image is always 4 components, 1 byte each, regardless of the\n"
  " * parameters of the full texture.  The simple image is only supported for\n"
  " * ordinary 2-d textures.\n"
  " *\n"
  " * Also see generate_simple_ram_image(), modify_simple_ram_image(), and\n"
  " * new_simple_ram_image().\n"
  " */";
#else
static const char *Dtool_Texture_set_simple_ram_image_1390_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PTA_uchar Texture::modify_simple_ram_image(void)
 */
static PyObject *Dtool_Texture_modify_simple_ram_image_1391(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.modify_simple_ram_image")) {
    return nullptr;
  }
  // 1-PTA_uchar Texture::modify_simple_ram_image(void)
  PTA_uchar *return_value = new PTA_uchar(((*local_this).modify_simple_ram_image)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_unsigned_char, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_modify_simple_ram_image_1391_comment =
  "C++ Interface:\n"
  "modify_simple_ram_image(const Texture self)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the internal \"simple\" texture image.  See\n"
  " * set_simple_ram_image().\n"
  " */";
#else
static const char *Dtool_Texture_modify_simple_ram_image_1391_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PTA_uchar Texture::new_simple_ram_image(int x_size, int y_size)
 */
static PyObject *Dtool_Texture_new_simple_ram_image_1392(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.new_simple_ram_image")) {
    return nullptr;
  }
  // 1-PTA_uchar Texture::new_simple_ram_image(int x_size, int y_size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x_size", "y_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:new_simple_ram_image", (char **)keyword_list, &param1, &param2)) {
    PTA_uchar *return_value = new PTA_uchar(((*local_this).new_simple_ram_image)((int)param1, (int)param2));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_unsigned_char, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "new_simple_ram_image(const Texture self, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_new_simple_ram_image_1392_comment =
  "C++ Interface:\n"
  "new_simple_ram_image(const Texture self, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Creates an empty array for the simple ram image of the indicated size, and\n"
  " * returns a modifiable pointer to the new array.  See set_simple_ram_image().\n"
  " */";
#else
static const char *Dtool_Texture_new_simple_ram_image_1392_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::generate_simple_ram_image(void)
 */
static PyObject *Dtool_Texture_generate_simple_ram_image_1393(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.generate_simple_ram_image")) {
    return nullptr;
  }
  // 1-void Texture::generate_simple_ram_image(void)
  ((*local_this).generate_simple_ram_image)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_generate_simple_ram_image_1393_comment =
  "C++ Interface:\n"
  "generate_simple_ram_image(const Texture self)\n"
  "\n"
  "/**\n"
  " * Computes the \"simple\" ram image by loading the main RAM image, if it is not\n"
  " * already available, and reducing it to 16x16 or smaller.  This may be an\n"
  " * expensive operation.\n"
  " */";
#else
static const char *Dtool_Texture_generate_simple_ram_image_1393_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::clear_simple_ram_image(void)
 */
static PyObject *Dtool_Texture_clear_simple_ram_image_1394(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_simple_ram_image")) {
    return nullptr;
  }
  // 1-inline void Texture::clear_simple_ram_image(void)
  ((*local_this).clear_simple_ram_image)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_simple_ram_image_1394_comment =
  "C++ Interface:\n"
  "clear_simple_ram_image(const Texture self)\n"
  "\n"
  "/**\n"
  " * Discards the current \"simple\" image.\n"
  " */";
#else
static const char *Dtool_Texture_clear_simple_ram_image_1394_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< TexturePeeker > Texture::peek(void)
 */
static PyObject *Dtool_Texture_peek_1400(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.peek")) {
    return nullptr;
  }
  // 1-PointerTo< TexturePeeker > Texture::peek(void)
  PointerTo< TexturePeeker > return_value = ((*local_this).peek)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TexturePeeker *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TexturePeeker, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_peek_1400_comment =
  "C++ Interface:\n"
  "peek(const Texture self)\n"
  "\n"
  "/**\n"
  " * Returns a TexturePeeker object that can be used to examine the individual\n"
  " * texels stored within this Texture by (u, v) coordinate.\n"
  " *\n"
  " * If the texture has a ram image resident, that image is used.  If it does\n"
  " * not have a full ram image but does have a simple_ram_image resident, that\n"
  " * image is used instead.  If neither image is resident the full image is\n"
  " * reloaded.\n"
  " *\n"
  " * Returns NULL if the texture cannot find an image to load, or the texture\n"
  " * format is incompatible.\n"
  " */";
#else
static const char *Dtool_Texture_peek_1400_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq Texture::get_properties_modified(void) const
 */
static PyObject *Dtool_Texture_get_properties_modified_1401(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline UpdateSeq Texture::get_properties_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const Texture*)local_this).get_properties_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_properties_modified_1401_comment =
  "C++ Interface:\n"
  "get_properties_modified(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number which is guaranteed to change at least every time\n"
  " * the texture properties (unrelated to the image) are modified.\n"
  " */";
#else
static const char *Dtool_Texture_get_properties_modified_1401_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq Texture::get_image_modified(void) const
 */
static PyObject *Dtool_Texture_get_image_modified_1402(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline UpdateSeq Texture::get_image_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const Texture*)local_this).get_image_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_image_modified_1402_comment =
  "C++ Interface:\n"
  "get_image_modified(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number which is guaranteed to change at least every time\n"
  " * the texture image data (including mipmap levels) are modified.\n"
  " */";
#else
static const char *Dtool_Texture_get_image_modified_1402_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq Texture::get_simple_image_modified(void) const
 */
static PyObject *Dtool_Texture_get_simple_image_modified_1403(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline UpdateSeq Texture::get_simple_image_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const Texture*)local_this).get_simple_image_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_simple_image_modified_1403_comment =
  "C++ Interface:\n"
  "get_simple_image_modified(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number which is guaranteed to change at least every time\n"
  " * the texture's \"simple\" image data is modified.\n"
  " */";
#else
static const char *Dtool_Texture_get_simple_image_modified_1403_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::has_auto_texture_scale(void) const
 */
static PyObject *Dtool_Texture_has_auto_texture_scale_1407(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::has_auto_texture_scale(void) const
  bool return_value = ((*(const Texture*)local_this).has_auto_texture_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_auto_texture_scale_1407_comment =
  "C++ Interface:\n"
  "has_auto_texture_scale(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_auto_texture_scale() has been set to something other\n"
  " * than ATS_unspecified for this particular texture.\n"
  " */";
#else
static const char *Dtool_Texture_has_auto_texture_scale_1407_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AutoTextureScale Texture::get_auto_texture_scale(void) const
 */
static PyObject *Dtool_Texture_get_auto_texture_scale_1408(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline AutoTextureScale Texture::get_auto_texture_scale(void) const
  AutoTextureScale return_value = ((*(const Texture*)local_this).get_auto_texture_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_auto_texture_scale_1408_comment =
  "C++ Interface:\n"
  "get_auto_texture_scale(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the power-of-2 texture-scaling mode that will be applied to this\n"
  " * particular texture when it is next loaded from disk.  See\n"
  " * set_textures_power_2().\n"
  " */";
#else
static const char *Dtool_Texture_get_auto_texture_scale_1408_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_auto_texture_scale(AutoTextureScale scale)
 */
static PyObject *Dtool_Texture_set_auto_texture_scale_1409(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_auto_texture_scale")) {
    return nullptr;
  }
  // 1-inline void Texture::set_auto_texture_scale(AutoTextureScale scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_auto_texture_scale)((AutoTextureScale)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_texture_scale(const Texture self, int scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_auto_texture_scale_1409_comment =
  "C++ Interface:\n"
  "set_auto_texture_scale(const Texture self, int scale)\n"
  "\n"
  "/**\n"
  " * Specifies the power-of-2 texture-scaling mode that will be applied to this\n"
  " * particular texture when it is next loaded from disk.  See\n"
  " * set_textures_power_2().\n"
  " */";
#else
static const char *Dtool_Texture_set_auto_texture_scale_1409_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< AsyncFuture > Texture::prepare(PreparedGraphicsObjects *prepared_objects)
 */
static PyObject *Dtool_Texture_prepare_1412(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.prepare")) {
    return nullptr;
  }
  // 1-PointerTo< AsyncFuture > Texture::prepare(PreparedGraphicsObjects *prepared_objects)
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Texture.prepare", false, true);
  if (arg_this != nullptr) {
    PointerTo< AsyncFuture > return_value = ((*local_this).prepare)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    AsyncFuture *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AsyncFuture, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare(const Texture self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_prepare_1412_comment =
  "C++ Interface:\n"
  "prepare(const Texture self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Indicates that the texture should be enqueued to be prepared in the\n"
  " * indicated prepared_objects at the beginning of the next frame.  This will\n"
  " * ensure the texture is already loaded into texture memory if it is expected\n"
  " * to be rendered soon.\n"
  " *\n"
  " * Use this function instead of prepare_now() to preload textures from a user\n"
  " * interface standpoint.\n"
  " */";
#else
static const char *Dtool_Texture_prepare_1412_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Texture::is_prepared(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_Texture_is_prepared_1413(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-bool Texture::is_prepared(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Texture.is_prepared", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const Texture*)local_this).is_prepared)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_prepared(Texture self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_is_prepared_1413_comment =
  "C++ Interface:\n"
  "is_prepared(Texture self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture has already been prepared or enqueued for\n"
  " * preparation on the indicated GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_Texture_is_prepared_1413_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Texture::was_image_modified(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_Texture_was_image_modified_1414(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-bool Texture::was_image_modified(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Texture.was_image_modified", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const Texture*)local_this).was_image_modified)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "was_image_modified(Texture self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_was_image_modified_1414_comment =
  "C++ Interface:\n"
  "was_image_modified(Texture self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture needs to be re-loaded onto the indicated GSG,\n"
  " * either because its image data is out-of-date, or because it's not fully\n"
  " * prepared now.\n"
  " */";
#else
static const char *Dtool_Texture_was_image_modified_1414_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t Texture::get_data_size_bytes(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_Texture_get_data_size_bytes_1415(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-std::size_t Texture::get_data_size_bytes(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Texture.get_data_size_bytes", false, true);
  if (arg_this != nullptr) {
    std::size_t return_value = ((*(const Texture*)local_this).get_data_size_bytes)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_data_size_bytes(Texture self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_data_size_bytes_1415_comment =
  "C++ Interface:\n"
  "get_data_size_bytes(Texture self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes which the texture is reported to consume within\n"
  " * graphics memory, for the indicated GSG.  This may return a nonzero value\n"
  " * even if the texture is not currently resident; you should also check\n"
  " * get_resident() if you want to know how much space the texture is actually\n"
  " * consuming right now.\n"
  " */";
#else
static const char *Dtool_Texture_get_data_size_bytes_1415_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Texture::get_active(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_Texture_get_active_1416(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-bool Texture::get_active(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Texture.get_active", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const Texture*)local_this).get_active)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_active(Texture self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_active_1416_comment =
  "C++ Interface:\n"
  "get_active(Texture self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Returns true if this Texture was rendered in the most recent frame within\n"
  " * the indicated GSG.\n"
  " */";
#else
static const char *Dtool_Texture_get_active_1416_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Texture::get_resident(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_Texture_get_resident_1417(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-bool Texture::get_resident(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Texture.get_resident", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const Texture*)local_this).get_resident)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_resident(Texture self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_resident_1417_comment =
  "C++ Interface:\n"
  "get_resident(Texture self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Returns true if this Texture is reported to be resident within graphics\n"
  " * memory for the indicated GSG.\n"
  " */";
#else
static const char *Dtool_Texture_get_resident_1417_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Texture::release(PreparedGraphicsObjects *prepared_objects)
 */
static PyObject *Dtool_Texture_release_1418(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.release")) {
    return nullptr;
  }
  // 1-bool Texture::release(PreparedGraphicsObjects *prepared_objects)
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Texture.release", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).release)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release(const Texture self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_release_1418_comment =
  "C++ Interface:\n"
  "release(const Texture self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Frees the texture context only on the indicated object, if it exists there.\n"
  " * Returns true if it was released, false if it had not been prepared.\n"
  " */";
#else
static const char *Dtool_Texture_release_1418_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Texture::release_all(void)
 */
static PyObject *Dtool_Texture_release_all_1419(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.release_all")) {
    return nullptr;
  }
  // 1-int Texture::release_all(void)
  int return_value = ((*local_this).release_all)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_release_all_1419_comment =
  "C++ Interface:\n"
  "release_all(const Texture self)\n"
  "\n"
  "/**\n"
  " * Frees the context allocated on all objects for which the texture has been\n"
  " * declared.  Returns the number of contexts which have been freed.\n"
  " */";
#else
static const char *Dtool_Texture_release_all_1419_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t Texture::estimate_texture_memory(void) const
 */
static PyObject *Dtool_Texture_estimate_texture_memory_1420(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-std::size_t Texture::estimate_texture_memory(void) const
  std::size_t return_value = ((*(const Texture*)local_this).estimate_texture_memory)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_estimate_texture_memory_1420_comment =
  "C++ Interface:\n"
  "estimate_texture_memory(Texture self)\n"
  "\n"
  "/**\n"
  " * Estimates the amount of texture memory that will be consumed by loading\n"
  " * this texture.  This returns a value that is not specific to any particular\n"
  " * graphics card or driver; it tries to make a reasonable assumption about how\n"
  " * a driver will load the texture.  It does not account for texture\n"
  " * compression or anything fancy.  This is mainly useful for debugging and\n"
  " * reporting purposes.\n"
  " *\n"
  " * Returns a value in bytes.\n"
  " */";
#else
static const char *Dtool_Texture_estimate_texture_memory_1420_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::set_aux_data(std::string const &key, TypedReferenceCount *aux_data)
 */
static PyObject *Dtool_Texture_set_aux_data_1421(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_aux_data")) {
    return nullptr;
  }
  // 1-void Texture::set_aux_data(std::string const &key, TypedReferenceCount *aux_data)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"key", "aux_data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_aux_data", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    TypedReferenceCount *param2_this = (TypedReferenceCount *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedReferenceCount, 2, "Texture.set_aux_data", false, true);
    if (param2_this != nullptr) {
      ((*local_this).set_aux_data)(std::string(param1_str, param1_len), param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux_data(const Texture self, str key, TypedReferenceCount aux_data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_aux_data_1421_comment =
  "C++ Interface:\n"
  "set_aux_data(const Texture self, str key, TypedReferenceCount aux_data)\n"
  "\n"
  "/**\n"
  " * Records an arbitrary object in the Texture, associated with a specified\n"
  " * key.  The object may later be retrieved by calling get_aux_data() with the\n"
  " * same key.\n"
  " *\n"
  " * These data objects are not recorded to a bam or txo file.\n"
  " */";
#else
static const char *Dtool_Texture_set_aux_data_1421_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::clear_aux_data(std::string const &key)
 */
static PyObject *Dtool_Texture_clear_aux_data_1422(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_aux_data")) {
    return nullptr;
  }
  // 1-void Texture::clear_aux_data(std::string const &key)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).clear_aux_data)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_aux_data(const Texture self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_clear_aux_data_1422_comment =
  "C++ Interface:\n"
  "clear_aux_data(const Texture self, str key)\n"
  "\n"
  "/**\n"
  " * Removes a record previously recorded via set_aux_data().\n"
  " */";
#else
static const char *Dtool_Texture_clear_aux_data_1422_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *Texture::get_aux_data(std::string const &key) const
 */
static PyObject *Dtool_Texture_get_aux_data_1423(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-TypedReferenceCount *Texture::get_aux_data(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    TypedReferenceCount *return_value = ((*(const Texture*)local_this).get_aux_data)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_aux_data(Texture self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_aux_data_1423_comment =
  "C++ Interface:\n"
  "get_aux_data(Texture self, str key)\n"
  "\n"
  "/**\n"
  " * Returns a record previously recorded via set_aux_data().  Returns NULL if\n"
  " * there was no record associated with the indicated key.\n"
  " */";
#else
static const char *Dtool_Texture_get_aux_data_1423_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void Texture::set_textures_power_2(AutoTextureScale scale)
 */
static PyObject *Dtool_Texture_set_textures_power_2_1427(PyObject *, PyObject *arg) {
  // 1-static inline void Texture::set_textures_power_2(AutoTextureScale scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (Texture::set_textures_power_2)((AutoTextureScale)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_textures_power_2(int scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_textures_power_2_1427_comment =
  "C++ Interface:\n"
  "set_textures_power_2(int scale)\n"
  "\n"
  "/**\n"
  " * Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control the\n"
  " * scaling of textures in general, if a particular texture does not override\n"
  " * this.  See also set_auto_texture_scale() for the per-texture override.\n"
  " */";
#else
static const char *Dtool_Texture_set_textures_power_2_1427_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline AutoTextureScale Texture::get_textures_power_2(void)
 */
static PyObject *Dtool_Texture_get_textures_power_2_1428(PyObject *, PyObject *) {
  // 1-static inline AutoTextureScale Texture::get_textures_power_2(void)
  AutoTextureScale return_value = (Texture::get_textures_power_2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_textures_power_2_1428_comment =
  "C++ Interface:\n"
  "get_textures_power_2()\n"
  "\n"
  "/**\n"
  " * This flag returns ATS_none, ATS_up, or ATS_down and controls the scaling of\n"
  " * textures in general.  It is initialized from the config variable of the\n"
  " * same name, but it can be subsequently adjusted.  See also\n"
  " * get_auto_texture_scale().\n"
  " */";
#else
static const char *Dtool_Texture_get_textures_power_2_1428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool Texture::has_textures_power_2(void)
 */
static PyObject *Dtool_Texture_has_textures_power_2_1429(PyObject *, PyObject *) {
  // 1-static inline bool Texture::has_textures_power_2(void)
  bool return_value = (Texture::has_textures_power_2)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_has_textures_power_2_1429_comment =
  "C++ Interface:\n"
  "has_textures_power_2()\n"
  "\n"
  "/**\n"
  " * If true, then get_textures_power_2 has been set using set_textures_power_2.\n"
  " * If false, then get_textures_power_2 simply returns the config variable of\n"
  " * the same name.\n"
  " */";
#else
static const char *Dtool_Texture_has_textures_power_2_1429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_pad_x_size(void) const
 */
static PyObject *Dtool_Texture_get_pad_x_size_1430(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_pad_x_size(void) const
  int return_value = ((*(const Texture*)local_this).get_pad_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_pad_x_size_1430_comment =
  "C++ Interface:\n"
  "get_pad_x_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns size of the pad region.  See set_pad_size.\n"
  " */";
#else
static const char *Dtool_Texture_get_pad_x_size_1430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_pad_y_size(void) const
 */
static PyObject *Dtool_Texture_get_pad_y_size_1431(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_pad_y_size(void) const
  int return_value = ((*(const Texture*)local_this).get_pad_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_pad_y_size_1431_comment =
  "C++ Interface:\n"
  "get_pad_y_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns size of the pad region.  See set_pad_size.\n"
  " */";
#else
static const char *Dtool_Texture_get_pad_y_size_1431_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_pad_z_size(void) const
 */
static PyObject *Dtool_Texture_get_pad_z_size_1432(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_pad_z_size(void) const
  int return_value = ((*(const Texture*)local_this).get_pad_z_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_pad_z_size_1432_comment =
  "C++ Interface:\n"
  "get_pad_z_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns size of the pad region.  See set_pad_size.\n"
  " */";
#else
static const char *Dtool_Texture_get_pad_z_size_1432_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 Texture::get_tex_scale(void) const
 */
static PyObject *Dtool_Texture_get_tex_scale_1433(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline LVecBase2 Texture::get_tex_scale(void) const
  LVecBase2 *return_value = new LVecBase2(((*(const Texture*)local_this).get_tex_scale)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_tex_scale_1433_comment =
  "C++ Interface:\n"
  "get_tex_scale(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns a scale pair that is suitable for applying to geometry via\n"
  " * NodePath::set_tex_scale(), which will convert texture coordinates on the\n"
  " * geometry from the range 0..1 into the appropriate range to render the video\n"
  " * part of the texture.\n"
  " *\n"
  " * This is necessary only if a padding size has been set via set_pad_size()\n"
  " * (or implicitly via something like \"textures-power-2 pad\" in the config.prc\n"
  " * file).  In this case, this is a convenient way to generate UV's that\n"
  " * reflect the built-in padding size.\n"
  " */";
#else
static const char *Dtool_Texture_get_tex_scale_1433_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_pad_size(int x = 0, int y = 0, int z = 0)
 */
static PyObject *Dtool_Texture_set_pad_size_1434(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_pad_size")) {
    return nullptr;
  }
  // 1-inline void Texture::set_pad_size(int x = 0, int y = 0, int z = 0)
  int param1 = 0;
  int param2 = 0;
  int param3 = 0;
  static const char *keyword_list[] = {"x", "y", "z", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|iii:set_pad_size", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_pad_size)((int)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pad_size(const Texture self, int x, int y, int z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_pad_size_1434_comment =
  "C++ Interface:\n"
  "set_pad_size(const Texture self, int x, int y, int z)\n"
  "\n"
  "/**\n"
  " * Sets the size of the pad region.\n"
  " *\n"
  " * Sometimes, when a video card demands power-of-two textures, it is necessary\n"
  " * to create a big texture and then only use a portion of it.  The pad region\n"
  " * indicates which portion of the texture is not really in use.  All\n"
  " * operations use the texture as a whole, including the pad region, unless\n"
  " * they explicitly state that they use only the non-pad region.\n"
  " *\n"
  " * Changing the texture's size clears the pad region.\n"
  " */";
#else
static const char *Dtool_Texture_set_pad_size_1434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::set_size_padded(int x = 1, int y = 1, int z = 1)
 */
static PyObject *Dtool_Texture_set_size_padded_1435(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_size_padded")) {
    return nullptr;
  }
  // 1-void Texture::set_size_padded(int x = 1, int y = 1, int z = 1)
  int param1 = 1;
  int param2 = 1;
  int param3 = 1;
  static const char *keyword_list[] = {"x", "y", "z", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|iii:set_size_padded", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_size_padded)((int)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_size_padded(const Texture self, int x, int y, int z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_size_padded_1435_comment =
  "C++ Interface:\n"
  "set_size_padded(const Texture self, int x, int y, int z)\n"
  "\n"
  "/**\n"
  " * Changes the size of the texture, padding if necessary, and setting the pad\n"
  " * region as well.\n"
  " */";
#else
static const char *Dtool_Texture_set_size_padded_1435_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_orig_file_x_size(void) const
 */
static PyObject *Dtool_Texture_get_orig_file_x_size_1436(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_orig_file_x_size(void) const
  int return_value = ((*(const Texture*)local_this).get_orig_file_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_orig_file_x_size_1436_comment =
  "C++ Interface:\n"
  "get_orig_file_x_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the X size of the original disk image that this Texture was loaded\n"
  " * from (if it came from a disk file), before any automatic rescaling by\n"
  " * Panda.\n"
  " */";
#else
static const char *Dtool_Texture_get_orig_file_x_size_1436_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_orig_file_y_size(void) const
 */
static PyObject *Dtool_Texture_get_orig_file_y_size_1437(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_orig_file_y_size(void) const
  int return_value = ((*(const Texture*)local_this).get_orig_file_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_orig_file_y_size_1437_comment =
  "C++ Interface:\n"
  "get_orig_file_y_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the Y size of the original disk image that this Texture was loaded\n"
  " * from (if it came from a disk file), before any automatic rescaling by\n"
  " * Panda.\n"
  " */";
#else
static const char *Dtool_Texture_get_orig_file_y_size_1437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Texture::get_orig_file_z_size(void) const
 */
static PyObject *Dtool_Texture_get_orig_file_z_size_1438(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline int Texture::get_orig_file_z_size(void) const
  int return_value = ((*(const Texture*)local_this).get_orig_file_z_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_orig_file_z_size_1438_comment =
  "C++ Interface:\n"
  "get_orig_file_z_size(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the Z size of the original disk image that this Texture was loaded\n"
  " * from (if it came from a disk file), before any automatic rescaling by\n"
  " * Panda.\n"
  " */";
#else
static const char *Dtool_Texture_get_orig_file_z_size_1438_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::set_orig_file_size(int x, int y, int z = 1)
 */
static PyObject *Dtool_Texture_set_orig_file_size_1442(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_orig_file_size")) {
    return nullptr;
  }
  // 1-void Texture::set_orig_file_size(int x, int y, int z = 1)
  int param1;
  int param2;
  int param3 = 1;
  static const char *keyword_list[] = {"x", "y", "z", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii|i:set_orig_file_size", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_orig_file_size)((int)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_orig_file_size(const Texture self, int x, int y, int z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_orig_file_size_1442_comment =
  "C++ Interface:\n"
  "set_orig_file_size(const Texture self, int x, int y, int z)\n"
  "\n"
  "/**\n"
  " * Specifies the size of the texture as it exists in its original disk file,\n"
  " * before any Panda scaling.\n"
  " */";
#else
static const char *Dtool_Texture_set_orig_file_size_1442_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_loaded_from_image(bool flag = true)
 */
static PyObject *Dtool_Texture_set_loaded_from_image_1443(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_loaded_from_image")) {
    return nullptr;
  }
  // 1-inline void Texture::set_loaded_from_image(bool flag = true)
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "flag")) {
    ((*local_this).set_loaded_from_image)((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_loaded_from_image(const Texture self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_loaded_from_image_1443_comment =
  "C++ Interface:\n"
  "set_loaded_from_image(const Texture self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates the texture has been loaded from a disk file\n"
  " * or PNMImage.  You should also ensure the filename has been set correctly.\n"
  " * When this flag is true, the texture may be automatically reloaded when its\n"
  " * ram image needs to be replaced.\n"
  " */";
#else
static const char *Dtool_Texture_set_loaded_from_image_1443_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::get_loaded_from_image(void) const
 */
static PyObject *Dtool_Texture_get_loaded_from_image_1444(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::get_loaded_from_image(void) const
  bool return_value = ((*(const Texture*)local_this).get_loaded_from_image)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_loaded_from_image_1444_comment =
  "C++ Interface:\n"
  "get_loaded_from_image(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the flag that indicates the texture has been loaded from a disk\n"
  " * file or PNMImage.  See set_loaded_from_image().\n"
  " */";
#else
static const char *Dtool_Texture_get_loaded_from_image_1444_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_loaded_from_txo(bool flag = true)
 */
static PyObject *Dtool_Texture_set_loaded_from_txo_1446(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_loaded_from_txo")) {
    return nullptr;
  }
  // 1-inline void Texture::set_loaded_from_txo(bool flag = true)
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "flag")) {
    ((*local_this).set_loaded_from_txo)((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_loaded_from_txo(const Texture self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_loaded_from_txo_1446_comment =
  "C++ Interface:\n"
  "set_loaded_from_txo(const Texture self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates the texture has been loaded from a txo file.\n"
  " * You probably shouldn't be setting this directly; it is set automatically\n"
  " * when a Texture is loaded.\n"
  " */";
#else
static const char *Dtool_Texture_set_loaded_from_txo_1446_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::get_loaded_from_txo(void) const
 */
static PyObject *Dtool_Texture_get_loaded_from_txo_1447(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::get_loaded_from_txo(void) const
  bool return_value = ((*(const Texture*)local_this).get_loaded_from_txo)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_loaded_from_txo_1447_comment =
  "C++ Interface:\n"
  "get_loaded_from_txo(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the flag that indicates the texture has been loaded from a txo\n"
  " * file.\n"
  " */";
#else
static const char *Dtool_Texture_get_loaded_from_txo_1447_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::get_match_framebuffer_format(void) const
 */
static PyObject *Dtool_Texture_get_match_framebuffer_format_1449(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::get_match_framebuffer_format(void) const
  bool return_value = ((*(const Texture*)local_this).get_match_framebuffer_format)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_match_framebuffer_format_1449_comment =
  "C++ Interface:\n"
  "get_match_framebuffer_format(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the special flag was set that indicates to the GSG that the\n"
  " * Texture's format should be chosen to exactly match the framebuffer's\n"
  " * format, presumably because the application intends to copy image data from\n"
  " * the framebuffer into the Texture (or vice-versa).\n"
  " */";
#else
static const char *Dtool_Texture_get_match_framebuffer_format_1449_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_match_framebuffer_format(bool flag)
 */
static PyObject *Dtool_Texture_set_match_framebuffer_format_1450(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_match_framebuffer_format")) {
    return nullptr;
  }
  // 1-inline void Texture::set_match_framebuffer_format(bool flag)
  ((*local_this).set_match_framebuffer_format)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_match_framebuffer_format(const Texture self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_match_framebuffer_format_1450_comment =
  "C++ Interface:\n"
  "set_match_framebuffer_format(const Texture self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the special flag that, if true, indicates to the GSG that the\n"
  " * Texture's format should be chosen to exactly match the framebuffer's\n"
  " * format, presumably because the application intends to copy image data from\n"
  " * the framebuffer into the Texture (or vice-versa).\n"
  " *\n"
  " * This sets only the graphics card's idea of the texture format; it is not\n"
  " * related to the system-memory format.\n"
  " */";
#else
static const char *Dtool_Texture_set_match_framebuffer_format_1450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::get_post_load_store_cache(void) const
 */
static PyObject *Dtool_Texture_get_post_load_store_cache_1452(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  // 1-inline bool Texture::get_post_load_store_cache(void) const
  bool return_value = ((*(const Texture*)local_this).get_post_load_store_cache)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_post_load_store_cache_1452_comment =
  "C++ Interface:\n"
  "get_post_load_store_cache(Texture self)\n"
  "\n"
  "/**\n"
  " * Returns the setting of the post_load_store_cache flag.  See\n"
  " * set_post_load_store_cache().\n"
  " */";
#else
static const char *Dtool_Texture_get_post_load_store_cache_1452_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Texture::set_post_load_store_cache(bool flag)
 */
static PyObject *Dtool_Texture_set_post_load_store_cache_1453(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.set_post_load_store_cache")) {
    return nullptr;
  }
  // 1-inline void Texture::set_post_load_store_cache(bool flag)
  ((*local_this).set_post_load_store_cache)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_post_load_store_cache(const Texture self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_set_post_load_store_cache_1453_comment =
  "C++ Interface:\n"
  "set_post_load_store_cache(const Texture self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the post_load_store_cache flag.  When this is set, the next time the\n"
  " * texture is loaded on a GSG, it will automatically extract its RAM image\n"
  " * from the GSG and save it to the global BamCache.\n"
  " *\n"
  " * This is used to store compressed RAM images in the BamCache.  This flag\n"
  " * should not be set explicitly; it is set automatically by the TexturePool\n"
  " * when model-cache-compressed-textures is set true.\n"
  " */";
#else
static const char *Dtool_Texture_set_post_load_store_cache_1453_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextureContext *Texture::prepare_now(int view, PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_Texture_prepare_now_1455(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.prepare_now")) {
    return nullptr;
  }
  // 1-TextureContext *Texture::prepare_now(int view, PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg)
  int param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"view", "prepared_objects", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOO:prepare_now", (char **)keyword_list, &param1, &param2, &param3)) {
    PreparedGraphicsObjects *param2_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PreparedGraphicsObjects, 2, "Texture.prepare_now", false, true);
    GraphicsStateGuardianBase *param3_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_GraphicsStateGuardianBase, 3, "Texture.prepare_now", false, true);
    if (param2_this != nullptr && param3_this != nullptr) {
      TextureContext *return_value = ((*local_this).prepare_now)((int)param1, param2_this, param3_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_now(const Texture self, int view, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_prepare_now_1455_comment =
  "C++ Interface:\n"
  "prepare_now(const Texture self, int view, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Creates a context for the texture on the particular GSG, if it does not\n"
  " * already exist.  Returns the new (or old) TextureContext.  This assumes that\n"
  " * the GraphicsStateGuardian is the currently active rendering context and\n"
  " * that it is ready to accept new textures.  If this is not necessarily the\n"
  " * case, you should use prepare() instead.\n"
  " *\n"
  " * Normally, this is not called directly except by the GraphicsStateGuardian;\n"
  " * a texture does not need to be explicitly prepared by the user before it may\n"
  " * be rendered.\n"
  " */";
#else
static const char *Dtool_Texture_prepare_now_1455_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int Texture::up_to_power_2(int value)
 */
static PyObject *Dtool_Texture_up_to_power_2_1456(PyObject *, PyObject *arg) {
  // 1-static int Texture::up_to_power_2(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (Texture::up_to_power_2)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "up_to_power_2(int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_up_to_power_2_1456_comment =
  "C++ Interface:\n"
  "up_to_power_2(int value)\n"
  "\n"
  "/**\n"
  " * Returns the smallest power of 2 greater than or equal to value.\n"
  " */";
#else
static const char *Dtool_Texture_up_to_power_2_1456_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int Texture::down_to_power_2(int value)
 */
static PyObject *Dtool_Texture_down_to_power_2_1457(PyObject *, PyObject *arg) {
  // 1-static int Texture::down_to_power_2(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (Texture::down_to_power_2)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "down_to_power_2(int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_down_to_power_2_1457_comment =
  "C++ Interface:\n"
  "down_to_power_2(int value)\n"
  "\n"
  "/**\n"
  " * Returns the largest power of 2 less than or equal to value.\n"
  " */";
#else
static const char *Dtool_Texture_down_to_power_2_1457_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Texture::consider_rescale(PNMImage &pnmimage)
 * static void Texture::consider_rescale(PNMImage &pnmimage, std::string const &name, AutoTextureScale auto_texture_scale = ::ATS_unspecified)
 */
static PyObject *Dtool_Texture_consider_rescale_1458(PyObject *self, PyObject *args, PyObject *kwds) {
  Texture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Texture)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        PyObject *arg;
        if (Dtool_ExtractArg(&arg, args, kwds, "pnmimage")) {
          // 1-void Texture::consider_rescale(PNMImage &pnmimage)
          PNMImage *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "Texture.consider_rescale", false, true);
          if (arg_this != nullptr) {
            ((*local_this).consider_rescale)(*arg_this);
            return Dtool_Return_None();
          }
        }
      } else {
#ifdef NDEBUG
        return Dtool_Raise_TypeError("non-const method called on const object");
#else
        return Dtool_Raise_TypeError("Cannot call Texture.consider_rescale() on a const object.");
#endif
      }
    }
    break;
  case 2:
  case 3:
    {
      // 1-static void Texture::consider_rescale(PNMImage &pnmimage, std::string const &name, AutoTextureScale auto_texture_scale = ::ATS_unspecified)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      int param2 = ::ATS_unspecified;
      static const char *keyword_list[] = {"pnmimage", "name", "auto_texture_scale", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#|i:consider_rescale", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2)) {
        PNMImage *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PNMImage, 0, "Texture.consider_rescale", false, true);
        if (param0_this != nullptr) {
          (Texture::consider_rescale)(*param0_this, std::string(param1_str, param1_len), (AutoTextureScale)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "consider_rescale() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "consider_rescale(const Texture self, PNMImage pnmimage)\n"
      "consider_rescale(PNMImage pnmimage, str name, int auto_texture_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_consider_rescale_1458_comment =
  "C++ Interface:\n"
  "consider_rescale(const Texture self, PNMImage pnmimage)\n"
  "consider_rescale(PNMImage pnmimage, str name, int auto_texture_scale)\n"
  "\n"
  "/**\n"
  " * Asks the PNMImage to change its scale when it reads the image, according to\n"
  " * the whims of the Config.prc file.\n"
  " *\n"
  " * For most efficient results, this method should be called after\n"
  " * pnmimage.read_header() has been called, but before pnmimage.read().  This\n"
  " * method may also be called after pnmimage.read(), i.e.  when the pnmimage is\n"
  " * already loaded; in this case it will rescale the image on the spot.  Also\n"
  " * see rescale_texture().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Asks the PNMImage to change its scale when it reads the image, according to\n"
  " * the whims of the Config.prc file.\n"
  " *\n"
  " * For most efficient results, this method should be called after\n"
  " * pnmimage.read_header() has been called, but before pnmimage.read().  This\n"
  " * method may also be called after pnmimage.read(), i.e.  when the pnmimage is\n"
  " * already loaded; in this case it will rescale the image on the spot.  Also\n"
  " * see rescale_texture().\n"
  " */";
#else
static const char *Dtool_Texture_consider_rescale_1458_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Texture::rescale_texture(void)
 */
static PyObject *Dtool_Texture_rescale_texture_1459(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.rescale_texture")) {
    return nullptr;
  }
  // 1-inline bool Texture::rescale_texture(void)
  bool return_value = ((*local_this).rescale_texture)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Texture_rescale_texture_1459_comment =
  "C++ Interface:\n"
  "rescale_texture(const Texture self)\n"
  "\n"
  "/**\n"
  " * This method is similar to consider_rescale(), but instead of scaling a\n"
  " * separate PNMImage, it will ask the Texture to rescale its own internal\n"
  " * image to a power of 2, according to the config file requirements.  This may\n"
  " * be useful after loading a Texture image by hand, instead of reading it from\n"
  " * a disk file.  Returns true if the texture is changed, false if it was not.\n"
  " */";
#else
static const char *Dtool_Texture_rescale_texture_1459_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string Texture::format_texture_type(Texture::TextureType tt)
 */
static PyObject *Dtool_Texture_format_texture_type_1460(PyObject *, PyObject *arg) {
  // 1-static std::string Texture::format_texture_type(Texture::TextureType tt)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (Texture::format_texture_type)((Texture::TextureType)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_texture_type(int tt)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_format_texture_type_1460_comment =
  "C++ Interface:\n"
  "format_texture_type(int tt)\n"
  "\n"
  "/**\n"
  " * Returns the indicated TextureType converted to a string word.\n"
  " */";
#else
static const char *Dtool_Texture_format_texture_type_1460_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Texture::TextureType Texture::string_texture_type(std::string const &str)
 */
static PyObject *Dtool_Texture_string_texture_type_1461(PyObject *, PyObject *arg) {
  // 1-static Texture::TextureType Texture::string_texture_type(std::string const &str)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    Texture::TextureType return_value = (Texture::string_texture_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_texture_type(str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_string_texture_type_1461_comment =
  "C++ Interface:\n"
  "string_texture_type(str str)\n"
  "\n"
  "/**\n"
  " * Returns the TextureType corresponding to the indicated string word.\n"
  " */";
#else
static const char *Dtool_Texture_string_texture_type_1461_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string Texture::format_component_type(Texture::ComponentType ct)
 */
static PyObject *Dtool_Texture_format_component_type_1462(PyObject *, PyObject *arg) {
  // 1-static std::string Texture::format_component_type(Texture::ComponentType ct)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (Texture::format_component_type)((Texture::ComponentType)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_component_type(int ct)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_format_component_type_1462_comment =
  "C++ Interface:\n"
  "format_component_type(int ct)\n"
  "\n"
  "/**\n"
  " * Returns the indicated ComponentType converted to a string word.\n"
  " */";
#else
static const char *Dtool_Texture_format_component_type_1462_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Texture::ComponentType Texture::string_component_type(std::string const &str)
 */
static PyObject *Dtool_Texture_string_component_type_1463(PyObject *, PyObject *arg) {
  // 1-static Texture::ComponentType Texture::string_component_type(std::string const &str)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    Texture::ComponentType return_value = (Texture::string_component_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_component_type(str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_string_component_type_1463_comment =
  "C++ Interface:\n"
  "string_component_type(str str)\n"
  "\n"
  "/**\n"
  " * Returns the ComponentType corresponding to the indicated string word.\n"
  " */";
#else
static const char *Dtool_Texture_string_component_type_1463_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string Texture::format_format(Texture::Format f)
 */
static PyObject *Dtool_Texture_format_format_1464(PyObject *, PyObject *arg) {
  // 1-static std::string Texture::format_format(Texture::Format f)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (Texture::format_format)((Texture::Format)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_format(int f)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_format_format_1464_comment =
  "C++ Interface:\n"
  "format_format(int f)\n"
  "\n"
  "/**\n"
  " * Returns the indicated Format converted to a string word.\n"
  " */";
#else
static const char *Dtool_Texture_format_format_1464_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Texture::Format Texture::string_format(std::string const &str)
 */
static PyObject *Dtool_Texture_string_format_1465(PyObject *, PyObject *arg) {
  // 1-static Texture::Format Texture::string_format(std::string const &str)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    Texture::Format return_value = (Texture::string_format)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_format(str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_string_format_1465_comment =
  "C++ Interface:\n"
  "string_format(str str)\n"
  "\n"
  "/**\n"
  " * Returns the Format corresponding to the indicated string word.\n"
  " */";
#else
static const char *Dtool_Texture_string_format_1465_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string Texture::format_compression_mode(Texture::CompressionMode cm)
 */
static PyObject *Dtool_Texture_format_compression_mode_1466(PyObject *, PyObject *arg) {
  // 1-static std::string Texture::format_compression_mode(Texture::CompressionMode cm)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (Texture::format_compression_mode)((Texture::CompressionMode)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_compression_mode(int cm)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_format_compression_mode_1466_comment =
  "C++ Interface:\n"
  "format_compression_mode(int cm)\n"
  "\n"
  "/**\n"
  " * Returns the indicated CompressionMode converted to a string word.\n"
  " */";
#else
static const char *Dtool_Texture_format_compression_mode_1466_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Texture::CompressionMode Texture::string_compression_mode(std::string const &str)
 */
static PyObject *Dtool_Texture_string_compression_mode_1467(PyObject *, PyObject *arg) {
  // 1-static Texture::CompressionMode Texture::string_compression_mode(std::string const &str)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    Texture::CompressionMode return_value = (Texture::string_compression_mode)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_compression_mode(str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_string_compression_mode_1467_comment =
  "C++ Interface:\n"
  "string_compression_mode(str str)\n"
  "\n"
  "/**\n"
  " * Returns the CompressionMode value associated with the given string\n"
  " * representation.\n"
  " */";
#else
static const char *Dtool_Texture_string_compression_mode_1467_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string Texture::format_quality_level(Texture::QualityLevel tql)
 */
static PyObject *Dtool_Texture_format_quality_level_1468(PyObject *, PyObject *arg) {
  // 1-static std::string Texture::format_quality_level(Texture::QualityLevel tql)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (Texture::format_quality_level)((Texture::QualityLevel)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_quality_level(int tql)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_format_quality_level_1468_comment =
  "C++ Interface:\n"
  "format_quality_level(int tql)\n"
  "\n"
  "/**\n"
  " * Returns the indicated QualityLevel converted to a string word.\n"
  " */";
#else
static const char *Dtool_Texture_format_quality_level_1468_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Texture::QualityLevel Texture::string_quality_level(std::string const &str)
 */
static PyObject *Dtool_Texture_string_quality_level_1469(PyObject *, PyObject *arg) {
  // 1-static Texture::QualityLevel Texture::string_quality_level(std::string const &str)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    Texture::QualityLevel return_value = (Texture::string_quality_level)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_quality_level(str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Texture_string_quality_level_1469_comment =
  "C++ Interface:\n"
  "string_quality_level(str str)\n"
  "\n"
  "/**\n"
  " * Returns the QualityLevel value associated with the given string\n"
  " * representation.\n"
  " */";
#else
static const char *Dtool_Texture_string_quality_level_1469_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Texture::get_class_type(void)
 */
static PyObject *Dtool_Texture_get_class_type_1470(PyObject *, PyObject *) {
  // 1-static TypeHandle Texture::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Texture::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_get_class_type_1470_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Texture_get_class_type_1470_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *Texture::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_Texture_upcast_to_TypedWritableReferenceCount_1189(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.upcast_to_TypedWritableReferenceCount")) {
    return nullptr;
  }
  // 1-TypedWritableReferenceCount *Texture::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Texture_upcast_to_TypedWritableReferenceCount_1189_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const Texture self)\n"
  "\n"
  "upcast from Texture to TypedWritableReferenceCount";
#else
static const char *Dtool_Texture_upcast_to_TypedWritableReferenceCount_1189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *Texture::upcast_to_Namable(void)
 */
static PyObject *Dtool_Texture_upcast_to_Namable_1191(PyObject *self, PyObject *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *Texture::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Texture_upcast_to_Namable_1191_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const Texture self)\n"
  "\n"
  "upcast from Texture to Namable";
#else
static const char *Dtool_Texture_upcast_to_Namable_1191_comment = nullptr;
#endif

static PyObject *Dtool_Texture_clear_color_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_clear_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor Texture::get_clear_color(void) const
  LColor *return_value = new LColor(((*(const Texture*)local_this).get_clear_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_Texture_clear_color_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.clear_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete clear_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_clear_color();
    return 0;
  }
  // 1-inline void Texture::set_clear_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_clear_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_clear_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_clear_color(const Texture self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_filename_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_filename()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline Filename const &Texture::get_filename(void) const
  Filename const *return_value = &(((*(const Texture*)local_this).get_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_Texture_filename_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.filename")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete filename attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_filename();
    return 0;
  }
  // 1-inline void Texture::set_filename(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_filename", "Filename");
    return -1;
  }
  ((*local_this).set_filename)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_filename(const Texture self, const Filename filename)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_alpha_filename_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_alpha_filename()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline Filename const &Texture::get_alpha_filename(void) const
  Filename const *return_value = &(((*(const Texture*)local_this).get_alpha_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_Texture_alpha_filename_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.alpha_filename")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete alpha_filename attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_alpha_filename();
    return 0;
  }
  // 1-inline void Texture::set_alpha_filename(Filename const &alpha_filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_alpha_filename", "Filename");
    return -1;
  }
  ((*local_this).set_alpha_filename)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_filename(const Texture self, const Filename alpha_filename)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_fullpath_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_fullpath()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline Filename const &Texture::get_fullpath(void) const
  Filename const *return_value = &(((*(const Texture*)local_this).get_fullpath)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_Texture_fullpath_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.fullpath")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete fullpath attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_fullpath();
    return 0;
  }
  // 1-inline void Texture::set_fullpath(Filename const &fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_fullpath", "Filename");
    return -1;
  }
  ((*local_this).set_fullpath)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fullpath(const Texture self, const Filename fullpath)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_alpha_fullpath_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_alpha_fullpath()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline Filename const &Texture::get_alpha_fullpath(void) const
  Filename const *return_value = &(((*(const Texture*)local_this).get_alpha_fullpath)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_Texture_alpha_fullpath_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.alpha_fullpath")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete alpha_fullpath attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_alpha_fullpath();
    return 0;
  }
  // 1-inline void Texture::set_alpha_fullpath(Filename const &alpha_fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_alpha_fullpath", "Filename");
    return -1;
  }
  ((*local_this).set_alpha_fullpath)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_fullpath(const Texture self, const Filename alpha_fullpath)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_x_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_x_size(void) const
  int return_value = ((*(const Texture*)local_this).get_x_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_x_size_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.x_size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete x_size attribute");
    return -1;
  }
  // 1-inline void Texture::set_x_size(int x_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_x_size)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_x_size(const Texture self, int x_size)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_y_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_y_size(void) const
  int return_value = ((*(const Texture*)local_this).get_y_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_y_size_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.y_size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete y_size attribute");
    return -1;
  }
  // 1-inline void Texture::set_y_size(int y_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_y_size)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_y_size(const Texture self, int y_size)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_z_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_z_size(void) const
  int return_value = ((*(const Texture*)local_this).get_z_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_z_size_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.z_size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete z_size attribute");
    return -1;
  }
  // 1-inline void Texture::set_z_size(int z_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_z_size)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_z_size(const Texture self, int z_size)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_num_views_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_num_views(void) const
  int return_value = ((*(const Texture*)local_this).get_num_views)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_num_views_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.num_views")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete num_views attribute");
    return -1;
  }
  // 1-inline void Texture::set_num_views(int num_views)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_num_views)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_num_views(const Texture self, int num_views)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_num_pages_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_num_pages(void) const
  int return_value = ((*(const Texture*)local_this).get_num_pages)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_num_components_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_num_components(void) const
  int return_value = ((*(const Texture*)local_this).get_num_components)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_component_width_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_component_width(void) const
  int return_value = ((*(const Texture*)local_this).get_component_width)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_texture_type_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture::TextureType Texture::get_texture_type(void) const
  Texture::TextureType return_value = ((*(const Texture*)local_this).get_texture_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_usage_hint_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::UsageHint Texture::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const Texture*)local_this).get_usage_hint)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_format_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture::Format Texture::get_format(void) const
  Texture::Format return_value = ((*(const Texture*)local_this).get_format)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_format_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.format")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete format attribute");
    return -1;
  }
  // 1-inline void Texture::set_format(Texture::Format format)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_format)((Texture::Format)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_format(const Texture self, int format)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_component_type_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture::ComponentType Texture::get_component_type(void) const
  Texture::ComponentType return_value = ((*(const Texture*)local_this).get_component_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_component_type_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.component_type")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete component_type attribute");
    return -1;
  }
  // 1-inline void Texture::set_component_type(Texture::ComponentType component_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_component_type)((Texture::ComponentType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_component_type(const Texture self, int component_type)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_wrap_u_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::WrapMode Texture::get_wrap_u(void) const
  SamplerState::WrapMode return_value = ((*(const Texture*)local_this).get_wrap_u)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_wrap_u_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.wrap_u")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wrap_u attribute");
    return -1;
  }
  // 1-inline void Texture::set_wrap_u(Texture::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_wrap_u)((Texture::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_u(const Texture self, int wrap)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_wrap_v_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::WrapMode Texture::get_wrap_v(void) const
  SamplerState::WrapMode return_value = ((*(const Texture*)local_this).get_wrap_v)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_wrap_v_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.wrap_v")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wrap_v attribute");
    return -1;
  }
  // 1-inline void Texture::set_wrap_v(Texture::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_wrap_v)((Texture::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_v(const Texture self, int wrap)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_wrap_w_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::WrapMode Texture::get_wrap_w(void) const
  SamplerState::WrapMode return_value = ((*(const Texture*)local_this).get_wrap_w)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_wrap_w_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.wrap_w")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wrap_w attribute");
    return -1;
  }
  // 1-inline void Texture::set_wrap_w(Texture::WrapMode wrap)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_wrap_w)((Texture::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_w(const Texture self, int wrap)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_minfilter_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::FilterType Texture::get_minfilter(void) const
  SamplerState::FilterType return_value = ((*(const Texture*)local_this).get_minfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_minfilter_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.minfilter")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete minfilter attribute");
    return -1;
  }
  // 1-inline void Texture::set_minfilter(Texture::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_minfilter)((Texture::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_minfilter(const Texture self, int filter)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_effective_minfilter_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::FilterType Texture::get_effective_minfilter(void) const
  SamplerState::FilterType return_value = ((*(const Texture*)local_this).get_effective_minfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_magfilter_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::FilterType Texture::get_magfilter(void) const
  SamplerState::FilterType return_value = ((*(const Texture*)local_this).get_magfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_magfilter_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.magfilter")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete magfilter attribute");
    return -1;
  }
  // 1-inline void Texture::set_magfilter(Texture::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_magfilter)((Texture::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_magfilter(const Texture self, int filter)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_effective_magfilter_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::FilterType Texture::get_effective_magfilter(void) const
  SamplerState::FilterType return_value = ((*(const Texture*)local_this).get_effective_magfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_anisotropic_degree_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_anisotropic_degree(void) const
  int return_value = ((*(const Texture*)local_this).get_anisotropic_degree)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_anisotropic_degree_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.anisotropic_degree")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete anisotropic_degree attribute");
    return -1;
  }
  // 1-inline void Texture::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_anisotropic_degree)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const Texture self, int anisotropic_degree)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_effective_anisotropic_degree_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_effective_anisotropic_degree(void) const
  int return_value = ((*(const Texture*)local_this).get_effective_anisotropic_degree)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_border_color_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor Texture::get_border_color(void) const
  LColor *return_value = new LColor(((*(const Texture*)local_this).get_border_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_Texture_border_color_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.border_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete border_color attribute");
    return -1;
  }
  // 1-inline void Texture::set_border_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Texture.set_border_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_border_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_border_color(const Texture self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_compression_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture::CompressionMode Texture::get_compression(void) const
  Texture::CompressionMode return_value = ((*(const Texture*)local_this).get_compression)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_compression_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.compression")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete compression attribute");
    return -1;
  }
  // 1-inline void Texture::set_compression(Texture::CompressionMode compression)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_compression)((Texture::CompressionMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_compression(const Texture self, int compression)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_render_to_texture_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool Texture::get_render_to_texture(void) const
  bool return_value = ((*(const Texture*)local_this).get_render_to_texture)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_render_to_texture_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.render_to_texture")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete render_to_texture attribute");
    return -1;
  }
  // 1-inline void Texture::set_render_to_texture(bool render_to_texture)
  ((*local_this).set_render_to_texture)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_render_to_texture(const Texture self, bool render_to_texture)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_default_sampler_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState const &Texture::get_default_sampler(void) const
  SamplerState const *return_value = &(((*(const Texture*)local_this).get_default_sampler)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SamplerState, false, true);
}

static int Dtool_Texture_default_sampler_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.default_sampler")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete default_sampler attribute");
    return -1;
  }
  // 1-inline void Texture::set_default_sampler(SamplerState const &sampler)
  SamplerState const *arg_this = (SamplerState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SamplerState, 1, "Texture.set_default_sampler", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_default_sampler)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_default_sampler(const Texture self, const SamplerState sampler)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_quality_level_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture::QualityLevel Texture::get_quality_level(void) const
  Texture::QualityLevel return_value = ((*(const Texture*)local_this).get_quality_level)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_quality_level_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.quality_level")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete quality_level attribute");
    return -1;
  }
  // 1-inline void Texture::set_quality_level(Texture::QualityLevel quality_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_quality_level)((Texture::QualityLevel)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_quality_level(const Texture self, int quality_level)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_effective_quality_level_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture::QualityLevel Texture::get_effective_quality_level(void) const
  Texture::QualityLevel return_value = ((*(const Texture*)local_this).get_effective_quality_level)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_expected_num_mipmap_levels_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_expected_num_mipmap_levels(void) const
  int return_value = ((*(const Texture*)local_this).get_expected_num_mipmap_levels)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_ram_image_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t Texture::get_ram_image_size(void) const
  std::size_t return_value = ((*(const Texture*)local_this).get_ram_image_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_ram_view_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t Texture::get_ram_view_size(void) const
  std::size_t return_value = ((*(const Texture*)local_this).get_ram_view_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_ram_page_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t Texture::get_ram_page_size(void) const
  std::size_t return_value = ((*(const Texture*)local_this).get_ram_page_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_expected_ram_image_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t Texture::get_expected_ram_image_size(void) const
  std::size_t return_value = ((*(const Texture*)local_this).get_expected_ram_image_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_expected_ram_page_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t Texture::get_expected_ram_page_size(void) const
  std::size_t return_value = ((*(const Texture*)local_this).get_expected_ram_page_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_ram_image_compression_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture::CompressionMode Texture::get_ram_image_compression(void) const
  Texture::CompressionMode return_value = ((*(const Texture*)local_this).get_ram_image_compression)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_keep_ram_image_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual bool Texture::get_keep_ram_image(void) const
  bool return_value = ((*(const Texture*)local_this).get_keep_ram_image)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_keep_ram_image_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.keep_ram_image")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete keep_ram_image attribute");
    return -1;
  }
  // 1-inline void Texture::set_keep_ram_image(bool keep_ram_image)
  ((*local_this).set_keep_ram_image)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_keep_ram_image(const Texture self, bool keep_ram_image)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_cacheable_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual bool Texture::is_cacheable(void) const
  bool return_value = ((*(const Texture*)local_this).is_cacheable)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_num_ram_mipmap_images_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_num_ram_mipmap_images(void) const
  int return_value = ((*(const Texture*)local_this).get_num_ram_mipmap_images)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_num_loadable_ram_mipmap_images_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int Texture::get_num_loadable_ram_mipmap_images(void) const
  int return_value = ((*(const Texture*)local_this).get_num_loadable_ram_mipmap_images)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_simple_x_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_simple_x_size(void) const
  int return_value = ((*(const Texture*)local_this).get_simple_x_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_simple_y_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_simple_y_size(void) const
  int return_value = ((*(const Texture*)local_this).get_simple_y_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_simple_ram_image_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_simple_ram_image()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline CPTA_uchar Texture::get_simple_ram_image(void) const
  CPTA_uchar *return_value = new CPTA_uchar(((*(const Texture*)local_this).get_simple_ram_image)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_unsigned_char, true, false);
}

static PyObject *Dtool_Texture_properties_modified_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq Texture::get_properties_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const Texture*)local_this).get_properties_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

static PyObject *Dtool_Texture_image_modified_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq Texture::get_image_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const Texture*)local_this).get_image_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

static PyObject *Dtool_Texture_simple_image_modified_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline UpdateSeq Texture::get_simple_image_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const Texture*)local_this).get_simple_image_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

static PyObject *Dtool_Texture_auto_texture_scale_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline AutoTextureScale Texture::get_auto_texture_scale(void) const
  AutoTextureScale return_value = ((*(const Texture*)local_this).get_auto_texture_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_auto_texture_scale_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.auto_texture_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete auto_texture_scale attribute");
    return -1;
  }
  // 1-inline void Texture::set_auto_texture_scale(AutoTextureScale scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_auto_texture_scale)((AutoTextureScale)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_auto_texture_scale(const Texture self, int scale)\n");
  }
  return -1;
}

/**
 * mapping getitem for property Texture::aux_data
 */
static PyObject *Dtool_Texture_aux_data_Mapping_Getitem(PyObject *self, PyObject *arg) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }
  {
    // 1-TypedReferenceCount *Texture::get_aux_data(std::string const &key) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      TypedReferenceCount *return_value = ((*(const Texture*)local_this).get_aux_data)(std::string(param1_str, param1_len));
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (!return_value) {
        PyErr_SetObject(PyExc_KeyError, arg);
        return nullptr;
      }
    }
  }
  // 1-TypedReferenceCount *Texture::get_aux_data(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    TypedReferenceCount *return_value = ((*(const Texture*)local_this).get_aux_data)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return Dtool_Raise_AssertionError();
    }
#endif
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_aux_data(Texture self, str key)\n");
  }
  return nullptr;
}

/**
 * mapping setitem for property Texture::aux_data
 */
static int Dtool_Texture_aux_data_Mapping_Setitem(PyObject *self, PyObject *key, PyObject *value) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.aux_data")) {
    return -1;
  }

  if (value == nullptr) {
    PyObject *arg = key;
    {
      // 1-TypedReferenceCount *Texture::get_aux_data(std::string const &key) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        TypedReferenceCount *return_value = ((*(const Texture*)local_this).get_aux_data)(std::string(param1_str, param1_len));
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (!return_value) {
          PyErr_SetObject(PyExc_KeyError, arg);
          return -1;
        }
      }
    }
    // 1-void Texture::clear_aux_data(std::string const &key)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).clear_aux_data)(std::string(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
    return -1;
  }
  PyObject *args = PyTuple_New(2);
  PyTuple_SET_ITEM(args, 0, key);
  PyTuple_SET_ITEM(args, 1, value);
  Py_INCREF(key);
  Py_INCREF(value);
  // 1-void Texture::set_aux_data(std::string const &key, TypedReferenceCount *aux_data)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  if (PyArg_ParseTuple(args, "s#O:set_aux_data", &param1_str, &param1_len, &param2)) {
    TypedReferenceCount *param2_this = (TypedReferenceCount *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedReferenceCount, 2, "Texture.set_aux_data", false, true);
    if (param2_this != nullptr) {
      ((*local_this).set_aux_data)(std::string(param1_str, param1_len), param2_this);
      Py_DECREF(args);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_aux_data(const Texture self, str key, TypedReferenceCount aux_data)\n");
  }
  Py_DECREF(args);
  return -1;
}

static PyObject *Dtool_Texture_aux_data_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MappingWrapper *wrap = Dtool_NewMutableMappingWrapper(self, "Texture.aux_data");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_Texture_aux_data_Mapping_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_Texture_aux_data_Mapping_Setitem;
    }
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_Texture_orig_file_x_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_orig_file_x_size(void) const
  int return_value = ((*(const Texture*)local_this).get_orig_file_x_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_orig_file_y_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_orig_file_y_size(void) const
  int return_value = ((*(const Texture*)local_this).get_orig_file_y_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_orig_file_z_size_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Texture::get_orig_file_z_size(void) const
  int return_value = ((*(const Texture*)local_this).get_orig_file_z_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Texture_loaded_from_image_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool Texture::get_loaded_from_image(void) const
  bool return_value = ((*(const Texture*)local_this).get_loaded_from_image)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_loaded_from_image_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.loaded_from_image")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete loaded_from_image attribute");
    return -1;
  }
  // 1-inline void Texture::set_loaded_from_image(bool flag)
  ((*local_this).set_loaded_from_image)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_loaded_from_image(const Texture self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_loaded_from_txo_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool Texture::get_loaded_from_txo(void) const
  bool return_value = ((*(const Texture*)local_this).get_loaded_from_txo)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_loaded_from_txo_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.loaded_from_txo")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete loaded_from_txo attribute");
    return -1;
  }
  // 1-inline void Texture::set_loaded_from_txo(bool flag)
  ((*local_this).set_loaded_from_txo)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_loaded_from_txo(const Texture self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_match_framebuffer_format_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool Texture::get_match_framebuffer_format(void) const
  bool return_value = ((*(const Texture*)local_this).get_match_framebuffer_format)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_match_framebuffer_format_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.match_framebuffer_format")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete match_framebuffer_format attribute");
    return -1;
  }
  // 1-inline void Texture::set_match_framebuffer_format(bool flag)
  ((*local_this).set_match_framebuffer_format)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_match_framebuffer_format(const Texture self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_Texture_post_load_store_cache_Getter(PyObject *self, void *) {
  const Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool Texture::get_post_load_store_cache(void) const
  bool return_value = ((*(const Texture*)local_this).get_post_load_store_cache)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Texture_post_load_store_cache_Setter(PyObject *self, PyObject *arg, void *) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Texture, (void **)&local_this, "Texture.post_load_store_cache")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete post_load_store_cache attribute");
    return -1;
  }
  // 1-inline void Texture::set_post_load_store_cache(bool flag)
  ((*local_this).set_post_load_store_cache)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_post_load_store_cache(const Texture self, bool flag)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit Texture::Texture(std::string const &name = string())
 */
static int Dtool_Init_Texture(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit Texture::Texture(std::string const &name = string())
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:Texture", (char **)keyword_list, &param0_str, &param0_len)) {
    Texture *return_value = new Texture(std::string(param0_str, param0_len));
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Texture, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Texture(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Texture(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Texture) {
    printf("Texture ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Texture *local_this = (Texture *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Texture) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Texture(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Texture) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Texture*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Texture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Texture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Texture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Texture*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Shader
 */
/**
 * Python function wrapper for:
 * static PointerTo< Shader > Shader::load(Filename const &file, Shader::ShaderLanguage lang = ::Shader::SL_none)
 * static PointerTo< Shader > Shader::load(Shader::ShaderLanguage lang, Filename const &vertex, Filename const &fragment, Filename const &geometry = "", Filename const &tess_control = "", Filename const &tess_evaluation = "")
 */
static PyObject *Dtool_Shader_load_1476(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "file")) {
        // 1-static PointerTo< Shader > Shader::load(Filename const &file, Shader::ShaderLanguage lang)
        Filename arg_local;
        Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 0, "Shader.load", "Filename");
        }
        PointerTo< Shader > return_value = (Shader::load)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        Shader *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Shader, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 2:
    {
      // 1-static PointerTo< Shader > Shader::load(Filename const &file, Shader::ShaderLanguage lang)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"file", "lang", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:load", (char **)keyword_list, &param0, &param1)) {
        Filename param0_local;
        Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
        if (!(param0_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "Shader.load", "Filename");
        }
        PointerTo< Shader > return_value = (Shader::load)(*param0_this, (Shader::ShaderLanguage)param1);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        Shader *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Shader, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 3:
  case 4:
  case 5:
  case 6:
    {
      // 1-static PointerTo< Shader > Shader::load(Shader::ShaderLanguage lang, Filename const &vertex, Filename const &fragment, Filename const &geometry = "", Filename const &tess_control = "", Filename const &tess_evaluation = "")
      int param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3 = nullptr;
      PyObject *param4 = nullptr;
      PyObject *param5 = nullptr;
      static const char *keyword_list[] = {"lang", "vertex", "fragment", "geometry", "tess_control", "tess_evaluation", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iOO|OOO:load", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Shader.load", "Filename");
        }
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Shader.load", "Filename");
        }
        Filename param3_local;
        Filename const *param3_this;
        if (param3 != nullptr) {
          param3_this = Dtool_Coerce_Filename(param3, param3_local);
        } else {
          param3_local = "";
          param3_this = &param3_local;
        }
        if (param3 != nullptr && !(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "Shader.load", "Filename");
        }
        Filename param4_local;
        Filename const *param4_this;
        if (param4 != nullptr) {
          param4_this = Dtool_Coerce_Filename(param4, param4_local);
        } else {
          param4_local = "";
          param4_this = &param4_local;
        }
        if (param4 != nullptr && !(param4_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "Shader.load", "Filename");
        }
        Filename param5_local;
        Filename const *param5_this;
        if (param5 != nullptr) {
          param5_this = Dtool_Coerce_Filename(param5, param5_local);
        } else {
          param5_local = "";
          param5_this = &param5_local;
        }
        if (param5 != nullptr && !(param5_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param5, 5, "Shader.load", "Filename");
        }
        PointerTo< Shader > return_value = (Shader::load)((Shader::ShaderLanguage)param0, *param1_this, *param2_this, *param3_this, *param4_this, *param5_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        Shader *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Shader, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "load() takes 1, 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load(const Filename file)\n"
      "load(const Filename file, int lang)\n"
      "load(int lang, const Filename vertex, const Filename fragment, const Filename geometry, const Filename tess_control, const Filename tess_evaluation)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_load_1476_comment =
  "C++ Interface:\n"
  "load(const Filename file)\n"
  "load(const Filename file, int lang)\n"
  "load(int lang, const Filename vertex, const Filename fragment, const Filename geometry, const Filename tess_control, const Filename tess_evaluation)\n"
  "\n"
  "/**\n"
  " * Loads the shader from the given string(s). Returns a boolean indicating\n"
  " * success or failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Loads the shader with the given filename.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant of Shader::load loads all shader programs separately.\n"
  " */";
#else
static const char *Dtool_Shader_load_1476_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< Shader > Shader::make(Shader::ShaderLanguage lang, std::string vertex, std::string fragment, std::string geometry = "", std::string tess_control = "", std::string tess_evaluation = "")
 * static PointerTo< Shader > Shader::make(std::string body, Shader::ShaderLanguage lang = ::Shader::SL_none)
 */
static PyObject *Dtool_Shader_make_1477(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "body")) {
        // 1-static PointerTo< Shader > Shader::make(std::string body, Shader::ShaderLanguage lang)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          PointerTo< Shader > return_value = (Shader::make)(std::string(param0_str, param0_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          Shader *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Shader, true, false, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 2:
    {
      // 1-static PointerTo< Shader > Shader::make(std::string body, Shader::ShaderLanguage lang)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      int param1;
      static const char *keyword_list[] = {"body", "lang", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:make", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        PointerTo< Shader > return_value = (Shader::make)(std::string(param0_str, param0_len), (Shader::ShaderLanguage)param1);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        Shader *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Shader, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 3:
  case 4:
  case 5:
  case 6:
    {
      // 1-static PointerTo< Shader > Shader::make(Shader::ShaderLanguage lang, std::string vertex, std::string fragment, std::string geometry = "", std::string tess_control = "", std::string tess_evaluation = "")
      int param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      const char *param2_str = nullptr;
      Py_ssize_t param2_len;
      const char *param3_str = "";
      Py_ssize_t param3_len = 0;
      const char *param4_str = "";
      Py_ssize_t param4_len = 0;
      const char *param5_str = "";
      Py_ssize_t param5_len = 0;
      static const char *keyword_list[] = {"lang", "vertex", "fragment", "geometry", "tess_control", "tess_evaluation", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "is#s#|s#s#s#:make", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len, &param4_str, &param4_len, &param5_str, &param5_len)) {
        PointerTo< Shader > return_value = (Shader::make)((Shader::ShaderLanguage)param0, std::string(param1_str, param1_len), std::string(param2_str, param2_len), std::string(param3_str, param3_len), std::string(param4_str, param4_len), std::string(param5_str, param5_len));
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        Shader *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Shader, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 1, 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(str body)\n"
      "make(str body, int lang)\n"
      "make(int lang, str vertex, str fragment, str geometry, str tess_control, str tess_evaluation)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_make_1477_comment =
  "C++ Interface:\n"
  "make(str body)\n"
  "make(str body, int lang)\n"
  "make(int lang, str vertex, str fragment, str geometry, str tess_control, str tess_evaluation)\n"
  "\n"
  "/**\n"
  " * Loads the shader, using the string as shader body.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Loads the shader, using the strings as shader bodies.\n"
  " */";
#else
static const char *Dtool_Shader_make_1477_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< Shader > Shader::load_compute(Shader::ShaderLanguage lang, Filename const &fn)
 */
static PyObject *Dtool_Shader_load_compute_1478(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< Shader > Shader::load_compute(Shader::ShaderLanguage lang, Filename const &fn)
  int param0;
  PyObject *param1;
  static const char *keyword_list[] = {"lang", "fn", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:load_compute", (char **)keyword_list, &param0, &param1)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Shader.load_compute", "Filename");
    }
    PointerTo< Shader > return_value = (Shader::load_compute)((Shader::ShaderLanguage)param0, *param1_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    Shader *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Shader, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_compute(int lang, const Filename fn)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_load_compute_1478_comment =
  "C++ Interface:\n"
  "load_compute(int lang, const Filename fn)\n"
  "\n"
  "/**\n"
  " * Loads a compute shader.\n"
  " */";
#else
static const char *Dtool_Shader_load_compute_1478_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< Shader > Shader::make_compute(Shader::ShaderLanguage lang, std::string body)
 */
static PyObject *Dtool_Shader_make_compute_1479(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< Shader > Shader::make_compute(Shader::ShaderLanguage lang, std::string body)
  int param0;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"lang", "body", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "is#:make_compute", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    PointerTo< Shader > return_value = (Shader::make_compute)((Shader::ShaderLanguage)param0, std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    Shader *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Shader, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_compute(int lang, str body)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_make_compute_1479_comment =
  "C++ Interface:\n"
  "make_compute(int lang, str body)\n"
  "\n"
  "/**\n"
  " * Loads the compute shader from the given string.\n"
  " */";
#else
static const char *Dtool_Shader_make_compute_1479_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename Shader::get_filename(Shader::ShaderType type = ::Shader::ST_none) const
 */
static PyObject *Dtool_Shader_get_filename_1480(PyObject *self, PyObject *args, PyObject *kwds) {
  Shader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Shader)) {
    return nullptr;
  }
  // 1-inline Filename Shader::get_filename(Shader::ShaderType type = ::Shader::ST_none) const
  int param1 = Shader::ST_none;
  static const char *keyword_list[] = {"type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_filename", (char **)keyword_list, &param1)) {
    Filename *return_value = new Filename(((*(const Shader*)local_this).get_filename)((Shader::ShaderType)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_filename(Shader self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_get_filename_1480_comment =
  "C++ Interface:\n"
  "get_filename(Shader self, int type)\n"
  "\n"
  "/**\n"
  " * Return the Shader's filename for the given shader type.\n"
  " */";
#else
static const char *Dtool_Shader_get_filename_1480_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Shader::set_filename(Shader::ShaderType type, Filename const &filename)
 */
static PyObject *Dtool_Shader_set_filename_1481(PyObject *self, PyObject *args, PyObject *kwds) {
  Shader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Shader, (void **)&local_this, "Shader.set_filename")) {
    return nullptr;
  }
  // 1-inline void Shader::set_filename(Shader::ShaderType type, Filename const &filename)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"type", "filename", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_filename", (char **)keyword_list, &param1, &param2)) {
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Shader.set_filename", "Filename");
    }
    ((*local_this).set_filename)((Shader::ShaderType)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_filename(const Shader self, int type, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_set_filename_1481_comment =
  "C++ Interface:\n"
  "set_filename(const Shader self, int type, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Sets the Shader's filename for the given shader type.  Useful for\n"
  " * associating a shader created with Shader.make with a name for diagnostics.\n"
  " */";
#else
static const char *Dtool_Shader_set_filename_1481_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Shader::get_text(Shader::ShaderType type = ::Shader::ST_none) const
 */
static PyObject *Dtool_Shader_get_text_1482(PyObject *self, PyObject *args, PyObject *kwds) {
  Shader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Shader)) {
    return nullptr;
  }
  // 1-inline std::string const &Shader::get_text(Shader::ShaderType type = ::Shader::ST_none) const
  int param1 = Shader::ST_none;
  static const char *keyword_list[] = {"type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_text", (char **)keyword_list, &param1)) {
    std::string const &return_value = ((*(const Shader*)local_this).get_text)((Shader::ShaderType)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_text(Shader self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_get_text_1482_comment =
  "C++ Interface:\n"
  "get_text(Shader self, int type)\n"
  "\n"
  "/**\n"
  " * Return the Shader's text for the given shader type.\n"
  " */";
#else
static const char *Dtool_Shader_get_text_1482_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Shader::get_error_flag(void) const
 */
static PyObject *Dtool_Shader_get_error_flag_1483(PyObject *self, PyObject *) {
  Shader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Shader)) {
    return nullptr;
  }
  // 1-inline bool Shader::get_error_flag(void) const
  bool return_value = ((*(const Shader*)local_this).get_error_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Shader_get_error_flag_1483_comment =
  "C++ Interface:\n"
  "get_error_flag(Shader self)\n"
  "\n"
  "/**\n"
  " * Returns true if the shader contains a compile-time error.  This doesn't\n"
  " * tell you whether or not the shader is supported on the current video card.\n"
  " */";
#else
static const char *Dtool_Shader_get_error_flag_1483_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Shader::ShaderLanguage Shader::get_language(void) const
 */
static PyObject *Dtool_Shader_get_language_1484(PyObject *self, PyObject *) {
  Shader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Shader)) {
    return nullptr;
  }
  // 1-inline Shader::ShaderLanguage Shader::get_language(void) const
  Shader::ShaderLanguage return_value = ((*(const Shader*)local_this).get_language)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Shader_get_language_1484_comment =
  "C++ Interface:\n"
  "get_language(Shader self)\n"
  "\n"
  "/**\n"
  " * Returns the shader language in which this shader was written.\n"
  " */";
#else
static const char *Dtool_Shader_get_language_1484_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Shader::has_fullpath(void) const
 */
static PyObject *Dtool_Shader_has_fullpath_1485(PyObject *self, PyObject *) {
  Shader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Shader)) {
    return nullptr;
  }
  // 1-inline bool Shader::has_fullpath(void) const
  bool return_value = ((*(const Shader*)local_this).has_fullpath)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Shader_has_fullpath_1485_comment =
  "C++ Interface:\n"
  "has_fullpath(Shader self)\n"
  "\n"
  "/**\n"
  " * Returns true if the fullpath has been set and is available.  See\n"
  " * set_fullpath().\n"
  " */";
#else
static const char *Dtool_Shader_has_fullpath_1485_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &Shader::get_fullpath(void) const
 */
static PyObject *Dtool_Shader_get_fullpath_1486(PyObject *self, PyObject *) {
  Shader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Shader)) {
    return nullptr;
  }
  // 1-inline Filename const &Shader::get_fullpath(void) const
  Filename const *return_value = &(((*(const Shader*)local_this).get_fullpath)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Shader_get_fullpath_1486_comment =
  "C++ Interface:\n"
  "get_fullpath(Shader self)\n"
  "\n"
  "/**\n"
  " * Returns the fullpath that has been set.  This is the full path to the file\n"
  " * as it was found along the model-path.\n"
  " */";
#else
static const char *Dtool_Shader_get_fullpath_1486_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Shader::get_cache_compiled_shader(void) const
 */
static PyObject *Dtool_Shader_get_cache_compiled_shader_1487(PyObject *self, PyObject *) {
  Shader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Shader)) {
    return nullptr;
  }
  // 1-inline bool Shader::get_cache_compiled_shader(void) const
  bool return_value = ((*(const Shader*)local_this).get_cache_compiled_shader)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Shader_get_cache_compiled_shader_1487_comment =
  "C++ Interface:\n"
  "get_cache_compiled_shader(Shader self)\n"
  "\n"
  "/**\n"
  " * Returns the setting of the cache_compiled_shader flag.  See\n"
  " * set_cache_compiled_shader().\n"
  " */";
#else
static const char *Dtool_Shader_get_cache_compiled_shader_1487_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Shader::set_cache_compiled_shader(bool flag)
 */
static PyObject *Dtool_Shader_set_cache_compiled_shader_1488(PyObject *self, PyObject *arg) {
  Shader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Shader, (void **)&local_this, "Shader.set_cache_compiled_shader")) {
    return nullptr;
  }
  // 1-inline void Shader::set_cache_compiled_shader(bool flag)
  ((*local_this).set_cache_compiled_shader)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_compiled_shader(const Shader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_set_cache_compiled_shader_1488_comment =
  "C++ Interface:\n"
  "set_cache_compiled_shader(const Shader self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the cache_compiled_shader flag.  When this is set, the next time the\n"
  " * Shader is loaded on a GSG, it will automatically extract the compiled\n"
  " * shader from the GSG and save it to the global BamCache.\n"
  " *\n"
  " * This is used to store compiled shaders in the BamCache.  This flag should\n"
  " * not be set explicitly; it is set automatically by the ShaderPool when\n"
  " * model-cache-compiled-shaders is set true.\n"
  " */";
#else
static const char *Dtool_Shader_set_cache_compiled_shader_1488_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< AsyncFuture > Shader::prepare(PreparedGraphicsObjects *prepared_objects)
 */
static PyObject *Dtool_Shader_prepare_1489(PyObject *self, PyObject *arg) {
  Shader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Shader, (void **)&local_this, "Shader.prepare")) {
    return nullptr;
  }
  // 1-PointerTo< AsyncFuture > Shader::prepare(PreparedGraphicsObjects *prepared_objects)
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Shader.prepare", false, true);
  if (arg_this != nullptr) {
    PointerTo< AsyncFuture > return_value = ((*local_this).prepare)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    AsyncFuture *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AsyncFuture, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare(const Shader self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_prepare_1489_comment =
  "C++ Interface:\n"
  "prepare(const Shader self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Indicates that the shader should be enqueued to be prepared in the\n"
  " * indicated prepared_objects at the beginning of the next frame.  This will\n"
  " * ensure the texture is already loaded into texture memory if it is expected\n"
  " * to be rendered soon.\n"
  " *\n"
  " * Use this function instead of prepare_now() to preload textures from a user\n"
  " * interface standpoint.\n"
  " */";
#else
static const char *Dtool_Shader_prepare_1489_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Shader::is_prepared(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_Shader_is_prepared_1490(PyObject *self, PyObject *arg) {
  Shader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Shader)) {
    return nullptr;
  }
  // 1-bool Shader::is_prepared(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Shader.is_prepared", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const Shader*)local_this).is_prepared)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_prepared(Shader self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_is_prepared_1490_comment =
  "C++ Interface:\n"
  "is_prepared(Shader self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Returns true if the shader has already been prepared or enqueued for\n"
  " * preparation on the indicated GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_Shader_is_prepared_1490_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Shader::release(PreparedGraphicsObjects *prepared_objects)
 */
static PyObject *Dtool_Shader_release_1491(PyObject *self, PyObject *arg) {
  Shader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Shader, (void **)&local_this, "Shader.release")) {
    return nullptr;
  }
  // 1-bool Shader::release(PreparedGraphicsObjects *prepared_objects)
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "Shader.release", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).release)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release(const Shader self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_release_1491_comment =
  "C++ Interface:\n"
  "release(const Shader self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Frees the texture context only on the indicated object, if it exists there.\n"
  " * Returns true if it was released, false if it had not been prepared.\n"
  " */";
#else
static const char *Dtool_Shader_release_1491_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Shader::release_all(void)
 */
static PyObject *Dtool_Shader_release_all_1492(PyObject *self, PyObject *) {
  Shader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Shader, (void **)&local_this, "Shader.release_all")) {
    return nullptr;
  }
  // 1-int Shader::release_all(void)
  int return_value = ((*local_this).release_all)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Shader_release_all_1492_comment =
  "C++ Interface:\n"
  "release_all(const Shader self)\n"
  "\n"
  "/**\n"
  " * Frees the context allocated on all objects for which the texture has been\n"
  " * declared.  Returns the number of contexts which have been freed.\n"
  " */";
#else
static const char *Dtool_Shader_release_all_1492_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ShaderContext *Shader::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_Shader_prepare_now_1493(PyObject *self, PyObject *args, PyObject *kwds) {
  Shader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Shader, (void **)&local_this, "Shader.prepare_now")) {
    return nullptr;
  }
  // 1-ShaderContext *Shader::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"prepared_objects", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:prepare_now", (char **)keyword_list, &param1, &param2)) {
    PreparedGraphicsObjects *param1_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PreparedGraphicsObjects, 1, "Shader.prepare_now", false, true);
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "Shader.prepare_now", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ShaderContext *return_value = ((*local_this).prepare_now)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ShaderContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_now(const Shader self, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Shader_prepare_now_1493_comment =
  "C++ Interface:\n"
  "prepare_now(const Shader self, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Creates a context for the shader on the particular GSG, if it does not\n"
  " * already exist.  Returns the new (or old) ShaderContext.  This assumes that\n"
  " * the GraphicsStateGuardian is the currently active rendering context and\n"
  " * that it is ready to accept new textures.  If this is not necessarily the\n"
  " * case, you should use prepare() instead.\n"
  " *\n"
  " * Normally, this is not called directly except by the GraphicsStateGuardian;\n"
  " * a shader does not need to be explicitly prepared by the user before it may\n"
  " * be rendered.\n"
  " */";
#else
static const char *Dtool_Shader_prepare_now_1493_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Shader::get_class_type(void)
 */
static PyObject *Dtool_Shader_get_class_type_1494(PyObject *, PyObject *) {
  // 1-static TypeHandle Shader::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Shader::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Shader_get_class_type_1494_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Shader_get_class_type_1494_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Shader::Shader(Shader const &) = default
 */
static int Dtool_Init_Shader(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Shader() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline Shader::Shader(Shader const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    CPT(Shader) param0_this;
    if (!Dtool_ConstCoerce_Shader(param0, param0_this)) {
      Dtool_Raise_ArgTypeError(param0, 0, "Shader.Shader", "Shader");
      return -1;
    }
    Shader *return_value = new Shader(*std::move(param0_this));
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Shader, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Shader(const Shader param0)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Shader(PyObject *args, CPT(Shader) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_Shader)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static PointerTo< Shader > Shader::make(std::string body, Shader::ShaderLanguage lang)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      PointerTo< Shader > return_value = (Shader::make)(std::string(param0_str, param0_len));
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move(DCAST(Shader, return_value.p()));
        return true;
      }
    }
    PyErr_Clear();
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-static PointerTo< Shader > Shader::make(std::string body, Shader::ShaderLanguage lang)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        int param1;
        if (PyArg_ParseTuple(args, "s#i:make", &param0_str, &param0_len, &param1)) {
          PointerTo< Shader > return_value = (Shader::make)(std::string(param0_str, param0_len), (Shader::ShaderLanguage)param1);
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move(DCAST(Shader, return_value.p()));
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 3:
      case 4:
      case 5:
      case 6: {
        // 1-static PointerTo< Shader > Shader::make(Shader::ShaderLanguage lang, std::string vertex, std::string fragment, std::string geometry = "", std::string tess_control = "", std::string tess_evaluation = "")
        int param0;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        const char *param3_str = "";
        Py_ssize_t param3_len = 0;
        const char *param4_str = "";
        Py_ssize_t param4_len = 0;
        const char *param5_str = "";
        Py_ssize_t param5_len = 0;
        if (PyArg_ParseTuple(args, "is#s#|s#s#s#:make", &param0, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len, &param4_str, &param4_len, &param5_str, &param5_len)) {
          PointerTo< Shader > return_value = (Shader::make)((Shader::ShaderLanguage)param0, std::string(param1_str, param1_len), std::string(param2_str, param2_len), std::string(param3_str, param3_len), std::string(param4_str, param4_len), std::string(param5_str, param5_len));
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move(DCAST(Shader, return_value.p()));
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_Shader(PyObject *args, PT(Shader) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_Shader)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static PointerTo< Shader > Shader::make(std::string body, Shader::ShaderLanguage lang)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      PointerTo< Shader > return_value = (Shader::make)(std::string(param0_str, param0_len));
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move(DCAST(Shader, return_value.p()));
        return true;
      }
    }
    PyErr_Clear();
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-static PointerTo< Shader > Shader::make(std::string body, Shader::ShaderLanguage lang)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        int param1;
        if (PyArg_ParseTuple(args, "s#i:make", &param0_str, &param0_len, &param1)) {
          PointerTo< Shader > return_value = (Shader::make)(std::string(param0_str, param0_len), (Shader::ShaderLanguage)param1);
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move(DCAST(Shader, return_value.p()));
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 3:
      case 4:
      case 5:
      case 6: {
        // 1-static PointerTo< Shader > Shader::make(Shader::ShaderLanguage lang, std::string vertex, std::string fragment, std::string geometry = "", std::string tess_control = "", std::string tess_evaluation = "")
        int param0;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        const char *param3_str = "";
        Py_ssize_t param3_len = 0;
        const char *param4_str = "";
        Py_ssize_t param4_len = 0;
        const char *param5_str = "";
        Py_ssize_t param5_len = 0;
        if (PyArg_ParseTuple(args, "is#s#|s#s#s#:make", &param0, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len, &param4_str, &param4_len, &param5_str, &param5_len)) {
          PointerTo< Shader > return_value = (Shader::make)((Shader::ShaderLanguage)param0, std::string(param1_str, param1_len), std::string(param2_str, param2_len), std::string(param3_str, param3_len), std::string(param4_str, param4_len), std::string(param5_str, param5_len));
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = std::move(DCAST(Shader, return_value.p()));
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_Shader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Shader) {
    printf("Shader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Shader *local_this = (Shader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Shader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Shader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Shader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Shader*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Shader*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Shader*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Shader*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShaderBuffer
 */
/**
 * Python function wrapper for:
 * void ShaderBuffer::prepare(PreparedGraphicsObjects *prepared_objects)
 */
static PyObject *Dtool_ShaderBuffer_prepare_1511(PyObject *self, PyObject *arg) {
  ShaderBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderBuffer, (void **)&local_this, "ShaderBuffer.prepare")) {
    return nullptr;
  }
  // 1-void ShaderBuffer::prepare(PreparedGraphicsObjects *prepared_objects)
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "ShaderBuffer.prepare", false, true);
  if (arg_this != nullptr) {
    ((*local_this).prepare)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare(const ShaderBuffer self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderBuffer_prepare_1511_comment =
  "C++ Interface:\n"
  "prepare(const ShaderBuffer self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Indicates that the data should be enqueued to be prepared in the indicated\n"
  " * prepared_objects at the beginning of the next frame.  This will ensure the\n"
  " * data is already loaded into the GSG if it is expected to be rendered soon.\n"
  " *\n"
  " * Use this function instead of prepare_now() to preload datas from a user\n"
  " * interface standpoint.\n"
  " */";
#else
static const char *Dtool_ShaderBuffer_prepare_1511_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ShaderBuffer::is_prepared(PreparedGraphicsObjects *prepared_objects) const
 */
static PyObject *Dtool_ShaderBuffer_is_prepared_1512(PyObject *self, PyObject *arg) {
  ShaderBuffer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderBuffer)) {
    return nullptr;
  }
  // 1-bool ShaderBuffer::is_prepared(PreparedGraphicsObjects *prepared_objects) const
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "ShaderBuffer.is_prepared", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const ShaderBuffer*)local_this).is_prepared)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_prepared(ShaderBuffer self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderBuffer_is_prepared_1512_comment =
  "C++ Interface:\n"
  "is_prepared(ShaderBuffer self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Returns true if the data has already been prepared or enqueued for\n"
  " * preparation on the indicated GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_ShaderBuffer_is_prepared_1512_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BufferContext *ShaderBuffer::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_ShaderBuffer_prepare_now_1513(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderBuffer, (void **)&local_this, "ShaderBuffer.prepare_now")) {
    return nullptr;
  }
  // 1-BufferContext *ShaderBuffer::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"prepared_objects", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:prepare_now", (char **)keyword_list, &param1, &param2)) {
    PreparedGraphicsObjects *param1_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PreparedGraphicsObjects, 1, "ShaderBuffer.prepare_now", false, true);
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "ShaderBuffer.prepare_now", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      BufferContext *return_value = ((*local_this).prepare_now)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BufferContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_now(const ShaderBuffer self, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderBuffer_prepare_now_1513_comment =
  "C++ Interface:\n"
  "prepare_now(const ShaderBuffer self, PreparedGraphicsObjects prepared_objects, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Creates a context for the data on the particular GSG, if it does not\n"
  " * already exist.  Returns the new (or old) BufferContext.  This assumes\n"
  " * that the GraphicsStateGuardian is the currently active rendering context\n"
  " * and that it is ready to accept new datas.  If this is not necessarily the\n"
  " * case, you should use prepare() instead.\n"
  " *\n"
  " * Normally, this is not called directly except by the GraphicsStateGuardian;\n"
  " * a data does not need to be explicitly prepared by the user before it may be\n"
  " * rendered.\n"
  " */";
#else
static const char *Dtool_ShaderBuffer_prepare_now_1513_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ShaderBuffer::release(PreparedGraphicsObjects *prepared_objects)
 */
static PyObject *Dtool_ShaderBuffer_release_1514(PyObject *self, PyObject *arg) {
  ShaderBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderBuffer, (void **)&local_this, "ShaderBuffer.release")) {
    return nullptr;
  }
  // 1-bool ShaderBuffer::release(PreparedGraphicsObjects *prepared_objects)
  PreparedGraphicsObjects *arg_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PreparedGraphicsObjects, 1, "ShaderBuffer.release", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).release)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release(const ShaderBuffer self, PreparedGraphicsObjects prepared_objects)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderBuffer_release_1514_comment =
  "C++ Interface:\n"
  "release(const ShaderBuffer self, PreparedGraphicsObjects prepared_objects)\n"
  "\n"
  "/**\n"
  " * Frees the data context only on the indicated object, if it exists there.\n"
  " * Returns true if it was released, false if it had not been prepared.\n"
  " */";
#else
static const char *Dtool_ShaderBuffer_release_1514_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ShaderBuffer::release_all(void)
 */
static PyObject *Dtool_ShaderBuffer_release_all_1515(PyObject *self, PyObject *) {
  ShaderBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderBuffer, (void **)&local_this, "ShaderBuffer.release_all")) {
    return nullptr;
  }
  // 1-int ShaderBuffer::release_all(void)
  int return_value = ((*local_this).release_all)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderBuffer_release_all_1515_comment =
  "C++ Interface:\n"
  "release_all(const ShaderBuffer self)\n"
  "\n"
  "/**\n"
  " * Frees the context allocated on all objects for which the data has been\n"
  " * declared.  Returns the number of contexts which have been freed.\n"
  " */";
#else
static const char *Dtool_ShaderBuffer_release_all_1515_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ShaderBuffer::get_class_type(void)
 */
static PyObject *Dtool_ShaderBuffer_get_class_type_1516(PyObject *, PyObject *) {
  // 1-static TypeHandle ShaderBuffer::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ShaderBuffer::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderBuffer_get_class_type_1516_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShaderBuffer_get_class_type_1516_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *ShaderBuffer::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_ShaderBuffer_upcast_to_TypedWritableReferenceCount_1497(PyObject *self, PyObject *) {
  ShaderBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderBuffer, (void **)&local_this, "ShaderBuffer.upcast_to_TypedWritableReferenceCount")) {
    return nullptr;
  }
  // 1-TypedWritableReferenceCount *ShaderBuffer::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ShaderBuffer_upcast_to_TypedWritableReferenceCount_1497_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const ShaderBuffer self)\n"
  "\n"
  "upcast from ShaderBuffer to TypedWritableReferenceCount";
#else
static const char *Dtool_ShaderBuffer_upcast_to_TypedWritableReferenceCount_1497_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *ShaderBuffer::upcast_to_Namable(void)
 */
static PyObject *Dtool_ShaderBuffer_upcast_to_Namable_1499(PyObject *self, PyObject *) {
  ShaderBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderBuffer, (void **)&local_this, "ShaderBuffer.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *ShaderBuffer::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderBuffer_upcast_to_Namable_1499_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const ShaderBuffer self)\n"
  "\n"
  "upcast from ShaderBuffer to Namable";
#else
static const char *Dtool_ShaderBuffer_upcast_to_Namable_1499_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomEnums *ShaderBuffer::upcast_to_GeomEnums(void)
 */
static PyObject *Dtool_ShaderBuffer_upcast_to_GeomEnums_1501(PyObject *self, PyObject *) {
  ShaderBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderBuffer, (void **)&local_this, "ShaderBuffer.upcast_to_GeomEnums")) {
    return nullptr;
  }
  // 1-GeomEnums *ShaderBuffer::upcast_to_GeomEnums(void)
  GeomEnums *return_value = (GeomEnums *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GeomEnums, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderBuffer_upcast_to_GeomEnums_1501_comment =
  "C++ Interface:\n"
  "upcast_to_GeomEnums(const ShaderBuffer self)\n"
  "\n"
  "upcast from ShaderBuffer to GeomEnums";
#else
static const char *Dtool_ShaderBuffer_upcast_to_GeomEnums_1501_comment = nullptr;
#endif

static PyObject *Dtool_ShaderBuffer_data_size_bytes_Getter(PyObject *self, void *) {
  const ShaderBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderBuffer, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline uint64_t ShaderBuffer::get_data_size_bytes(void) const
  uint64_t return_value = ((*(const ShaderBuffer*)local_this).get_data_size_bytes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ShaderBuffer_usage_hint_Getter(PyObject *self, void *) {
  const ShaderBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderBuffer, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::UsageHint ShaderBuffer::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const ShaderBuffer*)local_this).get_usage_hint)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ShaderBuffer::ShaderBuffer(ShaderBuffer const &) = default
 * inline explicit ShaderBuffer::ShaderBuffer(std::string const &name, uint64_t size, GeomEnums::UsageHint usage_hint)
 * inline explicit ShaderBuffer::ShaderBuffer(std::string const &name, vector_uchar initial_data, GeomEnums::UsageHint usage_hint)
 */
static int Dtool_Init_ShaderBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline ShaderBuffer::ShaderBuffer(ShaderBuffer const &) = default
      ShaderBuffer const *arg_this = (ShaderBuffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShaderBuffer, 0, "ShaderBuffer.ShaderBuffer", true, true);
      if (arg_this != nullptr) {
        ShaderBuffer *return_value = new ShaderBuffer(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderBuffer, true, false);
      }
    }
    break;
  case 3:
    {
      {
        // -2 inline explicit ShaderBuffer::ShaderBuffer(std::string const &name, vector_uchar initial_data, GeomEnums::UsageHint usage_hint)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        unsigned char *param1_str = nullptr;
        Py_ssize_t param1_len;
        int param2;
        static const char *keyword_list[] = {"name", "initial_data", "usage_hint", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#" FMTCHAR_BYTES "#i:ShaderBuffer", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2)) {
          ShaderBuffer *return_value = new ShaderBuffer(std::string(param0_str, param0_len), vector_uchar(param1_str, param1_str + param1_len), (GeomEnums::UsageHint)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderBuffer, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline explicit ShaderBuffer::ShaderBuffer(std::string const &name, uint64_t size, GeomEnums::UsageHint usage_hint)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        unsigned PY_LONG_LONG param1;
        int param2;
        static const char *keyword_list[] = {"name", "size", "usage_hint", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Ki:ShaderBuffer", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2)) {
          ShaderBuffer *return_value = new ShaderBuffer(std::string(param0_str, param0_len), (uint64_t)param1, (GeomEnums::UsageHint)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderBuffer, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline explicit ShaderBuffer::ShaderBuffer(std::string const &name, vector_uchar initial_data, GeomEnums::UsageHint usage_hint)
      // No coercion possible: inline explicit ShaderBuffer::ShaderBuffer(std::string const &name, uint64_t size, GeomEnums::UsageHint usage_hint)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ShaderBuffer() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShaderBuffer(const ShaderBuffer param0)\n"
      "ShaderBuffer(str name, bytes initial_data, int usage_hint)\n"
      "ShaderBuffer(str name, long size, int usage_hint)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ShaderBuffer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShaderBuffer) {
    printf("ShaderBuffer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShaderBuffer *local_this = (ShaderBuffer *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShaderBuffer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShaderBuffer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShaderBuffer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (ShaderBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ShaderBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShaderBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ShaderBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ShaderBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ShaderBuffer*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PreparedGraphicsObjects
 */
/**
 * Python function wrapper for:
 * inline std::string const &PreparedGraphicsObjects::get_name(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_name_1518(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-inline std::string const &PreparedGraphicsObjects::get_name(void) const
  std::string const &return_value = ((*(const PreparedGraphicsObjects*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_name_1518_comment =
  "C++ Interface:\n"
  "get_name(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the PreparedGraphicsObjects structure.  This is an\n"
  " * arbitrary name that serves mainly to uniquify the context for PStats\n"
  " * reporting.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_name_1518_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::set_graphics_memory_limit(std::size_t limit)
 */
static PyObject *Dtool_PreparedGraphicsObjects_set_graphics_memory_limit_1519(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.set_graphics_memory_limit")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::set_graphics_memory_limit(std::size_t limit)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).set_graphics_memory_limit)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_graphics_memory_limit(const PreparedGraphicsObjects self, int limit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_set_graphics_memory_limit_1519_comment =
  "C++ Interface:\n"
  "set_graphics_memory_limit(const PreparedGraphicsObjects self, int limit)\n"
  "\n"
  "/**\n"
  " * Sets an artificial cap on graphics memory that will be imposed on this GSG.\n"
  " *\n"
  " * This limits the total amount of graphics memory, including texture memory\n"
  " * and vertex buffer memory, that will be consumed by the GSG, regardless of\n"
  " * whether the hardware claims to provide more graphics memory than this.  It\n"
  " * is useful to put a ceiling on graphics memory consumed, since some drivers\n"
  " * seem to allow the application to consume more memory than the hardware can\n"
  " * realistically support.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_set_graphics_memory_limit_1519_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t PreparedGraphicsObjects::get_graphics_memory_limit(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_graphics_memory_limit_1520(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-inline std::size_t PreparedGraphicsObjects::get_graphics_memory_limit(void) const
  std::size_t return_value = ((*(const PreparedGraphicsObjects*)local_this).get_graphics_memory_limit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_graphics_memory_limit_1520_comment =
  "C++ Interface:\n"
  "get_graphics_memory_limit(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the artificial cap on graphics memory that will be imposed on this\n"
  " * GSG.  See set_graphics_memory_limit().\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_graphics_memory_limit_1520_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::show_graphics_memory_lru(std::ostream &out) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_show_graphics_memory_lru_1521(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::show_graphics_memory_lru(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PreparedGraphicsObjects.show_graphics_memory_lru", false, true);
  if (arg_this != nullptr) {
    ((*(const PreparedGraphicsObjects*)local_this).show_graphics_memory_lru)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "show_graphics_memory_lru(PreparedGraphicsObjects self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_show_graphics_memory_lru_1521_comment =
  "C++ Interface:\n"
  "show_graphics_memory_lru(PreparedGraphicsObjects self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes to the indicated ostream a report of how the various textures and\n"
  " * vertex buffers are allocated in the LRU.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_show_graphics_memory_lru_1521_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::show_residency_trackers(std::ostream &out) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_show_residency_trackers_1522(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::show_residency_trackers(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PreparedGraphicsObjects.show_residency_trackers", false, true);
  if (arg_this != nullptr) {
    ((*(const PreparedGraphicsObjects*)local_this).show_residency_trackers)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "show_residency_trackers(PreparedGraphicsObjects self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_show_residency_trackers_1522_comment =
  "C++ Interface:\n"
  "show_residency_trackers(PreparedGraphicsObjects self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes to the indicated ostream a report of how the various textures and\n"
  " * vertex buffers are allocated in the LRU.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_show_residency_trackers_1522_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PreparedGraphicsObjects::release_all(void)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_all_1523(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_all")) {
    return nullptr;
  }
  // 1-inline void PreparedGraphicsObjects::release_all(void)
  ((*local_this).release_all)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_all_1523_comment =
  "C++ Interface:\n"
  "release_all(const PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Releases all prepared objects of all kinds at once.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_all_1523_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PreparedGraphicsObjects::get_num_queued(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_queued_1524(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-inline int PreparedGraphicsObjects::get_num_queued(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_queued)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_1524_comment =
  "C++ Interface:\n"
  "get_num_queued(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of objects of any kind that have been enqueued to be\n"
  " * prepared on this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_1524_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PreparedGraphicsObjects::get_num_prepared(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_prepared_1525(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-inline int PreparedGraphicsObjects::get_num_prepared(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_prepared)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_1525_comment =
  "C++ Interface:\n"
  "get_num_prepared(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of objects of any kind that have already been prepared\n"
  " * on this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_1525_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::enqueue_texture(Texture *tex)
 */
static PyObject *Dtool_PreparedGraphicsObjects_enqueue_texture_1526(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.enqueue_texture")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::enqueue_texture(Texture *tex)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "PreparedGraphicsObjects.enqueue_texture", false, true);
  if (arg_this != nullptr) {
    ((*local_this).enqueue_texture)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enqueue_texture(const PreparedGraphicsObjects self, Texture tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_enqueue_texture_1526_comment =
  "C++ Interface:\n"
  "enqueue_texture(const PreparedGraphicsObjects self, Texture tex)\n"
  "\n"
  "/**\n"
  " * Indicates that a texture would like to be put on the list to be prepared\n"
  " * when the GSG is next ready to do this (presumably at the next frame).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_enqueue_texture_1526_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_texture_queued(Texture const *tex) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_texture_queued_1527(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_texture_queued(Texture const *tex) const
  Texture const *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "PreparedGraphicsObjects.is_texture_queued", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_texture_queued)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_texture_queued(PreparedGraphicsObjects self, const Texture tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_texture_queued_1527_comment =
  "C++ Interface:\n"
  "is_texture_queued(PreparedGraphicsObjects self, const Texture tex)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture has been queued on this GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_texture_queued_1527_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::dequeue_texture(Texture *tex)
 */
static PyObject *Dtool_PreparedGraphicsObjects_dequeue_texture_1528(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.dequeue_texture")) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::dequeue_texture(Texture *tex)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "PreparedGraphicsObjects.dequeue_texture", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).dequeue_texture)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dequeue_texture(const PreparedGraphicsObjects self, Texture tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_dequeue_texture_1528_comment =
  "C++ Interface:\n"
  "dequeue_texture(const PreparedGraphicsObjects self, Texture tex)\n"
  "\n"
  "/**\n"
  " * Removes a texture from the queued list of textures to be prepared.\n"
  " * Normally it is not necessary to call this, unless you change your mind\n"
  " * about preparing it at the last minute, since the texture will automatically\n"
  " * be dequeued and prepared at the next frame.\n"
  " *\n"
  " * The return value is true if the texture is successfully dequeued, false if\n"
  " * it had not been queued.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_dequeue_texture_1528_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_texture_prepared(Texture const *tex) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_texture_prepared_1529(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_texture_prepared(Texture const *tex) const
  Texture const *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "PreparedGraphicsObjects.is_texture_prepared", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_texture_prepared)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_texture_prepared(PreparedGraphicsObjects self, const Texture tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_texture_prepared_1529_comment =
  "C++ Interface:\n"
  "is_texture_prepared(PreparedGraphicsObjects self, const Texture tex)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture has been prepared on this GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_texture_prepared_1529_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::release_texture(Texture *tex)
 * void PreparedGraphicsObjects::release_texture(TextureContext *tc)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_texture_1530(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_texture")) {
    return nullptr;
  }
  {
    // -2 void PreparedGraphicsObjects::release_texture(TextureContext *tc)
    TextureContext *arg_this = (TextureContext *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureContext, 1, "PreparedGraphicsObjects.release_texture", false, false);
    if (arg_this != nullptr) {
      ((*local_this).release_texture)(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PreparedGraphicsObjects::release_texture(Texture *tex)
    Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "PreparedGraphicsObjects.release_texture", false, false);
    if (arg_this != nullptr) {
      ((*local_this).release_texture)(arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void PreparedGraphicsObjects::release_texture(TextureContext *tc)
  // No coercion possible: void PreparedGraphicsObjects::release_texture(Texture *tex)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_texture(const PreparedGraphicsObjects self, TextureContext tc)\n"
      "release_texture(const PreparedGraphicsObjects self, Texture tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_texture_1530_comment =
  "C++ Interface:\n"
  "release_texture(const PreparedGraphicsObjects self, TextureContext tc)\n"
  "release_texture(const PreparedGraphicsObjects self, Texture tex)\n"
  "\n"
  "/**\n"
  " * Indicates that a texture context, created by a previous call to\n"
  " * prepare_texture(), is no longer needed.  The driver resources will not be\n"
  " * freed until some GSG calls update(), indicating it is at a stage where it\n"
  " * is ready to release textures--this prevents conflicts from threading or\n"
  " * multiple GSG's sharing textures (we have no way of knowing which graphics\n"
  " * context is currently active, or what state it's in, at the time\n"
  " * release_texture is called).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Releases a texture if it has already been prepared, or removes it from the\n"
  " * preparation queue.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_texture_1530_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::release_all_textures(void)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_all_textures_1531(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_all_textures")) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::release_all_textures(void)
  int return_value = ((*local_this).release_all_textures)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_all_textures_1531_comment =
  "C++ Interface:\n"
  "release_all_textures(const PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Releases all textures at once.  This will force them to be reloaded into\n"
  " * texture memory for all GSG's that share this object.  Returns the number of\n"
  " * textures released.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_all_textures_1531_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_queued_textures(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_queued_textures_1532(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_queued_textures(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_queued_textures)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_textures_1532_comment =
  "C++ Interface:\n"
  "get_num_queued_textures(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of textures that have been enqueued to be prepared on\n"
  " * this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_textures_1532_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_prepared_textures(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_prepared_textures_1533(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_prepared_textures(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_prepared_textures)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_textures_1533_comment =
  "C++ Interface:\n"
  "get_num_prepared_textures(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of textures that have already been prepared on this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_textures_1533_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextureContext *PreparedGraphicsObjects::prepare_texture_now(Texture *tex, int view, GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_PreparedGraphicsObjects_prepare_texture_now_1534(PyObject *self, PyObject *args, PyObject *kwds) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.prepare_texture_now")) {
    return nullptr;
  }
  // 1-TextureContext *PreparedGraphicsObjects::prepare_texture_now(Texture *tex, int view, GraphicsStateGuardianBase *gsg)
  PyObject *param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"tex", "view", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO:prepare_texture_now", (char **)keyword_list, &param1, &param2, &param3)) {
    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "PreparedGraphicsObjects.prepare_texture_now", false, true);
    GraphicsStateGuardianBase *param3_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_GraphicsStateGuardianBase, 3, "PreparedGraphicsObjects.prepare_texture_now", false, true);
    if (param1_this != nullptr && param3_this != nullptr) {
      TextureContext *return_value = ((*local_this).prepare_texture_now)(param1_this, (int)param2, param3_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_texture_now(const PreparedGraphicsObjects self, Texture tex, int view, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_prepare_texture_now_1534_comment =
  "C++ Interface:\n"
  "prepare_texture_now(const PreparedGraphicsObjects self, Texture tex, int view, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Immediately creates a new TextureContext for the indicated texture and\n"
  " * returns it.  This assumes that the GraphicsStateGuardian is the currently\n"
  " * active rendering context and that it is ready to accept new textures.  If\n"
  " * this is not necessarily the case, you should use enqueue_texture() instead.\n"
  " *\n"
  " * Normally, this function is not called directly.  Call\n"
  " * Texture::prepare_now() instead.\n"
  " *\n"
  " * The TextureContext contains all of the pertinent information needed by the\n"
  " * GSG to keep track of this one particular texture, and will exist as long as\n"
  " * the texture is ready to be rendered.\n"
  " *\n"
  " * When either the Texture or the PreparedGraphicsObjects object destructs,\n"
  " * the TextureContext will be deleted.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_prepare_texture_now_1534_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::enqueue_sampler(SamplerState const &sampler)
 */
static PyObject *Dtool_PreparedGraphicsObjects_enqueue_sampler_1535(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.enqueue_sampler")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::enqueue_sampler(SamplerState const &sampler)
  SamplerState const *arg_this = (SamplerState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SamplerState, 1, "PreparedGraphicsObjects.enqueue_sampler", true, true);
  if (arg_this != nullptr) {
    ((*local_this).enqueue_sampler)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enqueue_sampler(const PreparedGraphicsObjects self, const SamplerState sampler)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_enqueue_sampler_1535_comment =
  "C++ Interface:\n"
  "enqueue_sampler(const PreparedGraphicsObjects self, const SamplerState sampler)\n"
  "\n"
  "/**\n"
  " * Indicates that a sampler would like to be put on the list to be prepared\n"
  " * when the GSG is next ready to do this (presumably at the next frame).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_enqueue_sampler_1535_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_sampler_queued(SamplerState const &sampler) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_sampler_queued_1536(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_sampler_queued(SamplerState const &sampler) const
  SamplerState const *arg_this = (SamplerState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SamplerState, 1, "PreparedGraphicsObjects.is_sampler_queued", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_sampler_queued)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_sampler_queued(PreparedGraphicsObjects self, const SamplerState sampler)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_sampler_queued_1536_comment =
  "C++ Interface:\n"
  "is_sampler_queued(PreparedGraphicsObjects self, const SamplerState sampler)\n"
  "\n"
  "/**\n"
  " * Returns true if the sampler has been queued on this GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_sampler_queued_1536_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::dequeue_sampler(SamplerState const &sampler)
 */
static PyObject *Dtool_PreparedGraphicsObjects_dequeue_sampler_1537(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.dequeue_sampler")) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::dequeue_sampler(SamplerState const &sampler)
  SamplerState const *arg_this = (SamplerState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SamplerState, 1, "PreparedGraphicsObjects.dequeue_sampler", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).dequeue_sampler)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dequeue_sampler(const PreparedGraphicsObjects self, const SamplerState sampler)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_dequeue_sampler_1537_comment =
  "C++ Interface:\n"
  "dequeue_sampler(const PreparedGraphicsObjects self, const SamplerState sampler)\n"
  "\n"
  "/**\n"
  " * Removes a sampler from the queued list of samplers to be prepared.\n"
  " * Normally it is not necessary to call this, unless you change your mind\n"
  " * about preparing it at the last minute, since the sampler will automatically\n"
  " * be dequeued and prepared at the next frame.\n"
  " *\n"
  " * The return value is true if the sampler is successfully dequeued, false if\n"
  " * it had not been queued.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_dequeue_sampler_1537_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_sampler_prepared(SamplerState const &sampler) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_sampler_prepared_1538(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_sampler_prepared(SamplerState const &sampler) const
  SamplerState const *arg_this = (SamplerState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SamplerState, 1, "PreparedGraphicsObjects.is_sampler_prepared", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_sampler_prepared)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_sampler_prepared(PreparedGraphicsObjects self, const SamplerState sampler)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_sampler_prepared_1538_comment =
  "C++ Interface:\n"
  "is_sampler_prepared(PreparedGraphicsObjects self, const SamplerState sampler)\n"
  "\n"
  "/**\n"
  " * Returns true if the sampler has been prepared on this GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_sampler_prepared_1538_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Rejected Remap [void PreparedGraphicsObjects::release_sampler(SamplerContext *sc)]
 * void PreparedGraphicsObjects::release_sampler(SamplerState const &sampler)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_sampler_1539(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_sampler")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::release_sampler(SamplerState const &sampler)
  SamplerState const *arg_this = (SamplerState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SamplerState, 1, "PreparedGraphicsObjects.release_sampler", true, true);
  if (arg_this != nullptr) {
    ((*local_this).release_sampler)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_sampler(const PreparedGraphicsObjects self, const SamplerState sampler)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_sampler_1539_comment =
  "C++ Interface:\n"
  "release_sampler(const PreparedGraphicsObjects self, const SamplerState sampler)\n"
  "\n"
  "/**\n"
  " * Indicates that a sampler context, created by a previous call to\n"
  " * prepare_sampler(), is no longer needed.  The driver resources will not be\n"
  " * freed until some GSG calls update(), indicating it is at a stage where it\n"
  " * is ready to release samplers.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Releases a sampler if it has already been prepared, or removes it from the\n"
  " * preparation queue.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_sampler_1539_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::release_all_samplers(void)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_all_samplers_1540(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_all_samplers")) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::release_all_samplers(void)
  int return_value = ((*local_this).release_all_samplers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_all_samplers_1540_comment =
  "C++ Interface:\n"
  "release_all_samplers(const PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Releases all samplers at once.  This will force them to be reloaded for all\n"
  " * GSG's that share this object.  Returns the number of samplers released.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_all_samplers_1540_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_queued_samplers(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_queued_samplers_1541(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_queued_samplers(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_queued_samplers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_samplers_1541_comment =
  "C++ Interface:\n"
  "get_num_queued_samplers(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of samplers that have been enqueued to be prepared on\n"
  " * this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_samplers_1541_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_prepared_samplers(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_prepared_samplers_1542(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_prepared_samplers(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_prepared_samplers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_samplers_1542_comment =
  "C++ Interface:\n"
  "get_num_prepared_samplers(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of samplers that have already been prepared on this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_samplers_1542_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::enqueue_geom(Geom *geom)
 */
static PyObject *Dtool_PreparedGraphicsObjects_enqueue_geom_1544(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.enqueue_geom")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::enqueue_geom(Geom *geom)
  Geom *arg_this = (Geom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Geom, 1, "PreparedGraphicsObjects.enqueue_geom", false, true);
  if (arg_this != nullptr) {
    ((*local_this).enqueue_geom)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enqueue_geom(const PreparedGraphicsObjects self, Geom geom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_enqueue_geom_1544_comment =
  "C++ Interface:\n"
  "enqueue_geom(const PreparedGraphicsObjects self, Geom geom)\n"
  "\n"
  "/**\n"
  " * Indicates that a geom would like to be put on the list to be prepared when\n"
  " * the GSG is next ready to do this (presumably at the next frame).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_enqueue_geom_1544_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_geom_queued(Geom const *geom) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_geom_queued_1545(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_geom_queued(Geom const *geom) const
  Geom const *arg_this = (Geom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Geom, 1, "PreparedGraphicsObjects.is_geom_queued", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_geom_queued)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_geom_queued(PreparedGraphicsObjects self, const Geom geom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_geom_queued_1545_comment =
  "C++ Interface:\n"
  "is_geom_queued(PreparedGraphicsObjects self, const Geom geom)\n"
  "\n"
  "/**\n"
  " * Returns true if the geom has been queued on this GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_geom_queued_1545_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::dequeue_geom(Geom *geom)
 */
static PyObject *Dtool_PreparedGraphicsObjects_dequeue_geom_1546(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.dequeue_geom")) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::dequeue_geom(Geom *geom)
  Geom *arg_this = (Geom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Geom, 1, "PreparedGraphicsObjects.dequeue_geom", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).dequeue_geom)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dequeue_geom(const PreparedGraphicsObjects self, Geom geom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_dequeue_geom_1546_comment =
  "C++ Interface:\n"
  "dequeue_geom(const PreparedGraphicsObjects self, Geom geom)\n"
  "\n"
  "/**\n"
  " * Removes a geom from the queued list of geoms to be prepared.  Normally it\n"
  " * is not necessary to call this, unless you change your mind about preparing\n"
  " * it at the last minute, since the geom will automatically be dequeued and\n"
  " * prepared at the next frame.\n"
  " *\n"
  " * The return value is true if the geom is successfully dequeued, false if it\n"
  " * had not been queued.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_dequeue_geom_1546_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_geom_prepared(Geom const *geom) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_geom_prepared_1547(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_geom_prepared(Geom const *geom) const
  Geom const *arg_this = (Geom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Geom, 1, "PreparedGraphicsObjects.is_geom_prepared", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_geom_prepared)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_geom_prepared(PreparedGraphicsObjects self, const Geom geom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_geom_prepared_1547_comment =
  "C++ Interface:\n"
  "is_geom_prepared(PreparedGraphicsObjects self, const Geom geom)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex buffer has been prepared on this GSG, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_geom_prepared_1547_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::release_geom(GeomContext *gc)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_geom_1548(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_geom")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::release_geom(GeomContext *gc)
  GeomContext *arg_this = (GeomContext *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomContext, 1, "PreparedGraphicsObjects.release_geom", false, true);
  if (arg_this != nullptr) {
    ((*local_this).release_geom)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_geom(const PreparedGraphicsObjects self, GeomContext gc)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_geom_1548_comment =
  "C++ Interface:\n"
  "release_geom(const PreparedGraphicsObjects self, GeomContext gc)\n"
  "\n"
  "/**\n"
  " * Indicates that a geom context, created by a previous call to\n"
  " * prepare_geom(), is no longer needed.  The driver resources will not be\n"
  " * freed until some GSG calls update(), indicating it is at a stage where it\n"
  " * is ready to release geoms--this prevents conflicts from threading or\n"
  " * multiple GSG's sharing geoms (we have no way of knowing which graphics\n"
  " * context is currently active, or what state it's in, at the time\n"
  " * release_geom is called).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_geom_1548_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::release_all_geoms(void)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_all_geoms_1549(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_all_geoms")) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::release_all_geoms(void)
  int return_value = ((*local_this).release_all_geoms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_all_geoms_1549_comment =
  "C++ Interface:\n"
  "release_all_geoms(const PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Releases all geoms at once.  This will force them to be reloaded into geom\n"
  " * memory for all GSG's that share this object.  Returns the number of geoms\n"
  " * released.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_all_geoms_1549_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_queued_geoms(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_queued_geoms_1550(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_queued_geoms(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_queued_geoms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_geoms_1550_comment =
  "C++ Interface:\n"
  "get_num_queued_geoms(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of geoms that have been enqueued to be prepared on this\n"
  " * GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_geoms_1550_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_prepared_geoms(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_prepared_geoms_1551(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_prepared_geoms(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_prepared_geoms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_geoms_1551_comment =
  "C++ Interface:\n"
  "get_num_prepared_geoms(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of geoms that have already been prepared on this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_geoms_1551_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GeomContext *PreparedGraphicsObjects::prepare_geom_now(Geom *geom, GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_PreparedGraphicsObjects_prepare_geom_now_1552(PyObject *self, PyObject *args, PyObject *kwds) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.prepare_geom_now")) {
    return nullptr;
  }
  // 1-GeomContext *PreparedGraphicsObjects::prepare_geom_now(Geom *geom, GraphicsStateGuardianBase *gsg)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"geom", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:prepare_geom_now", (char **)keyword_list, &param1, &param2)) {
    Geom *param1_this = (Geom *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Geom, 1, "PreparedGraphicsObjects.prepare_geom_now", false, true);
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "PreparedGraphicsObjects.prepare_geom_now", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      GeomContext *return_value = ((*local_this).prepare_geom_now)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_geom_now(const PreparedGraphicsObjects self, Geom geom, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_prepare_geom_now_1552_comment =
  "C++ Interface:\n"
  "prepare_geom_now(const PreparedGraphicsObjects self, Geom geom, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Immediately creates a new GeomContext for the indicated geom and returns\n"
  " * it.  This assumes that the GraphicsStateGuardian is the currently active\n"
  " * rendering context and that it is ready to accept new geoms.  If this is not\n"
  " * necessarily the case, you should use enqueue_geom() instead.\n"
  " *\n"
  " * Normally, this function is not called directly.  Call Geom::prepare_now()\n"
  " * instead.\n"
  " *\n"
  " * The GeomContext contains all of the pertinent information needed by the GSG\n"
  " * to keep track of this one particular geom, and will exist as long as the\n"
  " * geom is ready to be rendered.\n"
  " *\n"
  " * When either the Geom or the PreparedGraphicsObjects object destructs, the\n"
  " * GeomContext will be deleted.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_prepare_geom_now_1552_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::enqueue_shader(Shader *shader)
 */
static PyObject *Dtool_PreparedGraphicsObjects_enqueue_shader_1553(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.enqueue_shader")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::enqueue_shader(Shader *shader)
  PT(Shader) arg_this;
  if (!Dtool_Coerce_Shader(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PreparedGraphicsObjects.enqueue_shader", "Shader");
  }
  ((*local_this).enqueue_shader)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enqueue_shader(const PreparedGraphicsObjects self, Shader shader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_enqueue_shader_1553_comment =
  "C++ Interface:\n"
  "enqueue_shader(const PreparedGraphicsObjects self, Shader shader)\n"
  "\n"
  "/**\n"
  " * Indicates that a shader would like to be put on the list to be prepared\n"
  " * when the GSG is next ready to do this (presumably at the next frame).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_enqueue_shader_1553_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_shader_queued(Shader const *shader) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_shader_queued_1554(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_shader_queued(Shader const *shader) const
  CPT(Shader) arg_this;
  if (!Dtool_ConstCoerce_Shader(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PreparedGraphicsObjects.is_shader_queued", "Shader");
  }
  bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_shader_queued)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_shader_queued(PreparedGraphicsObjects self, const Shader shader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_shader_queued_1554_comment =
  "C++ Interface:\n"
  "is_shader_queued(PreparedGraphicsObjects self, const Shader shader)\n"
  "\n"
  "/**\n"
  " * Returns true if the shader has been queued on this GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_shader_queued_1554_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::dequeue_shader(Shader *shader)
 */
static PyObject *Dtool_PreparedGraphicsObjects_dequeue_shader_1555(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.dequeue_shader")) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::dequeue_shader(Shader *shader)
  PT(Shader) arg_this;
  if (!Dtool_Coerce_Shader(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PreparedGraphicsObjects.dequeue_shader", "Shader");
  }
  bool return_value = ((*local_this).dequeue_shader)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dequeue_shader(const PreparedGraphicsObjects self, Shader shader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_dequeue_shader_1555_comment =
  "C++ Interface:\n"
  "dequeue_shader(const PreparedGraphicsObjects self, Shader shader)\n"
  "\n"
  "/**\n"
  " * Removes a shader from the queued list of shaders to be prepared.  Normally\n"
  " * it is not necessary to call this, unless you change your mind about\n"
  " * preparing it at the last minute, since the shader will automatically be\n"
  " * dequeued and prepared at the next frame.\n"
  " *\n"
  " * The return value is true if the shader is successfully dequeued, false if\n"
  " * it had not been queued.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_dequeue_shader_1555_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_shader_prepared(Shader const *shader) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_shader_prepared_1556(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_shader_prepared(Shader const *shader) const
  CPT(Shader) arg_this;
  if (!Dtool_ConstCoerce_Shader(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PreparedGraphicsObjects.is_shader_prepared", "Shader");
  }
  bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_shader_prepared)(std::move(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_shader_prepared(PreparedGraphicsObjects self, const Shader shader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_shader_prepared_1556_comment =
  "C++ Interface:\n"
  "is_shader_prepared(PreparedGraphicsObjects self, const Shader shader)\n"
  "\n"
  "/**\n"
  " * Returns true if the shader has been prepared on this GSG, false otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_shader_prepared_1556_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::release_shader(ShaderContext *sc)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_shader_1557(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_shader")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::release_shader(ShaderContext *sc)
  ShaderContext *arg_this = (ShaderContext *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShaderContext, 1, "PreparedGraphicsObjects.release_shader", false, true);
  if (arg_this != nullptr) {
    ((*local_this).release_shader)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_shader(const PreparedGraphicsObjects self, ShaderContext sc)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_shader_1557_comment =
  "C++ Interface:\n"
  "release_shader(const PreparedGraphicsObjects self, ShaderContext sc)\n"
  "\n"
  "/**\n"
  " * Indicates that a shader context, created by a previous call to\n"
  " * prepare_shader(), is no longer needed.  The driver resources will not be\n"
  " * freed until some GSG calls update(), indicating it is at a stage where it\n"
  " * is ready to release shaders--this prevents conflicts from threading or\n"
  " * multiple GSG's sharing shaders (we have no way of knowing which graphics\n"
  " * context is currently active, or what state it's in, at the time\n"
  " * release_shader is called).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_shader_1557_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::release_all_shaders(void)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_all_shaders_1558(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_all_shaders")) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::release_all_shaders(void)
  int return_value = ((*local_this).release_all_shaders)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_all_shaders_1558_comment =
  "C++ Interface:\n"
  "release_all_shaders(const PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Releases all shaders at once.  This will force them to be reloaded into\n"
  " * shader memory for all GSG's that share this object.  Returns the number of\n"
  " * shaders released.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_all_shaders_1558_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_queued_shaders(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_queued_shaders_1559(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_queued_shaders(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_queued_shaders)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_shaders_1559_comment =
  "C++ Interface:\n"
  "get_num_queued_shaders(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of shaders that have been enqueued to be prepared on\n"
  " * this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_shaders_1559_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_prepared_shaders(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_prepared_shaders_1560(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_prepared_shaders(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_prepared_shaders)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_shaders_1560_comment =
  "C++ Interface:\n"
  "get_num_prepared_shaders(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of shaders that have already been prepared on this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_shaders_1560_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ShaderContext *PreparedGraphicsObjects::prepare_shader_now(Shader *shader, GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_PreparedGraphicsObjects_prepare_shader_now_1561(PyObject *self, PyObject *args, PyObject *kwds) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.prepare_shader_now")) {
    return nullptr;
  }
  // 1-ShaderContext *PreparedGraphicsObjects::prepare_shader_now(Shader *shader, GraphicsStateGuardianBase *gsg)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"shader", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:prepare_shader_now", (char **)keyword_list, &param1, &param2)) {
    PT(Shader) param1_this;
    if (!Dtool_Coerce_Shader(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PreparedGraphicsObjects.prepare_shader_now", "Shader");
    }
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "PreparedGraphicsObjects.prepare_shader_now", false, true);
    if (param2_this != nullptr) {
      ShaderContext *return_value = ((*local_this).prepare_shader_now)(std::move(param1_this), param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ShaderContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_shader_now(const PreparedGraphicsObjects self, Shader shader, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_prepare_shader_now_1561_comment =
  "C++ Interface:\n"
  "prepare_shader_now(const PreparedGraphicsObjects self, Shader shader, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Immediately creates a new ShaderContext for the indicated shader and\n"
  " * returns it.  This assumes that the GraphicsStateGuardian is the currently\n"
  " * active rendering context and that it is ready to accept new shaders.  If\n"
  " * this is not necessarily the case, you should use enqueue_shader() instead.\n"
  " *\n"
  " * Normally, this function is not called directly.  Call Shader::prepare_now()\n"
  " * instead.\n"
  " *\n"
  " * The ShaderContext contains all of the pertinent information needed by the\n"
  " * GSG to keep track of this one particular shader, and will exist as long as\n"
  " * the shader is ready to be rendered.\n"
  " *\n"
  " * When either the Shader or the PreparedGraphicsObjects object destructs, the\n"
  " * ShaderContext will be deleted.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_prepare_shader_now_1561_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::enqueue_vertex_buffer(GeomVertexArrayData *data)
 */
static PyObject *Dtool_PreparedGraphicsObjects_enqueue_vertex_buffer_1562(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.enqueue_vertex_buffer")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::enqueue_vertex_buffer(GeomVertexArrayData *data)
  GeomVertexArrayData *arg_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayData, 1, "PreparedGraphicsObjects.enqueue_vertex_buffer", false, true);
  if (arg_this != nullptr) {
    ((*local_this).enqueue_vertex_buffer)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enqueue_vertex_buffer(const PreparedGraphicsObjects self, GeomVertexArrayData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_enqueue_vertex_buffer_1562_comment =
  "C++ Interface:\n"
  "enqueue_vertex_buffer(const PreparedGraphicsObjects self, GeomVertexArrayData data)\n"
  "\n"
  "/**\n"
  " * Indicates that a buffer would like to be put on the list to be prepared\n"
  " * when the GSG is next ready to do this (presumably at the next frame).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_enqueue_vertex_buffer_1562_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_vertex_buffer_queued(GeomVertexArrayData const *data) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_vertex_buffer_queued_1563(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_vertex_buffer_queued(GeomVertexArrayData const *data) const
  GeomVertexArrayData const *arg_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayData, 1, "PreparedGraphicsObjects.is_vertex_buffer_queued", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_vertex_buffer_queued)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_vertex_buffer_queued(PreparedGraphicsObjects self, const GeomVertexArrayData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_vertex_buffer_queued_1563_comment =
  "C++ Interface:\n"
  "is_vertex_buffer_queued(PreparedGraphicsObjects self, const GeomVertexArrayData data)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex buffer has been queued on this GSG, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_vertex_buffer_queued_1563_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::dequeue_vertex_buffer(GeomVertexArrayData *data)
 */
static PyObject *Dtool_PreparedGraphicsObjects_dequeue_vertex_buffer_1564(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.dequeue_vertex_buffer")) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::dequeue_vertex_buffer(GeomVertexArrayData *data)
  GeomVertexArrayData *arg_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayData, 1, "PreparedGraphicsObjects.dequeue_vertex_buffer", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).dequeue_vertex_buffer)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dequeue_vertex_buffer(const PreparedGraphicsObjects self, GeomVertexArrayData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_dequeue_vertex_buffer_1564_comment =
  "C++ Interface:\n"
  "dequeue_vertex_buffer(const PreparedGraphicsObjects self, GeomVertexArrayData data)\n"
  "\n"
  "/**\n"
  " * Removes a buffer from the queued list of data arrays to be prepared.\n"
  " * Normally it is not necessary to call this, unless you change your mind\n"
  " * about preparing it at the last minute, since the data will automatically be\n"
  " * dequeued and prepared at the next frame.\n"
  " *\n"
  " * The return value is true if the buffer is successfully dequeued, false if\n"
  " * it had not been queued.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_dequeue_vertex_buffer_1564_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_vertex_buffer_prepared(GeomVertexArrayData const *data) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_vertex_buffer_prepared_1565(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_vertex_buffer_prepared(GeomVertexArrayData const *data) const
  GeomVertexArrayData const *arg_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayData, 1, "PreparedGraphicsObjects.is_vertex_buffer_prepared", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_vertex_buffer_prepared)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_vertex_buffer_prepared(PreparedGraphicsObjects self, const GeomVertexArrayData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_vertex_buffer_prepared_1565_comment =
  "C++ Interface:\n"
  "is_vertex_buffer_prepared(PreparedGraphicsObjects self, const GeomVertexArrayData data)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex buffer has been prepared on this GSG, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_vertex_buffer_prepared_1565_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::release_vertex_buffer(VertexBufferContext *vbc)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_vertex_buffer_1566(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_vertex_buffer")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::release_vertex_buffer(VertexBufferContext *vbc)
  VertexBufferContext *arg_this = (VertexBufferContext *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VertexBufferContext, 1, "PreparedGraphicsObjects.release_vertex_buffer", false, true);
  if (arg_this != nullptr) {
    ((*local_this).release_vertex_buffer)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_vertex_buffer(const PreparedGraphicsObjects self, VertexBufferContext vbc)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_vertex_buffer_1566_comment =
  "C++ Interface:\n"
  "release_vertex_buffer(const PreparedGraphicsObjects self, VertexBufferContext vbc)\n"
  "\n"
  "/**\n"
  " * Indicates that a data context, created by a previous call to\n"
  " * prepare_vertex_buffer(), is no longer needed.  The driver resources will\n"
  " * not be freed until some GSG calls update(), indicating it is at a stage\n"
  " * where it is ready to release datas--this prevents conflicts from threading\n"
  " * or multiple GSG's sharing datas (we have no way of knowing which graphics\n"
  " * context is currently active, or what state it's in, at the time\n"
  " * release_vertex_buffer is called).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_vertex_buffer_1566_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::release_all_vertex_buffers(void)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_all_vertex_buffers_1567(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_all_vertex_buffers")) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::release_all_vertex_buffers(void)
  int return_value = ((*local_this).release_all_vertex_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_all_vertex_buffers_1567_comment =
  "C++ Interface:\n"
  "release_all_vertex_buffers(const PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Releases all datas at once.  This will force them to be reloaded into data\n"
  " * memory for all GSG's that share this object.  Returns the number of datas\n"
  " * released.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_all_vertex_buffers_1567_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_queued_vertex_buffers(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_queued_vertex_buffers_1568(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_queued_vertex_buffers(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_queued_vertex_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_vertex_buffers_1568_comment =
  "C++ Interface:\n"
  "get_num_queued_vertex_buffers(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertex buffers that have been enqueued to be prepared\n"
  " * on this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_vertex_buffers_1568_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_prepared_vertex_buffers(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_prepared_vertex_buffers_1569(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_prepared_vertex_buffers(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_prepared_vertex_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_vertex_buffers_1569_comment =
  "C++ Interface:\n"
  "get_num_prepared_vertex_buffers(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertex buffers that have already been prepared on\n"
  " * this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_vertex_buffers_1569_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * VertexBufferContext *PreparedGraphicsObjects::prepare_vertex_buffer_now(GeomVertexArrayData *data, GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_PreparedGraphicsObjects_prepare_vertex_buffer_now_1570(PyObject *self, PyObject *args, PyObject *kwds) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.prepare_vertex_buffer_now")) {
    return nullptr;
  }
  // 1-VertexBufferContext *PreparedGraphicsObjects::prepare_vertex_buffer_now(GeomVertexArrayData *data, GraphicsStateGuardianBase *gsg)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"data", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:prepare_vertex_buffer_now", (char **)keyword_list, &param1, &param2)) {
    GeomVertexArrayData *param1_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GeomVertexArrayData, 1, "PreparedGraphicsObjects.prepare_vertex_buffer_now", false, true);
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "PreparedGraphicsObjects.prepare_vertex_buffer_now", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      VertexBufferContext *return_value = ((*local_this).prepare_vertex_buffer_now)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VertexBufferContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_vertex_buffer_now(const PreparedGraphicsObjects self, GeomVertexArrayData data, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_prepare_vertex_buffer_now_1570_comment =
  "C++ Interface:\n"
  "prepare_vertex_buffer_now(const PreparedGraphicsObjects self, GeomVertexArrayData data, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Immediately creates a new VertexBufferContext for the indicated data and\n"
  " * returns it.  This assumes that the GraphicsStateGuardian is the currently\n"
  " * active rendering context and that it is ready to accept new datas.  If this\n"
  " * is not necessarily the case, you should use enqueue_vertex_buffer()\n"
  " * instead.\n"
  " *\n"
  " * Normally, this function is not called directly.  Call Data::prepare_now()\n"
  " * instead.\n"
  " *\n"
  " * The VertexBufferContext contains all of the pertinent information needed by\n"
  " * the GSG to keep track of this one particular data, and will exist as long\n"
  " * as the data is ready to be rendered.\n"
  " *\n"
  " * When either the Data or the PreparedGraphicsObjects object destructs, the\n"
  " * VertexBufferContext will be deleted.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_prepare_vertex_buffer_now_1570_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::enqueue_index_buffer(GeomPrimitive *data)
 */
static PyObject *Dtool_PreparedGraphicsObjects_enqueue_index_buffer_1571(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.enqueue_index_buffer")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::enqueue_index_buffer(GeomPrimitive *data)
  GeomPrimitive *arg_this = (GeomPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomPrimitive, 1, "PreparedGraphicsObjects.enqueue_index_buffer", false, true);
  if (arg_this != nullptr) {
    ((*local_this).enqueue_index_buffer)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enqueue_index_buffer(const PreparedGraphicsObjects self, GeomPrimitive data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_enqueue_index_buffer_1571_comment =
  "C++ Interface:\n"
  "enqueue_index_buffer(const PreparedGraphicsObjects self, GeomPrimitive data)\n"
  "\n"
  "/**\n"
  " * Indicates that a buffer would like to be put on the list to be prepared\n"
  " * when the GSG is next ready to do this (presumably at the next frame).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_enqueue_index_buffer_1571_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_index_buffer_queued(GeomPrimitive const *data) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_index_buffer_queued_1572(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_index_buffer_queued(GeomPrimitive const *data) const
  GeomPrimitive const *arg_this = (GeomPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomPrimitive, 1, "PreparedGraphicsObjects.is_index_buffer_queued", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_index_buffer_queued)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_index_buffer_queued(PreparedGraphicsObjects self, const GeomPrimitive data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_index_buffer_queued_1572_comment =
  "C++ Interface:\n"
  "is_index_buffer_queued(PreparedGraphicsObjects self, const GeomPrimitive data)\n"
  "\n"
  "/**\n"
  " * Returns true if the index buffer has been queued on this GSG, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_index_buffer_queued_1572_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::dequeue_index_buffer(GeomPrimitive *data)
 */
static PyObject *Dtool_PreparedGraphicsObjects_dequeue_index_buffer_1573(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.dequeue_index_buffer")) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::dequeue_index_buffer(GeomPrimitive *data)
  GeomPrimitive *arg_this = (GeomPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomPrimitive, 1, "PreparedGraphicsObjects.dequeue_index_buffer", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).dequeue_index_buffer)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dequeue_index_buffer(const PreparedGraphicsObjects self, GeomPrimitive data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_dequeue_index_buffer_1573_comment =
  "C++ Interface:\n"
  "dequeue_index_buffer(const PreparedGraphicsObjects self, GeomPrimitive data)\n"
  "\n"
  "/**\n"
  " * Removes a buffer from the queued list of data arrays to be prepared.\n"
  " * Normally it is not necessary to call this, unless you change your mind\n"
  " * about preparing it at the last minute, since the data will automatically be\n"
  " * dequeued and prepared at the next frame.\n"
  " *\n"
  " * The return value is true if the buffer is successfully dequeued, false if\n"
  " * it had not been queued.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_dequeue_index_buffer_1573_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_index_buffer_prepared(GeomPrimitive const *data) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_index_buffer_prepared_1574(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_index_buffer_prepared(GeomPrimitive const *data) const
  GeomPrimitive const *arg_this = (GeomPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomPrimitive, 1, "PreparedGraphicsObjects.is_index_buffer_prepared", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_index_buffer_prepared)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_index_buffer_prepared(PreparedGraphicsObjects self, const GeomPrimitive data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_index_buffer_prepared_1574_comment =
  "C++ Interface:\n"
  "is_index_buffer_prepared(PreparedGraphicsObjects self, const GeomPrimitive data)\n"
  "\n"
  "/**\n"
  " * Returns true if the index buffer has been prepared on this GSG, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_index_buffer_prepared_1574_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::release_index_buffer(IndexBufferContext *ibc)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_index_buffer_1575(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_index_buffer")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::release_index_buffer(IndexBufferContext *ibc)
  IndexBufferContext *arg_this = (IndexBufferContext *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_IndexBufferContext, 1, "PreparedGraphicsObjects.release_index_buffer", false, true);
  if (arg_this != nullptr) {
    ((*local_this).release_index_buffer)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_index_buffer(const PreparedGraphicsObjects self, IndexBufferContext ibc)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_index_buffer_1575_comment =
  "C++ Interface:\n"
  "release_index_buffer(const PreparedGraphicsObjects self, IndexBufferContext ibc)\n"
  "\n"
  "/**\n"
  " * Indicates that a data context, created by a previous call to\n"
  " * prepare_index_buffer(), is no longer needed.  The driver resources will not\n"
  " * be freed until some GSG calls update(), indicating it is at a stage where\n"
  " * it is ready to release datas--this prevents conflicts from threading or\n"
  " * multiple GSG's sharing datas (we have no way of knowing which graphics\n"
  " * context is currently active, or what state it's in, at the time\n"
  " * release_index_buffer is called).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_index_buffer_1575_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::release_all_index_buffers(void)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_all_index_buffers_1576(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_all_index_buffers")) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::release_all_index_buffers(void)
  int return_value = ((*local_this).release_all_index_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_all_index_buffers_1576_comment =
  "C++ Interface:\n"
  "release_all_index_buffers(const PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Releases all datas at once.  This will force them to be reloaded into data\n"
  " * memory for all GSG's that share this object.  Returns the number of datas\n"
  " * released.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_all_index_buffers_1576_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_queued_index_buffers(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_queued_index_buffers_1577(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_queued_index_buffers(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_queued_index_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_index_buffers_1577_comment =
  "C++ Interface:\n"
  "get_num_queued_index_buffers(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of index buffers that have been enqueued to be prepared\n"
  " * on this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_index_buffers_1577_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_prepared_index_buffers(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_prepared_index_buffers_1578(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_prepared_index_buffers(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_prepared_index_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_index_buffers_1578_comment =
  "C++ Interface:\n"
  "get_num_prepared_index_buffers(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of index buffers that have already been prepared on this\n"
  " * GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_index_buffers_1578_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * IndexBufferContext *PreparedGraphicsObjects::prepare_index_buffer_now(GeomPrimitive *data, GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_PreparedGraphicsObjects_prepare_index_buffer_now_1579(PyObject *self, PyObject *args, PyObject *kwds) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.prepare_index_buffer_now")) {
    return nullptr;
  }
  // 1-IndexBufferContext *PreparedGraphicsObjects::prepare_index_buffer_now(GeomPrimitive *data, GraphicsStateGuardianBase *gsg)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"data", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:prepare_index_buffer_now", (char **)keyword_list, &param1, &param2)) {
    GeomPrimitive *param1_this = (GeomPrimitive *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GeomPrimitive, 1, "PreparedGraphicsObjects.prepare_index_buffer_now", false, true);
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "PreparedGraphicsObjects.prepare_index_buffer_now", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      IndexBufferContext *return_value = ((*local_this).prepare_index_buffer_now)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_IndexBufferContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_index_buffer_now(const PreparedGraphicsObjects self, GeomPrimitive data, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_prepare_index_buffer_now_1579_comment =
  "C++ Interface:\n"
  "prepare_index_buffer_now(const PreparedGraphicsObjects self, GeomPrimitive data, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Immediately creates a new IndexBufferContext for the indicated data and\n"
  " * returns it.  This assumes that the GraphicsStateGuardian is the currently\n"
  " * active rendering context and that it is ready to accept new datas.  If this\n"
  " * is not necessarily the case, you should use enqueue_index_buffer() instead.\n"
  " *\n"
  " * Normally, this function is not called directly.  Call Data::prepare_now()\n"
  " * instead.\n"
  " *\n"
  " * The IndexBufferContext contains all of the pertinent information needed by\n"
  " * the GSG to keep track of this one particular data, and will exist as long\n"
  " * as the data is ready to be rendered.\n"
  " *\n"
  " * When either the Data or the PreparedGraphicsObjects object destructs, the\n"
  " * IndexBufferContext will be deleted.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_prepare_index_buffer_now_1579_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::enqueue_shader_buffer(ShaderBuffer *data)
 */
static PyObject *Dtool_PreparedGraphicsObjects_enqueue_shader_buffer_1580(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.enqueue_shader_buffer")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::enqueue_shader_buffer(ShaderBuffer *data)
  ShaderBuffer *arg_this = (ShaderBuffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShaderBuffer, 1, "PreparedGraphicsObjects.enqueue_shader_buffer", false, true);
  if (arg_this != nullptr) {
    ((*local_this).enqueue_shader_buffer)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enqueue_shader_buffer(const PreparedGraphicsObjects self, ShaderBuffer data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_enqueue_shader_buffer_1580_comment =
  "C++ Interface:\n"
  "enqueue_shader_buffer(const PreparedGraphicsObjects self, ShaderBuffer data)\n"
  "\n"
  "/**\n"
  " * Indicates that a buffer would like to be put on the list to be prepared\n"
  " * when the GSG is next ready to do this (presumably at the next frame).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_enqueue_shader_buffer_1580_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_shader_buffer_queued(ShaderBuffer const *data) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_shader_buffer_queued_1581(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_shader_buffer_queued(ShaderBuffer const *data) const
  ShaderBuffer const *arg_this = (ShaderBuffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShaderBuffer, 1, "PreparedGraphicsObjects.is_shader_buffer_queued", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_shader_buffer_queued)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_shader_buffer_queued(PreparedGraphicsObjects self, const ShaderBuffer data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_shader_buffer_queued_1581_comment =
  "C++ Interface:\n"
  "is_shader_buffer_queued(PreparedGraphicsObjects self, const ShaderBuffer data)\n"
  "\n"
  "/**\n"
  " * Returns true if the index buffer has been queued on this GSG, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_shader_buffer_queued_1581_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::dequeue_shader_buffer(ShaderBuffer *data)
 */
static PyObject *Dtool_PreparedGraphicsObjects_dequeue_shader_buffer_1582(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.dequeue_shader_buffer")) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::dequeue_shader_buffer(ShaderBuffer *data)
  ShaderBuffer *arg_this = (ShaderBuffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShaderBuffer, 1, "PreparedGraphicsObjects.dequeue_shader_buffer", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).dequeue_shader_buffer)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dequeue_shader_buffer(const PreparedGraphicsObjects self, ShaderBuffer data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_dequeue_shader_buffer_1582_comment =
  "C++ Interface:\n"
  "dequeue_shader_buffer(const PreparedGraphicsObjects self, ShaderBuffer data)\n"
  "\n"
  "/**\n"
  " * Removes a buffer from the queued list of data arrays to be prepared.\n"
  " * Normally it is not necessary to call this, unless you change your mind\n"
  " * about preparing it at the last minute, since the data will automatically be\n"
  " * dequeued and prepared at the next frame.\n"
  " *\n"
  " * The return value is true if the buffer is successfully dequeued, false if\n"
  " * it had not been queued.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_dequeue_shader_buffer_1582_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PreparedGraphicsObjects::is_shader_buffer_prepared(ShaderBuffer const *data) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_is_shader_buffer_prepared_1583(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-bool PreparedGraphicsObjects::is_shader_buffer_prepared(ShaderBuffer const *data) const
  ShaderBuffer const *arg_this = (ShaderBuffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShaderBuffer, 1, "PreparedGraphicsObjects.is_shader_buffer_prepared", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PreparedGraphicsObjects*)local_this).is_shader_buffer_prepared)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_shader_buffer_prepared(PreparedGraphicsObjects self, const ShaderBuffer data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_is_shader_buffer_prepared_1583_comment =
  "C++ Interface:\n"
  "is_shader_buffer_prepared(PreparedGraphicsObjects self, const ShaderBuffer data)\n"
  "\n"
  "/**\n"
  " * Returns true if the index buffer has been prepared on this GSG, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_is_shader_buffer_prepared_1583_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PreparedGraphicsObjects::release_shader_buffer(BufferContext *bc)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_shader_buffer_1584(PyObject *self, PyObject *arg) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_shader_buffer")) {
    return nullptr;
  }
  // 1-void PreparedGraphicsObjects::release_shader_buffer(BufferContext *bc)
  BufferContext *arg_this = (BufferContext *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BufferContext, 1, "PreparedGraphicsObjects.release_shader_buffer", false, true);
  if (arg_this != nullptr) {
    ((*local_this).release_shader_buffer)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_shader_buffer(const PreparedGraphicsObjects self, BufferContext bc)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_shader_buffer_1584_comment =
  "C++ Interface:\n"
  "release_shader_buffer(const PreparedGraphicsObjects self, BufferContext bc)\n"
  "\n"
  "/**\n"
  " * Indicates that a data context, created by a previous call to\n"
  " * prepare_shader_buffer(), is no longer needed.  The driver resources will not\n"
  " * be freed until some GSG calls update(), indicating it is at a stage where\n"
  " * it is ready to release datas--this prevents conflicts from threading or\n"
  " * multiple GSG's sharing datas (we have no way of knowing which graphics\n"
  " * context is currently active, or what state it's in, at the time\n"
  " * release_shader_buffer is called).\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_shader_buffer_1584_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::release_all_shader_buffers(void)
 */
static PyObject *Dtool_PreparedGraphicsObjects_release_all_shader_buffers_1585(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.release_all_shader_buffers")) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::release_all_shader_buffers(void)
  int return_value = ((*local_this).release_all_shader_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_release_all_shader_buffers_1585_comment =
  "C++ Interface:\n"
  "release_all_shader_buffers(const PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Releases all datas at once.  This will force them to be reloaded into data\n"
  " * memory for all GSG's that share this object.  Returns the number of datas\n"
  " * released.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_release_all_shader_buffers_1585_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_queued_shader_buffers(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_queued_shader_buffers_1586(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_queued_shader_buffers(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_queued_shader_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_shader_buffers_1586_comment =
  "C++ Interface:\n"
  "get_num_queued_shader_buffers(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of index buffers that have been enqueued to be prepared\n"
  " * on this GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_queued_shader_buffers_1586_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PreparedGraphicsObjects::get_num_prepared_shader_buffers(void) const
 */
static PyObject *Dtool_PreparedGraphicsObjects_get_num_prepared_shader_buffers_1587(PyObject *self, PyObject *) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PreparedGraphicsObjects)) {
    return nullptr;
  }
  // 1-int PreparedGraphicsObjects::get_num_prepared_shader_buffers(void) const
  int return_value = ((*(const PreparedGraphicsObjects*)local_this).get_num_prepared_shader_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_shader_buffers_1587_comment =
  "C++ Interface:\n"
  "get_num_prepared_shader_buffers(PreparedGraphicsObjects self)\n"
  "\n"
  "/**\n"
  " * Returns the number of index buffers that have already been prepared on this\n"
  " * GSG.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_get_num_prepared_shader_buffers_1587_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BufferContext *PreparedGraphicsObjects::prepare_shader_buffer_now(ShaderBuffer *data, GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_PreparedGraphicsObjects_prepare_shader_buffer_now_1588(PyObject *self, PyObject *args, PyObject *kwds) {
  PreparedGraphicsObjects *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PreparedGraphicsObjects, (void **)&local_this, "PreparedGraphicsObjects.prepare_shader_buffer_now")) {
    return nullptr;
  }
  // 1-BufferContext *PreparedGraphicsObjects::prepare_shader_buffer_now(ShaderBuffer *data, GraphicsStateGuardianBase *gsg)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"data", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:prepare_shader_buffer_now", (char **)keyword_list, &param1, &param2)) {
    ShaderBuffer *param1_this = (ShaderBuffer *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ShaderBuffer, 1, "PreparedGraphicsObjects.prepare_shader_buffer_now", false, true);
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "PreparedGraphicsObjects.prepare_shader_buffer_now", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      BufferContext *return_value = ((*local_this).prepare_shader_buffer_now)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BufferContext, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_shader_buffer_now(const PreparedGraphicsObjects self, ShaderBuffer data, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PreparedGraphicsObjects_prepare_shader_buffer_now_1588_comment =
  "C++ Interface:\n"
  "prepare_shader_buffer_now(const PreparedGraphicsObjects self, ShaderBuffer data, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Immediately creates a new BufferContext for the indicated data and\n"
  " * returns it.  This assumes that the GraphicsStateGuardian is the currently\n"
  " * active rendering context and that it is ready to accept new datas.  If this\n"
  " * is not necessarily the case, you should use enqueue_shader_buffer() instead.\n"
  " *\n"
  " * Normally, this function is not called directly.  Call Data::prepare_now()\n"
  " * instead.\n"
  " *\n"
  " * The BufferContext contains all of the pertinent information needed by\n"
  " * the GSG to keep track of this one particular data, and will exist as long\n"
  " * as the data is ready to be rendered.\n"
  " *\n"
  " * When either the Data or the PreparedGraphicsObjects object destructs, the\n"
  " * BufferContext will be deleted.\n"
  " */";
#else
static const char *Dtool_PreparedGraphicsObjects_prepare_shader_buffer_now_1588_comment = nullptr;
#endif

static int Dtool_Init_PreparedGraphicsObjects(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PreparedGraphicsObjects(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PreparedGraphicsObjects) {
    printf("PreparedGraphicsObjects ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PreparedGraphicsObjects *local_this = (PreparedGraphicsObjects *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PreparedGraphicsObjects) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PreparedGraphicsObjects(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PreparedGraphicsObjects) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PreparedGraphicsObjects*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class IndexBufferContext
 */
/**
 * Python function wrapper for:
 * inline GeomPrimitive *IndexBufferContext::get_data(void) const
 */
static PyObject *Dtool_IndexBufferContext_get_data_1594(PyObject *self, PyObject *) {
  IndexBufferContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_IndexBufferContext)) {
    return nullptr;
  }
  // 1-inline GeomPrimitive *IndexBufferContext::get_data(void) const
  GeomPrimitive *return_value = ((*(const IndexBufferContext*)local_this).get_data)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomPrimitive, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_IndexBufferContext_get_data_1594_comment =
  "C++ Interface:\n"
  "get_data(IndexBufferContext self)\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the client-side array data object.\n"
  " */";
#else
static const char *Dtool_IndexBufferContext_get_data_1594_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle IndexBufferContext::get_class_type(void)
 */
static PyObject *Dtool_IndexBufferContext_get_class_type_1598(PyObject *, PyObject *) {
  // 1-static TypeHandle IndexBufferContext::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((IndexBufferContext::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_IndexBufferContext_get_class_type_1598_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_IndexBufferContext_get_class_type_1598_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BufferContext *IndexBufferContext::upcast_to_BufferContext(void)
 */
static PyObject *Dtool_IndexBufferContext_upcast_to_BufferContext_1590(PyObject *self, PyObject *) {
  IndexBufferContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IndexBufferContext, (void **)&local_this, "IndexBufferContext.upcast_to_BufferContext")) {
    return nullptr;
  }
  // 1-BufferContext *IndexBufferContext::upcast_to_BufferContext(void)
  BufferContext *return_value = (BufferContext *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BufferContext, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_IndexBufferContext_upcast_to_BufferContext_1590_comment =
  "C++ Interface:\n"
  "upcast_to_BufferContext(const IndexBufferContext self)\n"
  "\n"
  "upcast from IndexBufferContext to BufferContext";
#else
static const char *Dtool_IndexBufferContext_upcast_to_BufferContext_1590_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AdaptiveLruPage *IndexBufferContext::upcast_to_AdaptiveLruPage(void)
 */
static PyObject *Dtool_IndexBufferContext_upcast_to_AdaptiveLruPage_1592(PyObject *self, PyObject *) {
  IndexBufferContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IndexBufferContext, (void **)&local_this, "IndexBufferContext.upcast_to_AdaptiveLruPage")) {
    return nullptr;
  }
  // 1-AdaptiveLruPage *IndexBufferContext::upcast_to_AdaptiveLruPage(void)
  AdaptiveLruPage *return_value = (AdaptiveLruPage *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AdaptiveLruPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_IndexBufferContext_upcast_to_AdaptiveLruPage_1592_comment =
  "C++ Interface:\n"
  "upcast_to_AdaptiveLruPage(const IndexBufferContext self)\n"
  "\n"
  "upcast from IndexBufferContext to AdaptiveLruPage";
#else
static const char *Dtool_IndexBufferContext_upcast_to_AdaptiveLruPage_1592_comment = nullptr;
#endif

static int Dtool_Init_IndexBufferContext(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_IndexBufferContext(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_IndexBufferContext) {
    printf("IndexBufferContext ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  IndexBufferContext *local_this = (IndexBufferContext *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_IndexBufferContext) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AdaptiveLruPage) {
    return (AdaptiveLruPage *) local_this;
  }
  if (requested_type == Dtool_Ptr_BufferContext) {
    return (BufferContext *) local_this;
  }
  if (requested_type == Dtool_Ptr_SavedContext) {
    return (SavedContext *)(BufferContext *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(SavedContext *)(BufferContext *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_IndexBufferContext(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_IndexBufferContext) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AdaptiveLruPage) {
    AdaptiveLruPage* other_this = (AdaptiveLruPage*)from_this;
    return (IndexBufferContext*)other_this;
  }
  if (from_type == Dtool_Ptr_BufferContext) {
    BufferContext* other_this = (BufferContext*)from_this;
    return (IndexBufferContext*)other_this;
  }
  if (from_type == Dtool_Ptr_SavedContext) {
    SavedContext* other_this = (SavedContext*)from_this;
    return (IndexBufferContext*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (IndexBufferContext*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Lens
 */
/**
 * Python function wrapper for:
 * virtual PointerTo< Lens > Lens::make_copy(void) const = 0
 */
static PyObject *Dtool_Lens_make_copy_1602(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-virtual PointerTo< Lens > Lens::make_copy(void) const = 0
  PointerTo< Lens > return_value = ((*(const Lens*)local_this).make_copy)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Lens *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Lens, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Lens_make_copy_1602_comment =
  "C++ Interface:\n"
  "make_copy(Lens self)\n";
#else
static const char *Dtool_Lens_make_copy_1602_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Lens::extrude(LPoint2 const &point2d, LPoint3 &near_point, LPoint3 &far_point) const
 * inline bool Lens::extrude(LPoint3 const &point2d, LPoint3 &near_point, LPoint3 &far_point) const
 */
static PyObject *Dtool_Lens_extrude_1603(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  {
    // -2 inline bool Lens::extrude(LPoint2 const &point2d, LPoint3 &near_point, LPoint3 &far_point) const
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    static const char *keyword_list[] = {"point2d", "near_point", "far_point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:extrude", (char **)keyword_list, &param1, &param2, &param3)) {
      LPoint2 const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint2f);
      LPoint3 *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LPoint3f, 2, "Lens.extrude", false, false);
      LPoint3 *param3_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LPoint3f, 3, "Lens.extrude", false, false);
      if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
        bool return_value = ((*(const Lens*)local_this).extrude)(*param1_this, *param2_this, *param3_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Lens::extrude(LPoint3 const &point2d, LPoint3 &near_point, LPoint3 &far_point) const
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    static const char *keyword_list[] = {"point2d", "near_point", "far_point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:extrude", (char **)keyword_list, &param1, &param2, &param3)) {
      LPoint3 const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
      LPoint3 *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LPoint3f, 2, "Lens.extrude", false, false);
      LPoint3 *param3_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LPoint3f, 3, "Lens.extrude", false, false);
      if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
        bool return_value = ((*(const Lens*)local_this).extrude)(*param1_this, *param2_this, *param3_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Lens::extrude(LPoint2 const &point2d, LPoint3 &near_point, LPoint3 &far_point) const
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    static const char *keyword_list[] = {"point2d", "near_point", "far_point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:extrude", (char **)keyword_list, &param1, &param2, &param3)) {
      LPoint2f param1_local;
      LPoint2 const *param1_this = Dtool_Coerce_LPoint2f(param1, param1_local);
      LPoint3f param2_local;
      LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
      LPoint3f param3_local;
      LPoint3 *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
      if ((param1_this != nullptr) && (param2_this != nullptr) && (param3_this != nullptr)) {
        bool return_value = ((*(const Lens*)local_this).extrude)(*param1_this, *param2_this, *param3_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Lens::extrude(LPoint3 const &point2d, LPoint3 &near_point, LPoint3 &far_point) const
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    static const char *keyword_list[] = {"point2d", "near_point", "far_point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:extrude", (char **)keyword_list, &param1, &param2, &param3)) {
      LPoint3f param1_local;
      LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
      LPoint3f param2_local;
      LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
      LPoint3f param3_local;
      LPoint3 *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
      if ((param1_this != nullptr) && (param2_this != nullptr) && (param3_this != nullptr)) {
        bool return_value = ((*(const Lens*)local_this).extrude)(*param1_this, *param2_this, *param3_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extrude(Lens self, const LPoint2f point2d, LPoint3f near_point, LPoint3f far_point)\n"
      "extrude(Lens self, const LPoint3f point2d, LPoint3f near_point, LPoint3f far_point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_extrude_1603_comment =
  "C++ Interface:\n"
  "extrude(Lens self, const LPoint2f point2d, LPoint3f near_point, LPoint3f far_point)\n"
  "extrude(Lens self, const LPoint3f point2d, LPoint3f near_point, LPoint3f far_point)\n"
  "\n"
  "/**\n"
  " * Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is\n"
  " * the center of the lens and (-1,-1) is the lower-left corner, compute the\n"
  " * corresponding vector in space that maps to this point, if such a vector can\n"
  " * be determined.  The vector is returned by indicating the points on the near\n"
  " * plane and far plane that both map to the indicated 2-d point.\n"
  " *\n"
  " * Returns true if the vector is defined, or false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is\n"
  " * the center of the lens and (-1,-1) is the lower-left corner, compute the\n"
  " * corresponding vector in space that maps to this point, if such a vector can\n"
  " * be determined.  The vector is returned by indicating the points on the near\n"
  " * plane and far plane that both map to the indicated 2-d point.\n"
  " *\n"
  " * The z coordinate of the 2-d point is ignored.\n"
  " *\n"
  " * Returns true if the vector is defined, or false otherwise.\n"
  " */";
#else
static const char *Dtool_Lens_extrude_1603_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Lens::extrude_depth(LPoint3 const &point2d, LPoint3 &point3d) const
 */
static PyObject *Dtool_Lens_extrude_depth_1604(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline bool Lens::extrude_depth(LPoint3 const &point2d, LPoint3 &point3d) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"point2d", "point3d", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:extrude_depth", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Lens.extrude_depth", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Lens.extrude_depth", "LPoint3f");
    }
    bool return_value = ((*(const Lens*)local_this).extrude_depth)(*param1_this, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extrude_depth(Lens self, const LPoint3f point2d, LPoint3f point3d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_extrude_depth_1604_comment =
  "C++ Interface:\n"
  "extrude_depth(Lens self, const LPoint3f point2d, LPoint3f point3d)\n"
  "\n"
  "/**\n"
  " * Uses the depth component of the 3-d result from project() to compute the\n"
  " * original point in 3-d space corresponding to a particular point on the\n"
  " * lens.  This exactly reverses project(), assuming the point does fall\n"
  " * legitimately within the lens.\n"
  " */";
#else
static const char *Dtool_Lens_extrude_depth_1604_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Lens::extrude_vec(LPoint2 const &point2d, LVector3 &vec3d) const
 * inline bool Lens::extrude_vec(LPoint3 const &point2d, LVector3 &vec3d) const
 */
static PyObject *Dtool_Lens_extrude_vec_1605(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  {
    // -2 inline bool Lens::extrude_vec(LPoint2 const &point2d, LVector3 &vec3d) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point2d", "vec3d", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:extrude_vec", (char **)keyword_list, &param1, &param2)) {
      LPoint2 const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint2f);
      LVector3 *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVector3f, 2, "Lens.extrude_vec", false, false);
      if (param1_this != nullptr && param2_this != nullptr) {
        bool return_value = ((*(const Lens*)local_this).extrude_vec)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Lens::extrude_vec(LPoint3 const &point2d, LVector3 &vec3d) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point2d", "vec3d", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:extrude_vec", (char **)keyword_list, &param1, &param2)) {
      LPoint3 const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
      LVector3 *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVector3f, 2, "Lens.extrude_vec", false, false);
      if (param1_this != nullptr && param2_this != nullptr) {
        bool return_value = ((*(const Lens*)local_this).extrude_vec)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Lens::extrude_vec(LPoint2 const &point2d, LVector3 &vec3d) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point2d", "vec3d", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:extrude_vec", (char **)keyword_list, &param1, &param2)) {
      LPoint2f param1_local;
      LPoint2 const *param1_this = Dtool_Coerce_LPoint2f(param1, param1_local);
      LVector3f param2_local;
      LVector3 *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
      if ((param1_this != nullptr) && (param2_this != nullptr)) {
        bool return_value = ((*(const Lens*)local_this).extrude_vec)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Lens::extrude_vec(LPoint3 const &point2d, LVector3 &vec3d) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point2d", "vec3d", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:extrude_vec", (char **)keyword_list, &param1, &param2)) {
      LPoint3f param1_local;
      LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
      LVector3f param2_local;
      LVector3 *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
      if ((param1_this != nullptr) && (param2_this != nullptr)) {
        bool return_value = ((*(const Lens*)local_this).extrude_vec)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extrude_vec(Lens self, const LPoint2f point2d, LVector3f vec3d)\n"
      "extrude_vec(Lens self, const LPoint3f point2d, LVector3f vec3d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_extrude_vec_1605_comment =
  "C++ Interface:\n"
  "extrude_vec(Lens self, const LPoint2f point2d, LVector3f vec3d)\n"
  "extrude_vec(Lens self, const LPoint3f point2d, LVector3f vec3d)\n"
  "\n"
  "/**\n"
  " * Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is\n"
  " * the center of the lens and (-1,-1) is the lower-left corner, compute the\n"
  " * vector that corresponds to the view direction.  This will be parallel to\n"
  " * the normal on the surface (the far plane) corresponding to the lens shape\n"
  " * at this point.\n"
  " *\n"
  " * See the comment block on Lens::extrude_vec_impl() for a more in-depth\n"
  " * comment on the meaning of this vector.\n"
  " *\n"
  " * Returns true if the vector is defined, or false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is\n"
  " * the center of the lens and (-1,-1) is the lower-left corner, compute the\n"
  " * vector that corresponds to the view direction.  This will be parallel to\n"
  " * the normal on the surface (the far plane) corresponding to the lens shape\n"
  " * at this point.\n"
  " *\n"
  " * See the comment block on Lens::extrude_vec_impl() for a more in-depth\n"
  " * comment on the meaning of this vector.\n"
  " *\n"
  " * The z coordinate of the 2-d point is ignored.\n"
  " *\n"
  " * Returns true if the vector is defined, or false otherwise.\n"
  " */";
#else
static const char *Dtool_Lens_extrude_vec_1605_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Lens::project(LPoint3 const &point3d, LPoint2 &point2d) const
 * inline bool Lens::project(LPoint3 const &point3d, LPoint3 &point2d) const
 */
static PyObject *Dtool_Lens_project_1606(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  {
    // -2 inline bool Lens::project(LPoint3 const &point3d, LPoint2 &point2d) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point3d", "point2d", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:project", (char **)keyword_list, &param1, &param2)) {
      LPoint3 const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
      LPoint2 *param2_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LPoint2f, 2, "Lens.project", false, false);
      if (param1_this != nullptr && param2_this != nullptr) {
        bool return_value = ((*(const Lens*)local_this).project)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Lens::project(LPoint3 const &point3d, LPoint3 &point2d) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point3d", "point2d", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:project", (char **)keyword_list, &param1, &param2)) {
      LPoint3 const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
      LPoint3 *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LPoint3f, 2, "Lens.project", false, false);
      if (param1_this != nullptr && param2_this != nullptr) {
        bool return_value = ((*(const Lens*)local_this).project)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Lens::project(LPoint3 const &point3d, LPoint2 &point2d) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point3d", "point2d", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:project", (char **)keyword_list, &param1, &param2)) {
      LPoint3f param1_local;
      LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
      LPoint2f param2_local;
      LPoint2 *param2_this = Dtool_Coerce_LPoint2f(param2, param2_local);
      if ((param1_this != nullptr) && (param2_this != nullptr)) {
        bool return_value = ((*(const Lens*)local_this).project)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Lens::project(LPoint3 const &point3d, LPoint3 &point2d) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"point3d", "point2d", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:project", (char **)keyword_list, &param1, &param2)) {
      LPoint3f param1_local;
      LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
      LPoint3f param2_local;
      LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
      if ((param1_this != nullptr) && (param2_this != nullptr)) {
        bool return_value = ((*(const Lens*)local_this).project)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(Lens self, const LPoint3f point3d, LPoint2f point2d)\n"
      "project(Lens self, const LPoint3f point3d, LPoint3f point2d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_project_1606_comment =
  "C++ Interface:\n"
  "project(Lens self, const LPoint3f point3d, LPoint2f point2d)\n"
  "project(Lens self, const LPoint3f point3d, LPoint3f point2d)\n"
  "\n"
  "/**\n"
  " * Given a 3-d point in space, determine the 2-d point this maps to, in the\n"
  " * range (-1,1) in both dimensions, where (0,0) is the center of the lens and\n"
  " * (-1,-1) is the lower-left corner.\n"
  " *\n"
  " * Returns true if the 3-d point is in front of the lens and within the\n"
  " * viewing frustum (in which case point2d is filled in), or false otherwise\n"
  " * (in which case point2d will be filled in with something, which may or may\n"
  " * not be meaningful).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Given a 3-d point in space, determine the 2-d point this maps to, in the\n"
  " * range (-1,1) in both dimensions, where (0,0) is the center of the lens and\n"
  " * (-1,-1) is the lower-left corner.\n"
  " *\n"
  " * The z coordinate will also be set to a value in the range (-1, 1), where 1\n"
  " * represents a point on the near plane, and -1 represents a point on the far\n"
  " * plane.\n"
  " *\n"
  " * Returns true if the 3-d point is in front of the lens and within the\n"
  " * viewing frustum (in which case point2d is filled in), or false otherwise\n"
  " * (in which case point2d will be filled in with something, which may or may\n"
  " * not be meaningful).\n"
  " */";
#else
static const char *Dtool_Lens_project_1606_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_change_event(std::string const &event)
 */
static PyObject *Dtool_Lens_set_change_event_1607(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_change_event")) {
    return nullptr;
  }
  // 1-inline void Lens::set_change_event(std::string const &event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_change_event)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_change_event(const Lens self, str event)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_change_event_1607_comment =
  "C++ Interface:\n"
  "set_change_event(const Lens self, str event)\n"
  "\n"
  "/**\n"
  " * Sets the name of the event that will be generated whenever any properties\n"
  " * of the Lens have changed.  If this is not set for a particular lens, no\n"
  " * event will be generated.\n"
  " *\n"
  " * The event is thrown with one parameter, the lens itself.  This can be used\n"
  " * to automatically track changes to camera fov, etc.  in the application.\n"
  " */";
#else
static const char *Dtool_Lens_set_change_event_1607_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Lens::get_change_event(void) const
 */
static PyObject *Dtool_Lens_get_change_event_1608(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline std::string const &Lens::get_change_event(void) const
  std::string const &return_value = ((*(const Lens*)local_this).get_change_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_change_event_1608_comment =
  "C++ Interface:\n"
  "get_change_event(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the event that will be generated whenever any\n"
  " * properties of this particular Lens have changed.\n"
  " */";
#else
static const char *Dtool_Lens_get_change_event_1608_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::set_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_Lens_set_coordinate_system_1610(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_coordinate_system")) {
    return nullptr;
  }
  // 1-void Lens::set_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_coordinate_system)((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const Lens self, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_coordinate_system_1610_comment =
  "C++ Interface:\n"
  "set_coordinate_system(const Lens self, int cs)\n"
  "\n"
  "/**\n"
  " * Specifies the coordinate system that all 3-d computations are performed\n"
  " * within for this Lens.  Normally, this is CS_default.\n"
  " */";
#else
static const char *Dtool_Lens_set_coordinate_system_1610_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem Lens::get_coordinate_system(void) const
 */
static PyObject *Dtool_Lens_get_coordinate_system_1611(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline CoordinateSystem Lens::get_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const Lens*)local_this).get_coordinate_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_coordinate_system_1611_comment =
  "C++ Interface:\n"
  "get_coordinate_system(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system that all 3-d computations are performed\n"
  " * within for this Lens.  Normally, this is CS_default.\n"
  " */";
#else
static const char *Dtool_Lens_get_coordinate_system_1611_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::clear(void)
 */
static PyObject *Dtool_Lens_clear_1614(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.clear")) {
    return nullptr;
  }
  // 1-void Lens::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Lens_clear_1614_comment =
  "C++ Interface:\n"
  "clear(const Lens self)\n"
  "\n"
  "/**\n"
  " * Resets all lens parameters to their initial default settings.\n"
  " */";
#else
static const char *Dtool_Lens_clear_1614_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_film_size(LVecBase2 const &film_size)
 * inline void Lens::set_film_size(PN_stdfloat width)
 * inline void Lens::set_film_size(PN_stdfloat width, PN_stdfloat height)
 */
static PyObject *Dtool_Lens_set_film_size_1615(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_film_size")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline void Lens::set_film_size(LVecBase2 const &film_size)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "film_size")) {
          LVecBase2 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase2f);
          if (param1_this != nullptr) {
            ((*local_this).set_film_size)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 inline void Lens::set_film_size(PN_stdfloat width)
        float param1;
        static const char *keyword_list[] = {"width", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:set_film_size", (char **)keyword_list, &param1)) {
          ((*local_this).set_film_size)((PN_stdfloat)param1);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void Lens::set_film_size(LVecBase2 const &film_size)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "film_size")) {
          LVecBase2f param1_local;
          LVecBase2 const *param1_this = Dtool_Coerce_LVecBase2f(param1, param1_local);
          if ((param1_this != nullptr)) {
            ((*local_this).set_film_size)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

      // No coercion possible: inline void Lens::set_film_size(PN_stdfloat width)
    }
    break;
  case 2:
    {
      // 1-inline void Lens::set_film_size(PN_stdfloat width, PN_stdfloat height)
      float param1;
      float param2;
      static const char *keyword_list[] = {"width", "height", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_film_size", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_film_size)((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_film_size() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_film_size(const Lens self, const LVecBase2f film_size)\n"
      "set_film_size(const Lens self, float width)\n"
      "set_film_size(const Lens self, float width, float height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_film_size_1615_comment =
  "C++ Interface:\n"
  "set_film_size(const Lens self, const LVecBase2f film_size)\n"
  "set_film_size(const Lens self, float width)\n"
  "set_film_size(const Lens self, float width, float height)\n"
  "\n"
  "/**\n"
  " * Sets the horizontal size of the film without changing its shape.  The\n"
  " * aspect ratio remains unchanged; this computes the vertical size of the film\n"
  " * to automatically maintain the aspect ratio.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the size and shape of the \"film\" within the lens.  This both\n"
  " * establishes the units used by calls like set_focal_length(), and\n"
  " * establishes the aspect ratio of the frame.\n"
  " *\n"
  " * In a physical camera, the field of view of a lens is determined by the\n"
  " * lens' focal length and by the size of the film area exposed by the lens.\n"
  " * For instance, a 35mm camera exposes a rectangle on the film about 24mm x\n"
  " * 36mm, which means a 50mm lens gives about a 40-degree horizontal field of\n"
  " * view.\n"
  " *\n"
  " * In the virtual camera, you may set the film size to any units here, and\n"
  " * specify a focal length in the same units to simulate the same effect.  Or,\n"
  " * you may ignore this parameter, and specify the field of view and aspect\n"
  " * ratio of the lens directly.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the size and shape of the \"film\" within the lens.  This both\n"
  " * establishes the units used by calls like set_focal_length(), and\n"
  " * establishes the aspect ratio of the frame.\n"
  " *\n"
  " * In a physical camera, the field of view of a lens is determined by the\n"
  " * lens' focal length and by the size of the film area exposed by the lens.\n"
  " * For instance, a 35mm camera exposes a rectangle on the film about 24mm x\n"
  " * 36mm, which means a 50mm lens gives about a 40-degree horizontal field of\n"
  " * view.\n"
  " *\n"
  " * In the virtual camera, you may set the film size to any units here, and\n"
  " * specify a focal length in the same units to simulate the same effect.  Or,\n"
  " * you may ignore this parameter, and specify the field of view and aspect\n"
  " * ratio of the lens directly.\n"
  " */";
#else
static const char *Dtool_Lens_set_film_size_1615_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 const &Lens::get_film_size(void) const
 */
static PyObject *Dtool_Lens_get_film_size_1616(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LVecBase2 const &Lens::get_film_size(void) const
  LVecBase2 const *return_value = &(((*(const Lens*)local_this).get_film_size)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_film_size_1616_comment =
  "C++ Interface:\n"
  "get_film_size(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the horizontal and vertical film size of the virtual film.  See\n"
  " * set_film_size().\n"
  " */";
#else
static const char *Dtool_Lens_get_film_size_1616_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_film_offset(LVecBase2 const &film_offset)
 * inline void Lens::set_film_offset(PN_stdfloat x, PN_stdfloat y)
 */
static PyObject *Dtool_Lens_set_film_offset_1621(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_film_offset")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "film_offset")) {
        // 1-inline void Lens::set_film_offset(LVecBase2 const &film_offset)
        LVecBase2f arg_local;
        LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "Lens.set_film_offset", "LVecBase2f");
        }
        ((*local_this).set_film_offset)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void Lens::set_film_offset(PN_stdfloat x, PN_stdfloat y)
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_film_offset", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_film_offset)((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_film_offset() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_film_offset(const Lens self, const LVecBase2f film_offset)\n"
      "set_film_offset(const Lens self, float x, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_film_offset_1621_comment =
  "C++ Interface:\n"
  "set_film_offset(const Lens self, const LVecBase2f film_offset)\n"
  "set_film_offset(const Lens self, float x, float y)\n"
  "\n"
  "/**\n"
  " * Sets the horizontal and vertical offset amounts of this Lens.  These are\n"
  " * both in the same units specified in set_film_size().\n"
  " *\n"
  " * This can be used to establish an off-axis lens.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the horizontal and vertical offset amounts of this Lens.  These are\n"
  " * both in the same units specified in set_film_size().\n"
  " *\n"
  " * This can be used to establish an off-axis lens.\n"
  " */";
#else
static const char *Dtool_Lens_set_film_offset_1621_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 const &Lens::get_film_offset(void) const
 */
static PyObject *Dtool_Lens_get_film_offset_1622(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LVector2 const &Lens::get_film_offset(void) const
  LVector2 const *return_value = &(((*(const Lens*)local_this).get_film_offset)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_film_offset_1622_comment =
  "C++ Interface:\n"
  "get_film_offset(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the horizontal and vertical offset amounts of this Lens.  See\n"
  " * set_film_offset().\n"
  " */";
#else
static const char *Dtool_Lens_get_film_offset_1622_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_focal_length(PN_stdfloat focal_length)
 */
static PyObject *Dtool_Lens_set_focal_length_1627(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_focal_length")) {
    return nullptr;
  }
  // 1-inline void Lens::set_focal_length(PN_stdfloat focal_length)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_focal_length)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_focal_length(const Lens self, float focal_length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_focal_length_1627_comment =
  "C++ Interface:\n"
  "set_focal_length(const Lens self, float focal_length)\n"
  "\n"
  "/**\n"
  " * Sets the focal length of the lens.  This may adjust the field-of-view\n"
  " * correspondingly, and is an alternate way to specify field of view.\n"
  " *\n"
  " * For certain kinds of lenses (e.g.  OrthographicLens), the focal length has\n"
  " * no meaning.\n"
  " */";
#else
static const char *Dtool_Lens_set_focal_length_1627_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Lens::get_focal_length(void) const
 */
static PyObject *Dtool_Lens_get_focal_length_1628(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Lens::get_focal_length(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_focal_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_focal_length_1628_comment =
  "C++ Interface:\n"
  "get_focal_length(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the focal length of the lens.  This may have been set explicitly by\n"
  " * a previous call to set_focal_length(), or it may be computed based on the\n"
  " * lens' fov and film_size.  For certain kinds of lenses, the focal length has\n"
  " * no meaning.\n"
  " */";
#else
static const char *Dtool_Lens_get_focal_length_1628_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::set_min_fov(PN_stdfloat min_fov)
 */
static PyObject *Dtool_Lens_set_min_fov_1630(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_min_fov")) {
    return nullptr;
  }
  // 1-void Lens::set_min_fov(PN_stdfloat min_fov)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_min_fov)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_fov(const Lens self, float min_fov)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_min_fov_1630_comment =
  "C++ Interface:\n"
  "set_min_fov(const Lens self, float min_fov)\n"
  "\n"
  "/**\n"
  " * Sets the field of view of the smallest dimension of the window.  If the\n"
  " * window is wider than it is tall, this specifies the vertical field of view;\n"
  " * if it is taller than it is wide, this specifies the horizontal field of\n"
  " * view.\n"
  " *\n"
  " * In many cases, this is preferable to setting either the horizontal or\n"
  " * vertical field of view explicitly.  Setting this parameter means that\n"
  " * pulling the window wider will widen the field of view, which is usually\n"
  " * what you expect to happen.\n"
  " */";
#else
static const char *Dtool_Lens_set_min_fov_1630_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_fov(LVecBase2 const &fov)
 * inline void Lens::set_fov(PN_stdfloat fov)
 * inline void Lens::set_fov(PN_stdfloat hfov, PN_stdfloat vfov)
 */
static PyObject *Dtool_Lens_set_fov_1631(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_fov")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "fov")) {
        {
          // -2 inline void Lens::set_fov(LVecBase2 const &fov)
          LVecBase2 const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2f);
          if (arg_this != nullptr) {
            ((*local_this).set_fov)(*arg_this);
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void Lens::set_fov(PN_stdfloat fov)
          if (PyNumber_Check(arg)) {
            ((*local_this).set_fov)((PN_stdfloat)PyFloat_AsDouble(arg));
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void Lens::set_fov(LVecBase2 const &fov)
          LVecBase2f arg_local;
          LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
          if ((arg_this != nullptr)) {
            ((*local_this).set_fov)(*arg_this);
            return Dtool_Return_None();
          }
        }

        // No coercion possible: inline void Lens::set_fov(PN_stdfloat fov)
      }
    }
    break;
  case 2:
    {
      // 1-inline void Lens::set_fov(PN_stdfloat hfov, PN_stdfloat vfov)
      float param1;
      float param2;
      static const char *keyword_list[] = {"hfov", "vfov", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_fov", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_fov)((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_fov() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fov(const Lens self, const LVecBase2f fov)\n"
      "set_fov(const Lens self, float fov)\n"
      "set_fov(const Lens self, float hfov, float vfov)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_fov_1631_comment =
  "C++ Interface:\n"
  "set_fov(const Lens self, const LVecBase2f fov)\n"
  "set_fov(const Lens self, float fov)\n"
  "set_fov(const Lens self, float hfov, float vfov)\n"
  "\n"
  "/**\n"
  " * Sets the horizontal field of view of the lens without changing the aspect\n"
  " * ratio.  The vertical field of view is adjusted to maintain the same aspect\n"
  " * ratio.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the field of view of the lens in both dimensions.  This establishes\n"
  " * both the field of view and the aspect ratio of the lens.  This is one way\n"
  " * to specify the field of view of a lens; set_focal_length() is another way.\n"
  " *\n"
  " * For certain kinds of lenses (like OrthoLens), the field of view has no\n"
  " * meaning.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the field of view of the lens in both dimensions.  This establishes\n"
  " * both the field of view and the aspect ratio of the lens.  This is one way\n"
  " * to specify the field of view of a lens; set_focal_length() is another way.\n"
  " *\n"
  " * For certain kinds of lenses (like OrthographicLens), the field of view has\n"
  " * no meaning.\n"
  " */";
#else
static const char *Dtool_Lens_set_fov_1631_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 const &Lens::get_fov(void) const
 */
static PyObject *Dtool_Lens_get_fov_1632(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LVecBase2 const &Lens::get_fov(void) const
  LVecBase2 const *return_value = &(((*(const Lens*)local_this).get_fov)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_fov_1632_comment =
  "C++ Interface:\n"
  "get_fov(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the horizontal and vertical film size of the virtual film.  See\n"
  " * set_fov().\n"
  " */";
#else
static const char *Dtool_Lens_get_fov_1632_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Lens::get_hfov(void) const
 */
static PyObject *Dtool_Lens_get_hfov_1633(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Lens::get_hfov(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_hfov)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_hfov_1633_comment =
  "C++ Interface:\n"
  "get_hfov(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the horizontal component of fov only.  See get_fov().\n"
  " */";
#else
static const char *Dtool_Lens_get_hfov_1633_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Lens::get_vfov(void) const
 */
static PyObject *Dtool_Lens_get_vfov_1634(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Lens::get_vfov(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_vfov)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_vfov_1634_comment =
  "C++ Interface:\n"
  "get_vfov(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the vertical component of fov only.  See get_fov().\n"
  " */";
#else
static const char *Dtool_Lens_get_vfov_1634_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Lens::get_min_fov(void) const
 */
static PyObject *Dtool_Lens_get_min_fov_1635(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-PN_stdfloat Lens::get_min_fov(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_min_fov)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_min_fov_1635_comment =
  "C++ Interface:\n"
  "get_min_fov(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the field of view of the narrowest dimension of the window.  See\n"
  " * set_min_fov().\n"
  " */";
#else
static const char *Dtool_Lens_get_min_fov_1635_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_aspect_ratio(PN_stdfloat aspect_ratio)
 */
static PyObject *Dtool_Lens_set_aspect_ratio_1638(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_aspect_ratio")) {
    return nullptr;
  }
  // 1-inline void Lens::set_aspect_ratio(PN_stdfloat aspect_ratio)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_aspect_ratio)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aspect_ratio(const Lens self, float aspect_ratio)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_aspect_ratio_1638_comment =
  "C++ Interface:\n"
  "set_aspect_ratio(const Lens self, float aspect_ratio)\n"
  "\n"
  "/**\n"
  " * Sets the aspect ratio of the lens.  This is the ratio of the height to the\n"
  " * width of the generated image.  Setting this overrides the two-parameter fov\n"
  " * or film size setting.\n"
  " */";
#else
static const char *Dtool_Lens_set_aspect_ratio_1638_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Lens::get_aspect_ratio(void) const
 */
static PyObject *Dtool_Lens_get_aspect_ratio_1639(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Lens::get_aspect_ratio(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_aspect_ratio)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_aspect_ratio_1639_comment =
  "C++ Interface:\n"
  "get_aspect_ratio(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the aspect ratio of the Lens.  This is determined based on the\n"
  " * indicated film size; see set_film_size().\n"
  " */";
#else
static const char *Dtool_Lens_get_aspect_ratio_1639_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_near(PN_stdfloat near_distance)
 */
static PyObject *Dtool_Lens_set_near_1641(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_near")) {
    return nullptr;
  }
  // 1-inline void Lens::set_near(PN_stdfloat near_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_near)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_near(const Lens self, float near_distance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_near_1641_comment =
  "C++ Interface:\n"
  "set_near(const Lens self, float near_distance)\n"
  "\n"
  "/**\n"
  " * Defines the position of the near plane (or cylinder, sphere, whatever).\n"
  " * Points closer to the lens than this may not be rendered.\n"
  " */";
#else
static const char *Dtool_Lens_set_near_1641_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Lens::get_near(void) const
 */
static PyObject *Dtool_Lens_get_near_1642(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Lens::get_near(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_near)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_near_1642_comment =
  "C++ Interface:\n"
  "get_near(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the position of the near plane (or cylinder, sphere, whatever).\n"
  " */";
#else
static const char *Dtool_Lens_get_near_1642_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_far(PN_stdfloat far_distance)
 */
static PyObject *Dtool_Lens_set_far_1643(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_far")) {
    return nullptr;
  }
  // 1-inline void Lens::set_far(PN_stdfloat far_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_far)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_far(const Lens self, float far_distance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_far_1643_comment =
  "C++ Interface:\n"
  "set_far(const Lens self, float far_distance)\n"
  "\n"
  "/**\n"
  " * Defines the position of the far plane (or cylinder, sphere, whatever).\n"
  " * Points farther from the lens than this may not be rendered.\n"
  " */";
#else
static const char *Dtool_Lens_set_far_1643_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Lens::get_far(void) const
 */
static PyObject *Dtool_Lens_get_far_1644(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Lens::get_far(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_far)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_far_1644_comment =
  "C++ Interface:\n"
  "get_far(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the position of the far plane (or cylinder, sphere, whatever).\n"
  " */";
#else
static const char *Dtool_Lens_get_far_1644_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_near_far(PN_stdfloat near_distance, PN_stdfloat far_distance)
 */
static PyObject *Dtool_Lens_set_near_far_1645(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_near_far")) {
    return nullptr;
  }
  // 1-inline void Lens::set_near_far(PN_stdfloat near_distance, PN_stdfloat far_distance)
  float param1;
  float param2;
  static const char *keyword_list[] = {"near_distance", "far_distance", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_near_far", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_near_far)((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_near_far(const Lens self, float near_distance, float far_distance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_near_far_1645_comment =
  "C++ Interface:\n"
  "set_near_far(const Lens self, float near_distance, float far_distance)\n"
  "\n"
  "/**\n"
  " * Simultaneously changes the near and far planes.\n"
  " */";
#else
static const char *Dtool_Lens_set_near_far_1645_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PN_stdfloat Lens::get_default_near(void)
 */
static PyObject *Dtool_Lens_get_default_near_1648(PyObject *, PyObject *) {
  // 1-static PN_stdfloat Lens::get_default_near(void)
  PN_stdfloat return_value = (Lens::get_default_near)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_default_near_1648_comment =
  "C++ Interface:\n"
  "get_default_near()\n"
  "\n"
  "/**\n"
  " * Returns the default near plane distance that will be assigned to each\n"
  " * newly-created lens.  This is read from the Config.prc file.\n"
  " */";
#else
static const char *Dtool_Lens_get_default_near_1648_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PN_stdfloat Lens::get_default_far(void)
 */
static PyObject *Dtool_Lens_get_default_far_1649(PyObject *, PyObject *) {
  // 1-static PN_stdfloat Lens::get_default_far(void)
  PN_stdfloat return_value = (Lens::get_default_far)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_default_far_1649_comment =
  "C++ Interface:\n"
  "get_default_far()\n"
  "\n"
  "/**\n"
  " * Returns the default far plane distance that will be assigned to each newly-\n"
  " * created lens.  This is read from the Config.prc file.\n"
  " */";
#else
static const char *Dtool_Lens_get_default_far_1649_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::set_view_hpr(LVecBase3 const &view_hpr)
 * inline void Lens::set_view_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_Lens_set_view_hpr_1650(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_view_hpr")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "view_hpr")) {
        // 1-void Lens::set_view_hpr(LVecBase3 const &view_hpr)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "Lens.set_view_hpr", "LVecBase3f");
        }
        ((*local_this).set_view_hpr)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void Lens::set_view_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"h", "p", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_view_hpr", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_view_hpr)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_view_hpr() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_view_hpr(const Lens self, const LVecBase3f view_hpr)\n"
      "set_view_hpr(const Lens self, float h, float p, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_view_hpr_1650_comment =
  "C++ Interface:\n"
  "set_view_hpr(const Lens self, const LVecBase3f view_hpr)\n"
  "set_view_hpr(const Lens self, float h, float p, float r)\n"
  "\n"
  "/**\n"
  " * Sets the direction in which the lens is facing.  Normally, this is down the\n"
  " * forward axis (usually the Y axis), but it may be rotated.  This is only one\n"
  " * way of specifying the rotation; you may also specify an explicit vector in\n"
  " * which to look, or you may give a complete transformation matrix.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the direction in which the lens is facing.  Normally, this is down the\n"
  " * forward axis (usually the Y axis), but it may be rotated.  This is only one\n"
  " * way of specifying the rotation; you may also specify an explicit vector in\n"
  " * which to look, or you may give a complete transformation matrix.\n"
  " */";
#else
static const char *Dtool_Lens_set_view_hpr_1650_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 const &Lens::get_view_hpr(void) const
 */
static PyObject *Dtool_Lens_get_view_hpr_1651(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-LVecBase3 const &Lens::get_view_hpr(void) const
  LVecBase3 const *return_value = &(((*(const Lens*)local_this).get_view_hpr)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_view_hpr_1651_comment =
  "C++ Interface:\n"
  "get_view_hpr(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the direction in which the lens is facing.\n"
  " */";
#else
static const char *Dtool_Lens_get_view_hpr_1651_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::set_view_vector(LVector3 const &view_vector, LVector3 const &up_vector)
 * inline void Lens::set_view_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat i, PN_stdfloat j, PN_stdfloat k)
 */
static PyObject *Dtool_Lens_set_view_vector_1656(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_view_vector")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void Lens::set_view_vector(LVector3 const &view_vector, LVector3 const &up_vector)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"view_vector", "up_vector", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_view_vector", (char **)keyword_list, &param1, &param2)) {
        LVector3f param1_local;
        LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Lens.set_view_vector", "LVector3f");
        }
        LVector3f param2_local;
        LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Lens.set_view_vector", "LVector3f");
        }
        ((*local_this).set_view_vector)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void Lens::set_view_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat i, PN_stdfloat j, PN_stdfloat k)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "z", "i", "j", "k", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set_view_vector", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).set_view_vector)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_view_vector() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_view_vector(const Lens self, const LVector3f view_vector, const LVector3f up_vector)\n"
      "set_view_vector(const Lens self, float x, float y, float z, float i, float j, float k)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_view_vector_1656_comment =
  "C++ Interface:\n"
  "set_view_vector(const Lens self, const LVector3f view_vector, const LVector3f up_vector)\n"
  "set_view_vector(const Lens self, float x, float y, float z, float i, float j, float k)\n"
  "\n"
  "/**\n"
  " * Specifies the direction in which the lens is facing by giving an axis to\n"
  " * look along, and a perpendicular (or at least non-parallel) up axis.\n"
  " *\n"
  " * See also set_view_hpr().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies the direction in which the lens is facing by giving an axis to\n"
  " * look along, and a perpendicular (or at least non-parallel) up axis.\n"
  " *\n"
  " * See also set_view_hpr().\n"
  " */";
#else
static const char *Dtool_Lens_set_view_vector_1656_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 const &Lens::get_view_vector(void) const
 */
static PyObject *Dtool_Lens_get_view_vector_1657(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-LVector3 const &Lens::get_view_vector(void) const
  LVector3 const *return_value = &(((*(const Lens*)local_this).get_view_vector)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_view_vector_1657_comment =
  "C++ Interface:\n"
  "get_view_vector(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the axis along which the lens is facing.\n"
  " */";
#else
static const char *Dtool_Lens_get_view_vector_1657_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 const &Lens::get_up_vector(void) const
 */
static PyObject *Dtool_Lens_get_up_vector_1658(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-LVector3 const &Lens::get_up_vector(void) const
  LVector3 const *return_value = &(((*(const Lens*)local_this).get_up_vector)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_up_vector_1658_comment =
  "C++ Interface:\n"
  "get_up_vector(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the axis perpendicular to the camera's view vector that indicates\n"
  " * the \"up\" direction.\n"
  " */";
#else
static const char *Dtool_Lens_get_up_vector_1658_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3 Lens::get_nodal_point(void) const
 */
static PyObject *Dtool_Lens_get_nodal_point_1659(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-LPoint3 Lens::get_nodal_point(void) const
  LPoint3 *return_value = new LPoint3(((*(const Lens*)local_this).get_nodal_point)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_nodal_point_1659_comment =
  "C++ Interface:\n"
  "get_nodal_point(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the center point of the lens: the point from which the lens is\n"
  " * viewing.\n"
  " */";
#else
static const char *Dtool_Lens_get_nodal_point_1659_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_interocular_distance(PN_stdfloat interocular_distance)
 */
static PyObject *Dtool_Lens_set_interocular_distance_1663(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_interocular_distance")) {
    return nullptr;
  }
  // 1-inline void Lens::set_interocular_distance(PN_stdfloat interocular_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_interocular_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_interocular_distance(const Lens self, float interocular_distance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_interocular_distance_1663_comment =
  "C++ Interface:\n"
  "set_interocular_distance(const Lens self, float interocular_distance)\n"
  "\n"
  "/**\n"
  " * Sets the distance between the left and right eyes of a stereo camera.  This\n"
  " * distance is used to apply a stereo effect when the lens is rendered on a\n"
  " * stereo display region.  It only has an effect on a PerspectiveLens.\n"
  " *\n"
  " * The left eye and the right eye are each offset along the X axis by half of\n"
  " * this distance, so that this parameter specifies the total distance between\n"
  " * them.\n"
  " *\n"
  " * Also see set_convergence_distance(), which relates.\n"
  " */";
#else
static const char *Dtool_Lens_set_interocular_distance_1663_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Lens::get_interocular_distance(void) const
 */
static PyObject *Dtool_Lens_get_interocular_distance_1664(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Lens::get_interocular_distance(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_interocular_distance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_interocular_distance_1664_comment =
  "C++ Interface:\n"
  "get_interocular_distance(Lens self)\n"
  "\n"
  "/**\n"
  " * See set_interocular_distance().\n"
  " */";
#else
static const char *Dtool_Lens_get_interocular_distance_1664_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_convergence_distance(PN_stdfloat convergence_distance)
 */
static PyObject *Dtool_Lens_set_convergence_distance_1665(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_convergence_distance")) {
    return nullptr;
  }
  // 1-inline void Lens::set_convergence_distance(PN_stdfloat convergence_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_convergence_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_convergence_distance(const Lens self, float convergence_distance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_convergence_distance_1665_comment =
  "C++ Interface:\n"
  "set_convergence_distance(const Lens self, float convergence_distance)\n"
  "\n"
  "/**\n"
  " * Sets the distance between between the camera plane and the point in the\n"
  " * distance that the left and right eyes are both looking at.  This distance\n"
  " * is used to apply a stereo effect when the lens is rendered on a stereo\n"
  " * display region.  It only has an effect on a PerspectiveLens.\n"
  " *\n"
  " * This parameter must be greater than 0, but may be as large as you like.  It\n"
  " * controls the distance at which the two stereo images will appear to\n"
  " * converge, which is a normal property of stereo vision.  Normally this\n"
  " * should be set to the distance from the camera to the area of interest in\n"
  " * your scene.  Anything beyond this distance will appear to go into the\n"
  " * screen, and anything closer will appear to come out of the screen.  If you\n"
  " * want to simulate parallel stereo, set this to infinity.\n"
  " *\n"
  " * Note that this creates an off-axis frustum, which means that the lenses are\n"
  " * still pointing in the same direction, which is usually more desirable than\n"
  " * the more naive toe-in approach, where the two lenses are simply tilted\n"
  " * toward each other.\n"
  " *\n"
  " * Prior to Panda3D 1.9.0, the convergence was being calculated incorrectly.\n"
  " * It has since been corrected.  To restore the legacy behavior you can set\n"
  " * the stereo-lens-old-convergence variable to true.\n"
  " *\n"
  " * Also see set_interocular_distance(), which relates.\n"
  " */";
#else
static const char *Dtool_Lens_set_convergence_distance_1665_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Lens::get_convergence_distance(void) const
 */
static PyObject *Dtool_Lens_get_convergence_distance_1666(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Lens::get_convergence_distance(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_convergence_distance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_convergence_distance_1666_comment =
  "C++ Interface:\n"
  "get_convergence_distance(Lens self)\n"
  "\n"
  "/**\n"
  " * See set_convergence_distance().\n"
  " */";
#else
static const char *Dtool_Lens_get_convergence_distance_1666_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Lens::set_view_mat(LMatrix4 const &view_mat)
 */
static PyObject *Dtool_Lens_set_view_mat_1669(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_view_mat")) {
    return nullptr;
  }
  // 1-inline void Lens::set_view_mat(LMatrix4 const &view_mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Lens.set_view_mat", "LMatrix4f");
  }
  ((*local_this).set_view_mat)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_view_mat(const Lens self, const LMatrix4f view_mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_view_mat_1669_comment =
  "C++ Interface:\n"
  "set_view_mat(const Lens self, const LMatrix4f view_mat)\n"
  "\n"
  "/**\n"
  " * Sets an arbitrary transformation on the lens.  This replaces the individual\n"
  " * transformation components like set_view_hpr().\n"
  " *\n"
  " * Setting a transformation here will have a slightly different effect than\n"
  " * putting one on the LensNode that contains this lens.  In particular,\n"
  " * lighting and other effects computations will still be performed on the lens\n"
  " * in its untransformed (facing forward) position, but the actual projection\n"
  " * matrix will be transformed by this matrix.\n"
  " */";
#else
static const char *Dtool_Lens_set_view_mat_1669_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &Lens::get_view_mat(void) const
 */
static PyObject *Dtool_Lens_get_view_mat_1670(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &Lens::get_view_mat(void) const
  LMatrix4 const *return_value = &(((*(const Lens*)local_this).get_view_mat)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_view_mat_1670_comment =
  "C++ Interface:\n"
  "get_view_mat(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the direction in which the lens is facing.\n"
  " */";
#else
static const char *Dtool_Lens_get_view_mat_1670_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::clear_view_mat(void)
 */
static PyObject *Dtool_Lens_clear_view_mat_1671(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.clear_view_mat")) {
    return nullptr;
  }
  // 1-void Lens::clear_view_mat(void)
  ((*local_this).clear_view_mat)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Lens_clear_view_mat_1671_comment =
  "C++ Interface:\n"
  "clear_view_mat(const Lens self)\n"
  "\n"
  "/**\n"
  " * Resets the lens transform to identity.\n"
  " */";
#else
static const char *Dtool_Lens_clear_view_mat_1671_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::set_keystone(LVecBase2 const &keystone)
 */
static PyObject *Dtool_Lens_set_keystone_1676(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_keystone")) {
    return nullptr;
  }
  // 1-void Lens::set_keystone(LVecBase2 const &keystone)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Lens.set_keystone", "LVecBase2f");
  }
  ((*local_this).set_keystone)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_keystone(const Lens self, const LVecBase2f keystone)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_keystone_1676_comment =
  "C++ Interface:\n"
  "set_keystone(const Lens self, const LVecBase2f keystone)\n"
  "\n"
  "/**\n"
  " * Indicates the ratio of keystone correction to perform on the lens, in each\n"
  " * of three axes.  This will build a special non-affine scale factor into the\n"
  " * projection matrix that will compensate for keystoning of a projected image;\n"
  " * this can be used to compensate for a projector that for physical reasons\n"
  " * cannot be aimed directly at its screen.\n"
  " *\n"
  " * The default value is taken from the default-keystone Config variable.  0, 0\n"
  " * indicates no keystone correction; specify a small value (usually in the\n"
  " * range -1 .. 1) in either the x or y position to generate a keystone\n"
  " * correction in that axis.\n"
  " */";
#else
static const char *Dtool_Lens_set_keystone_1676_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 const &Lens::get_keystone(void) const
 */
static PyObject *Dtool_Lens_get_keystone_1677(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LVecBase2 const &Lens::get_keystone(void) const
  LVecBase2 const *return_value = &(((*(const Lens*)local_this).get_keystone)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_keystone_1677_comment =
  "C++ Interface:\n"
  "get_keystone(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the keystone correction specified for the lens.\n"
  " */";
#else
static const char *Dtool_Lens_get_keystone_1677_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::clear_keystone(void)
 */
static PyObject *Dtool_Lens_clear_keystone_1678(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.clear_keystone")) {
    return nullptr;
  }
  // 1-void Lens::clear_keystone(void)
  ((*local_this).clear_keystone)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Lens_clear_keystone_1678_comment =
  "C++ Interface:\n"
  "clear_keystone(const Lens self)\n"
  "\n"
  "/**\n"
  " * Disables the lens keystone correction.\n"
  " */";
#else
static const char *Dtool_Lens_clear_keystone_1678_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::set_custom_film_mat(LMatrix4 const &custom_film_mat)
 */
static PyObject *Dtool_Lens_set_custom_film_mat_1680(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_custom_film_mat")) {
    return nullptr;
  }
  // 1-void Lens::set_custom_film_mat(LMatrix4 const &custom_film_mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Lens.set_custom_film_mat", "LMatrix4f");
  }
  ((*local_this).set_custom_film_mat)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_custom_film_mat(const Lens self, const LMatrix4f custom_film_mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_custom_film_mat_1680_comment =
  "C++ Interface:\n"
  "set_custom_film_mat(const Lens self, const LMatrix4f custom_film_mat)\n"
  "\n"
  "/**\n"
  " * Specifies a custom matrix to transform the points on the film after they\n"
  " * have been converted into nominal film space (-1 .. 1 in U and V).  This can\n"
  " * be used to introduce arbitrary scales, rotations, or other linear\n"
  " * transforms to the media plane.  This is normally a 2-d matrix, but a full\n"
  " * 4x4 matrix may be specified.  This is applied on top of any film size, lens\n"
  " * shift, and/or keystone correction.\n"
  " */";
#else
static const char *Dtool_Lens_set_custom_film_mat_1680_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &Lens::get_custom_film_mat(void) const
 */
static PyObject *Dtool_Lens_get_custom_film_mat_1681(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &Lens::get_custom_film_mat(void) const
  LMatrix4 const *return_value = &(((*(const Lens*)local_this).get_custom_film_mat)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_custom_film_mat_1681_comment =
  "C++ Interface:\n"
  "get_custom_film_mat(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the custom_film_mat specified for the lens.\n"
  " */";
#else
static const char *Dtool_Lens_get_custom_film_mat_1681_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::clear_custom_film_mat(void)
 */
static PyObject *Dtool_Lens_clear_custom_film_mat_1682(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.clear_custom_film_mat")) {
    return nullptr;
  }
  // 1-void Lens::clear_custom_film_mat(void)
  ((*local_this).clear_custom_film_mat)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Lens_clear_custom_film_mat_1682_comment =
  "C++ Interface:\n"
  "clear_custom_film_mat(const Lens self)\n"
  "\n"
  "/**\n"
  " * Disables the lens custom_film_mat correction.\n"
  " */";
#else
static const char *Dtool_Lens_clear_custom_film_mat_1682_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::set_frustum_from_corners(LVecBase3 const &ul, LVecBase3 const &ur, LVecBase3 const &ll, LVecBase3 const &lr, int flags)
 */
static PyObject *Dtool_Lens_set_frustum_from_corners_1684(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.set_frustum_from_corners")) {
    return nullptr;
  }
  // 1-void Lens::set_frustum_from_corners(LVecBase3 const &ul, LVecBase3 const &ur, LVecBase3 const &ll, LVecBase3 const &lr, int flags)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  PyObject *param4;
  int param5;
  static const char *keyword_list[] = {"ul", "ur", "ll", "lr", "flags", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:set_frustum_from_corners", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    LVecBase3f param1_local;
    LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Lens.set_frustum_from_corners", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Lens.set_frustum_from_corners", "LVecBase3f");
    }
    LVecBase3f param3_local;
    LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "Lens.set_frustum_from_corners", "LVecBase3f");
    }
    LVecBase3f param4_local;
    LVecBase3 const *param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
    if (!(param4_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "Lens.set_frustum_from_corners", "LVecBase3f");
    }
    ((*local_this).set_frustum_from_corners)(*param1_this, *param2_this, *param3_this, *param4_this, (int)param5);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frustum_from_corners(const Lens self, const LVecBase3f ul, const LVecBase3f ur, const LVecBase3f ll, const LVecBase3f lr, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_set_frustum_from_corners_1684_comment =
  "C++ Interface:\n"
  "set_frustum_from_corners(const Lens self, const LVecBase3f ul, const LVecBase3f ur, const LVecBase3f ll, const LVecBase3f lr, int flags)\n"
  "\n"
  "/**\n"
  " * Sets up the lens to use the frustum defined by the four indicated points.\n"
  " * This is most useful for a PerspectiveLens, but it may be called for other\n"
  " * kinds of lenses as well.\n"
  " *\n"
  " * The frustum will be rooted at the origin (or by whatever translation might\n"
  " * have been specified in a previous call to set_view_mat).\n"
  " *\n"
  " * It is legal for the four points not to be arranged in a rectangle; if this\n"
  " * is the case, the frustum will be fitted as tightly as possible to cover all\n"
  " * four points.\n"
  " *\n"
  " * The flags parameter contains the union of one or more of the following bits\n"
  " * to control the behavior of this function:\n"
  " *\n"
  " * FC_roll - If this is included, the camera may be rotated so that its up\n"
  " * vector is perpendicular to the top line.  Otherwise, the standard up vector\n"
  " * is used.\n"
  " *\n"
  " * FC_camera_plane - This allows the camera plane to be adjusted to be as\n"
  " * nearly perpendicular to the center of the frustum as possible.  Without\n"
  " * this bit, the orientation camera plane is defined by position of the four\n"
  " * points (which should all be coplanar).  With this bit, the camera plane is\n"
  " * arbitarary, and may be chosen so that the four points do not themselves lie\n"
  " * in the camera plane (but the points will still be within the frustum).\n"
  " *\n"
  " * FC_off_axis - This allows the resulting frustum to be off-axis to get the\n"
  " * tightest possible fit.  Without this bit, the viewing axis will be centered\n"
  " * within the frustum, but there may be more wasted space along the edges.\n"
  " *\n"
  " * FC_aspect_ratio - This allows the frustum to be scaled non-proportionately\n"
  " * in the vertical and horizontal dimensions, if necessary, to get a tighter\n"
  " * fit.  Without this bit, the current aspect ratio will be preserved.\n"
  " *\n"
  " * FC_shear - This allows the frustum to be sheared, if necessary, to get the\n"
  " * tightest possible fit.  This may result in a parallelogram-based frustum,\n"
  " * which will give a slanted appearance to the rendered image.  Without this\n"
  " * bit, the frustum will be rectangle-based.\n"
  " *\n"
  " * In general, if 0 is passed in as the value for flags, the generated frustum\n"
  " * will be a loose fit but sane; if -1 is passed in, it will be a tighter fit\n"
  " * and possibly screwy.\n"
  " */";
#else
static const char *Dtool_Lens_set_frustum_from_corners_1684_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lens::recompute_all(void)
 */
static PyObject *Dtool_Lens_recompute_all_1685(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.recompute_all")) {
    return nullptr;
  }
  // 1-void Lens::recompute_all(void)
  ((*local_this).recompute_all)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Lens_recompute_all_1685_comment =
  "C++ Interface:\n"
  "recompute_all(const Lens self)\n"
  "\n"
  "/**\n"
  " * Forces all internal parameters of the Lens to be recomputed.  Normally,\n"
  " * this should never need to be called; it is provided only to assist in\n"
  " * debugging.\n"
  " */";
#else
static const char *Dtool_Lens_recompute_all_1685_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool Lens::is_linear(void) const
 */
static PyObject *Dtool_Lens_is_linear_1686(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-virtual bool Lens::is_linear(void) const
  bool return_value = ((*(const Lens*)local_this).is_linear)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_is_linear_1686_comment =
  "C++ Interface:\n"
  "is_linear(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns true if the lens represents a linear projection (e.g.\n"
  " * PerspectiveLens, OrthographicLens), and therefore there is a valid matrix\n"
  " * returned by get_projection_mat(), or false otherwise.\n"
  " */";
#else
static const char *Dtool_Lens_is_linear_1686_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool Lens::is_perspective(void) const
 */
static PyObject *Dtool_Lens_is_perspective_1687(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-virtual bool Lens::is_perspective(void) const
  bool return_value = ((*(const Lens*)local_this).is_perspective)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_is_perspective_1687_comment =
  "C++ Interface:\n"
  "is_perspective(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns true if the lens represents a perspective projection (i.e.  it is a\n"
  " * PerspectiveLens), false otherwise.\n"
  " */";
#else
static const char *Dtool_Lens_is_perspective_1687_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool Lens::is_orthographic(void) const
 */
static PyObject *Dtool_Lens_is_orthographic_1688(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-virtual bool Lens::is_orthographic(void) const
  bool return_value = ((*(const Lens*)local_this).is_orthographic)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lens_is_orthographic_1688_comment =
  "C++ Interface:\n"
  "is_orthographic(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns true if the lens represents a orthographic projection (i.e.  it is\n"
  " * a OrthographicLens), false otherwise.\n"
  " */";
#else
static const char *Dtool_Lens_is_orthographic_1688_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PointerTo< Geom > Lens::make_geometry(void)
 */
static PyObject *Dtool_Lens_make_geometry_1689(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.make_geometry")) {
    return nullptr;
  }
  // 1-virtual PointerTo< Geom > Lens::make_geometry(void)
  PointerTo< Geom > return_value = ((*local_this).make_geometry)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Geom *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Lens_make_geometry_1689_comment =
  "C++ Interface:\n"
  "make_geometry(const Lens self)\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new Geom that can be rendered to show a visible\n"
  " * representation of the frustum used for this kind of lens, if it makes sense\n"
  " * to do so.  If a visible representation cannot be created, returns NULL.\n"
  " */";
#else
static const char *Dtool_Lens_make_geometry_1689_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PointerTo< BoundingVolume > Lens::make_bounds(void) const
 */
static PyObject *Dtool_Lens_make_bounds_1690(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-virtual PointerTo< BoundingVolume > Lens::make_bounds(void) const
  PointerTo< BoundingVolume > return_value = ((*(const Lens*)local_this).make_bounds)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  BoundingVolume *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Lens_make_bounds_1690_comment =
  "C++ Interface:\n"
  "make_bounds(Lens self)\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new BoundingVolume that encloses the frustum used\n"
  " * for this kind of lens, if possible.  If a suitable bounding volume cannot\n"
  " * be created, returns NULL.\n"
  " */";
#else
static const char *Dtool_Lens_make_bounds_1690_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &Lens::get_projection_mat(Lens::StereoChannel channel = ::Lens::SC_mono) const
 */
static PyObject *Dtool_Lens_get_projection_mat_1691(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &Lens::get_projection_mat(Lens::StereoChannel channel = ::Lens::SC_mono) const
  int param1 = Lens::SC_mono;
  static const char *keyword_list[] = {"channel", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_projection_mat", (char **)keyword_list, &param1)) {
    LMatrix4 const *return_value = &(((*(const Lens*)local_this).get_projection_mat)((Lens::StereoChannel)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_projection_mat(Lens self, int channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_projection_mat_1691_comment =
  "C++ Interface:\n"
  "get_projection_mat(Lens self, int channel)\n"
  "\n"
  "/**\n"
  " * Returns the complete transformation matrix from a 3-d point in space to a\n"
  " * point on the film, if such a matrix exists, or the identity matrix if the\n"
  " * lens is nonlinear.\n"
  " */";
#else
static const char *Dtool_Lens_get_projection_mat_1691_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &Lens::get_projection_mat_inv(Lens::StereoChannel channel = ::Lens::SC_mono) const
 */
static PyObject *Dtool_Lens_get_projection_mat_inv_1692(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &Lens::get_projection_mat_inv(Lens::StereoChannel channel = ::Lens::SC_mono) const
  int param1 = Lens::SC_mono;
  static const char *keyword_list[] = {"channel", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_projection_mat_inv", (char **)keyword_list, &param1)) {
    LMatrix4 const *return_value = &(((*(const Lens*)local_this).get_projection_mat_inv)((Lens::StereoChannel)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_projection_mat_inv(Lens self, int channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_projection_mat_inv_1692_comment =
  "C++ Interface:\n"
  "get_projection_mat_inv(Lens self, int channel)\n"
  "\n"
  "/**\n"
  " * Returns the matrix that transforms from a 2-d point on the film to a 3-d\n"
  " * vector in space, if such a matrix exists.\n"
  " */";
#else
static const char *Dtool_Lens_get_projection_mat_inv_1692_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &Lens::get_film_mat(void) const
 */
static PyObject *Dtool_Lens_get_film_mat_1693(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &Lens::get_film_mat(void) const
  LMatrix4 const *return_value = &(((*(const Lens*)local_this).get_film_mat)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_film_mat_1693_comment =
  "C++ Interface:\n"
  "get_film_mat(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the matrix that transforms from a point behind the lens to a point\n"
  " * on the film.\n"
  " */";
#else
static const char *Dtool_Lens_get_film_mat_1693_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &Lens::get_film_mat_inv(void) const
 */
static PyObject *Dtool_Lens_get_film_mat_inv_1694(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &Lens::get_film_mat_inv(void) const
  LMatrix4 const *return_value = &(((*(const Lens*)local_this).get_film_mat_inv)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_film_mat_inv_1694_comment =
  "C++ Interface:\n"
  "get_film_mat_inv(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the matrix that transforms from a point on the film to a point\n"
  " * behind the lens.\n"
  " */";
#else
static const char *Dtool_Lens_get_film_mat_inv_1694_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &Lens::get_lens_mat(void) const
 */
static PyObject *Dtool_Lens_get_lens_mat_1695(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &Lens::get_lens_mat(void) const
  LMatrix4 const *return_value = &(((*(const Lens*)local_this).get_lens_mat)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_lens_mat_1695_comment =
  "C++ Interface:\n"
  "get_lens_mat(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the matrix that transforms from a point in front of the lens to a\n"
  " * point in space.\n"
  " */";
#else
static const char *Dtool_Lens_get_lens_mat_1695_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &Lens::get_lens_mat_inv(void) const
 */
static PyObject *Dtool_Lens_get_lens_mat_inv_1696(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &Lens::get_lens_mat_inv(void) const
  LMatrix4 const *return_value = &(((*(const Lens*)local_this).get_lens_mat_inv)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_lens_mat_inv_1696_comment =
  "C++ Interface:\n"
  "get_lens_mat_inv(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the matrix that transforms from a point in space to a point in\n"
  " * front of the lens.\n"
  " */";
#else
static const char *Dtool_Lens_get_lens_mat_inv_1696_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Lens::output(std::ostream &out) const
 */
static PyObject *Dtool_Lens_output_1697(PyObject *self, PyObject *arg) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-virtual void Lens::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Lens.output", false, true);
  if (arg_this != nullptr) {
    ((*(const Lens*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Lens self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_output_1697_comment =
  "C++ Interface:\n"
  "output(Lens self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Lens_output_1697_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Lens::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_Lens_write_1698(PyObject *self, PyObject *args, PyObject *kwds) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-virtual void Lens::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Lens.write", false, true);
    if (param1_this != nullptr) {
      ((*(const Lens*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(Lens self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lens_write_1698_comment =
  "C++ Interface:\n"
  "write(Lens self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Lens_write_1698_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq Lens::get_last_change(void) const
 */
static PyObject *Dtool_Lens_get_last_change_1699(PyObject *self, PyObject *) {
  Lens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lens)) {
    return nullptr;
  }
  // 1-inline UpdateSeq Lens::get_last_change(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const Lens*)local_this).get_last_change)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_last_change_1699_comment =
  "C++ Interface:\n"
  "get_last_change(Lens self)\n"
  "\n"
  "/**\n"
  " * Returns the UpdateSeq that is incremented whenever the lens properties are\n"
  " * changed.  As long as this number remains the same, you may assume the lens\n"
  " * properties are unchanged.\n"
  " */";
#else
static const char *Dtool_Lens_get_last_change_1699_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Lens::get_class_type(void)
 */
static PyObject *Dtool_Lens_get_class_type_1700(PyObject *, PyObject *) {
  // 1-static TypeHandle Lens::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Lens::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Lens_get_class_type_1700_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Lens_get_class_type_1700_comment = nullptr;
#endif

static PyObject *Dtool_Lens_change_event_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &Lens::get_change_event(void) const
  std::string const &return_value = ((*(const Lens*)local_this).get_change_event)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Lens_change_event_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.change_event")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete change_event attribute");
    return -1;
  }
  // 1-inline void Lens::set_change_event(std::string const &event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_change_event)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_change_event(const Lens self, str event)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_coordinate_system_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CoordinateSystem Lens::get_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const Lens*)local_this).get_coordinate_system)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Lens_coordinate_system_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.coordinate_system")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete coordinate_system attribute");
    return -1;
  }
  // 1-void Lens::set_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_coordinate_system)((CoordinateSystem)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const Lens self, int cs)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_film_size_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2 const &Lens::get_film_size(void) const
  LVecBase2 const *return_value = &(((*(const Lens*)local_this).get_film_size)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

static int Dtool_Lens_film_size_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.film_size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete film_size attribute");
    return -1;
  }
  {
    // -2 inline void Lens::set_film_size(LVecBase2 const &film_size)
    LVecBase2 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2f);
    if (arg_this != nullptr) {
      ((*local_this).set_film_size)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void Lens::set_film_size(PN_stdfloat width)
    if (PyNumber_Check(arg)) {
      ((*local_this).set_film_size)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void Lens::set_film_size(LVecBase2 const &film_size)
    LVecBase2f arg_local;
    LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_film_size)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  // No coercion possible: inline void Lens::set_film_size(PN_stdfloat width)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_film_size(const Lens self, const LVecBase2f film_size)\n"
      "set_film_size(const Lens self, float width)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_film_offset_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVector2 const &Lens::get_film_offset(void) const
  LVector2 const *return_value = &(((*(const Lens*)local_this).get_film_offset)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, false, true);
}

static int Dtool_Lens_film_offset_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.film_offset")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete film_offset attribute");
    return -1;
  }
  // 1-inline void Lens::set_film_offset(LVecBase2 const &film_offset)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Lens.set_film_offset", "LVecBase2f");
    return -1;
  }
  ((*local_this).set_film_offset)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_film_offset(const Lens self, const LVecBase2f film_offset)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_focal_length_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Lens::get_focal_length(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_focal_length)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Lens_focal_length_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.focal_length")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete focal_length attribute");
    return -1;
  }
  // 1-inline void Lens::set_focal_length(PN_stdfloat focal_length)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_focal_length)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_focal_length(const Lens self, float focal_length)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_fov_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2 const &Lens::get_fov(void) const
  LVecBase2 const *return_value = &(((*(const Lens*)local_this).get_fov)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

static int Dtool_Lens_fov_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.fov")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete fov attribute");
    return -1;
  }
  {
    // -2 inline void Lens::set_fov(LVecBase2 const &fov)
    LVecBase2 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2f);
    if (arg_this != nullptr) {
      ((*local_this).set_fov)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void Lens::set_fov(PN_stdfloat fov)
    if (PyNumber_Check(arg)) {
      ((*local_this).set_fov)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void Lens::set_fov(LVecBase2 const &fov)
    LVecBase2f arg_local;
    LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_fov)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  // No coercion possible: inline void Lens::set_fov(PN_stdfloat fov)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fov(const Lens self, const LVecBase2f fov)\n"
      "set_fov(const Lens self, float fov)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_min_fov_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PN_stdfloat Lens::get_min_fov(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_min_fov)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Lens_min_fov_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.min_fov")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete min_fov attribute");
    return -1;
  }
  // 1-void Lens::set_min_fov(PN_stdfloat min_fov)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_min_fov)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_min_fov(const Lens self, float min_fov)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_aspect_ratio_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Lens::get_aspect_ratio(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_aspect_ratio)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Lens_aspect_ratio_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.aspect_ratio")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete aspect_ratio attribute");
    return -1;
  }
  // 1-inline void Lens::set_aspect_ratio(PN_stdfloat aspect_ratio)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_aspect_ratio)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_aspect_ratio(const Lens self, float aspect_ratio)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_near_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Lens::get_near(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_near)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Lens_near_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.near")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete near attribute");
    return -1;
  }
  // 1-inline void Lens::set_near(PN_stdfloat near_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_near)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_near(const Lens self, float near_distance)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_far_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Lens::get_far(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_far)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Lens_far_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.far")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete far attribute");
    return -1;
  }
  // 1-inline void Lens::set_far(PN_stdfloat far_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_far)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_far(const Lens self, float far_distance)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_view_hpr_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-LVecBase3 const &Lens::get_view_hpr(void) const
  LVecBase3 const *return_value = &(((*(const Lens*)local_this).get_view_hpr)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static int Dtool_Lens_view_hpr_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.view_hpr")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete view_hpr attribute");
    return -1;
  }
  // 1-void Lens::set_view_hpr(LVecBase3 const &view_hpr)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Lens.set_view_hpr", "LVecBase3f");
    return -1;
  }
  ((*local_this).set_view_hpr)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_view_hpr(const Lens self, const LVecBase3f view_hpr)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_nodal_point_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-LPoint3 Lens::get_nodal_point(void) const
  LPoint3 *return_value = new LPoint3(((*(const Lens*)local_this).get_nodal_point)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

static PyObject *Dtool_Lens_interocular_distance_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Lens::get_interocular_distance(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_interocular_distance)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Lens_interocular_distance_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.interocular_distance")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete interocular_distance attribute");
    return -1;
  }
  // 1-inline void Lens::set_interocular_distance(PN_stdfloat interocular_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_interocular_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_interocular_distance(const Lens self, float interocular_distance)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_convergence_distance_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Lens::get_convergence_distance(void) const
  PN_stdfloat return_value = ((*(const Lens*)local_this).get_convergence_distance)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Lens_convergence_distance_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.convergence_distance")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete convergence_distance attribute");
    return -1;
  }
  // 1-inline void Lens::set_convergence_distance(PN_stdfloat convergence_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_convergence_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_convergence_distance(const Lens self, float convergence_distance)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_view_mat_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LMatrix4 const &Lens::get_view_mat(void) const
  LMatrix4 const *return_value = &(((*(const Lens*)local_this).get_view_mat)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

static int Dtool_Lens_view_mat_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.view_mat")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete view_mat attribute");
    return -1;
  }
  // 1-inline void Lens::set_view_mat(LMatrix4 const &view_mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Lens.set_view_mat", "LMatrix4f");
    return -1;
  }
  ((*local_this).set_view_mat)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_view_mat(const Lens self, const LMatrix4f view_mat)\n");
  }
  return -1;
}

static PyObject *Dtool_Lens_keystone_Getter(PyObject *self, void *) {
  const Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2 const &Lens::get_keystone(void) const
  LVecBase2 const *return_value = &(((*(const Lens*)local_this).get_keystone)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

static int Dtool_Lens_keystone_Setter(PyObject *self, PyObject *arg, void *) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lens, (void **)&local_this, "Lens.keystone")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete keystone attribute");
    return -1;
  }
  // 1-void Lens::set_keystone(LVecBase2 const &keystone)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Lens.set_keystone", "LVecBase2f");
    return -1;
  }
  ((*local_this).set_keystone)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_keystone(const Lens self, const LVecBase2f keystone)\n");
  }
  return -1;
}

static int Dtool_Init_Lens(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_Lens(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Lens) {
    printf("Lens ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Lens *local_this = (Lens *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Lens) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Lens(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Lens) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Lens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Lens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Lens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Lens*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Material
 */
/**
 * Python function wrapper for:
 * void Material::operator =(Material const &copy)
 */
static PyObject *Dtool_Material_operator_1708(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.assign")) {
    return nullptr;
  }
  // 1-void Material::operator =(Material const &copy)
  Material const *arg_this = (Material *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Material, 1, "Material.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    Material *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Material, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Material self, const Material copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_operator_1708_comment =
  "C++ Interface:\n"
  "assign(const Material self, const Material copy)\n";
#else
static const char *Dtool_Material_operator_1708_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Material *Material::get_default(void)
 */
static PyObject *Dtool_Material_get_default_1710(PyObject *, PyObject *) {
  // 1-static inline Material *Material::get_default(void)
  Material *return_value = (Material::get_default)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Material, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Material_get_default_1710_comment =
  "C++ Interface:\n"
  "get_default()\n"
  "\n"
  "/**\n"
  " * Returns the default material.\n"
  " */";
#else
static const char *Dtool_Material_get_default_1710_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Material::has_base_color(void) const
 */
static PyObject *Dtool_Material_has_base_color_1711(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline bool Material::has_base_color(void) const
  bool return_value = ((*(const Material*)local_this).has_base_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_has_base_color_1711_comment =
  "C++ Interface:\n"
  "has_base_color(Material self)\n"
  "\n"
  "/**\n"
  " * Returns true if the base color has been explicitly set for this material,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_Material_has_base_color_1711_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &Material::get_base_color(void) const
 */
static PyObject *Dtool_Material_get_base_color_1712(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline LColor const &Material::get_base_color(void) const
  LColor const *return_value = &(((*(const Material*)local_this).get_base_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_base_color_1712_comment =
  "C++ Interface:\n"
  "get_base_color(Material self)\n"
  "\n"
  "/**\n"
  " * Returns the base_color color setting, if it has been set.  If neither the\n"
  " * base color nor the metallic have been set, this returns the diffuse color.\n"
  " */";
#else
static const char *Dtool_Material_get_base_color_1712_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::set_base_color(LColor const &color)
 */
static PyObject *Dtool_Material_set_base_color_1713(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_base_color")) {
    return nullptr;
  }
  // 1-void Material::set_base_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Material.set_base_color", "LVecBase4f");
  }
  ((*local_this).set_base_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_base_color(const Material self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_set_base_color_1713_comment =
  "C++ Interface:\n"
  "set_base_color(const Material self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Specifies the base color of the material.  In conjunction with\n"
  " * set_metallic, this is an alternate way to specify the color of a material.\n"
  " * For dielectrics, this will determine the value of the diffuse color, and\n"
  " * for metals, this will determine the value of the specular color.\n"
  " *\n"
  " * Setting this will clear an explicit specular, diffuse or ambient color\n"
  " * assignment.\n"
  " *\n"
  " * If this is not set, the object color will be used.\n"
  " */";
#else
static const char *Dtool_Material_set_base_color_1713_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::clear_base_color(void)
 */
static PyObject *Dtool_Material_clear_base_color_1714(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.clear_base_color")) {
    return nullptr;
  }
  // 1-void Material::clear_base_color(void)
  ((*local_this).clear_base_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Material_clear_base_color_1714_comment =
  "C++ Interface:\n"
  "clear_base_color(const Material self)\n"
  "\n"
  "/**\n"
  " * Removes the explicit base_color color from the material.\n"
  " */";
#else
static const char *Dtool_Material_clear_base_color_1714_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Material::has_ambient(void) const
 */
static PyObject *Dtool_Material_has_ambient_1715(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline bool Material::has_ambient(void) const
  bool return_value = ((*(const Material*)local_this).has_ambient)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_has_ambient_1715_comment =
  "C++ Interface:\n"
  "has_ambient(Material self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ambient color has been explicitly set for this\n"
  " * material, false otherwise.\n"
  " */";
#else
static const char *Dtool_Material_has_ambient_1715_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &Material::get_ambient(void) const
 */
static PyObject *Dtool_Material_get_ambient_1716(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline LColor const &Material::get_ambient(void) const
  LColor const *return_value = &(((*(const Material*)local_this).get_ambient)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_ambient_1716_comment =
  "C++ Interface:\n"
  "get_ambient(Material self)\n"
  "\n"
  "/**\n"
  " * Returns the ambient color setting, if it has been set.  Returns (0,0,0,0)\n"
  " * if the ambient color has not been set.\n"
  " */";
#else
static const char *Dtool_Material_get_ambient_1716_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::set_ambient(LColor const &color)
 */
static PyObject *Dtool_Material_set_ambient_1717(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_ambient")) {
    return nullptr;
  }
  // 1-void Material::set_ambient(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Material.set_ambient", "LVecBase4f");
  }
  ((*local_this).set_ambient)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ambient(const Material self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_set_ambient_1717_comment =
  "C++ Interface:\n"
  "set_ambient(const Material self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Specifies the ambient color setting of the material.  This will be the\n"
  " * multiplied by any ambient lights in effect on the material to set its base\n"
  " * color.\n"
  " *\n"
  " * This is the color of the object as it appears in the absence of direct\n"
  " * light.\n"
  " *\n"
  " * If this is not set, the object color will be used.\n"
  " */";
#else
static const char *Dtool_Material_set_ambient_1717_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Material::clear_ambient(void)
 */
static PyObject *Dtool_Material_clear_ambient_1718(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.clear_ambient")) {
    return nullptr;
  }
  // 1-inline void Material::clear_ambient(void)
  ((*local_this).clear_ambient)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Material_clear_ambient_1718_comment =
  "C++ Interface:\n"
  "clear_ambient(const Material self)\n"
  "\n"
  "/**\n"
  " * Removes the explicit ambient color from the material.\n"
  " */";
#else
static const char *Dtool_Material_clear_ambient_1718_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Material::has_diffuse(void) const
 */
static PyObject *Dtool_Material_has_diffuse_1719(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline bool Material::has_diffuse(void) const
  bool return_value = ((*(const Material*)local_this).has_diffuse)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_has_diffuse_1719_comment =
  "C++ Interface:\n"
  "has_diffuse(Material self)\n"
  "\n"
  "/**\n"
  " * Returns true if the diffuse color has been explicitly set for this\n"
  " * material, false otherwise.\n"
  " */";
#else
static const char *Dtool_Material_has_diffuse_1719_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &Material::get_diffuse(void) const
 */
static PyObject *Dtool_Material_get_diffuse_1720(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline LColor const &Material::get_diffuse(void) const
  LColor const *return_value = &(((*(const Material*)local_this).get_diffuse)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_diffuse_1720_comment =
  "C++ Interface:\n"
  "get_diffuse(Material self)\n"
  "\n"
  "/**\n"
  " * Returns the diffuse color setting, if it has been set.  Returns (1,1,1,1)\n"
  " * if the diffuse color has not been set.\n"
  " */";
#else
static const char *Dtool_Material_get_diffuse_1720_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::set_diffuse(LColor const &color)
 */
static PyObject *Dtool_Material_set_diffuse_1721(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_diffuse")) {
    return nullptr;
  }
  // 1-void Material::set_diffuse(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Material.set_diffuse", "LVecBase4f");
  }
  ((*local_this).set_diffuse)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_diffuse(const Material self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_set_diffuse_1721_comment =
  "C++ Interface:\n"
  "set_diffuse(const Material self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Specifies the diffuse color setting of the material.  This will be\n"
  " * multiplied by any lights in effect on the material to get the color in the\n"
  " * parts of the object illuminated by the lights.\n"
  " *\n"
  " * This is the primary color of an object; the color of the object as it\n"
  " * appears in direct light, in the absence of highlights.\n"
  " *\n"
  " * If this is not set, the object color will be used.\n"
  " */";
#else
static const char *Dtool_Material_set_diffuse_1721_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Material::clear_diffuse(void)
 */
static PyObject *Dtool_Material_clear_diffuse_1722(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.clear_diffuse")) {
    return nullptr;
  }
  // 1-inline void Material::clear_diffuse(void)
  ((*local_this).clear_diffuse)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Material_clear_diffuse_1722_comment =
  "C++ Interface:\n"
  "clear_diffuse(const Material self)\n"
  "\n"
  "/**\n"
  " * Removes the explicit diffuse color from the material.\n"
  " */";
#else
static const char *Dtool_Material_clear_diffuse_1722_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Material::has_specular(void) const
 */
static PyObject *Dtool_Material_has_specular_1723(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline bool Material::has_specular(void) const
  bool return_value = ((*(const Material*)local_this).has_specular)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_has_specular_1723_comment =
  "C++ Interface:\n"
  "has_specular(Material self)\n"
  "\n"
  "/**\n"
  " * Returns true if the specular color has been explicitly set for this\n"
  " * material, false otherwise.\n"
  " */";
#else
static const char *Dtool_Material_has_specular_1723_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &Material::get_specular(void) const
 */
static PyObject *Dtool_Material_get_specular_1724(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline LColor const &Material::get_specular(void) const
  LColor const *return_value = &(((*(const Material*)local_this).get_specular)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_specular_1724_comment =
  "C++ Interface:\n"
  "get_specular(Material self)\n"
  "\n"
  "/**\n"
  " * Returns the specular color setting, if it has been set.  Returns (0,0,0,0)\n"
  " * if the specular color has not been set.\n"
  " */";
#else
static const char *Dtool_Material_get_specular_1724_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::set_specular(LColor const &color)
 */
static PyObject *Dtool_Material_set_specular_1725(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_specular")) {
    return nullptr;
  }
  // 1-void Material::set_specular(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Material.set_specular", "LVecBase4f");
  }
  ((*local_this).set_specular)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_specular(const Material self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_set_specular_1725_comment =
  "C++ Interface:\n"
  "set_specular(const Material self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Specifies the specular color setting of the material.  This will be\n"
  " * multiplied by any lights in effect on the material to compute the color of\n"
  " * specular highlights on the object.\n"
  " *\n"
  " * This is the highlight color of an object: the color of small highlight\n"
  " * reflections.\n"
  " *\n"
  " * If this is not set, the specular color is taken from the index of\n"
  " * refraction, which is 1 by default (meaning no specular reflections are\n"
  " * generated).\n"
  " */";
#else
static const char *Dtool_Material_set_specular_1725_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::clear_specular(void)
 */
static PyObject *Dtool_Material_clear_specular_1726(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.clear_specular")) {
    return nullptr;
  }
  // 1-void Material::clear_specular(void)
  ((*local_this).clear_specular)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Material_clear_specular_1726_comment =
  "C++ Interface:\n"
  "clear_specular(const Material self)\n"
  "\n"
  "/**\n"
  " * Removes the explicit specular color from the material.\n"
  " */";
#else
static const char *Dtool_Material_clear_specular_1726_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Material::has_emission(void) const
 */
static PyObject *Dtool_Material_has_emission_1727(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline bool Material::has_emission(void) const
  bool return_value = ((*(const Material*)local_this).has_emission)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_has_emission_1727_comment =
  "C++ Interface:\n"
  "has_emission(Material self)\n"
  "\n"
  "/**\n"
  " * Returns true if the emission color has been explicitly set for this\n"
  " * material, false otherwise.\n"
  " */";
#else
static const char *Dtool_Material_has_emission_1727_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &Material::get_emission(void) const
 */
static PyObject *Dtool_Material_get_emission_1728(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline LColor const &Material::get_emission(void) const
  LColor const *return_value = &(((*(const Material*)local_this).get_emission)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_emission_1728_comment =
  "C++ Interface:\n"
  "get_emission(Material self)\n"
  "\n"
  "/**\n"
  " * Returns the emission color setting, if it has been set.  Returns (0,0,0,0)\n"
  " * if the emission color has not been set.\n"
  " */";
#else
static const char *Dtool_Material_get_emission_1728_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::set_emission(LColor const &color)
 */
static PyObject *Dtool_Material_set_emission_1729(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_emission")) {
    return nullptr;
  }
  // 1-void Material::set_emission(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Material.set_emission", "LVecBase4f");
  }
  ((*local_this).set_emission)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_emission(const Material self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_set_emission_1729_comment =
  "C++ Interface:\n"
  "set_emission(const Material self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Specifies the emission color setting of the material.  This is the color of\n"
  " * the object as it appears in the absence of any light whatsover, including\n"
  " * ambient light.  It is as if the object is glowing by this color (although\n"
  " * of course it will not illuminate neighboring objects).\n"
  " *\n"
  " * If this is not set, the object will not glow by its own light and will only\n"
  " * appear visible in the presence of one or more lights.\n"
  " */";
#else
static const char *Dtool_Material_set_emission_1729_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Material::clear_emission(void)
 */
static PyObject *Dtool_Material_clear_emission_1730(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.clear_emission")) {
    return nullptr;
  }
  // 1-inline void Material::clear_emission(void)
  ((*local_this).clear_emission)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Material_clear_emission_1730_comment =
  "C++ Interface:\n"
  "clear_emission(const Material self)\n"
  "\n"
  "/**\n"
  " * Removes the explicit emission color from the material.\n"
  " */";
#else
static const char *Dtool_Material_clear_emission_1730_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Material::get_shininess(void) const
 */
static PyObject *Dtool_Material_get_shininess_1731(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Material::get_shininess(void) const
  PN_stdfloat return_value = ((*(const Material*)local_this).get_shininess)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_shininess_1731_comment =
  "C++ Interface:\n"
  "get_shininess(Material self)\n"
  "\n"
  "/**\n"
  " * Returns the shininess exponent of the material.\n"
  " */";
#else
static const char *Dtool_Material_get_shininess_1731_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::set_shininess(PN_stdfloat shininess)
 */
static PyObject *Dtool_Material_set_shininess_1732(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_shininess")) {
    return nullptr;
  }
  // 1-void Material::set_shininess(PN_stdfloat shininess)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_shininess)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shininess(const Material self, float shininess)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_set_shininess_1732_comment =
  "C++ Interface:\n"
  "set_shininess(const Material self, float shininess)\n"
  "\n"
  "/**\n"
  " * Sets the shininess exponent of the material.  This controls the size of the\n"
  " * specular highlight spot.  In general, larger number produce a smaller\n"
  " * specular highlight, which makes the object appear shinier.  Smaller numbers\n"
  " * produce a larger highlight, which makes the object appear less shiny.\n"
  " *\n"
  " * This is usually in the range 0..128.\n"
  " *\n"
  " * Setting a shininess value removes any previous roughness assignment.\n"
  " */";
#else
static const char *Dtool_Material_set_shininess_1732_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Material::has_roughness(void) const
 */
static PyObject *Dtool_Material_has_roughness_1733(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline bool Material::has_roughness(void) const
  bool return_value = ((*(const Material*)local_this).has_roughness)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_has_roughness_1733_comment =
  "C++ Interface:\n"
  "has_roughness(Material self)\n"
  "\n"
  "/**\n"
  " * Returns true if the roughness has been explicitly set for this material,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_Material_has_roughness_1733_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Material::get_roughness(void) const
 */
static PyObject *Dtool_Material_get_roughness_1734(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-PN_stdfloat Material::get_roughness(void) const
  PN_stdfloat return_value = ((*(const Material*)local_this).get_roughness)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_roughness_1734_comment =
  "C++ Interface:\n"
  "get_roughness(Material self)\n"
  "\n"
  "/**\n"
  " * Returns the roughness previously specified by set_roughness.  If none was\n"
  " * previously set, this value is computed from the shininess value.\n"
  " */";
#else
static const char *Dtool_Material_get_roughness_1734_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::set_roughness(PN_stdfloat roughness)
 */
static PyObject *Dtool_Material_set_roughness_1735(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_roughness")) {
    return nullptr;
  }
  // 1-void Material::set_roughness(PN_stdfloat roughness)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_roughness)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_roughness(const Material self, float roughness)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_set_roughness_1735_comment =
  "C++ Interface:\n"
  "set_roughness(const Material self, float roughness)\n"
  "\n"
  "/**\n"
  " * Sets the roughness exponent of the material, where 0 is completely shiny\n"
  " * (infinite shininess), and 1 is a completely dull object (0 shininess).\n"
  " * This is a different, more perceptually intuitive way of controlling the\n"
  " * size of the specular spot, and more commonly used in physically-based\n"
  " * rendering.\n"
  " *\n"
  " * Setting a roughness recalculates the shininess value.\n"
  " */";
#else
static const char *Dtool_Material_set_roughness_1735_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Material::has_metallic(void) const
 */
static PyObject *Dtool_Material_has_metallic_1736(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline bool Material::has_metallic(void) const
  bool return_value = ((*(const Material*)local_this).has_metallic)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_has_metallic_1736_comment =
  "C++ Interface:\n"
  "has_metallic(Material self)\n"
  "\n"
  "/**\n"
  " * Returns true if the metallic has been explicitly set for this material,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_Material_has_metallic_1736_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Material::get_metallic(void) const
 */
static PyObject *Dtool_Material_get_metallic_1737(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Material::get_metallic(void) const
  PN_stdfloat return_value = ((*(const Material*)local_this).get_metallic)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_metallic_1737_comment =
  "C++ Interface:\n"
  "get_metallic(Material self)\n"
  "\n"
  "/**\n"
  " * Returns the metallic setting, if it has been set.  Returns 0 if it has not\n"
  " * been set.\n"
  " */";
#else
static const char *Dtool_Material_get_metallic_1737_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::set_metallic(PN_stdfloat metallic)
 */
static PyObject *Dtool_Material_set_metallic_1738(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_metallic")) {
    return nullptr;
  }
  // 1-void Material::set_metallic(PN_stdfloat metallic)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_metallic)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_metallic(const Material self, float metallic)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_set_metallic_1738_comment =
  "C++ Interface:\n"
  "set_metallic(const Material self, float metallic)\n"
  "\n"
  "/**\n"
  " * Sets the metallic setting of the material, which is is used for physically-\n"
  " * based rendering models.  This is usually 0 for dielectric materials and 1\n"
  " * for metals.  It really does not make sense to set this to a value other\n"
  " * than 0 or 1, but it is nonetheless a float for compatibility with tools\n"
  " * that allow setting this to values other than 0 or 1.\n"
  " */";
#else
static const char *Dtool_Material_set_metallic_1738_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::clear_metallic(void)
 */
static PyObject *Dtool_Material_clear_metallic_1739(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.clear_metallic")) {
    return nullptr;
  }
  // 1-void Material::clear_metallic(void)
  ((*local_this).clear_metallic)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Material_clear_metallic_1739_comment =
  "C++ Interface:\n"
  "clear_metallic(const Material self)\n"
  "\n"
  "/**\n"
  " * Removes the explicit metallic setting from the material.\n"
  " */";
#else
static const char *Dtool_Material_clear_metallic_1739_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Material::has_refractive_index(void) const
 */
static PyObject *Dtool_Material_has_refractive_index_1740(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline bool Material::has_refractive_index(void) const
  bool return_value = ((*(const Material*)local_this).has_refractive_index)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_has_refractive_index_1740_comment =
  "C++ Interface:\n"
  "has_refractive_index(Material self)\n"
  "\n"
  "/**\n"
  " * Returns true if a refractive index has explicitly been specified for this\n"
  " * material.\n"
  " */";
#else
static const char *Dtool_Material_has_refractive_index_1740_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Material::get_refractive_index(void) const
 */
static PyObject *Dtool_Material_get_refractive_index_1741(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Material::get_refractive_index(void) const
  PN_stdfloat return_value = ((*(const Material*)local_this).get_refractive_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_refractive_index_1741_comment =
  "C++ Interface:\n"
  "get_refractive_index(Material self)\n"
  "\n"
  "/**\n"
  " * Returns the index of refraction, or 1 if none has been set for this\n"
  " * material.\n"
  " */";
#else
static const char *Dtool_Material_get_refractive_index_1741_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::set_refractive_index(PN_stdfloat refractive_index)
 */
static PyObject *Dtool_Material_set_refractive_index_1742(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_refractive_index")) {
    return nullptr;
  }
  // 1-void Material::set_refractive_index(PN_stdfloat refractive_index)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_refractive_index)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_refractive_index(const Material self, float refractive_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_set_refractive_index_1742_comment =
  "C++ Interface:\n"
  "set_refractive_index(const Material self, float refractive_index)\n"
  "\n"
  "/**\n"
  " * Sets the index of refraction of the material, which is used to determine\n"
  " * the specular color in absence of an explicit specular color assignment.\n"
  " * This is usually 1.5 for dielectric materials.  It is not very useful for\n"
  " * metals, since they cannot be described as easily with a single number.\n"
  " *\n"
  " * Should be 1 or higher.  The default is 1.\n"
  " */";
#else
static const char *Dtool_Material_set_refractive_index_1742_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Material::get_local(void) const
 */
static PyObject *Dtool_Material_get_local_1743(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline bool Material::get_local(void) const
  bool return_value = ((*(const Material*)local_this).get_local)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_local_1743_comment =
  "C++ Interface:\n"
  "get_local(Material self)\n"
  "\n"
  "/**\n"
  " * Returns the local viewer flag.  Set set_local().\n"
  " */";
#else
static const char *Dtool_Material_get_local_1743_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Material::set_local(bool local)
 */
static PyObject *Dtool_Material_set_local_1744(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_local")) {
    return nullptr;
  }
  // 1-inline void Material::set_local(bool local)
  ((*local_this).set_local)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_local(const Material self, bool local)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_set_local_1744_comment =
  "C++ Interface:\n"
  "set_local(const Material self, bool local)\n"
  "\n"
  "/**\n"
  " * Sets the local viewer flag.  Set this true to enable camera-relative\n"
  " * specular highlights, or false to use orthogonal specular highlights.  The\n"
  " * default value is true.  Applications that use orthogonal projection should\n"
  " * specify false.\n"
  " */";
#else
static const char *Dtool_Material_set_local_1744_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Material::get_twoside(void) const
 */
static PyObject *Dtool_Material_get_twoside_1745(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline bool Material::get_twoside(void) const
  bool return_value = ((*(const Material*)local_this).get_twoside)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_twoside_1745_comment =
  "C++ Interface:\n"
  "get_twoside(Material self)\n"
  "\n"
  "/**\n"
  " * Returns the state of the two-sided lighting flag.  See set_twoside().\n"
  " */";
#else
static const char *Dtool_Material_get_twoside_1745_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Material::set_twoside(bool twoside)
 */
static PyObject *Dtool_Material_set_twoside_1746(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_twoside")) {
    return nullptr;
  }
  // 1-inline void Material::set_twoside(bool twoside)
  ((*local_this).set_twoside)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_twoside(const Material self, bool twoside)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_set_twoside_1746_comment =
  "C++ Interface:\n"
  "set_twoside(const Material self, bool twoside)\n"
  "\n"
  "/**\n"
  " * Set this true to enable two-sided lighting.  When two-sided lighting is on,\n"
  " * both sides of a polygon will be lit by this material.  The default is for\n"
  " * two-sided lighting to be off, in which case only the front surface is lit.\n"
  " */";
#else
static const char *Dtool_Material_set_twoside_1746_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Material::compare_to(Material const &other) const
 */
static PyObject *Dtool_Material_compare_to_1750(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-int Material::compare_to(Material const &other) const
  Material const *arg_this = (Material *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Material, 1, "Material.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const Material*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(Material self, const Material other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_compare_to_1750_comment =
  "C++ Interface:\n"
  "compare_to(Material self, const Material other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this material sorts before the other\n"
  " * one, greater than zero if it sorts after, or zero if they are equivalent.\n"
  " * The sorting order is arbitrary and largely meaningless, except to\n"
  " * differentiate different materials.\n"
  " */";
#else
static const char *Dtool_Material_compare_to_1750_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::output(std::ostream &out) const
 */
static PyObject *Dtool_Material_output_1751(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-void Material::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Material.output", false, true);
  if (arg_this != nullptr) {
    ((*(const Material*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Material self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_output_1751_comment =
  "C++ Interface:\n"
  "output(Material self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Material_output_1751_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Material::write(std::ostream &out, int indent) const
 */
static PyObject *Dtool_Material_write_1752(PyObject *self, PyObject *args, PyObject *kwds) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-void Material::write(std::ostream &out, int indent) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Material.write", false, true);
    if (param1_this != nullptr) {
      ((*(const Material*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(Material self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Material_write_1752_comment =
  "C++ Interface:\n"
  "write(Material self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Material_write_1752_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Material::is_attrib_locked(void) const
 */
static PyObject *Dtool_Material_is_attrib_locked_1753(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Material)) {
    return nullptr;
  }
  // 1-inline bool Material::is_attrib_locked(void) const
  bool return_value = ((*(const Material*)local_this).is_attrib_locked)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Material_is_attrib_locked_1753_comment =
  "C++ Interface:\n"
  "is_attrib_locked(Material self)\n"
  "\n"
  "/**\n"
  " * @deprecated This no longer has any meaning in 1.10.\n"
  " */";
#else
static const char *Dtool_Material_is_attrib_locked_1753_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Material::set_attrib_lock(void)
 */
static PyObject *Dtool_Material_set_attrib_lock_1754(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.set_attrib_lock")) {
    return nullptr;
  }
  // 1-inline void Material::set_attrib_lock(void)
  ((*local_this).set_attrib_lock)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Material_set_attrib_lock_1754_comment =
  "C++ Interface:\n"
  "set_attrib_lock(const Material self)\n"
  "\n"
  "/**\n"
  " * @deprecated This no longer has any meaning in 1.10.\n"
  " */";
#else
static const char *Dtool_Material_set_attrib_lock_1754_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Material::get_class_type(void)
 */
static PyObject *Dtool_Material_get_class_type_1766(PyObject *, PyObject *) {
  // 1-static TypeHandle Material::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Material::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Material_get_class_type_1766_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Material_get_class_type_1766_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *Material::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_Material_upcast_to_TypedWritableReferenceCount_1703(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.upcast_to_TypedWritableReferenceCount")) {
    return nullptr;
  }
  // 1-TypedWritableReferenceCount *Material::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Material_upcast_to_TypedWritableReferenceCount_1703_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const Material self)\n"
  "\n"
  "upcast from Material to TypedWritableReferenceCount";
#else
static const char *Dtool_Material_upcast_to_TypedWritableReferenceCount_1703_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *Material::upcast_to_Namable(void)
 */
static PyObject *Dtool_Material_upcast_to_Namable_1705(PyObject *self, PyObject *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *Material::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Material_upcast_to_Namable_1705_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const Material self)\n"
  "\n"
  "upcast from Material to Namable";
#else
static const char *Dtool_Material_upcast_to_Namable_1705_comment = nullptr;
#endif

static PyObject *Dtool_Material_base_color_Getter(PyObject *self, void *) {
  const Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_base_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor const &Material::get_base_color(void) const
  LColor const *return_value = &(((*(const Material*)local_this).get_base_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_Material_base_color_Setter(PyObject *self, PyObject *arg, void *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.base_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete base_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_base_color();
    return 0;
  }
  // 1-void Material::set_base_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Material.set_base_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_base_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_base_color(const Material self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_Material_ambient_Getter(PyObject *self, void *) {
  const Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_ambient()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor const &Material::get_ambient(void) const
  LColor const *return_value = &(((*(const Material*)local_this).get_ambient)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_Material_ambient_Setter(PyObject *self, PyObject *arg, void *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.ambient")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete ambient attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_ambient();
    return 0;
  }
  // 1-void Material::set_ambient(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Material.set_ambient", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_ambient)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_ambient(const Material self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_Material_diffuse_Getter(PyObject *self, void *) {
  const Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_diffuse()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor const &Material::get_diffuse(void) const
  LColor const *return_value = &(((*(const Material*)local_this).get_diffuse)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_Material_diffuse_Setter(PyObject *self, PyObject *arg, void *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.diffuse")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete diffuse attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_diffuse();
    return 0;
  }
  // 1-void Material::set_diffuse(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Material.set_diffuse", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_diffuse)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_diffuse(const Material self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_Material_specular_Getter(PyObject *self, void *) {
  const Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_specular()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor const &Material::get_specular(void) const
  LColor const *return_value = &(((*(const Material*)local_this).get_specular)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_Material_specular_Setter(PyObject *self, PyObject *arg, void *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.specular")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete specular attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_specular();
    return 0;
  }
  // 1-void Material::set_specular(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Material.set_specular", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_specular)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_specular(const Material self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_Material_emission_Getter(PyObject *self, void *) {
  const Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_emission()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor const &Material::get_emission(void) const
  LColor const *return_value = &(((*(const Material*)local_this).get_emission)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_Material_emission_Setter(PyObject *self, PyObject *arg, void *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.emission")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete emission attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_emission();
    return 0;
  }
  // 1-void Material::set_emission(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Material.set_emission", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_emission)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_emission(const Material self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_Material_shininess_Getter(PyObject *self, void *) {
  const Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Material::get_shininess(void) const
  PN_stdfloat return_value = ((*(const Material*)local_this).get_shininess)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Material_shininess_Setter(PyObject *self, PyObject *arg, void *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.shininess")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete shininess attribute");
    return -1;
  }
  // 1-void Material::set_shininess(PN_stdfloat shininess)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_shininess)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shininess(const Material self, float shininess)\n");
  }
  return -1;
}

static PyObject *Dtool_Material_roughness_Getter(PyObject *self, void *) {
  const Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PN_stdfloat Material::get_roughness(void) const
  PN_stdfloat return_value = ((*(const Material*)local_this).get_roughness)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Material_roughness_Setter(PyObject *self, PyObject *arg, void *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.roughness")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete roughness attribute");
    return -1;
  }
  // 1-void Material::set_roughness(PN_stdfloat roughness)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_roughness)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_roughness(const Material self, float roughness)\n");
  }
  return -1;
}

static PyObject *Dtool_Material_metallic_Getter(PyObject *self, void *) {
  const Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Material::get_metallic(void) const
  PN_stdfloat return_value = ((*(const Material*)local_this).get_metallic)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Material_metallic_Setter(PyObject *self, PyObject *arg, void *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.metallic")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete metallic attribute");
    return -1;
  }
  // 1-void Material::set_metallic(PN_stdfloat metallic)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_metallic)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_metallic(const Material self, float metallic)\n");
  }
  return -1;
}

static PyObject *Dtool_Material_refractive_index_Getter(PyObject *self, void *) {
  const Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Material::get_refractive_index(void) const
  PN_stdfloat return_value = ((*(const Material*)local_this).get_refractive_index)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Material_refractive_index_Setter(PyObject *self, PyObject *arg, void *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.refractive_index")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete refractive_index attribute");
    return -1;
  }
  // 1-void Material::set_refractive_index(PN_stdfloat refractive_index)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_refractive_index)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_refractive_index(const Material self, float refractive_index)\n");
  }
  return -1;
}

static PyObject *Dtool_Material_local_Getter(PyObject *self, void *) {
  const Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool Material::get_local(void) const
  bool return_value = ((*(const Material*)local_this).get_local)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Material_local_Setter(PyObject *self, PyObject *arg, void *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.local")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete local attribute");
    return -1;
  }
  // 1-inline void Material::set_local(bool local)
  ((*local_this).set_local)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_local(const Material self, bool local)\n");
  }
  return -1;
}

static PyObject *Dtool_Material_twoside_Getter(PyObject *self, void *) {
  const Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool Material::get_twoside(void) const
  bool return_value = ((*(const Material*)local_this).get_twoside)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Material_twoside_Setter(PyObject *self, PyObject *arg, void *) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Material, (void **)&local_this, "Material.twoside")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete twoside attribute");
    return -1;
  }
  // 1-inline void Material::set_twoside(bool twoside)
  ((*local_this).set_twoside)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_twoside(const Material self, bool twoside)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline Material::Material(Material const &copy)
 * inline explicit Material::Material(std::string const &name = "")
 */
static int Dtool_Init_Material(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit Material::Material(std::string const &name)
      Material *return_value = new Material();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Material, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Material::Material(Material const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          Material const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Material);
          if (param0_this != nullptr) {
            Material *return_value = new Material(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Material, true, false);
          }
        }
      }

      {
        // -2 inline explicit Material::Material(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Material", (char **)keyword_list, &param0_str, &param0_len)) {
          Material *return_value = new Material(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Material, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline Material::Material(Material const &copy)
      // No coercion possible: inline explicit Material::Material(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Material() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Material()\n"
      "Material(const Material copy)\n"
      "Material(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Material(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Material) {
    printf("Material ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Material *local_this = (Material *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Material) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Material(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Material) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Material*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Material*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Material*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Material*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Material*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MaterialPool
 */
/**
 * Python function wrapper for:
 * static inline Material *MaterialPool::get_material(Material *temp)
 */
static PyObject *Dtool_MaterialPool_get_material_1768(PyObject *, PyObject *arg) {
  // 1-static inline Material *MaterialPool::get_material(Material *temp)
  Material *arg_this = (Material *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Material, 0, "MaterialPool.get_material", false, true);
  if (arg_this != nullptr) {
    Material *return_value = (MaterialPool::get_material)(arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Material, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_material(Material temp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialPool_get_material_1768_comment =
  "C++ Interface:\n"
  "get_material(Material temp)\n"
  "\n"
  "/**\n"
  " * Returns a Material pointer that represents the same material described by\n"
  " * temp, except that it is a shared pointer.\n"
  " *\n"
  " * Each call to get_material() passing an equivalent Material pointer will\n"
  " * return the same shared pointer.\n"
  " *\n"
  " * If you modify the shared pointer, it will automatically disassociate it\n"
  " * from the pool.\n"
  " *\n"
  " * Also, the return value may be a different pointer than that passed in, or\n"
  " * it may be the same pointer.  In either case, the passed in pointer has now\n"
  " * been sacrificed to the greater good and should not be used again (like any\n"
  " * other PointerTo, it will be freed when the last reference count is\n"
  " * removed).\n"
  " */";
#else
static const char *Dtool_MaterialPool_get_material_1768_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MaterialPool::release_material(Material *temp)
 */
static PyObject *Dtool_MaterialPool_release_material_1769(PyObject *, PyObject *arg) {
  // 1-static inline void MaterialPool::release_material(Material *temp)
  Material *arg_this = (Material *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Material, 0, "MaterialPool.release_material", false, true);
  if (arg_this != nullptr) {
    (MaterialPool::release_material)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_material(Material temp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialPool_release_material_1769_comment =
  "C++ Interface:\n"
  "release_material(Material temp)\n"
  "\n"
  "/**\n"
  " * Removes the indicated material from the pool.\n"
  " */";
#else
static const char *Dtool_MaterialPool_release_material_1769_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MaterialPool::release_all_materials(void)
 */
static PyObject *Dtool_MaterialPool_release_all_materials_1770(PyObject *, PyObject *) {
  // 1-static inline void MaterialPool::release_all_materials(void)
  (MaterialPool::release_all_materials)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MaterialPool_release_all_materials_1770_comment =
  "C++ Interface:\n"
  "release_all_materials()\n"
  "\n"
  "/**\n"
  " * Releases all materials in the pool and restores the pool to the empty\n"
  " * state.\n"
  " */";
#else
static const char *Dtool_MaterialPool_release_all_materials_1770_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int MaterialPool::garbage_collect(void)
 */
static PyObject *Dtool_MaterialPool_garbage_collect_1771(PyObject *, PyObject *) {
  // 1-static inline int MaterialPool::garbage_collect(void)
  int return_value = (MaterialPool::garbage_collect)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MaterialPool_garbage_collect_1771_comment =
  "C++ Interface:\n"
  "garbage_collect()\n"
  "\n"
  "/**\n"
  " * Releases only those materials in the pool that have a reference count of\n"
  " * exactly 1; i.e.  only those materials that are not being used outside of\n"
  " * the pool.  Returns the number of materials released.\n"
  " */";
#else
static const char *Dtool_MaterialPool_garbage_collect_1771_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MaterialPool::list_contents(std::ostream &out)
 */
static PyObject *Dtool_MaterialPool_list_contents_1772(PyObject *, PyObject *arg) {
  // 1-static inline void MaterialPool::list_contents(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "MaterialPool.list_contents", false, true);
  if (arg_this != nullptr) {
    (MaterialPool::list_contents)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_contents(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialPool_list_contents_1772_comment =
  "C++ Interface:\n"
  "list_contents(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the material pool to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_MaterialPool_list_contents_1772_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void MaterialPool::write(std::ostream &out)
 */
static PyObject *Dtool_MaterialPool_write_1773(PyObject *, PyObject *arg) {
  // 1-static void MaterialPool::write(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "MaterialPool.write", false, true);
  if (arg_this != nullptr) {
    (MaterialPool::write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MaterialPool_write_1773_comment =
  "C++ Interface:\n"
  "write(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the material pool to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_MaterialPool_write_1773_comment = nullptr;
#endif

static int Dtool_Init_MaterialPool(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MaterialPool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MaterialPool) {
    printf("MaterialPool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MaterialPool *local_this = (MaterialPool *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MaterialPool) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MaterialPool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MaterialPool) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MatrixLens
 */
/**
 * Python function wrapper for:
 * inline void MatrixLens::set_user_mat(LMatrix4 const &user_mat)
 */
static PyObject *Dtool_MatrixLens_set_user_mat_1777(PyObject *self, PyObject *arg) {
  MatrixLens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MatrixLens, (void **)&local_this, "MatrixLens.set_user_mat")) {
    return nullptr;
  }
  // 1-inline void MatrixLens::set_user_mat(LMatrix4 const &user_mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MatrixLens.set_user_mat", "LMatrix4f");
  }
  ((*local_this).set_user_mat)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_user_mat(const MatrixLens self, const LMatrix4f user_mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MatrixLens_set_user_mat_1777_comment =
  "C++ Interface:\n"
  "set_user_mat(const MatrixLens self, const LMatrix4f user_mat)\n"
  "\n"
  "/**\n"
  " * Explicitly specifies the projection matrix.  This matrix should convert X\n"
  " * and Y to the range [-film_size/2, film_size/2], where (-fs/2,-fs/2) is the\n"
  " * lower left corner of the screen and (fs/2, fs/2) is the upper right.  Z\n"
  " * should go to the range [-1, 1], where -1 is the far plane and 1 is the near\n"
  " * plane.  Note that this is a left-handed Y-up coordinate system.\n"
  " *\n"
  " * The default film_size for a MatrixLens is 2, so the default range is [-1,\n"
  " * 1] for both X and Y.  This is consistent with the GL conventions for\n"
  " * projection matrices.\n"
  " */";
#else
static const char *Dtool_MatrixLens_set_user_mat_1777_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &MatrixLens::get_user_mat(void) const
 */
static PyObject *Dtool_MatrixLens_get_user_mat_1778(PyObject *self, PyObject *) {
  MatrixLens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MatrixLens)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &MatrixLens::get_user_mat(void) const
  LMatrix4 const *return_value = &(((*(const MatrixLens*)local_this).get_user_mat)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_MatrixLens_get_user_mat_1778_comment =
  "C++ Interface:\n"
  "get_user_mat(MatrixLens self)\n"
  "\n"
  "/**\n"
  " * Returns the explicit projection matrix as set by the user.  This does not\n"
  " * include transforms on the lens or film (e.g.  a film offset or view hpr).\n"
  " */";
#else
static const char *Dtool_MatrixLens_get_user_mat_1778_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void MatrixLens::set_left_eye_mat(LMatrix4 const &user_mat)
 */
static PyObject *Dtool_MatrixLens_set_left_eye_mat_1780(PyObject *self, PyObject *arg) {
  MatrixLens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MatrixLens, (void **)&local_this, "MatrixLens.set_left_eye_mat")) {
    return nullptr;
  }
  // 1-inline void MatrixLens::set_left_eye_mat(LMatrix4 const &user_mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MatrixLens.set_left_eye_mat", "LMatrix4f");
  }
  ((*local_this).set_left_eye_mat)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_left_eye_mat(const MatrixLens self, const LMatrix4f user_mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MatrixLens_set_left_eye_mat_1780_comment =
  "C++ Interface:\n"
  "set_left_eye_mat(const MatrixLens self, const LMatrix4f user_mat)\n"
  "\n"
  "/**\n"
  " * Sets a custom projection matrix for the left eye.  This is only used if the\n"
  " * lens is attached to a stereo camera, in which case the left eye matrix will\n"
  " * be used to draw the scene in the left eye (but the center matrix--the\n"
  " * user_mat--will still be used to cull the scene).\n"
  " *\n"
  " * This matrix should not be too different from the center matrix (set by\n"
  " * set_user_mat()) or culling errors may become obvious.\n"
  " */";
#else
static const char *Dtool_MatrixLens_set_left_eye_mat_1780_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void MatrixLens::clear_left_eye_mat(void)
 */
static PyObject *Dtool_MatrixLens_clear_left_eye_mat_1781(PyObject *self, PyObject *) {
  MatrixLens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MatrixLens, (void **)&local_this, "MatrixLens.clear_left_eye_mat")) {
    return nullptr;
  }
  // 1-inline void MatrixLens::clear_left_eye_mat(void)
  ((*local_this).clear_left_eye_mat)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MatrixLens_clear_left_eye_mat_1781_comment =
  "C++ Interface:\n"
  "clear_left_eye_mat(const MatrixLens self)\n"
  "\n"
  "/**\n"
  " * Removes the custom projection matrix set for the left eye, and uses the\n"
  " * center matrix (set by set_user_mat) instead.\n"
  " */";
#else
static const char *Dtool_MatrixLens_clear_left_eye_mat_1781_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MatrixLens::has_left_eye_mat(void) const
 */
static PyObject *Dtool_MatrixLens_has_left_eye_mat_1782(PyObject *self, PyObject *) {
  MatrixLens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MatrixLens)) {
    return nullptr;
  }
  // 1-inline bool MatrixLens::has_left_eye_mat(void) const
  bool return_value = ((*(const MatrixLens*)local_this).has_left_eye_mat)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MatrixLens_has_left_eye_mat_1782_comment =
  "C++ Interface:\n"
  "has_left_eye_mat(MatrixLens self)\n"
  "\n"
  "/**\n"
  " * Returns true if the camera has a custom projection matrix set for the left\n"
  " * eye, or false if the center matrix (set by set_user_mat) will be used for\n"
  " * the left eye.\n"
  " */";
#else
static const char *Dtool_MatrixLens_has_left_eye_mat_1782_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &MatrixLens::get_left_eye_mat(void) const
 */
static PyObject *Dtool_MatrixLens_get_left_eye_mat_1783(PyObject *self, PyObject *) {
  MatrixLens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MatrixLens)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &MatrixLens::get_left_eye_mat(void) const
  LMatrix4 const *return_value = &(((*(const MatrixLens*)local_this).get_left_eye_mat)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_MatrixLens_get_left_eye_mat_1783_comment =
  "C++ Interface:\n"
  "get_left_eye_mat(MatrixLens self)\n"
  "\n"
  "/**\n"
  " * Returns the custom projection matrix for the left eye, if any, or the\n"
  " * center matrix if there is no custom matrix set for the left eye.\n"
  " */";
#else
static const char *Dtool_MatrixLens_get_left_eye_mat_1783_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void MatrixLens::set_right_eye_mat(LMatrix4 const &user_mat)
 */
static PyObject *Dtool_MatrixLens_set_right_eye_mat_1784(PyObject *self, PyObject *arg) {
  MatrixLens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MatrixLens, (void **)&local_this, "MatrixLens.set_right_eye_mat")) {
    return nullptr;
  }
  // 1-inline void MatrixLens::set_right_eye_mat(LMatrix4 const &user_mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MatrixLens.set_right_eye_mat", "LMatrix4f");
  }
  ((*local_this).set_right_eye_mat)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_right_eye_mat(const MatrixLens self, const LMatrix4f user_mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MatrixLens_set_right_eye_mat_1784_comment =
  "C++ Interface:\n"
  "set_right_eye_mat(const MatrixLens self, const LMatrix4f user_mat)\n"
  "\n"
  "/**\n"
  " * Sets a custom projection matrix for the right eye.  This is only used if\n"
  " * the lens is attached to a stereo camera, in which case the right eye matrix\n"
  " * will be used to draw the scene in the right eye (but the center matrix--the\n"
  " * user_mat--will still be used to cull the scene).\n"
  " *\n"
  " * This matrix should not be too different from the center matrix (set by\n"
  " * set_user_mat()) or culling errors may become obvious.\n"
  " */";
#else
static const char *Dtool_MatrixLens_set_right_eye_mat_1784_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void MatrixLens::clear_right_eye_mat(void)
 */
static PyObject *Dtool_MatrixLens_clear_right_eye_mat_1785(PyObject *self, PyObject *) {
  MatrixLens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MatrixLens, (void **)&local_this, "MatrixLens.clear_right_eye_mat")) {
    return nullptr;
  }
  // 1-inline void MatrixLens::clear_right_eye_mat(void)
  ((*local_this).clear_right_eye_mat)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MatrixLens_clear_right_eye_mat_1785_comment =
  "C++ Interface:\n"
  "clear_right_eye_mat(const MatrixLens self)\n"
  "\n"
  "/**\n"
  " * Removes the custom projection matrix set for the right eye, and uses the\n"
  " * center matrix (set by set_user_mat) instead.\n"
  " */";
#else
static const char *Dtool_MatrixLens_clear_right_eye_mat_1785_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MatrixLens::has_right_eye_mat(void) const
 */
static PyObject *Dtool_MatrixLens_has_right_eye_mat_1786(PyObject *self, PyObject *) {
  MatrixLens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MatrixLens)) {
    return nullptr;
  }
  // 1-inline bool MatrixLens::has_right_eye_mat(void) const
  bool return_value = ((*(const MatrixLens*)local_this).has_right_eye_mat)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MatrixLens_has_right_eye_mat_1786_comment =
  "C++ Interface:\n"
  "has_right_eye_mat(MatrixLens self)\n"
  "\n"
  "/**\n"
  " * Returns true if the camera has a custom projection matrix set for the right\n"
  " * eye, or false if the center matrix (set by set_user_mat) will be used for\n"
  " * the right eye.\n"
  " */";
#else
static const char *Dtool_MatrixLens_has_right_eye_mat_1786_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &MatrixLens::get_right_eye_mat(void) const
 */
static PyObject *Dtool_MatrixLens_get_right_eye_mat_1787(PyObject *self, PyObject *) {
  MatrixLens *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MatrixLens)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &MatrixLens::get_right_eye_mat(void) const
  LMatrix4 const *return_value = &(((*(const MatrixLens*)local_this).get_right_eye_mat)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_MatrixLens_get_right_eye_mat_1787_comment =
  "C++ Interface:\n"
  "get_right_eye_mat(MatrixLens self)\n"
  "\n"
  "/**\n"
  " * Returns the custom projection matrix for the right eye, if any, or the\n"
  " * center matrix if there is no custom matrix set for the right eye.\n"
  " */";
#else
static const char *Dtool_MatrixLens_get_right_eye_mat_1787_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MatrixLens::get_class_type(void)
 */
static PyObject *Dtool_MatrixLens_get_class_type_1788(PyObject *, PyObject *) {
  // 1-static TypeHandle MatrixLens::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MatrixLens::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MatrixLens_get_class_type_1788_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MatrixLens_get_class_type_1788_comment = nullptr;
#endif

static PyObject *Dtool_MatrixLens_user_mat_Getter(PyObject *self, void *) {
  const MatrixLens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MatrixLens, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LMatrix4 const &MatrixLens::get_user_mat(void) const
  LMatrix4 const *return_value = &(((*(const MatrixLens*)local_this).get_user_mat)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

static int Dtool_MatrixLens_user_mat_Setter(PyObject *self, PyObject *arg, void *) {
  MatrixLens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MatrixLens, (void **)&local_this, "MatrixLens.user_mat")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete user_mat attribute");
    return -1;
  }
  // 1-inline void MatrixLens::set_user_mat(LMatrix4 const &user_mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "MatrixLens.set_user_mat", "LMatrix4f");
    return -1;
  }
  ((*local_this).set_user_mat)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_user_mat(const MatrixLens self, const LMatrix4f user_mat)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline MatrixLens::MatrixLens(void)
 */
static int Dtool_Init_MatrixLens(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("MatrixLens() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "MatrixLens() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline MatrixLens::MatrixLens(void)
  MatrixLens *return_value = new MatrixLens();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MatrixLens, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MatrixLens()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MatrixLens(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MatrixLens) {
    printf("MatrixLens ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MatrixLens *local_this = (MatrixLens *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MatrixLens) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Lens) {
    return (Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(Lens *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MatrixLens(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MatrixLens) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Lens) {
    Lens* other_this = (Lens*)from_this;
    return (MatrixLens*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MatrixLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MatrixLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MatrixLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MatrixLens*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OrthographicLens
 */
/**
 * Python function wrapper for:
 * static TypeHandle OrthographicLens::get_class_type(void)
 */
static PyObject *Dtool_OrthographicLens_get_class_type_1792(PyObject *, PyObject *) {
  // 1-static TypeHandle OrthographicLens::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OrthographicLens::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OrthographicLens_get_class_type_1792_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OrthographicLens_get_class_type_1792_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OrthographicLens::OrthographicLens(void)
 */
static int Dtool_Init_OrthographicLens(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("OrthographicLens() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OrthographicLens() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline OrthographicLens::OrthographicLens(void)
  OrthographicLens *return_value = new OrthographicLens();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OrthographicLens, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OrthographicLens()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OrthographicLens(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OrthographicLens) {
    printf("OrthographicLens ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OrthographicLens *local_this = (OrthographicLens *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OrthographicLens) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Lens) {
    return (Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(Lens *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OrthographicLens(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OrthographicLens) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Lens) {
    Lens* other_this = (Lens*)from_this;
    return (OrthographicLens*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OrthographicLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OrthographicLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (OrthographicLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (OrthographicLens*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamTextureSampler
 */
/**
 * Python function wrapper for:
 * inline Texture *ParamTextureSampler::get_texture(void) const
 */
static PyObject *Dtool_ParamTextureSampler_get_texture_1797(PyObject *self, PyObject *) {
  ParamTextureSampler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamTextureSampler)) {
    return nullptr;
  }
  // 1-inline Texture *ParamTextureSampler::get_texture(void) const
  Texture *return_value = ((*(const ParamTextureSampler*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ParamTextureSampler_get_texture_1797_comment =
  "C++ Interface:\n"
  "get_texture(ParamTextureSampler self)\n"
  "\n"
  "/**\n"
  " * Retrieves the texture stored in the parameter.\n"
  " */";
#else
static const char *Dtool_ParamTextureSampler_get_texture_1797_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState const &ParamTextureSampler::get_sampler(void) const
 */
static PyObject *Dtool_ParamTextureSampler_get_sampler_1798(PyObject *self, PyObject *) {
  ParamTextureSampler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamTextureSampler)) {
    return nullptr;
  }
  // 1-inline SamplerState const &ParamTextureSampler::get_sampler(void) const
  SamplerState const *return_value = &(((*(const ParamTextureSampler*)local_this).get_sampler)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SamplerState, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamTextureSampler_get_sampler_1798_comment =
  "C++ Interface:\n"
  "get_sampler(ParamTextureSampler self)\n"
  "\n"
  "/**\n"
  " * Retrieves the sampler state stored in the parameter.\n"
  " */";
#else
static const char *Dtool_ParamTextureSampler_get_sampler_1798_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamTextureSampler::get_class_type(void)
 */
static PyObject *Dtool_ParamTextureSampler_get_class_type_1802(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamTextureSampler::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamTextureSampler::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamTextureSampler_get_class_type_1802_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamTextureSampler_get_class_type_1802_comment = nullptr;
#endif

static PyObject *Dtool_ParamTextureSampler_texture_Getter(PyObject *self, void *) {
  const ParamTextureSampler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamTextureSampler, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture *ParamTextureSampler::get_texture(void) const
  Texture *return_value = ((*(const ParamTextureSampler*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_ParamTextureSampler_sampler_Getter(PyObject *self, void *) {
  const ParamTextureSampler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamTextureSampler, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState const &ParamTextureSampler::get_sampler(void) const
  SamplerState const *return_value = &(((*(const ParamTextureSampler*)local_this).get_sampler)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SamplerState, false, true);
}

/**
 * Python function wrapper for:
 * inline ParamTextureSampler::ParamTextureSampler(Texture *tex, SamplerState const &sampler)
 */
static int Dtool_Init_ParamTextureSampler(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline ParamTextureSampler::ParamTextureSampler(Texture *tex, SamplerState const &sampler)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"tex", "sampler", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:ParamTextureSampler", (char **)keyword_list, &param0, &param1)) {
    Texture *param0_this = (Texture *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Texture, 0, "ParamTextureSampler.ParamTextureSampler", false, true);
    SamplerState const *param1_this = (SamplerState *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_SamplerState, 1, "ParamTextureSampler.ParamTextureSampler", true, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      ParamTextureSampler *return_value = new ParamTextureSampler(param0_this, *param1_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamTextureSampler, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamTextureSampler(Texture tex, const SamplerState sampler)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamTextureSampler(PyObject *args, CPT(ParamTextureSampler) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamTextureSampler)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline ParamTextureSampler::ParamTextureSampler(Texture *tex, SamplerState const &sampler)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "ParamTextureSampler", 2, 2, &param0, &param1)) {
        Texture *param0_this = (Texture *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Texture, 0, "ParamTextureSampler.ParamTextureSampler", false, false);
        SamplerState const *param1_this = nullptr;
        DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_SamplerState);
        if (param0_this != nullptr && param1_this != nullptr) {
          ParamTextureSampler *return_value = new ParamTextureSampler(param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ParamTextureSampler(PyObject *args, PT(ParamTextureSampler) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamTextureSampler)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline ParamTextureSampler::ParamTextureSampler(Texture *tex, SamplerState const &sampler)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "ParamTextureSampler", 2, 2, &param0, &param1)) {
        Texture *param0_this = (Texture *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Texture, 0, "ParamTextureSampler.ParamTextureSampler", false, false);
        SamplerState const *param1_this = nullptr;
        DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_SamplerState);
        if (param0_this != nullptr && param1_this != nullptr) {
          ParamTextureSampler *return_value = new ParamTextureSampler(param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ParamTextureSampler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamTextureSampler) {
    printf("ParamTextureSampler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamTextureSampler *local_this = (ParamTextureSampler *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamTextureSampler) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamTextureSampler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamTextureSampler) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamTextureSampler*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamTextureSampler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamTextureSampler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamTextureSampler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamTextureSampler*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamTextureImage
 */
/**
 * Python function wrapper for:
 * inline Texture *ParamTextureImage::get_texture(void) const
 */
static PyObject *Dtool_ParamTextureImage_get_texture_1806(PyObject *self, PyObject *) {
  ParamTextureImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamTextureImage)) {
    return nullptr;
  }
  // 1-inline Texture *ParamTextureImage::get_texture(void) const
  Texture *return_value = ((*(const ParamTextureImage*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ParamTextureImage_get_texture_1806_comment =
  "C++ Interface:\n"
  "get_texture(ParamTextureImage self)\n"
  "\n"
  "/**\n"
  " * Retrieves the texture stored in the parameter.\n"
  " */";
#else
static const char *Dtool_ParamTextureImage_get_texture_1806_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ParamTextureImage::has_read_access(void) const
 */
static PyObject *Dtool_ParamTextureImage_has_read_access_1807(PyObject *self, PyObject *) {
  ParamTextureImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamTextureImage)) {
    return nullptr;
  }
  // 1-inline bool ParamTextureImage::has_read_access(void) const
  bool return_value = ((*(const ParamTextureImage*)local_this).has_read_access)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParamTextureImage_has_read_access_1807_comment =
  "C++ Interface:\n"
  "has_read_access(ParamTextureImage self)\n"
  "\n"
  "/**\n"
  " * Returns true if this image should be bound with read access enabled.\n"
  " */";
#else
static const char *Dtool_ParamTextureImage_has_read_access_1807_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ParamTextureImage::has_write_access(void) const
 */
static PyObject *Dtool_ParamTextureImage_has_write_access_1808(PyObject *self, PyObject *) {
  ParamTextureImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamTextureImage)) {
    return nullptr;
  }
  // 1-inline bool ParamTextureImage::has_write_access(void) const
  bool return_value = ((*(const ParamTextureImage*)local_this).has_write_access)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParamTextureImage_has_write_access_1808_comment =
  "C++ Interface:\n"
  "has_write_access(ParamTextureImage self)\n"
  "\n"
  "/**\n"
  " * Returns true if this image should be bound with write access enabled.\n"
  " */";
#else
static const char *Dtool_ParamTextureImage_has_write_access_1808_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ParamTextureImage::get_bind_layered(void) const
 */
static PyObject *Dtool_ParamTextureImage_get_bind_layered_1809(PyObject *self, PyObject *) {
  ParamTextureImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamTextureImage)) {
    return nullptr;
  }
  // 1-inline bool ParamTextureImage::get_bind_layered(void) const
  bool return_value = ((*(const ParamTextureImage*)local_this).get_bind_layered)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParamTextureImage_get_bind_layered_1809_comment =
  "C++ Interface:\n"
  "get_bind_layered(ParamTextureImage self)\n"
  "\n"
  "/**\n"
  " * Returns true if all layers of this image should be bound simultaneously.\n"
  " */";
#else
static const char *Dtool_ParamTextureImage_get_bind_layered_1809_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ParamTextureImage::get_bind_level(void) const
 */
static PyObject *Dtool_ParamTextureImage_get_bind_level_1810(PyObject *self, PyObject *) {
  ParamTextureImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamTextureImage)) {
    return nullptr;
  }
  // 1-inline int ParamTextureImage::get_bind_level(void) const
  int return_value = ((*(const ParamTextureImage*)local_this).get_bind_level)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParamTextureImage_get_bind_level_1810_comment =
  "C++ Interface:\n"
  "get_bind_level(ParamTextureImage self)\n"
  "\n"
  "/**\n"
  " * Returns the image level that should be bound.\n"
  " */";
#else
static const char *Dtool_ParamTextureImage_get_bind_level_1810_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ParamTextureImage::get_bind_layer(void) const
 */
static PyObject *Dtool_ParamTextureImage_get_bind_layer_1811(PyObject *self, PyObject *) {
  ParamTextureImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamTextureImage)) {
    return nullptr;
  }
  // 1-inline int ParamTextureImage::get_bind_layer(void) const
  int return_value = ((*(const ParamTextureImage*)local_this).get_bind_layer)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParamTextureImage_get_bind_layer_1811_comment =
  "C++ Interface:\n"
  "get_bind_layer(ParamTextureImage self)\n"
  "\n"
  "/**\n"
  " * Returns the image layer that should be bound.  This is undefined if\n"
  " * get_bind_layered() returns false.\n"
  " */";
#else
static const char *Dtool_ParamTextureImage_get_bind_layer_1811_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamTextureImage::get_class_type(void)
 */
static PyObject *Dtool_ParamTextureImage_get_class_type_1817(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamTextureImage::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamTextureImage::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamTextureImage_get_class_type_1817_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamTextureImage_get_class_type_1817_comment = nullptr;
#endif

static PyObject *Dtool_ParamTextureImage_texture_Getter(PyObject *self, void *) {
  const ParamTextureImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamTextureImage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture *ParamTextureImage::get_texture(void) const
  Texture *return_value = ((*(const ParamTextureImage*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_ParamTextureImage_read_access_Getter(PyObject *self, void *) {
  const ParamTextureImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamTextureImage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool ParamTextureImage::has_read_access(void) const
  bool return_value = ((*(const ParamTextureImage*)local_this).has_read_access)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ParamTextureImage_write_access_Getter(PyObject *self, void *) {
  const ParamTextureImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamTextureImage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool ParamTextureImage::has_write_access(void) const
  bool return_value = ((*(const ParamTextureImage*)local_this).has_write_access)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ParamTextureImage_bind_level_Getter(PyObject *self, void *) {
  const ParamTextureImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamTextureImage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ParamTextureImage::get_bind_level(void) const
  int return_value = ((*(const ParamTextureImage*)local_this).get_bind_level)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ParamTextureImage_bind_layer_Getter(PyObject *self, void *) {
  const ParamTextureImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamTextureImage, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->get_bind_layered()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int ParamTextureImage::get_bind_layer(void) const
  int return_value = ((*(const ParamTextureImage*)local_this).get_bind_layer)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ParamTextureImage::ParamTextureImage(Texture *tex, bool read, bool write, int z = -1, int n = 0)
 */
static int Dtool_Init_ParamTextureImage(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline ParamTextureImage::ParamTextureImage(Texture *tex, bool read, bool write, int z = -1, int n = 0)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  int param3 = -1;
  int param4 = 0;
  static const char *keyword_list[] = {"tex", "read", "write", "z", "n", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|ii:ParamTextureImage", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
    Texture *param0_this = (Texture *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Texture, 0, "ParamTextureImage.ParamTextureImage", false, true);
    if (param0_this != nullptr) {
      ParamTextureImage *return_value = new ParamTextureImage(param0_this, (PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (int)param3, (int)param4);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamTextureImage, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamTextureImage(Texture tex, bool read, bool write, int z, int n)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamTextureImage(PyObject *args, CPT(ParamTextureImage) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamTextureImage)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 5) {
      // 1-inline ParamTextureImage::ParamTextureImage(Texture *tex, bool read, bool write, int z = -1, int n = 0)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      int param3 = -1;
      int param4 = 0;
      if (PyArg_ParseTuple(args, "OOO|ii:ParamTextureImage", &param0, &param1, &param2, &param3, &param4)) {
        Texture *param0_this = (Texture *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Texture, 0, "ParamTextureImage.ParamTextureImage", false, false);
        if (param0_this != nullptr) {
          ParamTextureImage *return_value = new ParamTextureImage(param0_this, (PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (int)param3, (int)param4);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ParamTextureImage(PyObject *args, PT(ParamTextureImage) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamTextureImage)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 5) {
      // 1-inline ParamTextureImage::ParamTextureImage(Texture *tex, bool read, bool write, int z = -1, int n = 0)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      int param3 = -1;
      int param4 = 0;
      if (PyArg_ParseTuple(args, "OOO|ii:ParamTextureImage", &param0, &param1, &param2, &param3, &param4)) {
        Texture *param0_this = (Texture *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Texture, 0, "ParamTextureImage.ParamTextureImage", false, false);
        if (param0_this != nullptr) {
          ParamTextureImage *return_value = new ParamTextureImage(param0_this, (PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (int)param3, (int)param4);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ParamTextureImage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamTextureImage) {
    printf("ParamTextureImage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamTextureImage *local_this = (ParamTextureImage *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamTextureImage) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamTextureImage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamTextureImage) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamTextureImage*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamTextureImage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamTextureImage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamTextureImage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamTextureImage*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PerspectiveLens
 */
/**
 * Python function wrapper for:
 * static TypeHandle PerspectiveLens::get_class_type(void)
 */
static PyObject *Dtool_PerspectiveLens_get_class_type_1821(PyObject *, PyObject *) {
  // 1-static TypeHandle PerspectiveLens::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PerspectiveLens::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PerspectiveLens_get_class_type_1821_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PerspectiveLens_get_class_type_1821_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PerspectiveLens::PerspectiveLens(void)
 * inline explicit PerspectiveLens::PerspectiveLens(PN_stdfloat hfov, PN_stdfloat vfov)
 */
static int Dtool_Init_PerspectiveLens(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PerspectiveLens::PerspectiveLens(void)
      PerspectiveLens *return_value = new PerspectiveLens();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerspectiveLens, true, false);
    }
    break;
  case 2:
    {
      // 1-inline explicit PerspectiveLens::PerspectiveLens(PN_stdfloat hfov, PN_stdfloat vfov)
      float param0;
      float param1;
      static const char *keyword_list[] = {"hfov", "vfov", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:PerspectiveLens", (char **)keyword_list, &param0, &param1)) {
        PerspectiveLens *return_value = new PerspectiveLens((PN_stdfloat)param0, (PN_stdfloat)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerspectiveLens, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PerspectiveLens() takes 0 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PerspectiveLens()\n"
      "PerspectiveLens(float hfov, float vfov)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PerspectiveLens(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PerspectiveLens) {
    printf("PerspectiveLens ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PerspectiveLens *local_this = (PerspectiveLens *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PerspectiveLens) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Lens) {
    return (Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(Lens *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PerspectiveLens(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PerspectiveLens) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Lens) {
    Lens* other_this = (Lens*)from_this;
    return (PerspectiveLens*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PerspectiveLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PerspectiveLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PerspectiveLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PerspectiveLens*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextureReloadRequest
 */
/**
 * Python function wrapper for:
 * inline PreparedGraphicsObjects *TextureReloadRequest::get_prepared_graphics_objects(void) const
 */
static PyObject *Dtool_TextureReloadRequest_get_prepared_graphics_objects_1825(PyObject *self, PyObject *) {
  TextureReloadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureReloadRequest)) {
    return nullptr;
  }
  // 1-inline PreparedGraphicsObjects *TextureReloadRequest::get_prepared_graphics_objects(void) const
  PreparedGraphicsObjects *return_value = ((*(const TextureReloadRequest*)local_this).get_prepared_graphics_objects)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PreparedGraphicsObjects, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureReloadRequest_get_prepared_graphics_objects_1825_comment =
  "C++ Interface:\n"
  "get_prepared_graphics_objects(TextureReloadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the PreparedGraphicsObjects object associated with this\n"
  " * asynchronous TextureReloadRequest.\n"
  " */";
#else
static const char *Dtool_TextureReloadRequest_get_prepared_graphics_objects_1825_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *TextureReloadRequest::get_texture(void) const
 */
static PyObject *Dtool_TextureReloadRequest_get_texture_1826(PyObject *self, PyObject *) {
  TextureReloadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureReloadRequest)) {
    return nullptr;
  }
  // 1-inline Texture *TextureReloadRequest::get_texture(void) const
  Texture *return_value = ((*(const TextureReloadRequest*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureReloadRequest_get_texture_1826_comment =
  "C++ Interface:\n"
  "get_texture(TextureReloadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the Texture object associated with this asynchronous\n"
  " * TextureReloadRequest.\n"
  " */";
#else
static const char *Dtool_TextureReloadRequest_get_texture_1826_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureReloadRequest::get_allow_compressed(void) const
 */
static PyObject *Dtool_TextureReloadRequest_get_allow_compressed_1827(PyObject *self, PyObject *) {
  TextureReloadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureReloadRequest)) {
    return nullptr;
  }
  // 1-inline bool TextureReloadRequest::get_allow_compressed(void) const
  bool return_value = ((*(const TextureReloadRequest*)local_this).get_allow_compressed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureReloadRequest_get_allow_compressed_1827_comment =
  "C++ Interface:\n"
  "get_allow_compressed(TextureReloadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the \"allow compressed\" flag associated with this asynchronous\n"
  " * TextureReloadRequest.\n"
  " */";
#else
static const char *Dtool_TextureReloadRequest_get_allow_compressed_1827_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureReloadRequest::is_ready(void) const
 */
static PyObject *Dtool_TextureReloadRequest_is_ready_1828(PyObject *self, PyObject *) {
  TextureReloadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureReloadRequest)) {
    return nullptr;
  }
  // 1-inline bool TextureReloadRequest::is_ready(void) const
  bool return_value = ((*(const TextureReloadRequest*)local_this).is_ready)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureReloadRequest_is_ready_1828_comment =
  "C++ Interface:\n"
  "is_ready(TextureReloadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns true if this request has completed, false if it is still pending.\n"
  " * Equivalent to `req.done() and not req.cancelled()`.\n"
  " * @see done()\n"
  " */";
#else
static const char *Dtool_TextureReloadRequest_is_ready_1828_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextureReloadRequest::get_class_type(void)
 */
static PyObject *Dtool_TextureReloadRequest_get_class_type_1830(PyObject *, PyObject *) {
  // 1-static TypeHandle TextureReloadRequest::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TextureReloadRequest::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureReloadRequest_get_class_type_1830_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextureReloadRequest_get_class_type_1830_comment = nullptr;
#endif

static PyObject *Dtool_TextureReloadRequest_texture_Getter(PyObject *self, void *) {
  const TextureReloadRequest *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureReloadRequest, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture *TextureReloadRequest::get_texture(void) const
  Texture *return_value = ((*(const TextureReloadRequest*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * inline TextureReloadRequest::TextureReloadRequest(TextureReloadRequest const &) = default
 * inline explicit TextureReloadRequest::TextureReloadRequest(std::string const &name, PreparedGraphicsObjects *pgo, Texture *texture, bool allow_compressed)
 */
static int Dtool_Init_TextureReloadRequest(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline TextureReloadRequest::TextureReloadRequest(TextureReloadRequest const &) = default
      TextureReloadRequest const *arg_this = (TextureReloadRequest *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureReloadRequest, 0, "TextureReloadRequest.TextureReloadRequest", true, true);
      if (arg_this != nullptr) {
        TextureReloadRequest *return_value = new TextureReloadRequest(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureReloadRequest, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline explicit TextureReloadRequest::TextureReloadRequest(std::string const &name, PreparedGraphicsObjects *pgo, Texture *texture, bool allow_compressed)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"name", "pgo", "texture", "allow_compressed", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#OOO:TextureReloadRequest", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3)) {
        PreparedGraphicsObjects *param1_this = (PreparedGraphicsObjects *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PreparedGraphicsObjects, 1, "TextureReloadRequest.TextureReloadRequest", false, true);
        Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Texture, 2, "TextureReloadRequest.TextureReloadRequest", false, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          TextureReloadRequest *return_value = new TextureReloadRequest(std::string(param0_str, param0_len), param1_this, param2_this, (PyObject_IsTrue(param3) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureReloadRequest, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextureReloadRequest() takes 1 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextureReloadRequest(const TextureReloadRequest param0)\n"
      "TextureReloadRequest(str name, PreparedGraphicsObjects pgo, Texture texture, bool allow_compressed)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextureReloadRequest(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextureReloadRequest) {
    printf("TextureReloadRequest ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextureReloadRequest *local_this = (TextureReloadRequest *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextureReloadRequest) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncFuture) {
    return (AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextureReloadRequest(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextureReloadRequest) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    AsyncFuture* other_this = (AsyncFuture*)from_this;
    return (TextureReloadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (TextureReloadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (TextureReloadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TextureReloadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TextureReloadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (TextureReloadRequest*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextureContext
 */
/**
 * Python function wrapper for:
 * inline Texture *TextureContext::get_texture(void) const
 */
static PyObject *Dtool_TextureContext_get_texture_1837(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureContext)) {
    return nullptr;
  }
  // 1-inline Texture *TextureContext::get_texture(void) const
  Texture *return_value = ((*(const TextureContext*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_get_texture_1837_comment =
  "C++ Interface:\n"
  "get_texture(TextureContext self)\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the associated Texture object.\n"
  " */";
#else
static const char *Dtool_TextureContext_get_texture_1837_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureContext::get_view(void) const
 */
static PyObject *Dtool_TextureContext_get_view_1838(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureContext)) {
    return nullptr;
  }
  // 1-inline int TextureContext::get_view(void) const
  int return_value = ((*(const TextureContext*)local_this).get_view)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_get_view_1838_comment =
  "C++ Interface:\n"
  "get_view(TextureContext self)\n"
  "\n"
  "/**\n"
  " * Returns the specific view of a multiview texture this context represents.\n"
  " * In the usual case, with a non-multiview texture, this will be 0.\n"
  " */";
#else
static const char *Dtool_TextureContext_get_view_1838_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual uint64_t TextureContext::get_native_id(void) const
 */
static PyObject *Dtool_TextureContext_get_native_id_1839(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureContext)) {
    return nullptr;
  }
  // 1-virtual uint64_t TextureContext::get_native_id(void) const
  uint64_t return_value = ((*(const TextureContext*)local_this).get_native_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_get_native_id_1839_comment =
  "C++ Interface:\n"
  "get_native_id(TextureContext self)\n"
  "\n"
  "/**\n"
  " * Returns an implementation-defined handle or pointer that can be used\n"
  " * to interface directly with the underlying API.\n"
  " * Returns 0 if the underlying implementation does not support this.\n"
  " */";
#else
static const char *Dtool_TextureContext_get_native_id_1839_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual uint64_t TextureContext::get_native_buffer_id(void) const
 */
static PyObject *Dtool_TextureContext_get_native_buffer_id_1840(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureContext)) {
    return nullptr;
  }
  // 1-virtual uint64_t TextureContext::get_native_buffer_id(void) const
  uint64_t return_value = ((*(const TextureContext*)local_this).get_native_buffer_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_get_native_buffer_id_1840_comment =
  "C++ Interface:\n"
  "get_native_buffer_id(TextureContext self)\n"
  "\n"
  "/**\n"
  " * Similar to get_native_id, but some implementations use a separate\n"
  " * identifier for the buffer object associated with buffer textures.\n"
  " * Returns 0 if the underlying implementation does not support this, or\n"
  " * if this is not a buffer texture.\n"
  " */";
#else
static const char *Dtool_TextureContext_get_native_buffer_id_1840_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureContext::was_modified(void) const
 */
static PyObject *Dtool_TextureContext_was_modified_1841(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureContext)) {
    return nullptr;
  }
  // 1-inline bool TextureContext::was_modified(void) const
  bool return_value = ((*(const TextureContext*)local_this).was_modified)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_was_modified_1841_comment =
  "C++ Interface:\n"
  "was_modified(TextureContext self)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture properties or image have been modified since\n"
  " * the last time mark_loaded() was called.\n"
  " */";
#else
static const char *Dtool_TextureContext_was_modified_1841_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureContext::was_properties_modified(void) const
 */
static PyObject *Dtool_TextureContext_was_properties_modified_1842(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureContext)) {
    return nullptr;
  }
  // 1-inline bool TextureContext::was_properties_modified(void) const
  bool return_value = ((*(const TextureContext*)local_this).was_properties_modified)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_was_properties_modified_1842_comment =
  "C++ Interface:\n"
  "was_properties_modified(TextureContext self)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture properties (unrelated to the image) have been\n"
  " * modified since the last time mark_loaded() was called.\n"
  " */";
#else
static const char *Dtool_TextureContext_was_properties_modified_1842_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureContext::was_image_modified(void) const
 */
static PyObject *Dtool_TextureContext_was_image_modified_1843(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureContext)) {
    return nullptr;
  }
  // 1-inline bool TextureContext::was_image_modified(void) const
  bool return_value = ((*(const TextureContext*)local_this).was_image_modified)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_was_image_modified_1843_comment =
  "C++ Interface:\n"
  "was_image_modified(TextureContext self)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture image has been modified since the last time\n"
  " * mark_loaded() was called.\n"
  " */";
#else
static const char *Dtool_TextureContext_was_image_modified_1843_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureContext::was_simple_image_modified(void) const
 */
static PyObject *Dtool_TextureContext_was_simple_image_modified_1844(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureContext)) {
    return nullptr;
  }
  // 1-inline bool TextureContext::was_simple_image_modified(void) const
  bool return_value = ((*(const TextureContext*)local_this).was_simple_image_modified)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_was_simple_image_modified_1844_comment =
  "C++ Interface:\n"
  "was_simple_image_modified(TextureContext self)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture's \"simple\" image has been modified since the\n"
  " * last time mark_simple_loaded() was called.\n"
  " */";
#else
static const char *Dtool_TextureContext_was_simple_image_modified_1844_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq TextureContext::get_properties_modified(void) const
 */
static PyObject *Dtool_TextureContext_get_properties_modified_1845(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureContext)) {
    return nullptr;
  }
  // 1-inline UpdateSeq TextureContext::get_properties_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const TextureContext*)local_this).get_properties_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_get_properties_modified_1845_comment =
  "C++ Interface:\n"
  "get_properties_modified(TextureContext self)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number which is guaranteed to change at least every time\n"
  " * the texture properties (unrelated to the image) are modified.\n"
  " */";
#else
static const char *Dtool_TextureContext_get_properties_modified_1845_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq TextureContext::get_image_modified(void) const
 */
static PyObject *Dtool_TextureContext_get_image_modified_1846(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureContext)) {
    return nullptr;
  }
  // 1-inline UpdateSeq TextureContext::get_image_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const TextureContext*)local_this).get_image_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_get_image_modified_1846_comment =
  "C++ Interface:\n"
  "get_image_modified(TextureContext self)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number which is guaranteed to change at least every time\n"
  " * the texture image data (including mipmap levels) are modified.\n"
  " */";
#else
static const char *Dtool_TextureContext_get_image_modified_1846_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq TextureContext::get_simple_image_modified(void) const
 */
static PyObject *Dtool_TextureContext_get_simple_image_modified_1847(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureContext)) {
    return nullptr;
  }
  // 1-inline UpdateSeq TextureContext::get_simple_image_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const TextureContext*)local_this).get_simple_image_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_get_simple_image_modified_1847_comment =
  "C++ Interface:\n"
  "get_simple_image_modified(TextureContext self)\n"
  "\n"
  "/**\n"
  " * Returns a sequence number which is guaranteed to change at least every time\n"
  " * the texture's \"simple\" image data is modified.\n"
  " */";
#else
static const char *Dtool_TextureContext_get_simple_image_modified_1847_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextureContext::get_class_type(void)
 */
static PyObject *Dtool_TextureContext_get_class_type_1848(PyObject *, PyObject *) {
  // 1-static TypeHandle TextureContext::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TextureContext::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_get_class_type_1848_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextureContext_get_class_type_1848_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BufferContext *TextureContext::upcast_to_BufferContext(void)
 */
static PyObject *Dtool_TextureContext_upcast_to_BufferContext_1833(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureContext, (void **)&local_this, "TextureContext.upcast_to_BufferContext")) {
    return nullptr;
  }
  // 1-BufferContext *TextureContext::upcast_to_BufferContext(void)
  BufferContext *return_value = (BufferContext *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BufferContext, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_upcast_to_BufferContext_1833_comment =
  "C++ Interface:\n"
  "upcast_to_BufferContext(const TextureContext self)\n"
  "\n"
  "upcast from TextureContext to BufferContext";
#else
static const char *Dtool_TextureContext_upcast_to_BufferContext_1833_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AdaptiveLruPage *TextureContext::upcast_to_AdaptiveLruPage(void)
 */
static PyObject *Dtool_TextureContext_upcast_to_AdaptiveLruPage_1835(PyObject *self, PyObject *) {
  TextureContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureContext, (void **)&local_this, "TextureContext.upcast_to_AdaptiveLruPage")) {
    return nullptr;
  }
  // 1-AdaptiveLruPage *TextureContext::upcast_to_AdaptiveLruPage(void)
  AdaptiveLruPage *return_value = (AdaptiveLruPage *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AdaptiveLruPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TextureContext_upcast_to_AdaptiveLruPage_1835_comment =
  "C++ Interface:\n"
  "upcast_to_AdaptiveLruPage(const TextureContext self)\n"
  "\n"
  "upcast from TextureContext to AdaptiveLruPage";
#else
static const char *Dtool_TextureContext_upcast_to_AdaptiveLruPage_1835_comment = nullptr;
#endif

static int Dtool_Init_TextureContext(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TextureContext(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextureContext) {
    printf("TextureContext ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextureContext *local_this = (TextureContext *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextureContext) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AdaptiveLruPage) {
    return (AdaptiveLruPage *) local_this;
  }
  if (requested_type == Dtool_Ptr_BufferContext) {
    return (BufferContext *) local_this;
  }
  if (requested_type == Dtool_Ptr_SavedContext) {
    return (SavedContext *)(BufferContext *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(SavedContext *)(BufferContext *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextureContext(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextureContext) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AdaptiveLruPage) {
    AdaptiveLruPage* other_this = (AdaptiveLruPage*)from_this;
    return (TextureContext*)other_this;
  }
  if (from_type == Dtool_Ptr_BufferContext) {
    BufferContext* other_this = (BufferContext*)from_this;
    return (TextureContext*)other_this;
  }
  if (from_type == Dtool_Ptr_SavedContext) {
    SavedContext* other_this = (SavedContext*)from_this;
    return (TextureContext*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TextureContext*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShaderContext
 */
/**
 * Python function wrapper for:
 * inline Shader *ShaderContext::get_shader(void) const
 */
static PyObject *Dtool_ShaderContext_get_shader_1851(PyObject *self, PyObject *) {
  ShaderContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderContext)) {
    return nullptr;
  }
  // 1-inline Shader *ShaderContext::get_shader(void) const
  Shader *return_value = ((*(const ShaderContext*)local_this).get_shader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Shader, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ShaderContext_get_shader_1851_comment =
  "C++ Interface:\n"
  "get_shader(ShaderContext self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderContext_get_shader_1851_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ShaderContext::get_class_type(void)
 */
static PyObject *Dtool_ShaderContext_get_class_type_1854(PyObject *, PyObject *) {
  // 1-static TypeHandle ShaderContext::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ShaderContext::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderContext_get_class_type_1854_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShaderContext_get_class_type_1854_comment = nullptr;
#endif

static PyObject *Dtool_ShaderContext_shader_Getter(PyObject *self, void *) {
  const ShaderContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderContext, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Shader *ShaderContext::get_shader(void) const
  Shader *return_value = ((*(const ShaderContext*)local_this).get_shader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Shader, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Init_ShaderContext(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ShaderContext(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShaderContext) {
    printf("ShaderContext ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShaderContext *local_this = (ShaderContext *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShaderContext) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_SavedContext) {
    return (SavedContext *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(SavedContext *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShaderContext(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShaderContext) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_SavedContext) {
    SavedContext* other_this = (SavedContext*)from_this;
    return (ShaderContext*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ShaderContext*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class UserVertexSlider
 */
/**
 * Python function wrapper for:
 * inline void UserVertexSlider::set_slider(PN_stdfloat slider)
 */
static PyObject *Dtool_UserVertexSlider_set_slider_1858(PyObject *self, PyObject *arg) {
  UserVertexSlider *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UserVertexSlider, (void **)&local_this, "UserVertexSlider.set_slider")) {
    return nullptr;
  }
  // 1-inline void UserVertexSlider::set_slider(PN_stdfloat slider)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_slider)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slider(const UserVertexSlider self, float slider)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UserVertexSlider_set_slider_1858_comment =
  "C++ Interface:\n"
  "set_slider(const UserVertexSlider self, float slider)\n"
  "\n"
  "/**\n"
  " * Stores the indicated slider value.\n"
  " */";
#else
static const char *Dtool_UserVertexSlider_set_slider_1858_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UserVertexSlider::get_class_type(void)
 */
static PyObject *Dtool_UserVertexSlider_get_class_type_1859(PyObject *, PyObject *) {
  // 1-static TypeHandle UserVertexSlider::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((UserVertexSlider::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UserVertexSlider_get_class_type_1859_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UserVertexSlider_get_class_type_1859_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit UserVertexSlider::UserVertexSlider(InternalName const *name)
 * explicit UserVertexSlider::UserVertexSlider(std::string const &name)
 */
static int Dtool_Init_UserVertexSlider(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "UserVertexSlider() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    {
      // -2 explicit UserVertexSlider::UserVertexSlider(InternalName const *name)
      InternalName const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_InternalName);
      if (arg_this != nullptr) {
        UserVertexSlider *return_value = new UserVertexSlider(arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UserVertexSlider, true, false);
      }
    }

    {
      // -2 explicit UserVertexSlider::UserVertexSlider(std::string const &name)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
        param0_str = nullptr;
      }
#endif
      if (param0_str != nullptr) {
        UserVertexSlider *return_value = new UserVertexSlider(std::string(param0_str, param0_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UserVertexSlider, true, false);
      }
      PyErr_Clear();
    }

    {
      // -2 explicit UserVertexSlider::UserVertexSlider(InternalName const *name)
      CPT(InternalName) arg_this;
      if (Dtool_ConstCoerce_InternalName(arg, arg_this)) {
        UserVertexSlider *return_value = new UserVertexSlider(std::move(arg_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UserVertexSlider, true, false);
      }
    }

    // No coercion possible: explicit UserVertexSlider::UserVertexSlider(std::string const &name)
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UserVertexSlider(const InternalName name)\n"
      "UserVertexSlider(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_UserVertexSlider(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_UserVertexSlider) {
    printf("UserVertexSlider ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  UserVertexSlider *local_this = (UserVertexSlider *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_UserVertexSlider) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_VertexSlider) {
    return (VertexSlider *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_UserVertexSlider(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_UserVertexSlider) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (UserVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (UserVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (UserVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (UserVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_VertexSlider) {
    VertexSlider* other_this = (VertexSlider*)from_this;
    return (UserVertexSlider*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class UserVertexTransform
 */
/**
 * Python function wrapper for:
 * inline std::string const &UserVertexTransform::get_name(void) const
 */
static PyObject *Dtool_UserVertexTransform_get_name_1863(PyObject *self, PyObject *) {
  UserVertexTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UserVertexTransform)) {
    return nullptr;
  }
  // 1-inline std::string const &UserVertexTransform::get_name(void) const
  std::string const &return_value = ((*(const UserVertexTransform*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UserVertexTransform_get_name_1863_comment =
  "C++ Interface:\n"
  "get_name(UserVertexTransform self)\n"
  "\n"
  "/**\n"
  " * Returns the name passed to the constructor.  Completely arbitrary.\n"
  " */";
#else
static const char *Dtool_UserVertexTransform_get_name_1863_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void UserVertexTransform::set_matrix(LMatrix4 const &matrix)
 */
static PyObject *Dtool_UserVertexTransform_set_matrix_1864(PyObject *self, PyObject *arg) {
  UserVertexTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UserVertexTransform, (void **)&local_this, "UserVertexTransform.set_matrix")) {
    return nullptr;
  }
  // 1-inline void UserVertexTransform::set_matrix(LMatrix4 const &matrix)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "UserVertexTransform.set_matrix", "LMatrix4f");
  }
  ((*local_this).set_matrix)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_matrix(const UserVertexTransform self, const LMatrix4f matrix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UserVertexTransform_set_matrix_1864_comment =
  "C++ Interface:\n"
  "set_matrix(const UserVertexTransform self, const LMatrix4f matrix)\n"
  "\n"
  "/**\n"
  " * Stores the indicated matrix.\n"
  " */";
#else
static const char *Dtool_UserVertexTransform_set_matrix_1864_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UserVertexTransform::get_class_type(void)
 */
static PyObject *Dtool_UserVertexTransform_get_class_type_1865(PyObject *, PyObject *) {
  // 1-static TypeHandle UserVertexTransform::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((UserVertexTransform::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UserVertexTransform_get_class_type_1865_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UserVertexTransform_get_class_type_1865_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit UserVertexTransform::UserVertexTransform(std::string const &name)
 */
static int Dtool_Init_UserVertexTransform(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "UserVertexTransform() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit UserVertexTransform::UserVertexTransform(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      UserVertexTransform *return_value = new UserVertexTransform(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UserVertexTransform, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UserVertexTransform(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_UserVertexTransform(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_UserVertexTransform) {
    printf("UserVertexTransform ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  UserVertexTransform *local_this = (UserVertexTransform *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_UserVertexTransform) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_VertexTransform) {
    return (VertexTransform *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_UserVertexTransform(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_UserVertexTransform) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (UserVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (UserVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (UserVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (UserVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_VertexTransform) {
    VertexTransform* other_this = (VertexTransform*)from_this;
    return (UserVertexTransform*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VideoTexture
 */
/**
 * Python function wrapper for:
 * virtual bool VideoTexture::get_keep_ram_image(void) const
 */
static PyObject *Dtool_VideoTexture_get_keep_ram_image_1873(PyObject *self, PyObject *) {
  VideoTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VideoTexture)) {
    return nullptr;
  }
  // 1-virtual bool VideoTexture::get_keep_ram_image(void) const
  bool return_value = ((*(const VideoTexture*)local_this).get_keep_ram_image)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VideoTexture_get_keep_ram_image_1873_comment =
  "C++ Interface:\n"
  "get_keep_ram_image(VideoTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the flag that indicates whether this Texture is eligible to have\n"
  " * its main RAM copy of the texture memory dumped when the texture is prepared\n"
  " * for rendering.  See set_keep_ram_image().\n"
  " */";
#else
static const char *Dtool_VideoTexture_get_keep_ram_image_1873_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int VideoTexture::get_video_width(void) const
 */
static PyObject *Dtool_VideoTexture_get_video_width_1874(PyObject *self, PyObject *) {
  VideoTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VideoTexture)) {
    return nullptr;
  }
  // 1-inline int VideoTexture::get_video_width(void) const
  int return_value = ((*(const VideoTexture*)local_this).get_video_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VideoTexture_get_video_width_1874_comment =
  "C++ Interface:\n"
  "get_video_width(VideoTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the width in texels of the source video stream.  This is not\n"
  " * necessarily the width of the actual texture, since the texture may have\n"
  " * been expanded to raise it to a power of 2.\n"
  " */";
#else
static const char *Dtool_VideoTexture_get_video_width_1874_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int VideoTexture::get_video_height(void) const
 */
static PyObject *Dtool_VideoTexture_get_video_height_1875(PyObject *self, PyObject *) {
  VideoTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VideoTexture)) {
    return nullptr;
  }
  // 1-inline int VideoTexture::get_video_height(void) const
  int return_value = ((*(const VideoTexture*)local_this).get_video_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VideoTexture_get_video_height_1875_comment =
  "C++ Interface:\n"
  "get_video_height(VideoTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the height in texels of the source video stream.  This is not\n"
  " * necessarily the height of the actual texture, since the texture may have\n"
  " * been expanded to raise it to a power of 2.\n"
  " */";
#else
static const char *Dtool_VideoTexture_get_video_height_1875_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VideoTexture::get_class_type(void)
 */
static PyObject *Dtool_VideoTexture_get_class_type_1878(PyObject *, PyObject *) {
  // 1-static TypeHandle VideoTexture::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VideoTexture::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VideoTexture_get_class_type_1878_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VideoTexture_get_class_type_1878_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *VideoTexture::upcast_to_Texture(void)
 */
static PyObject *Dtool_VideoTexture_upcast_to_Texture_1868(PyObject *self, PyObject *) {
  VideoTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VideoTexture, (void **)&local_this, "VideoTexture.upcast_to_Texture")) {
    return nullptr;
  }
  // 1-Texture *VideoTexture::upcast_to_Texture(void)
  Texture *return_value = (Texture *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_VideoTexture_upcast_to_Texture_1868_comment =
  "C++ Interface:\n"
  "upcast_to_Texture(const VideoTexture self)\n"
  "\n"
  "upcast from VideoTexture to Texture";
#else
static const char *Dtool_VideoTexture_upcast_to_Texture_1868_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AnimInterface *VideoTexture::upcast_to_AnimInterface(void)
 */
static PyObject *Dtool_VideoTexture_upcast_to_AnimInterface_1871(PyObject *self, PyObject *) {
  VideoTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VideoTexture, (void **)&local_this, "VideoTexture.upcast_to_AnimInterface")) {
    return nullptr;
  }
  // 1-AnimInterface *VideoTexture::upcast_to_AnimInterface(void)
  AnimInterface *return_value = (AnimInterface *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AnimInterface, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VideoTexture_upcast_to_AnimInterface_1871_comment =
  "C++ Interface:\n"
  "upcast_to_AnimInterface(const VideoTexture self)\n"
  "\n"
  "upcast from VideoTexture to AnimInterface";
#else
static const char *Dtool_VideoTexture_upcast_to_AnimInterface_1871_comment = nullptr;
#endif

static PyObject *Dtool_VideoTexture_video_width_Getter(PyObject *self, void *) {
  const VideoTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VideoTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int VideoTexture::get_video_width(void) const
  int return_value = ((*(const VideoTexture*)local_this).get_video_width)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_VideoTexture_video_height_Getter(PyObject *self, void *) {
  const VideoTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VideoTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int VideoTexture::get_video_height(void) const
  int return_value = ((*(const VideoTexture*)local_this).get_video_height)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_VideoTexture(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VideoTexture(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VideoTexture) {
    printf("VideoTexture ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VideoTexture *local_this = (VideoTexture *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VideoTexture) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimInterface) {
    return (AnimInterface *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_Texture) {
    return (Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(Texture *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VideoTexture(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VideoTexture) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimInterface) {
    AnimInterface* other_this = (AnimInterface*)from_this;
    return (VideoTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (VideoTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VideoTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_Texture) {
    Texture* other_this = (Texture*)from_this;
    return (VideoTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VideoTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (VideoTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (VideoTexture*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VertexBufferContext
 */
/**
 * Python function wrapper for:
 * inline GeomVertexArrayData *VertexBufferContext::get_data(void) const
 */
static PyObject *Dtool_VertexBufferContext_get_data_1885(PyObject *self, PyObject *) {
  VertexBufferContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexBufferContext)) {
    return nullptr;
  }
  // 1-inline GeomVertexArrayData *VertexBufferContext::get_data(void) const
  GeomVertexArrayData *return_value = ((*(const VertexBufferContext*)local_this).get_data)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomVertexArrayData, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_VertexBufferContext_get_data_1885_comment =
  "C++ Interface:\n"
  "get_data(VertexBufferContext self)\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the client-side array data object.\n"
  " */";
#else
static const char *Dtool_VertexBufferContext_get_data_1885_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool VertexBufferContext::changed_size(GeomVertexArrayDataHandle const *reader) const
 */
static PyObject *Dtool_VertexBufferContext_changed_size_1886(PyObject *self, PyObject *arg) {
  VertexBufferContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexBufferContext)) {
    return nullptr;
  }
  // 1-inline bool VertexBufferContext::changed_size(GeomVertexArrayDataHandle const *reader) const
  GeomVertexArrayDataHandle const *arg_this = (GeomVertexArrayDataHandle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayDataHandle, 1, "VertexBufferContext.changed_size", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const VertexBufferContext*)local_this).changed_size)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "changed_size(VertexBufferContext self, const GeomVertexArrayDataHandle reader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexBufferContext_changed_size_1886_comment =
  "C++ Interface:\n"
  "changed_size(VertexBufferContext self, const GeomVertexArrayDataHandle reader)\n"
  "\n"
  "/**\n"
  " * Returns true if the data has changed size since the last time mark_loaded()\n"
  " * was called.\n"
  " */";
#else
static const char *Dtool_VertexBufferContext_changed_size_1886_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool VertexBufferContext::changed_usage_hint(GeomVertexArrayDataHandle const *reader) const
 */
static PyObject *Dtool_VertexBufferContext_changed_usage_hint_1887(PyObject *self, PyObject *arg) {
  VertexBufferContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexBufferContext)) {
    return nullptr;
  }
  // 1-inline bool VertexBufferContext::changed_usage_hint(GeomVertexArrayDataHandle const *reader) const
  GeomVertexArrayDataHandle const *arg_this = (GeomVertexArrayDataHandle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayDataHandle, 1, "VertexBufferContext.changed_usage_hint", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const VertexBufferContext*)local_this).changed_usage_hint)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "changed_usage_hint(VertexBufferContext self, const GeomVertexArrayDataHandle reader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexBufferContext_changed_usage_hint_1887_comment =
  "C++ Interface:\n"
  "changed_usage_hint(VertexBufferContext self, const GeomVertexArrayDataHandle reader)\n"
  "\n"
  "/**\n"
  " * Returns true if the data has changed its usage hint since the last time\n"
  " * mark_loaded() was called.\n"
  " */";
#else
static const char *Dtool_VertexBufferContext_changed_usage_hint_1887_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool VertexBufferContext::was_modified(GeomVertexArrayDataHandle const *reader) const
 */
static PyObject *Dtool_VertexBufferContext_was_modified_1888(PyObject *self, PyObject *arg) {
  VertexBufferContext *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VertexBufferContext)) {
    return nullptr;
  }
  // 1-inline bool VertexBufferContext::was_modified(GeomVertexArrayDataHandle const *reader) const
  GeomVertexArrayDataHandle const *arg_this = (GeomVertexArrayDataHandle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayDataHandle, 1, "VertexBufferContext.was_modified", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const VertexBufferContext*)local_this).was_modified)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "was_modified(VertexBufferContext self, const GeomVertexArrayDataHandle reader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VertexBufferContext_was_modified_1888_comment =
  "C++ Interface:\n"
  "was_modified(VertexBufferContext self, const GeomVertexArrayDataHandle reader)\n"
  "\n"
  "/**\n"
  " * Returns true if the data has been modified since the last time\n"
  " * mark_loaded() was called.\n"
  " */";
#else
static const char *Dtool_VertexBufferContext_was_modified_1888_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VertexBufferContext::get_class_type(void)
 */
static PyObject *Dtool_VertexBufferContext_get_class_type_1889(PyObject *, PyObject *) {
  // 1-static TypeHandle VertexBufferContext::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VertexBufferContext::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexBufferContext_get_class_type_1889_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VertexBufferContext_get_class_type_1889_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BufferContext *VertexBufferContext::upcast_to_BufferContext(void)
 */
static PyObject *Dtool_VertexBufferContext_upcast_to_BufferContext_1881(PyObject *self, PyObject *) {
  VertexBufferContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VertexBufferContext, (void **)&local_this, "VertexBufferContext.upcast_to_BufferContext")) {
    return nullptr;
  }
  // 1-BufferContext *VertexBufferContext::upcast_to_BufferContext(void)
  BufferContext *return_value = (BufferContext *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BufferContext, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_VertexBufferContext_upcast_to_BufferContext_1881_comment =
  "C++ Interface:\n"
  "upcast_to_BufferContext(const VertexBufferContext self)\n"
  "\n"
  "upcast from VertexBufferContext to BufferContext";
#else
static const char *Dtool_VertexBufferContext_upcast_to_BufferContext_1881_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AdaptiveLruPage *VertexBufferContext::upcast_to_AdaptiveLruPage(void)
 */
static PyObject *Dtool_VertexBufferContext_upcast_to_AdaptiveLruPage_1883(PyObject *self, PyObject *) {
  VertexBufferContext *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VertexBufferContext, (void **)&local_this, "VertexBufferContext.upcast_to_AdaptiveLruPage")) {
    return nullptr;
  }
  // 1-AdaptiveLruPage *VertexBufferContext::upcast_to_AdaptiveLruPage(void)
  AdaptiveLruPage *return_value = (AdaptiveLruPage *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AdaptiveLruPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VertexBufferContext_upcast_to_AdaptiveLruPage_1883_comment =
  "C++ Interface:\n"
  "upcast_to_AdaptiveLruPage(const VertexBufferContext self)\n"
  "\n"
  "upcast from VertexBufferContext to AdaptiveLruPage";
#else
static const char *Dtool_VertexBufferContext_upcast_to_AdaptiveLruPage_1883_comment = nullptr;
#endif

static int Dtool_Init_VertexBufferContext(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VertexBufferContext(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VertexBufferContext) {
    printf("VertexBufferContext ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VertexBufferContext *local_this = (VertexBufferContext *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VertexBufferContext) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AdaptiveLruPage) {
    return (AdaptiveLruPage *) local_this;
  }
  if (requested_type == Dtool_Ptr_BufferContext) {
    return (BufferContext *) local_this;
  }
  if (requested_type == Dtool_Ptr_SavedContext) {
    return (SavedContext *)(BufferContext *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(SavedContext *)(BufferContext *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VertexBufferContext(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VertexBufferContext) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AdaptiveLruPage) {
    AdaptiveLruPage* other_this = (AdaptiveLruPage*)from_this;
    return (VertexBufferContext*)other_this;
  }
  if (from_type == Dtool_Ptr_BufferContext) {
    BufferContext* other_this = (BufferContext*)from_this;
    return (VertexBufferContext*)other_this;
  }
  if (from_type == Dtool_Ptr_SavedContext) {
    SavedContext* other_this = (SavedContext*)from_this;
    return (VertexBufferContext*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VertexBufferContext*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextureCollection
 */
/**
 * Python function wrapper for:
 * void TextureCollection::operator =(TextureCollection const &copy)
 */
static PyObject *Dtool_TextureCollection_operator_1893(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureCollection, (void **)&local_this, "TextureCollection.assign")) {
    return nullptr;
  }
  // 1-void TextureCollection::operator =(TextureCollection const &copy)
  TextureCollection arg_local;
  TextureCollection const *arg_this = Dtool_Coerce_TextureCollection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TextureCollection.assign", "TextureCollection");
  }
  ((*local_this).operator =)(*arg_this);
  TextureCollection *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureCollection, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TextureCollection self, const TextureCollection copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_operator_1893_comment =
  "C++ Interface:\n"
  "assign(const TextureCollection self, const TextureCollection copy)\n";
#else
static const char *Dtool_TextureCollection_operator_1893_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *TextureCollection::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_TextureCollection_reduce_1895(PyObject *self, PyObject *) {
  TextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureCollection)) {
    return nullptr;
  }
  // 1-PyObject *TextureCollection::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const TextureCollection*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_reduce_1895_comment =
  "C++ Interface:\n"
  "__reduce__(TextureCollection self)\n";
#else
static const char *Dtool_TextureCollection_reduce_1895_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureCollection::add_texture(Texture *texture)
 */
static PyObject *Dtool_TextureCollection_add_texture_1896(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureCollection, (void **)&local_this, "TextureCollection.add_texture")) {
    return nullptr;
  }
  // 1-void TextureCollection::add_texture(Texture *texture)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "TextureCollection.add_texture", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_texture)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_texture(const TextureCollection self, Texture texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_add_texture_1896_comment =
  "C++ Interface:\n"
  "add_texture(const TextureCollection self, Texture texture)\n"
  "\n"
  "/**\n"
  " * Adds a new Texture to the collection.\n"
  " */";
#else
static const char *Dtool_TextureCollection_add_texture_1896_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextureCollection::remove_texture(Texture *texture)
 */
static PyObject *Dtool_TextureCollection_remove_texture_1897(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureCollection, (void **)&local_this, "TextureCollection.remove_texture")) {
    return nullptr;
  }
  // 1-bool TextureCollection::remove_texture(Texture *texture)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "TextureCollection.remove_texture", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_texture)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_texture(const TextureCollection self, Texture texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_remove_texture_1897_comment =
  "C++ Interface:\n"
  "remove_texture(const TextureCollection self, Texture texture)\n"
  "\n"
  "/**\n"
  " * Removes the indicated Texture from the collection.  Returns true if the\n"
  " * texture was removed, false if it was not a member of the collection.\n"
  " */";
#else
static const char *Dtool_TextureCollection_remove_texture_1897_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureCollection::add_textures_from(TextureCollection const &other)
 */
static PyObject *Dtool_TextureCollection_add_textures_from_1898(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureCollection, (void **)&local_this, "TextureCollection.add_textures_from")) {
    return nullptr;
  }
  // 1-void TextureCollection::add_textures_from(TextureCollection const &other)
  TextureCollection arg_local;
  TextureCollection const *arg_this = Dtool_Coerce_TextureCollection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TextureCollection.add_textures_from", "TextureCollection");
  }
  ((*local_this).add_textures_from)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_textures_from(const TextureCollection self, const TextureCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_add_textures_from_1898_comment =
  "C++ Interface:\n"
  "add_textures_from(const TextureCollection self, const TextureCollection other)\n"
  "\n"
  "/**\n"
  " * Adds all the Textures indicated in the other collection to this texture.\n"
  " * The other textures are simply appended to the end of the textures in this\n"
  " * list; duplicates are not automatically removed.\n"
  " */";
#else
static const char *Dtool_TextureCollection_add_textures_from_1898_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureCollection::remove_textures_from(TextureCollection const &other)
 */
static PyObject *Dtool_TextureCollection_remove_textures_from_1899(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureCollection, (void **)&local_this, "TextureCollection.remove_textures_from")) {
    return nullptr;
  }
  // 1-void TextureCollection::remove_textures_from(TextureCollection const &other)
  TextureCollection arg_local;
  TextureCollection const *arg_this = Dtool_Coerce_TextureCollection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TextureCollection.remove_textures_from", "TextureCollection");
  }
  ((*local_this).remove_textures_from)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_textures_from(const TextureCollection self, const TextureCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_remove_textures_from_1899_comment =
  "C++ Interface:\n"
  "remove_textures_from(const TextureCollection self, const TextureCollection other)\n"
  "\n"
  "/**\n"
  " * Removes from this collection all of the Textures listed in the other\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_TextureCollection_remove_textures_from_1899_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureCollection::remove_duplicate_textures(void)
 */
static PyObject *Dtool_TextureCollection_remove_duplicate_textures_1900(PyObject *self, PyObject *) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureCollection, (void **)&local_this, "TextureCollection.remove_duplicate_textures")) {
    return nullptr;
  }
  // 1-void TextureCollection::remove_duplicate_textures(void)
  ((*local_this).remove_duplicate_textures)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_remove_duplicate_textures_1900_comment =
  "C++ Interface:\n"
  "remove_duplicate_textures(const TextureCollection self)\n"
  "\n"
  "/**\n"
  " * Removes any duplicate entries of the same Textures on this collection.  If\n"
  " * a Texture appears multiple times, the first appearance is retained;\n"
  " * subsequent appearances are removed.\n"
  " */";
#else
static const char *Dtool_TextureCollection_remove_duplicate_textures_1900_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextureCollection::has_texture(Texture *texture) const
 */
static PyObject *Dtool_TextureCollection_has_texture_1901(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureCollection)) {
    return nullptr;
  }
  // 1-bool TextureCollection::has_texture(Texture *texture) const
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "TextureCollection.has_texture", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const TextureCollection*)local_this).has_texture)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_texture(TextureCollection self, Texture texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_has_texture_1901_comment =
  "C++ Interface:\n"
  "has_texture(TextureCollection self, Texture texture)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated Texture appears in this collection, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_TextureCollection_has_texture_1901_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureCollection::clear(void)
 */
static PyObject *Dtool_TextureCollection_clear_1902(PyObject *self, PyObject *) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureCollection, (void **)&local_this, "TextureCollection.clear")) {
    return nullptr;
  }
  // 1-void TextureCollection::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_clear_1902_comment =
  "C++ Interface:\n"
  "clear(const TextureCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all Textures from the collection.\n"
  " */";
#else
static const char *Dtool_TextureCollection_clear_1902_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureCollection::reserve(std::size_t num)
 */
static PyObject *Dtool_TextureCollection_reserve_1903(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureCollection, (void **)&local_this, "TextureCollection.reserve")) {
    return nullptr;
  }
  // 1-void TextureCollection::reserve(std::size_t num)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).reserve)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reserve(const TextureCollection self, int num)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_reserve_1903_comment =
  "C++ Interface:\n"
  "reserve(const TextureCollection self, int num)\n"
  "\n"
  "/**\n"
  " * This is a hint to Panda to allocate enough memory to hold the given number\n"
  " * of NodePaths, if you know ahead of time how many you will be adding.\n"
  " */";
#else
static const char *Dtool_TextureCollection_reserve_1903_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *TextureCollection::find_texture(std::string const &name) const
 */
static PyObject *Dtool_TextureCollection_find_texture_1904(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureCollection)) {
    return nullptr;
  }
  // 1-Texture *TextureCollection::find_texture(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    Texture *return_value = ((*(const TextureCollection*)local_this).find_texture)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_texture(TextureCollection self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_find_texture_1904_comment =
  "C++ Interface:\n"
  "find_texture(TextureCollection self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the texture in the collection with the indicated name, if any, or\n"
  " * NULL if no texture has that name.\n"
  " */";
#else
static const char *Dtool_TextureCollection_find_texture_1904_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TextureCollection::get_num_textures(void) const
 */
static PyObject *Dtool_TextureCollection_get_num_textures_1905(PyObject *self, PyObject *) {
  TextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureCollection)) {
    return nullptr;
  }
  // 1-int TextureCollection::get_num_textures(void) const
  int return_value = ((*(const TextureCollection*)local_this).get_num_textures)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_get_num_textures_1905_comment =
  "C++ Interface:\n"
  "get_num_textures(TextureCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of Textures in the collection.\n"
  " */";
#else
static const char *Dtool_TextureCollection_get_num_textures_1905_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *TextureCollection::get_texture(int index) const
 */
static PyObject *Dtool_TextureCollection_get_texture_1906(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureCollection)) {
    return nullptr;
  }
  // 1-Texture *TextureCollection::get_texture(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Texture *return_value = ((*(const TextureCollection*)local_this).get_texture)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture(TextureCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_get_texture_1906_comment =
  "C++ Interface:\n"
  "get_texture(TextureCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth Texture in the collection.\n"
  " */";
#else
static const char *Dtool_TextureCollection_get_texture_1906_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureCollection::append(Texture *texture)
 */
static PyObject *Dtool_TextureCollection_append_1912(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureCollection, (void **)&local_this, "TextureCollection.append")) {
    return nullptr;
  }
  // 1-inline void TextureCollection::append(Texture *texture)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "TextureCollection.append", false, true);
  if (arg_this != nullptr) {
    ((*local_this).append)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append(const TextureCollection self, Texture texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_append_1912_comment =
  "C++ Interface:\n"
  "append(const TextureCollection self, Texture texture)\n"
  "\n"
  "// Method names to satisfy Python's conventions.\n"
  "\n"
  "/**\n"
  " * Adds a new Texture to the collection.  This method duplicates the\n"
  " * add_texture() method; it is provided to satisfy Python's naming convention.\n"
  " */";
#else
static const char *Dtool_TextureCollection_append_1912_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextureCollection::extend(TextureCollection const &other)
 */
static PyObject *Dtool_TextureCollection_extend_1913(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextureCollection, (void **)&local_this, "TextureCollection.extend")) {
    return nullptr;
  }
  // 1-inline void TextureCollection::extend(TextureCollection const &other)
  TextureCollection arg_local;
  TextureCollection const *arg_this = Dtool_Coerce_TextureCollection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TextureCollection.extend", "TextureCollection");
  }
  ((*local_this).extend)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extend(const TextureCollection self, const TextureCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_extend_1913_comment =
  "C++ Interface:\n"
  "extend(const TextureCollection self, const TextureCollection other)\n"
  "\n"
  "/**\n"
  " * Appends the other list onto the end of this one.  This method duplicates\n"
  " * the += operator; it is provided to satisfy Python's naming convention.\n"
  " */";
#else
static const char *Dtool_TextureCollection_extend_1913_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureCollection::output(std::ostream &out) const
 */
static PyObject *Dtool_TextureCollection_output_1914(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureCollection)) {
    return nullptr;
  }
  // 1-void TextureCollection::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "TextureCollection.output", false, true);
  if (arg_this != nullptr) {
    ((*(const TextureCollection*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(TextureCollection self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_output_1914_comment =
  "C++ Interface:\n"
  "output(TextureCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the TextureCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_TextureCollection_output_1914_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextureCollection::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_TextureCollection_write_1915(PyObject *self, PyObject *args, PyObject *kwds) {
  TextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureCollection)) {
    return nullptr;
  }
  // 1-void TextureCollection::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "TextureCollection.write", false, true);
    if (param1_this != nullptr) {
      ((*(const TextureCollection*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TextureCollection self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureCollection_write_1915_comment =
  "C++ Interface:\n"
  "write(TextureCollection self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the TextureCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_TextureCollection_write_1915_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextureCollection::TextureCollection(void)
 * TextureCollection::TextureCollection(PyObject *self, PyObject *sequence)
 * TextureCollection::TextureCollection(TextureCollection const &copy)
 */
static int Dtool_Init_TextureCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TextureCollection::TextureCollection(void)
      TextureCollection *return_value = new TextureCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureCollection, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 TextureCollection::TextureCollection(TextureCollection const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          TextureCollection const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TextureCollection);
          if (param0_this != nullptr) {
            TextureCollection *return_value = new TextureCollection(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureCollection, true, false);
          }
        }
      }

      {
        // -2 TextureCollection::TextureCollection(PyObject *self, PyObject *sequence)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "sequence")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_TextureCollection, false, false);
          TextureCollection *result = new TextureCollection;
          invoke_extension(result).__init__(self, param0);
          TextureCollection *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureCollection, true, false);
          }
        }
      }

      {
        // -2 TextureCollection::TextureCollection(TextureCollection const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          TextureCollection param0_local;
          TextureCollection const *param0_this = Dtool_Coerce_TextureCollection(param0, param0_local);
          if ((param0_this != nullptr)) {
            TextureCollection *return_value = new TextureCollection(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureCollection, true, false);
          }
        }
      }

      // No coercion possible: TextureCollection::TextureCollection(PyObject *self, PyObject *sequence)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextureCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextureCollection()\n"
      "TextureCollection(const TextureCollection copy)\n"
      "TextureCollection(object sequence)\n");
  }
  return -1;
}

TextureCollection *Dtool_Coerce_TextureCollection(PyObject *args, TextureCollection &coerced) {
  TextureCollection *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_TextureCollection)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const TextureCollection *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-TextureCollection::TextureCollection(PyObject *self, PyObject *sequence)
    // Pre-initialize self for the constructor
    PyObject *self = Dtool_new_TextureCollection(&Dtool_TextureCollection._PyType, nullptr, nullptr);
    invoke_extension(&coerced).__init__(self, arg);
    PyObject_Del(self);
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      return nullptr;
    } else {
      return &coerced;
    }
  }
  return nullptr;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TextureCollection_get_textures(PyObject *self, PyObject *) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_textures)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TextureCollection_get_texture_1906(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_TextureCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextureCollection) {
    printf("TextureCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextureCollection *local_this = (TextureCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextureCollection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextureCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextureCollection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TexturePool
 */
/**
 * Python function wrapper for:
 * static inline bool TexturePool::has_texture(Filename const &filename)
 */
static PyObject *Dtool_TexturePool_has_texture_1917(PyObject *, PyObject *arg) {
  // 1-static inline bool TexturePool::has_texture(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "TexturePool.has_texture", "Filename");
  }
  bool return_value = (TexturePool::has_texture)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_texture(const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_has_texture_1917_comment =
  "C++ Interface:\n"
  "has_texture(const Filename filename)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture has ever been loaded, false otherwise.\n"
  " */";
#else
static const char *Dtool_TexturePool_has_texture_1917_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool TexturePool::verify_texture(Filename const &filename)
 */
static PyObject *Dtool_TexturePool_verify_texture_1918(PyObject *, PyObject *arg) {
  // 1-static inline bool TexturePool::verify_texture(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "TexturePool.verify_texture", "Filename");
  }
  bool return_value = (TexturePool::verify_texture)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "verify_texture(const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_verify_texture_1918_comment =
  "C++ Interface:\n"
  "verify_texture(const Filename filename)\n"
  "\n"
  "/**\n"
  " * Loads the given filename up into a texture, if it has not already been\n"
  " * loaded, and returns true to indicate success, or false to indicate failure.\n"
  " * If this returns true, it is guaranteed that a subsequent call to\n"
  " * load_texture() with the same texture name will return a valid Texture\n"
  " * pointer.\n"
  " */";
#else
static const char *Dtool_TexturePool_verify_texture_1918_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Texture *TexturePool::load_texture(Filename const &filename, Filename const &alpha_filename, int primary_file_num_channels = 0, int alpha_file_channel = 0, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
 * static inline Texture *TexturePool::load_texture(Filename const &filename, int primary_file_num_channels = 0, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
 */
static PyObject *Dtool_TexturePool_load_texture_1919(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "filename")) {
        // 1-static inline Texture *TexturePool::load_texture(Filename const &filename, int primary_file_num_channels, bool read_mipmaps, LoaderOptions const &options)
        Filename arg_local;
        Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 0, "TexturePool.load_texture", "Filename");
        }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        Texture *return_value = (TexturePool::load_texture)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 2:
  case 3:
  case 4:
  case 5:
  case 6:
    {
      {
        // -2 static inline Texture *TexturePool::load_texture(Filename const &filename, Filename const &alpha_filename, int primary_file_num_channels = 0, int alpha_file_channel = 0, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
        PyObject *param0;
        PyObject *param1;
        int param2 = 0;
        int param3 = 0;
        PyObject *param4 = Py_False;
        PyObject *param5 = nullptr;
        static const char *keyword_list[] = {"filename", "alpha_filename", "primary_file_num_channels", "alpha_file_channel", "read_mipmaps", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|iiOO:load_texture", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          Filename const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
          Filename const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
          LoaderOptions const *param5_this;
          const LoaderOptions &param5_ref = LoaderOptions();
          if (param5 == nullptr) {
            param5_this = &param5_ref;
          } else {
            param5_this = nullptr;
            DtoolInstance_GetPointer(param5, param5_this, *Dtool_Ptr_LoaderOptions);
          }
          if (param0_this != nullptr && param1_this != nullptr && (param5 == nullptr || param5_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            Texture *return_value = (TexturePool::load_texture)(*param0_this, *param1_this, (int)param2, (int)param3, (PyObject_IsTrue(param4) != 0), *param5_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (Dtool_CheckErrorOccurred()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return nullptr;
            }
            if (return_value == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 static inline Texture *TexturePool::load_texture(Filename const &filename, int primary_file_num_channels = 0, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
        PyObject *param0;
        int param1;
        PyObject *param2 = Py_False;
        PyObject *param3 = nullptr;
        static const char *keyword_list[] = {"filename", "primary_file_num_channels", "read_mipmaps", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi|OO:load_texture", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          Filename const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
          LoaderOptions const *param3_this;
          const LoaderOptions &param3_ref = LoaderOptions();
          if (param3 == nullptr) {
            param3_this = &param3_ref;
          } else {
            param3_this = nullptr;
            DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LoaderOptions);
          }
          if (param0_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            Texture *return_value = (TexturePool::load_texture)(*param0_this, (int)param1, (PyObject_IsTrue(param2) != 0), *param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (Dtool_CheckErrorOccurred()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return nullptr;
            }
            if (return_value == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 static inline Texture *TexturePool::load_texture(Filename const &filename, Filename const &alpha_filename, int primary_file_num_channels = 0, int alpha_file_channel = 0, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
        PyObject *param0;
        PyObject *param1;
        int param2 = 0;
        int param3 = 0;
        PyObject *param4 = Py_False;
        PyObject *param5 = nullptr;
        static const char *keyword_list[] = {"filename", "alpha_filename", "primary_file_num_channels", "alpha_file_channel", "read_mipmaps", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|iiOO:load_texture", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          Filename param1_local;
          Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
          LoaderOptions param5_local;
          LoaderOptions const *param5_this;
          if (param5 != nullptr) {
            param5_this = Dtool_Coerce_LoaderOptions(param5, param5_local);
          } else {
            param5_local = LoaderOptions();
            param5_this = &param5_local;
          }
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param5 == nullptr || (param5_this != nullptr))) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            Texture *return_value = (TexturePool::load_texture)(*param0_this, *param1_this, (int)param2, (int)param3, (PyObject_IsTrue(param4) != 0), *param5_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (Dtool_CheckErrorOccurred()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return nullptr;
            }
            if (return_value == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 static inline Texture *TexturePool::load_texture(Filename const &filename, int primary_file_num_channels = 0, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
        PyObject *param0;
        int param1;
        PyObject *param2 = Py_False;
        PyObject *param3 = nullptr;
        static const char *keyword_list[] = {"filename", "primary_file_num_channels", "read_mipmaps", "options", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi|OO:load_texture", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          LoaderOptions param3_local;
          LoaderOptions const *param3_this;
          if (param3 != nullptr) {
            param3_this = Dtool_Coerce_LoaderOptions(param3, param3_local);
          } else {
            param3_local = LoaderOptions();
            param3_this = &param3_local;
          }
          if ((param0_this != nullptr) && (param3 == nullptr || (param3_this != nullptr))) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            Texture *return_value = (TexturePool::load_texture)(*param0_this, (int)param1, (PyObject_IsTrue(param2) != 0), *param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (Dtool_CheckErrorOccurred()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return nullptr;
            }
            if (return_value == nullptr) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "load_texture() takes 1, 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_texture(const Filename filename)\n"
      "load_texture(const Filename filename, const Filename alpha_filename, int primary_file_num_channels, int alpha_file_channel, bool read_mipmaps, const LoaderOptions options)\n"
      "load_texture(const Filename filename, int primary_file_num_channels, bool read_mipmaps, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_load_texture_1919_comment =
  "C++ Interface:\n"
  "load_texture(const Filename filename)\n"
  "load_texture(const Filename filename, const Filename alpha_filename, int primary_file_num_channels, int alpha_file_channel, bool read_mipmaps, const LoaderOptions options)\n"
  "load_texture(const Filename filename, int primary_file_num_channels, bool read_mipmaps, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Loads the given filename up into a texture, if it has not already been\n"
  " * loaded, and returns the new texture.  If a texture with the same filename\n"
  " * was previously loaded, returns that one instead.  If the texture file\n"
  " * cannot be found, returns NULL.\n"
  " *\n"
  " * If read_mipmaps is true, the filename should contain a hash mark ('#'),\n"
  " * which will be filled in with the mipmap level number; and the texture will\n"
  " * be defined with a series of images, one for each mipmap level.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Loads the given filename up into a texture, if it has not already been\n"
  " * loaded, and returns the new texture.  If a texture with the same filename\n"
  " * was previously loaded, returns that one instead.  If the texture file\n"
  " * cannot be found, returns NULL.\n"
  " *\n"
  " * If read_mipmaps is true, both filenames should contain a hash mark ('#'),\n"
  " * which will be filled in with the mipmap level number; and the texture will\n"
  " * be defined with a series of images, two for each mipmap level.\n"
  " */";
#else
static const char *Dtool_TexturePool_load_texture_1919_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Texture *TexturePool::load_3d_texture(Filename const &filename_pattern, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
 */
static PyObject *Dtool_TexturePool_load_3d_texture_1920(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline Texture *TexturePool::load_3d_texture(Filename const &filename_pattern, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
  PyObject *param0;
  PyObject *param1 = Py_False;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"filename_pattern", "read_mipmaps", "options", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:load_3d_texture", (char **)keyword_list, &param0, &param1, &param2)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "TexturePool.load_3d_texture", "Filename");
    }
    LoaderOptions param2_local;
    LoaderOptions const *param2_this;
    if (param2 != nullptr) {
      param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
    } else {
      param2_local = LoaderOptions();
      param2_this = &param2_local;
    }
    if (param2 != nullptr && !(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TexturePool.load_3d_texture", "LoaderOptions");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    Texture *return_value = (TexturePool::load_3d_texture)(*param0_this, (PyObject_IsTrue(param1) != 0), *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_3d_texture(const Filename filename_pattern, bool read_mipmaps, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_load_3d_texture_1920_comment =
  "C++ Interface:\n"
  "load_3d_texture(const Filename filename_pattern, bool read_mipmaps, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Loads a 3-D texture that is specified with a series of n pages, all\n"
  " * numbered in sequence, and beginning with index 0.  The filename should\n"
  " * include a sequence of one or more hash characters (\"#\") which will be\n"
  " * filled in with the index number of each level.\n"
  " *\n"
  " * If read_mipmaps is true, the filename should contain an additional hash\n"
  " * mark.  The first hash mark will be filled in with the mipmap level number,\n"
  " * and the second with the index number of each 3-d level.\n"
  " */";
#else
static const char *Dtool_TexturePool_load_3d_texture_1920_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Texture *TexturePool::load_2d_texture_array(Filename const &filename_pattern, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
 */
static PyObject *Dtool_TexturePool_load_2d_texture_array_1921(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline Texture *TexturePool::load_2d_texture_array(Filename const &filename_pattern, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
  PyObject *param0;
  PyObject *param1 = Py_False;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"filename_pattern", "read_mipmaps", "options", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:load_2d_texture_array", (char **)keyword_list, &param0, &param1, &param2)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "TexturePool.load_2d_texture_array", "Filename");
    }
    LoaderOptions param2_local;
    LoaderOptions const *param2_this;
    if (param2 != nullptr) {
      param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
    } else {
      param2_local = LoaderOptions();
      param2_this = &param2_local;
    }
    if (param2 != nullptr && !(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TexturePool.load_2d_texture_array", "LoaderOptions");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    Texture *return_value = (TexturePool::load_2d_texture_array)(*param0_this, (PyObject_IsTrue(param1) != 0), *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_2d_texture_array(const Filename filename_pattern, bool read_mipmaps, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_load_2d_texture_array_1921_comment =
  "C++ Interface:\n"
  "load_2d_texture_array(const Filename filename_pattern, bool read_mipmaps, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Loads a 2-D texture array that is specified with a series of n pages, all\n"
  " * numbered in sequence, and beginning with index 0.  The filename should\n"
  " * include a sequence of one or more hash characters (\"#\") which will be\n"
  " * filled in with the index number of each level.\n"
  " *\n"
  " * If read_mipmaps is true, the filename should contain an additional hash\n"
  " * mark.  The first hash mark will be filled in with the mipmap level number,\n"
  " * and the second with the index number of each 2-d level.\n"
  " */";
#else
static const char *Dtool_TexturePool_load_2d_texture_array_1921_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Texture *TexturePool::load_cube_map(Filename const &filename_pattern, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
 */
static PyObject *Dtool_TexturePool_load_cube_map_1922(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline Texture *TexturePool::load_cube_map(Filename const &filename_pattern, bool read_mipmaps = false, LoaderOptions const &options = LoaderOptions())
  PyObject *param0;
  PyObject *param1 = Py_False;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"filename_pattern", "read_mipmaps", "options", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:load_cube_map", (char **)keyword_list, &param0, &param1, &param2)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "TexturePool.load_cube_map", "Filename");
    }
    LoaderOptions param2_local;
    LoaderOptions const *param2_this;
    if (param2 != nullptr) {
      param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
    } else {
      param2_local = LoaderOptions();
      param2_this = &param2_local;
    }
    if (param2 != nullptr && !(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TexturePool.load_cube_map", "LoaderOptions");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    Texture *return_value = (TexturePool::load_cube_map)(*param0_this, (PyObject_IsTrue(param1) != 0), *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_cube_map(const Filename filename_pattern, bool read_mipmaps, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_load_cube_map_1922_comment =
  "C++ Interface:\n"
  "load_cube_map(const Filename filename_pattern, bool read_mipmaps, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Loads a cube map texture that is specified with a series of 6 pages,\n"
  " * numbered 0 through 5.  The filename should include a sequence of one or\n"
  " * more hash characters (\"#\") which will be filled in with the index number of\n"
  " * each pagee.\n"
  " *\n"
  " * If read_mipmaps is true, the filename should contain an additional hash\n"
  " * mark.  The first hash mark will be filled in with the mipmap level number,\n"
  " * and the second with the face number, 0 through 5.\n"
  " */";
#else
static const char *Dtool_TexturePool_load_cube_map_1922_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Texture *TexturePool::get_normalization_cube_map(int size)
 */
static PyObject *Dtool_TexturePool_get_normalization_cube_map_1923(PyObject *, PyObject *arg) {
  // 1-static inline Texture *TexturePool::get_normalization_cube_map(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Texture *return_value = (TexturePool::get_normalization_cube_map)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_normalization_cube_map(int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_get_normalization_cube_map_1923_comment =
  "C++ Interface:\n"
  "get_normalization_cube_map(int size)\n"
  "\n"
  "/**\n"
  " * Returns a standard Texture object that has been created with\n"
  " * Texture::generate_normalization_cube_map().  This Texture may be shared by\n"
  " * any application code requiring a normalization cube map.  It will be at\n"
  " * least as large as the specified size, though it may be larger.\n"
  " */";
#else
static const char *Dtool_TexturePool_get_normalization_cube_map_1923_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Texture *TexturePool::get_alpha_scale_map(void)
 */
static PyObject *Dtool_TexturePool_get_alpha_scale_map_1924(PyObject *, PyObject *) {
  // 1-static inline Texture *TexturePool::get_alpha_scale_map(void)
  Texture *return_value = (TexturePool::get_alpha_scale_map)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_get_alpha_scale_map_1924_comment =
  "C++ Interface:\n"
  "get_alpha_scale_map()\n"
  "\n"
  "/**\n"
  " * Returns a standard Texture object that has been created with\n"
  " * Texture::generate_alpha_scale_map().\n"
  " *\n"
  " * This Texture object is used internally by Panda to apply an alpha scale to\n"
  " * an object (instead of munging its vertices) when\n"
  " * gsg->get_alpha_scale_via_texture() returns true.\n"
  " */";
#else
static const char *Dtool_TexturePool_get_alpha_scale_map_1924_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TexturePool::add_texture(Texture *texture)
 */
static PyObject *Dtool_TexturePool_add_texture_1925(PyObject *, PyObject *arg) {
  // 1-static inline void TexturePool::add_texture(Texture *texture)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 0, "TexturePool.add_texture", false, true);
  if (arg_this != nullptr) {
    (TexturePool::add_texture)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_texture(Texture texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_add_texture_1925_comment =
  "C++ Interface:\n"
  "add_texture(Texture texture)\n"
  "\n"
  "/**\n"
  " * Adds the indicated already-loaded texture to the pool.  The texture must\n"
  " * have a filename set for its name.  The texture will always replace any\n"
  " * previously-loaded texture in the pool that had the same filename.\n"
  " */";
#else
static const char *Dtool_TexturePool_add_texture_1925_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TexturePool::release_texture(Texture *texture)
 */
static PyObject *Dtool_TexturePool_release_texture_1926(PyObject *, PyObject *arg) {
  // 1-static inline void TexturePool::release_texture(Texture *texture)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 0, "TexturePool.release_texture", false, true);
  if (arg_this != nullptr) {
    (TexturePool::release_texture)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_texture(Texture texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_release_texture_1926_comment =
  "C++ Interface:\n"
  "release_texture(Texture texture)\n"
  "\n"
  "/**\n"
  " * Removes the indicated texture from the pool, indicating it will never be\n"
  " * loaded again; the texture may then be freed.  If this function is never\n"
  " * called, a reference count will be maintained on every texture every loaded,\n"
  " * and textures will never be freed.\n"
  " *\n"
  " * The texture's name should not have been changed during its lifetime, or\n"
  " * this function may fail to locate it in the pool.\n"
  " */";
#else
static const char *Dtool_TexturePool_release_texture_1926_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TexturePool::release_all_textures(void)
 */
static PyObject *Dtool_TexturePool_release_all_textures_1927(PyObject *, PyObject *) {
  // 1-static inline void TexturePool::release_all_textures(void)
  (TexturePool::release_all_textures)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_release_all_textures_1927_comment =
  "C++ Interface:\n"
  "release_all_textures()\n"
  "\n"
  "/**\n"
  " * Releases all textures in the pool and restores the pool to the empty state.\n"
  " */";
#else
static const char *Dtool_TexturePool_release_all_textures_1927_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TexturePool::rehash(void)
 */
static PyObject *Dtool_TexturePool_rehash_1928(PyObject *, PyObject *) {
  // 1-static inline void TexturePool::rehash(void)
  (TexturePool::rehash)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_rehash_1928_comment =
  "C++ Interface:\n"
  "rehash()\n"
  "\n"
  "/**\n"
  " * Should be called when the model-path changes, to blow away the cache of\n"
  " * texture pathnames found along the model-path.\n"
  " */";
#else
static const char *Dtool_TexturePool_rehash_1928_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int TexturePool::garbage_collect(void)
 */
static PyObject *Dtool_TexturePool_garbage_collect_1929(PyObject *, PyObject *) {
  // 1-static inline int TexturePool::garbage_collect(void)
  int return_value = (TexturePool::garbage_collect)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_garbage_collect_1929_comment =
  "C++ Interface:\n"
  "garbage_collect()\n"
  "\n"
  "/**\n"
  " * Releases only those textures in the pool that have a reference count of\n"
  " * exactly 1; i.e.  only those textures that are not being used outside of the\n"
  " * pool.  Returns the number of textures released.\n"
  " */";
#else
static const char *Dtool_TexturePool_garbage_collect_1929_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TexturePool::list_contents(void)
 * static inline void TexturePool::list_contents(std::ostream &out)
 */
static PyObject *Dtool_TexturePool_list_contents_1930(PyObject *, PyObject *args) {
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-static inline void TexturePool::list_contents(void)
      (TexturePool::list_contents)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-static inline void TexturePool::list_contents(std::ostream &out)
      std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "TexturePool.list_contents", false, true);
      if (arg_this != nullptr) {
        (TexturePool::list_contents)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "list_contents() takes 0 or 1 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_contents()\n"
      "list_contents(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_list_contents_1930_comment =
  "C++ Interface:\n"
  "list_contents()\n"
  "list_contents(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the texture pool to the indicated output stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Lists the contents of the texture pool to cout\n"
  " */";
#else
static const char *Dtool_TexturePool_list_contents_1930_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Texture *TexturePool::find_texture(std::string const &name)
 */
static PyObject *Dtool_TexturePool_find_texture_1931(PyObject *, PyObject *arg) {
  // 1-static inline Texture *TexturePool::find_texture(std::string const &name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    Texture *return_value = (TexturePool::find_texture)(std::string(param0_str, param0_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_texture(str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_find_texture_1931_comment =
  "C++ Interface:\n"
  "find_texture(str name)\n"
  "\n"
  "/**\n"
  " * Returns the first texture found in the pool that matches the indicated name\n"
  " * (which may contain wildcards).  Returns the texture if it is found, or NULL\n"
  " * if it is not.\n"
  " */";
#else
static const char *Dtool_TexturePool_find_texture_1931_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline TextureCollection TexturePool::find_all_textures(std::string const &name = "*")
 */
static PyObject *Dtool_TexturePool_find_all_textures_1932(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline TextureCollection TexturePool::find_all_textures(std::string const &name = "*")
  const char *param0_str = "*";
  Py_ssize_t param0_len = 1;
  static const char *keyword_list[] = {"name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:find_all_textures", (char **)keyword_list, &param0_str, &param0_len)) {
    TextureCollection *return_value = new TextureCollection((TexturePool::find_all_textures)(std::string(param0_str, param0_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureCollection, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_textures(str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_find_all_textures_1932_comment =
  "C++ Interface:\n"
  "find_all_textures(str name)\n"
  "\n"
  "/**\n"
  " * Returns the set of all textures found in the pool that match the indicated\n"
  " * name (which may contain wildcards).\n"
  " */";
#else
static const char *Dtool_TexturePool_find_all_textures_1932_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TexturePool::set_fake_texture_image(Filename const &filename)
 */
static PyObject *Dtool_TexturePool_set_fake_texture_image_1933(PyObject *, PyObject *arg) {
  // 1-static inline void TexturePool::set_fake_texture_image(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "TexturePool.set_fake_texture_image", "Filename");
  }
  (TexturePool::set_fake_texture_image)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fake_texture_image(const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_set_fake_texture_image_1933_comment =
  "C++ Interface:\n"
  "set_fake_texture_image(const Filename filename)\n"
  "\n"
  "/**\n"
  " * Sets a bogus filename that will be loaded in lieu of any textures requested\n"
  " * from this point on.\n"
  " */";
#else
static const char *Dtool_TexturePool_set_fake_texture_image_1933_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TexturePool::clear_fake_texture_image(void)
 */
static PyObject *Dtool_TexturePool_clear_fake_texture_image_1934(PyObject *, PyObject *) {
  // 1-static inline void TexturePool::clear_fake_texture_image(void)
  (TexturePool::clear_fake_texture_image)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_clear_fake_texture_image_1934_comment =
  "C++ Interface:\n"
  "clear_fake_texture_image()\n"
  "\n"
  "/**\n"
  " * Restores normal behavior of loading the textures actually requested.\n"
  " */";
#else
static const char *Dtool_TexturePool_clear_fake_texture_image_1934_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool TexturePool::has_fake_texture_image(void)
 */
static PyObject *Dtool_TexturePool_has_fake_texture_image_1935(PyObject *, PyObject *) {
  // 1-static inline bool TexturePool::has_fake_texture_image(void)
  bool return_value = (TexturePool::has_fake_texture_image)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_has_fake_texture_image_1935_comment =
  "C++ Interface:\n"
  "has_fake_texture_image()\n"
  "\n"
  "/**\n"
  " * Returns true if fake_texture_image mode has been enabled, false if we are\n"
  " * in the normal mode.\n"
  " */";
#else
static const char *Dtool_TexturePool_has_fake_texture_image_1935_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Filename const &TexturePool::get_fake_texture_image(void)
 */
static PyObject *Dtool_TexturePool_get_fake_texture_image_1936(PyObject *, PyObject *) {
  // 1-static inline Filename const &TexturePool::get_fake_texture_image(void)
  Filename const *return_value = &((TexturePool::get_fake_texture_image)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_get_fake_texture_image_1936_comment =
  "C++ Interface:\n"
  "get_fake_texture_image()\n"
  "\n"
  "/**\n"
  " * Returns the filename that was specified with a previous call to\n"
  " * set_fake_texture_image().\n"
  " */";
#else
static const char *Dtool_TexturePool_get_fake_texture_image_1936_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PointerTo< Texture > TexturePool::make_texture(std::string const &extension)
 */
static PyObject *Dtool_TexturePool_make_texture_1937(PyObject *, PyObject *arg) {
  // 1-static inline PointerTo< Texture > TexturePool::make_texture(std::string const &extension)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    PointerTo< Texture > return_value = (TexturePool::make_texture)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    Texture *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Texture, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_texture(str extension)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_make_texture_1937_comment =
  "C++ Interface:\n"
  "make_texture(str extension)\n"
  "\n"
  "/**\n"
  " * Creates a new Texture object of the appropriate type for the indicated\n"
  " * filename extension, according to the types that have been registered via\n"
  " * register_texture_type().\n"
  " */";
#else
static const char *Dtool_TexturePool_make_texture_1937_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void TexturePool::write(std::ostream &out)
 */
static PyObject *Dtool_TexturePool_write_1938(PyObject *, PyObject *arg) {
  // 1-static void TexturePool::write(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "TexturePool.write", false, true);
  if (arg_this != nullptr) {
    (TexturePool::write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePool_write_1938_comment =
  "C++ Interface:\n"
  "write(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the texture pool to the indicated output stream.  For\n"
  " * debugging.\n"
  " */";
#else
static const char *Dtool_TexturePool_write_1938_comment = nullptr;
#endif

static int Dtool_Init_TexturePool(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TexturePool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TexturePool) {
    printf("TexturePool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TexturePool *local_this = (TexturePool *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TexturePool) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TexturePool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TexturePool) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TexturePeeker
 */
/**
 * Python function wrapper for:
 * inline int TexturePeeker::get_x_size(void) const
 */
static PyObject *Dtool_TexturePeeker_get_x_size_1941(PyObject *self, PyObject *) {
  TexturePeeker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexturePeeker)) {
    return nullptr;
  }
  // 1-inline int TexturePeeker::get_x_size(void) const
  int return_value = ((*(const TexturePeeker*)local_this).get_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexturePeeker_get_x_size_1941_comment =
  "C++ Interface:\n"
  "get_x_size(TexturePeeker self)\n"
  "\n"
  "/**\n"
  " * Returns the width of the texture image that is contributing to the\n"
  " * TexturePeeker's information.  This may be either the Texture's full width,\n"
  " * or its simple ram image's width.\n"
  " */";
#else
static const char *Dtool_TexturePeeker_get_x_size_1941_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TexturePeeker::get_y_size(void) const
 */
static PyObject *Dtool_TexturePeeker_get_y_size_1942(PyObject *self, PyObject *) {
  TexturePeeker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexturePeeker)) {
    return nullptr;
  }
  // 1-inline int TexturePeeker::get_y_size(void) const
  int return_value = ((*(const TexturePeeker*)local_this).get_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexturePeeker_get_y_size_1942_comment =
  "C++ Interface:\n"
  "get_y_size(TexturePeeker self)\n"
  "\n"
  "/**\n"
  " * Returns the height of the texture image that is contributing to the\n"
  " * TexturePeeker's information.  This may be either the Texture's full height,\n"
  " * or its simple ram image's height.\n"
  " */";
#else
static const char *Dtool_TexturePeeker_get_y_size_1942_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TexturePeeker::get_z_size(void) const
 */
static PyObject *Dtool_TexturePeeker_get_z_size_1943(PyObject *self, PyObject *) {
  TexturePeeker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexturePeeker)) {
    return nullptr;
  }
  // 1-inline int TexturePeeker::get_z_size(void) const
  int return_value = ((*(const TexturePeeker*)local_this).get_z_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexturePeeker_get_z_size_1943_comment =
  "C++ Interface:\n"
  "get_z_size(TexturePeeker self)\n"
  "\n"
  "/**\n"
  " * Returns the depth of the texture image that is contributing to the\n"
  " * TexturePeeker's information.\n"
  " */";
#else
static const char *Dtool_TexturePeeker_get_z_size_1943_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TexturePeeker::has_pixel(int x, int y) const
 */
static PyObject *Dtool_TexturePeeker_has_pixel_1944(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePeeker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexturePeeker)) {
    return nullptr;
  }
  // 1-inline bool TexturePeeker::has_pixel(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_pixel", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const TexturePeeker*)local_this).has_pixel)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_pixel(TexturePeeker self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePeeker_has_pixel_1944_comment =
  "C++ Interface:\n"
  "has_pixel(TexturePeeker self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns whether a given coordinate is inside of the texture dimensions.\n"
  " */";
#else
static const char *Dtool_TexturePeeker_has_pixel_1944_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TexturePeeker::lookup(LColor &color, PN_stdfloat u, PN_stdfloat v) const
 * void TexturePeeker::lookup(LColor &color, PN_stdfloat u, PN_stdfloat v, PN_stdfloat w) const
 */
static PyObject *Dtool_TexturePeeker_lookup_1945(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePeeker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexturePeeker)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-void TexturePeeker::lookup(LColor &color, PN_stdfloat u, PN_stdfloat v) const
      PyObject *param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"color", "u", "v", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:lookup", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase4f param1_local;
        LColor *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "TexturePeeker.lookup", "LVecBase4f");
        }
        ((*(const TexturePeeker*)local_this).lookup)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-void TexturePeeker::lookup(LColor &color, PN_stdfloat u, PN_stdfloat v, PN_stdfloat w) const
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"color", "u", "v", "w", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:lookup", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        LVecBase4f param1_local;
        LColor *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "TexturePeeker.lookup", "LVecBase4f");
        }
        ((*(const TexturePeeker*)local_this).lookup)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "lookup() takes 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lookup(TexturePeeker self, LVecBase4f color, float u, float v)\n"
      "lookup(TexturePeeker self, LVecBase4f color, float u, float v, float w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePeeker_lookup_1945_comment =
  "C++ Interface:\n"
  "lookup(TexturePeeker self, LVecBase4f color, float u, float v)\n"
  "lookup(TexturePeeker self, LVecBase4f color, float u, float v, float w)\n"
  "\n"
  "/**\n"
  " * Fills \"color\" with the RGBA color of the texel at point (u, v).\n"
  " *\n"
  " * The texel color is determined via nearest-point sampling (no filtering of\n"
  " * adjacent pixels), regardless of the filter type associated with the\n"
  " * texture.  u, v, and w will wrap around regardless of the texture's wrap\n"
  " * mode.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills \"color\" with the RGBA color of the texel at point (u, v, w).\n"
  " *\n"
  " * The texel color is determined via nearest-point sampling (no filtering of\n"
  " * adjacent pixels), regardless of the filter type associated with the\n"
  " * texture.  u, v, and w will wrap around regardless of the texture's wrap\n"
  " * mode.\n"
  " */";
#else
static const char *Dtool_TexturePeeker_lookup_1945_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TexturePeeker::fetch_pixel(LColor &color, int x, int y) const
 */
static PyObject *Dtool_TexturePeeker_fetch_pixel_1946(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePeeker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexturePeeker)) {
    return nullptr;
  }
  // 1-void TexturePeeker::fetch_pixel(LColor &color, int x, int y) const
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"color", "x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:fetch_pixel", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase4f param1_local;
    LColor *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TexturePeeker.fetch_pixel", "LVecBase4f");
    }
    ((*(const TexturePeeker*)local_this).fetch_pixel)(*param1_this, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fetch_pixel(TexturePeeker self, LVecBase4f color, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePeeker_fetch_pixel_1946_comment =
  "C++ Interface:\n"
  "fetch_pixel(TexturePeeker self, LVecBase4f color, int x, int y)\n"
  "\n"
  "/**\n"
  " *  Works like TexturePeeker::lookup(), but instead uv-coordinates integer\n"
  " *  coordinates are used.\n"
  " */";
#else
static const char *Dtool_TexturePeeker_fetch_pixel_1946_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TexturePeeker::lookup_bilinear(LColor &color, PN_stdfloat u, PN_stdfloat v) const
 */
static PyObject *Dtool_TexturePeeker_lookup_bilinear_1947(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePeeker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexturePeeker)) {
    return nullptr;
  }
  // 1-bool TexturePeeker::lookup_bilinear(LColor &color, PN_stdfloat u, PN_stdfloat v) const
  PyObject *param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"color", "u", "v", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:lookup_bilinear", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase4f param1_local;
    LColor *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TexturePeeker.lookup_bilinear", "LVecBase4f");
    }
    bool return_value = ((*(const TexturePeeker*)local_this).lookup_bilinear)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lookup_bilinear(TexturePeeker self, LVecBase4f color, float u, float v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePeeker_lookup_bilinear_1947_comment =
  "C++ Interface:\n"
  "lookup_bilinear(TexturePeeker self, LVecBase4f color, float u, float v)\n"
  "\n"
  "/**\n"
  " * Performs a bilinear lookup to retrieve the color value stored at the uv\n"
  " * coordinate (u, v).\n"
  " *\n"
  " * In case the point is outside of the uv range, color is set to zero,\n"
  " * and false is returned.  Otherwise true is returned.\n"
  " */";
#else
static const char *Dtool_TexturePeeker_lookup_bilinear_1947_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TexturePeeker::filter_rect(LColor &color, PN_stdfloat min_u, PN_stdfloat min_v, PN_stdfloat max_u, PN_stdfloat max_v) const
 * void TexturePeeker::filter_rect(LColor &color, PN_stdfloat min_u, PN_stdfloat min_v, PN_stdfloat min_w, PN_stdfloat max_u, PN_stdfloat max_v, PN_stdfloat max_w) const
 */
static PyObject *Dtool_TexturePeeker_filter_rect_1948(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePeeker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TexturePeeker)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 5:
    {
      // 1-void TexturePeeker::filter_rect(LColor &color, PN_stdfloat min_u, PN_stdfloat min_v, PN_stdfloat max_u, PN_stdfloat max_v) const
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"color", "min_u", "min_v", "max_u", "max_v", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offff:filter_rect", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        LVecBase4f param1_local;
        LColor *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "TexturePeeker.filter_rect", "LVecBase4f");
        }
        ((*(const TexturePeeker*)local_this).filter_rect)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
        return Dtool_Return_None();
      }
    }
    break;
  case 7:
    {
      // 1-void TexturePeeker::filter_rect(LColor &color, PN_stdfloat min_u, PN_stdfloat min_v, PN_stdfloat min_w, PN_stdfloat max_u, PN_stdfloat max_v, PN_stdfloat max_w) const
      PyObject *param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      static const char *keyword_list[] = {"color", "min_u", "min_v", "min_w", "max_u", "max_v", "max_w", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offffff:filter_rect", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        LVecBase4f param1_local;
        LColor *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "TexturePeeker.filter_rect", "LVecBase4f");
        }
        ((*(const TexturePeeker*)local_this).filter_rect)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "filter_rect() takes 6 or 8 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "filter_rect(TexturePeeker self, LVecBase4f color, float min_u, float min_v, float max_u, float max_v)\n"
      "filter_rect(TexturePeeker self, LVecBase4f color, float min_u, float min_v, float min_w, float max_u, float max_v, float max_w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePeeker_filter_rect_1948_comment =
  "C++ Interface:\n"
  "filter_rect(TexturePeeker self, LVecBase4f color, float min_u, float min_v, float max_u, float max_v)\n"
  "filter_rect(TexturePeeker self, LVecBase4f color, float min_u, float min_v, float min_w, float max_u, float max_v, float max_w)\n"
  "\n"
  "/**\n"
  " * Fills \"color\" with the average RGBA color of the texels within the\n"
  " * rectangle defined by the specified coordinate range.\n"
  " *\n"
  " * The texel color is linearly filtered over the entire region.  u, v, and w\n"
  " * will wrap around regardless of the texture's wrap mode.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills \"color\" with the average RGBA color of the texels within the\n"
  " * rectangle defined by the specified coordinate range.\n"
  " *\n"
  " * The texel color is linearly filtered over the entire region.  u, v, and w\n"
  " * will wrap around regardless of the texture's wrap mode.\n"
  " */";
#else
static const char *Dtool_TexturePeeker_filter_rect_1948_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TexturePeeker::TexturePeeker(TexturePeeker const &) = default
 */
static int Dtool_Init_TexturePeeker(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TexturePeeker() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline TexturePeeker::TexturePeeker(TexturePeeker const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    TexturePeeker const *param0_this = (TexturePeeker *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TexturePeeker, 0, "TexturePeeker.TexturePeeker", true, true);
    if (param0_this != nullptr) {
      TexturePeeker *return_value = new TexturePeeker(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TexturePeeker, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TexturePeeker(const TexturePeeker param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TexturePeeker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TexturePeeker) {
    printf("TexturePeeker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TexturePeeker *local_this = (TexturePeeker *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TexturePeeker) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TexturePeeker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TexturePeeker) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TexturePeeker*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextureStagePool
 */
/**
 * Python function wrapper for:
 * static inline TextureStage *TextureStagePool::get_stage(TextureStage *temp)
 */
static PyObject *Dtool_TextureStagePool_get_stage_1953(PyObject *, PyObject *arg) {
  // 1-static inline TextureStage *TextureStagePool::get_stage(TextureStage *temp)
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 0, "TextureStagePool.get_stage", false, true);
  if (arg_this != nullptr) {
    TextureStage *return_value = (TextureStagePool::get_stage)(arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_stage(TextureStage temp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStagePool_get_stage_1953_comment =
  "C++ Interface:\n"
  "get_stage(TextureStage temp)\n"
  "\n"
  "/**\n"
  " * Returns a TextureStage pointer that represents the same TextureStage\n"
  " * described by temp, except that it is a shared pointer.\n"
  " *\n"
  " * Each call to get_stage() passing an equivalent TextureStage pointer will\n"
  " * return the same shared pointer.\n"
  " *\n"
  " * If you modify the shared pointer, it will automatically disassociate it\n"
  " * from the pool.\n"
  " *\n"
  " * Also, the return value may be a different pointer than that passed in, or\n"
  " * it may be the same pointer.  In either case, the passed in pointer has now\n"
  " * been sacrificed to the greater good and should not be used again (like any\n"
  " * other PointerTo, it will be freed when the last reference count is\n"
  " * removed).\n"
  " */";
#else
static const char *Dtool_TextureStagePool_get_stage_1953_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TextureStagePool::release_stage(TextureStage *temp)
 */
static PyObject *Dtool_TextureStagePool_release_stage_1954(PyObject *, PyObject *arg) {
  // 1-static inline void TextureStagePool::release_stage(TextureStage *temp)
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 0, "TextureStagePool.release_stage", false, true);
  if (arg_this != nullptr) {
    (TextureStagePool::release_stage)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_stage(TextureStage temp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStagePool_release_stage_1954_comment =
  "C++ Interface:\n"
  "release_stage(TextureStage temp)\n"
  "\n"
  "/**\n"
  " * Removes the indicated TextureStage from the pool.\n"
  " */";
#else
static const char *Dtool_TextureStagePool_release_stage_1954_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TextureStagePool::release_all_stages(void)
 */
static PyObject *Dtool_TextureStagePool_release_all_stages_1955(PyObject *, PyObject *) {
  // 1-static inline void TextureStagePool::release_all_stages(void)
  (TextureStagePool::release_all_stages)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextureStagePool_release_all_stages_1955_comment =
  "C++ Interface:\n"
  "release_all_stages()\n"
  "\n"
  "/**\n"
  " * Releases all TextureStages in the pool and restores the pool to the empty\n"
  " * state.\n"
  " */";
#else
static const char *Dtool_TextureStagePool_release_all_stages_1955_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TextureStagePool::set_mode(TextureStagePool::Mode mode)
 */
static PyObject *Dtool_TextureStagePool_set_mode_1956(PyObject *, PyObject *arg) {
  // 1-static inline void TextureStagePool::set_mode(TextureStagePool::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (TextureStagePool::set_mode)((TextureStagePool::Mode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mode(int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStagePool_set_mode_1956_comment =
  "C++ Interface:\n"
  "set_mode(int mode)\n"
  "\n"
  "/**\n"
  " * Specifies the fundamental operating mode of the TextureStagePool.\n"
  " *\n"
  " * If this is M_none, each call to get_stage() returns the same TextureStage\n"
  " * pointer that was passed in (the pool is effectively disabled).  If this is\n"
  " * M_name, each call to get_stage() returns the last TextureStage passed in\n"
  " * with the same name, whether it has different properties or not.  If this is\n"
  " * M_unique, then each call to get_stage() returns only TextureStages with\n"
  " * identical properties.\n"
  " */";
#else
static const char *Dtool_TextureStagePool_set_mode_1956_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline TextureStagePool::Mode TextureStagePool::get_mode(void)
 */
static PyObject *Dtool_TextureStagePool_get_mode_1957(PyObject *, PyObject *) {
  // 1-static inline TextureStagePool::Mode TextureStagePool::get_mode(void)
  TextureStagePool::Mode return_value = (TextureStagePool::get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStagePool_get_mode_1957_comment =
  "C++ Interface:\n"
  "get_mode()\n"
  "\n"
  "/**\n"
  " * Returns the fundamental operating mode of the TextureStagePool.  See\n"
  " * set_mode().\n"
  " */";
#else
static const char *Dtool_TextureStagePool_get_mode_1957_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int TextureStagePool::garbage_collect(void)
 */
static PyObject *Dtool_TextureStagePool_garbage_collect_1959(PyObject *, PyObject *) {
  // 1-static inline int TextureStagePool::garbage_collect(void)
  int return_value = (TextureStagePool::garbage_collect)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureStagePool_garbage_collect_1959_comment =
  "C++ Interface:\n"
  "garbage_collect()\n"
  "\n"
  "/**\n"
  " * Releases only those TextureStages in the pool that have a reference count\n"
  " * of exactly 1; i.e.  only those TextureStages that are not being used\n"
  " * outside of the pool.  Returns the number of TextureStages released.\n"
  " */";
#else
static const char *Dtool_TextureStagePool_garbage_collect_1959_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TextureStagePool::list_contents(std::ostream &out)
 */
static PyObject *Dtool_TextureStagePool_list_contents_1960(PyObject *, PyObject *arg) {
  // 1-static inline void TextureStagePool::list_contents(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "TextureStagePool.list_contents", false, true);
  if (arg_this != nullptr) {
    (TextureStagePool::list_contents)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_contents(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStagePool_list_contents_1960_comment =
  "C++ Interface:\n"
  "list_contents(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the TextureStage pool to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_TextureStagePool_list_contents_1960_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void TextureStagePool::write(std::ostream &out)
 */
static PyObject *Dtool_TextureStagePool_write_1961(PyObject *, PyObject *arg) {
  // 1-static void TextureStagePool::write(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "TextureStagePool.write", false, true);
  if (arg_this != nullptr) {
    (TextureStagePool::write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStagePool_write_1961_comment =
  "C++ Interface:\n"
  "write(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the TextureStage pool to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_TextureStagePool_write_1961_comment = nullptr;
#endif

static PyObject *Dtool_TextureStagePool_mode_Getter(PyObject *self, void *) {
  // 1-static inline TextureStagePool::Mode TextureStagePool::get_mode(void)
  TextureStagePool::Mode return_value = (TextureStagePool::get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextureStagePool_mode_Setter(PyObject *self, PyObject *arg, void *) {
  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete mode attribute");
    return -1;
  }
  // 1-static inline void TextureStagePool::set_mode(TextureStagePool::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (TextureStagePool::set_mode)((TextureStagePool::Mode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_mode(int mode)\n");
  }
  return -1;
}

static int Dtool_Init_TextureStagePool(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TextureStagePool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextureStagePool) {
    printf("TextureStagePool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextureStagePool *local_this = (TextureStagePool *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextureStagePool) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextureStagePool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextureStagePool) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for AdaptiveLru (AdaptiveLru)
 */
static PyMethodDef Dtool_Methods_AdaptiveLru[] = {
  {"get_total_size", &Dtool_AdaptiveLru_get_total_size_5, METH_NOARGS, (const char *)Dtool_AdaptiveLru_get_total_size_5_comment},
  {"getTotalSize", &Dtool_AdaptiveLru_get_total_size_5, METH_NOARGS, (const char *)Dtool_AdaptiveLru_get_total_size_5_comment},
  {"get_max_size", &Dtool_AdaptiveLru_get_max_size_6, METH_NOARGS, (const char *)Dtool_AdaptiveLru_get_max_size_6_comment},
  {"getMaxSize", &Dtool_AdaptiveLru_get_max_size_6, METH_NOARGS, (const char *)Dtool_AdaptiveLru_get_max_size_6_comment},
  {"set_max_size", &Dtool_AdaptiveLru_set_max_size_7, METH_O, (const char *)Dtool_AdaptiveLru_set_max_size_7_comment},
  {"setMaxSize", &Dtool_AdaptiveLru_set_max_size_7, METH_O, (const char *)Dtool_AdaptiveLru_set_max_size_7_comment},
  {"count_active_size", &Dtool_AdaptiveLru_count_active_size_8, METH_NOARGS, (const char *)Dtool_AdaptiveLru_count_active_size_8_comment},
  {"countActiveSize", &Dtool_AdaptiveLru_count_active_size_8, METH_NOARGS, (const char *)Dtool_AdaptiveLru_count_active_size_8_comment},
  {"consider_evict", &Dtool_AdaptiveLru_consider_evict_9, METH_NOARGS, (const char *)Dtool_AdaptiveLru_consider_evict_9_comment},
  {"considerEvict", &Dtool_AdaptiveLru_consider_evict_9, METH_NOARGS, (const char *)Dtool_AdaptiveLru_consider_evict_9_comment},
  {"evict_to", &Dtool_AdaptiveLru_evict_to_10, METH_O, (const char *)Dtool_AdaptiveLru_evict_to_10_comment},
  {"evictTo", &Dtool_AdaptiveLru_evict_to_10, METH_O, (const char *)Dtool_AdaptiveLru_evict_to_10_comment},
  {"begin_epoch", &Dtool_AdaptiveLru_begin_epoch_11, METH_NOARGS, (const char *)Dtool_AdaptiveLru_begin_epoch_11_comment},
  {"beginEpoch", &Dtool_AdaptiveLru_begin_epoch_11, METH_NOARGS, (const char *)Dtool_AdaptiveLru_begin_epoch_11_comment},
  {"validate", &Dtool_AdaptiveLru_validate_12, METH_NOARGS, (const char *)Dtool_AdaptiveLru_validate_12_comment},
  {"output", &Dtool_AdaptiveLru_output_13, METH_O, (const char *)Dtool_AdaptiveLru_output_13_comment},
  {"write", (PyCFunction) &Dtool_AdaptiveLru_write_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AdaptiveLru_write_14_comment},
  {"set_weight", &Dtool_AdaptiveLru_set_weight_15, METH_O, (const char *)Dtool_AdaptiveLru_set_weight_15_comment},
  {"setWeight", &Dtool_AdaptiveLru_set_weight_15, METH_O, (const char *)Dtool_AdaptiveLru_set_weight_15_comment},
  {"get_weight", &Dtool_AdaptiveLru_get_weight_16, METH_NOARGS, (const char *)Dtool_AdaptiveLru_get_weight_16_comment},
  {"getWeight", &Dtool_AdaptiveLru_get_weight_16, METH_NOARGS, (const char *)Dtool_AdaptiveLru_get_weight_16_comment},
  {"set_max_updates_per_frame", &Dtool_AdaptiveLru_set_max_updates_per_frame_17, METH_O, (const char *)Dtool_AdaptiveLru_set_max_updates_per_frame_17_comment},
  {"setMaxUpdatesPerFrame", &Dtool_AdaptiveLru_set_max_updates_per_frame_17, METH_O, (const char *)Dtool_AdaptiveLru_set_max_updates_per_frame_17_comment},
  {"get_max_updates_per_frame", &Dtool_AdaptiveLru_get_max_updates_per_frame_18, METH_NOARGS, (const char *)Dtool_AdaptiveLru_get_max_updates_per_frame_18_comment},
  {"getMaxUpdatesPerFrame", &Dtool_AdaptiveLru_get_max_updates_per_frame_18, METH_NOARGS, (const char *)Dtool_AdaptiveLru_get_max_updates_per_frame_18_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AdaptiveLru
//////////////////
static PyObject *Dtool_Repr_AdaptiveLru(PyObject *self) {
  AdaptiveLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AdaptiveLru, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AdaptiveLru
//////////////////
static PyObject *Dtool_Str_AdaptiveLru(PyObject *self) {
  AdaptiveLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AdaptiveLru, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AdaptiveLru = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AdaptiveLru = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AdaptiveLru = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AdaptiveLru = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AdaptiveLru = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AdaptiveLru = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AdaptiveLru",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AdaptiveLru,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AdaptiveLru,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AdaptiveLru,
    &Dtool_NumberMethods_AdaptiveLru,
    &Dtool_SequenceMethods_AdaptiveLru,
    &Dtool_MappingMethods_AdaptiveLru,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AdaptiveLru,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AdaptiveLru,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A basic LRU-type algorithm, except that it is adaptive and attempts to\n"
    " * avoid evicting pages that have been used more frequently (even if less\n"
    " * recently) than other pages.\n"
    " *\n"
    " * The interface is designed to be identical to that for SimpleLru, so that it\n"
    " * may be used as a drop-in replacement.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AdaptiveLru,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AdaptiveLru,
    PyType_GenericAlloc,
    Dtool_new_AdaptiveLru,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AdaptiveLru,
  Dtool_UpcastInterface_AdaptiveLru,
  Dtool_DowncastInterface_AdaptiveLru,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AdaptiveLru(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_AdaptiveLru._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_AdaptiveLru._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AdaptiveLru._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AdaptiveLru) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AdaptiveLru)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AdaptiveLru);
  }
}

/**
 * Python method tables for AdaptiveLruPage (AdaptiveLruPage)
 */
static PyMethodDef Dtool_Methods_AdaptiveLruPage[] = {
  {"assign", &Dtool_AdaptiveLruPage_operator_27, METH_O, (const char *)Dtool_AdaptiveLruPage_operator_27_comment},
  {"get_lru", &Dtool_AdaptiveLruPage_get_lru_29, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_get_lru_29_comment},
  {"getLru", &Dtool_AdaptiveLruPage_get_lru_29, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_get_lru_29_comment},
  {"enqueue_lru", &Dtool_AdaptiveLruPage_enqueue_lru_30, METH_O, (const char *)Dtool_AdaptiveLruPage_enqueue_lru_30_comment},
  {"enqueueLru", &Dtool_AdaptiveLruPage_enqueue_lru_30, METH_O, (const char *)Dtool_AdaptiveLruPage_enqueue_lru_30_comment},
  {"dequeue_lru", &Dtool_AdaptiveLruPage_dequeue_lru_31, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_dequeue_lru_31_comment},
  {"dequeueLru", &Dtool_AdaptiveLruPage_dequeue_lru_31, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_dequeue_lru_31_comment},
  {"mark_used_lru", &Dtool_AdaptiveLruPage_mark_used_lru_32, METH_VARARGS, (const char *)Dtool_AdaptiveLruPage_mark_used_lru_32_comment},
  {"markUsedLru", &Dtool_AdaptiveLruPage_mark_used_lru_32, METH_VARARGS, (const char *)Dtool_AdaptiveLruPage_mark_used_lru_32_comment},
  {"get_lru_size", &Dtool_AdaptiveLruPage_get_lru_size_33, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_get_lru_size_33_comment},
  {"getLruSize", &Dtool_AdaptiveLruPage_get_lru_size_33, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_get_lru_size_33_comment},
  {"set_lru_size", &Dtool_AdaptiveLruPage_set_lru_size_34, METH_O, (const char *)Dtool_AdaptiveLruPage_set_lru_size_34_comment},
  {"setLruSize", &Dtool_AdaptiveLruPage_set_lru_size_34, METH_O, (const char *)Dtool_AdaptiveLruPage_set_lru_size_34_comment},
  {"evict_lru", &Dtool_AdaptiveLruPage_evict_lru_35, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_evict_lru_35_comment},
  {"evictLru", &Dtool_AdaptiveLruPage_evict_lru_35, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_evict_lru_35_comment},
  {"output", &Dtool_AdaptiveLruPage_output_36, METH_O, (const char *)Dtool_AdaptiveLruPage_output_36_comment},
  {"write", (PyCFunction) &Dtool_AdaptiveLruPage_write_37, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AdaptiveLruPage_write_37_comment},
  {"get_num_frames", &Dtool_AdaptiveLruPage_get_num_frames_38, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_get_num_frames_38_comment},
  {"getNumFrames", &Dtool_AdaptiveLruPage_get_num_frames_38, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_get_num_frames_38_comment},
  {"get_num_inactive_frames", &Dtool_AdaptiveLruPage_get_num_inactive_frames_39, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_get_num_inactive_frames_39_comment},
  {"getNumInactiveFrames", &Dtool_AdaptiveLruPage_get_num_inactive_frames_39, METH_NOARGS, (const char *)Dtool_AdaptiveLruPage_get_num_inactive_frames_39_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AdaptiveLruPage
//////////////////
static PyObject *Dtool_Repr_AdaptiveLruPage(PyObject *self) {
  AdaptiveLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AdaptiveLruPage, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AdaptiveLruPage
//////////////////
static PyObject *Dtool_Str_AdaptiveLruPage(PyObject *self) {
  AdaptiveLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AdaptiveLruPage, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AdaptiveLruPage = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AdaptiveLruPage = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AdaptiveLruPage = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AdaptiveLruPage = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AdaptiveLruPage = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AdaptiveLruPage = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AdaptiveLruPage",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AdaptiveLruPage,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AdaptiveLruPage,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AdaptiveLruPage,
    &Dtool_NumberMethods_AdaptiveLruPage,
    &Dtool_SequenceMethods_AdaptiveLruPage,
    &Dtool_MappingMethods_AdaptiveLruPage,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AdaptiveLruPage,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AdaptiveLruPage,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * One atomic piece that may be managed by a AdaptiveLru chain.  To use this\n"
    " * class, inherit from it and override evict_lru().\n"
    " *\n"
    " * This class multiply inherits from two classes which in turn both inherit\n"
    " * from LinkedListNode.  This is just a sneaky C++ trick to allow this class\n"
    " * to inherit from LinkedListNode twice, so that pages can be stored on two\n"
    " * different linked lists simultaneously.  The AdaptiveLru class depends on\n"
    " * this; it maintains its pages in two different lists, one grouped by\n"
    " * priority, and one in order by next partial update needs.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AdaptiveLruPage,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AdaptiveLruPage,
    PyType_GenericAlloc,
    Dtool_new_AdaptiveLruPage,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AdaptiveLruPage,
  Dtool_UpcastInterface_AdaptiveLruPage,
  Dtool_DowncastInterface_AdaptiveLruPage,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AdaptiveLruPage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AdaptiveLruPage._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AdaptiveLruPage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AdaptiveLruPage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AdaptiveLruPage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AdaptiveLruPage);
  }
}

/**
 * Python method tables for GeomEnums (GeomEnums)
 */
static PyMethodDef Dtool_Methods_GeomEnums[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomEnums = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_GeomEnums = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomEnums",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomEnums,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomEnums,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class exists just to provide scoping for the various enumerated types\n"
    " * used by Geom, GeomVertexData, GeomVertexArrayData, GeomPrimitive, and other\n"
    " * related classes.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomEnums,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomEnums,
    PyType_GenericAlloc,
    Dtool_new_GeomEnums,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomEnums,
  Dtool_UpcastInterface_GeomEnums,
  Dtool_DowncastInterface_GeomEnums,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomEnums(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_GeomEnums._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(127);
    Dtool_GeomEnums._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum GeomEnums::UsageHint;
    PyDict_SetItemString(dict, "UH_client", Dtool_WrapValue(GeomEnums::UH_client));
    PyDict_SetItemString(dict, "UHClient", Dtool_WrapValue(GeomEnums::UH_client));
    PyDict_SetItemString(dict, "UH_stream", Dtool_WrapValue(GeomEnums::UH_stream));
    PyDict_SetItemString(dict, "UHStream", Dtool_WrapValue(GeomEnums::UH_stream));
    PyDict_SetItemString(dict, "UH_dynamic", Dtool_WrapValue(GeomEnums::UH_dynamic));
    PyDict_SetItemString(dict, "UHDynamic", Dtool_WrapValue(GeomEnums::UH_dynamic));
    PyDict_SetItemString(dict, "UH_static", Dtool_WrapValue(GeomEnums::UH_static));
    PyDict_SetItemString(dict, "UHStatic", Dtool_WrapValue(GeomEnums::UH_static));
    PyDict_SetItemString(dict, "UH_unspecified", Dtool_WrapValue(GeomEnums::UH_unspecified));
    PyDict_SetItemString(dict, "UHUnspecified", Dtool_WrapValue(GeomEnums::UH_unspecified));
    // enum GeomEnums::GeomRendering;
    PyDict_SetItemString(dict, "GR_indexed_point", Dtool_WrapValue(GeomEnums::GR_indexed_point));
    PyDict_SetItemString(dict, "GRIndexedPoint", Dtool_WrapValue(GeomEnums::GR_indexed_point));
    PyDict_SetItemString(dict, "GR_indexed_other", Dtool_WrapValue(GeomEnums::GR_indexed_other));
    PyDict_SetItemString(dict, "GRIndexedOther", Dtool_WrapValue(GeomEnums::GR_indexed_other));
    PyDict_SetItemString(dict, "GR_indexed_bits", Dtool_WrapValue(GeomEnums::GR_indexed_bits));
    PyDict_SetItemString(dict, "GRIndexedBits", Dtool_WrapValue(GeomEnums::GR_indexed_bits));
    PyDict_SetItemString(dict, "GR_point", Dtool_WrapValue(GeomEnums::GR_point));
    PyDict_SetItemString(dict, "GRPoint", Dtool_WrapValue(GeomEnums::GR_point));
    PyDict_SetItemString(dict, "GR_point_uniform_size", Dtool_WrapValue(GeomEnums::GR_point_uniform_size));
    PyDict_SetItemString(dict, "GRPointUniformSize", Dtool_WrapValue(GeomEnums::GR_point_uniform_size));
    PyDict_SetItemString(dict, "GR_per_point_size", Dtool_WrapValue(GeomEnums::GR_per_point_size));
    PyDict_SetItemString(dict, "GRPerPointSize", Dtool_WrapValue(GeomEnums::GR_per_point_size));
    PyDict_SetItemString(dict, "GR_point_perspective", Dtool_WrapValue(GeomEnums::GR_point_perspective));
    PyDict_SetItemString(dict, "GRPointPerspective", Dtool_WrapValue(GeomEnums::GR_point_perspective));
    PyDict_SetItemString(dict, "GR_point_aspect_ratio", Dtool_WrapValue(GeomEnums::GR_point_aspect_ratio));
    PyDict_SetItemString(dict, "GRPointAspectRatio", Dtool_WrapValue(GeomEnums::GR_point_aspect_ratio));
    PyDict_SetItemString(dict, "GR_point_scale", Dtool_WrapValue(GeomEnums::GR_point_scale));
    PyDict_SetItemString(dict, "GRPointScale", Dtool_WrapValue(GeomEnums::GR_point_scale));
    PyDict_SetItemString(dict, "GR_point_rotate", Dtool_WrapValue(GeomEnums::GR_point_rotate));
    PyDict_SetItemString(dict, "GRPointRotate", Dtool_WrapValue(GeomEnums::GR_point_rotate));
    PyDict_SetItemString(dict, "GR_point_sprite", Dtool_WrapValue(GeomEnums::GR_point_sprite));
    PyDict_SetItemString(dict, "GRPointSprite", Dtool_WrapValue(GeomEnums::GR_point_sprite));
    PyDict_SetItemString(dict, "GR_point_sprite_tex_matrix", Dtool_WrapValue(GeomEnums::GR_point_sprite_tex_matrix));
    PyDict_SetItemString(dict, "GRPointSpriteTexMatrix", Dtool_WrapValue(GeomEnums::GR_point_sprite_tex_matrix));
    PyDict_SetItemString(dict, "GR_point_bits", Dtool_WrapValue(GeomEnums::GR_point_bits));
    PyDict_SetItemString(dict, "GRPointBits", Dtool_WrapValue(GeomEnums::GR_point_bits));
    PyDict_SetItemString(dict, "GR_triangle_strip", Dtool_WrapValue(GeomEnums::GR_triangle_strip));
    PyDict_SetItemString(dict, "GRTriangleStrip", Dtool_WrapValue(GeomEnums::GR_triangle_strip));
    PyDict_SetItemString(dict, "GR_triangle_fan", Dtool_WrapValue(GeomEnums::GR_triangle_fan));
    PyDict_SetItemString(dict, "GRTriangleFan", Dtool_WrapValue(GeomEnums::GR_triangle_fan));
    PyDict_SetItemString(dict, "GR_line_strip", Dtool_WrapValue(GeomEnums::GR_line_strip));
    PyDict_SetItemString(dict, "GRLineStrip", Dtool_WrapValue(GeomEnums::GR_line_strip));
    PyDict_SetItemString(dict, "GR_composite_bits", Dtool_WrapValue(GeomEnums::GR_composite_bits));
    PyDict_SetItemString(dict, "GRCompositeBits", Dtool_WrapValue(GeomEnums::GR_composite_bits));
    PyDict_SetItemString(dict, "GR_strip_cut_index", Dtool_WrapValue(GeomEnums::GR_strip_cut_index));
    PyDict_SetItemString(dict, "GRStripCutIndex", Dtool_WrapValue(GeomEnums::GR_strip_cut_index));
    PyDict_SetItemString(dict, "GR_flat_first_vertex", Dtool_WrapValue(GeomEnums::GR_flat_first_vertex));
    PyDict_SetItemString(dict, "GRFlatFirstVertex", Dtool_WrapValue(GeomEnums::GR_flat_first_vertex));
    PyDict_SetItemString(dict, "GR_flat_last_vertex", Dtool_WrapValue(GeomEnums::GR_flat_last_vertex));
    PyDict_SetItemString(dict, "GRFlatLastVertex", Dtool_WrapValue(GeomEnums::GR_flat_last_vertex));
    PyDict_SetItemString(dict, "GR_shade_model_bits", Dtool_WrapValue(GeomEnums::GR_shade_model_bits));
    PyDict_SetItemString(dict, "GRShadeModelBits", Dtool_WrapValue(GeomEnums::GR_shade_model_bits));
    PyDict_SetItemString(dict, "GR_render_mode_wireframe", Dtool_WrapValue(GeomEnums::GR_render_mode_wireframe));
    PyDict_SetItemString(dict, "GRRenderModeWireframe", Dtool_WrapValue(GeomEnums::GR_render_mode_wireframe));
    PyDict_SetItemString(dict, "GR_render_mode_point", Dtool_WrapValue(GeomEnums::GR_render_mode_point));
    PyDict_SetItemString(dict, "GRRenderModePoint", Dtool_WrapValue(GeomEnums::GR_render_mode_point));
    PyDict_SetItemString(dict, "GR_adjacency", Dtool_WrapValue(GeomEnums::GR_adjacency));
    PyDict_SetItemString(dict, "GRAdjacency", Dtool_WrapValue(GeomEnums::GR_adjacency));
    // enum GeomEnums::ShadeModel;
    PyDict_SetItemString(dict, "SM_uniform", Dtool_WrapValue(GeomEnums::SM_uniform));
    PyDict_SetItemString(dict, "SMUniform", Dtool_WrapValue(GeomEnums::SM_uniform));
    PyDict_SetItemString(dict, "SM_smooth", Dtool_WrapValue(GeomEnums::SM_smooth));
    PyDict_SetItemString(dict, "SMSmooth", Dtool_WrapValue(GeomEnums::SM_smooth));
    PyDict_SetItemString(dict, "SM_flat_first_vertex", Dtool_WrapValue(GeomEnums::SM_flat_first_vertex));
    PyDict_SetItemString(dict, "SMFlatFirstVertex", Dtool_WrapValue(GeomEnums::SM_flat_first_vertex));
    PyDict_SetItemString(dict, "SM_flat_last_vertex", Dtool_WrapValue(GeomEnums::SM_flat_last_vertex));
    PyDict_SetItemString(dict, "SMFlatLastVertex", Dtool_WrapValue(GeomEnums::SM_flat_last_vertex));
    // enum GeomEnums::PrimitiveType;
    PyDict_SetItemString(dict, "PT_none", Dtool_WrapValue(GeomEnums::PT_none));
    PyDict_SetItemString(dict, "PTNone", Dtool_WrapValue(GeomEnums::PT_none));
    PyDict_SetItemString(dict, "PT_polygons", Dtool_WrapValue(GeomEnums::PT_polygons));
    PyDict_SetItemString(dict, "PTPolygons", Dtool_WrapValue(GeomEnums::PT_polygons));
    PyDict_SetItemString(dict, "PT_lines", Dtool_WrapValue(GeomEnums::PT_lines));
    PyDict_SetItemString(dict, "PTLines", Dtool_WrapValue(GeomEnums::PT_lines));
    PyDict_SetItemString(dict, "PT_points", Dtool_WrapValue(GeomEnums::PT_points));
    PyDict_SetItemString(dict, "PTPoints", Dtool_WrapValue(GeomEnums::PT_points));
    PyDict_SetItemString(dict, "PT_patches", Dtool_WrapValue(GeomEnums::PT_patches));
    PyDict_SetItemString(dict, "PTPatches", Dtool_WrapValue(GeomEnums::PT_patches));
    // enum GeomEnums::NumericType;
    PyDict_SetItemString(dict, "NT_uint8", Dtool_WrapValue(GeomEnums::NT_uint8));
    PyDict_SetItemString(dict, "NTUint8", Dtool_WrapValue(GeomEnums::NT_uint8));
    PyDict_SetItemString(dict, "NT_uint16", Dtool_WrapValue(GeomEnums::NT_uint16));
    PyDict_SetItemString(dict, "NTUint16", Dtool_WrapValue(GeomEnums::NT_uint16));
    PyDict_SetItemString(dict, "NT_uint32", Dtool_WrapValue(GeomEnums::NT_uint32));
    PyDict_SetItemString(dict, "NTUint32", Dtool_WrapValue(GeomEnums::NT_uint32));
    PyDict_SetItemString(dict, "NT_packed_dcba", Dtool_WrapValue(GeomEnums::NT_packed_dcba));
    PyDict_SetItemString(dict, "NTPackedDcba", Dtool_WrapValue(GeomEnums::NT_packed_dcba));
    PyDict_SetItemString(dict, "NT_packed_dabc", Dtool_WrapValue(GeomEnums::NT_packed_dabc));
    PyDict_SetItemString(dict, "NTPackedDabc", Dtool_WrapValue(GeomEnums::NT_packed_dabc));
    PyDict_SetItemString(dict, "NT_float32", Dtool_WrapValue(GeomEnums::NT_float32));
    PyDict_SetItemString(dict, "NTFloat32", Dtool_WrapValue(GeomEnums::NT_float32));
    PyDict_SetItemString(dict, "NT_float64", Dtool_WrapValue(GeomEnums::NT_float64));
    PyDict_SetItemString(dict, "NTFloat64", Dtool_WrapValue(GeomEnums::NT_float64));
    PyDict_SetItemString(dict, "NT_stdfloat", Dtool_WrapValue(GeomEnums::NT_stdfloat));
    PyDict_SetItemString(dict, "NTStdfloat", Dtool_WrapValue(GeomEnums::NT_stdfloat));
    PyDict_SetItemString(dict, "NT_int8", Dtool_WrapValue(GeomEnums::NT_int8));
    PyDict_SetItemString(dict, "NTInt8", Dtool_WrapValue(GeomEnums::NT_int8));
    PyDict_SetItemString(dict, "NT_int16", Dtool_WrapValue(GeomEnums::NT_int16));
    PyDict_SetItemString(dict, "NTInt16", Dtool_WrapValue(GeomEnums::NT_int16));
    PyDict_SetItemString(dict, "NT_int32", Dtool_WrapValue(GeomEnums::NT_int32));
    PyDict_SetItemString(dict, "NTInt32", Dtool_WrapValue(GeomEnums::NT_int32));
    PyDict_SetItemString(dict, "NT_packed_ufloat", Dtool_WrapValue(GeomEnums::NT_packed_ufloat));
    PyDict_SetItemString(dict, "NTPackedUfloat", Dtool_WrapValue(GeomEnums::NT_packed_ufloat));
    // enum GeomEnums::Contents;
    PyDict_SetItemString(dict, "C_other", Dtool_WrapValue(GeomEnums::C_other));
    PyDict_SetItemString(dict, "COther", Dtool_WrapValue(GeomEnums::C_other));
    PyDict_SetItemString(dict, "C_point", Dtool_WrapValue(GeomEnums::C_point));
    PyDict_SetItemString(dict, "CPoint", Dtool_WrapValue(GeomEnums::C_point));
    PyDict_SetItemString(dict, "C_clip_point", Dtool_WrapValue(GeomEnums::C_clip_point));
    PyDict_SetItemString(dict, "CClipPoint", Dtool_WrapValue(GeomEnums::C_clip_point));
    PyDict_SetItemString(dict, "C_vector", Dtool_WrapValue(GeomEnums::C_vector));
    PyDict_SetItemString(dict, "CVector", Dtool_WrapValue(GeomEnums::C_vector));
    PyDict_SetItemString(dict, "C_texcoord", Dtool_WrapValue(GeomEnums::C_texcoord));
    PyDict_SetItemString(dict, "CTexcoord", Dtool_WrapValue(GeomEnums::C_texcoord));
    PyDict_SetItemString(dict, "C_color", Dtool_WrapValue(GeomEnums::C_color));
    PyDict_SetItemString(dict, "CColor", Dtool_WrapValue(GeomEnums::C_color));
    PyDict_SetItemString(dict, "C_index", Dtool_WrapValue(GeomEnums::C_index));
    PyDict_SetItemString(dict, "CIndex", Dtool_WrapValue(GeomEnums::C_index));
    PyDict_SetItemString(dict, "C_morph_delta", Dtool_WrapValue(GeomEnums::C_morph_delta));
    PyDict_SetItemString(dict, "CMorphDelta", Dtool_WrapValue(GeomEnums::C_morph_delta));
    PyDict_SetItemString(dict, "C_matrix", Dtool_WrapValue(GeomEnums::C_matrix));
    PyDict_SetItemString(dict, "CMatrix", Dtool_WrapValue(GeomEnums::C_matrix));
    PyDict_SetItemString(dict, "C_normal", Dtool_WrapValue(GeomEnums::C_normal));
    PyDict_SetItemString(dict, "CNormal", Dtool_WrapValue(GeomEnums::C_normal));
    // enum GeomEnums::AnimationType;
    PyDict_SetItemString(dict, "AT_none", Dtool_WrapValue(GeomEnums::AT_none));
    PyDict_SetItemString(dict, "ATNone", Dtool_WrapValue(GeomEnums::AT_none));
    PyDict_SetItemString(dict, "AT_panda", Dtool_WrapValue(GeomEnums::AT_panda));
    PyDict_SetItemString(dict, "ATPanda", Dtool_WrapValue(GeomEnums::AT_panda));
    PyDict_SetItemString(dict, "AT_hardware", Dtool_WrapValue(GeomEnums::AT_hardware));
    PyDict_SetItemString(dict, "ATHardware", Dtool_WrapValue(GeomEnums::AT_hardware));
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomEnums) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomEnums)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomEnums);
  }
}

/**
 * Python method tables for GeomVertexAnimationSpec (GeomVertexAnimationSpec)
 */
static PyMethodDef Dtool_Methods_GeomVertexAnimationSpec[] = {
  {"assign", &Dtool_GeomVertexAnimationSpec_operator_52, METH_O, (const char *)Dtool_GeomVertexAnimationSpec_operator_52_comment},
  {"get_animation_type", &Dtool_GeomVertexAnimationSpec_get_animation_type_53, METH_NOARGS, (const char *)Dtool_GeomVertexAnimationSpec_get_animation_type_53_comment},
  {"getAnimationType", &Dtool_GeomVertexAnimationSpec_get_animation_type_53, METH_NOARGS, (const char *)Dtool_GeomVertexAnimationSpec_get_animation_type_53_comment},
  {"get_num_transforms", &Dtool_GeomVertexAnimationSpec_get_num_transforms_55, METH_NOARGS, (const char *)Dtool_GeomVertexAnimationSpec_get_num_transforms_55_comment},
  {"getNumTransforms", &Dtool_GeomVertexAnimationSpec_get_num_transforms_55, METH_NOARGS, (const char *)Dtool_GeomVertexAnimationSpec_get_num_transforms_55_comment},
  {"get_indexed_transforms", &Dtool_GeomVertexAnimationSpec_get_indexed_transforms_56, METH_NOARGS, (const char *)Dtool_GeomVertexAnimationSpec_get_indexed_transforms_56_comment},
  {"getIndexedTransforms", &Dtool_GeomVertexAnimationSpec_get_indexed_transforms_56, METH_NOARGS, (const char *)Dtool_GeomVertexAnimationSpec_get_indexed_transforms_56_comment},
  {"set_none", &Dtool_GeomVertexAnimationSpec_set_none_61, METH_NOARGS, (const char *)Dtool_GeomVertexAnimationSpec_set_none_61_comment},
  {"setNone", &Dtool_GeomVertexAnimationSpec_set_none_61, METH_NOARGS, (const char *)Dtool_GeomVertexAnimationSpec_set_none_61_comment},
  {"set_panda", &Dtool_GeomVertexAnimationSpec_set_panda_62, METH_NOARGS, (const char *)Dtool_GeomVertexAnimationSpec_set_panda_62_comment},
  {"setPanda", &Dtool_GeomVertexAnimationSpec_set_panda_62, METH_NOARGS, (const char *)Dtool_GeomVertexAnimationSpec_set_panda_62_comment},
  {"set_hardware", (PyCFunction) &Dtool_GeomVertexAnimationSpec_set_hardware_63, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexAnimationSpec_set_hardware_63_comment},
  {"setHardware", (PyCFunction) &Dtool_GeomVertexAnimationSpec_set_hardware_63, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexAnimationSpec_set_hardware_63_comment},
  {"output", &Dtool_GeomVertexAnimationSpec_output_64, METH_O, (const char *)Dtool_GeomVertexAnimationSpec_output_64_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     GeomVertexAnimationSpec
//////////////////
static PyObject *Dtool_Repr_GeomVertexAnimationSpec(PyObject *self) {
  GeomVertexAnimationSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexAnimationSpec, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_GeomVertexAnimationSpec[] = {
  {(char *)"animation_type", &Dtool_GeomVertexAnimationSpec_animation_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_transforms", &Dtool_GeomVertexAnimationSpec_num_transforms_Getter, nullptr, nullptr, nullptr},
  {(char *)"indexed_transforms", &Dtool_GeomVertexAnimationSpec_indexed_transforms_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GeomVertexAnimationSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomVertexAnimationSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomVertexAnimationSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomVertexAnimationSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomVertexAnimationSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomVertexAnimationSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomVertexAnimationSpec",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomVertexAnimationSpec,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomVertexAnimationSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_GeomVertexAnimationSpec,
    &Dtool_NumberMethods_GeomVertexAnimationSpec,
    &Dtool_SequenceMethods_GeomVertexAnimationSpec,
    &Dtool_MappingMethods_GeomVertexAnimationSpec,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_GeomVertexAnimationSpec,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomVertexAnimationSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object describes how the vertex animation, if any, represented in a\n"
    " * GeomVertexData is encoded.\n"
    " *\n"
    " * Vertex animation includes soft-skinned skeleton animation and morphs (blend\n"
    " * shapes), and might be performed on the CPU by Panda, or passed down to the\n"
    " * graphics backed to be performed on the hardware (depending on the\n"
    " * hardware's advertised capabilities).\n"
    " *\n"
    " * Changing this setting doesn't by itself change the way the animation is\n"
    " * actually performed; this just specifies how the vertices are set up to be\n"
    " * animated.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomVertexAnimationSpec,
    nullptr, // tp_members
    Dtool_Properties_GeomVertexAnimationSpec,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomVertexAnimationSpec,
    PyType_GenericAlloc,
    Dtool_new_GeomVertexAnimationSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomVertexAnimationSpec,
  Dtool_UpcastInterface_GeomVertexAnimationSpec,
  Dtool_DowncastInterface_GeomVertexAnimationSpec,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomVertexAnimationSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_GeomVertexAnimationSpec._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_GeomVertexAnimationSpec._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomVertexAnimationSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomVertexAnimationSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomVertexAnimationSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomVertexAnimationSpec);
  }
}

/**
 * Python method tables for InternalName (InternalName)
 */
static PyMethodDef Dtool_Methods_InternalName[] = {
  {"make", (PyCFunction) &Dtool_InternalName_make_68, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_InternalName_make_68_comment},
  {"append", &Dtool_InternalName_append_69, METH_O, (const char *)Dtool_InternalName_append_69_comment},
  {"get_parent", &Dtool_InternalName_get_parent_70, METH_NOARGS, (const char *)Dtool_InternalName_get_parent_70_comment},
  {"getParent", &Dtool_InternalName_get_parent_70, METH_NOARGS, (const char *)Dtool_InternalName_get_parent_70_comment},
  {"get_name", &Dtool_InternalName_get_name_71, METH_NOARGS, (const char *)Dtool_InternalName_get_name_71_comment},
  {"getName", &Dtool_InternalName_get_name_71, METH_NOARGS, (const char *)Dtool_InternalName_get_name_71_comment},
  {"join", &Dtool_InternalName_join_72, METH_O, (const char *)Dtool_InternalName_join_72_comment},
  {"get_basename", &Dtool_InternalName_get_basename_73, METH_NOARGS, (const char *)Dtool_InternalName_get_basename_73_comment},
  {"getBasename", &Dtool_InternalName_get_basename_73, METH_NOARGS, (const char *)Dtool_InternalName_get_basename_73_comment},
  {"find_ancestor", &Dtool_InternalName_find_ancestor_81, METH_O, (const char *)Dtool_InternalName_find_ancestor_81_comment},
  {"findAncestor", &Dtool_InternalName_find_ancestor_81, METH_O, (const char *)Dtool_InternalName_find_ancestor_81_comment},
  {"get_ancestor", &Dtool_InternalName_get_ancestor_82, METH_O, (const char *)Dtool_InternalName_get_ancestor_82_comment},
  {"getAncestor", &Dtool_InternalName_get_ancestor_82, METH_O, (const char *)Dtool_InternalName_get_ancestor_82_comment},
  {"get_top", &Dtool_InternalName_get_top_83, METH_NOARGS, (const char *)Dtool_InternalName_get_top_83_comment},
  {"getTop", &Dtool_InternalName_get_top_83, METH_NOARGS, (const char *)Dtool_InternalName_get_top_83_comment},
  {"get_net_basename", &Dtool_InternalName_get_net_basename_84, METH_O, (const char *)Dtool_InternalName_get_net_basename_84_comment},
  {"getNetBasename", &Dtool_InternalName_get_net_basename_84, METH_O, (const char *)Dtool_InternalName_get_net_basename_84_comment},
  {"output", &Dtool_InternalName_output_85, METH_O, (const char *)Dtool_InternalName_output_85_comment},
  {"get_root", &Dtool_InternalName_get_root_86, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_root_86_comment},
  {"getRoot", &Dtool_InternalName_get_root_86, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_root_86_comment},
  {"get_error", &Dtool_InternalName_get_error_87, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_error_87_comment},
  {"getError", &Dtool_InternalName_get_error_87, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_error_87_comment},
  {"get_vertex", &Dtool_InternalName_get_vertex_88, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_vertex_88_comment},
  {"getVertex", &Dtool_InternalName_get_vertex_88, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_vertex_88_comment},
  {"get_normal", &Dtool_InternalName_get_normal_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_normal_89_comment},
  {"getNormal", &Dtool_InternalName_get_normal_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_normal_89_comment},
  {"get_tangent", &Dtool_InternalName_get_tangent_90, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_tangent_90_comment},
  {"getTangent", &Dtool_InternalName_get_tangent_90, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_tangent_90_comment},
  {"get_tangent_name", &Dtool_InternalName_get_tangent_name_91, METH_O | METH_STATIC, (const char *)Dtool_InternalName_get_tangent_name_91_comment},
  {"getTangentName", &Dtool_InternalName_get_tangent_name_91, METH_O | METH_STATIC, (const char *)Dtool_InternalName_get_tangent_name_91_comment},
  {"get_binormal", &Dtool_InternalName_get_binormal_92, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_binormal_92_comment},
  {"getBinormal", &Dtool_InternalName_get_binormal_92, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_binormal_92_comment},
  {"get_binormal_name", &Dtool_InternalName_get_binormal_name_93, METH_O | METH_STATIC, (const char *)Dtool_InternalName_get_binormal_name_93_comment},
  {"getBinormalName", &Dtool_InternalName_get_binormal_name_93, METH_O | METH_STATIC, (const char *)Dtool_InternalName_get_binormal_name_93_comment},
  {"get_texcoord", &Dtool_InternalName_get_texcoord_94, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_texcoord_94_comment},
  {"getTexcoord", &Dtool_InternalName_get_texcoord_94, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_texcoord_94_comment},
  {"get_texcoord_name", &Dtool_InternalName_get_texcoord_name_95, METH_O | METH_STATIC, (const char *)Dtool_InternalName_get_texcoord_name_95_comment},
  {"getTexcoordName", &Dtool_InternalName_get_texcoord_name_95, METH_O | METH_STATIC, (const char *)Dtool_InternalName_get_texcoord_name_95_comment},
  {"get_color", &Dtool_InternalName_get_color_96, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_color_96_comment},
  {"getColor", &Dtool_InternalName_get_color_96, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_color_96_comment},
  {"get_rotate", &Dtool_InternalName_get_rotate_97, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_rotate_97_comment},
  {"getRotate", &Dtool_InternalName_get_rotate_97, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_rotate_97_comment},
  {"get_size", &Dtool_InternalName_get_size_98, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_size_98_comment},
  {"getSize", &Dtool_InternalName_get_size_98, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_size_98_comment},
  {"get_aspect_ratio", &Dtool_InternalName_get_aspect_ratio_99, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_aspect_ratio_99_comment},
  {"getAspectRatio", &Dtool_InternalName_get_aspect_ratio_99, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_aspect_ratio_99_comment},
  {"get_transform_blend", &Dtool_InternalName_get_transform_blend_100, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_transform_blend_100_comment},
  {"getTransformBlend", &Dtool_InternalName_get_transform_blend_100, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_transform_blend_100_comment},
  {"get_transform_weight", &Dtool_InternalName_get_transform_weight_101, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_transform_weight_101_comment},
  {"getTransformWeight", &Dtool_InternalName_get_transform_weight_101, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_transform_weight_101_comment},
  {"get_transform_index", &Dtool_InternalName_get_transform_index_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_transform_index_102_comment},
  {"getTransformIndex", &Dtool_InternalName_get_transform_index_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_transform_index_102_comment},
  {"get_morph", (PyCFunction) &Dtool_InternalName_get_morph_103, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_InternalName_get_morph_103_comment},
  {"getMorph", (PyCFunction) &Dtool_InternalName_get_morph_103, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_InternalName_get_morph_103_comment},
  {"get_index", &Dtool_InternalName_get_index_104, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_index_104_comment},
  {"getIndex", &Dtool_InternalName_get_index_104, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_index_104_comment},
  {"get_world", &Dtool_InternalName_get_world_105, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_world_105_comment},
  {"getWorld", &Dtool_InternalName_get_world_105, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_world_105_comment},
  {"get_camera", &Dtool_InternalName_get_camera_106, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_camera_106_comment},
  {"getCamera", &Dtool_InternalName_get_camera_106, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_camera_106_comment},
  {"get_model", &Dtool_InternalName_get_model_107, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_model_107_comment},
  {"getModel", &Dtool_InternalName_get_model_107, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_model_107_comment},
  {"get_view", &Dtool_InternalName_get_view_108, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_view_108_comment},
  {"getView", &Dtool_InternalName_get_view_108, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_view_108_comment},
  {"get_class_type", &Dtool_InternalName_get_class_type_109, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_class_type_109_comment},
  {"getClassType", &Dtool_InternalName_get_class_type_109, METH_NOARGS | METH_STATIC, (const char *)Dtool_InternalName_get_class_type_109_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     InternalName
//////////////////
static PyObject *Dtool_Repr_InternalName(PyObject *self) {
  InternalName *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalName, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_InternalName[] = {
  {(char *)"parent", &Dtool_InternalName_parent_Getter, nullptr, nullptr, nullptr},
  {(char *)"name", &Dtool_InternalName_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"basename", &Dtool_InternalName_basename_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_InternalName = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_InternalName = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_InternalName = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_InternalName = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_InternalName = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_InternalName = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.InternalName",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InternalName,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_InternalName,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_InternalName,
    &Dtool_NumberMethods_InternalName,
    &Dtool_SequenceMethods_InternalName,
    &Dtool_MappingMethods_InternalName,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_InternalName,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_InternalName,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Encodes a string name in a hash table, mapping it to a pointer.  This is\n"
    " * used to tokenify names so they may be used efficiently in low-level Panda\n"
    " * structures, for instance to differentiate the multiple sets of texture\n"
    " * coordinates that might be stored on a Geom.\n"
    " *\n"
    " * InternalNames are hierarchical, with the '.' used by convention as a\n"
    " * separator character.  You can construct a single InternalName as a\n"
    " * composition of one or more other names, or by giving it a source string\n"
    " * directly.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InternalName,
    nullptr, // tp_members
    Dtool_Properties_InternalName,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InternalName,
    PyType_GenericAlloc,
    Dtool_new_InternalName,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InternalName,
  Dtool_UpcastInterface_InternalName,
  Dtool_DowncastInterface_InternalName,
  (CoerceFunction)Dtool_ConstCoerce_InternalName,
  (CoerceFunction)Dtool_Coerce_InternalName,
};

static void Dtool_PyModuleClassInit_InternalName(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_InternalName._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_InternalName._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_InternalName._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InternalName) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InternalName)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InternalName);
  }
}

/**
 * Python method tables for GeomVertexColumn (GeomVertexColumn)
 */
static PyMethodDef Dtool_Methods_GeomVertexColumn[] = {
  {"assign", &Dtool_GeomVertexColumn_operator_112, METH_O, (const char *)Dtool_GeomVertexColumn_operator_112_comment},
  {"get_name", &Dtool_GeomVertexColumn_get_name_114, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_name_114_comment},
  {"getName", &Dtool_GeomVertexColumn_get_name_114, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_name_114_comment},
  {"get_num_components", &Dtool_GeomVertexColumn_get_num_components_115, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_num_components_115_comment},
  {"getNumComponents", &Dtool_GeomVertexColumn_get_num_components_115, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_num_components_115_comment},
  {"get_num_values", &Dtool_GeomVertexColumn_get_num_values_116, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_num_values_116_comment},
  {"getNumValues", &Dtool_GeomVertexColumn_get_num_values_116, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_num_values_116_comment},
  {"get_num_elements", &Dtool_GeomVertexColumn_get_num_elements_117, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_num_elements_117_comment},
  {"getNumElements", &Dtool_GeomVertexColumn_get_num_elements_117, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_num_elements_117_comment},
  {"get_numeric_type", &Dtool_GeomVertexColumn_get_numeric_type_118, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_numeric_type_118_comment},
  {"getNumericType", &Dtool_GeomVertexColumn_get_numeric_type_118, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_numeric_type_118_comment},
  {"get_contents", &Dtool_GeomVertexColumn_get_contents_119, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_contents_119_comment},
  {"getContents", &Dtool_GeomVertexColumn_get_contents_119, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_contents_119_comment},
  {"get_start", &Dtool_GeomVertexColumn_get_start_120, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_start_120_comment},
  {"getStart", &Dtool_GeomVertexColumn_get_start_120, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_start_120_comment},
  {"get_column_alignment", &Dtool_GeomVertexColumn_get_column_alignment_121, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_column_alignment_121_comment},
  {"getColumnAlignment", &Dtool_GeomVertexColumn_get_column_alignment_121, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_column_alignment_121_comment},
  {"get_element_stride", &Dtool_GeomVertexColumn_get_element_stride_122, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_element_stride_122_comment},
  {"getElementStride", &Dtool_GeomVertexColumn_get_element_stride_122, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_element_stride_122_comment},
  {"get_component_bytes", &Dtool_GeomVertexColumn_get_component_bytes_123, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_component_bytes_123_comment},
  {"getComponentBytes", &Dtool_GeomVertexColumn_get_component_bytes_123, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_component_bytes_123_comment},
  {"get_total_bytes", &Dtool_GeomVertexColumn_get_total_bytes_124, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_total_bytes_124_comment},
  {"getTotalBytes", &Dtool_GeomVertexColumn_get_total_bytes_124, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_get_total_bytes_124_comment},
  {"has_homogeneous_coord", &Dtool_GeomVertexColumn_has_homogeneous_coord_125, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_has_homogeneous_coord_125_comment},
  {"hasHomogeneousCoord", &Dtool_GeomVertexColumn_has_homogeneous_coord_125, METH_NOARGS, (const char *)Dtool_GeomVertexColumn_has_homogeneous_coord_125_comment},
  {"overlaps_with", (PyCFunction) &Dtool_GeomVertexColumn_overlaps_with_126, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexColumn_overlaps_with_126_comment},
  {"overlapsWith", (PyCFunction) &Dtool_GeomVertexColumn_overlaps_with_126, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexColumn_overlaps_with_126_comment},
  {"is_bytewise_equivalent", &Dtool_GeomVertexColumn_is_bytewise_equivalent_127, METH_O, (const char *)Dtool_GeomVertexColumn_is_bytewise_equivalent_127_comment},
  {"isBytewiseEquivalent", &Dtool_GeomVertexColumn_is_bytewise_equivalent_127, METH_O, (const char *)Dtool_GeomVertexColumn_is_bytewise_equivalent_127_comment},
  {"set_name", &Dtool_GeomVertexColumn_set_name_128, METH_O, (const char *)Dtool_GeomVertexColumn_set_name_128_comment},
  {"setName", &Dtool_GeomVertexColumn_set_name_128, METH_O, (const char *)Dtool_GeomVertexColumn_set_name_128_comment},
  {"set_num_components", &Dtool_GeomVertexColumn_set_num_components_129, METH_O, (const char *)Dtool_GeomVertexColumn_set_num_components_129_comment},
  {"setNumComponents", &Dtool_GeomVertexColumn_set_num_components_129, METH_O, (const char *)Dtool_GeomVertexColumn_set_num_components_129_comment},
  {"set_numeric_type", &Dtool_GeomVertexColumn_set_numeric_type_130, METH_O, (const char *)Dtool_GeomVertexColumn_set_numeric_type_130_comment},
  {"setNumericType", &Dtool_GeomVertexColumn_set_numeric_type_130, METH_O, (const char *)Dtool_GeomVertexColumn_set_numeric_type_130_comment},
  {"set_contents", &Dtool_GeomVertexColumn_set_contents_131, METH_O, (const char *)Dtool_GeomVertexColumn_set_contents_131_comment},
  {"setContents", &Dtool_GeomVertexColumn_set_contents_131, METH_O, (const char *)Dtool_GeomVertexColumn_set_contents_131_comment},
  {"set_start", &Dtool_GeomVertexColumn_set_start_132, METH_O, (const char *)Dtool_GeomVertexColumn_set_start_132_comment},
  {"setStart", &Dtool_GeomVertexColumn_set_start_132, METH_O, (const char *)Dtool_GeomVertexColumn_set_start_132_comment},
  {"set_column_alignment", &Dtool_GeomVertexColumn_set_column_alignment_133, METH_O, (const char *)Dtool_GeomVertexColumn_set_column_alignment_133_comment},
  {"setColumnAlignment", &Dtool_GeomVertexColumn_set_column_alignment_133, METH_O, (const char *)Dtool_GeomVertexColumn_set_column_alignment_133_comment},
  {"output", &Dtool_GeomVertexColumn_output_134, METH_O, (const char *)Dtool_GeomVertexColumn_output_134_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     GeomVertexColumn
//////////////////
static PyObject *Dtool_Repr_GeomVertexColumn(PyObject *self) {
  GeomVertexColumn *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexColumn, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_GeomVertexColumn = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomVertexColumn = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomVertexColumn = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomVertexColumn = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomVertexColumn = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomVertexColumn = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomVertexColumn",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomVertexColumn,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomVertexColumn,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_GeomVertexColumn,
    &Dtool_NumberMethods_GeomVertexColumn,
    &Dtool_SequenceMethods_GeomVertexColumn,
    &Dtool_MappingMethods_GeomVertexColumn,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_GeomVertexColumn,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomVertexColumn,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines how a single column is interleaved within a vertex array\n"
    " * stored within a Geom.  The GeomVertexArrayFormat class maintains a list of\n"
    " * these to completely define a particular array structure.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomVertexColumn,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomVertexColumn,
    PyType_GenericAlloc,
    Dtool_new_GeomVertexColumn,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomVertexColumn,
  Dtool_UpcastInterface_GeomVertexColumn,
  Dtool_DowncastInterface_GeomVertexColumn,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomVertexColumn(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_GeomVertexColumn._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_GeomVertexColumn._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomVertexColumn._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomVertexColumn) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomVertexColumn)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomVertexColumn);
  }
}

/**
 * Python method tables for GeomVertexArrayFormat (GeomVertexArrayFormat)
 */
static PyMethodDef Dtool_Methods_GeomVertexArrayFormat[] = {
  {"assign", &Dtool_GeomVertexArrayFormat_operator_141, METH_O, (const char *)Dtool_GeomVertexArrayFormat_operator_141_comment},
  {"unref", &Dtool_GeomVertexArrayFormat_unref_143, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_unref_143_comment},
  {"is_registered", &Dtool_GeomVertexArrayFormat_is_registered_144, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_is_registered_144_comment},
  {"isRegistered", &Dtool_GeomVertexArrayFormat_is_registered_144, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_is_registered_144_comment},
  {"register_format", &Dtool_GeomVertexArrayFormat_register_format_145, METH_O | METH_STATIC, (const char *)Dtool_GeomVertexArrayFormat_register_format_145_comment},
  {"registerFormat", &Dtool_GeomVertexArrayFormat_register_format_145, METH_O | METH_STATIC, (const char *)Dtool_GeomVertexArrayFormat_register_format_145_comment},
  {"get_stride", &Dtool_GeomVertexArrayFormat_get_stride_147, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_get_stride_147_comment},
  {"getStride", &Dtool_GeomVertexArrayFormat_get_stride_147, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_get_stride_147_comment},
  {"set_stride", &Dtool_GeomVertexArrayFormat_set_stride_148, METH_O, (const char *)Dtool_GeomVertexArrayFormat_set_stride_148_comment},
  {"setStride", &Dtool_GeomVertexArrayFormat_set_stride_148, METH_O, (const char *)Dtool_GeomVertexArrayFormat_set_stride_148_comment},
  {"get_pad_to", &Dtool_GeomVertexArrayFormat_get_pad_to_150, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_get_pad_to_150_comment},
  {"getPadTo", &Dtool_GeomVertexArrayFormat_get_pad_to_150, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_get_pad_to_150_comment},
  {"set_pad_to", &Dtool_GeomVertexArrayFormat_set_pad_to_151, METH_O, (const char *)Dtool_GeomVertexArrayFormat_set_pad_to_151_comment},
  {"setPadTo", &Dtool_GeomVertexArrayFormat_set_pad_to_151, METH_O, (const char *)Dtool_GeomVertexArrayFormat_set_pad_to_151_comment},
  {"get_divisor", &Dtool_GeomVertexArrayFormat_get_divisor_153, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_get_divisor_153_comment},
  {"getDivisor", &Dtool_GeomVertexArrayFormat_get_divisor_153, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_get_divisor_153_comment},
  {"set_divisor", &Dtool_GeomVertexArrayFormat_set_divisor_154, METH_O, (const char *)Dtool_GeomVertexArrayFormat_set_divisor_154_comment},
  {"setDivisor", &Dtool_GeomVertexArrayFormat_set_divisor_154, METH_O, (const char *)Dtool_GeomVertexArrayFormat_set_divisor_154_comment},
  {"get_total_bytes", &Dtool_GeomVertexArrayFormat_get_total_bytes_156, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_get_total_bytes_156_comment},
  {"getTotalBytes", &Dtool_GeomVertexArrayFormat_get_total_bytes_156, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_get_total_bytes_156_comment},
  {"add_column", (PyCFunction) &Dtool_GeomVertexArrayFormat_add_column_158, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayFormat_add_column_158_comment},
  {"addColumn", (PyCFunction) &Dtool_GeomVertexArrayFormat_add_column_158, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayFormat_add_column_158_comment},
  {"remove_column", &Dtool_GeomVertexArrayFormat_remove_column_159, METH_O, (const char *)Dtool_GeomVertexArrayFormat_remove_column_159_comment},
  {"removeColumn", &Dtool_GeomVertexArrayFormat_remove_column_159, METH_O, (const char *)Dtool_GeomVertexArrayFormat_remove_column_159_comment},
  {"clear_columns", &Dtool_GeomVertexArrayFormat_clear_columns_160, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_clear_columns_160_comment},
  {"clearColumns", &Dtool_GeomVertexArrayFormat_clear_columns_160, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_clear_columns_160_comment},
  {"pack_columns", &Dtool_GeomVertexArrayFormat_pack_columns_161, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_pack_columns_161_comment},
  {"packColumns", &Dtool_GeomVertexArrayFormat_pack_columns_161, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_pack_columns_161_comment},
  {"align_columns_for_animation", &Dtool_GeomVertexArrayFormat_align_columns_for_animation_162, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_align_columns_for_animation_162_comment},
  {"alignColumnsForAnimation", &Dtool_GeomVertexArrayFormat_align_columns_for_animation_162, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_align_columns_for_animation_162_comment},
  {"get_num_columns", &Dtool_GeomVertexArrayFormat_get_num_columns_163, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_get_num_columns_163_comment},
  {"getNumColumns", &Dtool_GeomVertexArrayFormat_get_num_columns_163, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_get_num_columns_163_comment},
  {"get_column", (PyCFunction) &Dtool_GeomVertexArrayFormat_get_column_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayFormat_get_column_164_comment},
  {"getColumn", (PyCFunction) &Dtool_GeomVertexArrayFormat_get_column_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayFormat_get_column_164_comment},
  {"has_column", &Dtool_GeomVertexArrayFormat_has_column_169, METH_O, (const char *)Dtool_GeomVertexArrayFormat_has_column_169_comment},
  {"hasColumn", &Dtool_GeomVertexArrayFormat_has_column_169, METH_O, (const char *)Dtool_GeomVertexArrayFormat_has_column_169_comment},
  {"is_data_subset_of", &Dtool_GeomVertexArrayFormat_is_data_subset_of_170, METH_O, (const char *)Dtool_GeomVertexArrayFormat_is_data_subset_of_170_comment},
  {"isDataSubsetOf", &Dtool_GeomVertexArrayFormat_is_data_subset_of_170, METH_O, (const char *)Dtool_GeomVertexArrayFormat_is_data_subset_of_170_comment},
  {"count_unused_space", &Dtool_GeomVertexArrayFormat_count_unused_space_171, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_count_unused_space_171_comment},
  {"countUnusedSpace", &Dtool_GeomVertexArrayFormat_count_unused_space_171, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_count_unused_space_171_comment},
  {"output", &Dtool_GeomVertexArrayFormat_output_172, METH_O, (const char *)Dtool_GeomVertexArrayFormat_output_172_comment},
  {"write", (PyCFunction) &Dtool_GeomVertexArrayFormat_write_173, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayFormat_write_173_comment},
  {"write_with_data", (PyCFunction) &Dtool_GeomVertexArrayFormat_write_with_data_174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayFormat_write_with_data_174_comment},
  {"writeWithData", (PyCFunction) &Dtool_GeomVertexArrayFormat_write_with_data_174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayFormat_write_with_data_174_comment},
  {"get_format_string", (PyCFunction) &Dtool_GeomVertexArrayFormat_get_format_string_175, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayFormat_get_format_string_175_comment},
  {"getFormatString", (PyCFunction) &Dtool_GeomVertexArrayFormat_get_format_string_175, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayFormat_get_format_string_175_comment},
  {"get_class_type", &Dtool_GeomVertexArrayFormat_get_class_type_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayFormat_get_class_type_176_comment},
  {"getClassType", &Dtool_GeomVertexArrayFormat_get_class_type_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayFormat_get_class_type_176_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_GeomVertexArrayFormat_upcast_to_TypedWritableReferenceCount_136, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_upcast_to_TypedWritableReferenceCount_136_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_GeomVertexArrayFormat_upcast_to_TypedWritableReferenceCount_136, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_upcast_to_TypedWritableReferenceCount_136_comment},
  {"upcast_to_GeomEnums", &Dtool_GeomVertexArrayFormat_upcast_to_GeomEnums_138, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_upcast_to_GeomEnums_138_comment},
  {"upcastToGeomEnums", &Dtool_GeomVertexArrayFormat_upcast_to_GeomEnums_138, METH_NOARGS, (const char *)Dtool_GeomVertexArrayFormat_upcast_to_GeomEnums_138_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_columns", (PyCFunction) &MakeSeq_GeomVertexArrayFormat_get_columns, METH_NOARGS, nullptr},
  { "getColumns", (PyCFunction) &MakeSeq_GeomVertexArrayFormat_get_columns, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     GeomVertexArrayFormat
//////////////////
static PyObject *Dtool_Repr_GeomVertexArrayFormat(PyObject *self) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayFormat, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     GeomVertexArrayFormat
//////////////////
static PyObject *Dtool_Str_GeomVertexArrayFormat(PyObject *self) {
  GeomVertexArrayFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayFormat, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_GeomVertexArrayFormat[] = {
  {(char *)"registered", &Dtool_GeomVertexArrayFormat_registered_Getter, nullptr, nullptr, nullptr},
  {(char *)"stride", &Dtool_GeomVertexArrayFormat_stride_Getter, &Dtool_GeomVertexArrayFormat_stride_Setter, nullptr, nullptr},
  {(char *)"pad_to", &Dtool_GeomVertexArrayFormat_pad_to_Getter, &Dtool_GeomVertexArrayFormat_pad_to_Setter, nullptr, nullptr},
  {(char *)"divisor", &Dtool_GeomVertexArrayFormat_divisor_Getter, &Dtool_GeomVertexArrayFormat_divisor_Setter, nullptr, nullptr},
  {(char *)"total_bytes", &Dtool_GeomVertexArrayFormat_total_bytes_Getter, nullptr, nullptr, nullptr},
  {(char *)"columns", &Dtool_GeomVertexArrayFormat_columns_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GeomVertexArrayFormat = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomVertexArrayFormat = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomVertexArrayFormat = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomVertexArrayFormat = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomVertexArrayFormat = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomVertexArrayFormat = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomVertexArrayFormat",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomVertexArrayFormat,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomVertexArrayFormat,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_GeomVertexArrayFormat,
    &Dtool_NumberMethods_GeomVertexArrayFormat,
    &Dtool_SequenceMethods_GeomVertexArrayFormat,
    &Dtool_MappingMethods_GeomVertexArrayFormat,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_GeomVertexArrayFormat,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomVertexArrayFormat,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This describes the structure of a single array within a Geom data.  See\n"
    " * GeomVertexFormat for the parent class which collects together all of the\n"
    " * individual GeomVertexArrayFormat objects.\n"
    " *\n"
    " * A particular array may include any number of standard or user-defined\n"
    " * columns.  All columns consist of a sequence of one or more numeric values,\n"
    " * packed in any of a variety of formats; the semantic meaning of each column\n"
    " * is defined in general with its contents member, and in particular by its\n"
    " * name.  The standard array types used most often are named \"vertex\",\n"
    " * \"normal\", \"texcoord\", and \"color\"; other kinds of data may be piggybacked\n"
    " * into the data record simply by choosing a unique name.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomVertexArrayFormat,
    nullptr, // tp_members
    Dtool_Properties_GeomVertexArrayFormat,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomVertexArrayFormat,
    PyType_GenericAlloc,
    Dtool_new_GeomVertexArrayFormat,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomVertexArrayFormat,
  Dtool_UpcastInterface_GeomVertexArrayFormat,
  Dtool_DowncastInterface_GeomVertexArrayFormat,
  (CoerceFunction)Dtool_ConstCoerce_GeomVertexArrayFormat,
  (CoerceFunction)Dtool_Coerce_GeomVertexArrayFormat,
};

static void Dtool_PyModuleClassInit_GeomVertexArrayFormat(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_GeomVertexArrayFormat._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_GeomVertexArrayFormat._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomVertexArrayFormat._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomVertexArrayFormat) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomVertexArrayFormat)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomVertexArrayFormat);
  }
}

/**
 * Python method tables for GeomVertexFormat (GeomVertexFormat)
 */
static PyMethodDef Dtool_Methods_GeomVertexFormat[] = {
  {"assign", &Dtool_GeomVertexFormat_operator_183, METH_O, (const char *)Dtool_GeomVertexFormat_operator_183_comment},
  {"unref", &Dtool_GeomVertexFormat_unref_185, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_unref_185_comment},
  {"is_registered", &Dtool_GeomVertexFormat_is_registered_186, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_is_registered_186_comment},
  {"isRegistered", &Dtool_GeomVertexFormat_is_registered_186, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_is_registered_186_comment},
  {"register_format", &Dtool_GeomVertexFormat_register_format_187, METH_O | METH_STATIC, (const char *)Dtool_GeomVertexFormat_register_format_187_comment},
  {"registerFormat", &Dtool_GeomVertexFormat_register_format_187, METH_O | METH_STATIC, (const char *)Dtool_GeomVertexFormat_register_format_187_comment},
  {"get_animation", &Dtool_GeomVertexFormat_get_animation_189, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_animation_189_comment},
  {"getAnimation", &Dtool_GeomVertexFormat_get_animation_189, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_animation_189_comment},
  {"set_animation", &Dtool_GeomVertexFormat_set_animation_190, METH_O, (const char *)Dtool_GeomVertexFormat_set_animation_190_comment},
  {"setAnimation", &Dtool_GeomVertexFormat_set_animation_190, METH_O, (const char *)Dtool_GeomVertexFormat_set_animation_190_comment},
  {"get_post_animated_format", &Dtool_GeomVertexFormat_get_post_animated_format_193, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_post_animated_format_193_comment},
  {"getPostAnimatedFormat", &Dtool_GeomVertexFormat_get_post_animated_format_193, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_post_animated_format_193_comment},
  {"get_union_format", &Dtool_GeomVertexFormat_get_union_format_194, METH_O, (const char *)Dtool_GeomVertexFormat_get_union_format_194_comment},
  {"getUnionFormat", &Dtool_GeomVertexFormat_get_union_format_194, METH_O, (const char *)Dtool_GeomVertexFormat_get_union_format_194_comment},
  {"get_num_arrays", &Dtool_GeomVertexFormat_get_num_arrays_195, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_arrays_195_comment},
  {"getNumArrays", &Dtool_GeomVertexFormat_get_num_arrays_195, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_arrays_195_comment},
  {"get_array", &Dtool_GeomVertexFormat_get_array_196, METH_O, (const char *)Dtool_GeomVertexFormat_get_array_196_comment},
  {"getArray", &Dtool_GeomVertexFormat_get_array_196, METH_O, (const char *)Dtool_GeomVertexFormat_get_array_196_comment},
  {"modify_array", &Dtool_GeomVertexFormat_modify_array_198, METH_O, (const char *)Dtool_GeomVertexFormat_modify_array_198_comment},
  {"modifyArray", &Dtool_GeomVertexFormat_modify_array_198, METH_O, (const char *)Dtool_GeomVertexFormat_modify_array_198_comment},
  {"set_array", (PyCFunction) &Dtool_GeomVertexFormat_set_array_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexFormat_set_array_199_comment},
  {"setArray", (PyCFunction) &Dtool_GeomVertexFormat_set_array_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexFormat_set_array_199_comment},
  {"remove_array", &Dtool_GeomVertexFormat_remove_array_200, METH_O, (const char *)Dtool_GeomVertexFormat_remove_array_200_comment},
  {"removeArray", &Dtool_GeomVertexFormat_remove_array_200, METH_O, (const char *)Dtool_GeomVertexFormat_remove_array_200_comment},
  {"add_array", &Dtool_GeomVertexFormat_add_array_201, METH_O, (const char *)Dtool_GeomVertexFormat_add_array_201_comment},
  {"addArray", &Dtool_GeomVertexFormat_add_array_201, METH_O, (const char *)Dtool_GeomVertexFormat_add_array_201_comment},
  {"insert_array", (PyCFunction) &Dtool_GeomVertexFormat_insert_array_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexFormat_insert_array_202_comment},
  {"insertArray", (PyCFunction) &Dtool_GeomVertexFormat_insert_array_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexFormat_insert_array_202_comment},
  {"clear_arrays", &Dtool_GeomVertexFormat_clear_arrays_203, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_clear_arrays_203_comment},
  {"clearArrays", &Dtool_GeomVertexFormat_clear_arrays_203, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_clear_arrays_203_comment},
  {"remove_empty_arrays", &Dtool_GeomVertexFormat_remove_empty_arrays_204, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_remove_empty_arrays_204_comment},
  {"removeEmptyArrays", &Dtool_GeomVertexFormat_remove_empty_arrays_204, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_remove_empty_arrays_204_comment},
  {"get_num_columns", &Dtool_GeomVertexFormat_get_num_columns_205, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_columns_205_comment},
  {"getNumColumns", &Dtool_GeomVertexFormat_get_num_columns_205, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_columns_205_comment},
  {"get_array_with", &Dtool_GeomVertexFormat_get_array_with_206, METH_O, (const char *)Dtool_GeomVertexFormat_get_array_with_206_comment},
  {"getArrayWith", &Dtool_GeomVertexFormat_get_array_with_206, METH_O, (const char *)Dtool_GeomVertexFormat_get_array_with_206_comment},
  {"get_column", &Dtool_GeomVertexFormat_get_column_207, METH_O, (const char *)Dtool_GeomVertexFormat_get_column_207_comment},
  {"getColumn", &Dtool_GeomVertexFormat_get_column_207, METH_O, (const char *)Dtool_GeomVertexFormat_get_column_207_comment},
  {"has_column", &Dtool_GeomVertexFormat_has_column_208, METH_O, (const char *)Dtool_GeomVertexFormat_has_column_208_comment},
  {"hasColumn", &Dtool_GeomVertexFormat_has_column_208, METH_O, (const char *)Dtool_GeomVertexFormat_has_column_208_comment},
  {"get_column_name", &Dtool_GeomVertexFormat_get_column_name_209, METH_O, (const char *)Dtool_GeomVertexFormat_get_column_name_209_comment},
  {"getColumnName", &Dtool_GeomVertexFormat_get_column_name_209, METH_O, (const char *)Dtool_GeomVertexFormat_get_column_name_209_comment},
  {"remove_column", (PyCFunction) &Dtool_GeomVertexFormat_remove_column_211, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexFormat_remove_column_211_comment},
  {"removeColumn", (PyCFunction) &Dtool_GeomVertexFormat_remove_column_211, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexFormat_remove_column_211_comment},
  {"pack_columns", &Dtool_GeomVertexFormat_pack_columns_212, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_pack_columns_212_comment},
  {"packColumns", &Dtool_GeomVertexFormat_pack_columns_212, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_pack_columns_212_comment},
  {"align_columns_for_animation", &Dtool_GeomVertexFormat_align_columns_for_animation_213, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_align_columns_for_animation_213_comment},
  {"alignColumnsForAnimation", &Dtool_GeomVertexFormat_align_columns_for_animation_213, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_align_columns_for_animation_213_comment},
  {"maybe_align_columns_for_animation", &Dtool_GeomVertexFormat_maybe_align_columns_for_animation_214, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_maybe_align_columns_for_animation_214_comment},
  {"maybeAlignColumnsForAnimation", &Dtool_GeomVertexFormat_maybe_align_columns_for_animation_214, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_maybe_align_columns_for_animation_214_comment},
  {"get_num_points", &Dtool_GeomVertexFormat_get_num_points_215, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_points_215_comment},
  {"getNumPoints", &Dtool_GeomVertexFormat_get_num_points_215, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_points_215_comment},
  {"get_point", &Dtool_GeomVertexFormat_get_point_216, METH_O, (const char *)Dtool_GeomVertexFormat_get_point_216_comment},
  {"getPoint", &Dtool_GeomVertexFormat_get_point_216, METH_O, (const char *)Dtool_GeomVertexFormat_get_point_216_comment},
  {"get_num_vectors", &Dtool_GeomVertexFormat_get_num_vectors_218, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_vectors_218_comment},
  {"getNumVectors", &Dtool_GeomVertexFormat_get_num_vectors_218, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_vectors_218_comment},
  {"get_vector", &Dtool_GeomVertexFormat_get_vector_219, METH_O, (const char *)Dtool_GeomVertexFormat_get_vector_219_comment},
  {"getVector", &Dtool_GeomVertexFormat_get_vector_219, METH_O, (const char *)Dtool_GeomVertexFormat_get_vector_219_comment},
  {"get_num_texcoords", &Dtool_GeomVertexFormat_get_num_texcoords_221, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_texcoords_221_comment},
  {"getNumTexcoords", &Dtool_GeomVertexFormat_get_num_texcoords_221, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_texcoords_221_comment},
  {"get_texcoord", &Dtool_GeomVertexFormat_get_texcoord_222, METH_O, (const char *)Dtool_GeomVertexFormat_get_texcoord_222_comment},
  {"getTexcoord", &Dtool_GeomVertexFormat_get_texcoord_222, METH_O, (const char *)Dtool_GeomVertexFormat_get_texcoord_222_comment},
  {"get_num_morphs", &Dtool_GeomVertexFormat_get_num_morphs_224, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_morphs_224_comment},
  {"getNumMorphs", &Dtool_GeomVertexFormat_get_num_morphs_224, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_get_num_morphs_224_comment},
  {"get_morph_slider", &Dtool_GeomVertexFormat_get_morph_slider_225, METH_O, (const char *)Dtool_GeomVertexFormat_get_morph_slider_225_comment},
  {"getMorphSlider", &Dtool_GeomVertexFormat_get_morph_slider_225, METH_O, (const char *)Dtool_GeomVertexFormat_get_morph_slider_225_comment},
  {"get_morph_base", &Dtool_GeomVertexFormat_get_morph_base_226, METH_O, (const char *)Dtool_GeomVertexFormat_get_morph_base_226_comment},
  {"getMorphBase", &Dtool_GeomVertexFormat_get_morph_base_226, METH_O, (const char *)Dtool_GeomVertexFormat_get_morph_base_226_comment},
  {"get_morph_delta", &Dtool_GeomVertexFormat_get_morph_delta_227, METH_O, (const char *)Dtool_GeomVertexFormat_get_morph_delta_227_comment},
  {"getMorphDelta", &Dtool_GeomVertexFormat_get_morph_delta_227, METH_O, (const char *)Dtool_GeomVertexFormat_get_morph_delta_227_comment},
  {"output", &Dtool_GeomVertexFormat_output_239, METH_O, (const char *)Dtool_GeomVertexFormat_output_239_comment},
  {"write", (PyCFunction) &Dtool_GeomVertexFormat_write_240, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexFormat_write_240_comment},
  {"write_with_data", (PyCFunction) &Dtool_GeomVertexFormat_write_with_data_241, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexFormat_write_with_data_241_comment},
  {"writeWithData", (PyCFunction) &Dtool_GeomVertexFormat_write_with_data_241, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexFormat_write_with_data_241_comment},
  {"get_empty", &Dtool_GeomVertexFormat_get_empty_242, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_empty_242_comment},
  {"getEmpty", &Dtool_GeomVertexFormat_get_empty_242, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_empty_242_comment},
  {"get_v3", &Dtool_GeomVertexFormat_get_v3_243, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3_243_comment},
  {"getV3", &Dtool_GeomVertexFormat_get_v3_243, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3_243_comment},
  {"get_v3n3", &Dtool_GeomVertexFormat_get_v3n3_244, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3_244_comment},
  {"getV3n3", &Dtool_GeomVertexFormat_get_v3n3_244, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3_244_comment},
  {"get_v3t2", &Dtool_GeomVertexFormat_get_v3t2_245, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3t2_245_comment},
  {"getV3t2", &Dtool_GeomVertexFormat_get_v3t2_245, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3t2_245_comment},
  {"get_v3n3t2", &Dtool_GeomVertexFormat_get_v3n3t2_246, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3t2_246_comment},
  {"getV3n3t2", &Dtool_GeomVertexFormat_get_v3n3t2_246, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3t2_246_comment},
  {"get_v3cp", &Dtool_GeomVertexFormat_get_v3cp_247, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3cp_247_comment},
  {"getV3cp", &Dtool_GeomVertexFormat_get_v3cp_247, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3cp_247_comment},
  {"get_v3cpt2", &Dtool_GeomVertexFormat_get_v3cpt2_248, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3cpt2_248_comment},
  {"getV3cpt2", &Dtool_GeomVertexFormat_get_v3cpt2_248, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3cpt2_248_comment},
  {"get_v3n3cp", &Dtool_GeomVertexFormat_get_v3n3cp_249, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3cp_249_comment},
  {"getV3n3cp", &Dtool_GeomVertexFormat_get_v3n3cp_249, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3cp_249_comment},
  {"get_v3n3cpt2", &Dtool_GeomVertexFormat_get_v3n3cpt2_250, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3cpt2_250_comment},
  {"getV3n3cpt2", &Dtool_GeomVertexFormat_get_v3n3cpt2_250, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3cpt2_250_comment},
  {"get_v3c4", &Dtool_GeomVertexFormat_get_v3c4_251, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3c4_251_comment},
  {"getV3c4", &Dtool_GeomVertexFormat_get_v3c4_251, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3c4_251_comment},
  {"get_v3c4t2", &Dtool_GeomVertexFormat_get_v3c4t2_252, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3c4t2_252_comment},
  {"getV3c4t2", &Dtool_GeomVertexFormat_get_v3c4t2_252, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3c4t2_252_comment},
  {"get_v3n3c4", &Dtool_GeomVertexFormat_get_v3n3c4_253, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3c4_253_comment},
  {"getV3n3c4", &Dtool_GeomVertexFormat_get_v3n3c4_253, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3c4_253_comment},
  {"get_v3n3c4t2", &Dtool_GeomVertexFormat_get_v3n3c4t2_254, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3c4t2_254_comment},
  {"getV3n3c4t2", &Dtool_GeomVertexFormat_get_v3n3c4t2_254, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_v3n3c4t2_254_comment},
  {"get_class_type", &Dtool_GeomVertexFormat_get_class_type_255, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_class_type_255_comment},
  {"getClassType", &Dtool_GeomVertexFormat_get_class_type_255, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexFormat_get_class_type_255_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_GeomVertexFormat_upcast_to_TypedWritableReferenceCount_178, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_upcast_to_TypedWritableReferenceCount_178_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_GeomVertexFormat_upcast_to_TypedWritableReferenceCount_178, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_upcast_to_TypedWritableReferenceCount_178_comment},
  {"upcast_to_GeomEnums", &Dtool_GeomVertexFormat_upcast_to_GeomEnums_180, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_upcast_to_GeomEnums_180_comment},
  {"upcastToGeomEnums", &Dtool_GeomVertexFormat_upcast_to_GeomEnums_180, METH_NOARGS, (const char *)Dtool_GeomVertexFormat_upcast_to_GeomEnums_180_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_arrays", (PyCFunction) &MakeSeq_GeomVertexFormat_get_arrays, METH_NOARGS, nullptr},
  { "getArrays", (PyCFunction) &MakeSeq_GeomVertexFormat_get_arrays, METH_NOARGS, nullptr},
  {"get_columns", (PyCFunction) &MakeSeq_GeomVertexFormat_get_columns, METH_NOARGS, nullptr},
  { "getColumns", (PyCFunction) &MakeSeq_GeomVertexFormat_get_columns, METH_NOARGS, nullptr},
  {"get_points", (PyCFunction) &MakeSeq_GeomVertexFormat_get_points, METH_NOARGS, nullptr},
  { "getPoints", (PyCFunction) &MakeSeq_GeomVertexFormat_get_points, METH_NOARGS, nullptr},
  {"get_vectors", (PyCFunction) &MakeSeq_GeomVertexFormat_get_vectors, METH_NOARGS, nullptr},
  { "getVectors", (PyCFunction) &MakeSeq_GeomVertexFormat_get_vectors, METH_NOARGS, nullptr},
  {"get_texcoords", (PyCFunction) &MakeSeq_GeomVertexFormat_get_texcoords, METH_NOARGS, nullptr},
  { "getTexcoords", (PyCFunction) &MakeSeq_GeomVertexFormat_get_texcoords, METH_NOARGS, nullptr},
  {"get_morph_sliders", (PyCFunction) &MakeSeq_GeomVertexFormat_get_morph_sliders, METH_NOARGS, nullptr},
  { "getMorphSliders", (PyCFunction) &MakeSeq_GeomVertexFormat_get_morph_sliders, METH_NOARGS, nullptr},
  {"get_morph_bases", (PyCFunction) &MakeSeq_GeomVertexFormat_get_morph_bases, METH_NOARGS, nullptr},
  { "getMorphBases", (PyCFunction) &MakeSeq_GeomVertexFormat_get_morph_bases, METH_NOARGS, nullptr},
  {"get_morph_deltas", (PyCFunction) &MakeSeq_GeomVertexFormat_get_morph_deltas, METH_NOARGS, nullptr},
  { "getMorphDeltas", (PyCFunction) &MakeSeq_GeomVertexFormat_get_morph_deltas, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     GeomVertexFormat
//////////////////
static PyObject *Dtool_Repr_GeomVertexFormat(PyObject *self) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     GeomVertexFormat
//////////////////
static PyObject *Dtool_Str_GeomVertexFormat(PyObject *self) {
  GeomVertexFormat *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexFormat, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_GeomVertexFormat[] = {
  {(char *)"registered", &Dtool_GeomVertexFormat_registered_Getter, nullptr, nullptr, nullptr},
  {(char *)"animation", &Dtool_GeomVertexFormat_animation_Getter, &Dtool_GeomVertexFormat_animation_Setter, nullptr, nullptr},
  {(char *)"arrays", &Dtool_GeomVertexFormat_arrays_Getter, nullptr, nullptr, nullptr},
  {(char *)"points", &Dtool_GeomVertexFormat_points_Getter, nullptr, nullptr, nullptr},
  {(char *)"vectors", &Dtool_GeomVertexFormat_vectors_Getter, nullptr, nullptr, nullptr},
  {(char *)"columns", &Dtool_GeomVertexFormat_columns_Getter, nullptr, (char *)
    "// We also define this as a mapping interface, for lookups by name.",
    nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GeomVertexFormat = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomVertexFormat = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomVertexFormat = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomVertexFormat = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomVertexFormat = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomVertexFormat = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomVertexFormat",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomVertexFormat,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomVertexFormat,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_GeomVertexFormat,
    &Dtool_NumberMethods_GeomVertexFormat,
    &Dtool_SequenceMethods_GeomVertexFormat,
    &Dtool_MappingMethods_GeomVertexFormat,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_GeomVertexFormat,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomVertexFormat,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class defines the physical layout of the vertex data stored within a\n"
    " * Geom.  The layout consists of a list of named columns, each of which has a\n"
    " * numeric type and a size.\n"
    " *\n"
    " * The columns are typically interleaved within a single array, but they may\n"
    " * also be distributed among multiple different arrays; at the extreme, each\n"
    " * column may be alone within its own array (which amounts to a parallel-array\n"
    " * definition).\n"
    " *\n"
    " * Thus, a GeomVertexFormat is really a list of GeomVertexArrayFormats, each\n"
    " * of which contains a list of columns.  However, a particular column name\n"
    " * should not appear more than once in the format, even between different\n"
    " * arrays.\n"
    " *\n"
    " * There are a handful of standard pre-defined GeomVertexFormat objects, or\n"
    " * you may define your own as needed.  You may record any combination of\n"
    " * standard and/or user-defined columns in your custom GeomVertexFormat\n"
    " * constructions.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomVertexFormat,
    nullptr, // tp_members
    Dtool_Properties_GeomVertexFormat,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomVertexFormat,
    PyType_GenericAlloc,
    Dtool_new_GeomVertexFormat,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomVertexFormat,
  Dtool_UpcastInterface_GeomVertexFormat,
  Dtool_DowncastInterface_GeomVertexFormat,
  (CoerceFunction)Dtool_ConstCoerce_GeomVertexFormat,
  (CoerceFunction)Dtool_Coerce_GeomVertexFormat,
};

static void Dtool_PyModuleClassInit_GeomVertexFormat(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_GeomVertexFormat._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_GeomVertexFormat._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomVertexFormat._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomVertexFormat) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomVertexFormat)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomVertexFormat);
  }
}

/**
 * Python method tables for SimpleLru (SimpleLru)
 */
static PyMethodDef Dtool_Methods_SimpleLru[] = {
  {"get_total_size", &Dtool_SimpleLru_get_total_size_264, METH_NOARGS, (const char *)Dtool_SimpleLru_get_total_size_264_comment},
  {"getTotalSize", &Dtool_SimpleLru_get_total_size_264, METH_NOARGS, (const char *)Dtool_SimpleLru_get_total_size_264_comment},
  {"get_max_size", &Dtool_SimpleLru_get_max_size_265, METH_NOARGS, (const char *)Dtool_SimpleLru_get_max_size_265_comment},
  {"getMaxSize", &Dtool_SimpleLru_get_max_size_265, METH_NOARGS, (const char *)Dtool_SimpleLru_get_max_size_265_comment},
  {"set_max_size", &Dtool_SimpleLru_set_max_size_266, METH_O, (const char *)Dtool_SimpleLru_set_max_size_266_comment},
  {"setMaxSize", &Dtool_SimpleLru_set_max_size_266, METH_O, (const char *)Dtool_SimpleLru_set_max_size_266_comment},
  {"count_active_size", &Dtool_SimpleLru_count_active_size_267, METH_NOARGS, (const char *)Dtool_SimpleLru_count_active_size_267_comment},
  {"countActiveSize", &Dtool_SimpleLru_count_active_size_267, METH_NOARGS, (const char *)Dtool_SimpleLru_count_active_size_267_comment},
  {"consider_evict", &Dtool_SimpleLru_consider_evict_268, METH_NOARGS, (const char *)Dtool_SimpleLru_consider_evict_268_comment},
  {"considerEvict", &Dtool_SimpleLru_consider_evict_268, METH_NOARGS, (const char *)Dtool_SimpleLru_consider_evict_268_comment},
  {"evict_to", &Dtool_SimpleLru_evict_to_269, METH_O, (const char *)Dtool_SimpleLru_evict_to_269_comment},
  {"evictTo", &Dtool_SimpleLru_evict_to_269, METH_O, (const char *)Dtool_SimpleLru_evict_to_269_comment},
  {"begin_epoch", &Dtool_SimpleLru_begin_epoch_270, METH_NOARGS, (const char *)Dtool_SimpleLru_begin_epoch_270_comment},
  {"beginEpoch", &Dtool_SimpleLru_begin_epoch_270, METH_NOARGS, (const char *)Dtool_SimpleLru_begin_epoch_270_comment},
  {"validate", &Dtool_SimpleLru_validate_271, METH_NOARGS, (const char *)Dtool_SimpleLru_validate_271_comment},
  {"output", &Dtool_SimpleLru_output_272, METH_O, (const char *)Dtool_SimpleLru_output_272_comment},
  {"write", (PyCFunction) &Dtool_SimpleLru_write_273, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SimpleLru_write_273_comment},
  {"upcast_to_Namable", &Dtool_SimpleLru_upcast_to_Namable_260, METH_NOARGS, (const char *)Dtool_SimpleLru_upcast_to_Namable_260_comment},
  {"upcastToNamable", &Dtool_SimpleLru_upcast_to_Namable_260, METH_NOARGS, (const char *)Dtool_SimpleLru_upcast_to_Namable_260_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     SimpleLru
//////////////////
static PyObject *Dtool_Repr_SimpleLru(PyObject *self) {
  SimpleLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SimpleLru, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     SimpleLru
//////////////////
static PyObject *Dtool_Str_SimpleLru(PyObject *self) {
  SimpleLru *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SimpleLru, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_SimpleLru = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SimpleLru = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SimpleLru = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SimpleLru = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SimpleLru = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SimpleLru = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SimpleLru",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SimpleLru,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SimpleLru,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_SimpleLru,
    &Dtool_NumberMethods_SimpleLru,
    &Dtool_SequenceMethods_SimpleLru,
    &Dtool_MappingMethods_SimpleLru,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_SimpleLru,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SimpleLru,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An implementation of a very simple LRU algorithm.  Also see AdaptiveLru.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SimpleLru,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SimpleLru,
    PyType_GenericAlloc,
    Dtool_new_SimpleLru,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SimpleLru,
  Dtool_UpcastInterface_SimpleLru,
  Dtool_DowncastInterface_SimpleLru,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SimpleLru(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_SimpleLru._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_SimpleLru._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SimpleLru._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SimpleLru) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SimpleLru)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SimpleLru);
  }
}

/**
 * Python method tables for SimpleLruPage (SimpleLruPage)
 */
static PyMethodDef Dtool_Methods_SimpleLruPage[] = {
  {"assign", &Dtool_SimpleLruPage_operator_278, METH_O, (const char *)Dtool_SimpleLruPage_operator_278_comment},
  {"get_lru", &Dtool_SimpleLruPage_get_lru_280, METH_NOARGS, (const char *)Dtool_SimpleLruPage_get_lru_280_comment},
  {"getLru", &Dtool_SimpleLruPage_get_lru_280, METH_NOARGS, (const char *)Dtool_SimpleLruPage_get_lru_280_comment},
  {"enqueue_lru", &Dtool_SimpleLruPage_enqueue_lru_281, METH_O, (const char *)Dtool_SimpleLruPage_enqueue_lru_281_comment},
  {"enqueueLru", &Dtool_SimpleLruPage_enqueue_lru_281, METH_O, (const char *)Dtool_SimpleLruPage_enqueue_lru_281_comment},
  {"dequeue_lru", &Dtool_SimpleLruPage_dequeue_lru_282, METH_NOARGS, (const char *)Dtool_SimpleLruPage_dequeue_lru_282_comment},
  {"dequeueLru", &Dtool_SimpleLruPage_dequeue_lru_282, METH_NOARGS, (const char *)Dtool_SimpleLruPage_dequeue_lru_282_comment},
  {"mark_used_lru", &Dtool_SimpleLruPage_mark_used_lru_283, METH_VARARGS, (const char *)Dtool_SimpleLruPage_mark_used_lru_283_comment},
  {"markUsedLru", &Dtool_SimpleLruPage_mark_used_lru_283, METH_VARARGS, (const char *)Dtool_SimpleLruPage_mark_used_lru_283_comment},
  {"get_lru_size", &Dtool_SimpleLruPage_get_lru_size_284, METH_NOARGS, (const char *)Dtool_SimpleLruPage_get_lru_size_284_comment},
  {"getLruSize", &Dtool_SimpleLruPage_get_lru_size_284, METH_NOARGS, (const char *)Dtool_SimpleLruPage_get_lru_size_284_comment},
  {"set_lru_size", &Dtool_SimpleLruPage_set_lru_size_285, METH_O, (const char *)Dtool_SimpleLruPage_set_lru_size_285_comment},
  {"setLruSize", &Dtool_SimpleLruPage_set_lru_size_285, METH_O, (const char *)Dtool_SimpleLruPage_set_lru_size_285_comment},
  {"evict_lru", &Dtool_SimpleLruPage_evict_lru_286, METH_NOARGS, (const char *)Dtool_SimpleLruPage_evict_lru_286_comment},
  {"evictLru", &Dtool_SimpleLruPage_evict_lru_286, METH_NOARGS, (const char *)Dtool_SimpleLruPage_evict_lru_286_comment},
  {"output", &Dtool_SimpleLruPage_output_287, METH_O, (const char *)Dtool_SimpleLruPage_output_287_comment},
  {"write", (PyCFunction) &Dtool_SimpleLruPage_write_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SimpleLruPage_write_288_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     SimpleLruPage
//////////////////
static PyObject *Dtool_Repr_SimpleLruPage(PyObject *self) {
  SimpleLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SimpleLruPage, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     SimpleLruPage
//////////////////
static PyObject *Dtool_Str_SimpleLruPage(PyObject *self) {
  SimpleLruPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SimpleLruPage, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_SimpleLruPage = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SimpleLruPage = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SimpleLruPage = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SimpleLruPage = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SimpleLruPage = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SimpleLruPage = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SimpleLruPage",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SimpleLruPage,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SimpleLruPage,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_SimpleLruPage,
    &Dtool_NumberMethods_SimpleLruPage,
    &Dtool_SequenceMethods_SimpleLruPage,
    &Dtool_MappingMethods_SimpleLruPage,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_SimpleLruPage,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SimpleLruPage,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * One atomic piece that may be managed by a SimpleLru chain.  To use this\n"
    " * class, inherit from it and override evict_lru().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SimpleLruPage,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SimpleLruPage,
    PyType_GenericAlloc,
    Dtool_new_SimpleLruPage,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SimpleLruPage,
  Dtool_UpcastInterface_SimpleLruPage,
  Dtool_DowncastInterface_SimpleLruPage,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SimpleLruPage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SimpleLruPage._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SimpleLruPage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SimpleLruPage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SimpleLruPage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SimpleLruPage);
  }
}

/**
 * Python method tables for SimpleAllocator (SimpleAllocator)
 */
static PyMethodDef Dtool_Methods_SimpleAllocator[] = {
  {"alloc", (PyCFunction) &Dtool_SimpleAllocator_alloc_294, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SimpleAllocator_alloc_294_comment},
  {"is_empty", &Dtool_SimpleAllocator_is_empty_295, METH_NOARGS, (const char *)Dtool_SimpleAllocator_is_empty_295_comment},
  {"isEmpty", &Dtool_SimpleAllocator_is_empty_295, METH_NOARGS, (const char *)Dtool_SimpleAllocator_is_empty_295_comment},
  {"get_total_size", &Dtool_SimpleAllocator_get_total_size_296, METH_NOARGS, (const char *)Dtool_SimpleAllocator_get_total_size_296_comment},
  {"getTotalSize", &Dtool_SimpleAllocator_get_total_size_296, METH_NOARGS, (const char *)Dtool_SimpleAllocator_get_total_size_296_comment},
  {"get_max_size", &Dtool_SimpleAllocator_get_max_size_297, METH_NOARGS, (const char *)Dtool_SimpleAllocator_get_max_size_297_comment},
  {"getMaxSize", &Dtool_SimpleAllocator_get_max_size_297, METH_NOARGS, (const char *)Dtool_SimpleAllocator_get_max_size_297_comment},
  {"set_max_size", &Dtool_SimpleAllocator_set_max_size_298, METH_O, (const char *)Dtool_SimpleAllocator_set_max_size_298_comment},
  {"setMaxSize", &Dtool_SimpleAllocator_set_max_size_298, METH_O, (const char *)Dtool_SimpleAllocator_set_max_size_298_comment},
  {"get_contiguous", &Dtool_SimpleAllocator_get_contiguous_299, METH_NOARGS, (const char *)Dtool_SimpleAllocator_get_contiguous_299_comment},
  {"getContiguous", &Dtool_SimpleAllocator_get_contiguous_299, METH_NOARGS, (const char *)Dtool_SimpleAllocator_get_contiguous_299_comment},
  {"get_first_block", &Dtool_SimpleAllocator_get_first_block_300, METH_NOARGS, (const char *)Dtool_SimpleAllocator_get_first_block_300_comment},
  {"getFirstBlock", &Dtool_SimpleAllocator_get_first_block_300, METH_NOARGS, (const char *)Dtool_SimpleAllocator_get_first_block_300_comment},
  {"output", &Dtool_SimpleAllocator_output_301, METH_O, (const char *)Dtool_SimpleAllocator_output_301_comment},
  {"write", &Dtool_SimpleAllocator_write_302, METH_O, (const char *)Dtool_SimpleAllocator_write_302_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     SimpleAllocator
//////////////////
static PyObject *Dtool_Repr_SimpleAllocator(PyObject *self) {
  SimpleAllocator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SimpleAllocator, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     SimpleAllocator
//////////////////
static PyObject *Dtool_Str_SimpleAllocator(PyObject *self) {
  SimpleAllocator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SimpleAllocator, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_SimpleAllocator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SimpleAllocator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SimpleAllocator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SimpleAllocator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SimpleAllocator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SimpleAllocator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SimpleAllocator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SimpleAllocator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SimpleAllocator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_SimpleAllocator,
    &Dtool_NumberMethods_SimpleAllocator,
    &Dtool_SequenceMethods_SimpleAllocator,
    &Dtool_MappingMethods_SimpleAllocator,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_SimpleAllocator,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SimpleAllocator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An implementation of a very simple block allocator.  This class can\n"
    " * allocate ranges of nonnegative integers within a specified upper limit; it\n"
    " * uses a simple first-fit algorithm to find the next available space.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SimpleAllocator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SimpleAllocator,
    PyType_GenericAlloc,
    Dtool_new_SimpleAllocator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SimpleAllocator,
  Dtool_UpcastInterface_SimpleAllocator,
  Dtool_DowncastInterface_SimpleAllocator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SimpleAllocator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SimpleAllocator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SimpleAllocator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SimpleAllocator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SimpleAllocator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SimpleAllocator);
  }
}

/**
 * Python method tables for SimpleAllocatorBlock (SimpleAllocatorBlock)
 */
static PyMethodDef Dtool_Methods_SimpleAllocatorBlock[] = {
  {"free", &Dtool_SimpleAllocatorBlock_free_305, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_free_305_comment},
  {"get_allocator", &Dtool_SimpleAllocatorBlock_get_allocator_306, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_get_allocator_306_comment},
  {"getAllocator", &Dtool_SimpleAllocatorBlock_get_allocator_306, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_get_allocator_306_comment},
  {"get_start", &Dtool_SimpleAllocatorBlock_get_start_307, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_get_start_307_comment},
  {"getStart", &Dtool_SimpleAllocatorBlock_get_start_307, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_get_start_307_comment},
  {"get_size", &Dtool_SimpleAllocatorBlock_get_size_308, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_get_size_308_comment},
  {"getSize", &Dtool_SimpleAllocatorBlock_get_size_308, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_get_size_308_comment},
  {"is_free", &Dtool_SimpleAllocatorBlock_is_free_309, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_is_free_309_comment},
  {"isFree", &Dtool_SimpleAllocatorBlock_is_free_309, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_is_free_309_comment},
  {"get_max_size", &Dtool_SimpleAllocatorBlock_get_max_size_310, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_get_max_size_310_comment},
  {"getMaxSize", &Dtool_SimpleAllocatorBlock_get_max_size_310, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_get_max_size_310_comment},
  {"realloc", &Dtool_SimpleAllocatorBlock_realloc_311, METH_O, (const char *)Dtool_SimpleAllocatorBlock_realloc_311_comment},
  {"get_next_block", &Dtool_SimpleAllocatorBlock_get_next_block_312, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_get_next_block_312_comment},
  {"getNextBlock", &Dtool_SimpleAllocatorBlock_get_next_block_312, METH_NOARGS, (const char *)Dtool_SimpleAllocatorBlock_get_next_block_312_comment},
  {"output", &Dtool_SimpleAllocatorBlock_output_313, METH_O, (const char *)Dtool_SimpleAllocatorBlock_output_313_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     SimpleAllocatorBlock
//////////////////
static PyObject *Dtool_Repr_SimpleAllocatorBlock(PyObject *self) {
  SimpleAllocatorBlock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SimpleAllocatorBlock, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_SimpleAllocatorBlock = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SimpleAllocatorBlock = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SimpleAllocatorBlock = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SimpleAllocatorBlock = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SimpleAllocatorBlock = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SimpleAllocatorBlock = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SimpleAllocatorBlock",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SimpleAllocatorBlock,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SimpleAllocatorBlock,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_SimpleAllocatorBlock,
    &Dtool_NumberMethods_SimpleAllocatorBlock,
    &Dtool_SequenceMethods_SimpleAllocatorBlock,
    &Dtool_MappingMethods_SimpleAllocatorBlock,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_SimpleAllocatorBlock,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SimpleAllocatorBlock,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single block as returned from SimpleAllocator::alloc().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SimpleAllocatorBlock,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SimpleAllocatorBlock,
    PyType_GenericAlloc,
    Dtool_new_SimpleAllocatorBlock,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SimpleAllocatorBlock,
  Dtool_UpcastInterface_SimpleAllocatorBlock,
  Dtool_DowncastInterface_SimpleAllocatorBlock,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SimpleAllocatorBlock(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SimpleAllocatorBlock._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SimpleAllocatorBlock._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SimpleAllocatorBlock) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SimpleAllocatorBlock)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SimpleAllocatorBlock);
  }
}

/**
 * Python method tables for VertexDataSaveFile (VertexDataSaveFile)
 */
static PyMethodDef Dtool_Methods_VertexDataSaveFile[] = {
  {"is_valid", &Dtool_VertexDataSaveFile_is_valid_315, METH_NOARGS, (const char *)Dtool_VertexDataSaveFile_is_valid_315_comment},
  {"isValid", &Dtool_VertexDataSaveFile_is_valid_315, METH_NOARGS, (const char *)Dtool_VertexDataSaveFile_is_valid_315_comment},
  {"get_total_file_size", &Dtool_VertexDataSaveFile_get_total_file_size_316, METH_NOARGS, (const char *)Dtool_VertexDataSaveFile_get_total_file_size_316_comment},
  {"getTotalFileSize", &Dtool_VertexDataSaveFile_get_total_file_size_316, METH_NOARGS, (const char *)Dtool_VertexDataSaveFile_get_total_file_size_316_comment},
  {"get_used_file_size", &Dtool_VertexDataSaveFile_get_used_file_size_317, METH_NOARGS, (const char *)Dtool_VertexDataSaveFile_get_used_file_size_317_comment},
  {"getUsedFileSize", &Dtool_VertexDataSaveFile_get_used_file_size_317, METH_NOARGS, (const char *)Dtool_VertexDataSaveFile_get_used_file_size_317_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VertexDataSaveFile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VertexDataSaveFile = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VertexDataSaveFile = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VertexDataSaveFile = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VertexDataSaveFile = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VertexDataSaveFile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VertexDataSaveFile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VertexDataSaveFile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VertexDataSaveFile,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VertexDataSaveFile,
    &Dtool_SequenceMethods_VertexDataSaveFile,
    &Dtool_MappingMethods_VertexDataSaveFile,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VertexDataSaveFile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A temporary file to hold the vertex data that has been evicted from memory\n"
    " * and written to disk.  All vertex data arrays are written into one large\n"
    " * flat file.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VertexDataSaveFile,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VertexDataSaveFile,
    PyType_GenericAlloc,
    Dtool_new_VertexDataSaveFile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VertexDataSaveFile,
  Dtool_UpcastInterface_VertexDataSaveFile,
  Dtool_DowncastInterface_VertexDataSaveFile,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VertexDataSaveFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_SimpleAllocator(nullptr);
    Dtool_VertexDataSaveFile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_SimpleAllocator);
    Dtool_VertexDataSaveFile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VertexDataSaveFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VertexDataSaveFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VertexDataSaveFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VertexDataSaveFile);
  }
}

/**
 * Python method tables for VertexDataPage (VertexDataPage)
 */
static PyMethodDef Dtool_Methods_VertexDataPage[] = {
  {"get_ram_class", &Dtool_VertexDataPage_get_ram_class_324, METH_NOARGS, (const char *)Dtool_VertexDataPage_get_ram_class_324_comment},
  {"getRamClass", &Dtool_VertexDataPage_get_ram_class_324, METH_NOARGS, (const char *)Dtool_VertexDataPage_get_ram_class_324_comment},
  {"get_pending_ram_class", &Dtool_VertexDataPage_get_pending_ram_class_325, METH_NOARGS, (const char *)Dtool_VertexDataPage_get_pending_ram_class_325_comment},
  {"getPendingRamClass", &Dtool_VertexDataPage_get_pending_ram_class_325, METH_NOARGS, (const char *)Dtool_VertexDataPage_get_pending_ram_class_325_comment},
  {"request_resident", &Dtool_VertexDataPage_request_resident_326, METH_NOARGS, (const char *)Dtool_VertexDataPage_request_resident_326_comment},
  {"requestResident", &Dtool_VertexDataPage_request_resident_326, METH_NOARGS, (const char *)Dtool_VertexDataPage_request_resident_326_comment},
  {"alloc", &Dtool_VertexDataPage_alloc_327, METH_O, (const char *)Dtool_VertexDataPage_alloc_327_comment},
  {"get_first_block", &Dtool_VertexDataPage_get_first_block_328, METH_NOARGS, (const char *)Dtool_VertexDataPage_get_first_block_328_comment},
  {"getFirstBlock", &Dtool_VertexDataPage_get_first_block_328, METH_NOARGS, (const char *)Dtool_VertexDataPage_get_first_block_328_comment},
  {"get_book", &Dtool_VertexDataPage_get_book_329, METH_NOARGS, (const char *)Dtool_VertexDataPage_get_book_329_comment},
  {"getBook", &Dtool_VertexDataPage_get_book_329, METH_NOARGS, (const char *)Dtool_VertexDataPage_get_book_329_comment},
  {"get_global_lru", &Dtool_VertexDataPage_get_global_lru_330, METH_O | METH_STATIC, (const char *)Dtool_VertexDataPage_get_global_lru_330_comment},
  {"getGlobalLru", &Dtool_VertexDataPage_get_global_lru_330, METH_O | METH_STATIC, (const char *)Dtool_VertexDataPage_get_global_lru_330_comment},
  {"get_pending_lru", &Dtool_VertexDataPage_get_pending_lru_331, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_pending_lru_331_comment},
  {"getPendingLru", &Dtool_VertexDataPage_get_pending_lru_331, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_pending_lru_331_comment},
  {"get_save_file", &Dtool_VertexDataPage_get_save_file_332, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_save_file_332_comment},
  {"getSaveFile", &Dtool_VertexDataPage_get_save_file_332, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_save_file_332_comment},
  {"save_to_disk", &Dtool_VertexDataPage_save_to_disk_335, METH_NOARGS, (const char *)Dtool_VertexDataPage_save_to_disk_335_comment},
  {"saveToDisk", &Dtool_VertexDataPage_save_to_disk_335, METH_NOARGS, (const char *)Dtool_VertexDataPage_save_to_disk_335_comment},
  {"get_num_threads", &Dtool_VertexDataPage_get_num_threads_336, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_num_threads_336_comment},
  {"getNumThreads", &Dtool_VertexDataPage_get_num_threads_336, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_num_threads_336_comment},
  {"get_num_pending_reads", &Dtool_VertexDataPage_get_num_pending_reads_337, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_num_pending_reads_337_comment},
  {"getNumPendingReads", &Dtool_VertexDataPage_get_num_pending_reads_337, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_num_pending_reads_337_comment},
  {"get_num_pending_writes", &Dtool_VertexDataPage_get_num_pending_writes_338, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_num_pending_writes_338_comment},
  {"getNumPendingWrites", &Dtool_VertexDataPage_get_num_pending_writes_338, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_num_pending_writes_338_comment},
  {"stop_threads", &Dtool_VertexDataPage_stop_threads_339, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_stop_threads_339_comment},
  {"stopThreads", &Dtool_VertexDataPage_stop_threads_339, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_stop_threads_339_comment},
  {"flush_threads", &Dtool_VertexDataPage_flush_threads_340, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_flush_threads_340_comment},
  {"flushThreads", &Dtool_VertexDataPage_flush_threads_340, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_flush_threads_340_comment},
  {"output", &Dtool_VertexDataPage_output_341, METH_O, (const char *)Dtool_VertexDataPage_output_341_comment},
  {"write", (PyCFunction) &Dtool_VertexDataPage_write_342, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VertexDataPage_write_342_comment},
  {"get_class_type", &Dtool_VertexDataPage_get_class_type_343, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_class_type_343_comment},
  {"getClassType", &Dtool_VertexDataPage_get_class_type_343, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexDataPage_get_class_type_343_comment},
  {"upcast_to_SimpleAllocator", &Dtool_VertexDataPage_upcast_to_SimpleAllocator_319, METH_NOARGS, (const char *)Dtool_VertexDataPage_upcast_to_SimpleAllocator_319_comment},
  {"upcastToSimpleAllocator", &Dtool_VertexDataPage_upcast_to_SimpleAllocator_319, METH_NOARGS, (const char *)Dtool_VertexDataPage_upcast_to_SimpleAllocator_319_comment},
  {"upcast_to_SimpleLruPage", &Dtool_VertexDataPage_upcast_to_SimpleLruPage_321, METH_NOARGS, (const char *)Dtool_VertexDataPage_upcast_to_SimpleLruPage_321_comment},
  {"upcastToSimpleLruPage", &Dtool_VertexDataPage_upcast_to_SimpleLruPage_321, METH_NOARGS, (const char *)Dtool_VertexDataPage_upcast_to_SimpleLruPage_321_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     VertexDataPage
//////////////////
static PyObject *Dtool_Repr_VertexDataPage(PyObject *self) {
  VertexDataPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VertexDataPage, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     VertexDataPage
//////////////////
static PyObject *Dtool_Str_VertexDataPage(PyObject *self) {
  VertexDataPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VertexDataPage, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_VertexDataPage = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VertexDataPage = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VertexDataPage = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VertexDataPage = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VertexDataPage = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VertexDataPage = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VertexDataPage",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VertexDataPage,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VertexDataPage,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_VertexDataPage,
    &Dtool_NumberMethods_VertexDataPage,
    &Dtool_SequenceMethods_VertexDataPage,
    &Dtool_MappingMethods_VertexDataPage,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_VertexDataPage,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VertexDataPage,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A block of bytes that holds one or more VertexDataBlocks.  The entire page\n"
    " * may be paged out, in the form of in-memory compression or to an on-disk\n"
    " * cache file, if necessary.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VertexDataPage,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VertexDataPage,
    PyType_GenericAlloc,
    Dtool_new_VertexDataPage,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VertexDataPage,
  Dtool_UpcastInterface_VertexDataPage,
  Dtool_DowncastInterface_VertexDataPage,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VertexDataPage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_SimpleAllocator(nullptr);
    Dtool_PyModuleClassInit_SimpleLruPage(nullptr);
    Dtool_VertexDataPage._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_SimpleAllocator, (PyTypeObject *)&Dtool_SimpleLruPage);
    Dtool_VertexDataPage._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_VertexDataPage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum VertexDataPage::RamClass;
    PyDict_SetItemString(dict, "RC_resident", Dtool_WrapValue(VertexDataPage::RC_resident));
    PyDict_SetItemString(dict, "RCResident", Dtool_WrapValue(VertexDataPage::RC_resident));
    PyDict_SetItemString(dict, "RC_compressed", Dtool_WrapValue(VertexDataPage::RC_compressed));
    PyDict_SetItemString(dict, "RCCompressed", Dtool_WrapValue(VertexDataPage::RC_compressed));
    PyDict_SetItemString(dict, "RC_disk", Dtool_WrapValue(VertexDataPage::RC_disk));
    PyDict_SetItemString(dict, "RCDisk", Dtool_WrapValue(VertexDataPage::RC_disk));
    PyDict_SetItemString(dict, "RC_end_of_list", Dtool_WrapValue(VertexDataPage::RC_end_of_list));
    PyDict_SetItemString(dict, "RCEndOfList", Dtool_WrapValue(VertexDataPage::RC_end_of_list));
    static const PyGetSetDef def_save_file = {(char *)"save_file", &Dtool_VertexDataPage_save_file_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "save_file", Dtool_NewStaticProperty(&Dtool_VertexDataPage._PyType, &def_save_file));
    if (PyType_Ready((PyTypeObject *)&Dtool_VertexDataPage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VertexDataPage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VertexDataPage);
  }
}

/**
 * Python method tables for VertexDataBook (VertexDataBook)
 */
static PyMethodDef Dtool_Methods_VertexDataBook[] = {
  {"alloc", &Dtool_VertexDataBook_alloc_347, METH_O, (const char *)Dtool_VertexDataBook_alloc_347_comment},
  {"get_num_pages", &Dtool_VertexDataBook_get_num_pages_348, METH_NOARGS, (const char *)Dtool_VertexDataBook_get_num_pages_348_comment},
  {"getNumPages", &Dtool_VertexDataBook_get_num_pages_348, METH_NOARGS, (const char *)Dtool_VertexDataBook_get_num_pages_348_comment},
  {"count_total_page_size", &Dtool_VertexDataBook_count_total_page_size_349, METH_VARARGS, (const char *)Dtool_VertexDataBook_count_total_page_size_349_comment},
  {"countTotalPageSize", &Dtool_VertexDataBook_count_total_page_size_349, METH_VARARGS, (const char *)Dtool_VertexDataBook_count_total_page_size_349_comment},
  {"count_allocated_size", &Dtool_VertexDataBook_count_allocated_size_350, METH_VARARGS, (const char *)Dtool_VertexDataBook_count_allocated_size_350_comment},
  {"countAllocatedSize", &Dtool_VertexDataBook_count_allocated_size_350, METH_VARARGS, (const char *)Dtool_VertexDataBook_count_allocated_size_350_comment},
  {"save_to_disk", &Dtool_VertexDataBook_save_to_disk_351, METH_NOARGS, (const char *)Dtool_VertexDataBook_save_to_disk_351_comment},
  {"saveToDisk", &Dtool_VertexDataBook_save_to_disk_351, METH_NOARGS, (const char *)Dtool_VertexDataBook_save_to_disk_351_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VertexDataBook = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_VertexDataBook = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VertexDataBook",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VertexDataBook,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VertexDataBook,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A collection of VertexDataPages, which can be used to allocate new\n"
    " * VertexDataBlock objects.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VertexDataBook,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VertexDataBook,
    PyType_GenericAlloc,
    Dtool_new_VertexDataBook,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VertexDataBook,
  Dtool_UpcastInterface_VertexDataBook,
  Dtool_DowncastInterface_VertexDataBook,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VertexDataBook(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_VertexDataBook._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VertexDataBook._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VertexDataBook) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VertexDataBook)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VertexDataBook);
  }
}

/**
 * Python method tables for VertexDataBlock (VertexDataBlock)
 */
static PyMethodDef Dtool_Methods_VertexDataBlock[] = {
  {"get_page", &Dtool_VertexDataBlock_get_page_358, METH_NOARGS, (const char *)Dtool_VertexDataBlock_get_page_358_comment},
  {"getPage", &Dtool_VertexDataBlock_get_page_358, METH_NOARGS, (const char *)Dtool_VertexDataBlock_get_page_358_comment},
  {"get_next_block", &Dtool_VertexDataBlock_get_next_block_359, METH_NOARGS, (const char *)Dtool_VertexDataBlock_get_next_block_359_comment},
  {"getNextBlock", &Dtool_VertexDataBlock_get_next_block_359, METH_NOARGS, (const char *)Dtool_VertexDataBlock_get_next_block_359_comment},
  {"upcast_to_SimpleAllocatorBlock", &Dtool_VertexDataBlock_upcast_to_SimpleAllocatorBlock_353, METH_NOARGS, (const char *)Dtool_VertexDataBlock_upcast_to_SimpleAllocatorBlock_353_comment},
  {"upcastToSimpleAllocatorBlock", &Dtool_VertexDataBlock_upcast_to_SimpleAllocatorBlock_353, METH_NOARGS, (const char *)Dtool_VertexDataBlock_upcast_to_SimpleAllocatorBlock_353_comment},
  {"upcast_to_ReferenceCount", &Dtool_VertexDataBlock_upcast_to_ReferenceCount_356, METH_NOARGS, (const char *)Dtool_VertexDataBlock_upcast_to_ReferenceCount_356_comment},
  {"upcastToReferenceCount", &Dtool_VertexDataBlock_upcast_to_ReferenceCount_356, METH_NOARGS, (const char *)Dtool_VertexDataBlock_upcast_to_ReferenceCount_356_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VertexDataBlock = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VertexDataBlock = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VertexDataBlock = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VertexDataBlock = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VertexDataBlock = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VertexDataBlock = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VertexDataBlock",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VertexDataBlock,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VertexDataBlock,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VertexDataBlock,
    &Dtool_SequenceMethods_VertexDataBlock,
    &Dtool_MappingMethods_VertexDataBlock,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VertexDataBlock,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A block of bytes that stores the actual raw vertex data referenced by a\n"
    " * GeomVertexArrayData object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VertexDataBlock,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VertexDataBlock,
    PyType_GenericAlloc,
    Dtool_new_VertexDataBlock,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VertexDataBlock,
  Dtool_UpcastInterface_VertexDataBlock,
  Dtool_DowncastInterface_VertexDataBlock,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VertexDataBlock(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_SimpleAllocatorBlock(nullptr);
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_VertexDataBlock._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_SimpleAllocatorBlock, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_VertexDataBlock._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VertexDataBlock._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VertexDataBlock) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VertexDataBlock)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VertexDataBlock);
  }
}

/**
 * Python method tables for GeomVertexArrayData (GeomVertexArrayData)
 */
static PyMethodDef Dtool_Methods_GeomVertexArrayData[] = {
  {"assign", &Dtool_GeomVertexArrayData_operator_370, METH_O, (const char *)Dtool_GeomVertexArrayData_operator_370_comment},
  {"compare_to", &Dtool_GeomVertexArrayData_compare_to_375, METH_O, (const char *)Dtool_GeomVertexArrayData_compare_to_375_comment},
  {"compareTo", &Dtool_GeomVertexArrayData_compare_to_375, METH_O, (const char *)Dtool_GeomVertexArrayData_compare_to_375_comment},
  {"get_array_format", &Dtool_GeomVertexArrayData_get_array_format_376, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_get_array_format_376_comment},
  {"getArrayFormat", &Dtool_GeomVertexArrayData_get_array_format_376, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_get_array_format_376_comment},
  {"get_usage_hint", &Dtool_GeomVertexArrayData_get_usage_hint_378, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_get_usage_hint_378_comment},
  {"getUsageHint", &Dtool_GeomVertexArrayData_get_usage_hint_378, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_get_usage_hint_378_comment},
  {"set_usage_hint", &Dtool_GeomVertexArrayData_set_usage_hint_379, METH_O, (const char *)Dtool_GeomVertexArrayData_set_usage_hint_379_comment},
  {"setUsageHint", &Dtool_GeomVertexArrayData_set_usage_hint_379, METH_O, (const char *)Dtool_GeomVertexArrayData_set_usage_hint_379_comment},
  {"has_column", &Dtool_GeomVertexArrayData_has_column_381, METH_O, (const char *)Dtool_GeomVertexArrayData_has_column_381_comment},
  {"hasColumn", &Dtool_GeomVertexArrayData_has_column_381, METH_O, (const char *)Dtool_GeomVertexArrayData_has_column_381_comment},
  {"get_num_rows", &Dtool_GeomVertexArrayData_get_num_rows_382, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_get_num_rows_382_comment},
  {"getNumRows", &Dtool_GeomVertexArrayData_get_num_rows_382, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_get_num_rows_382_comment},
  {"set_num_rows", &Dtool_GeomVertexArrayData_set_num_rows_383, METH_O, (const char *)Dtool_GeomVertexArrayData_set_num_rows_383_comment},
  {"setNumRows", &Dtool_GeomVertexArrayData_set_num_rows_383, METH_O, (const char *)Dtool_GeomVertexArrayData_set_num_rows_383_comment},
  {"unclean_set_num_rows", &Dtool_GeomVertexArrayData_unclean_set_num_rows_384, METH_O, (const char *)Dtool_GeomVertexArrayData_unclean_set_num_rows_384_comment},
  {"uncleanSetNumRows", &Dtool_GeomVertexArrayData_unclean_set_num_rows_384, METH_O, (const char *)Dtool_GeomVertexArrayData_unclean_set_num_rows_384_comment},
  {"reserve_num_rows", &Dtool_GeomVertexArrayData_reserve_num_rows_385, METH_O, (const char *)Dtool_GeomVertexArrayData_reserve_num_rows_385_comment},
  {"reserveNumRows", &Dtool_GeomVertexArrayData_reserve_num_rows_385, METH_O, (const char *)Dtool_GeomVertexArrayData_reserve_num_rows_385_comment},
  {"clear_rows", &Dtool_GeomVertexArrayData_clear_rows_386, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_clear_rows_386_comment},
  {"clearRows", &Dtool_GeomVertexArrayData_clear_rows_386, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_clear_rows_386_comment},
  {"get_data_size_bytes", &Dtool_GeomVertexArrayData_get_data_size_bytes_387, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_get_data_size_bytes_387_comment},
  {"getDataSizeBytes", &Dtool_GeomVertexArrayData_get_data_size_bytes_387, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_get_data_size_bytes_387_comment},
  {"get_modified", &Dtool_GeomVertexArrayData_get_modified_388, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_get_modified_388_comment},
  {"getModified", &Dtool_GeomVertexArrayData_get_modified_388, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_get_modified_388_comment},
  {"output", &Dtool_GeomVertexArrayData_output_394, METH_O, (const char *)Dtool_GeomVertexArrayData_output_394_comment},
  {"write", (PyCFunction) &Dtool_GeomVertexArrayData_write_395, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayData_write_395_comment},
  {"request_resident", (PyCFunction) &Dtool_GeomVertexArrayData_request_resident_396, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayData_request_resident_396_comment},
  {"requestResident", (PyCFunction) &Dtool_GeomVertexArrayData_request_resident_396, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayData_request_resident_396_comment},
  {"get_handle", (PyCFunction) &Dtool_GeomVertexArrayData_get_handle_397, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayData_get_handle_397_comment},
  {"getHandle", (PyCFunction) &Dtool_GeomVertexArrayData_get_handle_397, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayData_get_handle_397_comment},
  {"modify_handle", (PyCFunction) &Dtool_GeomVertexArrayData_modify_handle_398, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayData_modify_handle_398_comment},
  {"modifyHandle", (PyCFunction) &Dtool_GeomVertexArrayData_modify_handle_398, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayData_modify_handle_398_comment},
  {"prepare", &Dtool_GeomVertexArrayData_prepare_399, METH_O, (const char *)Dtool_GeomVertexArrayData_prepare_399_comment},
  {"is_prepared", &Dtool_GeomVertexArrayData_is_prepared_400, METH_O, (const char *)Dtool_GeomVertexArrayData_is_prepared_400_comment},
  {"isPrepared", &Dtool_GeomVertexArrayData_is_prepared_400, METH_O, (const char *)Dtool_GeomVertexArrayData_is_prepared_400_comment},
  {"prepare_now", (PyCFunction) &Dtool_GeomVertexArrayData_prepare_now_401, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayData_prepare_now_401_comment},
  {"prepareNow", (PyCFunction) &Dtool_GeomVertexArrayData_prepare_now_401, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayData_prepare_now_401_comment},
  {"release", &Dtool_GeomVertexArrayData_release_402, METH_O, (const char *)Dtool_GeomVertexArrayData_release_402_comment},
  {"release_all", &Dtool_GeomVertexArrayData_release_all_403, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_release_all_403_comment},
  {"releaseAll", &Dtool_GeomVertexArrayData_release_all_403, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_release_all_403_comment},
  {"get_independent_lru", &Dtool_GeomVertexArrayData_get_independent_lru_404, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayData_get_independent_lru_404_comment},
  {"getIndependentLru", &Dtool_GeomVertexArrayData_get_independent_lru_404, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayData_get_independent_lru_404_comment},
  {"get_small_lru", &Dtool_GeomVertexArrayData_get_small_lru_405, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayData_get_small_lru_405_comment},
  {"getSmallLru", &Dtool_GeomVertexArrayData_get_small_lru_405, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayData_get_small_lru_405_comment},
  {"lru_epoch", &Dtool_GeomVertexArrayData_lru_epoch_406, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayData_lru_epoch_406_comment},
  {"lruEpoch", &Dtool_GeomVertexArrayData_lru_epoch_406, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayData_lru_epoch_406_comment},
  {"get_book", &Dtool_GeomVertexArrayData_get_book_407, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayData_get_book_407_comment},
  {"getBook", &Dtool_GeomVertexArrayData_get_book_407, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayData_get_book_407_comment},
  {"get_class_type", &Dtool_GeomVertexArrayData_get_class_type_410, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayData_get_class_type_410_comment},
  {"getClassType", &Dtool_GeomVertexArrayData_get_class_type_410, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayData_get_class_type_410_comment},
  {"upcast_to_CopyOnWriteObject", &Dtool_GeomVertexArrayData_upcast_to_CopyOnWriteObject_363, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_upcast_to_CopyOnWriteObject_363_comment},
  {"upcastToCopyOnWriteObject", &Dtool_GeomVertexArrayData_upcast_to_CopyOnWriteObject_363, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_upcast_to_CopyOnWriteObject_363_comment},
  {"upcast_to_SimpleLruPage", &Dtool_GeomVertexArrayData_upcast_to_SimpleLruPage_365, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_upcast_to_SimpleLruPage_365_comment},
  {"upcastToSimpleLruPage", &Dtool_GeomVertexArrayData_upcast_to_SimpleLruPage_365, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_upcast_to_SimpleLruPage_365_comment},
  {"upcast_to_GeomEnums", &Dtool_GeomVertexArrayData_upcast_to_GeomEnums_367, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_upcast_to_GeomEnums_367_comment},
  {"upcastToGeomEnums", &Dtool_GeomVertexArrayData_upcast_to_GeomEnums_367, METH_NOARGS, (const char *)Dtool_GeomVertexArrayData_upcast_to_GeomEnums_367_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// GeomVertexArrayData slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_GeomVertexArrayData_getbuffer_408_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayData, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    return invoke_extension((const GeomVertexArrayData *)local_this).__getbuffer__(self, buffer, flags);
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// GeomVertexArrayData slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_GeomVertexArrayData_releasebuffer_409_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayData, (void **)&local_this)) {
    return;
  }

  invoke_extension((const GeomVertexArrayData *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// GeomVertexArrayData slot tp_compare -> compare_to
//////////////////
static int Dtool_GeomVertexArrayData_compare_to_375_tp_compare(PyObject *self, PyObject *arg) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayData, (void **)&local_this)) {
    return -1;
  }

  // 1-int GeomVertexArrayData::compare_to(GeomVertexArrayData const &other) const
  GeomVertexArrayData const *arg_this = (GeomVertexArrayData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexArrayData, 1, "GeomVertexArrayData.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const GeomVertexArrayData*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(GeomVertexArrayData self, const GeomVertexArrayData other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     GeomVertexArrayData
//////////////////
static PyObject *Dtool_Repr_GeomVertexArrayData(PyObject *self) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayData, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     GeomVertexArrayData
//////////////////
static PyObject *Dtool_Str_GeomVertexArrayData(PyObject *self) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayData, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     GeomVertexArrayData
//////////////////
static PyObject *Dtool_RichCompare_GeomVertexArrayData(PyObject *self, PyObject *arg, int op) {
  GeomVertexArrayData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexArrayData, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_GeomVertexArrayData_compare_to_375_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_GeomVertexArrayData[] = {
  {(char *)"array_format", &Dtool_GeomVertexArrayData_array_format_Getter, nullptr, nullptr, nullptr},
  {(char *)"usage_hint", &Dtool_GeomVertexArrayData_usage_hint_Getter, &Dtool_GeomVertexArrayData_usage_hint_Setter, nullptr, nullptr},
  {(char *)"data_size_bytes", &Dtool_GeomVertexArrayData_data_size_bytes_Getter, nullptr, nullptr, nullptr},
  {(char *)"modified", &Dtool_GeomVertexArrayData_modified_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GeomVertexArrayData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomVertexArrayData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomVertexArrayData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomVertexArrayData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_GeomVertexArrayData_getbuffer_408_bf_getbuffer,
  &Dtool_GeomVertexArrayData_releasebuffer_409_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomVertexArrayData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomVertexArrayData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomVertexArrayData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomVertexArrayData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomVertexArrayData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_GeomVertexArrayData_compare_to_375_tp_compare,
#endif
    &Dtool_Repr_GeomVertexArrayData,
    &Dtool_NumberMethods_GeomVertexArrayData,
    &Dtool_SequenceMethods_GeomVertexArrayData,
    &Dtool_MappingMethods_GeomVertexArrayData,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_GeomVertexArrayData,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomVertexArrayData,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the data for one array of a GeomVertexData structure.  Many\n"
    " * GeomVertexData structures will only define one array, with all data\n"
    " * elements interleaved (DirectX 8.0 and before insisted on this format); some\n"
    " * will define multiple arrays.\n"
    " *\n"
    " * DirectX calls this concept of one array a \"stream\". It also closely\n"
    " * correlates with the concept of a vertex buffer.\n"
    " *\n"
    " * This object is just a block of data.  In general, you should not be\n"
    " * directly messing with this object from application code.  See\n"
    " * GeomVertexData for the organizing structure, and see\n"
    " * GeomVertexReader/Writer/Rewriter for high-level tools to manipulate the\n"
    " * actual vertex data.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_GeomVertexArrayData,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomVertexArrayData,
    nullptr, // tp_members
    Dtool_Properties_GeomVertexArrayData,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomVertexArrayData,
    PyType_GenericAlloc,
    Dtool_new_GeomVertexArrayData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomVertexArrayData,
  Dtool_UpcastInterface_GeomVertexArrayData,
  Dtool_DowncastInterface_GeomVertexArrayData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomVertexArrayData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CopyOnWriteObject != nullptr);
    assert(Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_SimpleLruPage(nullptr);
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_GeomVertexArrayData._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)Dtool_Ptr_CopyOnWriteObject, (PyTypeObject *)&Dtool_SimpleLruPage, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_GeomVertexArrayData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomVertexArrayData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomVertexArrayData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomVertexArrayData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomVertexArrayData);
  }
}

/**
 * Python method tables for GeomVertexArrayDataHandle (GeomVertexArrayDataHandle)
 */
static PyMethodDef Dtool_Methods_GeomVertexArrayDataHandle[] = {
  {"get_object", &Dtool_GeomVertexArrayDataHandle_get_object_417, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_object_417_comment},
  {"getObject", &Dtool_GeomVertexArrayDataHandle_get_object_417, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_object_417_comment},
  {"get_array_format", &Dtool_GeomVertexArrayDataHandle_get_array_format_420, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_array_format_420_comment},
  {"getArrayFormat", &Dtool_GeomVertexArrayDataHandle_get_array_format_420, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_array_format_420_comment},
  {"get_usage_hint", &Dtool_GeomVertexArrayDataHandle_get_usage_hint_421, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_usage_hint_421_comment},
  {"getUsageHint", &Dtool_GeomVertexArrayDataHandle_get_usage_hint_421, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_usage_hint_421_comment},
  {"get_num_rows", &Dtool_GeomVertexArrayDataHandle_get_num_rows_424, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_num_rows_424_comment},
  {"getNumRows", &Dtool_GeomVertexArrayDataHandle_get_num_rows_424, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_num_rows_424_comment},
  {"set_num_rows", &Dtool_GeomVertexArrayDataHandle_set_num_rows_425, METH_O, (const char *)Dtool_GeomVertexArrayDataHandle_set_num_rows_425_comment},
  {"setNumRows", &Dtool_GeomVertexArrayDataHandle_set_num_rows_425, METH_O, (const char *)Dtool_GeomVertexArrayDataHandle_set_num_rows_425_comment},
  {"unclean_set_num_rows", &Dtool_GeomVertexArrayDataHandle_unclean_set_num_rows_426, METH_O, (const char *)Dtool_GeomVertexArrayDataHandle_unclean_set_num_rows_426_comment},
  {"uncleanSetNumRows", &Dtool_GeomVertexArrayDataHandle_unclean_set_num_rows_426, METH_O, (const char *)Dtool_GeomVertexArrayDataHandle_unclean_set_num_rows_426_comment},
  {"reserve_num_rows", &Dtool_GeomVertexArrayDataHandle_reserve_num_rows_427, METH_O, (const char *)Dtool_GeomVertexArrayDataHandle_reserve_num_rows_427_comment},
  {"reserveNumRows", &Dtool_GeomVertexArrayDataHandle_reserve_num_rows_427, METH_O, (const char *)Dtool_GeomVertexArrayDataHandle_reserve_num_rows_427_comment},
  {"clear_rows", &Dtool_GeomVertexArrayDataHandle_clear_rows_428, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_clear_rows_428_comment},
  {"clearRows", &Dtool_GeomVertexArrayDataHandle_clear_rows_428, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_clear_rows_428_comment},
  {"get_data_size_bytes", &Dtool_GeomVertexArrayDataHandle_get_data_size_bytes_429, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_data_size_bytes_429_comment},
  {"getDataSizeBytes", &Dtool_GeomVertexArrayDataHandle_get_data_size_bytes_429, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_data_size_bytes_429_comment},
  {"get_modified", &Dtool_GeomVertexArrayDataHandle_get_modified_430, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_modified_430_comment},
  {"getModified", &Dtool_GeomVertexArrayDataHandle_get_modified_430, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_modified_430_comment},
  {"request_resident", &Dtool_GeomVertexArrayDataHandle_request_resident_433, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_request_resident_433_comment},
  {"requestResident", &Dtool_GeomVertexArrayDataHandle_request_resident_433, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_request_resident_433_comment},
  {"prepare_now", (PyCFunction) &Dtool_GeomVertexArrayDataHandle_prepare_now_434, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayDataHandle_prepare_now_434_comment},
  {"prepareNow", (PyCFunction) &Dtool_GeomVertexArrayDataHandle_prepare_now_434, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayDataHandle_prepare_now_434_comment},
  {"copy_data_from", &Dtool_GeomVertexArrayDataHandle_copy_data_from_435, METH_O, (const char *)Dtool_GeomVertexArrayDataHandle_copy_data_from_435_comment},
  {"copyDataFrom", &Dtool_GeomVertexArrayDataHandle_copy_data_from_435, METH_O, (const char *)Dtool_GeomVertexArrayDataHandle_copy_data_from_435_comment},
  {"copy_subdata_from", (PyCFunction) &Dtool_GeomVertexArrayDataHandle_copy_subdata_from_436, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayDataHandle_copy_subdata_from_436_comment},
  {"copySubdataFrom", (PyCFunction) &Dtool_GeomVertexArrayDataHandle_copy_subdata_from_436, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayDataHandle_copy_subdata_from_436_comment},
  {"get_data", &Dtool_GeomVertexArrayDataHandle_get_data_437, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_data_437_comment},
  {"getData", &Dtool_GeomVertexArrayDataHandle_get_data_437, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_get_data_437_comment},
  {"set_data", &Dtool_GeomVertexArrayDataHandle_set_data_438, METH_O, (const char *)Dtool_GeomVertexArrayDataHandle_set_data_438_comment},
  {"setData", &Dtool_GeomVertexArrayDataHandle_set_data_438, METH_O, (const char *)Dtool_GeomVertexArrayDataHandle_set_data_438_comment},
  {"get_subdata", (PyCFunction) &Dtool_GeomVertexArrayDataHandle_get_subdata_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayDataHandle_get_subdata_439_comment},
  {"getSubdata", (PyCFunction) &Dtool_GeomVertexArrayDataHandle_get_subdata_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayDataHandle_get_subdata_439_comment},
  {"set_subdata", (PyCFunction) &Dtool_GeomVertexArrayDataHandle_set_subdata_440, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayDataHandle_set_subdata_440_comment},
  {"setSubdata", (PyCFunction) &Dtool_GeomVertexArrayDataHandle_set_subdata_440, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexArrayDataHandle_set_subdata_440_comment},
  {"mark_used", &Dtool_GeomVertexArrayDataHandle_mark_used_441, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_mark_used_441_comment},
  {"markUsed", &Dtool_GeomVertexArrayDataHandle_mark_used_441, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_mark_used_441_comment},
  {"get_class_type", &Dtool_GeomVertexArrayDataHandle_get_class_type_442, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayDataHandle_get_class_type_442_comment},
  {"getClassType", &Dtool_GeomVertexArrayDataHandle_get_class_type_442, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexArrayDataHandle_get_class_type_442_comment},
  {"upcast_to_ReferenceCount", &Dtool_GeomVertexArrayDataHandle_upcast_to_ReferenceCount_412, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_upcast_to_ReferenceCount_412_comment},
  {"upcastToReferenceCount", &Dtool_GeomVertexArrayDataHandle_upcast_to_ReferenceCount_412, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_upcast_to_ReferenceCount_412_comment},
  {"upcast_to_GeomEnums", &Dtool_GeomVertexArrayDataHandle_upcast_to_GeomEnums_414, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_upcast_to_GeomEnums_414_comment},
  {"upcastToGeomEnums", &Dtool_GeomVertexArrayDataHandle_upcast_to_GeomEnums_414, METH_NOARGS, (const char *)Dtool_GeomVertexArrayDataHandle_upcast_to_GeomEnums_414_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_GeomVertexArrayDataHandle[] = {
  {(char *)"object", &Dtool_GeomVertexArrayDataHandle_object_Getter, nullptr, nullptr, nullptr},
  {(char *)"array_format", &Dtool_GeomVertexArrayDataHandle_array_format_Getter, nullptr, nullptr, nullptr},
  {(char *)"usage_hint", &Dtool_GeomVertexArrayDataHandle_usage_hint_Getter, nullptr, nullptr, nullptr},
  {(char *)"data_size_bytes", &Dtool_GeomVertexArrayDataHandle_data_size_bytes_Getter, nullptr, nullptr, nullptr},
  {(char *)"modified", &Dtool_GeomVertexArrayDataHandle_modified_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GeomVertexArrayDataHandle = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomVertexArrayDataHandle = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomVertexArrayDataHandle = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomVertexArrayDataHandle = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomVertexArrayDataHandle = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomVertexArrayDataHandle = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomVertexArrayDataHandle",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomVertexArrayDataHandle,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomVertexArrayDataHandle,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomVertexArrayDataHandle,
    &Dtool_SequenceMethods_GeomVertexArrayDataHandle,
    &Dtool_MappingMethods_GeomVertexArrayDataHandle,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomVertexArrayDataHandle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This data object is returned by GeomVertexArrayData::get_handle() or\n"
    " * modify_handle(). As long as it exists, the data is locked; when the last of\n"
    " * these destructs, the data is unlocked.\n"
    " *\n"
    " * Only one thread at a time may lock the data; other threads attempting to\n"
    " * lock the data will block.  A given thread may simultaneously lock the data\n"
    " * multiple times.\n"
    " *\n"
    " * This class serves in lieu of a pair of GeomVertexArrayDataPipelineReader\n"
    " * and GeomVertexArrayDataPipelineWriter classes\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomVertexArrayDataHandle,
    nullptr, // tp_members
    Dtool_Properties_GeomVertexArrayDataHandle,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomVertexArrayDataHandle,
    PyType_GenericAlloc,
    Dtool_new_GeomVertexArrayDataHandle,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomVertexArrayDataHandle,
  Dtool_UpcastInterface_GeomVertexArrayDataHandle,
  Dtool_DowncastInterface_GeomVertexArrayDataHandle,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomVertexArrayDataHandle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_GeomVertexArrayDataHandle._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_ReferenceCount, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_GeomVertexArrayDataHandle._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomVertexArrayDataHandle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomVertexArrayDataHandle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomVertexArrayDataHandle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomVertexArrayDataHandle);
  }
}

/**
 * Python method tables for GeomCacheManager (GeomCacheManager)
 */
static PyMethodDef Dtool_Methods_GeomCacheManager[] = {
  {"set_max_size", &Dtool_GeomCacheManager_set_max_size_444, METH_O, (const char *)Dtool_GeomCacheManager_set_max_size_444_comment},
  {"setMaxSize", &Dtool_GeomCacheManager_set_max_size_444, METH_O, (const char *)Dtool_GeomCacheManager_set_max_size_444_comment},
  {"get_max_size", &Dtool_GeomCacheManager_get_max_size_445, METH_NOARGS, (const char *)Dtool_GeomCacheManager_get_max_size_445_comment},
  {"getMaxSize", &Dtool_GeomCacheManager_get_max_size_445, METH_NOARGS, (const char *)Dtool_GeomCacheManager_get_max_size_445_comment},
  {"get_total_size", &Dtool_GeomCacheManager_get_total_size_446, METH_NOARGS, (const char *)Dtool_GeomCacheManager_get_total_size_446_comment},
  {"getTotalSize", &Dtool_GeomCacheManager_get_total_size_446, METH_NOARGS, (const char *)Dtool_GeomCacheManager_get_total_size_446_comment},
  {"flush", &Dtool_GeomCacheManager_flush_447, METH_NOARGS, (const char *)Dtool_GeomCacheManager_flush_447_comment},
  {"get_global_ptr", &Dtool_GeomCacheManager_get_global_ptr_448, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomCacheManager_get_global_ptr_448_comment},
  {"getGlobalPtr", &Dtool_GeomCacheManager_get_global_ptr_448, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomCacheManager_get_global_ptr_448_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomCacheManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_GeomCacheManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomCacheManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomCacheManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomCacheManager,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is used to keep track of, and limit the size of, the cache of munged\n"
    " * vertices, which would otherwise be distributed through all of the\n"
    " * GeomVertexData objects in the system.\n"
    " *\n"
    " * The actual data in the cache is not stored here, but rather it is\n"
    " * distributed among the various GeomVertexData source objects.  This allows\n"
    " * the cache data to propagate through the multiprocess pipeline.\n"
    " *\n"
    " * This structure actually caches any of a number of different types of\n"
    " * pointers, and mixes them all up in the same LRU cache list.  Some of them\n"
    " * (such as GeomMunger) are reference-counted here in the cache; most are not.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomCacheManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomCacheManager,
    PyType_GenericAlloc,
    Dtool_new_GeomCacheManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomCacheManager,
  Dtool_UpcastInterface_GeomCacheManager,
  Dtool_DowncastInterface_GeomCacheManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomCacheManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_GeomCacheManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomCacheManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomCacheManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomCacheManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomCacheManager);
  }
}

/**
 * Python method tables for VertexTransform (VertexTransform)
 */
static PyMethodDef Dtool_Methods_VertexTransform[] = {
  {"get_matrix", &Dtool_VertexTransform_get_matrix_450, METH_O, (const char *)Dtool_VertexTransform_get_matrix_450_comment},
  {"getMatrix", &Dtool_VertexTransform_get_matrix_450, METH_O, (const char *)Dtool_VertexTransform_get_matrix_450_comment},
  {"mult_matrix", (PyCFunction) &Dtool_VertexTransform_mult_matrix_451, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VertexTransform_mult_matrix_451_comment},
  {"multMatrix", (PyCFunction) &Dtool_VertexTransform_mult_matrix_451, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VertexTransform_mult_matrix_451_comment},
  {"accumulate_matrix", (PyCFunction) &Dtool_VertexTransform_accumulate_matrix_452, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VertexTransform_accumulate_matrix_452_comment},
  {"accumulateMatrix", (PyCFunction) &Dtool_VertexTransform_accumulate_matrix_452, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VertexTransform_accumulate_matrix_452_comment},
  {"get_modified", (PyCFunction) &Dtool_VertexTransform_get_modified_453, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VertexTransform_get_modified_453_comment},
  {"getModified", (PyCFunction) &Dtool_VertexTransform_get_modified_453, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VertexTransform_get_modified_453_comment},
  {"output", &Dtool_VertexTransform_output_455, METH_O, (const char *)Dtool_VertexTransform_output_455_comment},
  {"write", (PyCFunction) &Dtool_VertexTransform_write_456, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VertexTransform_write_456_comment},
  {"get_next_modified", &Dtool_VertexTransform_get_next_modified_457, METH_O | METH_STATIC, (const char *)Dtool_VertexTransform_get_next_modified_457_comment},
  {"getNextModified", &Dtool_VertexTransform_get_next_modified_457, METH_O | METH_STATIC, (const char *)Dtool_VertexTransform_get_next_modified_457_comment},
  {"get_global_modified", &Dtool_VertexTransform_get_global_modified_458, METH_O | METH_STATIC, (const char *)Dtool_VertexTransform_get_global_modified_458_comment},
  {"getGlobalModified", &Dtool_VertexTransform_get_global_modified_458, METH_O | METH_STATIC, (const char *)Dtool_VertexTransform_get_global_modified_458_comment},
  {"get_class_type", &Dtool_VertexTransform_get_class_type_459, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexTransform_get_class_type_459_comment},
  {"getClassType", &Dtool_VertexTransform_get_class_type_459, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexTransform_get_class_type_459_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     VertexTransform
//////////////////
static PyObject *Dtool_Repr_VertexTransform(PyObject *self) {
  VertexTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VertexTransform, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     VertexTransform
//////////////////
static PyObject *Dtool_Str_VertexTransform(PyObject *self) {
  VertexTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VertexTransform, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_VertexTransform[] = {
  {(char *)"modified", &Dtool_VertexTransform_modified_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_VertexTransform = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VertexTransform = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VertexTransform = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VertexTransform = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VertexTransform = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VertexTransform = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VertexTransform",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VertexTransform,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VertexTransform,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_VertexTransform,
    &Dtool_NumberMethods_VertexTransform,
    &Dtool_SequenceMethods_VertexTransform,
    &Dtool_MappingMethods_VertexTransform,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_VertexTransform,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VertexTransform,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an abstract base class that holds a pointer to some transform,\n"
    " * computed in some arbitrary way, that is to be applied to vertices during\n"
    " * rendering.  This is used to implement soft-skinned and animated vertices.\n"
    " * Derived classes will define how the transform is actually computed.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VertexTransform,
    nullptr, // tp_members
    Dtool_Properties_VertexTransform,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VertexTransform,
    PyType_GenericAlloc,
    Dtool_new_VertexTransform,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VertexTransform,
  Dtool_UpcastInterface_VertexTransform,
  Dtool_DowncastInterface_VertexTransform,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VertexTransform(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_VertexTransform._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_VertexTransform._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VertexTransform._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VertexTransform) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VertexTransform)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VertexTransform);
  }
}

/**
 * Python method tables for TransformTable (TransformTable)
 */
static PyMethodDef Dtool_Methods_TransformTable[] = {
  {"assign", &Dtool_TransformTable_operator_462, METH_O, (const char *)Dtool_TransformTable_operator_462_comment},
  {"is_registered", &Dtool_TransformTable_is_registered_463, METH_NOARGS, (const char *)Dtool_TransformTable_is_registered_463_comment},
  {"isRegistered", &Dtool_TransformTable_is_registered_463, METH_NOARGS, (const char *)Dtool_TransformTable_is_registered_463_comment},
  {"register_table", &Dtool_TransformTable_register_table_464, METH_O | METH_STATIC, (const char *)Dtool_TransformTable_register_table_464_comment},
  {"registerTable", &Dtool_TransformTable_register_table_464, METH_O | METH_STATIC, (const char *)Dtool_TransformTable_register_table_464_comment},
  {"get_num_transforms", &Dtool_TransformTable_get_num_transforms_465, METH_NOARGS, (const char *)Dtool_TransformTable_get_num_transforms_465_comment},
  {"getNumTransforms", &Dtool_TransformTable_get_num_transforms_465, METH_NOARGS, (const char *)Dtool_TransformTable_get_num_transforms_465_comment},
  {"get_transform", &Dtool_TransformTable_get_transform_466, METH_O, (const char *)Dtool_TransformTable_get_transform_466_comment},
  {"getTransform", &Dtool_TransformTable_get_transform_466, METH_O, (const char *)Dtool_TransformTable_get_transform_466_comment},
  {"get_modified", (PyCFunction) &Dtool_TransformTable_get_modified_468, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformTable_get_modified_468_comment},
  {"getModified", (PyCFunction) &Dtool_TransformTable_get_modified_468, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformTable_get_modified_468_comment},
  {"set_transform", (PyCFunction) &Dtool_TransformTable_set_transform_469, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformTable_set_transform_469_comment},
  {"setTransform", (PyCFunction) &Dtool_TransformTable_set_transform_469, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformTable_set_transform_469_comment},
  {"insert_transform", (PyCFunction) &Dtool_TransformTable_insert_transform_470, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformTable_insert_transform_470_comment},
  {"insertTransform", (PyCFunction) &Dtool_TransformTable_insert_transform_470, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformTable_insert_transform_470_comment},
  {"remove_transform", &Dtool_TransformTable_remove_transform_471, METH_O, (const char *)Dtool_TransformTable_remove_transform_471_comment},
  {"removeTransform", &Dtool_TransformTable_remove_transform_471, METH_O, (const char *)Dtool_TransformTable_remove_transform_471_comment},
  {"add_transform", &Dtool_TransformTable_add_transform_472, METH_O, (const char *)Dtool_TransformTable_add_transform_472_comment},
  {"addTransform", &Dtool_TransformTable_add_transform_472, METH_O, (const char *)Dtool_TransformTable_add_transform_472_comment},
  {"write", &Dtool_TransformTable_write_473, METH_O, (const char *)Dtool_TransformTable_write_473_comment},
  {"get_class_type", &Dtool_TransformTable_get_class_type_479, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformTable_get_class_type_479_comment},
  {"getClassType", &Dtool_TransformTable_get_class_type_479, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformTable_get_class_type_479_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_transforms", (PyCFunction) &MakeSeq_TransformTable_get_transforms, METH_NOARGS, nullptr},
  { "getTransforms", (PyCFunction) &MakeSeq_TransformTable_get_transforms, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     TransformTable
//////////////////
static PyObject *Dtool_Str_TransformTable(PyObject *self) {
  TransformTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformTable, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_TransformTable[] = {
  {(char *)"registered", &Dtool_TransformTable_registered_Getter, nullptr, nullptr, nullptr},
  {(char *)"modified", &Dtool_TransformTable_modified_Getter, nullptr, nullptr, nullptr},
  {(char *)"transforms", &Dtool_TransformTable_transforms_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TransformTable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TransformTable = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TransformTable = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TransformTable = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TransformTable = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TransformTable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TransformTable",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TransformTable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TransformTable,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TransformTable,
    &Dtool_SequenceMethods_TransformTable,
    &Dtool_MappingMethods_TransformTable,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_TransformTable,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TransformTable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Stores the total set of VertexTransforms that the vertices in a particular\n"
    " * GeomVertexData object might depend on.\n"
    " *\n"
    " * This structure is used for a GeomVertexData set up to compute its dynamic\n"
    " * vertices on the graphics card.  See TransformBlendTable for one set up to\n"
    " * compute its dynamic vertices on the CPU.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TransformTable,
    nullptr, // tp_members
    Dtool_Properties_TransformTable,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TransformTable,
    PyType_GenericAlloc,
    Dtool_new_TransformTable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TransformTable,
  Dtool_UpcastInterface_TransformTable,
  Dtool_DowncastInterface_TransformTable,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TransformTable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_TransformTable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_TransformTable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TransformTable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TransformTable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TransformTable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TransformTable);
  }
}

/**
 * Python method tables for TransformBlend (TransformBlend)
 */
static PyMethodDef Dtool_Methods_TransformBlend[] = {
  {"assign", &Dtool_TransformBlend_operator_482, METH_O, (const char *)Dtool_TransformBlend_operator_482_comment},
  {"compare_to", &Dtool_TransformBlend_compare_to_484, METH_O, (const char *)Dtool_TransformBlend_compare_to_484_comment},
  {"compareTo", &Dtool_TransformBlend_compare_to_484, METH_O, (const char *)Dtool_TransformBlend_compare_to_484_comment},
  {"add_transform", (PyCFunction) &Dtool_TransformBlend_add_transform_488, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_add_transform_488_comment},
  {"addTransform", (PyCFunction) &Dtool_TransformBlend_add_transform_488, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_add_transform_488_comment},
  {"remove_transform", &Dtool_TransformBlend_remove_transform_489, METH_O, (const char *)Dtool_TransformBlend_remove_transform_489_comment},
  {"removeTransform", &Dtool_TransformBlend_remove_transform_489, METH_O, (const char *)Dtool_TransformBlend_remove_transform_489_comment},
  {"limit_transforms", &Dtool_TransformBlend_limit_transforms_490, METH_O, (const char *)Dtool_TransformBlend_limit_transforms_490_comment},
  {"limitTransforms", &Dtool_TransformBlend_limit_transforms_490, METH_O, (const char *)Dtool_TransformBlend_limit_transforms_490_comment},
  {"normalize_weights", &Dtool_TransformBlend_normalize_weights_491, METH_NOARGS, (const char *)Dtool_TransformBlend_normalize_weights_491_comment},
  {"normalizeWeights", &Dtool_TransformBlend_normalize_weights_491, METH_NOARGS, (const char *)Dtool_TransformBlend_normalize_weights_491_comment},
  {"has_transform", &Dtool_TransformBlend_has_transform_492, METH_O, (const char *)Dtool_TransformBlend_has_transform_492_comment},
  {"hasTransform", &Dtool_TransformBlend_has_transform_492, METH_O, (const char *)Dtool_TransformBlend_has_transform_492_comment},
  {"get_weight", &Dtool_TransformBlend_get_weight_493, METH_O, (const char *)Dtool_TransformBlend_get_weight_493_comment},
  {"getWeight", &Dtool_TransformBlend_get_weight_493, METH_O, (const char *)Dtool_TransformBlend_get_weight_493_comment},
  {"get_num_transforms", &Dtool_TransformBlend_get_num_transforms_494, METH_NOARGS, (const char *)Dtool_TransformBlend_get_num_transforms_494_comment},
  {"getNumTransforms", &Dtool_TransformBlend_get_num_transforms_494, METH_NOARGS, (const char *)Dtool_TransformBlend_get_num_transforms_494_comment},
  {"get_transform", &Dtool_TransformBlend_get_transform_495, METH_O, (const char *)Dtool_TransformBlend_get_transform_495_comment},
  {"getTransform", &Dtool_TransformBlend_get_transform_495, METH_O, (const char *)Dtool_TransformBlend_get_transform_495_comment},
  {"set_transform", (PyCFunction) &Dtool_TransformBlend_set_transform_497, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_set_transform_497_comment},
  {"setTransform", (PyCFunction) &Dtool_TransformBlend_set_transform_497, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_set_transform_497_comment},
  {"set_weight", (PyCFunction) &Dtool_TransformBlend_set_weight_498, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_set_weight_498_comment},
  {"setWeight", (PyCFunction) &Dtool_TransformBlend_set_weight_498, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_set_weight_498_comment},
  {"update_blend", &Dtool_TransformBlend_update_blend_503, METH_O, (const char *)Dtool_TransformBlend_update_blend_503_comment},
  {"updateBlend", &Dtool_TransformBlend_update_blend_503, METH_O, (const char *)Dtool_TransformBlend_update_blend_503_comment},
  {"get_blend", (PyCFunction) &Dtool_TransformBlend_get_blend_504, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_get_blend_504_comment},
  {"getBlend", (PyCFunction) &Dtool_TransformBlend_get_blend_504, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_get_blend_504_comment},
  {"transform_point", (PyCFunction) &Dtool_TransformBlend_transform_point_505, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_transform_point_505_comment},
  {"transformPoint", (PyCFunction) &Dtool_TransformBlend_transform_point_505, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_transform_point_505_comment},
  {"transform_vector", (PyCFunction) &Dtool_TransformBlend_transform_vector_506, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_transform_vector_506_comment},
  {"transformVector", (PyCFunction) &Dtool_TransformBlend_transform_vector_506, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_transform_vector_506_comment},
  {"get_modified", (PyCFunction) &Dtool_TransformBlend_get_modified_507, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_get_modified_507_comment},
  {"getModified", (PyCFunction) &Dtool_TransformBlend_get_modified_507, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_get_modified_507_comment},
  {"output", &Dtool_TransformBlend_output_509, METH_O, (const char *)Dtool_TransformBlend_output_509_comment},
  {"write", (PyCFunction) &Dtool_TransformBlend_write_510, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlend_write_510_comment},
  {"get_class_type", &Dtool_TransformBlend_get_class_type_511, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformBlend_get_class_type_511_comment},
  {"getClassType", &Dtool_TransformBlend_get_class_type_511, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformBlend_get_class_type_511_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_transforms", (PyCFunction) &MakeSeq_TransformBlend_get_transforms, METH_NOARGS, nullptr},
  { "getTransforms", (PyCFunction) &MakeSeq_TransformBlend_get_transforms, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TransformBlend slot tp_compare -> compare_to
//////////////////
static int Dtool_TransformBlend_compare_to_484_tp_compare(PyObject *self, PyObject *arg) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlend, (void **)&local_this)) {
    return -1;
  }

  // 1-int TransformBlend::compare_to(TransformBlend const &other) const
  TransformBlend arg_local;
  TransformBlend const *arg_this = Dtool_Coerce_TransformBlend(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TransformBlend.compare_to", "TransformBlend");
    return -1;
  }
  int return_value = ((*(const TransformBlend*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(TransformBlend self, const TransformBlend other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     TransformBlend
//////////////////
static PyObject *Dtool_Repr_TransformBlend(PyObject *self) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlend, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     TransformBlend
//////////////////
static PyObject *Dtool_Str_TransformBlend(PyObject *self) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlend, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     TransformBlend
//////////////////
static PyObject *Dtool_RichCompare_TransformBlend(PyObject *self, PyObject *arg, int op) {
  TransformBlend *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlend, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool TransformBlend::operator <(TransformBlend const &other) const
      TransformBlend arg_local;
      TransformBlend const *arg_this = Dtool_Coerce_TransformBlend(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const TransformBlend*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool TransformBlend::operator ==(TransformBlend const &other) const
      TransformBlend arg_local;
      TransformBlend const *arg_this = Dtool_Coerce_TransformBlend(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const TransformBlend*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool TransformBlend::operator !=(TransformBlend const &other) const
      TransformBlend arg_local;
      TransformBlend const *arg_this = Dtool_Coerce_TransformBlend(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const TransformBlend*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_TransformBlend_compare_to_484_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_TransformBlend[] = {
  {(char *)"transforms", &Dtool_TransformBlend_transforms_Getter, nullptr, nullptr, nullptr},
  {(char *)"weights", &Dtool_TransformBlend_weights_Getter, nullptr, nullptr, nullptr},
  {(char *)"modified", &Dtool_TransformBlend_modified_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TransformBlend = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TransformBlend = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TransformBlend",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TransformBlend,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_TransformBlend_compare_to_484_tp_compare,
#endif
    &Dtool_Repr_TransformBlend,
    &Dtool_NumberMethods_TransformBlend,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_TransformBlend,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines a single entry in a TransformBlendTable.  It represents a\n"
    " * unique combination of VertexTransform pointers and blend amounts.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_TransformBlend,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TransformBlend,
    nullptr, // tp_members
    Dtool_Properties_TransformBlend,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TransformBlend,
    PyType_GenericAlloc,
    Dtool_new_TransformBlend,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TransformBlend,
  Dtool_UpcastInterface_TransformBlend,
  Dtool_DowncastInterface_TransformBlend,
  nullptr,
  (CoerceFunction)Dtool_Coerce_TransformBlend,
};

static void Dtool_PyModuleClassInit_TransformBlend(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TransformBlend._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TransformBlend._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TransformBlend) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TransformBlend)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TransformBlend);
  }
}

/**
 * Python method tables for TransformBlendTable (TransformBlendTable)
 */
static PyMethodDef Dtool_Methods_TransformBlendTable[] = {
  {"assign", &Dtool_TransformBlendTable_operator_514, METH_O, (const char *)Dtool_TransformBlendTable_operator_514_comment},
  {"get_num_blends", &Dtool_TransformBlendTable_get_num_blends_515, METH_NOARGS, (const char *)Dtool_TransformBlendTable_get_num_blends_515_comment},
  {"getNumBlends", &Dtool_TransformBlendTable_get_num_blends_515, METH_NOARGS, (const char *)Dtool_TransformBlendTable_get_num_blends_515_comment},
  {"get_blend", &Dtool_TransformBlendTable_get_blend_516, METH_O, (const char *)Dtool_TransformBlendTable_get_blend_516_comment},
  {"getBlend", &Dtool_TransformBlendTable_get_blend_516, METH_O, (const char *)Dtool_TransformBlendTable_get_blend_516_comment},
  {"get_modified", (PyCFunction) &Dtool_TransformBlendTable_get_modified_518, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlendTable_get_modified_518_comment},
  {"getModified", (PyCFunction) &Dtool_TransformBlendTable_get_modified_518, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlendTable_get_modified_518_comment},
  {"set_blend", (PyCFunction) &Dtool_TransformBlendTable_set_blend_519, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlendTable_set_blend_519_comment},
  {"setBlend", (PyCFunction) &Dtool_TransformBlendTable_set_blend_519, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlendTable_set_blend_519_comment},
  {"remove_blend", &Dtool_TransformBlendTable_remove_blend_520, METH_O, (const char *)Dtool_TransformBlendTable_remove_blend_520_comment},
  {"removeBlend", &Dtool_TransformBlendTable_remove_blend_520, METH_O, (const char *)Dtool_TransformBlendTable_remove_blend_520_comment},
  {"add_blend", &Dtool_TransformBlendTable_add_blend_521, METH_O, (const char *)Dtool_TransformBlendTable_add_blend_521_comment},
  {"addBlend", &Dtool_TransformBlendTable_add_blend_521, METH_O, (const char *)Dtool_TransformBlendTable_add_blend_521_comment},
  {"get_num_transforms", &Dtool_TransformBlendTable_get_num_transforms_522, METH_NOARGS, (const char *)Dtool_TransformBlendTable_get_num_transforms_522_comment},
  {"getNumTransforms", &Dtool_TransformBlendTable_get_num_transforms_522, METH_NOARGS, (const char *)Dtool_TransformBlendTable_get_num_transforms_522_comment},
  {"get_max_simultaneous_transforms", &Dtool_TransformBlendTable_get_max_simultaneous_transforms_523, METH_NOARGS, (const char *)Dtool_TransformBlendTable_get_max_simultaneous_transforms_523_comment},
  {"getMaxSimultaneousTransforms", &Dtool_TransformBlendTable_get_max_simultaneous_transforms_523, METH_NOARGS, (const char *)Dtool_TransformBlendTable_get_max_simultaneous_transforms_523_comment},
  {"set_rows", &Dtool_TransformBlendTable_set_rows_524, METH_O, (const char *)Dtool_TransformBlendTable_set_rows_524_comment},
  {"setRows", &Dtool_TransformBlendTable_set_rows_524, METH_O, (const char *)Dtool_TransformBlendTable_set_rows_524_comment},
  {"get_rows", &Dtool_TransformBlendTable_get_rows_525, METH_NOARGS, (const char *)Dtool_TransformBlendTable_get_rows_525_comment},
  {"getRows", &Dtool_TransformBlendTable_get_rows_525, METH_NOARGS, (const char *)Dtool_TransformBlendTable_get_rows_525_comment},
  {"modify_rows", &Dtool_TransformBlendTable_modify_rows_526, METH_NOARGS, (const char *)Dtool_TransformBlendTable_modify_rows_526_comment},
  {"modifyRows", &Dtool_TransformBlendTable_modify_rows_526, METH_NOARGS, (const char *)Dtool_TransformBlendTable_modify_rows_526_comment},
  {"write", (PyCFunction) &Dtool_TransformBlendTable_write_527, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TransformBlendTable_write_527_comment},
  {"get_class_type", &Dtool_TransformBlendTable_get_class_type_536, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformBlendTable_get_class_type_536_comment},
  {"getClassType", &Dtool_TransformBlendTable_get_class_type_536, METH_NOARGS | METH_STATIC, (const char *)Dtool_TransformBlendTable_get_class_type_536_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_blends", (PyCFunction) &MakeSeq_TransformBlendTable_get_blends, METH_NOARGS, nullptr},
  { "getBlends", (PyCFunction) &MakeSeq_TransformBlendTable_get_blends, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     TransformBlendTable
//////////////////
static PyObject *Dtool_Str_TransformBlendTable(PyObject *self) {
  TransformBlendTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TransformBlendTable, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_TransformBlendTable[] = {
  {(char *)"blends", &Dtool_TransformBlendTable_blends_Getter, nullptr, nullptr, nullptr},
  {(char *)"modified", &Dtool_TransformBlendTable_modified_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_transforms", &Dtool_TransformBlendTable_num_transforms_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_simultaneous_transforms", &Dtool_TransformBlendTable_max_simultaneous_transforms_Getter, nullptr, nullptr, nullptr},
  {(char *)"rows", &Dtool_TransformBlendTable_rows_Getter, &Dtool_TransformBlendTable_rows_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TransformBlendTable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TransformBlendTable = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TransformBlendTable = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TransformBlendTable = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TransformBlendTable = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TransformBlendTable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TransformBlendTable",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TransformBlendTable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TransformBlendTable,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TransformBlendTable,
    &Dtool_SequenceMethods_TransformBlendTable,
    &Dtool_MappingMethods_TransformBlendTable,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_TransformBlendTable,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TransformBlendTable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This structure collects together the different combinations of transforms\n"
    " * and blend amounts used by a GeomVertexData, to facilitate computing dynamic\n"
    " * vertices on the CPU at runtime.  Each vertex has a pointer to exactly one\n"
    " * of the entries in this table, and each entry defines a number of\n"
    " * transform/blend combinations.\n"
    " *\n"
    " * This structure is used for a GeomVertexData set up to compute its dynamic\n"
    " * vertices on the CPU.  See TransformTable for one set up to compute its\n"
    " * dynamic vertices on the graphics card.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TransformBlendTable,
    nullptr, // tp_members
    Dtool_Properties_TransformBlendTable,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TransformBlendTable,
    PyType_GenericAlloc,
    Dtool_new_TransformBlendTable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TransformBlendTable,
  Dtool_UpcastInterface_TransformBlendTable,
  Dtool_DowncastInterface_TransformBlendTable,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TransformBlendTable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CopyOnWriteObject != nullptr);
    assert(Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_TransformBlendTable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CopyOnWriteObject);
    Dtool_TransformBlendTable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TransformBlendTable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TransformBlendTable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TransformBlendTable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TransformBlendTable);
  }
}

/**
 * Python method tables for VertexSlider (VertexSlider)
 */
static PyMethodDef Dtool_Methods_VertexSlider[] = {
  {"get_name", &Dtool_VertexSlider_get_name_538, METH_NOARGS, (const char *)Dtool_VertexSlider_get_name_538_comment},
  {"getName", &Dtool_VertexSlider_get_name_538, METH_NOARGS, (const char *)Dtool_VertexSlider_get_name_538_comment},
  {"get_slider", &Dtool_VertexSlider_get_slider_540, METH_NOARGS, (const char *)Dtool_VertexSlider_get_slider_540_comment},
  {"getSlider", &Dtool_VertexSlider_get_slider_540, METH_NOARGS, (const char *)Dtool_VertexSlider_get_slider_540_comment},
  {"get_modified", (PyCFunction) &Dtool_VertexSlider_get_modified_541, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VertexSlider_get_modified_541_comment},
  {"getModified", (PyCFunction) &Dtool_VertexSlider_get_modified_541, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VertexSlider_get_modified_541_comment},
  {"output", &Dtool_VertexSlider_output_544, METH_O, (const char *)Dtool_VertexSlider_output_544_comment},
  {"write", (PyCFunction) &Dtool_VertexSlider_write_545, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VertexSlider_write_545_comment},
  {"get_class_type", &Dtool_VertexSlider_get_class_type_546, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexSlider_get_class_type_546_comment},
  {"getClassType", &Dtool_VertexSlider_get_class_type_546, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexSlider_get_class_type_546_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     VertexSlider
//////////////////
static PyObject *Dtool_Repr_VertexSlider(PyObject *self) {
  VertexSlider *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VertexSlider, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     VertexSlider
//////////////////
static PyObject *Dtool_Str_VertexSlider(PyObject *self) {
  VertexSlider *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VertexSlider, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_VertexSlider[] = {
  {(char *)"name", &Dtool_VertexSlider_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"slider", &Dtool_VertexSlider_slider_Getter, nullptr, nullptr, nullptr},
  {(char *)"modified", &Dtool_VertexSlider_modified_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_VertexSlider = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VertexSlider = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VertexSlider = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VertexSlider = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VertexSlider = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VertexSlider = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VertexSlider",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VertexSlider,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VertexSlider,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_VertexSlider,
    &Dtool_NumberMethods_VertexSlider,
    &Dtool_SequenceMethods_VertexSlider,
    &Dtool_MappingMethods_VertexSlider,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_VertexSlider,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VertexSlider,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an abstract base class that retains some slider value, which is a\n"
    " * linear value that typically ranges from 0.0 to 1.0, and is used to control\n"
    " * the animation of morphs (blend shapes).\n"
    " *\n"
    " * It is similar to VertexTransform, which keeps a full 4x4 transform matrix,\n"
    " * but the VertexSlider only keeps a single float value.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VertexSlider,
    nullptr, // tp_members
    Dtool_Properties_VertexSlider,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VertexSlider,
    PyType_GenericAlloc,
    Dtool_new_VertexSlider,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VertexSlider,
  Dtool_UpcastInterface_VertexSlider,
  Dtool_DowncastInterface_VertexSlider,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VertexSlider(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_VertexSlider._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_VertexSlider._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VertexSlider._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VertexSlider) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VertexSlider)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VertexSlider);
  }
}

/**
 * Python method tables for SliderTable (SliderTable)
 */
static PyMethodDef Dtool_Methods_SliderTable[] = {
  {"assign", &Dtool_SliderTable_operator_549, METH_O, (const char *)Dtool_SliderTable_operator_549_comment},
  {"is_registered", &Dtool_SliderTable_is_registered_550, METH_NOARGS, (const char *)Dtool_SliderTable_is_registered_550_comment},
  {"isRegistered", &Dtool_SliderTable_is_registered_550, METH_NOARGS, (const char *)Dtool_SliderTable_is_registered_550_comment},
  {"register_table", &Dtool_SliderTable_register_table_551, METH_O | METH_STATIC, (const char *)Dtool_SliderTable_register_table_551_comment},
  {"registerTable", &Dtool_SliderTable_register_table_551, METH_O | METH_STATIC, (const char *)Dtool_SliderTable_register_table_551_comment},
  {"get_num_sliders", &Dtool_SliderTable_get_num_sliders_552, METH_NOARGS, (const char *)Dtool_SliderTable_get_num_sliders_552_comment},
  {"getNumSliders", &Dtool_SliderTable_get_num_sliders_552, METH_NOARGS, (const char *)Dtool_SliderTable_get_num_sliders_552_comment},
  {"get_slider", &Dtool_SliderTable_get_slider_553, METH_O, (const char *)Dtool_SliderTable_get_slider_553_comment},
  {"getSlider", &Dtool_SliderTable_get_slider_553, METH_O, (const char *)Dtool_SliderTable_get_slider_553_comment},
  {"get_slider_rows", &Dtool_SliderTable_get_slider_rows_555, METH_O, (const char *)Dtool_SliderTable_get_slider_rows_555_comment},
  {"getSliderRows", &Dtool_SliderTable_get_slider_rows_555, METH_O, (const char *)Dtool_SliderTable_get_slider_rows_555_comment},
  {"find_sliders", &Dtool_SliderTable_find_sliders_556, METH_O, (const char *)Dtool_SliderTable_find_sliders_556_comment},
  {"findSliders", &Dtool_SliderTable_find_sliders_556, METH_O, (const char *)Dtool_SliderTable_find_sliders_556_comment},
  {"has_slider", &Dtool_SliderTable_has_slider_557, METH_O, (const char *)Dtool_SliderTable_has_slider_557_comment},
  {"hasSlider", &Dtool_SliderTable_has_slider_557, METH_O, (const char *)Dtool_SliderTable_has_slider_557_comment},
  {"is_empty", &Dtool_SliderTable_is_empty_558, METH_NOARGS, (const char *)Dtool_SliderTable_is_empty_558_comment},
  {"isEmpty", &Dtool_SliderTable_is_empty_558, METH_NOARGS, (const char *)Dtool_SliderTable_is_empty_558_comment},
  {"get_modified", (PyCFunction) &Dtool_SliderTable_get_modified_559, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SliderTable_get_modified_559_comment},
  {"getModified", (PyCFunction) &Dtool_SliderTable_get_modified_559, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SliderTable_get_modified_559_comment},
  {"set_slider", (PyCFunction) &Dtool_SliderTable_set_slider_561, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SliderTable_set_slider_561_comment},
  {"setSlider", (PyCFunction) &Dtool_SliderTable_set_slider_561, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SliderTable_set_slider_561_comment},
  {"set_slider_rows", (PyCFunction) &Dtool_SliderTable_set_slider_rows_562, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SliderTable_set_slider_rows_562_comment},
  {"setSliderRows", (PyCFunction) &Dtool_SliderTable_set_slider_rows_562, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SliderTable_set_slider_rows_562_comment},
  {"remove_slider", &Dtool_SliderTable_remove_slider_563, METH_O, (const char *)Dtool_SliderTable_remove_slider_563_comment},
  {"removeSlider", &Dtool_SliderTable_remove_slider_563, METH_O, (const char *)Dtool_SliderTable_remove_slider_563_comment},
  {"add_slider", (PyCFunction) &Dtool_SliderTable_add_slider_564, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SliderTable_add_slider_564_comment},
  {"addSlider", (PyCFunction) &Dtool_SliderTable_add_slider_564, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SliderTable_add_slider_564_comment},
  {"write", &Dtool_SliderTable_write_565, METH_O, (const char *)Dtool_SliderTable_write_565_comment},
  {"get_class_type", &Dtool_SliderTable_get_class_type_566, METH_NOARGS | METH_STATIC, (const char *)Dtool_SliderTable_get_class_type_566_comment},
  {"getClassType", &Dtool_SliderTable_get_class_type_566, METH_NOARGS | METH_STATIC, (const char *)Dtool_SliderTable_get_class_type_566_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_sliders", (PyCFunction) &MakeSeq_SliderTable_get_sliders, METH_NOARGS, nullptr},
  { "getSliders", (PyCFunction) &MakeSeq_SliderTable_get_sliders, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     SliderTable
//////////////////
static PyObject *Dtool_Str_SliderTable(PyObject *self) {
  SliderTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SliderTable, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_SliderTable[] = {
  {(char *)"modified", &Dtool_SliderTable_modified_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_SliderTable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SliderTable = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SliderTable = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SliderTable = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SliderTable = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SliderTable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SliderTable",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SliderTable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SliderTable,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SliderTable,
    &Dtool_SequenceMethods_SliderTable,
    &Dtool_MappingMethods_SliderTable,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_SliderTable,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SliderTable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Stores the total set of VertexSliders that the vertices in a particular\n"
    " * GeomVertexData object might depend on.\n"
    " *\n"
    " * This is similar to a TransformTable, but it stores VertexSliders instead of\n"
    " * VertexTransforms, and it stores them by name instead of by index number.\n"
    " * Also, it is only used when animating vertices on the CPU, since GPU's don't\n"
    " * support morphs at this point in time.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SliderTable,
    nullptr, // tp_members
    Dtool_Properties_SliderTable,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SliderTable,
    PyType_GenericAlloc,
    Dtool_new_SliderTable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SliderTable,
  Dtool_UpcastInterface_SliderTable,
  Dtool_DowncastInterface_SliderTable,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SliderTable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_SliderTable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_SliderTable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SliderTable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SliderTable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SliderTable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SliderTable);
  }
}

/**
 * Python method tables for GeomVertexData (GeomVertexData)
 */
static PyMethodDef Dtool_Methods_GeomVertexData[] = {
  {"assign", &Dtool_GeomVertexData_operator_573, METH_O, (const char *)Dtool_GeomVertexData_operator_573_comment},
  {"compare_to", &Dtool_GeomVertexData_compare_to_578, METH_O, (const char *)Dtool_GeomVertexData_compare_to_578_comment},
  {"compareTo", &Dtool_GeomVertexData_compare_to_578, METH_O, (const char *)Dtool_GeomVertexData_compare_to_578_comment},
  {"get_name", &Dtool_GeomVertexData_get_name_579, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_name_579_comment},
  {"getName", &Dtool_GeomVertexData_get_name_579, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_name_579_comment},
  {"set_name", &Dtool_GeomVertexData_set_name_580, METH_O, (const char *)Dtool_GeomVertexData_set_name_580_comment},
  {"setName", &Dtool_GeomVertexData_set_name_580, METH_O, (const char *)Dtool_GeomVertexData_set_name_580_comment},
  {"get_usage_hint", &Dtool_GeomVertexData_get_usage_hint_582, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_usage_hint_582_comment},
  {"getUsageHint", &Dtool_GeomVertexData_get_usage_hint_582, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_usage_hint_582_comment},
  {"set_usage_hint", &Dtool_GeomVertexData_set_usage_hint_583, METH_O, (const char *)Dtool_GeomVertexData_set_usage_hint_583_comment},
  {"setUsageHint", &Dtool_GeomVertexData_set_usage_hint_583, METH_O, (const char *)Dtool_GeomVertexData_set_usage_hint_583_comment},
  {"get_format", &Dtool_GeomVertexData_get_format_585, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_format_585_comment},
  {"getFormat", &Dtool_GeomVertexData_get_format_585, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_format_585_comment},
  {"set_format", &Dtool_GeomVertexData_set_format_586, METH_O, (const char *)Dtool_GeomVertexData_set_format_586_comment},
  {"setFormat", &Dtool_GeomVertexData_set_format_586, METH_O, (const char *)Dtool_GeomVertexData_set_format_586_comment},
  {"unclean_set_format", &Dtool_GeomVertexData_unclean_set_format_587, METH_O, (const char *)Dtool_GeomVertexData_unclean_set_format_587_comment},
  {"uncleanSetFormat", &Dtool_GeomVertexData_unclean_set_format_587, METH_O, (const char *)Dtool_GeomVertexData_unclean_set_format_587_comment},
  {"has_column", &Dtool_GeomVertexData_has_column_591, METH_O, (const char *)Dtool_GeomVertexData_has_column_591_comment},
  {"hasColumn", &Dtool_GeomVertexData_has_column_591, METH_O, (const char *)Dtool_GeomVertexData_has_column_591_comment},
  {"get_num_rows", &Dtool_GeomVertexData_get_num_rows_592, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_num_rows_592_comment},
  {"getNumRows", &Dtool_GeomVertexData_get_num_rows_592, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_num_rows_592_comment},
  {"set_num_rows", &Dtool_GeomVertexData_set_num_rows_593, METH_O, (const char *)Dtool_GeomVertexData_set_num_rows_593_comment},
  {"setNumRows", &Dtool_GeomVertexData_set_num_rows_593, METH_O, (const char *)Dtool_GeomVertexData_set_num_rows_593_comment},
  {"unclean_set_num_rows", &Dtool_GeomVertexData_unclean_set_num_rows_594, METH_O, (const char *)Dtool_GeomVertexData_unclean_set_num_rows_594_comment},
  {"uncleanSetNumRows", &Dtool_GeomVertexData_unclean_set_num_rows_594, METH_O, (const char *)Dtool_GeomVertexData_unclean_set_num_rows_594_comment},
  {"reserve_num_rows", &Dtool_GeomVertexData_reserve_num_rows_595, METH_O, (const char *)Dtool_GeomVertexData_reserve_num_rows_595_comment},
  {"reserveNumRows", &Dtool_GeomVertexData_reserve_num_rows_595, METH_O, (const char *)Dtool_GeomVertexData_reserve_num_rows_595_comment},
  {"clear_rows", &Dtool_GeomVertexData_clear_rows_596, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_rows_596_comment},
  {"clearRows", &Dtool_GeomVertexData_clear_rows_596, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_rows_596_comment},
  {"get_num_arrays", &Dtool_GeomVertexData_get_num_arrays_597, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_num_arrays_597_comment},
  {"getNumArrays", &Dtool_GeomVertexData_get_num_arrays_597, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_num_arrays_597_comment},
  {"get_array", &Dtool_GeomVertexData_get_array_598, METH_O, (const char *)Dtool_GeomVertexData_get_array_598_comment},
  {"getArray", &Dtool_GeomVertexData_get_array_598, METH_O, (const char *)Dtool_GeomVertexData_get_array_598_comment},
  {"get_array_handle", &Dtool_GeomVertexData_get_array_handle_599, METH_O, (const char *)Dtool_GeomVertexData_get_array_handle_599_comment},
  {"getArrayHandle", &Dtool_GeomVertexData_get_array_handle_599, METH_O, (const char *)Dtool_GeomVertexData_get_array_handle_599_comment},
  {"modify_array", &Dtool_GeomVertexData_modify_array_601, METH_O, (const char *)Dtool_GeomVertexData_modify_array_601_comment},
  {"modifyArray", &Dtool_GeomVertexData_modify_array_601, METH_O, (const char *)Dtool_GeomVertexData_modify_array_601_comment},
  {"modify_array_handle", &Dtool_GeomVertexData_modify_array_handle_602, METH_O, (const char *)Dtool_GeomVertexData_modify_array_handle_602_comment},
  {"modifyArrayHandle", &Dtool_GeomVertexData_modify_array_handle_602, METH_O, (const char *)Dtool_GeomVertexData_modify_array_handle_602_comment},
  {"set_array", (PyCFunction) &Dtool_GeomVertexData_set_array_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_set_array_603_comment},
  {"setArray", (PyCFunction) &Dtool_GeomVertexData_set_array_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_set_array_603_comment},
  {"get_transform_table", &Dtool_GeomVertexData_get_transform_table_606, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_transform_table_606_comment},
  {"getTransformTable", &Dtool_GeomVertexData_get_transform_table_606, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_transform_table_606_comment},
  {"set_transform_table", &Dtool_GeomVertexData_set_transform_table_607, METH_O, (const char *)Dtool_GeomVertexData_set_transform_table_607_comment},
  {"setTransformTable", &Dtool_GeomVertexData_set_transform_table_607, METH_O, (const char *)Dtool_GeomVertexData_set_transform_table_607_comment},
  {"clear_transform_table", &Dtool_GeomVertexData_clear_transform_table_608, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_transform_table_608_comment},
  {"clearTransformTable", &Dtool_GeomVertexData_clear_transform_table_608, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_transform_table_608_comment},
  {"get_transform_blend_table", &Dtool_GeomVertexData_get_transform_blend_table_612, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_transform_blend_table_612_comment},
  {"getTransformBlendTable", &Dtool_GeomVertexData_get_transform_blend_table_612, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_transform_blend_table_612_comment},
  {"modify_transform_blend_table", &Dtool_GeomVertexData_modify_transform_blend_table_613, METH_NOARGS, (const char *)Dtool_GeomVertexData_modify_transform_blend_table_613_comment},
  {"modifyTransformBlendTable", &Dtool_GeomVertexData_modify_transform_blend_table_613, METH_NOARGS, (const char *)Dtool_GeomVertexData_modify_transform_blend_table_613_comment},
  {"set_transform_blend_table", &Dtool_GeomVertexData_set_transform_blend_table_614, METH_O, (const char *)Dtool_GeomVertexData_set_transform_blend_table_614_comment},
  {"setTransformBlendTable", &Dtool_GeomVertexData_set_transform_blend_table_614, METH_O, (const char *)Dtool_GeomVertexData_set_transform_blend_table_614_comment},
  {"clear_transform_blend_table", &Dtool_GeomVertexData_clear_transform_blend_table_615, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_transform_blend_table_615_comment},
  {"clearTransformBlendTable", &Dtool_GeomVertexData_clear_transform_blend_table_615, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_transform_blend_table_615_comment},
  {"get_slider_table", &Dtool_GeomVertexData_get_slider_table_616, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_slider_table_616_comment},
  {"getSliderTable", &Dtool_GeomVertexData_get_slider_table_616, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_slider_table_616_comment},
  {"set_slider_table", &Dtool_GeomVertexData_set_slider_table_617, METH_O, (const char *)Dtool_GeomVertexData_set_slider_table_617_comment},
  {"setSliderTable", &Dtool_GeomVertexData_set_slider_table_617, METH_O, (const char *)Dtool_GeomVertexData_set_slider_table_617_comment},
  {"clear_slider_table", &Dtool_GeomVertexData_clear_slider_table_618, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_slider_table_618_comment},
  {"clearSliderTable", &Dtool_GeomVertexData_clear_slider_table_618, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_slider_table_618_comment},
  {"get_num_bytes", &Dtool_GeomVertexData_get_num_bytes_622, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_num_bytes_622_comment},
  {"getNumBytes", &Dtool_GeomVertexData_get_num_bytes_622, METH_NOARGS, (const char *)Dtool_GeomVertexData_get_num_bytes_622_comment},
  {"get_modified", (PyCFunction) &Dtool_GeomVertexData_get_modified_623, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_get_modified_623_comment},
  {"getModified", (PyCFunction) &Dtool_GeomVertexData_get_modified_623, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_get_modified_623_comment},
  {"request_resident", &Dtool_GeomVertexData_request_resident_626, METH_NOARGS, (const char *)Dtool_GeomVertexData_request_resident_626_comment},
  {"requestResident", &Dtool_GeomVertexData_request_resident_626, METH_NOARGS, (const char *)Dtool_GeomVertexData_request_resident_626_comment},
  {"copy_from", (PyCFunction) &Dtool_GeomVertexData_copy_from_627, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_copy_from_627_comment},
  {"copyFrom", (PyCFunction) &Dtool_GeomVertexData_copy_from_627, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_copy_from_627_comment},
  {"copy_row_from", (PyCFunction) &Dtool_GeomVertexData_copy_row_from_628, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_copy_row_from_628_comment},
  {"copyRowFrom", (PyCFunction) &Dtool_GeomVertexData_copy_row_from_628, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_copy_row_from_628_comment},
  {"convert_to", &Dtool_GeomVertexData_convert_to_629, METH_O, (const char *)Dtool_GeomVertexData_convert_to_629_comment},
  {"convertTo", &Dtool_GeomVertexData_convert_to_629, METH_O, (const char *)Dtool_GeomVertexData_convert_to_629_comment},
  {"scale_color", (PyCFunction) &Dtool_GeomVertexData_scale_color_630, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_scale_color_630_comment},
  {"scaleColor", (PyCFunction) &Dtool_GeomVertexData_scale_color_630, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_scale_color_630_comment},
  {"set_color", (PyCFunction) &Dtool_GeomVertexData_set_color_631, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_set_color_631_comment},
  {"setColor", (PyCFunction) &Dtool_GeomVertexData_set_color_631, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_set_color_631_comment},
  {"reverse_normals", &Dtool_GeomVertexData_reverse_normals_632, METH_NOARGS, (const char *)Dtool_GeomVertexData_reverse_normals_632_comment},
  {"reverseNormals", &Dtool_GeomVertexData_reverse_normals_632, METH_NOARGS, (const char *)Dtool_GeomVertexData_reverse_normals_632_comment},
  {"animate_vertices", (PyCFunction) &Dtool_GeomVertexData_animate_vertices_633, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_animate_vertices_633_comment},
  {"animateVertices", (PyCFunction) &Dtool_GeomVertexData_animate_vertices_633, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_animate_vertices_633_comment},
  {"clear_animated_vertices", &Dtool_GeomVertexData_clear_animated_vertices_634, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_animated_vertices_634_comment},
  {"clearAnimatedVertices", &Dtool_GeomVertexData_clear_animated_vertices_634, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_animated_vertices_634_comment},
  {"transform_vertices", (PyCFunction) &Dtool_GeomVertexData_transform_vertices_635, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_transform_vertices_635_comment},
  {"transformVertices", (PyCFunction) &Dtool_GeomVertexData_transform_vertices_635, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_transform_vertices_635_comment},
  {"replace_column", (PyCFunction) &Dtool_GeomVertexData_replace_column_636, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_replace_column_636_comment},
  {"replaceColumn", (PyCFunction) &Dtool_GeomVertexData_replace_column_636, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_replace_column_636_comment},
  {"output", &Dtool_GeomVertexData_output_637, METH_O, (const char *)Dtool_GeomVertexData_output_637_comment},
  {"write", (PyCFunction) &Dtool_GeomVertexData_write_638, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_write_638_comment},
  {"describe_vertex", (PyCFunction) &Dtool_GeomVertexData_describe_vertex_639, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_describe_vertex_639_comment},
  {"describeVertex", (PyCFunction) &Dtool_GeomVertexData_describe_vertex_639, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexData_describe_vertex_639_comment},
  {"clear_cache", &Dtool_GeomVertexData_clear_cache_640, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_cache_640_comment},
  {"clearCache", &Dtool_GeomVertexData_clear_cache_640, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_cache_640_comment},
  {"clear_cache_stage", &Dtool_GeomVertexData_clear_cache_stage_641, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_cache_stage_641_comment},
  {"clearCacheStage", &Dtool_GeomVertexData_clear_cache_stage_641, METH_NOARGS, (const char *)Dtool_GeomVertexData_clear_cache_stage_641_comment},
  {"get_class_type", &Dtool_GeomVertexData_get_class_type_642, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexData_get_class_type_642_comment},
  {"getClassType", &Dtool_GeomVertexData_get_class_type_642, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomVertexData_get_class_type_642_comment},
  {"upcast_to_CopyOnWriteObject", &Dtool_GeomVertexData_upcast_to_CopyOnWriteObject_568, METH_NOARGS, (const char *)Dtool_GeomVertexData_upcast_to_CopyOnWriteObject_568_comment},
  {"upcastToCopyOnWriteObject", &Dtool_GeomVertexData_upcast_to_CopyOnWriteObject_568, METH_NOARGS, (const char *)Dtool_GeomVertexData_upcast_to_CopyOnWriteObject_568_comment},
  {"upcast_to_GeomEnums", &Dtool_GeomVertexData_upcast_to_GeomEnums_570, METH_NOARGS, (const char *)Dtool_GeomVertexData_upcast_to_GeomEnums_570_comment},
  {"upcastToGeomEnums", &Dtool_GeomVertexData_upcast_to_GeomEnums_570, METH_NOARGS, (const char *)Dtool_GeomVertexData_upcast_to_GeomEnums_570_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_arrays", (PyCFunction) &MakeSeq_GeomVertexData_get_arrays, METH_NOARGS, nullptr},
  { "getArrays", (PyCFunction) &MakeSeq_GeomVertexData_get_arrays, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// GeomVertexData slot tp_compare -> compare_to
//////////////////
static int Dtool_GeomVertexData_compare_to_578_tp_compare(PyObject *self, PyObject *arg) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return -1;
  }

  // 1-int GeomVertexData::compare_to(GeomVertexData const &other) const
  GeomVertexData const *arg_this = (GeomVertexData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeomVertexData, 1, "GeomVertexData.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const GeomVertexData*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(GeomVertexData self, const GeomVertexData other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     GeomVertexData
//////////////////
static PyObject *Dtool_Repr_GeomVertexData(PyObject *self) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     GeomVertexData
//////////////////
static PyObject *Dtool_Str_GeomVertexData(PyObject *self) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     GeomVertexData
//////////////////
static PyObject *Dtool_RichCompare_GeomVertexData(PyObject *self, PyObject *arg, int op) {
  GeomVertexData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexData, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_GeomVertexData_compare_to_578_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_GeomVertexData[] = {
  {(char *)"name", &Dtool_GeomVertexData_name_Getter, &Dtool_GeomVertexData_name_Setter, nullptr, nullptr},
  {(char *)"usage_hint", &Dtool_GeomVertexData_usage_hint_Getter, &Dtool_GeomVertexData_usage_hint_Setter, nullptr, nullptr},
  {(char *)"format", &Dtool_GeomVertexData_format_Getter, &Dtool_GeomVertexData_format_Setter, nullptr, nullptr},
  {(char *)"arrays", &Dtool_GeomVertexData_arrays_Getter, nullptr, nullptr, nullptr},
  {(char *)"transform_table", &Dtool_GeomVertexData_transform_table_Getter, &Dtool_GeomVertexData_transform_table_Setter, nullptr, nullptr},
  {(char *)"slider_table", &Dtool_GeomVertexData_slider_table_Getter, &Dtool_GeomVertexData_slider_table_Setter, nullptr, nullptr},
  {(char *)"num_bytes", &Dtool_GeomVertexData_num_bytes_Getter, nullptr, nullptr, nullptr},
  {(char *)"modified", &Dtool_GeomVertexData_modified_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GeomVertexData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomVertexData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomVertexData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomVertexData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomVertexData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomVertexData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomVertexData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomVertexData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomVertexData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_GeomVertexData_compare_to_578_tp_compare,
#endif
    &Dtool_Repr_GeomVertexData,
    &Dtool_NumberMethods_GeomVertexData,
    &Dtool_SequenceMethods_GeomVertexData,
    &Dtool_MappingMethods_GeomVertexData,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_GeomVertexData,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomVertexData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines the actual numeric vertex data stored in a Geom, in the\n"
    " * structure defined by a particular GeomVertexFormat object.\n"
    " *\n"
    " * The data consists of one or more arrays, each of which in turn consists of\n"
    " * a series of rows, one per vertex.  All arrays should have the same number\n"
    " * of rows; each vertex is defined by the column data from a particular row\n"
    " * across all arrays.\n"
    " *\n"
    " * Often, there will be only one array per Geom, and the various columns\n"
    " * defined in the GeomVertexFormat will be interleaved within that array.\n"
    " * However, it is also possible to have multiple different arrays, with a\n"
    " * certain subset of the total columns defined in each array.\n"
    " *\n"
    " * However the data is distributed, the effect is of a single table of\n"
    " * vertices, where each vertex is represented by one row of the table.\n"
    " *\n"
    " * In general, application code should not attempt to directly manipulate the\n"
    " * vertex data through this structure; instead, use the GeomVertexReader,\n"
    " * GeomVertexWriter, and GeomVertexRewriter objects to read and write vertex\n"
    " * data at a high level.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_GeomVertexData,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomVertexData,
    nullptr, // tp_members
    Dtool_Properties_GeomVertexData,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomVertexData,
    PyType_GenericAlloc,
    Dtool_new_GeomVertexData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomVertexData,
  Dtool_UpcastInterface_GeomVertexData,
  Dtool_DowncastInterface_GeomVertexData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomVertexData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CopyOnWriteObject != nullptr);
    assert(Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_GeomVertexData._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_CopyOnWriteObject, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_GeomVertexData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomVertexData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomVertexData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomVertexData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomVertexData);
  }
}

/**
 * Python method tables for AnimateVerticesRequest (AnimateVerticesRequest)
 */
static PyMethodDef Dtool_Methods_AnimateVerticesRequest[] = {
  {"is_ready", &Dtool_AnimateVerticesRequest_is_ready_646, METH_NOARGS, (const char *)Dtool_AnimateVerticesRequest_is_ready_646_comment},
  {"isReady", &Dtool_AnimateVerticesRequest_is_ready_646, METH_NOARGS, (const char *)Dtool_AnimateVerticesRequest_is_ready_646_comment},
  {"get_class_type", &Dtool_AnimateVerticesRequest_get_class_type_647, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimateVerticesRequest_get_class_type_647_comment},
  {"getClassType", &Dtool_AnimateVerticesRequest_get_class_type_647, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimateVerticesRequest_get_class_type_647_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AnimateVerticesRequest = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimateVerticesRequest = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimateVerticesRequest = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimateVerticesRequest = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimateVerticesRequest = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimateVerticesRequest = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimateVerticesRequest",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimateVerticesRequest,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimateVerticesRequest,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AnimateVerticesRequest,
    &Dtool_SequenceMethods_AnimateVerticesRequest,
    &Dtool_MappingMethods_AnimateVerticesRequest,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimateVerticesRequest,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class object manages a single asynchronous request to animate vertices\n"
    " * on a GeomVertexData object.  animate_vertices will be called with\n"
    " * force=true (i.e.  blocking) in a sub-thread (if threading is available).\n"
    " * No result is stored or returned from this object.  It is expected that the\n"
    " * result will be cached and available for immediate use later during\n"
    " * rendering.  Thus it is important that the main thread block while these\n"
    " * requests are being run (presumably on multiple CPUs/cores), to ensure that\n"
    " * the data has been computed by the time it's needed.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimateVerticesRequest,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimateVerticesRequest,
    PyType_GenericAlloc,
    Dtool_new_AnimateVerticesRequest,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimateVerticesRequest,
  Dtool_UpcastInterface_AnimateVerticesRequest,
  Dtool_DowncastInterface_AnimateVerticesRequest,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimateVerticesRequest(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_AsyncTask != nullptr);
    assert(Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit(nullptr);
    Dtool_AnimateVerticesRequest._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_AsyncTask);
    Dtool_AnimateVerticesRequest._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimateVerticesRequest._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimateVerticesRequest) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimateVerticesRequest)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimateVerticesRequest);
  }
}

/**
 * Python method tables for SavedContext (SavedContext)
 */
static PyMethodDef Dtool_Methods_SavedContext[] = {
  {"get_class_type", &Dtool_SavedContext_get_class_type_651, METH_NOARGS | METH_STATIC, (const char *)Dtool_SavedContext_get_class_type_651_comment},
  {"getClassType", &Dtool_SavedContext_get_class_type_651, METH_NOARGS | METH_STATIC, (const char *)Dtool_SavedContext_get_class_type_651_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_SavedContext = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SavedContext = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SavedContext = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SavedContext = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SavedContext = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SavedContext = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SavedContext",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SavedContext,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SavedContext,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SavedContext,
    &Dtool_SequenceMethods_SavedContext,
    &Dtool_MappingMethods_SavedContext,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SavedContext,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for all GSG-specific context objects, such as\n"
    " * TextureContext and GeomContext.  It exists mainly to provide some\n"
    " * structural organization.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SavedContext,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SavedContext,
    PyType_GenericAlloc,
    Dtool_new_SavedContext,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SavedContext,
  Dtool_UpcastInterface_SavedContext,
  Dtool_DowncastInterface_SavedContext,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SavedContext(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_SavedContext._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_SavedContext._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SavedContext._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SavedContext) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SavedContext)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SavedContext);
  }
}

/**
 * Python method tables for BufferContext (BufferContext)
 */
static PyMethodDef Dtool_Methods_BufferContext[] = {
  {"get_data_size_bytes", &Dtool_BufferContext_get_data_size_bytes_657, METH_NOARGS, (const char *)Dtool_BufferContext_get_data_size_bytes_657_comment},
  {"getDataSizeBytes", &Dtool_BufferContext_get_data_size_bytes_657, METH_NOARGS, (const char *)Dtool_BufferContext_get_data_size_bytes_657_comment},
  {"get_modified", &Dtool_BufferContext_get_modified_658, METH_NOARGS, (const char *)Dtool_BufferContext_get_modified_658_comment},
  {"getModified", &Dtool_BufferContext_get_modified_658, METH_NOARGS, (const char *)Dtool_BufferContext_get_modified_658_comment},
  {"get_active", &Dtool_BufferContext_get_active_659, METH_NOARGS, (const char *)Dtool_BufferContext_get_active_659_comment},
  {"getActive", &Dtool_BufferContext_get_active_659, METH_NOARGS, (const char *)Dtool_BufferContext_get_active_659_comment},
  {"get_resident", &Dtool_BufferContext_get_resident_660, METH_NOARGS, (const char *)Dtool_BufferContext_get_resident_660_comment},
  {"getResident", &Dtool_BufferContext_get_resident_660, METH_NOARGS, (const char *)Dtool_BufferContext_get_resident_660_comment},
  {"get_class_type", &Dtool_BufferContext_get_class_type_668, METH_NOARGS | METH_STATIC, (const char *)Dtool_BufferContext_get_class_type_668_comment},
  {"getClassType", &Dtool_BufferContext_get_class_type_668, METH_NOARGS | METH_STATIC, (const char *)Dtool_BufferContext_get_class_type_668_comment},
  {"upcast_to_SavedContext", &Dtool_BufferContext_upcast_to_SavedContext_654, METH_NOARGS, (const char *)Dtool_BufferContext_upcast_to_SavedContext_654_comment},
  {"upcastToSavedContext", &Dtool_BufferContext_upcast_to_SavedContext_654, METH_NOARGS, (const char *)Dtool_BufferContext_upcast_to_SavedContext_654_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_BufferContext[] = {
  {(char *)"object", &Dtool_BufferContext_object_Getter, nullptr, nullptr, nullptr},
  {(char *)"data_size_bytes", &Dtool_BufferContext_data_size_bytes_Getter, nullptr, nullptr, nullptr},
  {(char *)"modified", &Dtool_BufferContext_modified_Getter, nullptr, nullptr, nullptr},
  {(char *)"active", &Dtool_BufferContext_active_Getter, nullptr, nullptr, nullptr},
  {(char *)"resident", &Dtool_BufferContext_resident_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_BufferContext = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BufferContext = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BufferContext = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BufferContext = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BufferContext = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BufferContext = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BufferContext",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BufferContext,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BufferContext,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BufferContext,
    &Dtool_SequenceMethods_BufferContext,
    &Dtool_MappingMethods_BufferContext,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BufferContext,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a base class for those kinds of SavedContexts that occupy an\n"
    " * easily-measured (and substantial) number of bytes in the video card's frame\n"
    " * buffer memory or AGP memory.  At the present, this includes most of the\n"
    " * SavedContext types: VertexBufferContext and IndexBufferContext, as well as\n"
    " * TextureContext.\n"
    " *\n"
    " * This class provides methods for tracking the video memory utilization, as\n"
    " * well as residency of each object, via PStats.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BufferContext,
    nullptr, // tp_members
    Dtool_Properties_BufferContext,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BufferContext,
    PyType_GenericAlloc,
    Dtool_new_BufferContext,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BufferContext,
  Dtool_UpcastInterface_BufferContext,
  Dtool_DowncastInterface_BufferContext,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BufferContext(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_SavedContext(nullptr);
    Dtool_BufferContext._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_SavedContext);
    Dtool_BufferContext._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BufferContext._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BufferContext) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BufferContext)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BufferContext);
  }
}

/**
 * Python method tables for GeomPrimitive (GeomPrimitive)
 */
static PyMethodDef Dtool_Methods_GeomPrimitive[] = {
  {"assign", &Dtool_GeomPrimitive_operator_674, METH_O, (const char *)Dtool_GeomPrimitive_operator_674_comment},
  {"make_copy", &Dtool_GeomPrimitive_make_copy_679, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_copy_679_comment},
  {"makeCopy", &Dtool_GeomPrimitive_make_copy_679, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_copy_679_comment},
  {"get_primitive_type", &Dtool_GeomPrimitive_get_primitive_type_680, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_primitive_type_680_comment},
  {"getPrimitiveType", &Dtool_GeomPrimitive_get_primitive_type_680, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_primitive_type_680_comment},
  {"get_geom_rendering", &Dtool_GeomPrimitive_get_geom_rendering_681, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_geom_rendering_681_comment},
  {"getGeomRendering", &Dtool_GeomPrimitive_get_geom_rendering_681, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_geom_rendering_681_comment},
  {"get_shade_model", &Dtool_GeomPrimitive_get_shade_model_684, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_shade_model_684_comment},
  {"getShadeModel", &Dtool_GeomPrimitive_get_shade_model_684, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_shade_model_684_comment},
  {"set_shade_model", &Dtool_GeomPrimitive_set_shade_model_685, METH_O, (const char *)Dtool_GeomPrimitive_set_shade_model_685_comment},
  {"setShadeModel", &Dtool_GeomPrimitive_set_shade_model_685, METH_O, (const char *)Dtool_GeomPrimitive_set_shade_model_685_comment},
  {"get_usage_hint", &Dtool_GeomPrimitive_get_usage_hint_687, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_usage_hint_687_comment},
  {"getUsageHint", &Dtool_GeomPrimitive_get_usage_hint_687, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_usage_hint_687_comment},
  {"set_usage_hint", &Dtool_GeomPrimitive_set_usage_hint_688, METH_O, (const char *)Dtool_GeomPrimitive_set_usage_hint_688_comment},
  {"setUsageHint", &Dtool_GeomPrimitive_set_usage_hint_688, METH_O, (const char *)Dtool_GeomPrimitive_set_usage_hint_688_comment},
  {"get_index_type", &Dtool_GeomPrimitive_get_index_type_690, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_index_type_690_comment},
  {"getIndexType", &Dtool_GeomPrimitive_get_index_type_690, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_index_type_690_comment},
  {"set_index_type", &Dtool_GeomPrimitive_set_index_type_691, METH_O, (const char *)Dtool_GeomPrimitive_set_index_type_691_comment},
  {"setIndexType", &Dtool_GeomPrimitive_set_index_type_691, METH_O, (const char *)Dtool_GeomPrimitive_set_index_type_691_comment},
  {"is_composite", &Dtool_GeomPrimitive_is_composite_693, METH_NOARGS, (const char *)Dtool_GeomPrimitive_is_composite_693_comment},
  {"isComposite", &Dtool_GeomPrimitive_is_composite_693, METH_NOARGS, (const char *)Dtool_GeomPrimitive_is_composite_693_comment},
  {"is_indexed", &Dtool_GeomPrimitive_is_indexed_694, METH_NOARGS, (const char *)Dtool_GeomPrimitive_is_indexed_694_comment},
  {"isIndexed", &Dtool_GeomPrimitive_is_indexed_694, METH_NOARGS, (const char *)Dtool_GeomPrimitive_is_indexed_694_comment},
  {"get_first_vertex", &Dtool_GeomPrimitive_get_first_vertex_695, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_first_vertex_695_comment},
  {"getFirstVertex", &Dtool_GeomPrimitive_get_first_vertex_695, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_first_vertex_695_comment},
  {"get_num_vertices", &Dtool_GeomPrimitive_get_num_vertices_696, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_vertices_696_comment},
  {"getNumVertices", &Dtool_GeomPrimitive_get_num_vertices_696, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_vertices_696_comment},
  {"get_vertex", &Dtool_GeomPrimitive_get_vertex_697, METH_O, (const char *)Dtool_GeomPrimitive_get_vertex_697_comment},
  {"getVertex", &Dtool_GeomPrimitive_get_vertex_697, METH_O, (const char *)Dtool_GeomPrimitive_get_vertex_697_comment},
  {"add_vertex", &Dtool_GeomPrimitive_add_vertex_699, METH_O, (const char *)Dtool_GeomPrimitive_add_vertex_699_comment},
  {"addVertex", &Dtool_GeomPrimitive_add_vertex_699, METH_O, (const char *)Dtool_GeomPrimitive_add_vertex_699_comment},
  {"add_vertices", (PyCFunction) &Dtool_GeomPrimitive_add_vertices_700, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_add_vertices_700_comment},
  {"addVertices", (PyCFunction) &Dtool_GeomPrimitive_add_vertices_700, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_add_vertices_700_comment},
  {"add_consecutive_vertices", (PyCFunction) &Dtool_GeomPrimitive_add_consecutive_vertices_701, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_add_consecutive_vertices_701_comment},
  {"addConsecutiveVertices", (PyCFunction) &Dtool_GeomPrimitive_add_consecutive_vertices_701, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_add_consecutive_vertices_701_comment},
  {"add_next_vertices", &Dtool_GeomPrimitive_add_next_vertices_702, METH_O, (const char *)Dtool_GeomPrimitive_add_next_vertices_702_comment},
  {"addNextVertices", &Dtool_GeomPrimitive_add_next_vertices_702, METH_O, (const char *)Dtool_GeomPrimitive_add_next_vertices_702_comment},
  {"reserve_num_vertices", &Dtool_GeomPrimitive_reserve_num_vertices_703, METH_O, (const char *)Dtool_GeomPrimitive_reserve_num_vertices_703_comment},
  {"reserveNumVertices", &Dtool_GeomPrimitive_reserve_num_vertices_703, METH_O, (const char *)Dtool_GeomPrimitive_reserve_num_vertices_703_comment},
  {"close_primitive", &Dtool_GeomPrimitive_close_primitive_704, METH_NOARGS, (const char *)Dtool_GeomPrimitive_close_primitive_704_comment},
  {"closePrimitive", &Dtool_GeomPrimitive_close_primitive_704, METH_NOARGS, (const char *)Dtool_GeomPrimitive_close_primitive_704_comment},
  {"clear_vertices", &Dtool_GeomPrimitive_clear_vertices_705, METH_NOARGS, (const char *)Dtool_GeomPrimitive_clear_vertices_705_comment},
  {"clearVertices", &Dtool_GeomPrimitive_clear_vertices_705, METH_NOARGS, (const char *)Dtool_GeomPrimitive_clear_vertices_705_comment},
  {"offset_vertices", (PyCFunction) &Dtool_GeomPrimitive_offset_vertices_706, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_offset_vertices_706_comment},
  {"offsetVertices", (PyCFunction) &Dtool_GeomPrimitive_offset_vertices_706, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_offset_vertices_706_comment},
  {"make_nonindexed", (PyCFunction) &Dtool_GeomPrimitive_make_nonindexed_707, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_make_nonindexed_707_comment},
  {"makeNonindexed", (PyCFunction) &Dtool_GeomPrimitive_make_nonindexed_707, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_make_nonindexed_707_comment},
  {"pack_vertices", (PyCFunction) &Dtool_GeomPrimitive_pack_vertices_708, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_pack_vertices_708_comment},
  {"packVertices", (PyCFunction) &Dtool_GeomPrimitive_pack_vertices_708, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_pack_vertices_708_comment},
  {"make_indexed", &Dtool_GeomPrimitive_make_indexed_709, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_indexed_709_comment},
  {"makeIndexed", &Dtool_GeomPrimitive_make_indexed_709, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_indexed_709_comment},
  {"get_num_primitives", &Dtool_GeomPrimitive_get_num_primitives_710, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_primitives_710_comment},
  {"getNumPrimitives", &Dtool_GeomPrimitive_get_num_primitives_710, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_primitives_710_comment},
  {"get_primitive_start", &Dtool_GeomPrimitive_get_primitive_start_711, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_start_711_comment},
  {"getPrimitiveStart", &Dtool_GeomPrimitive_get_primitive_start_711, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_start_711_comment},
  {"get_primitive_end", &Dtool_GeomPrimitive_get_primitive_end_712, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_end_712_comment},
  {"getPrimitiveEnd", &Dtool_GeomPrimitive_get_primitive_end_712, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_end_712_comment},
  {"get_primitive_num_vertices", &Dtool_GeomPrimitive_get_primitive_num_vertices_713, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_num_vertices_713_comment},
  {"getPrimitiveNumVertices", &Dtool_GeomPrimitive_get_primitive_num_vertices_713, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_num_vertices_713_comment},
  {"get_num_used_vertices", &Dtool_GeomPrimitive_get_num_used_vertices_714, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_used_vertices_714_comment},
  {"getNumUsedVertices", &Dtool_GeomPrimitive_get_num_used_vertices_714, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_used_vertices_714_comment},
  {"get_num_faces", &Dtool_GeomPrimitive_get_num_faces_715, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_faces_715_comment},
  {"getNumFaces", &Dtool_GeomPrimitive_get_num_faces_715, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_faces_715_comment},
  {"get_primitive_num_faces", &Dtool_GeomPrimitive_get_primitive_num_faces_716, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_num_faces_716_comment},
  {"getPrimitiveNumFaces", &Dtool_GeomPrimitive_get_primitive_num_faces_716, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_num_faces_716_comment},
  {"get_min_vertex", &Dtool_GeomPrimitive_get_min_vertex_717, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_min_vertex_717_comment},
  {"getMinVertex", &Dtool_GeomPrimitive_get_min_vertex_717, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_min_vertex_717_comment},
  {"get_primitive_min_vertex", &Dtool_GeomPrimitive_get_primitive_min_vertex_718, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_min_vertex_718_comment},
  {"getPrimitiveMinVertex", &Dtool_GeomPrimitive_get_primitive_min_vertex_718, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_min_vertex_718_comment},
  {"get_max_vertex", &Dtool_GeomPrimitive_get_max_vertex_719, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_max_vertex_719_comment},
  {"getMaxVertex", &Dtool_GeomPrimitive_get_max_vertex_719, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_max_vertex_719_comment},
  {"get_primitive_max_vertex", &Dtool_GeomPrimitive_get_primitive_max_vertex_720, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_max_vertex_720_comment},
  {"getPrimitiveMaxVertex", &Dtool_GeomPrimitive_get_primitive_max_vertex_720, METH_O, (const char *)Dtool_GeomPrimitive_get_primitive_max_vertex_720_comment},
  {"decompose", &Dtool_GeomPrimitive_decompose_721, METH_NOARGS, (const char *)Dtool_GeomPrimitive_decompose_721_comment},
  {"rotate", &Dtool_GeomPrimitive_rotate_722, METH_NOARGS, (const char *)Dtool_GeomPrimitive_rotate_722_comment},
  {"doubleside", &Dtool_GeomPrimitive_doubleside_723, METH_NOARGS, (const char *)Dtool_GeomPrimitive_doubleside_723_comment},
  {"reverse", &Dtool_GeomPrimitive_reverse_724, METH_NOARGS, (const char *)Dtool_GeomPrimitive_reverse_724_comment},
  {"match_shade_model", &Dtool_GeomPrimitive_match_shade_model_725, METH_O, (const char *)Dtool_GeomPrimitive_match_shade_model_725_comment},
  {"matchShadeModel", &Dtool_GeomPrimitive_match_shade_model_725, METH_O, (const char *)Dtool_GeomPrimitive_match_shade_model_725_comment},
  {"make_points", &Dtool_GeomPrimitive_make_points_726, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_points_726_comment},
  {"makePoints", &Dtool_GeomPrimitive_make_points_726, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_points_726_comment},
  {"make_lines", &Dtool_GeomPrimitive_make_lines_727, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_lines_727_comment},
  {"makeLines", &Dtool_GeomPrimitive_make_lines_727, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_lines_727_comment},
  {"make_patches", &Dtool_GeomPrimitive_make_patches_728, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_patches_728_comment},
  {"makePatches", &Dtool_GeomPrimitive_make_patches_728, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_patches_728_comment},
  {"make_adjacency", &Dtool_GeomPrimitive_make_adjacency_729, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_adjacency_729_comment},
  {"makeAdjacency", &Dtool_GeomPrimitive_make_adjacency_729, METH_NOARGS, (const char *)Dtool_GeomPrimitive_make_adjacency_729_comment},
  {"get_num_bytes", &Dtool_GeomPrimitive_get_num_bytes_730, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_bytes_730_comment},
  {"getNumBytes", &Dtool_GeomPrimitive_get_num_bytes_730, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_bytes_730_comment},
  {"get_data_size_bytes", &Dtool_GeomPrimitive_get_data_size_bytes_731, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_data_size_bytes_731_comment},
  {"getDataSizeBytes", &Dtool_GeomPrimitive_get_data_size_bytes_731, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_data_size_bytes_731_comment},
  {"get_modified", &Dtool_GeomPrimitive_get_modified_732, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_modified_732_comment},
  {"getModified", &Dtool_GeomPrimitive_get_modified_732, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_modified_732_comment},
  {"request_resident", (PyCFunction) &Dtool_GeomPrimitive_request_resident_736, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_request_resident_736_comment},
  {"requestResident", (PyCFunction) &Dtool_GeomPrimitive_request_resident_736, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_request_resident_736_comment},
  {"check_valid", &Dtool_GeomPrimitive_check_valid_737, METH_O, (const char *)Dtool_GeomPrimitive_check_valid_737_comment},
  {"checkValid", &Dtool_GeomPrimitive_check_valid_737, METH_O, (const char *)Dtool_GeomPrimitive_check_valid_737_comment},
  {"output", &Dtool_GeomPrimitive_output_738, METH_O, (const char *)Dtool_GeomPrimitive_output_738_comment},
  {"write", (PyCFunction) &Dtool_GeomPrimitive_write_739, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_write_739_comment},
  {"get_vertices", &Dtool_GeomPrimitive_get_vertices_740, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_vertices_740_comment},
  {"getVertices", &Dtool_GeomPrimitive_get_vertices_740, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_vertices_740_comment},
  {"get_vertices_handle", &Dtool_GeomPrimitive_get_vertices_handle_741, METH_O, (const char *)Dtool_GeomPrimitive_get_vertices_handle_741_comment},
  {"getVerticesHandle", &Dtool_GeomPrimitive_get_vertices_handle_741, METH_O, (const char *)Dtool_GeomPrimitive_get_vertices_handle_741_comment},
  {"modify_vertices", (PyCFunction) &Dtool_GeomPrimitive_modify_vertices_742, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_modify_vertices_742_comment},
  {"modifyVertices", (PyCFunction) &Dtool_GeomPrimitive_modify_vertices_742, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_modify_vertices_742_comment},
  {"modify_vertices_handle", &Dtool_GeomPrimitive_modify_vertices_handle_743, METH_O, (const char *)Dtool_GeomPrimitive_modify_vertices_handle_743_comment},
  {"modifyVerticesHandle", &Dtool_GeomPrimitive_modify_vertices_handle_743, METH_O, (const char *)Dtool_GeomPrimitive_modify_vertices_handle_743_comment},
  {"set_vertices", (PyCFunction) &Dtool_GeomPrimitive_set_vertices_744, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_set_vertices_744_comment},
  {"setVertices", (PyCFunction) &Dtool_GeomPrimitive_set_vertices_744, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_set_vertices_744_comment},
  {"set_nonindexed_vertices", (PyCFunction) &Dtool_GeomPrimitive_set_nonindexed_vertices_745, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_set_nonindexed_vertices_745_comment},
  {"setNonindexedVertices", (PyCFunction) &Dtool_GeomPrimitive_set_nonindexed_vertices_745, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_set_nonindexed_vertices_745_comment},
  {"get_index_stride", &Dtool_GeomPrimitive_get_index_stride_746, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_index_stride_746_comment},
  {"getIndexStride", &Dtool_GeomPrimitive_get_index_stride_746, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_index_stride_746_comment},
  {"get_strip_cut_index", &Dtool_GeomPrimitive_get_strip_cut_index_747, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_strip_cut_index_747_comment},
  {"getStripCutIndex", &Dtool_GeomPrimitive_get_strip_cut_index_747, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_strip_cut_index_747_comment},
  {"get_ends", &Dtool_GeomPrimitive_get_ends_750, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_ends_750_comment},
  {"getEnds", &Dtool_GeomPrimitive_get_ends_750, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_ends_750_comment},
  {"modify_ends", &Dtool_GeomPrimitive_modify_ends_751, METH_NOARGS, (const char *)Dtool_GeomPrimitive_modify_ends_751_comment},
  {"modifyEnds", &Dtool_GeomPrimitive_modify_ends_751, METH_NOARGS, (const char *)Dtool_GeomPrimitive_modify_ends_751_comment},
  {"set_ends", &Dtool_GeomPrimitive_set_ends_752, METH_O, (const char *)Dtool_GeomPrimitive_set_ends_752_comment},
  {"setEnds", &Dtool_GeomPrimitive_set_ends_752, METH_O, (const char *)Dtool_GeomPrimitive_set_ends_752_comment},
  {"get_mins", &Dtool_GeomPrimitive_get_mins_753, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_mins_753_comment},
  {"getMins", &Dtool_GeomPrimitive_get_mins_753, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_mins_753_comment},
  {"get_maxs", &Dtool_GeomPrimitive_get_maxs_754, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_maxs_754_comment},
  {"getMaxs", &Dtool_GeomPrimitive_get_maxs_754, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_maxs_754_comment},
  {"set_minmax", (PyCFunction) &Dtool_GeomPrimitive_set_minmax_757, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_set_minmax_757_comment},
  {"setMinmax", (PyCFunction) &Dtool_GeomPrimitive_set_minmax_757, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomPrimitive_set_minmax_757_comment},
  {"clear_minmax", &Dtool_GeomPrimitive_clear_minmax_758, METH_NOARGS, (const char *)Dtool_GeomPrimitive_clear_minmax_758_comment},
  {"clearMinmax", &Dtool_GeomPrimitive_clear_minmax_758, METH_NOARGS, (const char *)Dtool_GeomPrimitive_clear_minmax_758_comment},
  {"get_num_vertices_per_primitive", &Dtool_GeomPrimitive_get_num_vertices_per_primitive_759, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_vertices_per_primitive_759_comment},
  {"getNumVerticesPerPrimitive", &Dtool_GeomPrimitive_get_num_vertices_per_primitive_759, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_vertices_per_primitive_759_comment},
  {"get_min_num_vertices_per_primitive", &Dtool_GeomPrimitive_get_min_num_vertices_per_primitive_760, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_min_num_vertices_per_primitive_760_comment},
  {"getMinNumVerticesPerPrimitive", &Dtool_GeomPrimitive_get_min_num_vertices_per_primitive_760, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_min_num_vertices_per_primitive_760_comment},
  {"get_num_unused_vertices_per_primitive", &Dtool_GeomPrimitive_get_num_unused_vertices_per_primitive_761, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_unused_vertices_per_primitive_761_comment},
  {"getNumUnusedVerticesPerPrimitive", &Dtool_GeomPrimitive_get_num_unused_vertices_per_primitive_761, METH_NOARGS, (const char *)Dtool_GeomPrimitive_get_num_unused_vertices_per_primitive_761_comment},
  {"get_class_type", &Dtool_GeomPrimitive_get_class_type_765, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomPrimitive_get_class_type_765_comment},
  {"getClassType", &Dtool_GeomPrimitive_get_class_type_765, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomPrimitive_get_class_type_765_comment},
  {"upcast_to_CopyOnWriteObject", &Dtool_GeomPrimitive_upcast_to_CopyOnWriteObject_670, METH_NOARGS, (const char *)Dtool_GeomPrimitive_upcast_to_CopyOnWriteObject_670_comment},
  {"upcastToCopyOnWriteObject", &Dtool_GeomPrimitive_upcast_to_CopyOnWriteObject_670, METH_NOARGS, (const char *)Dtool_GeomPrimitive_upcast_to_CopyOnWriteObject_670_comment},
  {"upcast_to_GeomEnums", &Dtool_GeomPrimitive_upcast_to_GeomEnums_672, METH_NOARGS, (const char *)Dtool_GeomPrimitive_upcast_to_GeomEnums_672_comment},
  {"upcastToGeomEnums", &Dtool_GeomPrimitive_upcast_to_GeomEnums_672, METH_NOARGS, (const char *)Dtool_GeomPrimitive_upcast_to_GeomEnums_672_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_vertex_list", (PyCFunction) &MakeSeq_GeomPrimitive_get_vertex_list, METH_NOARGS, nullptr},
  { "getVertexList", (PyCFunction) &MakeSeq_GeomPrimitive_get_vertex_list, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     GeomPrimitive
//////////////////
static PyObject *Dtool_Repr_GeomPrimitive(PyObject *self) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     GeomPrimitive
//////////////////
static PyObject *Dtool_Str_GeomPrimitive(PyObject *self) {
  GeomPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_GeomPrimitive[] = {
  {(char *)"primitive_type", &Dtool_GeomPrimitive_primitive_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"geom_rendering", &Dtool_GeomPrimitive_geom_rendering_Getter, nullptr, nullptr, nullptr},
  {(char *)"shade_model", &Dtool_GeomPrimitive_shade_model_Getter, nullptr, nullptr, nullptr},
  {(char *)"usage_hint", &Dtool_GeomPrimitive_usage_hint_Getter, nullptr, nullptr, nullptr},
  {(char *)"index_type", &Dtool_GeomPrimitive_index_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_bytes", &Dtool_GeomPrimitive_num_bytes_Getter, nullptr, nullptr, nullptr},
  {(char *)"data_size_bytes", &Dtool_GeomPrimitive_data_size_bytes_Getter, nullptr, nullptr, nullptr},
  {(char *)"modified", &Dtool_GeomPrimitive_modified_Getter, nullptr, nullptr, nullptr},
  {(char *)"index_stride", &Dtool_GeomPrimitive_index_stride_Getter, nullptr, nullptr, nullptr},
  {(char *)"strip_cut_index", &Dtool_GeomPrimitive_strip_cut_index_Getter, nullptr, nullptr, nullptr},
  {(char *)"mins", &Dtool_GeomPrimitive_mins_Getter, nullptr, nullptr, nullptr},
  {(char *)"maxs", &Dtool_GeomPrimitive_maxs_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_vertices_per_primitive", &Dtool_GeomPrimitive_num_vertices_per_primitive_Getter, nullptr, nullptr, nullptr},
  {(char *)"min_num_vertices_per_primitive", &Dtool_GeomPrimitive_min_num_vertices_per_primitive_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_unused_vertices_per_primitive", &Dtool_GeomPrimitive_num_unused_vertices_per_primitive_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GeomPrimitive = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomPrimitive = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomPrimitive = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomPrimitive = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomPrimitive = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomPrimitive = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomPrimitive",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomPrimitive,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomPrimitive,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_GeomPrimitive,
    &Dtool_NumberMethods_GeomPrimitive,
    &Dtool_SequenceMethods_GeomPrimitive,
    &Dtool_MappingMethods_GeomPrimitive,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_GeomPrimitive,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomPrimitive,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an abstract base class for a family of classes that represent the\n"
    " * fundamental geometry primitives that may be stored in a Geom.\n"
    " *\n"
    " * They all have in common the fact that they are defined by tables of vertex\n"
    " * data stored in a GeomVertexData object.  Each GeomPrimitive object contains\n"
    " * an ordered list of integers, which index into the vertex array defined by\n"
    " * the GeomVertexData and define the particular vertices of the GeomVertexData\n"
    " * that are used for this primitive.\n"
    " *\n"
    " * The meaning of a given arrangement of vertices is defined by each\n"
    " * individual primitive type; for instance, a GeomTriangle renders a triangle\n"
    " * from each three consecutive vertices, while a GeomTriangleStrip renders a\n"
    " * strip of (n - 2) connected triangles from each sequence of n vertices.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomPrimitive,
    nullptr, // tp_members
    Dtool_Properties_GeomPrimitive,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomPrimitive,
    PyType_GenericAlloc,
    Dtool_new_GeomPrimitive,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomPrimitive,
  Dtool_UpcastInterface_GeomPrimitive,
  Dtool_DowncastInterface_GeomPrimitive,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomPrimitive(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CopyOnWriteObject != nullptr);
    assert(Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_GeomPrimitive._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_CopyOnWriteObject, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_GeomPrimitive._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomPrimitive._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomPrimitive) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomPrimitive)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomPrimitive);
  }
}

/**
 * Python method tables for TextureStage (TextureStage)
 */
static PyMethodDef Dtool_Methods_TextureStage[] = {
  {"assign", &Dtool_TextureStage_operator_768, METH_O, (const char *)Dtool_TextureStage_operator_768_comment},
  {"set_name", &Dtool_TextureStage_set_name_773, METH_O, (const char *)Dtool_TextureStage_set_name_773_comment},
  {"setName", &Dtool_TextureStage_set_name_773, METH_O, (const char *)Dtool_TextureStage_set_name_773_comment},
  {"get_name", &Dtool_TextureStage_get_name_774, METH_NOARGS, (const char *)Dtool_TextureStage_get_name_774_comment},
  {"getName", &Dtool_TextureStage_get_name_774, METH_NOARGS, (const char *)Dtool_TextureStage_get_name_774_comment},
  {"set_sort", &Dtool_TextureStage_set_sort_775, METH_O, (const char *)Dtool_TextureStage_set_sort_775_comment},
  {"setSort", &Dtool_TextureStage_set_sort_775, METH_O, (const char *)Dtool_TextureStage_set_sort_775_comment},
  {"get_sort", &Dtool_TextureStage_get_sort_776, METH_NOARGS, (const char *)Dtool_TextureStage_get_sort_776_comment},
  {"getSort", &Dtool_TextureStage_get_sort_776, METH_NOARGS, (const char *)Dtool_TextureStage_get_sort_776_comment},
  {"set_priority", &Dtool_TextureStage_set_priority_777, METH_O, (const char *)Dtool_TextureStage_set_priority_777_comment},
  {"setPriority", &Dtool_TextureStage_set_priority_777, METH_O, (const char *)Dtool_TextureStage_set_priority_777_comment},
  {"get_priority", &Dtool_TextureStage_get_priority_778, METH_NOARGS, (const char *)Dtool_TextureStage_get_priority_778_comment},
  {"getPriority", &Dtool_TextureStage_get_priority_778, METH_NOARGS, (const char *)Dtool_TextureStage_get_priority_778_comment},
  {"set_texcoord_name", &Dtool_TextureStage_set_texcoord_name_779, METH_O, (const char *)Dtool_TextureStage_set_texcoord_name_779_comment},
  {"setTexcoordName", &Dtool_TextureStage_set_texcoord_name_779, METH_O, (const char *)Dtool_TextureStage_set_texcoord_name_779_comment},
  {"get_texcoord_name", &Dtool_TextureStage_get_texcoord_name_780, METH_NOARGS, (const char *)Dtool_TextureStage_get_texcoord_name_780_comment},
  {"getTexcoordName", &Dtool_TextureStage_get_texcoord_name_780, METH_NOARGS, (const char *)Dtool_TextureStage_get_texcoord_name_780_comment},
  {"get_tangent_name", &Dtool_TextureStage_get_tangent_name_781, METH_NOARGS, (const char *)Dtool_TextureStage_get_tangent_name_781_comment},
  {"getTangentName", &Dtool_TextureStage_get_tangent_name_781, METH_NOARGS, (const char *)Dtool_TextureStage_get_tangent_name_781_comment},
  {"get_binormal_name", &Dtool_TextureStage_get_binormal_name_782, METH_NOARGS, (const char *)Dtool_TextureStage_get_binormal_name_782_comment},
  {"getBinormalName", &Dtool_TextureStage_get_binormal_name_782, METH_NOARGS, (const char *)Dtool_TextureStage_get_binormal_name_782_comment},
  {"set_mode", &Dtool_TextureStage_set_mode_783, METH_O, (const char *)Dtool_TextureStage_set_mode_783_comment},
  {"setMode", &Dtool_TextureStage_set_mode_783, METH_O, (const char *)Dtool_TextureStage_set_mode_783_comment},
  {"get_mode", &Dtool_TextureStage_get_mode_784, METH_NOARGS, (const char *)Dtool_TextureStage_get_mode_784_comment},
  {"getMode", &Dtool_TextureStage_get_mode_784, METH_NOARGS, (const char *)Dtool_TextureStage_get_mode_784_comment},
  {"is_fixed_function", &Dtool_TextureStage_is_fixed_function_785, METH_NOARGS, (const char *)Dtool_TextureStage_is_fixed_function_785_comment},
  {"isFixedFunction", &Dtool_TextureStage_is_fixed_function_785, METH_NOARGS, (const char *)Dtool_TextureStage_is_fixed_function_785_comment},
  {"set_color", &Dtool_TextureStage_set_color_786, METH_O, (const char *)Dtool_TextureStage_set_color_786_comment},
  {"setColor", &Dtool_TextureStage_set_color_786, METH_O, (const char *)Dtool_TextureStage_set_color_786_comment},
  {"get_color", &Dtool_TextureStage_get_color_787, METH_NOARGS, (const char *)Dtool_TextureStage_get_color_787_comment},
  {"getColor", &Dtool_TextureStage_get_color_787, METH_NOARGS, (const char *)Dtool_TextureStage_get_color_787_comment},
  {"set_rgb_scale", &Dtool_TextureStage_set_rgb_scale_788, METH_O, (const char *)Dtool_TextureStage_set_rgb_scale_788_comment},
  {"setRgbScale", &Dtool_TextureStage_set_rgb_scale_788, METH_O, (const char *)Dtool_TextureStage_set_rgb_scale_788_comment},
  {"get_rgb_scale", &Dtool_TextureStage_get_rgb_scale_789, METH_NOARGS, (const char *)Dtool_TextureStage_get_rgb_scale_789_comment},
  {"getRgbScale", &Dtool_TextureStage_get_rgb_scale_789, METH_NOARGS, (const char *)Dtool_TextureStage_get_rgb_scale_789_comment},
  {"set_alpha_scale", &Dtool_TextureStage_set_alpha_scale_790, METH_O, (const char *)Dtool_TextureStage_set_alpha_scale_790_comment},
  {"setAlphaScale", &Dtool_TextureStage_set_alpha_scale_790, METH_O, (const char *)Dtool_TextureStage_set_alpha_scale_790_comment},
  {"get_alpha_scale", &Dtool_TextureStage_get_alpha_scale_791, METH_NOARGS, (const char *)Dtool_TextureStage_get_alpha_scale_791_comment},
  {"getAlphaScale", &Dtool_TextureStage_get_alpha_scale_791, METH_NOARGS, (const char *)Dtool_TextureStage_get_alpha_scale_791_comment},
  {"set_saved_result", &Dtool_TextureStage_set_saved_result_792, METH_O, (const char *)Dtool_TextureStage_set_saved_result_792_comment},
  {"setSavedResult", &Dtool_TextureStage_set_saved_result_792, METH_O, (const char *)Dtool_TextureStage_set_saved_result_792_comment},
  {"get_saved_result", &Dtool_TextureStage_get_saved_result_793, METH_NOARGS, (const char *)Dtool_TextureStage_get_saved_result_793_comment},
  {"getSavedResult", &Dtool_TextureStage_get_saved_result_793, METH_NOARGS, (const char *)Dtool_TextureStage_get_saved_result_793_comment},
  {"set_tex_view_offset", &Dtool_TextureStage_set_tex_view_offset_794, METH_O, (const char *)Dtool_TextureStage_set_tex_view_offset_794_comment},
  {"setTexViewOffset", &Dtool_TextureStage_set_tex_view_offset_794, METH_O, (const char *)Dtool_TextureStage_set_tex_view_offset_794_comment},
  {"get_tex_view_offset", &Dtool_TextureStage_get_tex_view_offset_795, METH_NOARGS, (const char *)Dtool_TextureStage_get_tex_view_offset_795_comment},
  {"getTexViewOffset", &Dtool_TextureStage_get_tex_view_offset_795, METH_NOARGS, (const char *)Dtool_TextureStage_get_tex_view_offset_795_comment},
  {"set_combine_rgb", (PyCFunction) &Dtool_TextureStage_set_combine_rgb_796, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureStage_set_combine_rgb_796_comment},
  {"setCombineRgb", (PyCFunction) &Dtool_TextureStage_set_combine_rgb_796, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureStage_set_combine_rgb_796_comment},
  {"get_combine_rgb_mode", &Dtool_TextureStage_get_combine_rgb_mode_797, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_mode_797_comment},
  {"getCombineRgbMode", &Dtool_TextureStage_get_combine_rgb_mode_797, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_mode_797_comment},
  {"get_num_combine_rgb_operands", &Dtool_TextureStage_get_num_combine_rgb_operands_798, METH_NOARGS, (const char *)Dtool_TextureStage_get_num_combine_rgb_operands_798_comment},
  {"getNumCombineRgbOperands", &Dtool_TextureStage_get_num_combine_rgb_operands_798, METH_NOARGS, (const char *)Dtool_TextureStage_get_num_combine_rgb_operands_798_comment},
  {"get_combine_rgb_source0", &Dtool_TextureStage_get_combine_rgb_source0_799, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_source0_799_comment},
  {"getCombineRgbSource0", &Dtool_TextureStage_get_combine_rgb_source0_799, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_source0_799_comment},
  {"get_combine_rgb_operand0", &Dtool_TextureStage_get_combine_rgb_operand0_800, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_operand0_800_comment},
  {"getCombineRgbOperand0", &Dtool_TextureStage_get_combine_rgb_operand0_800, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_operand0_800_comment},
  {"get_combine_rgb_source1", &Dtool_TextureStage_get_combine_rgb_source1_801, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_source1_801_comment},
  {"getCombineRgbSource1", &Dtool_TextureStage_get_combine_rgb_source1_801, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_source1_801_comment},
  {"get_combine_rgb_operand1", &Dtool_TextureStage_get_combine_rgb_operand1_802, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_operand1_802_comment},
  {"getCombineRgbOperand1", &Dtool_TextureStage_get_combine_rgb_operand1_802, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_operand1_802_comment},
  {"get_combine_rgb_source2", &Dtool_TextureStage_get_combine_rgb_source2_803, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_source2_803_comment},
  {"getCombineRgbSource2", &Dtool_TextureStage_get_combine_rgb_source2_803, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_source2_803_comment},
  {"get_combine_rgb_operand2", &Dtool_TextureStage_get_combine_rgb_operand2_804, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_operand2_804_comment},
  {"getCombineRgbOperand2", &Dtool_TextureStage_get_combine_rgb_operand2_804, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_rgb_operand2_804_comment},
  {"set_combine_alpha", (PyCFunction) &Dtool_TextureStage_set_combine_alpha_805, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureStage_set_combine_alpha_805_comment},
  {"setCombineAlpha", (PyCFunction) &Dtool_TextureStage_set_combine_alpha_805, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureStage_set_combine_alpha_805_comment},
  {"get_combine_alpha_mode", &Dtool_TextureStage_get_combine_alpha_mode_806, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_mode_806_comment},
  {"getCombineAlphaMode", &Dtool_TextureStage_get_combine_alpha_mode_806, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_mode_806_comment},
  {"get_num_combine_alpha_operands", &Dtool_TextureStage_get_num_combine_alpha_operands_807, METH_NOARGS, (const char *)Dtool_TextureStage_get_num_combine_alpha_operands_807_comment},
  {"getNumCombineAlphaOperands", &Dtool_TextureStage_get_num_combine_alpha_operands_807, METH_NOARGS, (const char *)Dtool_TextureStage_get_num_combine_alpha_operands_807_comment},
  {"get_combine_alpha_source0", &Dtool_TextureStage_get_combine_alpha_source0_808, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_source0_808_comment},
  {"getCombineAlphaSource0", &Dtool_TextureStage_get_combine_alpha_source0_808, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_source0_808_comment},
  {"get_combine_alpha_operand0", &Dtool_TextureStage_get_combine_alpha_operand0_809, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_operand0_809_comment},
  {"getCombineAlphaOperand0", &Dtool_TextureStage_get_combine_alpha_operand0_809, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_operand0_809_comment},
  {"get_combine_alpha_source1", &Dtool_TextureStage_get_combine_alpha_source1_810, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_source1_810_comment},
  {"getCombineAlphaSource1", &Dtool_TextureStage_get_combine_alpha_source1_810, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_source1_810_comment},
  {"get_combine_alpha_operand1", &Dtool_TextureStage_get_combine_alpha_operand1_811, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_operand1_811_comment},
  {"getCombineAlphaOperand1", &Dtool_TextureStage_get_combine_alpha_operand1_811, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_operand1_811_comment},
  {"get_combine_alpha_source2", &Dtool_TextureStage_get_combine_alpha_source2_812, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_source2_812_comment},
  {"getCombineAlphaSource2", &Dtool_TextureStage_get_combine_alpha_source2_812, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_source2_812_comment},
  {"get_combine_alpha_operand2", &Dtool_TextureStage_get_combine_alpha_operand2_813, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_operand2_813_comment},
  {"getCombineAlphaOperand2", &Dtool_TextureStage_get_combine_alpha_operand2_813, METH_NOARGS, (const char *)Dtool_TextureStage_get_combine_alpha_operand2_813_comment},
  {"involves_color_scale", &Dtool_TextureStage_involves_color_scale_814, METH_NOARGS, (const char *)Dtool_TextureStage_involves_color_scale_814_comment},
  {"involvesColorScale", &Dtool_TextureStage_involves_color_scale_814, METH_NOARGS, (const char *)Dtool_TextureStage_involves_color_scale_814_comment},
  {"uses_color", &Dtool_TextureStage_uses_color_815, METH_NOARGS, (const char *)Dtool_TextureStage_uses_color_815_comment},
  {"usesColor", &Dtool_TextureStage_uses_color_815, METH_NOARGS, (const char *)Dtool_TextureStage_uses_color_815_comment},
  {"uses_primary_color", &Dtool_TextureStage_uses_primary_color_816, METH_NOARGS, (const char *)Dtool_TextureStage_uses_primary_color_816_comment},
  {"usesPrimaryColor", &Dtool_TextureStage_uses_primary_color_816, METH_NOARGS, (const char *)Dtool_TextureStage_uses_primary_color_816_comment},
  {"uses_last_saved_result", &Dtool_TextureStage_uses_last_saved_result_817, METH_NOARGS, (const char *)Dtool_TextureStage_uses_last_saved_result_817_comment},
  {"usesLastSavedResult", &Dtool_TextureStage_uses_last_saved_result_817, METH_NOARGS, (const char *)Dtool_TextureStage_uses_last_saved_result_817_comment},
  {"compare_to", &Dtool_TextureStage_compare_to_821, METH_O, (const char *)Dtool_TextureStage_compare_to_821_comment},
  {"compareTo", &Dtool_TextureStage_compare_to_821, METH_O, (const char *)Dtool_TextureStage_compare_to_821_comment},
  {"write", &Dtool_TextureStage_write_822, METH_O, (const char *)Dtool_TextureStage_write_822_comment},
  {"output", &Dtool_TextureStage_output_823, METH_O, (const char *)Dtool_TextureStage_output_823_comment},
  {"get_default", &Dtool_TextureStage_get_default_824, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStage_get_default_824_comment},
  {"getDefault", &Dtool_TextureStage_get_default_824, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStage_get_default_824_comment},
  {"get_class_type", &Dtool_TextureStage_get_class_type_842, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStage_get_class_type_842_comment},
  {"getClassType", &Dtool_TextureStage_get_class_type_842, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStage_get_class_type_842_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TextureStage slot tp_compare -> compare_to
//////////////////
static int Dtool_TextureStage_compare_to_821_tp_compare(PyObject *self, PyObject *arg) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return -1;
  }

  // 1-int TextureStage::compare_to(TextureStage const &other) const
  TextureStage const *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "TextureStage.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const TextureStage*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(TextureStage self, const TextureStage other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     TextureStage
//////////////////
static PyObject *Dtool_Repr_TextureStage(PyObject *self) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     TextureStage
//////////////////
static PyObject *Dtool_Str_TextureStage(PyObject *self) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     TextureStage
//////////////////
static PyObject *Dtool_RichCompare_TextureStage(PyObject *self, PyObject *arg, int op) {
  TextureStage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStage, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool TextureStage::operator ==(TextureStage const &other) const
      TextureStage const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TextureStage);
      if (arg_this != nullptr) {
        bool return_value = ((*(const TextureStage*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool TextureStage::operator !=(TextureStage const &other) const
      TextureStage const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TextureStage);
      if (arg_this != nullptr) {
        bool return_value = ((*(const TextureStage*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool TextureStage::operator <(TextureStage const &other) const
      TextureStage const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TextureStage);
      if (arg_this != nullptr) {
        bool return_value = ((*(const TextureStage*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_TextureStage_compare_to_821_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_TextureStage[] = {
  {(char *)"name", &Dtool_TextureStage_name_Getter, &Dtool_TextureStage_name_Setter, nullptr, nullptr},
  {(char *)"sort", &Dtool_TextureStage_sort_Getter, &Dtool_TextureStage_sort_Setter, nullptr, nullptr},
  {(char *)"priority", &Dtool_TextureStage_priority_Getter, &Dtool_TextureStage_priority_Setter, nullptr, nullptr},
  {(char *)"texcoord_name", &Dtool_TextureStage_texcoord_name_Getter, &Dtool_TextureStage_texcoord_name_Setter, nullptr, nullptr},
  {(char *)"tangent_name", &Dtool_TextureStage_tangent_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"binormal_name", &Dtool_TextureStage_binormal_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"mode", &Dtool_TextureStage_mode_Getter, &Dtool_TextureStage_mode_Setter, nullptr, nullptr},
  {(char *)"color", &Dtool_TextureStage_color_Getter, &Dtool_TextureStage_color_Setter, nullptr, nullptr},
  {(char *)"rgb_scale", &Dtool_TextureStage_rgb_scale_Getter, &Dtool_TextureStage_rgb_scale_Setter, nullptr, nullptr},
  {(char *)"alpha_scale", &Dtool_TextureStage_alpha_scale_Getter, &Dtool_TextureStage_alpha_scale_Setter, nullptr, nullptr},
  {(char *)"saved_result", &Dtool_TextureStage_saved_result_Getter, &Dtool_TextureStage_saved_result_Setter, nullptr, nullptr},
  {(char *)"tex_view_offset", &Dtool_TextureStage_tex_view_offset_Getter, &Dtool_TextureStage_tex_view_offset_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TextureStage = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextureStage = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TextureStage = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TextureStage = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TextureStage = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TextureStage = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextureStage",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextureStage,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TextureStage,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_TextureStage_compare_to_821_tp_compare,
#endif
    &Dtool_Repr_TextureStage,
    &Dtool_NumberMethods_TextureStage,
    &Dtool_SequenceMethods_TextureStage,
    &Dtool_MappingMethods_TextureStage,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_TextureStage,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TextureStage,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines the properties of a named stage of the multitexture pipeline.  The\n"
    " * TextureAttrib will associated a number of these stages with Texture\n"
    " * objects, and the GSG will render geometry by sorting all of the currently\n"
    " * active TextureStages in order and then issuing the appropriate rendering\n"
    " * calls to activate them.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_TextureStage,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextureStage,
    nullptr, // tp_members
    Dtool_Properties_TextureStage,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextureStage,
    PyType_GenericAlloc,
    Dtool_new_TextureStage,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextureStage,
  Dtool_UpcastInterface_TextureStage,
  Dtool_DowncastInterface_TextureStage,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextureStage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_TextureStage._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_TextureStage._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(75);
    Dtool_TextureStage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TextureStage::Mode;
    PyDict_SetItemString(dict, "M_modulate", Dtool_WrapValue(TextureStage::M_modulate));
    PyDict_SetItemString(dict, "MModulate", Dtool_WrapValue(TextureStage::M_modulate));
    PyDict_SetItemString(dict, "M_decal", Dtool_WrapValue(TextureStage::M_decal));
    PyDict_SetItemString(dict, "MDecal", Dtool_WrapValue(TextureStage::M_decal));
    PyDict_SetItemString(dict, "M_blend", Dtool_WrapValue(TextureStage::M_blend));
    PyDict_SetItemString(dict, "MBlend", Dtool_WrapValue(TextureStage::M_blend));
    PyDict_SetItemString(dict, "M_replace", Dtool_WrapValue(TextureStage::M_replace));
    PyDict_SetItemString(dict, "MReplace", Dtool_WrapValue(TextureStage::M_replace));
    PyDict_SetItemString(dict, "M_add", Dtool_WrapValue(TextureStage::M_add));
    PyDict_SetItemString(dict, "MAdd", Dtool_WrapValue(TextureStage::M_add));
    PyDict_SetItemString(dict, "M_combine", Dtool_WrapValue(TextureStage::M_combine));
    PyDict_SetItemString(dict, "MCombine", Dtool_WrapValue(TextureStage::M_combine));
    PyDict_SetItemString(dict, "M_blend_color_scale", Dtool_WrapValue(TextureStage::M_blend_color_scale));
    PyDict_SetItemString(dict, "MBlendColorScale", Dtool_WrapValue(TextureStage::M_blend_color_scale));
    PyDict_SetItemString(dict, "M_modulate_glow", Dtool_WrapValue(TextureStage::M_modulate_glow));
    PyDict_SetItemString(dict, "MModulateGlow", Dtool_WrapValue(TextureStage::M_modulate_glow));
    PyDict_SetItemString(dict, "M_modulate_gloss", Dtool_WrapValue(TextureStage::M_modulate_gloss));
    PyDict_SetItemString(dict, "MModulateGloss", Dtool_WrapValue(TextureStage::M_modulate_gloss));
    PyDict_SetItemString(dict, "M_normal", Dtool_WrapValue(TextureStage::M_normal));
    PyDict_SetItemString(dict, "MNormal", Dtool_WrapValue(TextureStage::M_normal));
    PyDict_SetItemString(dict, "M_normal_height", Dtool_WrapValue(TextureStage::M_normal_height));
    PyDict_SetItemString(dict, "MNormalHeight", Dtool_WrapValue(TextureStage::M_normal_height));
    PyDict_SetItemString(dict, "M_glow", Dtool_WrapValue(TextureStage::M_glow));
    PyDict_SetItemString(dict, "MGlow", Dtool_WrapValue(TextureStage::M_glow));
    PyDict_SetItemString(dict, "M_gloss", Dtool_WrapValue(TextureStage::M_gloss));
    PyDict_SetItemString(dict, "MGloss", Dtool_WrapValue(TextureStage::M_gloss));
    PyDict_SetItemString(dict, "M_height", Dtool_WrapValue(TextureStage::M_height));
    PyDict_SetItemString(dict, "MHeight", Dtool_WrapValue(TextureStage::M_height));
    PyDict_SetItemString(dict, "M_selector", Dtool_WrapValue(TextureStage::M_selector));
    PyDict_SetItemString(dict, "MSelector", Dtool_WrapValue(TextureStage::M_selector));
    PyDict_SetItemString(dict, "M_normal_gloss", Dtool_WrapValue(TextureStage::M_normal_gloss));
    PyDict_SetItemString(dict, "MNormalGloss", Dtool_WrapValue(TextureStage::M_normal_gloss));
    // enum TextureStage::CombineMode;
    PyDict_SetItemString(dict, "CM_undefined", Dtool_WrapValue(TextureStage::CM_undefined));
    PyDict_SetItemString(dict, "CMUndefined", Dtool_WrapValue(TextureStage::CM_undefined));
    PyDict_SetItemString(dict, "CM_replace", Dtool_WrapValue(TextureStage::CM_replace));
    PyDict_SetItemString(dict, "CMReplace", Dtool_WrapValue(TextureStage::CM_replace));
    PyDict_SetItemString(dict, "CM_modulate", Dtool_WrapValue(TextureStage::CM_modulate));
    PyDict_SetItemString(dict, "CMModulate", Dtool_WrapValue(TextureStage::CM_modulate));
    PyDict_SetItemString(dict, "CM_add", Dtool_WrapValue(TextureStage::CM_add));
    PyDict_SetItemString(dict, "CMAdd", Dtool_WrapValue(TextureStage::CM_add));
    PyDict_SetItemString(dict, "CM_add_signed", Dtool_WrapValue(TextureStage::CM_add_signed));
    PyDict_SetItemString(dict, "CMAddSigned", Dtool_WrapValue(TextureStage::CM_add_signed));
    PyDict_SetItemString(dict, "CM_interpolate", Dtool_WrapValue(TextureStage::CM_interpolate));
    PyDict_SetItemString(dict, "CMInterpolate", Dtool_WrapValue(TextureStage::CM_interpolate));
    PyDict_SetItemString(dict, "CM_subtract", Dtool_WrapValue(TextureStage::CM_subtract));
    PyDict_SetItemString(dict, "CMSubtract", Dtool_WrapValue(TextureStage::CM_subtract));
    PyDict_SetItemString(dict, "CM_dot3_rgb", Dtool_WrapValue(TextureStage::CM_dot3_rgb));
    PyDict_SetItemString(dict, "CMDot3Rgb", Dtool_WrapValue(TextureStage::CM_dot3_rgb));
    PyDict_SetItemString(dict, "CM_dot3_rgba", Dtool_WrapValue(TextureStage::CM_dot3_rgba));
    PyDict_SetItemString(dict, "CMDot3Rgba", Dtool_WrapValue(TextureStage::CM_dot3_rgba));
    // enum TextureStage::CombineSource;
    PyDict_SetItemString(dict, "CS_undefined", Dtool_WrapValue(TextureStage::CS_undefined));
    PyDict_SetItemString(dict, "CSUndefined", Dtool_WrapValue(TextureStage::CS_undefined));
    PyDict_SetItemString(dict, "CS_texture", Dtool_WrapValue(TextureStage::CS_texture));
    PyDict_SetItemString(dict, "CSTexture", Dtool_WrapValue(TextureStage::CS_texture));
    PyDict_SetItemString(dict, "CS_constant", Dtool_WrapValue(TextureStage::CS_constant));
    PyDict_SetItemString(dict, "CSConstant", Dtool_WrapValue(TextureStage::CS_constant));
    PyDict_SetItemString(dict, "CS_primary_color", Dtool_WrapValue(TextureStage::CS_primary_color));
    PyDict_SetItemString(dict, "CSPrimaryColor", Dtool_WrapValue(TextureStage::CS_primary_color));
    PyDict_SetItemString(dict, "CS_previous", Dtool_WrapValue(TextureStage::CS_previous));
    PyDict_SetItemString(dict, "CSPrevious", Dtool_WrapValue(TextureStage::CS_previous));
    PyDict_SetItemString(dict, "CS_constant_color_scale", Dtool_WrapValue(TextureStage::CS_constant_color_scale));
    PyDict_SetItemString(dict, "CSConstantColorScale", Dtool_WrapValue(TextureStage::CS_constant_color_scale));
    PyDict_SetItemString(dict, "CS_last_saved_result", Dtool_WrapValue(TextureStage::CS_last_saved_result));
    PyDict_SetItemString(dict, "CSLastSavedResult", Dtool_WrapValue(TextureStage::CS_last_saved_result));
    // enum TextureStage::CombineOperand;
    PyDict_SetItemString(dict, "CO_undefined", Dtool_WrapValue(TextureStage::CO_undefined));
    PyDict_SetItemString(dict, "COUndefined", Dtool_WrapValue(TextureStage::CO_undefined));
    PyDict_SetItemString(dict, "CO_src_color", Dtool_WrapValue(TextureStage::CO_src_color));
    PyDict_SetItemString(dict, "COSrcColor", Dtool_WrapValue(TextureStage::CO_src_color));
    PyDict_SetItemString(dict, "CO_one_minus_src_color", Dtool_WrapValue(TextureStage::CO_one_minus_src_color));
    PyDict_SetItemString(dict, "COOneMinusSrcColor", Dtool_WrapValue(TextureStage::CO_one_minus_src_color));
    PyDict_SetItemString(dict, "CO_src_alpha", Dtool_WrapValue(TextureStage::CO_src_alpha));
    PyDict_SetItemString(dict, "COSrcAlpha", Dtool_WrapValue(TextureStage::CO_src_alpha));
    PyDict_SetItemString(dict, "CO_one_minus_src_alpha", Dtool_WrapValue(TextureStage::CO_one_minus_src_alpha));
    PyDict_SetItemString(dict, "COOneMinusSrcAlpha", Dtool_WrapValue(TextureStage::CO_one_minus_src_alpha));
    static const PyGetSetDef def_default = {(char *)"default", &Dtool_TextureStage_default_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "default", Dtool_NewStaticProperty(&Dtool_TextureStage._PyType, &def_default));
    if (PyType_Ready((PyTypeObject *)&Dtool_TextureStage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextureStage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextureStage);
  }
}

/**
 * Python method tables for Geom (Geom)
 */
static PyMethodDef Dtool_Methods_Geom[] = {
  {"assign", &Dtool_Geom_operator_849, METH_O, (const char *)Dtool_Geom_operator_849_comment},
  {"make_copy", &Dtool_Geom_make_copy_854, METH_NOARGS, (const char *)Dtool_Geom_make_copy_854_comment},
  {"makeCopy", &Dtool_Geom_make_copy_854, METH_NOARGS, (const char *)Dtool_Geom_make_copy_854_comment},
  {"get_primitive_type", &Dtool_Geom_get_primitive_type_855, METH_NOARGS, (const char *)Dtool_Geom_get_primitive_type_855_comment},
  {"getPrimitiveType", &Dtool_Geom_get_primitive_type_855, METH_NOARGS, (const char *)Dtool_Geom_get_primitive_type_855_comment},
  {"get_shade_model", &Dtool_Geom_get_shade_model_856, METH_NOARGS, (const char *)Dtool_Geom_get_shade_model_856_comment},
  {"getShadeModel", &Dtool_Geom_get_shade_model_856, METH_NOARGS, (const char *)Dtool_Geom_get_shade_model_856_comment},
  {"get_geom_rendering", &Dtool_Geom_get_geom_rendering_857, METH_NOARGS, (const char *)Dtool_Geom_get_geom_rendering_857_comment},
  {"getGeomRendering", &Dtool_Geom_get_geom_rendering_857, METH_NOARGS, (const char *)Dtool_Geom_get_geom_rendering_857_comment},
  {"get_usage_hint", &Dtool_Geom_get_usage_hint_861, METH_NOARGS, (const char *)Dtool_Geom_get_usage_hint_861_comment},
  {"getUsageHint", &Dtool_Geom_get_usage_hint_861, METH_NOARGS, (const char *)Dtool_Geom_get_usage_hint_861_comment},
  {"set_usage_hint", &Dtool_Geom_set_usage_hint_862, METH_O, (const char *)Dtool_Geom_set_usage_hint_862_comment},
  {"setUsageHint", &Dtool_Geom_set_usage_hint_862, METH_O, (const char *)Dtool_Geom_set_usage_hint_862_comment},
  {"get_vertex_data", (PyCFunction) &Dtool_Geom_get_vertex_data_863, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_get_vertex_data_863_comment},
  {"getVertexData", (PyCFunction) &Dtool_Geom_get_vertex_data_863, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_get_vertex_data_863_comment},
  {"modify_vertex_data", &Dtool_Geom_modify_vertex_data_864, METH_NOARGS, (const char *)Dtool_Geom_modify_vertex_data_864_comment},
  {"modifyVertexData", &Dtool_Geom_modify_vertex_data_864, METH_NOARGS, (const char *)Dtool_Geom_modify_vertex_data_864_comment},
  {"set_vertex_data", &Dtool_Geom_set_vertex_data_865, METH_O, (const char *)Dtool_Geom_set_vertex_data_865_comment},
  {"setVertexData", &Dtool_Geom_set_vertex_data_865, METH_O, (const char *)Dtool_Geom_set_vertex_data_865_comment},
  {"offset_vertices", (PyCFunction) &Dtool_Geom_offset_vertices_866, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_offset_vertices_866_comment},
  {"offsetVertices", (PyCFunction) &Dtool_Geom_offset_vertices_866, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_offset_vertices_866_comment},
  {"make_nonindexed", &Dtool_Geom_make_nonindexed_867, METH_O, (const char *)Dtool_Geom_make_nonindexed_867_comment},
  {"makeNonindexed", &Dtool_Geom_make_nonindexed_867, METH_O, (const char *)Dtool_Geom_make_nonindexed_867_comment},
  {"get_animated_vertex_data", (PyCFunction) &Dtool_Geom_get_animated_vertex_data_868, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_get_animated_vertex_data_868_comment},
  {"getAnimatedVertexData", (PyCFunction) &Dtool_Geom_get_animated_vertex_data_868, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_get_animated_vertex_data_868_comment},
  {"is_empty", &Dtool_Geom_is_empty_869, METH_NOARGS, (const char *)Dtool_Geom_is_empty_869_comment},
  {"isEmpty", &Dtool_Geom_is_empty_869, METH_NOARGS, (const char *)Dtool_Geom_is_empty_869_comment},
  {"get_num_primitives", &Dtool_Geom_get_num_primitives_870, METH_NOARGS, (const char *)Dtool_Geom_get_num_primitives_870_comment},
  {"getNumPrimitives", &Dtool_Geom_get_num_primitives_870, METH_NOARGS, (const char *)Dtool_Geom_get_num_primitives_870_comment},
  {"get_primitive", &Dtool_Geom_get_primitive_871, METH_O, (const char *)Dtool_Geom_get_primitive_871_comment},
  {"getPrimitive", &Dtool_Geom_get_primitive_871, METH_O, (const char *)Dtool_Geom_get_primitive_871_comment},
  {"modify_primitive", &Dtool_Geom_modify_primitive_873, METH_O, (const char *)Dtool_Geom_modify_primitive_873_comment},
  {"modifyPrimitive", &Dtool_Geom_modify_primitive_873, METH_O, (const char *)Dtool_Geom_modify_primitive_873_comment},
  {"set_primitive", (PyCFunction) &Dtool_Geom_set_primitive_874, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_set_primitive_874_comment},
  {"setPrimitive", (PyCFunction) &Dtool_Geom_set_primitive_874, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_set_primitive_874_comment},
  {"insert_primitive", (PyCFunction) &Dtool_Geom_insert_primitive_875, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_insert_primitive_875_comment},
  {"insertPrimitive", (PyCFunction) &Dtool_Geom_insert_primitive_875, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_insert_primitive_875_comment},
  {"add_primitive", &Dtool_Geom_add_primitive_876, METH_O, (const char *)Dtool_Geom_add_primitive_876_comment},
  {"addPrimitive", &Dtool_Geom_add_primitive_876, METH_O, (const char *)Dtool_Geom_add_primitive_876_comment},
  {"remove_primitive", &Dtool_Geom_remove_primitive_877, METH_O, (const char *)Dtool_Geom_remove_primitive_877_comment},
  {"removePrimitive", &Dtool_Geom_remove_primitive_877, METH_O, (const char *)Dtool_Geom_remove_primitive_877_comment},
  {"clear_primitives", &Dtool_Geom_clear_primitives_878, METH_NOARGS, (const char *)Dtool_Geom_clear_primitives_878_comment},
  {"clearPrimitives", &Dtool_Geom_clear_primitives_878, METH_NOARGS, (const char *)Dtool_Geom_clear_primitives_878_comment},
  {"decompose", &Dtool_Geom_decompose_881, METH_NOARGS, (const char *)Dtool_Geom_decompose_881_comment},
  {"doubleside", &Dtool_Geom_doubleside_882, METH_NOARGS, (const char *)Dtool_Geom_doubleside_882_comment},
  {"reverse", &Dtool_Geom_reverse_883, METH_NOARGS, (const char *)Dtool_Geom_reverse_883_comment},
  {"rotate", &Dtool_Geom_rotate_884, METH_NOARGS, (const char *)Dtool_Geom_rotate_884_comment},
  {"unify", (PyCFunction) &Dtool_Geom_unify_885, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_unify_885_comment},
  {"make_points", &Dtool_Geom_make_points_886, METH_NOARGS, (const char *)Dtool_Geom_make_points_886_comment},
  {"makePoints", &Dtool_Geom_make_points_886, METH_NOARGS, (const char *)Dtool_Geom_make_points_886_comment},
  {"make_lines", &Dtool_Geom_make_lines_887, METH_NOARGS, (const char *)Dtool_Geom_make_lines_887_comment},
  {"makeLines", &Dtool_Geom_make_lines_887, METH_NOARGS, (const char *)Dtool_Geom_make_lines_887_comment},
  {"make_patches", &Dtool_Geom_make_patches_888, METH_NOARGS, (const char *)Dtool_Geom_make_patches_888_comment},
  {"makePatches", &Dtool_Geom_make_patches_888, METH_NOARGS, (const char *)Dtool_Geom_make_patches_888_comment},
  {"make_adjacency", &Dtool_Geom_make_adjacency_889, METH_NOARGS, (const char *)Dtool_Geom_make_adjacency_889_comment},
  {"makeAdjacency", &Dtool_Geom_make_adjacency_889, METH_NOARGS, (const char *)Dtool_Geom_make_adjacency_889_comment},
  {"decompose_in_place", &Dtool_Geom_decompose_in_place_890, METH_NOARGS, (const char *)Dtool_Geom_decompose_in_place_890_comment},
  {"decomposeInPlace", &Dtool_Geom_decompose_in_place_890, METH_NOARGS, (const char *)Dtool_Geom_decompose_in_place_890_comment},
  {"doubleside_in_place", &Dtool_Geom_doubleside_in_place_891, METH_NOARGS, (const char *)Dtool_Geom_doubleside_in_place_891_comment},
  {"doublesideInPlace", &Dtool_Geom_doubleside_in_place_891, METH_NOARGS, (const char *)Dtool_Geom_doubleside_in_place_891_comment},
  {"reverse_in_place", &Dtool_Geom_reverse_in_place_892, METH_NOARGS, (const char *)Dtool_Geom_reverse_in_place_892_comment},
  {"reverseInPlace", &Dtool_Geom_reverse_in_place_892, METH_NOARGS, (const char *)Dtool_Geom_reverse_in_place_892_comment},
  {"rotate_in_place", &Dtool_Geom_rotate_in_place_893, METH_NOARGS, (const char *)Dtool_Geom_rotate_in_place_893_comment},
  {"rotateInPlace", &Dtool_Geom_rotate_in_place_893, METH_NOARGS, (const char *)Dtool_Geom_rotate_in_place_893_comment},
  {"unify_in_place", (PyCFunction) &Dtool_Geom_unify_in_place_894, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_unify_in_place_894_comment},
  {"unifyInPlace", (PyCFunction) &Dtool_Geom_unify_in_place_894, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_unify_in_place_894_comment},
  {"make_points_in_place", &Dtool_Geom_make_points_in_place_895, METH_NOARGS, (const char *)Dtool_Geom_make_points_in_place_895_comment},
  {"makePointsInPlace", &Dtool_Geom_make_points_in_place_895, METH_NOARGS, (const char *)Dtool_Geom_make_points_in_place_895_comment},
  {"make_lines_in_place", &Dtool_Geom_make_lines_in_place_896, METH_NOARGS, (const char *)Dtool_Geom_make_lines_in_place_896_comment},
  {"makeLinesInPlace", &Dtool_Geom_make_lines_in_place_896, METH_NOARGS, (const char *)Dtool_Geom_make_lines_in_place_896_comment},
  {"make_patches_in_place", &Dtool_Geom_make_patches_in_place_897, METH_NOARGS, (const char *)Dtool_Geom_make_patches_in_place_897_comment},
  {"makePatchesInPlace", &Dtool_Geom_make_patches_in_place_897, METH_NOARGS, (const char *)Dtool_Geom_make_patches_in_place_897_comment},
  {"make_adjacency_in_place", &Dtool_Geom_make_adjacency_in_place_898, METH_NOARGS, (const char *)Dtool_Geom_make_adjacency_in_place_898_comment},
  {"makeAdjacencyInPlace", &Dtool_Geom_make_adjacency_in_place_898, METH_NOARGS, (const char *)Dtool_Geom_make_adjacency_in_place_898_comment},
  {"copy_primitives_from", &Dtool_Geom_copy_primitives_from_899, METH_O, (const char *)Dtool_Geom_copy_primitives_from_899_comment},
  {"copyPrimitivesFrom", &Dtool_Geom_copy_primitives_from_899, METH_O, (const char *)Dtool_Geom_copy_primitives_from_899_comment},
  {"get_num_bytes", &Dtool_Geom_get_num_bytes_900, METH_NOARGS, (const char *)Dtool_Geom_get_num_bytes_900_comment},
  {"getNumBytes", &Dtool_Geom_get_num_bytes_900, METH_NOARGS, (const char *)Dtool_Geom_get_num_bytes_900_comment},
  {"get_modified", (PyCFunction) &Dtool_Geom_get_modified_901, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_get_modified_901_comment},
  {"getModified", (PyCFunction) &Dtool_Geom_get_modified_901, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_get_modified_901_comment},
  {"request_resident", &Dtool_Geom_request_resident_904, METH_NOARGS, (const char *)Dtool_Geom_request_resident_904_comment},
  {"requestResident", &Dtool_Geom_request_resident_904, METH_NOARGS, (const char *)Dtool_Geom_request_resident_904_comment},
  {"transform_vertices", &Dtool_Geom_transform_vertices_905, METH_O, (const char *)Dtool_Geom_transform_vertices_905_comment},
  {"transformVertices", &Dtool_Geom_transform_vertices_905, METH_O, (const char *)Dtool_Geom_transform_vertices_905_comment},
  {"check_valid", &Dtool_Geom_check_valid_906, METH_VARARGS, (const char *)Dtool_Geom_check_valid_906_comment},
  {"checkValid", &Dtool_Geom_check_valid_906, METH_VARARGS, (const char *)Dtool_Geom_check_valid_906_comment},
  {"get_bounds", (PyCFunction) &Dtool_Geom_get_bounds_907, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_get_bounds_907_comment},
  {"getBounds", (PyCFunction) &Dtool_Geom_get_bounds_907, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_get_bounds_907_comment},
  {"get_nested_vertices", (PyCFunction) &Dtool_Geom_get_nested_vertices_908, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_get_nested_vertices_908_comment},
  {"getNestedVertices", (PyCFunction) &Dtool_Geom_get_nested_vertices_908, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_get_nested_vertices_908_comment},
  {"mark_bounds_stale", &Dtool_Geom_mark_bounds_stale_909, METH_NOARGS, (const char *)Dtool_Geom_mark_bounds_stale_909_comment},
  {"markBoundsStale", &Dtool_Geom_mark_bounds_stale_909, METH_NOARGS, (const char *)Dtool_Geom_mark_bounds_stale_909_comment},
  {"set_bounds_type", &Dtool_Geom_set_bounds_type_910, METH_O, (const char *)Dtool_Geom_set_bounds_type_910_comment},
  {"setBoundsType", &Dtool_Geom_set_bounds_type_910, METH_O, (const char *)Dtool_Geom_set_bounds_type_910_comment},
  {"get_bounds_type", &Dtool_Geom_get_bounds_type_911, METH_NOARGS, (const char *)Dtool_Geom_get_bounds_type_911_comment},
  {"getBoundsType", &Dtool_Geom_get_bounds_type_911, METH_NOARGS, (const char *)Dtool_Geom_get_bounds_type_911_comment},
  {"set_bounds", &Dtool_Geom_set_bounds_912, METH_O, (const char *)Dtool_Geom_set_bounds_912_comment},
  {"setBounds", &Dtool_Geom_set_bounds_912, METH_O, (const char *)Dtool_Geom_set_bounds_912_comment},
  {"clear_bounds", &Dtool_Geom_clear_bounds_913, METH_NOARGS, (const char *)Dtool_Geom_clear_bounds_913_comment},
  {"clearBounds", &Dtool_Geom_clear_bounds_913, METH_NOARGS, (const char *)Dtool_Geom_clear_bounds_913_comment},
  {"output", &Dtool_Geom_output_917, METH_O, (const char *)Dtool_Geom_output_917_comment},
  {"write", (PyCFunction) &Dtool_Geom_write_918, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_write_918_comment},
  {"clear_cache", &Dtool_Geom_clear_cache_919, METH_NOARGS, (const char *)Dtool_Geom_clear_cache_919_comment},
  {"clearCache", &Dtool_Geom_clear_cache_919, METH_NOARGS, (const char *)Dtool_Geom_clear_cache_919_comment},
  {"clear_cache_stage", &Dtool_Geom_clear_cache_stage_920, METH_O, (const char *)Dtool_Geom_clear_cache_stage_920_comment},
  {"clearCacheStage", &Dtool_Geom_clear_cache_stage_920, METH_O, (const char *)Dtool_Geom_clear_cache_stage_920_comment},
  {"prepare", &Dtool_Geom_prepare_921, METH_O, (const char *)Dtool_Geom_prepare_921_comment},
  {"is_prepared", &Dtool_Geom_is_prepared_922, METH_O, (const char *)Dtool_Geom_is_prepared_922_comment},
  {"isPrepared", &Dtool_Geom_is_prepared_922, METH_O, (const char *)Dtool_Geom_is_prepared_922_comment},
  {"release", &Dtool_Geom_release_923, METH_O, (const char *)Dtool_Geom_release_923_comment},
  {"release_all", &Dtool_Geom_release_all_924, METH_NOARGS, (const char *)Dtool_Geom_release_all_924_comment},
  {"releaseAll", &Dtool_Geom_release_all_924, METH_NOARGS, (const char *)Dtool_Geom_release_all_924_comment},
  {"prepare_now", (PyCFunction) &Dtool_Geom_prepare_now_925, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_prepare_now_925_comment},
  {"prepareNow", (PyCFunction) &Dtool_Geom_prepare_now_925, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Geom_prepare_now_925_comment},
  {"get_class_type", &Dtool_Geom_get_class_type_926, METH_NOARGS | METH_STATIC, (const char *)Dtool_Geom_get_class_type_926_comment},
  {"getClassType", &Dtool_Geom_get_class_type_926, METH_NOARGS | METH_STATIC, (const char *)Dtool_Geom_get_class_type_926_comment},
  {"upcast_to_CopyOnWriteObject", &Dtool_Geom_upcast_to_CopyOnWriteObject_844, METH_NOARGS, (const char *)Dtool_Geom_upcast_to_CopyOnWriteObject_844_comment},
  {"upcastToCopyOnWriteObject", &Dtool_Geom_upcast_to_CopyOnWriteObject_844, METH_NOARGS, (const char *)Dtool_Geom_upcast_to_CopyOnWriteObject_844_comment},
  {"upcast_to_GeomEnums", &Dtool_Geom_upcast_to_GeomEnums_846, METH_NOARGS, (const char *)Dtool_Geom_upcast_to_GeomEnums_846_comment},
  {"upcastToGeomEnums", &Dtool_Geom_upcast_to_GeomEnums_846, METH_NOARGS, (const char *)Dtool_Geom_upcast_to_GeomEnums_846_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_primitives", (PyCFunction) &MakeSeq_Geom_get_primitives, METH_NOARGS, nullptr},
  { "getPrimitives", (PyCFunction) &MakeSeq_Geom_get_primitives, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     Geom
//////////////////
static PyObject *Dtool_Repr_Geom(PyObject *self) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Geom, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     Geom
//////////////////
static PyObject *Dtool_Str_Geom(PyObject *self) {
  Geom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Geom, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_Geom[] = {
  {(char *)"primitive_type", &Dtool_Geom_primitive_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"shade_model", &Dtool_Geom_shade_model_Getter, nullptr, nullptr, nullptr},
  {(char *)"geom_rendering", &Dtool_Geom_geom_rendering_Getter, nullptr, nullptr, nullptr},
  {(char *)"primitives", &Dtool_Geom_primitives_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_bytes", &Dtool_Geom_num_bytes_Getter, nullptr, nullptr, nullptr},
  {(char *)"modified", &Dtool_Geom_modified_Getter, nullptr, nullptr, nullptr},
  {(char *)"bounds_type", &Dtool_Geom_bounds_type_Getter, &Dtool_Geom_bounds_type_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Geom = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Geom = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Geom = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Geom = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Geom = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Geom = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Geom",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Geom,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Geom,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_Geom,
    &Dtool_NumberMethods_Geom,
    &Dtool_SequenceMethods_Geom,
    &Dtool_MappingMethods_Geom,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_Geom,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Geom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A container for geometry primitives.  This class associates one or more\n"
    " * GeomPrimitive objects with a table of vertices defined by a GeomVertexData\n"
    " * object.  All of the primitives stored in a particular Geom are drawn from\n"
    " * the same set of vertices (each primitive uses a subset of all of the\n"
    " * vertices in the table), and all of them must be rendered at the same time,\n"
    " * in the same graphics state.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Geom,
    nullptr, // tp_members
    Dtool_Properties_Geom,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Geom,
    PyType_GenericAlloc,
    Dtool_new_Geom,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Geom,
  Dtool_UpcastInterface_Geom,
  Dtool_DowncastInterface_Geom,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Geom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CopyOnWriteObject != nullptr);
    assert(Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_Geom._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_CopyOnWriteObject, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_Geom._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Geom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Geom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Geom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Geom);
  }
}

/**
 * Python method tables for GeomContext (GeomContext)
 */
static PyMethodDef Dtool_Methods_GeomContext[] = {
  {"get_geom", &Dtool_GeomContext_get_geom_928, METH_NOARGS, (const char *)Dtool_GeomContext_get_geom_928_comment},
  {"getGeom", &Dtool_GeomContext_get_geom_928, METH_NOARGS, (const char *)Dtool_GeomContext_get_geom_928_comment},
  {"get_class_type", &Dtool_GeomContext_get_class_type_931, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomContext_get_class_type_931_comment},
  {"getClassType", &Dtool_GeomContext_get_class_type_931, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomContext_get_class_type_931_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_GeomContext[] = {
  {(char *)"geom", &Dtool_GeomContext_geom_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GeomContext = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomContext = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomContext = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomContext = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomContext = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomContext = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomContext",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomContext,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomContext,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomContext,
    &Dtool_SequenceMethods_GeomContext,
    &Dtool_MappingMethods_GeomContext,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomContext,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special class object that holds all the information returned by a\n"
    " * particular GSG to indicate the geom's internal context identifier.\n"
    " *\n"
    " * Geoms typically have an immediate-mode and a retained-mode operation.  When\n"
    " * using geoms in retained-mode (in response to Geom::prepare()), the GSG will\n"
    " * create some internal handle for the geom and store it here.  The geom\n"
    " * stores all of these handles internally.\n"
    " *\n"
    " * In the case of OpenGL, for example, a GeomContext corresponds to a display\n"
    " * list identifier.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomContext,
    nullptr, // tp_members
    Dtool_Properties_GeomContext,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomContext,
    PyType_GenericAlloc,
    Dtool_new_GeomContext,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomContext,
  Dtool_UpcastInterface_GeomContext,
  Dtool_DowncastInterface_GeomContext,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomContext(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_SavedContext(nullptr);
    Dtool_GeomContext._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_SavedContext);
    Dtool_GeomContext._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomContext._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomContext) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomContext)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomContext);
  }
}

/**
 * Python method tables for GeomLines (GeomLines)
 */
static PyMethodDef Dtool_Methods_GeomLines[] = {
  {"get_class_type", &Dtool_GeomLines_get_class_type_938, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomLines_get_class_type_938_comment},
  {"getClassType", &Dtool_GeomLines_get_class_type_938, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomLines_get_class_type_938_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomLines = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomLines = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomLines = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomLines = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomLines = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomLines = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomLines",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomLines,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomLines,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomLines,
    &Dtool_SequenceMethods_GeomLines,
    &Dtool_MappingMethods_GeomLines,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomLines,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a series of disconnected line segments.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomLines,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomLines,
    PyType_GenericAlloc,
    Dtool_new_GeomLines,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomLines,
  Dtool_UpcastInterface_GeomLines,
  Dtool_DowncastInterface_GeomLines,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomLines(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomPrimitive(nullptr);
    Dtool_GeomLines._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomPrimitive);
    Dtool_GeomLines._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomLines._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomLines) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomLines)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomLines);
  }
}

/**
 * Python method tables for GeomLinesAdjacency (GeomLinesAdjacency)
 */
static PyMethodDef Dtool_Methods_GeomLinesAdjacency[] = {
  {"get_class_type", &Dtool_GeomLinesAdjacency_get_class_type_944, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomLinesAdjacency_get_class_type_944_comment},
  {"getClassType", &Dtool_GeomLinesAdjacency_get_class_type_944, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomLinesAdjacency_get_class_type_944_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomLinesAdjacency = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomLinesAdjacency = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomLinesAdjacency = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomLinesAdjacency = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomLinesAdjacency = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomLinesAdjacency = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomLinesAdjacency",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomLinesAdjacency,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomLinesAdjacency,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomLinesAdjacency,
    &Dtool_SequenceMethods_GeomLinesAdjacency,
    &Dtool_MappingMethods_GeomLinesAdjacency,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomLinesAdjacency,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a series of disconnected line segments with adjacency information,\n"
    " * for use with geometry shaders.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomLinesAdjacency,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomLinesAdjacency,
    PyType_GenericAlloc,
    Dtool_new_GeomLinesAdjacency,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomLinesAdjacency,
  Dtool_UpcastInterface_GeomLinesAdjacency,
  Dtool_DowncastInterface_GeomLinesAdjacency,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomLinesAdjacency(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomPrimitive(nullptr);
    Dtool_GeomLinesAdjacency._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomPrimitive);
    Dtool_GeomLinesAdjacency._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomLinesAdjacency._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomLinesAdjacency) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomLinesAdjacency)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomLinesAdjacency);
  }
}

/**
 * Python method tables for GeomLinestrips (GeomLinestrips)
 */
static PyMethodDef Dtool_Methods_GeomLinestrips[] = {
  {"get_class_type", &Dtool_GeomLinestrips_get_class_type_950, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomLinestrips_get_class_type_950_comment},
  {"getClassType", &Dtool_GeomLinestrips_get_class_type_950, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomLinestrips_get_class_type_950_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomLinestrips = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomLinestrips = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomLinestrips = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomLinestrips = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomLinestrips = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomLinestrips = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomLinestrips",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomLinestrips,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomLinestrips,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomLinestrips,
    &Dtool_SequenceMethods_GeomLinestrips,
    &Dtool_MappingMethods_GeomLinestrips,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomLinestrips,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a series of line strips.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomLinestrips,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomLinestrips,
    PyType_GenericAlloc,
    Dtool_new_GeomLinestrips,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomLinestrips,
  Dtool_UpcastInterface_GeomLinestrips,
  Dtool_DowncastInterface_GeomLinestrips,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomLinestrips(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomPrimitive(nullptr);
    Dtool_GeomLinestrips._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomPrimitive);
    Dtool_GeomLinestrips._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomLinestrips._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomLinestrips) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomLinestrips)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomLinestrips);
  }
}

/**
 * Python method tables for GeomLinestripsAdjacency (GeomLinestripsAdjacency)
 */
static PyMethodDef Dtool_Methods_GeomLinestripsAdjacency[] = {
  {"get_class_type", &Dtool_GeomLinestripsAdjacency_get_class_type_956, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomLinestripsAdjacency_get_class_type_956_comment},
  {"getClassType", &Dtool_GeomLinestripsAdjacency_get_class_type_956, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomLinestripsAdjacency_get_class_type_956_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomLinestripsAdjacency = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomLinestripsAdjacency = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomLinestripsAdjacency = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomLinestripsAdjacency = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomLinestripsAdjacency = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomLinestripsAdjacency = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomLinestripsAdjacency",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomLinestripsAdjacency,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomLinestripsAdjacency,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomLinestripsAdjacency,
    &Dtool_SequenceMethods_GeomLinestripsAdjacency,
    &Dtool_MappingMethods_GeomLinestripsAdjacency,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomLinestripsAdjacency,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a series of line strips with adjacency information.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomLinestripsAdjacency,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomLinestripsAdjacency,
    PyType_GenericAlloc,
    Dtool_new_GeomLinestripsAdjacency,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomLinestripsAdjacency,
  Dtool_UpcastInterface_GeomLinestripsAdjacency,
  Dtool_DowncastInterface_GeomLinestripsAdjacency,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomLinestripsAdjacency(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomPrimitive(nullptr);
    Dtool_GeomLinestripsAdjacency._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomPrimitive);
    Dtool_GeomLinestripsAdjacency._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomLinestripsAdjacency._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomLinestripsAdjacency) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomLinestripsAdjacency)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomLinestripsAdjacency);
  }
}

/**
 * Python method tables for GeomPatches (GeomPatches)
 */
static PyMethodDef Dtool_Methods_GeomPatches[] = {
  {"get_class_type", &Dtool_GeomPatches_get_class_type_962, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomPatches_get_class_type_962_comment},
  {"getClassType", &Dtool_GeomPatches_get_class_type_962, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomPatches_get_class_type_962_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomPatches = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomPatches = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomPatches = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomPatches = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomPatches = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomPatches = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomPatches",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomPatches,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomPatches,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomPatches,
    &Dtool_SequenceMethods_GeomPatches,
    &Dtool_MappingMethods_GeomPatches,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomPatches,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a series of \"patches\", fixed-size groupings of vertices that must\n"
    " * be processed by a tessellation shader.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomPatches,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomPatches,
    PyType_GenericAlloc,
    Dtool_new_GeomPatches,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomPatches,
  Dtool_UpcastInterface_GeomPatches,
  Dtool_DowncastInterface_GeomPatches,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomPatches(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomPrimitive(nullptr);
    Dtool_GeomPatches._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomPrimitive);
    Dtool_GeomPatches._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomPatches._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomPatches) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomPatches)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomPatches);
  }
}

/**
 * Python method tables for GeomPoints (GeomPoints)
 */
static PyMethodDef Dtool_Methods_GeomPoints[] = {
  {"get_class_type", &Dtool_GeomPoints_get_class_type_968, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomPoints_get_class_type_968_comment},
  {"getClassType", &Dtool_GeomPoints_get_class_type_968, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomPoints_get_class_type_968_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomPoints = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomPoints = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomPoints = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomPoints = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomPoints = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomPoints = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomPoints",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomPoints,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomPoints,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomPoints,
    &Dtool_SequenceMethods_GeomPoints,
    &Dtool_MappingMethods_GeomPoints,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomPoints,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a series of disconnected points.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomPoints,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomPoints,
    PyType_GenericAlloc,
    Dtool_new_GeomPoints,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomPoints,
  Dtool_UpcastInterface_GeomPoints,
  Dtool_DowncastInterface_GeomPoints,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomPoints(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomPrimitive(nullptr);
    Dtool_GeomPoints._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomPrimitive);
    Dtool_GeomPoints._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomPoints._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomPoints) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomPoints)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomPoints);
  }
}

/**
 * Python method tables for GeomTriangles (GeomTriangles)
 */
static PyMethodDef Dtool_Methods_GeomTriangles[] = {
  {"get_class_type", &Dtool_GeomTriangles_get_class_type_974, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTriangles_get_class_type_974_comment},
  {"getClassType", &Dtool_GeomTriangles_get_class_type_974, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTriangles_get_class_type_974_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomTriangles = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomTriangles = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomTriangles = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomTriangles = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomTriangles = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomTriangles = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomTriangles",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomTriangles,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomTriangles,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomTriangles,
    &Dtool_SequenceMethods_GeomTriangles,
    &Dtool_MappingMethods_GeomTriangles,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomTriangles,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a series of disconnected triangles.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomTriangles,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomTriangles,
    PyType_GenericAlloc,
    Dtool_new_GeomTriangles,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomTriangles,
  Dtool_UpcastInterface_GeomTriangles,
  Dtool_DowncastInterface_GeomTriangles,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomTriangles(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomPrimitive(nullptr);
    Dtool_GeomTriangles._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomPrimitive);
    Dtool_GeomTriangles._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomTriangles._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomTriangles) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomTriangles)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomTriangles);
  }
}

/**
 * Python method tables for GeomTrianglesAdjacency (GeomTrianglesAdjacency)
 */
static PyMethodDef Dtool_Methods_GeomTrianglesAdjacency[] = {
  {"get_class_type", &Dtool_GeomTrianglesAdjacency_get_class_type_980, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTrianglesAdjacency_get_class_type_980_comment},
  {"getClassType", &Dtool_GeomTrianglesAdjacency_get_class_type_980, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTrianglesAdjacency_get_class_type_980_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomTrianglesAdjacency = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomTrianglesAdjacency = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomTrianglesAdjacency = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomTrianglesAdjacency = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomTrianglesAdjacency = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomTrianglesAdjacency = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomTrianglesAdjacency",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomTrianglesAdjacency,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomTrianglesAdjacency,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomTrianglesAdjacency,
    &Dtool_SequenceMethods_GeomTrianglesAdjacency,
    &Dtool_MappingMethods_GeomTrianglesAdjacency,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomTrianglesAdjacency,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a series of disconnected triangles, with adjacency information.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomTrianglesAdjacency,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomTrianglesAdjacency,
    PyType_GenericAlloc,
    Dtool_new_GeomTrianglesAdjacency,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomTrianglesAdjacency,
  Dtool_UpcastInterface_GeomTrianglesAdjacency,
  Dtool_DowncastInterface_GeomTrianglesAdjacency,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomTrianglesAdjacency(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomPrimitive(nullptr);
    Dtool_GeomTrianglesAdjacency._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomPrimitive);
    Dtool_GeomTrianglesAdjacency._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomTrianglesAdjacency._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomTrianglesAdjacency) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomTrianglesAdjacency)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomTrianglesAdjacency);
  }
}

/**
 * Python method tables for GeomTrifans (GeomTrifans)
 */
static PyMethodDef Dtool_Methods_GeomTrifans[] = {
  {"get_class_type", &Dtool_GeomTrifans_get_class_type_986, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTrifans_get_class_type_986_comment},
  {"getClassType", &Dtool_GeomTrifans_get_class_type_986, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTrifans_get_class_type_986_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomTrifans = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomTrifans = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomTrifans = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomTrifans = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomTrifans = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomTrifans = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomTrifans",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomTrifans,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomTrifans,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomTrifans,
    &Dtool_SequenceMethods_GeomTrifans,
    &Dtool_MappingMethods_GeomTrifans,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomTrifans,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a series of triangle fans.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomTrifans,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomTrifans,
    PyType_GenericAlloc,
    Dtool_new_GeomTrifans,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomTrifans,
  Dtool_UpcastInterface_GeomTrifans,
  Dtool_DowncastInterface_GeomTrifans,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomTrifans(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomPrimitive(nullptr);
    Dtool_GeomTrifans._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomPrimitive);
    Dtool_GeomTrifans._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomTrifans._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomTrifans) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomTrifans)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomTrifans);
  }
}

/**
 * Python method tables for GeomTristrips (GeomTristrips)
 */
static PyMethodDef Dtool_Methods_GeomTristrips[] = {
  {"get_class_type", &Dtool_GeomTristrips_get_class_type_992, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTristrips_get_class_type_992_comment},
  {"getClassType", &Dtool_GeomTristrips_get_class_type_992, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTristrips_get_class_type_992_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomTristrips = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomTristrips = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomTristrips = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomTristrips = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomTristrips = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomTristrips = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomTristrips",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomTristrips,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomTristrips,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomTristrips,
    &Dtool_SequenceMethods_GeomTristrips,
    &Dtool_MappingMethods_GeomTristrips,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomTristrips,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a series of triangle strips.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomTristrips,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomTristrips,
    PyType_GenericAlloc,
    Dtool_new_GeomTristrips,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomTristrips,
  Dtool_UpcastInterface_GeomTristrips,
  Dtool_DowncastInterface_GeomTristrips,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomTristrips(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomPrimitive(nullptr);
    Dtool_GeomTristrips._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomPrimitive);
    Dtool_GeomTristrips._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomTristrips._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomTristrips) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomTristrips)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomTristrips);
  }
}

/**
 * Python method tables for GeomTristripsAdjacency (GeomTristripsAdjacency)
 */
static PyMethodDef Dtool_Methods_GeomTristripsAdjacency[] = {
  {"get_class_type", &Dtool_GeomTristripsAdjacency_get_class_type_998, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTristripsAdjacency_get_class_type_998_comment},
  {"getClassType", &Dtool_GeomTristripsAdjacency_get_class_type_998, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTristripsAdjacency_get_class_type_998_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomTristripsAdjacency = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomTristripsAdjacency = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomTristripsAdjacency = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomTristripsAdjacency = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomTristripsAdjacency = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomTristripsAdjacency = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomTristripsAdjacency",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomTristripsAdjacency,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomTristripsAdjacency,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomTristripsAdjacency,
    &Dtool_SequenceMethods_GeomTristripsAdjacency,
    &Dtool_MappingMethods_GeomTristripsAdjacency,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomTristripsAdjacency,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a series of triangle strips with adjacency information.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomTristripsAdjacency,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomTristripsAdjacency,
    PyType_GenericAlloc,
    Dtool_new_GeomTristripsAdjacency,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomTristripsAdjacency,
  Dtool_UpcastInterface_GeomTristripsAdjacency,
  Dtool_DowncastInterface_GeomTristripsAdjacency,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomTristripsAdjacency(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomPrimitive(nullptr);
    Dtool_GeomTristripsAdjacency._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomPrimitive);
    Dtool_GeomTristripsAdjacency._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomTristripsAdjacency._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomTristripsAdjacency) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomTristripsAdjacency)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomTristripsAdjacency);
  }
}

/**
 * Python method tables for GeomVertexReader (GeomVertexReader)
 */
static PyMethodDef Dtool_Methods_GeomVertexReader[] = {
  {"assign", &Dtool_GeomVertexReader_operator_1001, METH_O, (const char *)Dtool_GeomVertexReader_operator_1001_comment},
  {"get_vertex_data", &Dtool_GeomVertexReader_get_vertex_data_1003, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_vertex_data_1003_comment},
  {"getVertexData", &Dtool_GeomVertexReader_get_vertex_data_1003, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_vertex_data_1003_comment},
  {"get_array_data", &Dtool_GeomVertexReader_get_array_data_1004, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_array_data_1004_comment},
  {"getArrayData", &Dtool_GeomVertexReader_get_array_data_1004, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_array_data_1004_comment},
  {"get_array_handle", &Dtool_GeomVertexReader_get_array_handle_1005, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_array_handle_1005_comment},
  {"getArrayHandle", &Dtool_GeomVertexReader_get_array_handle_1005, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_array_handle_1005_comment},
  {"get_stride", &Dtool_GeomVertexReader_get_stride_1006, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_stride_1006_comment},
  {"getStride", &Dtool_GeomVertexReader_get_stride_1006, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_stride_1006_comment},
  {"get_current_thread", &Dtool_GeomVertexReader_get_current_thread_1007, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_current_thread_1007_comment},
  {"getCurrentThread", &Dtool_GeomVertexReader_get_current_thread_1007, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_current_thread_1007_comment},
  {"set_force", &Dtool_GeomVertexReader_set_force_1008, METH_O, (const char *)Dtool_GeomVertexReader_set_force_1008_comment},
  {"setForce", &Dtool_GeomVertexReader_set_force_1008, METH_O, (const char *)Dtool_GeomVertexReader_set_force_1008_comment},
  {"get_force", &Dtool_GeomVertexReader_get_force_1009, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_force_1009_comment},
  {"getForce", &Dtool_GeomVertexReader_get_force_1009, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_force_1009_comment},
  {"set_column", (PyCFunction) &Dtool_GeomVertexReader_set_column_1010, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexReader_set_column_1010_comment},
  {"setColumn", (PyCFunction) &Dtool_GeomVertexReader_set_column_1010, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexReader_set_column_1010_comment},
  {"clear", &Dtool_GeomVertexReader_clear_1011, METH_NOARGS, (const char *)Dtool_GeomVertexReader_clear_1011_comment},
  {"has_column", &Dtool_GeomVertexReader_has_column_1012, METH_NOARGS, (const char *)Dtool_GeomVertexReader_has_column_1012_comment},
  {"hasColumn", &Dtool_GeomVertexReader_has_column_1012, METH_NOARGS, (const char *)Dtool_GeomVertexReader_has_column_1012_comment},
  {"get_array", &Dtool_GeomVertexReader_get_array_1013, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_array_1013_comment},
  {"getArray", &Dtool_GeomVertexReader_get_array_1013, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_array_1013_comment},
  {"get_column", &Dtool_GeomVertexReader_get_column_1014, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_column_1014_comment},
  {"getColumn", &Dtool_GeomVertexReader_get_column_1014, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_column_1014_comment},
  {"set_row_unsafe", &Dtool_GeomVertexReader_set_row_unsafe_1015, METH_O, (const char *)Dtool_GeomVertexReader_set_row_unsafe_1015_comment},
  {"setRowUnsafe", &Dtool_GeomVertexReader_set_row_unsafe_1015, METH_O, (const char *)Dtool_GeomVertexReader_set_row_unsafe_1015_comment},
  {"set_row", &Dtool_GeomVertexReader_set_row_1016, METH_O, (const char *)Dtool_GeomVertexReader_set_row_1016_comment},
  {"setRow", &Dtool_GeomVertexReader_set_row_1016, METH_O, (const char *)Dtool_GeomVertexReader_set_row_1016_comment},
  {"get_start_row", &Dtool_GeomVertexReader_get_start_row_1017, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_start_row_1017_comment},
  {"getStartRow", &Dtool_GeomVertexReader_get_start_row_1017, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_start_row_1017_comment},
  {"get_read_row", &Dtool_GeomVertexReader_get_read_row_1018, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_read_row_1018_comment},
  {"getReadRow", &Dtool_GeomVertexReader_get_read_row_1018, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_read_row_1018_comment},
  {"is_at_end", &Dtool_GeomVertexReader_is_at_end_1019, METH_NOARGS, (const char *)Dtool_GeomVertexReader_is_at_end_1019_comment},
  {"isAtEnd", &Dtool_GeomVertexReader_is_at_end_1019, METH_NOARGS, (const char *)Dtool_GeomVertexReader_is_at_end_1019_comment},
  {"get_data1f", &Dtool_GeomVertexReader_get_data1f_1020, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data1f_1020_comment},
  {"getData1f", &Dtool_GeomVertexReader_get_data1f_1020, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data1f_1020_comment},
  {"get_data2f", &Dtool_GeomVertexReader_get_data2f_1021, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data2f_1021_comment},
  {"getData2f", &Dtool_GeomVertexReader_get_data2f_1021, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data2f_1021_comment},
  {"get_data3f", &Dtool_GeomVertexReader_get_data3f_1022, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data3f_1022_comment},
  {"getData3f", &Dtool_GeomVertexReader_get_data3f_1022, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data3f_1022_comment},
  {"get_data4f", &Dtool_GeomVertexReader_get_data4f_1023, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data4f_1023_comment},
  {"getData4f", &Dtool_GeomVertexReader_get_data4f_1023, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data4f_1023_comment},
  {"get_matrix3f", &Dtool_GeomVertexReader_get_matrix3f_1024, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix3f_1024_comment},
  {"getMatrix3f", &Dtool_GeomVertexReader_get_matrix3f_1024, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix3f_1024_comment},
  {"get_matrix4f", &Dtool_GeomVertexReader_get_matrix4f_1025, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix4f_1025_comment},
  {"getMatrix4f", &Dtool_GeomVertexReader_get_matrix4f_1025, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix4f_1025_comment},
  {"get_data1d", &Dtool_GeomVertexReader_get_data1d_1026, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data1d_1026_comment},
  {"getData1d", &Dtool_GeomVertexReader_get_data1d_1026, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data1d_1026_comment},
  {"get_data2d", &Dtool_GeomVertexReader_get_data2d_1027, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data2d_1027_comment},
  {"getData2d", &Dtool_GeomVertexReader_get_data2d_1027, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data2d_1027_comment},
  {"get_data3d", &Dtool_GeomVertexReader_get_data3d_1028, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data3d_1028_comment},
  {"getData3d", &Dtool_GeomVertexReader_get_data3d_1028, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data3d_1028_comment},
  {"get_data4d", &Dtool_GeomVertexReader_get_data4d_1029, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data4d_1029_comment},
  {"getData4d", &Dtool_GeomVertexReader_get_data4d_1029, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data4d_1029_comment},
  {"get_matrix3d", &Dtool_GeomVertexReader_get_matrix3d_1030, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix3d_1030_comment},
  {"getMatrix3d", &Dtool_GeomVertexReader_get_matrix3d_1030, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix3d_1030_comment},
  {"get_matrix4d", &Dtool_GeomVertexReader_get_matrix4d_1031, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix4d_1031_comment},
  {"getMatrix4d", &Dtool_GeomVertexReader_get_matrix4d_1031, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix4d_1031_comment},
  {"get_data1", &Dtool_GeomVertexReader_get_data1_1032, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data1_1032_comment},
  {"getData1", &Dtool_GeomVertexReader_get_data1_1032, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data1_1032_comment},
  {"get_data2", &Dtool_GeomVertexReader_get_data2_1033, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data2_1033_comment},
  {"getData2", &Dtool_GeomVertexReader_get_data2_1033, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data2_1033_comment},
  {"get_data3", &Dtool_GeomVertexReader_get_data3_1034, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data3_1034_comment},
  {"getData3", &Dtool_GeomVertexReader_get_data3_1034, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data3_1034_comment},
  {"get_data4", &Dtool_GeomVertexReader_get_data4_1035, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data4_1035_comment},
  {"getData4", &Dtool_GeomVertexReader_get_data4_1035, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data4_1035_comment},
  {"get_matrix3", &Dtool_GeomVertexReader_get_matrix3_1036, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix3_1036_comment},
  {"getMatrix3", &Dtool_GeomVertexReader_get_matrix3_1036, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix3_1036_comment},
  {"get_matrix4", &Dtool_GeomVertexReader_get_matrix4_1037, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix4_1037_comment},
  {"getMatrix4", &Dtool_GeomVertexReader_get_matrix4_1037, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_matrix4_1037_comment},
  {"get_data1i", &Dtool_GeomVertexReader_get_data1i_1038, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data1i_1038_comment},
  {"getData1i", &Dtool_GeomVertexReader_get_data1i_1038, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data1i_1038_comment},
  {"get_data2i", &Dtool_GeomVertexReader_get_data2i_1039, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data2i_1039_comment},
  {"getData2i", &Dtool_GeomVertexReader_get_data2i_1039, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data2i_1039_comment},
  {"get_data3i", &Dtool_GeomVertexReader_get_data3i_1040, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data3i_1040_comment},
  {"getData3i", &Dtool_GeomVertexReader_get_data3i_1040, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data3i_1040_comment},
  {"get_data4i", &Dtool_GeomVertexReader_get_data4i_1041, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data4i_1041_comment},
  {"getData4i", &Dtool_GeomVertexReader_get_data4i_1041, METH_NOARGS, (const char *)Dtool_GeomVertexReader_get_data4i_1041_comment},
  {"output", &Dtool_GeomVertexReader_output_1042, METH_O, (const char *)Dtool_GeomVertexReader_output_1042_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     GeomVertexReader
//////////////////
static PyObject *Dtool_Repr_GeomVertexReader(PyObject *self) {
  GeomVertexReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexReader, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_GeomVertexReader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomVertexReader = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomVertexReader = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomVertexReader = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomVertexReader = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomVertexReader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomVertexReader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomVertexReader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomVertexReader,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_GeomVertexReader,
    &Dtool_NumberMethods_GeomVertexReader,
    &Dtool_SequenceMethods_GeomVertexReader,
    &Dtool_MappingMethods_GeomVertexReader,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_GeomVertexReader,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomVertexReader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object provides a high-level interface for quickly reading a sequence\n"
    " * of numeric values from a vertex table.\n"
    " *\n"
    " * It is particularly optimized for reading a single column of data values for\n"
    " * a series of vertices, without changing columns between each number.\n"
    " * Although you can also use one GeomVertexReader to read across the columns\n"
    " * if it is convenient, by calling set_column() repeatedly at each vertex, it\n"
    " * is faster to read down the columns, and to use a different GeomVertexReader\n"
    " * for each column.\n"
    " *\n"
    " * Note that a GeomVertexReader does not keep a reference count to the actual\n"
    " * vertex data buffer (it grabs the current data buffer from the\n"
    " * GeomVertexData whenever set_column() is called).  This means that it is\n"
    " * important not to keep a GeomVertexReader object around over a long period\n"
    " * of time in which the data buffer is likely to be deallocated; it is\n"
    " * intended for making a quick pass over the data in one session.\n"
    " *\n"
    " * It also means that you should create any GeomVertexWriters *before*\n"
    " * creating GeomVertexReaders on the same data, since the writer itself might\n"
    " * cause the vertex buffer to be deallocated.  Better yet, use a\n"
    " * GeomVertexRewriter if you are going to create both of them anyway.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomVertexReader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomVertexReader,
    PyType_GenericAlloc,
    Dtool_new_GeomVertexReader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomVertexReader,
  Dtool_UpcastInterface_GeomVertexReader,
  Dtool_DowncastInterface_GeomVertexReader,
  nullptr,
  (CoerceFunction)Dtool_Coerce_GeomVertexReader,
};

static void Dtool_PyModuleClassInit_GeomVertexReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_GeomVertexReader._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_GeomVertexReader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomVertexReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomVertexReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomVertexReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomVertexReader);
  }
}

/**
 * Python method tables for GeomVertexWriter (GeomVertexWriter)
 */
static PyMethodDef Dtool_Methods_GeomVertexWriter[] = {
  {"assign", &Dtool_GeomVertexWriter_operator_1045, METH_O, (const char *)Dtool_GeomVertexWriter_operator_1045_comment},
  {"get_vertex_data", &Dtool_GeomVertexWriter_get_vertex_data_1047, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_vertex_data_1047_comment},
  {"getVertexData", &Dtool_GeomVertexWriter_get_vertex_data_1047, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_vertex_data_1047_comment},
  {"get_array_data", &Dtool_GeomVertexWriter_get_array_data_1048, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_array_data_1048_comment},
  {"getArrayData", &Dtool_GeomVertexWriter_get_array_data_1048, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_array_data_1048_comment},
  {"get_array_handle", &Dtool_GeomVertexWriter_get_array_handle_1049, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_array_handle_1049_comment},
  {"getArrayHandle", &Dtool_GeomVertexWriter_get_array_handle_1049, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_array_handle_1049_comment},
  {"get_stride", &Dtool_GeomVertexWriter_get_stride_1050, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_stride_1050_comment},
  {"getStride", &Dtool_GeomVertexWriter_get_stride_1050, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_stride_1050_comment},
  {"get_current_thread", &Dtool_GeomVertexWriter_get_current_thread_1051, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_current_thread_1051_comment},
  {"getCurrentThread", &Dtool_GeomVertexWriter_get_current_thread_1051, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_current_thread_1051_comment},
  {"set_column", (PyCFunction) &Dtool_GeomVertexWriter_set_column_1052, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_column_1052_comment},
  {"setColumn", (PyCFunction) &Dtool_GeomVertexWriter_set_column_1052, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_column_1052_comment},
  {"clear", &Dtool_GeomVertexWriter_clear_1053, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_clear_1053_comment},
  {"reserve_num_rows", &Dtool_GeomVertexWriter_reserve_num_rows_1054, METH_O, (const char *)Dtool_GeomVertexWriter_reserve_num_rows_1054_comment},
  {"reserveNumRows", &Dtool_GeomVertexWriter_reserve_num_rows_1054, METH_O, (const char *)Dtool_GeomVertexWriter_reserve_num_rows_1054_comment},
  {"has_column", &Dtool_GeomVertexWriter_has_column_1055, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_has_column_1055_comment},
  {"hasColumn", &Dtool_GeomVertexWriter_has_column_1055, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_has_column_1055_comment},
  {"get_array", &Dtool_GeomVertexWriter_get_array_1056, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_array_1056_comment},
  {"getArray", &Dtool_GeomVertexWriter_get_array_1056, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_array_1056_comment},
  {"get_column", &Dtool_GeomVertexWriter_get_column_1057, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_column_1057_comment},
  {"getColumn", &Dtool_GeomVertexWriter_get_column_1057, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_column_1057_comment},
  {"set_row_unsafe", &Dtool_GeomVertexWriter_set_row_unsafe_1058, METH_O, (const char *)Dtool_GeomVertexWriter_set_row_unsafe_1058_comment},
  {"setRowUnsafe", &Dtool_GeomVertexWriter_set_row_unsafe_1058, METH_O, (const char *)Dtool_GeomVertexWriter_set_row_unsafe_1058_comment},
  {"set_row", &Dtool_GeomVertexWriter_set_row_1059, METH_O, (const char *)Dtool_GeomVertexWriter_set_row_1059_comment},
  {"setRow", &Dtool_GeomVertexWriter_set_row_1059, METH_O, (const char *)Dtool_GeomVertexWriter_set_row_1059_comment},
  {"get_start_row", &Dtool_GeomVertexWriter_get_start_row_1060, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_start_row_1060_comment},
  {"getStartRow", &Dtool_GeomVertexWriter_get_start_row_1060, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_start_row_1060_comment},
  {"get_write_row", &Dtool_GeomVertexWriter_get_write_row_1061, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_write_row_1061_comment},
  {"getWriteRow", &Dtool_GeomVertexWriter_get_write_row_1061, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_get_write_row_1061_comment},
  {"is_at_end", &Dtool_GeomVertexWriter_is_at_end_1062, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_is_at_end_1062_comment},
  {"isAtEnd", &Dtool_GeomVertexWriter_is_at_end_1062, METH_NOARGS, (const char *)Dtool_GeomVertexWriter_is_at_end_1062_comment},
  {"set_data1f", &Dtool_GeomVertexWriter_set_data1f_1063, METH_O, (const char *)Dtool_GeomVertexWriter_set_data1f_1063_comment},
  {"setData1f", &Dtool_GeomVertexWriter_set_data1f_1063, METH_O, (const char *)Dtool_GeomVertexWriter_set_data1f_1063_comment},
  {"set_data2f", (PyCFunction) &Dtool_GeomVertexWriter_set_data2f_1064, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data2f_1064_comment},
  {"setData2f", (PyCFunction) &Dtool_GeomVertexWriter_set_data2f_1064, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data2f_1064_comment},
  {"set_data3f", (PyCFunction) &Dtool_GeomVertexWriter_set_data3f_1065, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data3f_1065_comment},
  {"setData3f", (PyCFunction) &Dtool_GeomVertexWriter_set_data3f_1065, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data3f_1065_comment},
  {"set_data4f", (PyCFunction) &Dtool_GeomVertexWriter_set_data4f_1066, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data4f_1066_comment},
  {"setData4f", (PyCFunction) &Dtool_GeomVertexWriter_set_data4f_1066, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data4f_1066_comment},
  {"set_matrix3f", &Dtool_GeomVertexWriter_set_matrix3f_1067, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix3f_1067_comment},
  {"setMatrix3f", &Dtool_GeomVertexWriter_set_matrix3f_1067, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix3f_1067_comment},
  {"set_matrix4f", &Dtool_GeomVertexWriter_set_matrix4f_1068, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix4f_1068_comment},
  {"setMatrix4f", &Dtool_GeomVertexWriter_set_matrix4f_1068, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix4f_1068_comment},
  {"set_data1d", &Dtool_GeomVertexWriter_set_data1d_1069, METH_O, (const char *)Dtool_GeomVertexWriter_set_data1d_1069_comment},
  {"setData1d", &Dtool_GeomVertexWriter_set_data1d_1069, METH_O, (const char *)Dtool_GeomVertexWriter_set_data1d_1069_comment},
  {"set_data2d", (PyCFunction) &Dtool_GeomVertexWriter_set_data2d_1070, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data2d_1070_comment},
  {"setData2d", (PyCFunction) &Dtool_GeomVertexWriter_set_data2d_1070, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data2d_1070_comment},
  {"set_data3d", (PyCFunction) &Dtool_GeomVertexWriter_set_data3d_1071, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data3d_1071_comment},
  {"setData3d", (PyCFunction) &Dtool_GeomVertexWriter_set_data3d_1071, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data3d_1071_comment},
  {"set_data4d", (PyCFunction) &Dtool_GeomVertexWriter_set_data4d_1072, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data4d_1072_comment},
  {"setData4d", (PyCFunction) &Dtool_GeomVertexWriter_set_data4d_1072, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data4d_1072_comment},
  {"set_matrix3d", &Dtool_GeomVertexWriter_set_matrix3d_1073, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix3d_1073_comment},
  {"setMatrix3d", &Dtool_GeomVertexWriter_set_matrix3d_1073, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix3d_1073_comment},
  {"set_matrix4d", &Dtool_GeomVertexWriter_set_matrix4d_1074, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix4d_1074_comment},
  {"setMatrix4d", &Dtool_GeomVertexWriter_set_matrix4d_1074, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix4d_1074_comment},
  {"set_data1", &Dtool_GeomVertexWriter_set_data1_1075, METH_O, (const char *)Dtool_GeomVertexWriter_set_data1_1075_comment},
  {"setData1", &Dtool_GeomVertexWriter_set_data1_1075, METH_O, (const char *)Dtool_GeomVertexWriter_set_data1_1075_comment},
  {"set_data2", (PyCFunction) &Dtool_GeomVertexWriter_set_data2_1076, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data2_1076_comment},
  {"setData2", (PyCFunction) &Dtool_GeomVertexWriter_set_data2_1076, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data2_1076_comment},
  {"set_data3", (PyCFunction) &Dtool_GeomVertexWriter_set_data3_1077, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data3_1077_comment},
  {"setData3", (PyCFunction) &Dtool_GeomVertexWriter_set_data3_1077, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data3_1077_comment},
  {"set_data4", (PyCFunction) &Dtool_GeomVertexWriter_set_data4_1078, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data4_1078_comment},
  {"setData4", (PyCFunction) &Dtool_GeomVertexWriter_set_data4_1078, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data4_1078_comment},
  {"set_matrix3", &Dtool_GeomVertexWriter_set_matrix3_1079, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix3_1079_comment},
  {"setMatrix3", &Dtool_GeomVertexWriter_set_matrix3_1079, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix3_1079_comment},
  {"set_matrix4", &Dtool_GeomVertexWriter_set_matrix4_1080, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix4_1080_comment},
  {"setMatrix4", &Dtool_GeomVertexWriter_set_matrix4_1080, METH_O, (const char *)Dtool_GeomVertexWriter_set_matrix4_1080_comment},
  {"set_data1i", &Dtool_GeomVertexWriter_set_data1i_1081, METH_O, (const char *)Dtool_GeomVertexWriter_set_data1i_1081_comment},
  {"setData1i", &Dtool_GeomVertexWriter_set_data1i_1081, METH_O, (const char *)Dtool_GeomVertexWriter_set_data1i_1081_comment},
  {"set_data2i", (PyCFunction) &Dtool_GeomVertexWriter_set_data2i_1082, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data2i_1082_comment},
  {"setData2i", (PyCFunction) &Dtool_GeomVertexWriter_set_data2i_1082, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data2i_1082_comment},
  {"set_data3i", (PyCFunction) &Dtool_GeomVertexWriter_set_data3i_1083, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data3i_1083_comment},
  {"setData3i", (PyCFunction) &Dtool_GeomVertexWriter_set_data3i_1083, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data3i_1083_comment},
  {"set_data4i", (PyCFunction) &Dtool_GeomVertexWriter_set_data4i_1084, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data4i_1084_comment},
  {"setData4i", (PyCFunction) &Dtool_GeomVertexWriter_set_data4i_1084, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_set_data4i_1084_comment},
  {"add_data1f", &Dtool_GeomVertexWriter_add_data1f_1085, METH_O, (const char *)Dtool_GeomVertexWriter_add_data1f_1085_comment},
  {"addData1f", &Dtool_GeomVertexWriter_add_data1f_1085, METH_O, (const char *)Dtool_GeomVertexWriter_add_data1f_1085_comment},
  {"add_data2f", (PyCFunction) &Dtool_GeomVertexWriter_add_data2f_1086, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data2f_1086_comment},
  {"addData2f", (PyCFunction) &Dtool_GeomVertexWriter_add_data2f_1086, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data2f_1086_comment},
  {"add_data3f", (PyCFunction) &Dtool_GeomVertexWriter_add_data3f_1087, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data3f_1087_comment},
  {"addData3f", (PyCFunction) &Dtool_GeomVertexWriter_add_data3f_1087, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data3f_1087_comment},
  {"add_data4f", (PyCFunction) &Dtool_GeomVertexWriter_add_data4f_1088, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data4f_1088_comment},
  {"addData4f", (PyCFunction) &Dtool_GeomVertexWriter_add_data4f_1088, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data4f_1088_comment},
  {"add_matrix3f", &Dtool_GeomVertexWriter_add_matrix3f_1089, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix3f_1089_comment},
  {"addMatrix3f", &Dtool_GeomVertexWriter_add_matrix3f_1089, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix3f_1089_comment},
  {"add_matrix4f", &Dtool_GeomVertexWriter_add_matrix4f_1090, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix4f_1090_comment},
  {"addMatrix4f", &Dtool_GeomVertexWriter_add_matrix4f_1090, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix4f_1090_comment},
  {"add_data1d", &Dtool_GeomVertexWriter_add_data1d_1091, METH_O, (const char *)Dtool_GeomVertexWriter_add_data1d_1091_comment},
  {"addData1d", &Dtool_GeomVertexWriter_add_data1d_1091, METH_O, (const char *)Dtool_GeomVertexWriter_add_data1d_1091_comment},
  {"add_data2d", (PyCFunction) &Dtool_GeomVertexWriter_add_data2d_1092, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data2d_1092_comment},
  {"addData2d", (PyCFunction) &Dtool_GeomVertexWriter_add_data2d_1092, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data2d_1092_comment},
  {"add_data3d", (PyCFunction) &Dtool_GeomVertexWriter_add_data3d_1093, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data3d_1093_comment},
  {"addData3d", (PyCFunction) &Dtool_GeomVertexWriter_add_data3d_1093, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data3d_1093_comment},
  {"add_data4d", (PyCFunction) &Dtool_GeomVertexWriter_add_data4d_1094, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data4d_1094_comment},
  {"addData4d", (PyCFunction) &Dtool_GeomVertexWriter_add_data4d_1094, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data4d_1094_comment},
  {"add_matrix3d", &Dtool_GeomVertexWriter_add_matrix3d_1095, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix3d_1095_comment},
  {"addMatrix3d", &Dtool_GeomVertexWriter_add_matrix3d_1095, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix3d_1095_comment},
  {"add_matrix4d", &Dtool_GeomVertexWriter_add_matrix4d_1096, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix4d_1096_comment},
  {"addMatrix4d", &Dtool_GeomVertexWriter_add_matrix4d_1096, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix4d_1096_comment},
  {"add_data1", &Dtool_GeomVertexWriter_add_data1_1097, METH_O, (const char *)Dtool_GeomVertexWriter_add_data1_1097_comment},
  {"addData1", &Dtool_GeomVertexWriter_add_data1_1097, METH_O, (const char *)Dtool_GeomVertexWriter_add_data1_1097_comment},
  {"add_data2", (PyCFunction) &Dtool_GeomVertexWriter_add_data2_1098, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data2_1098_comment},
  {"addData2", (PyCFunction) &Dtool_GeomVertexWriter_add_data2_1098, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data2_1098_comment},
  {"add_data3", (PyCFunction) &Dtool_GeomVertexWriter_add_data3_1099, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data3_1099_comment},
  {"addData3", (PyCFunction) &Dtool_GeomVertexWriter_add_data3_1099, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data3_1099_comment},
  {"add_data4", (PyCFunction) &Dtool_GeomVertexWriter_add_data4_1100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data4_1100_comment},
  {"addData4", (PyCFunction) &Dtool_GeomVertexWriter_add_data4_1100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data4_1100_comment},
  {"add_matrix3", &Dtool_GeomVertexWriter_add_matrix3_1101, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix3_1101_comment},
  {"addMatrix3", &Dtool_GeomVertexWriter_add_matrix3_1101, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix3_1101_comment},
  {"add_matrix4", &Dtool_GeomVertexWriter_add_matrix4_1102, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix4_1102_comment},
  {"addMatrix4", &Dtool_GeomVertexWriter_add_matrix4_1102, METH_O, (const char *)Dtool_GeomVertexWriter_add_matrix4_1102_comment},
  {"add_data1i", &Dtool_GeomVertexWriter_add_data1i_1103, METH_O, (const char *)Dtool_GeomVertexWriter_add_data1i_1103_comment},
  {"addData1i", &Dtool_GeomVertexWriter_add_data1i_1103, METH_O, (const char *)Dtool_GeomVertexWriter_add_data1i_1103_comment},
  {"add_data2i", (PyCFunction) &Dtool_GeomVertexWriter_add_data2i_1104, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data2i_1104_comment},
  {"addData2i", (PyCFunction) &Dtool_GeomVertexWriter_add_data2i_1104, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data2i_1104_comment},
  {"add_data3i", (PyCFunction) &Dtool_GeomVertexWriter_add_data3i_1105, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data3i_1105_comment},
  {"addData3i", (PyCFunction) &Dtool_GeomVertexWriter_add_data3i_1105, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data3i_1105_comment},
  {"add_data4i", (PyCFunction) &Dtool_GeomVertexWriter_add_data4i_1106, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data4i_1106_comment},
  {"addData4i", (PyCFunction) &Dtool_GeomVertexWriter_add_data4i_1106, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexWriter_add_data4i_1106_comment},
  {"output", &Dtool_GeomVertexWriter_output_1107, METH_O, (const char *)Dtool_GeomVertexWriter_output_1107_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     GeomVertexWriter
//////////////////
static PyObject *Dtool_Repr_GeomVertexWriter(PyObject *self) {
  GeomVertexWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexWriter, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_GeomVertexWriter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomVertexWriter = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomVertexWriter = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomVertexWriter = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomVertexWriter = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomVertexWriter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomVertexWriter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomVertexWriter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomVertexWriter,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_GeomVertexWriter,
    &Dtool_NumberMethods_GeomVertexWriter,
    &Dtool_SequenceMethods_GeomVertexWriter,
    &Dtool_MappingMethods_GeomVertexWriter,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_GeomVertexWriter,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomVertexWriter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object provides a high-level interface for quickly writing a sequence\n"
    " * of numeric values from a vertex table.\n"
    " *\n"
    " * This object can be used both to replace existing vertices in the table, or\n"
    " * to extend the table with new vertices.  The set_data*() family of methods\n"
    " * can only be used to replace existing data; it is an error to allow these to\n"
    " * run past the end of the data.  The add_data*() family of methods, on the\n"
    " * other hand, can be used to replace existing data or add new data; if you\n"
    " * call set_row() into the middle of existing data the add_data*() methods\n"
    " * will behave like the corresponding set_data*(), but if they run past the\n"
    " * end of existing data they will quietly add new vertices.\n"
    " *\n"
    " * Like GeomVertexReader, the writer is particularly optimized for writing a\n"
    " * single column of data values for a series of vertices, without changing\n"
    " * columns between each number.  Although you can also use one\n"
    " * GeomVertexWriter to write across the columns if it is convenient, by\n"
    " * calling set_column() repeatedly at each vertex, it is faster to write down\n"
    " * the columns, and to use a different GeomVertexWriter for each column.\n"
    " *\n"
    " * Note that, like a GeomVertexReader, a GeomVertexWriter does not keep a\n"
    " * reference count to the actual vertex data buffer.  This means that it is\n"
    " * important not to keep a GeomVertexWriter object around over a long period\n"
    " * of time in which the data buffer is likely to be deallocated; it is\n"
    " * intended for making a quick pass over the data in one session.\n"
    " *\n"
    " * It also means that you should create any GeomVertexWriters *before*\n"
    " * creating GeomVertexReaders on the same data, since the writer itself might\n"
    " * cause the vertex buffer to be deallocated.  Better yet, use a\n"
    " * GeomVertexRewriter if you are going to create both of them anyway.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomVertexWriter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomVertexWriter,
    PyType_GenericAlloc,
    Dtool_new_GeomVertexWriter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomVertexWriter,
  Dtool_UpcastInterface_GeomVertexWriter,
  Dtool_DowncastInterface_GeomVertexWriter,
  nullptr,
  (CoerceFunction)Dtool_Coerce_GeomVertexWriter,
};

static void Dtool_PyModuleClassInit_GeomVertexWriter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_GeomVertexWriter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_GeomVertexWriter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomVertexWriter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomVertexWriter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomVertexWriter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomVertexWriter);
  }
}

/**
 * Python method tables for GeomVertexRewriter (GeomVertexRewriter)
 */
static PyMethodDef Dtool_Methods_GeomVertexRewriter[] = {
  {"assign", &Dtool_GeomVertexRewriter_operator_1114, METH_O, (const char *)Dtool_GeomVertexRewriter_operator_1114_comment},
  {"get_vertex_data", &Dtool_GeomVertexRewriter_get_vertex_data_1116, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_vertex_data_1116_comment},
  {"getVertexData", &Dtool_GeomVertexRewriter_get_vertex_data_1116, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_vertex_data_1116_comment},
  {"get_array_data", &Dtool_GeomVertexRewriter_get_array_data_1117, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_array_data_1117_comment},
  {"getArrayData", &Dtool_GeomVertexRewriter_get_array_data_1117, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_array_data_1117_comment},
  {"get_array_handle", &Dtool_GeomVertexRewriter_get_array_handle_1118, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_array_handle_1118_comment},
  {"getArrayHandle", &Dtool_GeomVertexRewriter_get_array_handle_1118, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_array_handle_1118_comment},
  {"get_stride", &Dtool_GeomVertexRewriter_get_stride_1119, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_stride_1119_comment},
  {"getStride", &Dtool_GeomVertexRewriter_get_stride_1119, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_stride_1119_comment},
  {"get_current_thread", &Dtool_GeomVertexRewriter_get_current_thread_1120, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_current_thread_1120_comment},
  {"getCurrentThread", &Dtool_GeomVertexRewriter_get_current_thread_1120, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_current_thread_1120_comment},
  {"set_column", (PyCFunction) &Dtool_GeomVertexRewriter_set_column_1121, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexRewriter_set_column_1121_comment},
  {"setColumn", (PyCFunction) &Dtool_GeomVertexRewriter_set_column_1121, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeomVertexRewriter_set_column_1121_comment},
  {"clear", &Dtool_GeomVertexRewriter_clear_1122, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_clear_1122_comment},
  {"has_column", &Dtool_GeomVertexRewriter_has_column_1123, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_has_column_1123_comment},
  {"hasColumn", &Dtool_GeomVertexRewriter_has_column_1123, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_has_column_1123_comment},
  {"get_array", &Dtool_GeomVertexRewriter_get_array_1124, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_array_1124_comment},
  {"getArray", &Dtool_GeomVertexRewriter_get_array_1124, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_array_1124_comment},
  {"get_column", &Dtool_GeomVertexRewriter_get_column_1125, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_column_1125_comment},
  {"getColumn", &Dtool_GeomVertexRewriter_get_column_1125, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_column_1125_comment},
  {"set_row_unsafe", &Dtool_GeomVertexRewriter_set_row_unsafe_1126, METH_O, (const char *)Dtool_GeomVertexRewriter_set_row_unsafe_1126_comment},
  {"setRowUnsafe", &Dtool_GeomVertexRewriter_set_row_unsafe_1126, METH_O, (const char *)Dtool_GeomVertexRewriter_set_row_unsafe_1126_comment},
  {"set_row", &Dtool_GeomVertexRewriter_set_row_1127, METH_O, (const char *)Dtool_GeomVertexRewriter_set_row_1127_comment},
  {"setRow", &Dtool_GeomVertexRewriter_set_row_1127, METH_O, (const char *)Dtool_GeomVertexRewriter_set_row_1127_comment},
  {"get_start_row", &Dtool_GeomVertexRewriter_get_start_row_1128, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_start_row_1128_comment},
  {"getStartRow", &Dtool_GeomVertexRewriter_get_start_row_1128, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_get_start_row_1128_comment},
  {"is_at_end", &Dtool_GeomVertexRewriter_is_at_end_1129, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_is_at_end_1129_comment},
  {"isAtEnd", &Dtool_GeomVertexRewriter_is_at_end_1129, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_is_at_end_1129_comment},
  {"output", &Dtool_GeomVertexRewriter_output_1130, METH_O, (const char *)Dtool_GeomVertexRewriter_output_1130_comment},
  {"upcast_to_GeomVertexWriter", &Dtool_GeomVertexRewriter_upcast_to_GeomVertexWriter_1109, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_upcast_to_GeomVertexWriter_1109_comment},
  {"upcastToGeomVertexWriter", &Dtool_GeomVertexRewriter_upcast_to_GeomVertexWriter_1109, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_upcast_to_GeomVertexWriter_1109_comment},
  {"upcast_to_GeomVertexReader", &Dtool_GeomVertexRewriter_upcast_to_GeomVertexReader_1111, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_upcast_to_GeomVertexReader_1111_comment},
  {"upcastToGeomVertexReader", &Dtool_GeomVertexRewriter_upcast_to_GeomVertexReader_1111, METH_NOARGS, (const char *)Dtool_GeomVertexRewriter_upcast_to_GeomVertexReader_1111_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     GeomVertexRewriter
//////////////////
static PyObject *Dtool_Repr_GeomVertexRewriter(PyObject *self) {
  GeomVertexRewriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomVertexRewriter, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_GeomVertexRewriter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomVertexRewriter = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomVertexRewriter = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomVertexRewriter = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomVertexRewriter = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomVertexRewriter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomVertexRewriter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomVertexRewriter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomVertexRewriter,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_GeomVertexRewriter,
    &Dtool_NumberMethods_GeomVertexRewriter,
    &Dtool_SequenceMethods_GeomVertexRewriter,
    &Dtool_MappingMethods_GeomVertexRewriter,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_GeomVertexRewriter,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomVertexRewriter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object provides the functionality of both a GeomVertexReader and a\n"
    " * GeomVertexWriter, combined together into one convenient package.  It is\n"
    " * designed for making a single pass over a GeomVertexData object, modifying\n"
    " * rows as it goes.\n"
    " *\n"
    " * Although it doesn't provide any real performance benefit over using a\n"
    " * separate reader and writer on the same data, it should probably be used in\n"
    " * preference to a separate reader and writer, because it makes an effort to\n"
    " * manage the reference counts properly between the reader and the writer to\n"
    " * avoid accidentally dereferencing either array while recopying.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomVertexRewriter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomVertexRewriter,
    PyType_GenericAlloc,
    Dtool_new_GeomVertexRewriter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomVertexRewriter,
  Dtool_UpcastInterface_GeomVertexRewriter,
  Dtool_DowncastInterface_GeomVertexRewriter,
  nullptr,
  (CoerceFunction)Dtool_Coerce_GeomVertexRewriter,
};

static void Dtool_PyModuleClassInit_GeomVertexRewriter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeomVertexWriter(nullptr);
    Dtool_PyModuleClassInit_GeomVertexReader(nullptr);
    Dtool_GeomVertexRewriter._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_GeomVertexWriter, (PyTypeObject *)&Dtool_GeomVertexReader);
    Dtool_GeomVertexRewriter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomVertexRewriter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomVertexRewriter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomVertexRewriter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomVertexRewriter);
  }
}

/**
 * Python method tables for SamplerState (SamplerState)
 */
static PyMethodDef Dtool_Methods_SamplerState[] = {
  {"get_default", &Dtool_SamplerState_get_default_1135, METH_NOARGS | METH_STATIC, (const char *)Dtool_SamplerState_get_default_1135_comment},
  {"getDefault", &Dtool_SamplerState_get_default_1135, METH_NOARGS | METH_STATIC, (const char *)Dtool_SamplerState_get_default_1135_comment},
  {"set_wrap_u", &Dtool_SamplerState_set_wrap_u_1136, METH_O, (const char *)Dtool_SamplerState_set_wrap_u_1136_comment},
  {"setWrapU", &Dtool_SamplerState_set_wrap_u_1136, METH_O, (const char *)Dtool_SamplerState_set_wrap_u_1136_comment},
  {"set_wrap_v", &Dtool_SamplerState_set_wrap_v_1137, METH_O, (const char *)Dtool_SamplerState_set_wrap_v_1137_comment},
  {"setWrapV", &Dtool_SamplerState_set_wrap_v_1137, METH_O, (const char *)Dtool_SamplerState_set_wrap_v_1137_comment},
  {"set_wrap_w", &Dtool_SamplerState_set_wrap_w_1138, METH_O, (const char *)Dtool_SamplerState_set_wrap_w_1138_comment},
  {"setWrapW", &Dtool_SamplerState_set_wrap_w_1138, METH_O, (const char *)Dtool_SamplerState_set_wrap_w_1138_comment},
  {"set_minfilter", &Dtool_SamplerState_set_minfilter_1139, METH_O, (const char *)Dtool_SamplerState_set_minfilter_1139_comment},
  {"setMinfilter", &Dtool_SamplerState_set_minfilter_1139, METH_O, (const char *)Dtool_SamplerState_set_minfilter_1139_comment},
  {"set_magfilter", &Dtool_SamplerState_set_magfilter_1140, METH_O, (const char *)Dtool_SamplerState_set_magfilter_1140_comment},
  {"setMagfilter", &Dtool_SamplerState_set_magfilter_1140, METH_O, (const char *)Dtool_SamplerState_set_magfilter_1140_comment},
  {"set_anisotropic_degree", &Dtool_SamplerState_set_anisotropic_degree_1141, METH_O, (const char *)Dtool_SamplerState_set_anisotropic_degree_1141_comment},
  {"setAnisotropicDegree", &Dtool_SamplerState_set_anisotropic_degree_1141, METH_O, (const char *)Dtool_SamplerState_set_anisotropic_degree_1141_comment},
  {"set_border_color", &Dtool_SamplerState_set_border_color_1142, METH_O, (const char *)Dtool_SamplerState_set_border_color_1142_comment},
  {"setBorderColor", &Dtool_SamplerState_set_border_color_1142, METH_O, (const char *)Dtool_SamplerState_set_border_color_1142_comment},
  {"set_min_lod", &Dtool_SamplerState_set_min_lod_1143, METH_O, (const char *)Dtool_SamplerState_set_min_lod_1143_comment},
  {"setMinLod", &Dtool_SamplerState_set_min_lod_1143, METH_O, (const char *)Dtool_SamplerState_set_min_lod_1143_comment},
  {"set_max_lod", &Dtool_SamplerState_set_max_lod_1144, METH_O, (const char *)Dtool_SamplerState_set_max_lod_1144_comment},
  {"setMaxLod", &Dtool_SamplerState_set_max_lod_1144, METH_O, (const char *)Dtool_SamplerState_set_max_lod_1144_comment},
  {"set_lod_bias", &Dtool_SamplerState_set_lod_bias_1145, METH_O, (const char *)Dtool_SamplerState_set_lod_bias_1145_comment},
  {"setLodBias", &Dtool_SamplerState_set_lod_bias_1145, METH_O, (const char *)Dtool_SamplerState_set_lod_bias_1145_comment},
  {"get_wrap_u", &Dtool_SamplerState_get_wrap_u_1146, METH_NOARGS, (const char *)Dtool_SamplerState_get_wrap_u_1146_comment},
  {"getWrapU", &Dtool_SamplerState_get_wrap_u_1146, METH_NOARGS, (const char *)Dtool_SamplerState_get_wrap_u_1146_comment},
  {"get_wrap_v", &Dtool_SamplerState_get_wrap_v_1147, METH_NOARGS, (const char *)Dtool_SamplerState_get_wrap_v_1147_comment},
  {"getWrapV", &Dtool_SamplerState_get_wrap_v_1147, METH_NOARGS, (const char *)Dtool_SamplerState_get_wrap_v_1147_comment},
  {"get_wrap_w", &Dtool_SamplerState_get_wrap_w_1148, METH_NOARGS, (const char *)Dtool_SamplerState_get_wrap_w_1148_comment},
  {"getWrapW", &Dtool_SamplerState_get_wrap_w_1148, METH_NOARGS, (const char *)Dtool_SamplerState_get_wrap_w_1148_comment},
  {"get_minfilter", &Dtool_SamplerState_get_minfilter_1149, METH_NOARGS, (const char *)Dtool_SamplerState_get_minfilter_1149_comment},
  {"getMinfilter", &Dtool_SamplerState_get_minfilter_1149, METH_NOARGS, (const char *)Dtool_SamplerState_get_minfilter_1149_comment},
  {"get_magfilter", &Dtool_SamplerState_get_magfilter_1150, METH_NOARGS, (const char *)Dtool_SamplerState_get_magfilter_1150_comment},
  {"getMagfilter", &Dtool_SamplerState_get_magfilter_1150, METH_NOARGS, (const char *)Dtool_SamplerState_get_magfilter_1150_comment},
  {"get_effective_minfilter", &Dtool_SamplerState_get_effective_minfilter_1151, METH_NOARGS, (const char *)Dtool_SamplerState_get_effective_minfilter_1151_comment},
  {"getEffectiveMinfilter", &Dtool_SamplerState_get_effective_minfilter_1151, METH_NOARGS, (const char *)Dtool_SamplerState_get_effective_minfilter_1151_comment},
  {"get_effective_magfilter", &Dtool_SamplerState_get_effective_magfilter_1152, METH_NOARGS, (const char *)Dtool_SamplerState_get_effective_magfilter_1152_comment},
  {"getEffectiveMagfilter", &Dtool_SamplerState_get_effective_magfilter_1152, METH_NOARGS, (const char *)Dtool_SamplerState_get_effective_magfilter_1152_comment},
  {"get_anisotropic_degree", &Dtool_SamplerState_get_anisotropic_degree_1153, METH_NOARGS, (const char *)Dtool_SamplerState_get_anisotropic_degree_1153_comment},
  {"getAnisotropicDegree", &Dtool_SamplerState_get_anisotropic_degree_1153, METH_NOARGS, (const char *)Dtool_SamplerState_get_anisotropic_degree_1153_comment},
  {"get_effective_anisotropic_degree", &Dtool_SamplerState_get_effective_anisotropic_degree_1154, METH_NOARGS, (const char *)Dtool_SamplerState_get_effective_anisotropic_degree_1154_comment},
  {"getEffectiveAnisotropicDegree", &Dtool_SamplerState_get_effective_anisotropic_degree_1154, METH_NOARGS, (const char *)Dtool_SamplerState_get_effective_anisotropic_degree_1154_comment},
  {"get_border_color", &Dtool_SamplerState_get_border_color_1155, METH_NOARGS, (const char *)Dtool_SamplerState_get_border_color_1155_comment},
  {"getBorderColor", &Dtool_SamplerState_get_border_color_1155, METH_NOARGS, (const char *)Dtool_SamplerState_get_border_color_1155_comment},
  {"get_min_lod", &Dtool_SamplerState_get_min_lod_1156, METH_NOARGS, (const char *)Dtool_SamplerState_get_min_lod_1156_comment},
  {"getMinLod", &Dtool_SamplerState_get_min_lod_1156, METH_NOARGS, (const char *)Dtool_SamplerState_get_min_lod_1156_comment},
  {"get_max_lod", &Dtool_SamplerState_get_max_lod_1157, METH_NOARGS, (const char *)Dtool_SamplerState_get_max_lod_1157_comment},
  {"getMaxLod", &Dtool_SamplerState_get_max_lod_1157, METH_NOARGS, (const char *)Dtool_SamplerState_get_max_lod_1157_comment},
  {"get_lod_bias", &Dtool_SamplerState_get_lod_bias_1158, METH_NOARGS, (const char *)Dtool_SamplerState_get_lod_bias_1158_comment},
  {"getLodBias", &Dtool_SamplerState_get_lod_bias_1158, METH_NOARGS, (const char *)Dtool_SamplerState_get_lod_bias_1158_comment},
  {"uses_mipmaps", &Dtool_SamplerState_uses_mipmaps_1173, METH_NOARGS, (const char *)Dtool_SamplerState_uses_mipmaps_1173_comment},
  {"usesMipmaps", &Dtool_SamplerState_uses_mipmaps_1173, METH_NOARGS, (const char *)Dtool_SamplerState_uses_mipmaps_1173_comment},
  {"is_mipmap", &Dtool_SamplerState_is_mipmap_1174, METH_O | METH_STATIC, (const char *)Dtool_SamplerState_is_mipmap_1174_comment},
  {"isMipmap", &Dtool_SamplerState_is_mipmap_1174, METH_O | METH_STATIC, (const char *)Dtool_SamplerState_is_mipmap_1174_comment},
  {"format_filter_type", &Dtool_SamplerState_format_filter_type_1175, METH_O | METH_STATIC, (const char *)Dtool_SamplerState_format_filter_type_1175_comment},
  {"formatFilterType", &Dtool_SamplerState_format_filter_type_1175, METH_O | METH_STATIC, (const char *)Dtool_SamplerState_format_filter_type_1175_comment},
  {"string_filter_type", &Dtool_SamplerState_string_filter_type_1176, METH_O | METH_STATIC, (const char *)Dtool_SamplerState_string_filter_type_1176_comment},
  {"stringFilterType", &Dtool_SamplerState_string_filter_type_1176, METH_O | METH_STATIC, (const char *)Dtool_SamplerState_string_filter_type_1176_comment},
  {"format_wrap_mode", &Dtool_SamplerState_format_wrap_mode_1177, METH_O | METH_STATIC, (const char *)Dtool_SamplerState_format_wrap_mode_1177_comment},
  {"formatWrapMode", &Dtool_SamplerState_format_wrap_mode_1177, METH_O | METH_STATIC, (const char *)Dtool_SamplerState_format_wrap_mode_1177_comment},
  {"string_wrap_mode", &Dtool_SamplerState_string_wrap_mode_1178, METH_O | METH_STATIC, (const char *)Dtool_SamplerState_string_wrap_mode_1178_comment},
  {"stringWrapMode", &Dtool_SamplerState_string_wrap_mode_1178, METH_O | METH_STATIC, (const char *)Dtool_SamplerState_string_wrap_mode_1178_comment},
  {"prepare", &Dtool_SamplerState_prepare_1182, METH_O, (const char *)Dtool_SamplerState_prepare_1182_comment},
  {"is_prepared", &Dtool_SamplerState_is_prepared_1183, METH_O, (const char *)Dtool_SamplerState_is_prepared_1183_comment},
  {"isPrepared", &Dtool_SamplerState_is_prepared_1183, METH_O, (const char *)Dtool_SamplerState_is_prepared_1183_comment},
  {"release", &Dtool_SamplerState_release_1184, METH_O, (const char *)Dtool_SamplerState_release_1184_comment},
  {"get_class_type", &Dtool_SamplerState_get_class_type_1186, METH_NOARGS | METH_STATIC, (const char *)Dtool_SamplerState_get_class_type_1186_comment},
  {"getClassType", &Dtool_SamplerState_get_class_type_1186, METH_NOARGS | METH_STATIC, (const char *)Dtool_SamplerState_get_class_type_1186_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A rich comparison function
//     SamplerState
//////////////////
static PyObject *Dtool_RichCompare_SamplerState(PyObject *self, PyObject *arg, int op) {
  SamplerState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SamplerState, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool SamplerState::operator ==(SamplerState const &other) const
      SamplerState const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_SamplerState);
      if (arg_this != nullptr) {
        bool return_value = ((*(const SamplerState*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool SamplerState::operator !=(SamplerState const &other) const
      SamplerState const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_SamplerState);
      if (arg_this != nullptr) {
        bool return_value = ((*(const SamplerState*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool SamplerState::operator <(SamplerState const &other) const
      SamplerState const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_SamplerState);
      if (arg_this != nullptr) {
        bool return_value = ((*(const SamplerState*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_SamplerState[] = {
  {(char *)"wrap_u", &Dtool_SamplerState_wrap_u_Getter, &Dtool_SamplerState_wrap_u_Setter, nullptr, nullptr},
  {(char *)"wrap_v", &Dtool_SamplerState_wrap_v_Getter, &Dtool_SamplerState_wrap_v_Setter, nullptr, nullptr},
  {(char *)"wrap_w", &Dtool_SamplerState_wrap_w_Getter, &Dtool_SamplerState_wrap_w_Setter, nullptr, nullptr},
  {(char *)"minfilter", &Dtool_SamplerState_minfilter_Getter, &Dtool_SamplerState_minfilter_Setter, nullptr, nullptr},
  {(char *)"magfilter", &Dtool_SamplerState_magfilter_Getter, &Dtool_SamplerState_magfilter_Setter, nullptr, nullptr},
  {(char *)"effective_minfilter", &Dtool_SamplerState_effective_minfilter_Getter, nullptr, nullptr, nullptr},
  {(char *)"effective_magfilter", &Dtool_SamplerState_effective_magfilter_Getter, nullptr, nullptr, nullptr},
  {(char *)"anisotropic_degree", &Dtool_SamplerState_anisotropic_degree_Getter, &Dtool_SamplerState_anisotropic_degree_Setter, nullptr, nullptr},
  {(char *)"effective_anisotropic_degree", &Dtool_SamplerState_effective_anisotropic_degree_Getter, nullptr, nullptr, nullptr},
  {(char *)"border_color", &Dtool_SamplerState_border_color_Getter, &Dtool_SamplerState_border_color_Setter, nullptr, nullptr},
  {(char *)"min_lod", &Dtool_SamplerState_min_lod_Getter, &Dtool_SamplerState_min_lod_Setter, nullptr, nullptr},
  {(char *)"max_lod", &Dtool_SamplerState_max_lod_Getter, &Dtool_SamplerState_max_lod_Setter, nullptr, nullptr},
  {(char *)"lod_bias", &Dtool_SamplerState_lod_bias_Getter, &Dtool_SamplerState_lod_bias_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_SamplerState = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_SamplerState = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SamplerState",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SamplerState,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_SamplerState,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents a set of settings that indicate how a texture is sampled.  This\n"
    " * can be used to sample the same texture using different settings in\n"
    " * different places.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_SamplerState,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SamplerState,
    nullptr, // tp_members
    Dtool_Properties_SamplerState,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SamplerState,
    PyType_GenericAlloc,
    Dtool_new_SamplerState,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SamplerState,
  Dtool_UpcastInterface_SamplerState,
  Dtool_DowncastInterface_SamplerState,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SamplerState(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SamplerState._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(31);
    Dtool_SamplerState._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum SamplerState::FilterType;
    PyDict_SetItemString(dict, "FT_nearest", Dtool_WrapValue(SamplerState::FT_nearest));
    PyDict_SetItemString(dict, "FTNearest", Dtool_WrapValue(SamplerState::FT_nearest));
    PyDict_SetItemString(dict, "FT_linear", Dtool_WrapValue(SamplerState::FT_linear));
    PyDict_SetItemString(dict, "FTLinear", Dtool_WrapValue(SamplerState::FT_linear));
    PyDict_SetItemString(dict, "FT_nearest_mipmap_nearest", Dtool_WrapValue(SamplerState::FT_nearest_mipmap_nearest));
    PyDict_SetItemString(dict, "FTNearestMipmapNearest", Dtool_WrapValue(SamplerState::FT_nearest_mipmap_nearest));
    PyDict_SetItemString(dict, "FT_linear_mipmap_nearest", Dtool_WrapValue(SamplerState::FT_linear_mipmap_nearest));
    PyDict_SetItemString(dict, "FTLinearMipmapNearest", Dtool_WrapValue(SamplerState::FT_linear_mipmap_nearest));
    PyDict_SetItemString(dict, "FT_nearest_mipmap_linear", Dtool_WrapValue(SamplerState::FT_nearest_mipmap_linear));
    PyDict_SetItemString(dict, "FTNearestMipmapLinear", Dtool_WrapValue(SamplerState::FT_nearest_mipmap_linear));
    PyDict_SetItemString(dict, "FT_linear_mipmap_linear", Dtool_WrapValue(SamplerState::FT_linear_mipmap_linear));
    PyDict_SetItemString(dict, "FTLinearMipmapLinear", Dtool_WrapValue(SamplerState::FT_linear_mipmap_linear));
    PyDict_SetItemString(dict, "FT_shadow", Dtool_WrapValue(SamplerState::FT_shadow));
    PyDict_SetItemString(dict, "FTShadow", Dtool_WrapValue(SamplerState::FT_shadow));
    PyDict_SetItemString(dict, "FT_default", Dtool_WrapValue(SamplerState::FT_default));
    PyDict_SetItemString(dict, "FTDefault", Dtool_WrapValue(SamplerState::FT_default));
    PyDict_SetItemString(dict, "FT_invalid", Dtool_WrapValue(SamplerState::FT_invalid));
    PyDict_SetItemString(dict, "FTInvalid", Dtool_WrapValue(SamplerState::FT_invalid));
    // enum SamplerState::WrapMode;
    PyDict_SetItemString(dict, "WM_clamp", Dtool_WrapValue(SamplerState::WM_clamp));
    PyDict_SetItemString(dict, "WMClamp", Dtool_WrapValue(SamplerState::WM_clamp));
    PyDict_SetItemString(dict, "WM_repeat", Dtool_WrapValue(SamplerState::WM_repeat));
    PyDict_SetItemString(dict, "WMRepeat", Dtool_WrapValue(SamplerState::WM_repeat));
    PyDict_SetItemString(dict, "WM_mirror", Dtool_WrapValue(SamplerState::WM_mirror));
    PyDict_SetItemString(dict, "WMMirror", Dtool_WrapValue(SamplerState::WM_mirror));
    PyDict_SetItemString(dict, "WM_mirror_once", Dtool_WrapValue(SamplerState::WM_mirror_once));
    PyDict_SetItemString(dict, "WMMirrorOnce", Dtool_WrapValue(SamplerState::WM_mirror_once));
    PyDict_SetItemString(dict, "WM_border_color", Dtool_WrapValue(SamplerState::WM_border_color));
    PyDict_SetItemString(dict, "WMBorderColor", Dtool_WrapValue(SamplerState::WM_border_color));
    PyDict_SetItemString(dict, "WM_invalid", Dtool_WrapValue(SamplerState::WM_invalid));
    PyDict_SetItemString(dict, "WMInvalid", Dtool_WrapValue(SamplerState::WM_invalid));
    if (PyType_Ready((PyTypeObject *)&Dtool_SamplerState) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SamplerState)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SamplerState);
  }
}

/**
 * Python method tables for Texture (Texture)
 */
static PyMethodDef Dtool_Methods_Texture[] = {
  {"make_copy", &Dtool_Texture_make_copy_1202, METH_NOARGS, (const char *)Dtool_Texture_make_copy_1202_comment},
  {"makeCopy", &Dtool_Texture_make_copy_1202, METH_NOARGS, (const char *)Dtool_Texture_make_copy_1202_comment},
  {"clear", &Dtool_Texture_clear_1203, METH_NOARGS, (const char *)Dtool_Texture_clear_1203_comment},
  {"setup_texture", (PyCFunction) &Dtool_Texture_setup_texture_1204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_texture_1204_comment},
  {"setupTexture", (PyCFunction) &Dtool_Texture_setup_texture_1204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_texture_1204_comment},
  {"setup_1d_texture", (PyCFunction) &Dtool_Texture_setup_1d_texture_1205, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_1d_texture_1205_comment},
  {"setup1dTexture", (PyCFunction) &Dtool_Texture_setup_1d_texture_1205, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_1d_texture_1205_comment},
  {"setup_2d_texture", (PyCFunction) &Dtool_Texture_setup_2d_texture_1206, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_2d_texture_1206_comment},
  {"setup2dTexture", (PyCFunction) &Dtool_Texture_setup_2d_texture_1206, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_2d_texture_1206_comment},
  {"setup_3d_texture", (PyCFunction) &Dtool_Texture_setup_3d_texture_1207, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_3d_texture_1207_comment},
  {"setup3dTexture", (PyCFunction) &Dtool_Texture_setup_3d_texture_1207, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_3d_texture_1207_comment},
  {"setup_cube_map", (PyCFunction) &Dtool_Texture_setup_cube_map_1208, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_cube_map_1208_comment},
  {"setupCubeMap", (PyCFunction) &Dtool_Texture_setup_cube_map_1208, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_cube_map_1208_comment},
  {"setup_2d_texture_array", (PyCFunction) &Dtool_Texture_setup_2d_texture_array_1209, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_2d_texture_array_1209_comment},
  {"setup2dTextureArray", (PyCFunction) &Dtool_Texture_setup_2d_texture_array_1209, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_2d_texture_array_1209_comment},
  {"setup_cube_map_array", (PyCFunction) &Dtool_Texture_setup_cube_map_array_1210, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_cube_map_array_1210_comment},
  {"setupCubeMapArray", (PyCFunction) &Dtool_Texture_setup_cube_map_array_1210, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_cube_map_array_1210_comment},
  {"setup_buffer_texture", (PyCFunction) &Dtool_Texture_setup_buffer_texture_1211, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_buffer_texture_1211_comment},
  {"setupBufferTexture", (PyCFunction) &Dtool_Texture_setup_buffer_texture_1211, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_setup_buffer_texture_1211_comment},
  {"generate_normalization_cube_map", &Dtool_Texture_generate_normalization_cube_map_1212, METH_O, (const char *)Dtool_Texture_generate_normalization_cube_map_1212_comment},
  {"generateNormalizationCubeMap", &Dtool_Texture_generate_normalization_cube_map_1212, METH_O, (const char *)Dtool_Texture_generate_normalization_cube_map_1212_comment},
  {"generate_alpha_scale_map", &Dtool_Texture_generate_alpha_scale_map_1213, METH_NOARGS, (const char *)Dtool_Texture_generate_alpha_scale_map_1213_comment},
  {"generateAlphaScaleMap", &Dtool_Texture_generate_alpha_scale_map_1213, METH_NOARGS, (const char *)Dtool_Texture_generate_alpha_scale_map_1213_comment},
  {"clear_image", &Dtool_Texture_clear_image_1214, METH_NOARGS, (const char *)Dtool_Texture_clear_image_1214_comment},
  {"clearImage", &Dtool_Texture_clear_image_1214, METH_NOARGS, (const char *)Dtool_Texture_clear_image_1214_comment},
  {"has_clear_color", &Dtool_Texture_has_clear_color_1215, METH_NOARGS, (const char *)Dtool_Texture_has_clear_color_1215_comment},
  {"hasClearColor", &Dtool_Texture_has_clear_color_1215, METH_NOARGS, (const char *)Dtool_Texture_has_clear_color_1215_comment},
  {"get_clear_color", &Dtool_Texture_get_clear_color_1216, METH_NOARGS, (const char *)Dtool_Texture_get_clear_color_1216_comment},
  {"getClearColor", &Dtool_Texture_get_clear_color_1216, METH_NOARGS, (const char *)Dtool_Texture_get_clear_color_1216_comment},
  {"set_clear_color", &Dtool_Texture_set_clear_color_1217, METH_O, (const char *)Dtool_Texture_set_clear_color_1217_comment},
  {"setClearColor", &Dtool_Texture_set_clear_color_1217, METH_O, (const char *)Dtool_Texture_set_clear_color_1217_comment},
  {"clear_clear_color", &Dtool_Texture_clear_clear_color_1218, METH_NOARGS, (const char *)Dtool_Texture_clear_clear_color_1218_comment},
  {"clearClearColor", &Dtool_Texture_clear_clear_color_1218, METH_NOARGS, (const char *)Dtool_Texture_clear_clear_color_1218_comment},
  {"get_clear_data", &Dtool_Texture_get_clear_data_1219, METH_NOARGS, (const char *)Dtool_Texture_get_clear_data_1219_comment},
  {"getClearData", &Dtool_Texture_get_clear_data_1219, METH_NOARGS, (const char *)Dtool_Texture_get_clear_data_1219_comment},
  {"read", (PyCFunction) &Dtool_Texture_read_1221, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_read_1221_comment},
  {"write", (PyCFunction) &Dtool_Texture_write_1222, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_write_1222_comment},
  {"read_txo", (PyCFunction) &Dtool_Texture_read_txo_1223, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_read_txo_1223_comment},
  {"readTxo", (PyCFunction) &Dtool_Texture_read_txo_1223, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_read_txo_1223_comment},
  {"make_from_txo", (PyCFunction) &Dtool_Texture_make_from_txo_1224, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Texture_make_from_txo_1224_comment},
  {"makeFromTxo", (PyCFunction) &Dtool_Texture_make_from_txo_1224, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Texture_make_from_txo_1224_comment},
  {"write_txo", (PyCFunction) &Dtool_Texture_write_txo_1225, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_write_txo_1225_comment},
  {"writeTxo", (PyCFunction) &Dtool_Texture_write_txo_1225, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_write_txo_1225_comment},
  {"read_dds", (PyCFunction) &Dtool_Texture_read_dds_1226, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_read_dds_1226_comment},
  {"readDds", (PyCFunction) &Dtool_Texture_read_dds_1226, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_read_dds_1226_comment},
  {"read_ktx", (PyCFunction) &Dtool_Texture_read_ktx_1227, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_read_ktx_1227_comment},
  {"readKtx", (PyCFunction) &Dtool_Texture_read_ktx_1227, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_read_ktx_1227_comment},
  {"load", (PyCFunction) &Dtool_Texture_load_1228, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_load_1228_comment},
  {"load_sub_image", (PyCFunction) &Dtool_Texture_load_sub_image_1229, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_load_sub_image_1229_comment},
  {"loadSubImage", (PyCFunction) &Dtool_Texture_load_sub_image_1229, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_load_sub_image_1229_comment},
  {"store", (PyCFunction) &Dtool_Texture_store_1230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_store_1230_comment},
  {"reload", &Dtool_Texture_reload_1231, METH_NOARGS, (const char *)Dtool_Texture_reload_1231_comment},
  {"load_related", &Dtool_Texture_load_related_1232, METH_O, (const char *)Dtool_Texture_load_related_1232_comment},
  {"loadRelated", &Dtool_Texture_load_related_1232, METH_O, (const char *)Dtool_Texture_load_related_1232_comment},
  {"has_filename", &Dtool_Texture_has_filename_1233, METH_NOARGS, (const char *)Dtool_Texture_has_filename_1233_comment},
  {"hasFilename", &Dtool_Texture_has_filename_1233, METH_NOARGS, (const char *)Dtool_Texture_has_filename_1233_comment},
  {"get_filename", &Dtool_Texture_get_filename_1234, METH_NOARGS, (const char *)Dtool_Texture_get_filename_1234_comment},
  {"getFilename", &Dtool_Texture_get_filename_1234, METH_NOARGS, (const char *)Dtool_Texture_get_filename_1234_comment},
  {"set_filename", &Dtool_Texture_set_filename_1235, METH_O, (const char *)Dtool_Texture_set_filename_1235_comment},
  {"setFilename", &Dtool_Texture_set_filename_1235, METH_O, (const char *)Dtool_Texture_set_filename_1235_comment},
  {"clear_filename", &Dtool_Texture_clear_filename_1236, METH_NOARGS, (const char *)Dtool_Texture_clear_filename_1236_comment},
  {"clearFilename", &Dtool_Texture_clear_filename_1236, METH_NOARGS, (const char *)Dtool_Texture_clear_filename_1236_comment},
  {"has_alpha_filename", &Dtool_Texture_has_alpha_filename_1240, METH_NOARGS, (const char *)Dtool_Texture_has_alpha_filename_1240_comment},
  {"hasAlphaFilename", &Dtool_Texture_has_alpha_filename_1240, METH_NOARGS, (const char *)Dtool_Texture_has_alpha_filename_1240_comment},
  {"get_alpha_filename", &Dtool_Texture_get_alpha_filename_1241, METH_NOARGS, (const char *)Dtool_Texture_get_alpha_filename_1241_comment},
  {"getAlphaFilename", &Dtool_Texture_get_alpha_filename_1241, METH_NOARGS, (const char *)Dtool_Texture_get_alpha_filename_1241_comment},
  {"set_alpha_filename", &Dtool_Texture_set_alpha_filename_1242, METH_O, (const char *)Dtool_Texture_set_alpha_filename_1242_comment},
  {"setAlphaFilename", &Dtool_Texture_set_alpha_filename_1242, METH_O, (const char *)Dtool_Texture_set_alpha_filename_1242_comment},
  {"clear_alpha_filename", &Dtool_Texture_clear_alpha_filename_1243, METH_NOARGS, (const char *)Dtool_Texture_clear_alpha_filename_1243_comment},
  {"clearAlphaFilename", &Dtool_Texture_clear_alpha_filename_1243, METH_NOARGS, (const char *)Dtool_Texture_clear_alpha_filename_1243_comment},
  {"has_fullpath", &Dtool_Texture_has_fullpath_1245, METH_NOARGS, (const char *)Dtool_Texture_has_fullpath_1245_comment},
  {"hasFullpath", &Dtool_Texture_has_fullpath_1245, METH_NOARGS, (const char *)Dtool_Texture_has_fullpath_1245_comment},
  {"get_fullpath", &Dtool_Texture_get_fullpath_1246, METH_NOARGS, (const char *)Dtool_Texture_get_fullpath_1246_comment},
  {"getFullpath", &Dtool_Texture_get_fullpath_1246, METH_NOARGS, (const char *)Dtool_Texture_get_fullpath_1246_comment},
  {"set_fullpath", &Dtool_Texture_set_fullpath_1247, METH_O, (const char *)Dtool_Texture_set_fullpath_1247_comment},
  {"setFullpath", &Dtool_Texture_set_fullpath_1247, METH_O, (const char *)Dtool_Texture_set_fullpath_1247_comment},
  {"clear_fullpath", &Dtool_Texture_clear_fullpath_1248, METH_NOARGS, (const char *)Dtool_Texture_clear_fullpath_1248_comment},
  {"clearFullpath", &Dtool_Texture_clear_fullpath_1248, METH_NOARGS, (const char *)Dtool_Texture_clear_fullpath_1248_comment},
  {"has_alpha_fullpath", &Dtool_Texture_has_alpha_fullpath_1250, METH_NOARGS, (const char *)Dtool_Texture_has_alpha_fullpath_1250_comment},
  {"hasAlphaFullpath", &Dtool_Texture_has_alpha_fullpath_1250, METH_NOARGS, (const char *)Dtool_Texture_has_alpha_fullpath_1250_comment},
  {"get_alpha_fullpath", &Dtool_Texture_get_alpha_fullpath_1251, METH_NOARGS, (const char *)Dtool_Texture_get_alpha_fullpath_1251_comment},
  {"getAlphaFullpath", &Dtool_Texture_get_alpha_fullpath_1251, METH_NOARGS, (const char *)Dtool_Texture_get_alpha_fullpath_1251_comment},
  {"set_alpha_fullpath", &Dtool_Texture_set_alpha_fullpath_1252, METH_O, (const char *)Dtool_Texture_set_alpha_fullpath_1252_comment},
  {"setAlphaFullpath", &Dtool_Texture_set_alpha_fullpath_1252, METH_O, (const char *)Dtool_Texture_set_alpha_fullpath_1252_comment},
  {"clear_alpha_fullpath", &Dtool_Texture_clear_alpha_fullpath_1253, METH_NOARGS, (const char *)Dtool_Texture_clear_alpha_fullpath_1253_comment},
  {"clearAlphaFullpath", &Dtool_Texture_clear_alpha_fullpath_1253, METH_NOARGS, (const char *)Dtool_Texture_clear_alpha_fullpath_1253_comment},
  {"get_x_size", &Dtool_Texture_get_x_size_1255, METH_NOARGS, (const char *)Dtool_Texture_get_x_size_1255_comment},
  {"getXSize", &Dtool_Texture_get_x_size_1255, METH_NOARGS, (const char *)Dtool_Texture_get_x_size_1255_comment},
  {"set_x_size", &Dtool_Texture_set_x_size_1256, METH_O, (const char *)Dtool_Texture_set_x_size_1256_comment},
  {"setXSize", &Dtool_Texture_set_x_size_1256, METH_O, (const char *)Dtool_Texture_set_x_size_1256_comment},
  {"get_y_size", &Dtool_Texture_get_y_size_1258, METH_NOARGS, (const char *)Dtool_Texture_get_y_size_1258_comment},
  {"getYSize", &Dtool_Texture_get_y_size_1258, METH_NOARGS, (const char *)Dtool_Texture_get_y_size_1258_comment},
  {"set_y_size", &Dtool_Texture_set_y_size_1259, METH_O, (const char *)Dtool_Texture_set_y_size_1259_comment},
  {"setYSize", &Dtool_Texture_set_y_size_1259, METH_O, (const char *)Dtool_Texture_set_y_size_1259_comment},
  {"get_z_size", &Dtool_Texture_get_z_size_1261, METH_NOARGS, (const char *)Dtool_Texture_get_z_size_1261_comment},
  {"getZSize", &Dtool_Texture_get_z_size_1261, METH_NOARGS, (const char *)Dtool_Texture_get_z_size_1261_comment},
  {"set_z_size", &Dtool_Texture_set_z_size_1262, METH_O, (const char *)Dtool_Texture_set_z_size_1262_comment},
  {"setZSize", &Dtool_Texture_set_z_size_1262, METH_O, (const char *)Dtool_Texture_set_z_size_1262_comment},
  {"get_num_views", &Dtool_Texture_get_num_views_1264, METH_NOARGS, (const char *)Dtool_Texture_get_num_views_1264_comment},
  {"getNumViews", &Dtool_Texture_get_num_views_1264, METH_NOARGS, (const char *)Dtool_Texture_get_num_views_1264_comment},
  {"set_num_views", &Dtool_Texture_set_num_views_1265, METH_O, (const char *)Dtool_Texture_set_num_views_1265_comment},
  {"setNumViews", &Dtool_Texture_set_num_views_1265, METH_O, (const char *)Dtool_Texture_set_num_views_1265_comment},
  {"get_num_pages", &Dtool_Texture_get_num_pages_1267, METH_NOARGS, (const char *)Dtool_Texture_get_num_pages_1267_comment},
  {"getNumPages", &Dtool_Texture_get_num_pages_1267, METH_NOARGS, (const char *)Dtool_Texture_get_num_pages_1267_comment},
  {"get_num_components", &Dtool_Texture_get_num_components_1268, METH_NOARGS, (const char *)Dtool_Texture_get_num_components_1268_comment},
  {"getNumComponents", &Dtool_Texture_get_num_components_1268, METH_NOARGS, (const char *)Dtool_Texture_get_num_components_1268_comment},
  {"get_component_width", &Dtool_Texture_get_component_width_1269, METH_NOARGS, (const char *)Dtool_Texture_get_component_width_1269_comment},
  {"getComponentWidth", &Dtool_Texture_get_component_width_1269, METH_NOARGS, (const char *)Dtool_Texture_get_component_width_1269_comment},
  {"get_texture_type", &Dtool_Texture_get_texture_type_1270, METH_NOARGS, (const char *)Dtool_Texture_get_texture_type_1270_comment},
  {"getTextureType", &Dtool_Texture_get_texture_type_1270, METH_NOARGS, (const char *)Dtool_Texture_get_texture_type_1270_comment},
  {"get_usage_hint", &Dtool_Texture_get_usage_hint_1271, METH_NOARGS, (const char *)Dtool_Texture_get_usage_hint_1271_comment},
  {"getUsageHint", &Dtool_Texture_get_usage_hint_1271, METH_NOARGS, (const char *)Dtool_Texture_get_usage_hint_1271_comment},
  {"get_format", &Dtool_Texture_get_format_1277, METH_NOARGS, (const char *)Dtool_Texture_get_format_1277_comment},
  {"getFormat", &Dtool_Texture_get_format_1277, METH_NOARGS, (const char *)Dtool_Texture_get_format_1277_comment},
  {"set_format", &Dtool_Texture_set_format_1278, METH_O, (const char *)Dtool_Texture_set_format_1278_comment},
  {"setFormat", &Dtool_Texture_set_format_1278, METH_O, (const char *)Dtool_Texture_set_format_1278_comment},
  {"get_component_type", &Dtool_Texture_get_component_type_1280, METH_NOARGS, (const char *)Dtool_Texture_get_component_type_1280_comment},
  {"getComponentType", &Dtool_Texture_get_component_type_1280, METH_NOARGS, (const char *)Dtool_Texture_get_component_type_1280_comment},
  {"set_component_type", &Dtool_Texture_set_component_type_1281, METH_O, (const char *)Dtool_Texture_set_component_type_1281_comment},
  {"setComponentType", &Dtool_Texture_set_component_type_1281, METH_O, (const char *)Dtool_Texture_set_component_type_1281_comment},
  {"get_wrap_u", &Dtool_Texture_get_wrap_u_1283, METH_NOARGS, (const char *)Dtool_Texture_get_wrap_u_1283_comment},
  {"getWrapU", &Dtool_Texture_get_wrap_u_1283, METH_NOARGS, (const char *)Dtool_Texture_get_wrap_u_1283_comment},
  {"set_wrap_u", &Dtool_Texture_set_wrap_u_1284, METH_O, (const char *)Dtool_Texture_set_wrap_u_1284_comment},
  {"setWrapU", &Dtool_Texture_set_wrap_u_1284, METH_O, (const char *)Dtool_Texture_set_wrap_u_1284_comment},
  {"get_wrap_v", &Dtool_Texture_get_wrap_v_1286, METH_NOARGS, (const char *)Dtool_Texture_get_wrap_v_1286_comment},
  {"getWrapV", &Dtool_Texture_get_wrap_v_1286, METH_NOARGS, (const char *)Dtool_Texture_get_wrap_v_1286_comment},
  {"set_wrap_v", &Dtool_Texture_set_wrap_v_1287, METH_O, (const char *)Dtool_Texture_set_wrap_v_1287_comment},
  {"setWrapV", &Dtool_Texture_set_wrap_v_1287, METH_O, (const char *)Dtool_Texture_set_wrap_v_1287_comment},
  {"get_wrap_w", &Dtool_Texture_get_wrap_w_1289, METH_NOARGS, (const char *)Dtool_Texture_get_wrap_w_1289_comment},
  {"getWrapW", &Dtool_Texture_get_wrap_w_1289, METH_NOARGS, (const char *)Dtool_Texture_get_wrap_w_1289_comment},
  {"set_wrap_w", &Dtool_Texture_set_wrap_w_1290, METH_O, (const char *)Dtool_Texture_set_wrap_w_1290_comment},
  {"setWrapW", &Dtool_Texture_set_wrap_w_1290, METH_O, (const char *)Dtool_Texture_set_wrap_w_1290_comment},
  {"get_minfilter", &Dtool_Texture_get_minfilter_1292, METH_NOARGS, (const char *)Dtool_Texture_get_minfilter_1292_comment},
  {"getMinfilter", &Dtool_Texture_get_minfilter_1292, METH_NOARGS, (const char *)Dtool_Texture_get_minfilter_1292_comment},
  {"get_effective_minfilter", &Dtool_Texture_get_effective_minfilter_1293, METH_NOARGS, (const char *)Dtool_Texture_get_effective_minfilter_1293_comment},
  {"getEffectiveMinfilter", &Dtool_Texture_get_effective_minfilter_1293, METH_NOARGS, (const char *)Dtool_Texture_get_effective_minfilter_1293_comment},
  {"set_minfilter", &Dtool_Texture_set_minfilter_1294, METH_O, (const char *)Dtool_Texture_set_minfilter_1294_comment},
  {"setMinfilter", &Dtool_Texture_set_minfilter_1294, METH_O, (const char *)Dtool_Texture_set_minfilter_1294_comment},
  {"get_magfilter", &Dtool_Texture_get_magfilter_1297, METH_NOARGS, (const char *)Dtool_Texture_get_magfilter_1297_comment},
  {"getMagfilter", &Dtool_Texture_get_magfilter_1297, METH_NOARGS, (const char *)Dtool_Texture_get_magfilter_1297_comment},
  {"get_effective_magfilter", &Dtool_Texture_get_effective_magfilter_1298, METH_NOARGS, (const char *)Dtool_Texture_get_effective_magfilter_1298_comment},
  {"getEffectiveMagfilter", &Dtool_Texture_get_effective_magfilter_1298, METH_NOARGS, (const char *)Dtool_Texture_get_effective_magfilter_1298_comment},
  {"set_magfilter", &Dtool_Texture_set_magfilter_1299, METH_O, (const char *)Dtool_Texture_set_magfilter_1299_comment},
  {"setMagfilter", &Dtool_Texture_set_magfilter_1299, METH_O, (const char *)Dtool_Texture_set_magfilter_1299_comment},
  {"get_anisotropic_degree", &Dtool_Texture_get_anisotropic_degree_1302, METH_NOARGS, (const char *)Dtool_Texture_get_anisotropic_degree_1302_comment},
  {"getAnisotropicDegree", &Dtool_Texture_get_anisotropic_degree_1302, METH_NOARGS, (const char *)Dtool_Texture_get_anisotropic_degree_1302_comment},
  {"get_effective_anisotropic_degree", &Dtool_Texture_get_effective_anisotropic_degree_1303, METH_NOARGS, (const char *)Dtool_Texture_get_effective_anisotropic_degree_1303_comment},
  {"getEffectiveAnisotropicDegree", &Dtool_Texture_get_effective_anisotropic_degree_1303, METH_NOARGS, (const char *)Dtool_Texture_get_effective_anisotropic_degree_1303_comment},
  {"set_anisotropic_degree", &Dtool_Texture_set_anisotropic_degree_1304, METH_O, (const char *)Dtool_Texture_set_anisotropic_degree_1304_comment},
  {"setAnisotropicDegree", &Dtool_Texture_set_anisotropic_degree_1304, METH_O, (const char *)Dtool_Texture_set_anisotropic_degree_1304_comment},
  {"get_border_color", &Dtool_Texture_get_border_color_1307, METH_NOARGS, (const char *)Dtool_Texture_get_border_color_1307_comment},
  {"getBorderColor", &Dtool_Texture_get_border_color_1307, METH_NOARGS, (const char *)Dtool_Texture_get_border_color_1307_comment},
  {"set_border_color", &Dtool_Texture_set_border_color_1308, METH_O, (const char *)Dtool_Texture_set_border_color_1308_comment},
  {"setBorderColor", &Dtool_Texture_set_border_color_1308, METH_O, (const char *)Dtool_Texture_set_border_color_1308_comment},
  {"has_compression", &Dtool_Texture_has_compression_1310, METH_NOARGS, (const char *)Dtool_Texture_has_compression_1310_comment},
  {"hasCompression", &Dtool_Texture_has_compression_1310, METH_NOARGS, (const char *)Dtool_Texture_has_compression_1310_comment},
  {"get_compression", &Dtool_Texture_get_compression_1311, METH_NOARGS, (const char *)Dtool_Texture_get_compression_1311_comment},
  {"getCompression", &Dtool_Texture_get_compression_1311, METH_NOARGS, (const char *)Dtool_Texture_get_compression_1311_comment},
  {"set_compression", &Dtool_Texture_set_compression_1312, METH_O, (const char *)Dtool_Texture_set_compression_1312_comment},
  {"setCompression", &Dtool_Texture_set_compression_1312, METH_O, (const char *)Dtool_Texture_set_compression_1312_comment},
  {"get_render_to_texture", &Dtool_Texture_get_render_to_texture_1314, METH_NOARGS, (const char *)Dtool_Texture_get_render_to_texture_1314_comment},
  {"getRenderToTexture", &Dtool_Texture_get_render_to_texture_1314, METH_NOARGS, (const char *)Dtool_Texture_get_render_to_texture_1314_comment},
  {"set_render_to_texture", &Dtool_Texture_set_render_to_texture_1315, METH_O, (const char *)Dtool_Texture_set_render_to_texture_1315_comment},
  {"setRenderToTexture", &Dtool_Texture_set_render_to_texture_1315, METH_O, (const char *)Dtool_Texture_set_render_to_texture_1315_comment},
  {"get_default_sampler", &Dtool_Texture_get_default_sampler_1317, METH_NOARGS, (const char *)Dtool_Texture_get_default_sampler_1317_comment},
  {"getDefaultSampler", &Dtool_Texture_get_default_sampler_1317, METH_NOARGS, (const char *)Dtool_Texture_get_default_sampler_1317_comment},
  {"set_default_sampler", &Dtool_Texture_set_default_sampler_1318, METH_O, (const char *)Dtool_Texture_set_default_sampler_1318_comment},
  {"setDefaultSampler", &Dtool_Texture_set_default_sampler_1318, METH_O, (const char *)Dtool_Texture_set_default_sampler_1318_comment},
  {"uses_mipmaps", &Dtool_Texture_uses_mipmaps_1321, METH_NOARGS, (const char *)Dtool_Texture_uses_mipmaps_1321_comment},
  {"usesMipmaps", &Dtool_Texture_uses_mipmaps_1321, METH_NOARGS, (const char *)Dtool_Texture_uses_mipmaps_1321_comment},
  {"get_quality_level", &Dtool_Texture_get_quality_level_1322, METH_NOARGS, (const char *)Dtool_Texture_get_quality_level_1322_comment},
  {"getQualityLevel", &Dtool_Texture_get_quality_level_1322, METH_NOARGS, (const char *)Dtool_Texture_get_quality_level_1322_comment},
  {"get_effective_quality_level", &Dtool_Texture_get_effective_quality_level_1323, METH_NOARGS, (const char *)Dtool_Texture_get_effective_quality_level_1323_comment},
  {"getEffectiveQualityLevel", &Dtool_Texture_get_effective_quality_level_1323, METH_NOARGS, (const char *)Dtool_Texture_get_effective_quality_level_1323_comment},
  {"set_quality_level", &Dtool_Texture_set_quality_level_1324, METH_O, (const char *)Dtool_Texture_set_quality_level_1324_comment},
  {"setQualityLevel", &Dtool_Texture_set_quality_level_1324, METH_O, (const char *)Dtool_Texture_set_quality_level_1324_comment},
  {"get_expected_num_mipmap_levels", &Dtool_Texture_get_expected_num_mipmap_levels_1327, METH_NOARGS, (const char *)Dtool_Texture_get_expected_num_mipmap_levels_1327_comment},
  {"getExpectedNumMipmapLevels", &Dtool_Texture_get_expected_num_mipmap_levels_1327, METH_NOARGS, (const char *)Dtool_Texture_get_expected_num_mipmap_levels_1327_comment},
  {"get_expected_mipmap_x_size", &Dtool_Texture_get_expected_mipmap_x_size_1328, METH_O, (const char *)Dtool_Texture_get_expected_mipmap_x_size_1328_comment},
  {"getExpectedMipmapXSize", &Dtool_Texture_get_expected_mipmap_x_size_1328, METH_O, (const char *)Dtool_Texture_get_expected_mipmap_x_size_1328_comment},
  {"get_expected_mipmap_y_size", &Dtool_Texture_get_expected_mipmap_y_size_1329, METH_O, (const char *)Dtool_Texture_get_expected_mipmap_y_size_1329_comment},
  {"getExpectedMipmapYSize", &Dtool_Texture_get_expected_mipmap_y_size_1329, METH_O, (const char *)Dtool_Texture_get_expected_mipmap_y_size_1329_comment},
  {"get_expected_mipmap_z_size", &Dtool_Texture_get_expected_mipmap_z_size_1330, METH_O, (const char *)Dtool_Texture_get_expected_mipmap_z_size_1330_comment},
  {"getExpectedMipmapZSize", &Dtool_Texture_get_expected_mipmap_z_size_1330, METH_O, (const char *)Dtool_Texture_get_expected_mipmap_z_size_1330_comment},
  {"get_expected_mipmap_num_pages", &Dtool_Texture_get_expected_mipmap_num_pages_1331, METH_O, (const char *)Dtool_Texture_get_expected_mipmap_num_pages_1331_comment},
  {"getExpectedMipmapNumPages", &Dtool_Texture_get_expected_mipmap_num_pages_1331, METH_O, (const char *)Dtool_Texture_get_expected_mipmap_num_pages_1331_comment},
  {"has_ram_image", &Dtool_Texture_has_ram_image_1333, METH_NOARGS, (const char *)Dtool_Texture_has_ram_image_1333_comment},
  {"hasRamImage", &Dtool_Texture_has_ram_image_1333, METH_NOARGS, (const char *)Dtool_Texture_has_ram_image_1333_comment},
  {"has_uncompressed_ram_image", &Dtool_Texture_has_uncompressed_ram_image_1334, METH_NOARGS, (const char *)Dtool_Texture_has_uncompressed_ram_image_1334_comment},
  {"hasUncompressedRamImage", &Dtool_Texture_has_uncompressed_ram_image_1334, METH_NOARGS, (const char *)Dtool_Texture_has_uncompressed_ram_image_1334_comment},
  {"might_have_ram_image", &Dtool_Texture_might_have_ram_image_1335, METH_NOARGS, (const char *)Dtool_Texture_might_have_ram_image_1335_comment},
  {"mightHaveRamImage", &Dtool_Texture_might_have_ram_image_1335, METH_NOARGS, (const char *)Dtool_Texture_might_have_ram_image_1335_comment},
  {"get_ram_image_size", &Dtool_Texture_get_ram_image_size_1336, METH_NOARGS, (const char *)Dtool_Texture_get_ram_image_size_1336_comment},
  {"getRamImageSize", &Dtool_Texture_get_ram_image_size_1336, METH_NOARGS, (const char *)Dtool_Texture_get_ram_image_size_1336_comment},
  {"get_ram_view_size", &Dtool_Texture_get_ram_view_size_1337, METH_NOARGS, (const char *)Dtool_Texture_get_ram_view_size_1337_comment},
  {"getRamViewSize", &Dtool_Texture_get_ram_view_size_1337, METH_NOARGS, (const char *)Dtool_Texture_get_ram_view_size_1337_comment},
  {"get_ram_page_size", &Dtool_Texture_get_ram_page_size_1338, METH_NOARGS, (const char *)Dtool_Texture_get_ram_page_size_1338_comment},
  {"getRamPageSize", &Dtool_Texture_get_ram_page_size_1338, METH_NOARGS, (const char *)Dtool_Texture_get_ram_page_size_1338_comment},
  {"get_expected_ram_image_size", &Dtool_Texture_get_expected_ram_image_size_1339, METH_NOARGS, (const char *)Dtool_Texture_get_expected_ram_image_size_1339_comment},
  {"getExpectedRamImageSize", &Dtool_Texture_get_expected_ram_image_size_1339, METH_NOARGS, (const char *)Dtool_Texture_get_expected_ram_image_size_1339_comment},
  {"get_expected_ram_page_size", &Dtool_Texture_get_expected_ram_page_size_1340, METH_NOARGS, (const char *)Dtool_Texture_get_expected_ram_page_size_1340_comment},
  {"getExpectedRamPageSize", &Dtool_Texture_get_expected_ram_page_size_1340, METH_NOARGS, (const char *)Dtool_Texture_get_expected_ram_page_size_1340_comment},
  {"get_ram_image", &Dtool_Texture_get_ram_image_1346, METH_NOARGS, (const char *)Dtool_Texture_get_ram_image_1346_comment},
  {"getRamImage", &Dtool_Texture_get_ram_image_1346, METH_NOARGS, (const char *)Dtool_Texture_get_ram_image_1346_comment},
  {"get_ram_image_compression", &Dtool_Texture_get_ram_image_compression_1347, METH_NOARGS, (const char *)Dtool_Texture_get_ram_image_compression_1347_comment},
  {"getRamImageCompression", &Dtool_Texture_get_ram_image_compression_1347, METH_NOARGS, (const char *)Dtool_Texture_get_ram_image_compression_1347_comment},
  {"get_uncompressed_ram_image", &Dtool_Texture_get_uncompressed_ram_image_1348, METH_NOARGS, (const char *)Dtool_Texture_get_uncompressed_ram_image_1348_comment},
  {"getUncompressedRamImage", &Dtool_Texture_get_uncompressed_ram_image_1348, METH_NOARGS, (const char *)Dtool_Texture_get_uncompressed_ram_image_1348_comment},
  {"get_ram_image_as", &Dtool_Texture_get_ram_image_as_1349, METH_O, (const char *)Dtool_Texture_get_ram_image_as_1349_comment},
  {"getRamImageAs", &Dtool_Texture_get_ram_image_as_1349, METH_O, (const char *)Dtool_Texture_get_ram_image_as_1349_comment},
  {"modify_ram_image", &Dtool_Texture_modify_ram_image_1350, METH_NOARGS, (const char *)Dtool_Texture_modify_ram_image_1350_comment},
  {"modifyRamImage", &Dtool_Texture_modify_ram_image_1350, METH_NOARGS, (const char *)Dtool_Texture_modify_ram_image_1350_comment},
  {"make_ram_image", &Dtool_Texture_make_ram_image_1351, METH_NOARGS, (const char *)Dtool_Texture_make_ram_image_1351_comment},
  {"makeRamImage", &Dtool_Texture_make_ram_image_1351, METH_NOARGS, (const char *)Dtool_Texture_make_ram_image_1351_comment},
  {"set_ram_image", (PyCFunction) &Dtool_Texture_set_ram_image_1352, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_ram_image_1352_comment},
  {"setRamImage", (PyCFunction) &Dtool_Texture_set_ram_image_1352, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_ram_image_1352_comment},
  {"set_ram_image_as", (PyCFunction) &Dtool_Texture_set_ram_image_as_1353, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_ram_image_as_1353_comment},
  {"setRamImageAs", (PyCFunction) &Dtool_Texture_set_ram_image_as_1353, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_ram_image_as_1353_comment},
  {"clear_ram_image", &Dtool_Texture_clear_ram_image_1354, METH_NOARGS, (const char *)Dtool_Texture_clear_ram_image_1354_comment},
  {"clearRamImage", &Dtool_Texture_clear_ram_image_1354, METH_NOARGS, (const char *)Dtool_Texture_clear_ram_image_1354_comment},
  {"set_keep_ram_image", &Dtool_Texture_set_keep_ram_image_1355, METH_O, (const char *)Dtool_Texture_set_keep_ram_image_1355_comment},
  {"setKeepRamImage", &Dtool_Texture_set_keep_ram_image_1355, METH_O, (const char *)Dtool_Texture_set_keep_ram_image_1355_comment},
  {"get_keep_ram_image", &Dtool_Texture_get_keep_ram_image_1356, METH_NOARGS, (const char *)Dtool_Texture_get_keep_ram_image_1356_comment},
  {"getKeepRamImage", &Dtool_Texture_get_keep_ram_image_1356, METH_NOARGS, (const char *)Dtool_Texture_get_keep_ram_image_1356_comment},
  {"is_cacheable", &Dtool_Texture_is_cacheable_1357, METH_NOARGS, (const char *)Dtool_Texture_is_cacheable_1357_comment},
  {"isCacheable", &Dtool_Texture_is_cacheable_1357, METH_NOARGS, (const char *)Dtool_Texture_is_cacheable_1357_comment},
  {"compress_ram_image", (PyCFunction) &Dtool_Texture_compress_ram_image_1361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_compress_ram_image_1361_comment},
  {"compressRamImage", (PyCFunction) &Dtool_Texture_compress_ram_image_1361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_compress_ram_image_1361_comment},
  {"uncompress_ram_image", &Dtool_Texture_uncompress_ram_image_1362, METH_NOARGS, (const char *)Dtool_Texture_uncompress_ram_image_1362_comment},
  {"uncompressRamImage", &Dtool_Texture_uncompress_ram_image_1362, METH_NOARGS, (const char *)Dtool_Texture_uncompress_ram_image_1362_comment},
  {"get_num_ram_mipmap_images", &Dtool_Texture_get_num_ram_mipmap_images_1363, METH_NOARGS, (const char *)Dtool_Texture_get_num_ram_mipmap_images_1363_comment},
  {"getNumRamMipmapImages", &Dtool_Texture_get_num_ram_mipmap_images_1363, METH_NOARGS, (const char *)Dtool_Texture_get_num_ram_mipmap_images_1363_comment},
  {"has_ram_mipmap_image", &Dtool_Texture_has_ram_mipmap_image_1364, METH_O, (const char *)Dtool_Texture_has_ram_mipmap_image_1364_comment},
  {"hasRamMipmapImage", &Dtool_Texture_has_ram_mipmap_image_1364, METH_O, (const char *)Dtool_Texture_has_ram_mipmap_image_1364_comment},
  {"get_num_loadable_ram_mipmap_images", &Dtool_Texture_get_num_loadable_ram_mipmap_images_1365, METH_NOARGS, (const char *)Dtool_Texture_get_num_loadable_ram_mipmap_images_1365_comment},
  {"getNumLoadableRamMipmapImages", &Dtool_Texture_get_num_loadable_ram_mipmap_images_1365, METH_NOARGS, (const char *)Dtool_Texture_get_num_loadable_ram_mipmap_images_1365_comment},
  {"has_all_ram_mipmap_images", &Dtool_Texture_has_all_ram_mipmap_images_1366, METH_NOARGS, (const char *)Dtool_Texture_has_all_ram_mipmap_images_1366_comment},
  {"hasAllRamMipmapImages", &Dtool_Texture_has_all_ram_mipmap_images_1366, METH_NOARGS, (const char *)Dtool_Texture_has_all_ram_mipmap_images_1366_comment},
  {"get_ram_mipmap_image_size", &Dtool_Texture_get_ram_mipmap_image_size_1367, METH_O, (const char *)Dtool_Texture_get_ram_mipmap_image_size_1367_comment},
  {"getRamMipmapImageSize", &Dtool_Texture_get_ram_mipmap_image_size_1367, METH_O, (const char *)Dtool_Texture_get_ram_mipmap_image_size_1367_comment},
  {"get_ram_mipmap_view_size", &Dtool_Texture_get_ram_mipmap_view_size_1368, METH_O, (const char *)Dtool_Texture_get_ram_mipmap_view_size_1368_comment},
  {"getRamMipmapViewSize", &Dtool_Texture_get_ram_mipmap_view_size_1368, METH_O, (const char *)Dtool_Texture_get_ram_mipmap_view_size_1368_comment},
  {"get_ram_mipmap_page_size", &Dtool_Texture_get_ram_mipmap_page_size_1369, METH_O, (const char *)Dtool_Texture_get_ram_mipmap_page_size_1369_comment},
  {"getRamMipmapPageSize", &Dtool_Texture_get_ram_mipmap_page_size_1369, METH_O, (const char *)Dtool_Texture_get_ram_mipmap_page_size_1369_comment},
  {"get_expected_ram_mipmap_image_size", &Dtool_Texture_get_expected_ram_mipmap_image_size_1370, METH_O, (const char *)Dtool_Texture_get_expected_ram_mipmap_image_size_1370_comment},
  {"getExpectedRamMipmapImageSize", &Dtool_Texture_get_expected_ram_mipmap_image_size_1370, METH_O, (const char *)Dtool_Texture_get_expected_ram_mipmap_image_size_1370_comment},
  {"get_expected_ram_mipmap_view_size", &Dtool_Texture_get_expected_ram_mipmap_view_size_1371, METH_O, (const char *)Dtool_Texture_get_expected_ram_mipmap_view_size_1371_comment},
  {"getExpectedRamMipmapViewSize", &Dtool_Texture_get_expected_ram_mipmap_view_size_1371, METH_O, (const char *)Dtool_Texture_get_expected_ram_mipmap_view_size_1371_comment},
  {"get_expected_ram_mipmap_page_size", &Dtool_Texture_get_expected_ram_mipmap_page_size_1372, METH_O, (const char *)Dtool_Texture_get_expected_ram_mipmap_page_size_1372_comment},
  {"getExpectedRamMipmapPageSize", &Dtool_Texture_get_expected_ram_mipmap_page_size_1372, METH_O, (const char *)Dtool_Texture_get_expected_ram_mipmap_page_size_1372_comment},
  {"get_ram_mipmap_image", &Dtool_Texture_get_ram_mipmap_image_1373, METH_O, (const char *)Dtool_Texture_get_ram_mipmap_image_1373_comment},
  {"getRamMipmapImage", &Dtool_Texture_get_ram_mipmap_image_1373, METH_O, (const char *)Dtool_Texture_get_ram_mipmap_image_1373_comment},
  {"modify_ram_mipmap_image", &Dtool_Texture_modify_ram_mipmap_image_1375, METH_O, (const char *)Dtool_Texture_modify_ram_mipmap_image_1375_comment},
  {"modifyRamMipmapImage", &Dtool_Texture_modify_ram_mipmap_image_1375, METH_O, (const char *)Dtool_Texture_modify_ram_mipmap_image_1375_comment},
  {"make_ram_mipmap_image", &Dtool_Texture_make_ram_mipmap_image_1376, METH_O, (const char *)Dtool_Texture_make_ram_mipmap_image_1376_comment},
  {"makeRamMipmapImage", &Dtool_Texture_make_ram_mipmap_image_1376, METH_O, (const char *)Dtool_Texture_make_ram_mipmap_image_1376_comment},
  {"set_ram_mipmap_pointer_from_int", (PyCFunction) &Dtool_Texture_set_ram_mipmap_pointer_from_int_1378, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_ram_mipmap_pointer_from_int_1378_comment},
  {"setRamMipmapPointerFromInt", (PyCFunction) &Dtool_Texture_set_ram_mipmap_pointer_from_int_1378, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_ram_mipmap_pointer_from_int_1378_comment},
  {"set_ram_mipmap_image", (PyCFunction) &Dtool_Texture_set_ram_mipmap_image_1379, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_ram_mipmap_image_1379_comment},
  {"setRamMipmapImage", (PyCFunction) &Dtool_Texture_set_ram_mipmap_image_1379, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_ram_mipmap_image_1379_comment},
  {"clear_ram_mipmap_image", &Dtool_Texture_clear_ram_mipmap_image_1380, METH_O, (const char *)Dtool_Texture_clear_ram_mipmap_image_1380_comment},
  {"clearRamMipmapImage", &Dtool_Texture_clear_ram_mipmap_image_1380, METH_O, (const char *)Dtool_Texture_clear_ram_mipmap_image_1380_comment},
  {"clear_ram_mipmap_images", &Dtool_Texture_clear_ram_mipmap_images_1381, METH_NOARGS, (const char *)Dtool_Texture_clear_ram_mipmap_images_1381_comment},
  {"clearRamMipmapImages", &Dtool_Texture_clear_ram_mipmap_images_1381, METH_NOARGS, (const char *)Dtool_Texture_clear_ram_mipmap_images_1381_comment},
  {"generate_ram_mipmap_images", &Dtool_Texture_generate_ram_mipmap_images_1382, METH_NOARGS, (const char *)Dtool_Texture_generate_ram_mipmap_images_1382_comment},
  {"generateRamMipmapImages", &Dtool_Texture_generate_ram_mipmap_images_1382, METH_NOARGS, (const char *)Dtool_Texture_generate_ram_mipmap_images_1382_comment},
  {"get_simple_x_size", &Dtool_Texture_get_simple_x_size_1385, METH_NOARGS, (const char *)Dtool_Texture_get_simple_x_size_1385_comment},
  {"getSimpleXSize", &Dtool_Texture_get_simple_x_size_1385, METH_NOARGS, (const char *)Dtool_Texture_get_simple_x_size_1385_comment},
  {"get_simple_y_size", &Dtool_Texture_get_simple_y_size_1386, METH_NOARGS, (const char *)Dtool_Texture_get_simple_y_size_1386_comment},
  {"getSimpleYSize", &Dtool_Texture_get_simple_y_size_1386, METH_NOARGS, (const char *)Dtool_Texture_get_simple_y_size_1386_comment},
  {"has_simple_ram_image", &Dtool_Texture_has_simple_ram_image_1387, METH_NOARGS, (const char *)Dtool_Texture_has_simple_ram_image_1387_comment},
  {"hasSimpleRamImage", &Dtool_Texture_has_simple_ram_image_1387, METH_NOARGS, (const char *)Dtool_Texture_has_simple_ram_image_1387_comment},
  {"get_simple_ram_image_size", &Dtool_Texture_get_simple_ram_image_size_1388, METH_NOARGS, (const char *)Dtool_Texture_get_simple_ram_image_size_1388_comment},
  {"getSimpleRamImageSize", &Dtool_Texture_get_simple_ram_image_size_1388, METH_NOARGS, (const char *)Dtool_Texture_get_simple_ram_image_size_1388_comment},
  {"get_simple_ram_image", &Dtool_Texture_get_simple_ram_image_1389, METH_NOARGS, (const char *)Dtool_Texture_get_simple_ram_image_1389_comment},
  {"getSimpleRamImage", &Dtool_Texture_get_simple_ram_image_1389, METH_NOARGS, (const char *)Dtool_Texture_get_simple_ram_image_1389_comment},
  {"set_simple_ram_image", (PyCFunction) &Dtool_Texture_set_simple_ram_image_1390, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_simple_ram_image_1390_comment},
  {"setSimpleRamImage", (PyCFunction) &Dtool_Texture_set_simple_ram_image_1390, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_simple_ram_image_1390_comment},
  {"modify_simple_ram_image", &Dtool_Texture_modify_simple_ram_image_1391, METH_NOARGS, (const char *)Dtool_Texture_modify_simple_ram_image_1391_comment},
  {"modifySimpleRamImage", &Dtool_Texture_modify_simple_ram_image_1391, METH_NOARGS, (const char *)Dtool_Texture_modify_simple_ram_image_1391_comment},
  {"new_simple_ram_image", (PyCFunction) &Dtool_Texture_new_simple_ram_image_1392, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_new_simple_ram_image_1392_comment},
  {"newSimpleRamImage", (PyCFunction) &Dtool_Texture_new_simple_ram_image_1392, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_new_simple_ram_image_1392_comment},
  {"generate_simple_ram_image", &Dtool_Texture_generate_simple_ram_image_1393, METH_NOARGS, (const char *)Dtool_Texture_generate_simple_ram_image_1393_comment},
  {"generateSimpleRamImage", &Dtool_Texture_generate_simple_ram_image_1393, METH_NOARGS, (const char *)Dtool_Texture_generate_simple_ram_image_1393_comment},
  {"clear_simple_ram_image", &Dtool_Texture_clear_simple_ram_image_1394, METH_NOARGS, (const char *)Dtool_Texture_clear_simple_ram_image_1394_comment},
  {"clearSimpleRamImage", &Dtool_Texture_clear_simple_ram_image_1394, METH_NOARGS, (const char *)Dtool_Texture_clear_simple_ram_image_1394_comment},
  {"peek", &Dtool_Texture_peek_1400, METH_NOARGS, (const char *)Dtool_Texture_peek_1400_comment},
  {"get_properties_modified", &Dtool_Texture_get_properties_modified_1401, METH_NOARGS, (const char *)Dtool_Texture_get_properties_modified_1401_comment},
  {"getPropertiesModified", &Dtool_Texture_get_properties_modified_1401, METH_NOARGS, (const char *)Dtool_Texture_get_properties_modified_1401_comment},
  {"get_image_modified", &Dtool_Texture_get_image_modified_1402, METH_NOARGS, (const char *)Dtool_Texture_get_image_modified_1402_comment},
  {"getImageModified", &Dtool_Texture_get_image_modified_1402, METH_NOARGS, (const char *)Dtool_Texture_get_image_modified_1402_comment},
  {"get_simple_image_modified", &Dtool_Texture_get_simple_image_modified_1403, METH_NOARGS, (const char *)Dtool_Texture_get_simple_image_modified_1403_comment},
  {"getSimpleImageModified", &Dtool_Texture_get_simple_image_modified_1403, METH_NOARGS, (const char *)Dtool_Texture_get_simple_image_modified_1403_comment},
  {"has_auto_texture_scale", &Dtool_Texture_has_auto_texture_scale_1407, METH_NOARGS, (const char *)Dtool_Texture_has_auto_texture_scale_1407_comment},
  {"hasAutoTextureScale", &Dtool_Texture_has_auto_texture_scale_1407, METH_NOARGS, (const char *)Dtool_Texture_has_auto_texture_scale_1407_comment},
  {"get_auto_texture_scale", &Dtool_Texture_get_auto_texture_scale_1408, METH_NOARGS, (const char *)Dtool_Texture_get_auto_texture_scale_1408_comment},
  {"getAutoTextureScale", &Dtool_Texture_get_auto_texture_scale_1408, METH_NOARGS, (const char *)Dtool_Texture_get_auto_texture_scale_1408_comment},
  {"set_auto_texture_scale", &Dtool_Texture_set_auto_texture_scale_1409, METH_O, (const char *)Dtool_Texture_set_auto_texture_scale_1409_comment},
  {"setAutoTextureScale", &Dtool_Texture_set_auto_texture_scale_1409, METH_O, (const char *)Dtool_Texture_set_auto_texture_scale_1409_comment},
  {"prepare", &Dtool_Texture_prepare_1412, METH_O, (const char *)Dtool_Texture_prepare_1412_comment},
  {"is_prepared", &Dtool_Texture_is_prepared_1413, METH_O, (const char *)Dtool_Texture_is_prepared_1413_comment},
  {"isPrepared", &Dtool_Texture_is_prepared_1413, METH_O, (const char *)Dtool_Texture_is_prepared_1413_comment},
  {"was_image_modified", &Dtool_Texture_was_image_modified_1414, METH_O, (const char *)Dtool_Texture_was_image_modified_1414_comment},
  {"wasImageModified", &Dtool_Texture_was_image_modified_1414, METH_O, (const char *)Dtool_Texture_was_image_modified_1414_comment},
  {"get_data_size_bytes", &Dtool_Texture_get_data_size_bytes_1415, METH_O, (const char *)Dtool_Texture_get_data_size_bytes_1415_comment},
  {"getDataSizeBytes", &Dtool_Texture_get_data_size_bytes_1415, METH_O, (const char *)Dtool_Texture_get_data_size_bytes_1415_comment},
  {"get_active", &Dtool_Texture_get_active_1416, METH_O, (const char *)Dtool_Texture_get_active_1416_comment},
  {"getActive", &Dtool_Texture_get_active_1416, METH_O, (const char *)Dtool_Texture_get_active_1416_comment},
  {"get_resident", &Dtool_Texture_get_resident_1417, METH_O, (const char *)Dtool_Texture_get_resident_1417_comment},
  {"getResident", &Dtool_Texture_get_resident_1417, METH_O, (const char *)Dtool_Texture_get_resident_1417_comment},
  {"release", &Dtool_Texture_release_1418, METH_O, (const char *)Dtool_Texture_release_1418_comment},
  {"release_all", &Dtool_Texture_release_all_1419, METH_NOARGS, (const char *)Dtool_Texture_release_all_1419_comment},
  {"releaseAll", &Dtool_Texture_release_all_1419, METH_NOARGS, (const char *)Dtool_Texture_release_all_1419_comment},
  {"estimate_texture_memory", &Dtool_Texture_estimate_texture_memory_1420, METH_NOARGS, (const char *)Dtool_Texture_estimate_texture_memory_1420_comment},
  {"estimateTextureMemory", &Dtool_Texture_estimate_texture_memory_1420, METH_NOARGS, (const char *)Dtool_Texture_estimate_texture_memory_1420_comment},
  {"set_aux_data", (PyCFunction) &Dtool_Texture_set_aux_data_1421, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_aux_data_1421_comment},
  {"setAuxData", (PyCFunction) &Dtool_Texture_set_aux_data_1421, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_aux_data_1421_comment},
  {"clear_aux_data", &Dtool_Texture_clear_aux_data_1422, METH_O, (const char *)Dtool_Texture_clear_aux_data_1422_comment},
  {"clearAuxData", &Dtool_Texture_clear_aux_data_1422, METH_O, (const char *)Dtool_Texture_clear_aux_data_1422_comment},
  {"get_aux_data", &Dtool_Texture_get_aux_data_1423, METH_O, (const char *)Dtool_Texture_get_aux_data_1423_comment},
  {"getAuxData", &Dtool_Texture_get_aux_data_1423, METH_O, (const char *)Dtool_Texture_get_aux_data_1423_comment},
  {"set_textures_power_2", &Dtool_Texture_set_textures_power_2_1427, METH_O | METH_STATIC, (const char *)Dtool_Texture_set_textures_power_2_1427_comment},
  {"setTexturesPower2", &Dtool_Texture_set_textures_power_2_1427, METH_O | METH_STATIC, (const char *)Dtool_Texture_set_textures_power_2_1427_comment},
  {"get_textures_power_2", &Dtool_Texture_get_textures_power_2_1428, METH_NOARGS | METH_STATIC, (const char *)Dtool_Texture_get_textures_power_2_1428_comment},
  {"getTexturesPower2", &Dtool_Texture_get_textures_power_2_1428, METH_NOARGS | METH_STATIC, (const char *)Dtool_Texture_get_textures_power_2_1428_comment},
  {"has_textures_power_2", &Dtool_Texture_has_textures_power_2_1429, METH_NOARGS | METH_STATIC, (const char *)Dtool_Texture_has_textures_power_2_1429_comment},
  {"hasTexturesPower2", &Dtool_Texture_has_textures_power_2_1429, METH_NOARGS | METH_STATIC, (const char *)Dtool_Texture_has_textures_power_2_1429_comment},
  {"get_pad_x_size", &Dtool_Texture_get_pad_x_size_1430, METH_NOARGS, (const char *)Dtool_Texture_get_pad_x_size_1430_comment},
  {"getPadXSize", &Dtool_Texture_get_pad_x_size_1430, METH_NOARGS, (const char *)Dtool_Texture_get_pad_x_size_1430_comment},
  {"get_pad_y_size", &Dtool_Texture_get_pad_y_size_1431, METH_NOARGS, (const char *)Dtool_Texture_get_pad_y_size_1431_comment},
  {"getPadYSize", &Dtool_Texture_get_pad_y_size_1431, METH_NOARGS, (const char *)Dtool_Texture_get_pad_y_size_1431_comment},
  {"get_pad_z_size", &Dtool_Texture_get_pad_z_size_1432, METH_NOARGS, (const char *)Dtool_Texture_get_pad_z_size_1432_comment},
  {"getPadZSize", &Dtool_Texture_get_pad_z_size_1432, METH_NOARGS, (const char *)Dtool_Texture_get_pad_z_size_1432_comment},
  {"get_tex_scale", &Dtool_Texture_get_tex_scale_1433, METH_NOARGS, (const char *)Dtool_Texture_get_tex_scale_1433_comment},
  {"getTexScale", &Dtool_Texture_get_tex_scale_1433, METH_NOARGS, (const char *)Dtool_Texture_get_tex_scale_1433_comment},
  {"set_pad_size", (PyCFunction) &Dtool_Texture_set_pad_size_1434, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_pad_size_1434_comment},
  {"setPadSize", (PyCFunction) &Dtool_Texture_set_pad_size_1434, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_pad_size_1434_comment},
  {"set_size_padded", (PyCFunction) &Dtool_Texture_set_size_padded_1435, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_size_padded_1435_comment},
  {"setSizePadded", (PyCFunction) &Dtool_Texture_set_size_padded_1435, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_size_padded_1435_comment},
  {"get_orig_file_x_size", &Dtool_Texture_get_orig_file_x_size_1436, METH_NOARGS, (const char *)Dtool_Texture_get_orig_file_x_size_1436_comment},
  {"getOrigFileXSize", &Dtool_Texture_get_orig_file_x_size_1436, METH_NOARGS, (const char *)Dtool_Texture_get_orig_file_x_size_1436_comment},
  {"get_orig_file_y_size", &Dtool_Texture_get_orig_file_y_size_1437, METH_NOARGS, (const char *)Dtool_Texture_get_orig_file_y_size_1437_comment},
  {"getOrigFileYSize", &Dtool_Texture_get_orig_file_y_size_1437, METH_NOARGS, (const char *)Dtool_Texture_get_orig_file_y_size_1437_comment},
  {"get_orig_file_z_size", &Dtool_Texture_get_orig_file_z_size_1438, METH_NOARGS, (const char *)Dtool_Texture_get_orig_file_z_size_1438_comment},
  {"getOrigFileZSize", &Dtool_Texture_get_orig_file_z_size_1438, METH_NOARGS, (const char *)Dtool_Texture_get_orig_file_z_size_1438_comment},
  {"set_orig_file_size", (PyCFunction) &Dtool_Texture_set_orig_file_size_1442, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_orig_file_size_1442_comment},
  {"setOrigFileSize", (PyCFunction) &Dtool_Texture_set_orig_file_size_1442, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_orig_file_size_1442_comment},
  {"set_loaded_from_image", (PyCFunction) &Dtool_Texture_set_loaded_from_image_1443, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_loaded_from_image_1443_comment},
  {"setLoadedFromImage", (PyCFunction) &Dtool_Texture_set_loaded_from_image_1443, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_loaded_from_image_1443_comment},
  {"get_loaded_from_image", &Dtool_Texture_get_loaded_from_image_1444, METH_NOARGS, (const char *)Dtool_Texture_get_loaded_from_image_1444_comment},
  {"getLoadedFromImage", &Dtool_Texture_get_loaded_from_image_1444, METH_NOARGS, (const char *)Dtool_Texture_get_loaded_from_image_1444_comment},
  {"set_loaded_from_txo", (PyCFunction) &Dtool_Texture_set_loaded_from_txo_1446, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_loaded_from_txo_1446_comment},
  {"setLoadedFromTxo", (PyCFunction) &Dtool_Texture_set_loaded_from_txo_1446, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_set_loaded_from_txo_1446_comment},
  {"get_loaded_from_txo", &Dtool_Texture_get_loaded_from_txo_1447, METH_NOARGS, (const char *)Dtool_Texture_get_loaded_from_txo_1447_comment},
  {"getLoadedFromTxo", &Dtool_Texture_get_loaded_from_txo_1447, METH_NOARGS, (const char *)Dtool_Texture_get_loaded_from_txo_1447_comment},
  {"get_match_framebuffer_format", &Dtool_Texture_get_match_framebuffer_format_1449, METH_NOARGS, (const char *)Dtool_Texture_get_match_framebuffer_format_1449_comment},
  {"getMatchFramebufferFormat", &Dtool_Texture_get_match_framebuffer_format_1449, METH_NOARGS, (const char *)Dtool_Texture_get_match_framebuffer_format_1449_comment},
  {"set_match_framebuffer_format", &Dtool_Texture_set_match_framebuffer_format_1450, METH_O, (const char *)Dtool_Texture_set_match_framebuffer_format_1450_comment},
  {"setMatchFramebufferFormat", &Dtool_Texture_set_match_framebuffer_format_1450, METH_O, (const char *)Dtool_Texture_set_match_framebuffer_format_1450_comment},
  {"get_post_load_store_cache", &Dtool_Texture_get_post_load_store_cache_1452, METH_NOARGS, (const char *)Dtool_Texture_get_post_load_store_cache_1452_comment},
  {"getPostLoadStoreCache", &Dtool_Texture_get_post_load_store_cache_1452, METH_NOARGS, (const char *)Dtool_Texture_get_post_load_store_cache_1452_comment},
  {"set_post_load_store_cache", &Dtool_Texture_set_post_load_store_cache_1453, METH_O, (const char *)Dtool_Texture_set_post_load_store_cache_1453_comment},
  {"setPostLoadStoreCache", &Dtool_Texture_set_post_load_store_cache_1453, METH_O, (const char *)Dtool_Texture_set_post_load_store_cache_1453_comment},
  {"prepare_now", (PyCFunction) &Dtool_Texture_prepare_now_1455, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_prepare_now_1455_comment},
  {"prepareNow", (PyCFunction) &Dtool_Texture_prepare_now_1455, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_prepare_now_1455_comment},
  {"up_to_power_2", &Dtool_Texture_up_to_power_2_1456, METH_O | METH_STATIC, (const char *)Dtool_Texture_up_to_power_2_1456_comment},
  {"upToPower2", &Dtool_Texture_up_to_power_2_1456, METH_O | METH_STATIC, (const char *)Dtool_Texture_up_to_power_2_1456_comment},
  {"down_to_power_2", &Dtool_Texture_down_to_power_2_1457, METH_O | METH_STATIC, (const char *)Dtool_Texture_down_to_power_2_1457_comment},
  {"downToPower2", &Dtool_Texture_down_to_power_2_1457, METH_O | METH_STATIC, (const char *)Dtool_Texture_down_to_power_2_1457_comment},
  {"consider_rescale", (PyCFunction) &Dtool_Texture_consider_rescale_1458, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_consider_rescale_1458_comment},
  {"considerRescale", (PyCFunction) &Dtool_Texture_consider_rescale_1458, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Texture_consider_rescale_1458_comment},
  {"rescale_texture", &Dtool_Texture_rescale_texture_1459, METH_NOARGS, (const char *)Dtool_Texture_rescale_texture_1459_comment},
  {"rescaleTexture", &Dtool_Texture_rescale_texture_1459, METH_NOARGS, (const char *)Dtool_Texture_rescale_texture_1459_comment},
  {"format_texture_type", &Dtool_Texture_format_texture_type_1460, METH_O | METH_STATIC, (const char *)Dtool_Texture_format_texture_type_1460_comment},
  {"formatTextureType", &Dtool_Texture_format_texture_type_1460, METH_O | METH_STATIC, (const char *)Dtool_Texture_format_texture_type_1460_comment},
  {"string_texture_type", &Dtool_Texture_string_texture_type_1461, METH_O | METH_STATIC, (const char *)Dtool_Texture_string_texture_type_1461_comment},
  {"stringTextureType", &Dtool_Texture_string_texture_type_1461, METH_O | METH_STATIC, (const char *)Dtool_Texture_string_texture_type_1461_comment},
  {"format_component_type", &Dtool_Texture_format_component_type_1462, METH_O | METH_STATIC, (const char *)Dtool_Texture_format_component_type_1462_comment},
  {"formatComponentType", &Dtool_Texture_format_component_type_1462, METH_O | METH_STATIC, (const char *)Dtool_Texture_format_component_type_1462_comment},
  {"string_component_type", &Dtool_Texture_string_component_type_1463, METH_O | METH_STATIC, (const char *)Dtool_Texture_string_component_type_1463_comment},
  {"stringComponentType", &Dtool_Texture_string_component_type_1463, METH_O | METH_STATIC, (const char *)Dtool_Texture_string_component_type_1463_comment},
  {"format_format", &Dtool_Texture_format_format_1464, METH_O | METH_STATIC, (const char *)Dtool_Texture_format_format_1464_comment},
  {"formatFormat", &Dtool_Texture_format_format_1464, METH_O | METH_STATIC, (const char *)Dtool_Texture_format_format_1464_comment},
  {"string_format", &Dtool_Texture_string_format_1465, METH_O | METH_STATIC, (const char *)Dtool_Texture_string_format_1465_comment},
  {"stringFormat", &Dtool_Texture_string_format_1465, METH_O | METH_STATIC, (const char *)Dtool_Texture_string_format_1465_comment},
  {"format_compression_mode", &Dtool_Texture_format_compression_mode_1466, METH_O | METH_STATIC, (const char *)Dtool_Texture_format_compression_mode_1466_comment},
  {"formatCompressionMode", &Dtool_Texture_format_compression_mode_1466, METH_O | METH_STATIC, (const char *)Dtool_Texture_format_compression_mode_1466_comment},
  {"string_compression_mode", &Dtool_Texture_string_compression_mode_1467, METH_O | METH_STATIC, (const char *)Dtool_Texture_string_compression_mode_1467_comment},
  {"stringCompressionMode", &Dtool_Texture_string_compression_mode_1467, METH_O | METH_STATIC, (const char *)Dtool_Texture_string_compression_mode_1467_comment},
  {"format_quality_level", &Dtool_Texture_format_quality_level_1468, METH_O | METH_STATIC, (const char *)Dtool_Texture_format_quality_level_1468_comment},
  {"formatQualityLevel", &Dtool_Texture_format_quality_level_1468, METH_O | METH_STATIC, (const char *)Dtool_Texture_format_quality_level_1468_comment},
  {"string_quality_level", &Dtool_Texture_string_quality_level_1469, METH_O | METH_STATIC, (const char *)Dtool_Texture_string_quality_level_1469_comment},
  {"stringQualityLevel", &Dtool_Texture_string_quality_level_1469, METH_O | METH_STATIC, (const char *)Dtool_Texture_string_quality_level_1469_comment},
  {"get_class_type", &Dtool_Texture_get_class_type_1470, METH_NOARGS | METH_STATIC, (const char *)Dtool_Texture_get_class_type_1470_comment},
  {"getClassType", &Dtool_Texture_get_class_type_1470, METH_NOARGS | METH_STATIC, (const char *)Dtool_Texture_get_class_type_1470_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_Texture_upcast_to_TypedWritableReferenceCount_1189, METH_NOARGS, (const char *)Dtool_Texture_upcast_to_TypedWritableReferenceCount_1189_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_Texture_upcast_to_TypedWritableReferenceCount_1189, METH_NOARGS, (const char *)Dtool_Texture_upcast_to_TypedWritableReferenceCount_1189_comment},
  {"upcast_to_Namable", &Dtool_Texture_upcast_to_Namable_1191, METH_NOARGS, (const char *)Dtool_Texture_upcast_to_Namable_1191_comment},
  {"upcastToNamable", &Dtool_Texture_upcast_to_Namable_1191, METH_NOARGS, (const char *)Dtool_Texture_upcast_to_Namable_1191_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     Texture
//////////////////
static PyObject *Dtool_Str_Texture(PyObject *self) {
  Texture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Texture, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_Texture[] = {
  {(char *)"clear_color", &Dtool_Texture_clear_color_Getter, &Dtool_Texture_clear_color_Setter, nullptr, nullptr},
  {(char *)"filename", &Dtool_Texture_filename_Getter, &Dtool_Texture_filename_Setter, nullptr, nullptr},
  {(char *)"alpha_filename", &Dtool_Texture_alpha_filename_Getter, &Dtool_Texture_alpha_filename_Setter, nullptr, nullptr},
  {(char *)"fullpath", &Dtool_Texture_fullpath_Getter, &Dtool_Texture_fullpath_Setter, nullptr, nullptr},
  {(char *)"alpha_fullpath", &Dtool_Texture_alpha_fullpath_Getter, &Dtool_Texture_alpha_fullpath_Setter, nullptr, nullptr},
  {(char *)"x_size", &Dtool_Texture_x_size_Getter, &Dtool_Texture_x_size_Setter, nullptr, nullptr},
  {(char *)"y_size", &Dtool_Texture_y_size_Getter, &Dtool_Texture_y_size_Setter, nullptr, nullptr},
  {(char *)"z_size", &Dtool_Texture_z_size_Getter, &Dtool_Texture_z_size_Setter, nullptr, nullptr},
  {(char *)"num_views", &Dtool_Texture_num_views_Getter, &Dtool_Texture_num_views_Setter, nullptr, nullptr},
  {(char *)"num_pages", &Dtool_Texture_num_pages_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_components", &Dtool_Texture_num_components_Getter, nullptr, nullptr, nullptr},
  {(char *)"component_width", &Dtool_Texture_component_width_Getter, nullptr, nullptr, nullptr},
  {(char *)"texture_type", &Dtool_Texture_texture_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"usage_hint", &Dtool_Texture_usage_hint_Getter, nullptr, nullptr, nullptr},
  {(char *)"format", &Dtool_Texture_format_Getter, &Dtool_Texture_format_Setter, nullptr, nullptr},
  {(char *)"component_type", &Dtool_Texture_component_type_Getter, &Dtool_Texture_component_type_Setter, nullptr, nullptr},
  {(char *)"wrap_u", &Dtool_Texture_wrap_u_Getter, &Dtool_Texture_wrap_u_Setter, nullptr, nullptr},
  {(char *)"wrap_v", &Dtool_Texture_wrap_v_Getter, &Dtool_Texture_wrap_v_Setter, nullptr, nullptr},
  {(char *)"wrap_w", &Dtool_Texture_wrap_w_Getter, &Dtool_Texture_wrap_w_Setter, nullptr, nullptr},
  {(char *)"minfilter", &Dtool_Texture_minfilter_Getter, &Dtool_Texture_minfilter_Setter, nullptr, nullptr},
  {(char *)"effective_minfilter", &Dtool_Texture_effective_minfilter_Getter, nullptr, nullptr, nullptr},
  {(char *)"magfilter", &Dtool_Texture_magfilter_Getter, &Dtool_Texture_magfilter_Setter, nullptr, nullptr},
  {(char *)"effective_magfilter", &Dtool_Texture_effective_magfilter_Getter, nullptr, nullptr, nullptr},
  {(char *)"anisotropic_degree", &Dtool_Texture_anisotropic_degree_Getter, &Dtool_Texture_anisotropic_degree_Setter, nullptr, nullptr},
  {(char *)"effective_anisotropic_degree", &Dtool_Texture_effective_anisotropic_degree_Getter, nullptr, nullptr, nullptr},
  {(char *)"border_color", &Dtool_Texture_border_color_Getter, &Dtool_Texture_border_color_Setter, nullptr, nullptr},
  {(char *)"compression", &Dtool_Texture_compression_Getter, &Dtool_Texture_compression_Setter, (char *)
    "// Could maybe use has_compression here, too",
    nullptr},
  {(char *)"render_to_texture", &Dtool_Texture_render_to_texture_Getter, &Dtool_Texture_render_to_texture_Setter, nullptr, nullptr},
  {(char *)"default_sampler", &Dtool_Texture_default_sampler_Getter, &Dtool_Texture_default_sampler_Setter, nullptr, nullptr},
  {(char *)"quality_level", &Dtool_Texture_quality_level_Getter, &Dtool_Texture_quality_level_Setter, nullptr, nullptr},
  {(char *)"effective_quality_level", &Dtool_Texture_effective_quality_level_Getter, nullptr, nullptr, nullptr},
  {(char *)"expected_num_mipmap_levels", &Dtool_Texture_expected_num_mipmap_levels_Getter, nullptr, nullptr, nullptr},
  {(char *)"ram_image_size", &Dtool_Texture_ram_image_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"ram_view_size", &Dtool_Texture_ram_view_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"ram_page_size", &Dtool_Texture_ram_page_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"expected_ram_image_size", &Dtool_Texture_expected_ram_image_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"expected_ram_page_size", &Dtool_Texture_expected_ram_page_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"ram_image_compression", &Dtool_Texture_ram_image_compression_Getter, nullptr, nullptr, nullptr},
  {(char *)"keep_ram_image", &Dtool_Texture_keep_ram_image_Getter, &Dtool_Texture_keep_ram_image_Setter, nullptr, nullptr},
  {(char *)"cacheable", &Dtool_Texture_cacheable_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_ram_mipmap_images", &Dtool_Texture_num_ram_mipmap_images_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_loadable_ram_mipmap_images", &Dtool_Texture_num_loadable_ram_mipmap_images_Getter, nullptr, nullptr, nullptr},
  {(char *)"simple_x_size", &Dtool_Texture_simple_x_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"simple_y_size", &Dtool_Texture_simple_y_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"simple_ram_image", &Dtool_Texture_simple_ram_image_Getter, nullptr, nullptr, nullptr},
  {(char *)"properties_modified", &Dtool_Texture_properties_modified_Getter, nullptr, nullptr, nullptr},
  {(char *)"image_modified", &Dtool_Texture_image_modified_Getter, nullptr, nullptr, nullptr},
  {(char *)"simple_image_modified", &Dtool_Texture_simple_image_modified_Getter, nullptr, nullptr, nullptr},
  {(char *)"auto_texture_scale", &Dtool_Texture_auto_texture_scale_Getter, &Dtool_Texture_auto_texture_scale_Setter, nullptr, nullptr},
  {(char *)"aux_data", &Dtool_Texture_aux_data_Getter, nullptr, nullptr, nullptr},
  {(char *)"orig_file_x_size", &Dtool_Texture_orig_file_x_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"orig_file_y_size", &Dtool_Texture_orig_file_y_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"orig_file_z_size", &Dtool_Texture_orig_file_z_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"loaded_from_image", &Dtool_Texture_loaded_from_image_Getter, &Dtool_Texture_loaded_from_image_Setter, nullptr, nullptr},
  {(char *)"loaded_from_txo", &Dtool_Texture_loaded_from_txo_Getter, &Dtool_Texture_loaded_from_txo_Setter, nullptr, nullptr},
  {(char *)"match_framebuffer_format", &Dtool_Texture_match_framebuffer_format_Getter, &Dtool_Texture_match_framebuffer_format_Setter, nullptr, nullptr},
  {(char *)"post_load_store_cache", &Dtool_Texture_post_load_store_cache_Getter, &Dtool_Texture_post_load_store_cache_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Texture = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Texture = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Texture = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Texture = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Texture = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Texture = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Texture",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Texture,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Texture,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Texture,
    &Dtool_SequenceMethods_Texture,
    &Dtool_MappingMethods_Texture,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_Texture,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Texture,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents a texture object, which is typically a single 2-d image but may\n"
    " * also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube\n"
    " * map texture.\n"
    " *\n"
    " * A texture's image data might be stored in system RAM (see get_ram_image())\n"
    " * or its image may be represented in texture memory on one or more\n"
    " * GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern\n"
    " * is that a texture is loaded from an image file on disk, which copies its\n"
    " * image data into system RAM; then the first time the texture is rendered its\n"
    " * image data is copied to texture memory (actually, to the graphics API), and\n"
    " * the system RAM image is automatically freed.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Texture,
    nullptr, // tp_members
    Dtool_Properties_Texture,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Texture,
    PyType_GenericAlloc,
    Dtool_new_Texture,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Texture,
  Dtool_UpcastInterface_Texture,
  Dtool_DowncastInterface_Texture,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Texture(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_Texture._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_Texture._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(195);
    Dtool_Texture._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum Texture::TextureType;
    PyDict_SetItemString(dict, "TT_1d_texture", Dtool_WrapValue(Texture::TT_1d_texture));
    PyDict_SetItemString(dict, "TT1dTexture", Dtool_WrapValue(Texture::TT_1d_texture));
    PyDict_SetItemString(dict, "TT_2d_texture", Dtool_WrapValue(Texture::TT_2d_texture));
    PyDict_SetItemString(dict, "TT2dTexture", Dtool_WrapValue(Texture::TT_2d_texture));
    PyDict_SetItemString(dict, "TT_3d_texture", Dtool_WrapValue(Texture::TT_3d_texture));
    PyDict_SetItemString(dict, "TT3dTexture", Dtool_WrapValue(Texture::TT_3d_texture));
    PyDict_SetItemString(dict, "TT_2d_texture_array", Dtool_WrapValue(Texture::TT_2d_texture_array));
    PyDict_SetItemString(dict, "TT2dTextureArray", Dtool_WrapValue(Texture::TT_2d_texture_array));
    PyDict_SetItemString(dict, "TT_cube_map", Dtool_WrapValue(Texture::TT_cube_map));
    PyDict_SetItemString(dict, "TTCubeMap", Dtool_WrapValue(Texture::TT_cube_map));
    PyDict_SetItemString(dict, "TT_buffer_texture", Dtool_WrapValue(Texture::TT_buffer_texture));
    PyDict_SetItemString(dict, "TTBufferTexture", Dtool_WrapValue(Texture::TT_buffer_texture));
    PyDict_SetItemString(dict, "TT_cube_map_array", Dtool_WrapValue(Texture::TT_cube_map_array));
    PyDict_SetItemString(dict, "TTCubeMapArray", Dtool_WrapValue(Texture::TT_cube_map_array));
    PyDict_SetItemString(dict, "TT_1d_texture_array", Dtool_WrapValue(Texture::TT_1d_texture_array));
    PyDict_SetItemString(dict, "TT1dTextureArray", Dtool_WrapValue(Texture::TT_1d_texture_array));
    // enum Texture::ComponentType;
    PyDict_SetItemString(dict, "T_unsigned_byte", Dtool_WrapValue(Texture::T_unsigned_byte));
    PyDict_SetItemString(dict, "TUnsignedByte", Dtool_WrapValue(Texture::T_unsigned_byte));
    PyDict_SetItemString(dict, "T_unsigned_short", Dtool_WrapValue(Texture::T_unsigned_short));
    PyDict_SetItemString(dict, "TUnsignedShort", Dtool_WrapValue(Texture::T_unsigned_short));
    PyDict_SetItemString(dict, "T_float", Dtool_WrapValue(Texture::T_float));
    PyDict_SetItemString(dict, "TFloat", Dtool_WrapValue(Texture::T_float));
    PyDict_SetItemString(dict, "T_unsigned_int_24_8", Dtool_WrapValue(Texture::T_unsigned_int_24_8));
    PyDict_SetItemString(dict, "TUnsignedInt248", Dtool_WrapValue(Texture::T_unsigned_int_24_8));
    PyDict_SetItemString(dict, "T_int", Dtool_WrapValue(Texture::T_int));
    PyDict_SetItemString(dict, "TInt", Dtool_WrapValue(Texture::T_int));
    PyDict_SetItemString(dict, "T_byte", Dtool_WrapValue(Texture::T_byte));
    PyDict_SetItemString(dict, "TByte", Dtool_WrapValue(Texture::T_byte));
    PyDict_SetItemString(dict, "T_short", Dtool_WrapValue(Texture::T_short));
    PyDict_SetItemString(dict, "TShort", Dtool_WrapValue(Texture::T_short));
    PyDict_SetItemString(dict, "T_half_float", Dtool_WrapValue(Texture::T_half_float));
    PyDict_SetItemString(dict, "THalfFloat", Dtool_WrapValue(Texture::T_half_float));
    PyDict_SetItemString(dict, "T_unsigned_int", Dtool_WrapValue(Texture::T_unsigned_int));
    PyDict_SetItemString(dict, "TUnsignedInt", Dtool_WrapValue(Texture::T_unsigned_int));
    // enum Texture::Format;
    PyDict_SetItemString(dict, "F_depth_stencil", Dtool_WrapValue(Texture::F_depth_stencil));
    PyDict_SetItemString(dict, "FDepthStencil", Dtool_WrapValue(Texture::F_depth_stencil));
    PyDict_SetItemString(dict, "F_color_index", Dtool_WrapValue(Texture::F_color_index));
    PyDict_SetItemString(dict, "FColorIndex", Dtool_WrapValue(Texture::F_color_index));
    PyDict_SetItemString(dict, "F_red", Dtool_WrapValue(Texture::F_red));
    PyDict_SetItemString(dict, "FRed", Dtool_WrapValue(Texture::F_red));
    PyDict_SetItemString(dict, "F_green", Dtool_WrapValue(Texture::F_green));
    PyDict_SetItemString(dict, "FGreen", Dtool_WrapValue(Texture::F_green));
    PyDict_SetItemString(dict, "F_blue", Dtool_WrapValue(Texture::F_blue));
    PyDict_SetItemString(dict, "FBlue", Dtool_WrapValue(Texture::F_blue));
    PyDict_SetItemString(dict, "F_alpha", Dtool_WrapValue(Texture::F_alpha));
    PyDict_SetItemString(dict, "FAlpha", Dtool_WrapValue(Texture::F_alpha));
    PyDict_SetItemString(dict, "F_rgb", Dtool_WrapValue(Texture::F_rgb));
    PyDict_SetItemString(dict, "FRgb", Dtool_WrapValue(Texture::F_rgb));
    PyDict_SetItemString(dict, "F_rgb5", Dtool_WrapValue(Texture::F_rgb5));
    PyDict_SetItemString(dict, "FRgb5", Dtool_WrapValue(Texture::F_rgb5));
    PyDict_SetItemString(dict, "F_rgb8", Dtool_WrapValue(Texture::F_rgb8));
    PyDict_SetItemString(dict, "FRgb8", Dtool_WrapValue(Texture::F_rgb8));
    PyDict_SetItemString(dict, "F_rgb12", Dtool_WrapValue(Texture::F_rgb12));
    PyDict_SetItemString(dict, "FRgb12", Dtool_WrapValue(Texture::F_rgb12));
    PyDict_SetItemString(dict, "F_rgb332", Dtool_WrapValue(Texture::F_rgb332));
    PyDict_SetItemString(dict, "FRgb332", Dtool_WrapValue(Texture::F_rgb332));
    PyDict_SetItemString(dict, "F_rgba", Dtool_WrapValue(Texture::F_rgba));
    PyDict_SetItemString(dict, "FRgba", Dtool_WrapValue(Texture::F_rgba));
    PyDict_SetItemString(dict, "F_rgbm", Dtool_WrapValue(Texture::F_rgbm));
    PyDict_SetItemString(dict, "FRgbm", Dtool_WrapValue(Texture::F_rgbm));
    PyDict_SetItemString(dict, "F_rgba4", Dtool_WrapValue(Texture::F_rgba4));
    PyDict_SetItemString(dict, "FRgba4", Dtool_WrapValue(Texture::F_rgba4));
    PyDict_SetItemString(dict, "F_rgba5", Dtool_WrapValue(Texture::F_rgba5));
    PyDict_SetItemString(dict, "FRgba5", Dtool_WrapValue(Texture::F_rgba5));
    PyDict_SetItemString(dict, "F_rgba8", Dtool_WrapValue(Texture::F_rgba8));
    PyDict_SetItemString(dict, "FRgba8", Dtool_WrapValue(Texture::F_rgba8));
    PyDict_SetItemString(dict, "F_rgba12", Dtool_WrapValue(Texture::F_rgba12));
    PyDict_SetItemString(dict, "FRgba12", Dtool_WrapValue(Texture::F_rgba12));
    PyDict_SetItemString(dict, "F_luminance", Dtool_WrapValue(Texture::F_luminance));
    PyDict_SetItemString(dict, "FLuminance", Dtool_WrapValue(Texture::F_luminance));
    PyDict_SetItemString(dict, "F_luminance_alpha", Dtool_WrapValue(Texture::F_luminance_alpha));
    PyDict_SetItemString(dict, "FLuminanceAlpha", Dtool_WrapValue(Texture::F_luminance_alpha));
    PyDict_SetItemString(dict, "F_luminance_alphamask", Dtool_WrapValue(Texture::F_luminance_alphamask));
    PyDict_SetItemString(dict, "FLuminanceAlphamask", Dtool_WrapValue(Texture::F_luminance_alphamask));
    PyDict_SetItemString(dict, "F_rgba16", Dtool_WrapValue(Texture::F_rgba16));
    PyDict_SetItemString(dict, "FRgba16", Dtool_WrapValue(Texture::F_rgba16));
    PyDict_SetItemString(dict, "F_rgba32", Dtool_WrapValue(Texture::F_rgba32));
    PyDict_SetItemString(dict, "FRgba32", Dtool_WrapValue(Texture::F_rgba32));
    PyDict_SetItemString(dict, "F_depth_component", Dtool_WrapValue(Texture::F_depth_component));
    PyDict_SetItemString(dict, "FDepthComponent", Dtool_WrapValue(Texture::F_depth_component));
    PyDict_SetItemString(dict, "F_depth_component16", Dtool_WrapValue(Texture::F_depth_component16));
    PyDict_SetItemString(dict, "FDepthComponent16", Dtool_WrapValue(Texture::F_depth_component16));
    PyDict_SetItemString(dict, "F_depth_component24", Dtool_WrapValue(Texture::F_depth_component24));
    PyDict_SetItemString(dict, "FDepthComponent24", Dtool_WrapValue(Texture::F_depth_component24));
    PyDict_SetItemString(dict, "F_depth_component32", Dtool_WrapValue(Texture::F_depth_component32));
    PyDict_SetItemString(dict, "FDepthComponent32", Dtool_WrapValue(Texture::F_depth_component32));
    PyDict_SetItemString(dict, "F_r16", Dtool_WrapValue(Texture::F_r16));
    PyDict_SetItemString(dict, "FR16", Dtool_WrapValue(Texture::F_r16));
    PyDict_SetItemString(dict, "F_rg16", Dtool_WrapValue(Texture::F_rg16));
    PyDict_SetItemString(dict, "FRg16", Dtool_WrapValue(Texture::F_rg16));
    PyDict_SetItemString(dict, "F_rgb16", Dtool_WrapValue(Texture::F_rgb16));
    PyDict_SetItemString(dict, "FRgb16", Dtool_WrapValue(Texture::F_rgb16));
    PyDict_SetItemString(dict, "F_srgb", Dtool_WrapValue(Texture::F_srgb));
    PyDict_SetItemString(dict, "FSrgb", Dtool_WrapValue(Texture::F_srgb));
    PyDict_SetItemString(dict, "F_srgb_alpha", Dtool_WrapValue(Texture::F_srgb_alpha));
    PyDict_SetItemString(dict, "FSrgbAlpha", Dtool_WrapValue(Texture::F_srgb_alpha));
    PyDict_SetItemString(dict, "F_sluminance", Dtool_WrapValue(Texture::F_sluminance));
    PyDict_SetItemString(dict, "FSluminance", Dtool_WrapValue(Texture::F_sluminance));
    PyDict_SetItemString(dict, "F_sluminance_alpha", Dtool_WrapValue(Texture::F_sluminance_alpha));
    PyDict_SetItemString(dict, "FSluminanceAlpha", Dtool_WrapValue(Texture::F_sluminance_alpha));
    PyDict_SetItemString(dict, "F_r32i", Dtool_WrapValue(Texture::F_r32i));
    PyDict_SetItemString(dict, "FR32i", Dtool_WrapValue(Texture::F_r32i));
    PyDict_SetItemString(dict, "F_r32", Dtool_WrapValue(Texture::F_r32));
    PyDict_SetItemString(dict, "FR32", Dtool_WrapValue(Texture::F_r32));
    PyDict_SetItemString(dict, "F_rg32", Dtool_WrapValue(Texture::F_rg32));
    PyDict_SetItemString(dict, "FRg32", Dtool_WrapValue(Texture::F_rg32));
    PyDict_SetItemString(dict, "F_rgb32", Dtool_WrapValue(Texture::F_rgb32));
    PyDict_SetItemString(dict, "FRgb32", Dtool_WrapValue(Texture::F_rgb32));
    PyDict_SetItemString(dict, "F_r8i", Dtool_WrapValue(Texture::F_r8i));
    PyDict_SetItemString(dict, "FR8i", Dtool_WrapValue(Texture::F_r8i));
    PyDict_SetItemString(dict, "F_rg8i", Dtool_WrapValue(Texture::F_rg8i));
    PyDict_SetItemString(dict, "FRg8i", Dtool_WrapValue(Texture::F_rg8i));
    PyDict_SetItemString(dict, "F_rgb8i", Dtool_WrapValue(Texture::F_rgb8i));
    PyDict_SetItemString(dict, "FRgb8i", Dtool_WrapValue(Texture::F_rgb8i));
    PyDict_SetItemString(dict, "F_rgba8i", Dtool_WrapValue(Texture::F_rgba8i));
    PyDict_SetItemString(dict, "FRgba8i", Dtool_WrapValue(Texture::F_rgba8i));
    PyDict_SetItemString(dict, "F_r11_g11_b10", Dtool_WrapValue(Texture::F_r11_g11_b10));
    PyDict_SetItemString(dict, "FR11G11B10", Dtool_WrapValue(Texture::F_r11_g11_b10));
    PyDict_SetItemString(dict, "F_rgb9_e5", Dtool_WrapValue(Texture::F_rgb9_e5));
    PyDict_SetItemString(dict, "FRgb9E5", Dtool_WrapValue(Texture::F_rgb9_e5));
    PyDict_SetItemString(dict, "F_rgb10_a2", Dtool_WrapValue(Texture::F_rgb10_a2));
    PyDict_SetItemString(dict, "FRgb10A2", Dtool_WrapValue(Texture::F_rgb10_a2));
    PyDict_SetItemString(dict, "F_rg", Dtool_WrapValue(Texture::F_rg));
    PyDict_SetItemString(dict, "FRg", Dtool_WrapValue(Texture::F_rg));
    PyDict_SetItemString(dict, "F_r16i", Dtool_WrapValue(Texture::F_r16i));
    PyDict_SetItemString(dict, "FR16i", Dtool_WrapValue(Texture::F_r16i));
    // enum Texture::DeprecatedFilterType;
    PyDict_SetItemString(dict, "FT_nearest", Dtool_WrapValue(Texture::FT_nearest));
    PyDict_SetItemString(dict, "FTNearest", Dtool_WrapValue(Texture::FT_nearest));
    PyDict_SetItemString(dict, "FT_linear", Dtool_WrapValue(Texture::FT_linear));
    PyDict_SetItemString(dict, "FTLinear", Dtool_WrapValue(Texture::FT_linear));
    PyDict_SetItemString(dict, "FT_nearest_mipmap_nearest", Dtool_WrapValue(Texture::FT_nearest_mipmap_nearest));
    PyDict_SetItemString(dict, "FTNearestMipmapNearest", Dtool_WrapValue(Texture::FT_nearest_mipmap_nearest));
    PyDict_SetItemString(dict, "FT_linear_mipmap_nearest", Dtool_WrapValue(Texture::FT_linear_mipmap_nearest));
    PyDict_SetItemString(dict, "FTLinearMipmapNearest", Dtool_WrapValue(Texture::FT_linear_mipmap_nearest));
    PyDict_SetItemString(dict, "FT_nearest_mipmap_linear", Dtool_WrapValue(Texture::FT_nearest_mipmap_linear));
    PyDict_SetItemString(dict, "FTNearestMipmapLinear", Dtool_WrapValue(Texture::FT_nearest_mipmap_linear));
    PyDict_SetItemString(dict, "FT_linear_mipmap_linear", Dtool_WrapValue(Texture::FT_linear_mipmap_linear));
    PyDict_SetItemString(dict, "FTLinearMipmapLinear", Dtool_WrapValue(Texture::FT_linear_mipmap_linear));
    PyDict_SetItemString(dict, "FT_shadow", Dtool_WrapValue(Texture::FT_shadow));
    PyDict_SetItemString(dict, "FTShadow", Dtool_WrapValue(Texture::FT_shadow));
    PyDict_SetItemString(dict, "FT_default", Dtool_WrapValue(Texture::FT_default));
    PyDict_SetItemString(dict, "FTDefault", Dtool_WrapValue(Texture::FT_default));
    PyDict_SetItemString(dict, "FT_invalid", Dtool_WrapValue(Texture::FT_invalid));
    PyDict_SetItemString(dict, "FTInvalid", Dtool_WrapValue(Texture::FT_invalid));
    // enum Texture::DeprecatedWrapMode;
    PyDict_SetItemString(dict, "WM_clamp", Dtool_WrapValue(Texture::WM_clamp));
    PyDict_SetItemString(dict, "WMClamp", Dtool_WrapValue(Texture::WM_clamp));
    PyDict_SetItemString(dict, "WM_repeat", Dtool_WrapValue(Texture::WM_repeat));
    PyDict_SetItemString(dict, "WMRepeat", Dtool_WrapValue(Texture::WM_repeat));
    PyDict_SetItemString(dict, "WM_mirror", Dtool_WrapValue(Texture::WM_mirror));
    PyDict_SetItemString(dict, "WMMirror", Dtool_WrapValue(Texture::WM_mirror));
    PyDict_SetItemString(dict, "WM_mirror_once", Dtool_WrapValue(Texture::WM_mirror_once));
    PyDict_SetItemString(dict, "WMMirrorOnce", Dtool_WrapValue(Texture::WM_mirror_once));
    PyDict_SetItemString(dict, "WM_border_color", Dtool_WrapValue(Texture::WM_border_color));
    PyDict_SetItemString(dict, "WMBorderColor", Dtool_WrapValue(Texture::WM_border_color));
    PyDict_SetItemString(dict, "WM_invalid", Dtool_WrapValue(Texture::WM_invalid));
    PyDict_SetItemString(dict, "WMInvalid", Dtool_WrapValue(Texture::WM_invalid));
    // enum Texture::CompressionMode;
    PyDict_SetItemString(dict, "CM_default", Dtool_WrapValue(Texture::CM_default));
    PyDict_SetItemString(dict, "CMDefault", Dtool_WrapValue(Texture::CM_default));
    PyDict_SetItemString(dict, "CM_off", Dtool_WrapValue(Texture::CM_off));
    PyDict_SetItemString(dict, "CMOff", Dtool_WrapValue(Texture::CM_off));
    PyDict_SetItemString(dict, "CM_on", Dtool_WrapValue(Texture::CM_on));
    PyDict_SetItemString(dict, "CMOn", Dtool_WrapValue(Texture::CM_on));
    PyDict_SetItemString(dict, "CM_fxt1", Dtool_WrapValue(Texture::CM_fxt1));
    PyDict_SetItemString(dict, "CMFxt1", Dtool_WrapValue(Texture::CM_fxt1));
    PyDict_SetItemString(dict, "CM_dxt1", Dtool_WrapValue(Texture::CM_dxt1));
    PyDict_SetItemString(dict, "CMDxt1", Dtool_WrapValue(Texture::CM_dxt1));
    PyDict_SetItemString(dict, "CM_dxt2", Dtool_WrapValue(Texture::CM_dxt2));
    PyDict_SetItemString(dict, "CMDxt2", Dtool_WrapValue(Texture::CM_dxt2));
    PyDict_SetItemString(dict, "CM_dxt3", Dtool_WrapValue(Texture::CM_dxt3));
    PyDict_SetItemString(dict, "CMDxt3", Dtool_WrapValue(Texture::CM_dxt3));
    PyDict_SetItemString(dict, "CM_dxt4", Dtool_WrapValue(Texture::CM_dxt4));
    PyDict_SetItemString(dict, "CMDxt4", Dtool_WrapValue(Texture::CM_dxt4));
    PyDict_SetItemString(dict, "CM_dxt5", Dtool_WrapValue(Texture::CM_dxt5));
    PyDict_SetItemString(dict, "CMDxt5", Dtool_WrapValue(Texture::CM_dxt5));
    PyDict_SetItemString(dict, "CM_pvr1_2bpp", Dtool_WrapValue(Texture::CM_pvr1_2bpp));
    PyDict_SetItemString(dict, "CMPvr12bpp", Dtool_WrapValue(Texture::CM_pvr1_2bpp));
    PyDict_SetItemString(dict, "CM_pvr1_4bpp", Dtool_WrapValue(Texture::CM_pvr1_4bpp));
    PyDict_SetItemString(dict, "CMPvr14bpp", Dtool_WrapValue(Texture::CM_pvr1_4bpp));
    PyDict_SetItemString(dict, "CM_rgtc", Dtool_WrapValue(Texture::CM_rgtc));
    PyDict_SetItemString(dict, "CMRgtc", Dtool_WrapValue(Texture::CM_rgtc));
    PyDict_SetItemString(dict, "CM_etc1", Dtool_WrapValue(Texture::CM_etc1));
    PyDict_SetItemString(dict, "CMEtc1", Dtool_WrapValue(Texture::CM_etc1));
    PyDict_SetItemString(dict, "CM_etc2", Dtool_WrapValue(Texture::CM_etc2));
    PyDict_SetItemString(dict, "CMEtc2", Dtool_WrapValue(Texture::CM_etc2));
    PyDict_SetItemString(dict, "CM_eac", Dtool_WrapValue(Texture::CM_eac));
    PyDict_SetItemString(dict, "CMEac", Dtool_WrapValue(Texture::CM_eac));
    // enum Texture::QualityLevel;
    PyDict_SetItemString(dict, "QL_default", Dtool_WrapValue(Texture::QL_default));
    PyDict_SetItemString(dict, "QLDefault", Dtool_WrapValue(Texture::QL_default));
    PyDict_SetItemString(dict, "QL_fastest", Dtool_WrapValue(Texture::QL_fastest));
    PyDict_SetItemString(dict, "QLFastest", Dtool_WrapValue(Texture::QL_fastest));
    PyDict_SetItemString(dict, "QL_normal", Dtool_WrapValue(Texture::QL_normal));
    PyDict_SetItemString(dict, "QLNormal", Dtool_WrapValue(Texture::QL_normal));
    PyDict_SetItemString(dict, "QL_best", Dtool_WrapValue(Texture::QL_best));
    PyDict_SetItemString(dict, "QLBest", Dtool_WrapValue(Texture::QL_best));
    if (PyType_Ready((PyTypeObject *)&Dtool_Texture) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Texture)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Texture);
  }
}

/**
 * Python method tables for Shader (Shader)
 */
static PyMethodDef Dtool_Methods_Shader[] = {
  {"load", (PyCFunction) &Dtool_Shader_load_1476, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Shader_load_1476_comment},
  {"make", (PyCFunction) &Dtool_Shader_make_1477, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Shader_make_1477_comment},
  {"load_compute", (PyCFunction) &Dtool_Shader_load_compute_1478, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Shader_load_compute_1478_comment},
  {"loadCompute", (PyCFunction) &Dtool_Shader_load_compute_1478, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Shader_load_compute_1478_comment},
  {"make_compute", (PyCFunction) &Dtool_Shader_make_compute_1479, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Shader_make_compute_1479_comment},
  {"makeCompute", (PyCFunction) &Dtool_Shader_make_compute_1479, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Shader_make_compute_1479_comment},
  {"get_filename", (PyCFunction) &Dtool_Shader_get_filename_1480, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Shader_get_filename_1480_comment},
  {"getFilename", (PyCFunction) &Dtool_Shader_get_filename_1480, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Shader_get_filename_1480_comment},
  {"set_filename", (PyCFunction) &Dtool_Shader_set_filename_1481, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Shader_set_filename_1481_comment},
  {"setFilename", (PyCFunction) &Dtool_Shader_set_filename_1481, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Shader_set_filename_1481_comment},
  {"get_text", (PyCFunction) &Dtool_Shader_get_text_1482, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Shader_get_text_1482_comment},
  {"getText", (PyCFunction) &Dtool_Shader_get_text_1482, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Shader_get_text_1482_comment},
  {"get_error_flag", &Dtool_Shader_get_error_flag_1483, METH_NOARGS, (const char *)Dtool_Shader_get_error_flag_1483_comment},
  {"getErrorFlag", &Dtool_Shader_get_error_flag_1483, METH_NOARGS, (const char *)Dtool_Shader_get_error_flag_1483_comment},
  {"get_language", &Dtool_Shader_get_language_1484, METH_NOARGS, (const char *)Dtool_Shader_get_language_1484_comment},
  {"getLanguage", &Dtool_Shader_get_language_1484, METH_NOARGS, (const char *)Dtool_Shader_get_language_1484_comment},
  {"has_fullpath", &Dtool_Shader_has_fullpath_1485, METH_NOARGS, (const char *)Dtool_Shader_has_fullpath_1485_comment},
  {"hasFullpath", &Dtool_Shader_has_fullpath_1485, METH_NOARGS, (const char *)Dtool_Shader_has_fullpath_1485_comment},
  {"get_fullpath", &Dtool_Shader_get_fullpath_1486, METH_NOARGS, (const char *)Dtool_Shader_get_fullpath_1486_comment},
  {"getFullpath", &Dtool_Shader_get_fullpath_1486, METH_NOARGS, (const char *)Dtool_Shader_get_fullpath_1486_comment},
  {"get_cache_compiled_shader", &Dtool_Shader_get_cache_compiled_shader_1487, METH_NOARGS, (const char *)Dtool_Shader_get_cache_compiled_shader_1487_comment},
  {"getCacheCompiledShader", &Dtool_Shader_get_cache_compiled_shader_1487, METH_NOARGS, (const char *)Dtool_Shader_get_cache_compiled_shader_1487_comment},
  {"set_cache_compiled_shader", &Dtool_Shader_set_cache_compiled_shader_1488, METH_O, (const char *)Dtool_Shader_set_cache_compiled_shader_1488_comment},
  {"setCacheCompiledShader", &Dtool_Shader_set_cache_compiled_shader_1488, METH_O, (const char *)Dtool_Shader_set_cache_compiled_shader_1488_comment},
  {"prepare", &Dtool_Shader_prepare_1489, METH_O, (const char *)Dtool_Shader_prepare_1489_comment},
  {"is_prepared", &Dtool_Shader_is_prepared_1490, METH_O, (const char *)Dtool_Shader_is_prepared_1490_comment},
  {"isPrepared", &Dtool_Shader_is_prepared_1490, METH_O, (const char *)Dtool_Shader_is_prepared_1490_comment},
  {"release", &Dtool_Shader_release_1491, METH_O, (const char *)Dtool_Shader_release_1491_comment},
  {"release_all", &Dtool_Shader_release_all_1492, METH_NOARGS, (const char *)Dtool_Shader_release_all_1492_comment},
  {"releaseAll", &Dtool_Shader_release_all_1492, METH_NOARGS, (const char *)Dtool_Shader_release_all_1492_comment},
  {"prepare_now", (PyCFunction) &Dtool_Shader_prepare_now_1493, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Shader_prepare_now_1493_comment},
  {"prepareNow", (PyCFunction) &Dtool_Shader_prepare_now_1493, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Shader_prepare_now_1493_comment},
  {"get_class_type", &Dtool_Shader_get_class_type_1494, METH_NOARGS | METH_STATIC, (const char *)Dtool_Shader_get_class_type_1494_comment},
  {"getClassType", &Dtool_Shader_get_class_type_1494, METH_NOARGS | METH_STATIC, (const char *)Dtool_Shader_get_class_type_1494_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Shader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Shader = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Shader = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Shader = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Shader = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Shader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Shader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Shader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Shader,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Shader,
    &Dtool_SequenceMethods_Shader,
    &Dtool_MappingMethods_Shader,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Shader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    "\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Shader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Shader,
    PyType_GenericAlloc,
    Dtool_new_Shader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Shader,
  Dtool_UpcastInterface_Shader,
  Dtool_DowncastInterface_Shader,
  (CoerceFunction)Dtool_ConstCoerce_Shader,
  (CoerceFunction)Dtool_Coerce_Shader,
};

static void Dtool_PyModuleClassInit_Shader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_Shader._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_Shader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(47);
    Dtool_Shader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum Shader::ShaderLanguage;
    PyDict_SetItemString(dict, "SL_none", Dtool_WrapValue(Shader::SL_none));
    PyDict_SetItemString(dict, "SLNone", Dtool_WrapValue(Shader::SL_none));
    PyDict_SetItemString(dict, "SL_Cg", Dtool_WrapValue(Shader::SL_Cg));
    PyDict_SetItemString(dict, "SLCg", Dtool_WrapValue(Shader::SL_Cg));
    PyDict_SetItemString(dict, "SL_GLSL", Dtool_WrapValue(Shader::SL_GLSL));
    PyDict_SetItemString(dict, "SLGLSL", Dtool_WrapValue(Shader::SL_GLSL));
    PyDict_SetItemString(dict, "SL_HLSL", Dtool_WrapValue(Shader::SL_HLSL));
    PyDict_SetItemString(dict, "SLHLSL", Dtool_WrapValue(Shader::SL_HLSL));
    PyDict_SetItemString(dict, "SL_SPIR_V", Dtool_WrapValue(Shader::SL_SPIR_V));
    PyDict_SetItemString(dict, "SLSPIRV", Dtool_WrapValue(Shader::SL_SPIR_V));
    // enum Shader::ShaderType;
    PyDict_SetItemString(dict, "ST_none", Dtool_WrapValue(Shader::ST_none));
    PyDict_SetItemString(dict, "STNone", Dtool_WrapValue(Shader::ST_none));
    PyDict_SetItemString(dict, "ST_vertex", Dtool_WrapValue(Shader::ST_vertex));
    PyDict_SetItemString(dict, "STVertex", Dtool_WrapValue(Shader::ST_vertex));
    PyDict_SetItemString(dict, "ST_fragment", Dtool_WrapValue(Shader::ST_fragment));
    PyDict_SetItemString(dict, "STFragment", Dtool_WrapValue(Shader::ST_fragment));
    PyDict_SetItemString(dict, "ST_geometry", Dtool_WrapValue(Shader::ST_geometry));
    PyDict_SetItemString(dict, "STGeometry", Dtool_WrapValue(Shader::ST_geometry));
    PyDict_SetItemString(dict, "ST_tess_control", Dtool_WrapValue(Shader::ST_tess_control));
    PyDict_SetItemString(dict, "STTessControl", Dtool_WrapValue(Shader::ST_tess_control));
    PyDict_SetItemString(dict, "ST_tess_evaluation", Dtool_WrapValue(Shader::ST_tess_evaluation));
    PyDict_SetItemString(dict, "STTessEvaluation", Dtool_WrapValue(Shader::ST_tess_evaluation));
    PyDict_SetItemString(dict, "ST_compute", Dtool_WrapValue(Shader::ST_compute));
    PyDict_SetItemString(dict, "STCompute", Dtool_WrapValue(Shader::ST_compute));
    PyDict_SetItemString(dict, "ST_COUNT", Dtool_WrapValue(Shader::ST_COUNT));
    PyDict_SetItemString(dict, "STCOUNT", Dtool_WrapValue(Shader::ST_COUNT));
    // enum Shader::AutoShaderSwitch;
    PyDict_SetItemString(dict, "AS_normal", Dtool_WrapValue(Shader::AS_normal));
    PyDict_SetItemString(dict, "ASNormal", Dtool_WrapValue(Shader::AS_normal));
    PyDict_SetItemString(dict, "AS_glow", Dtool_WrapValue(Shader::AS_glow));
    PyDict_SetItemString(dict, "ASGlow", Dtool_WrapValue(Shader::AS_glow));
    PyDict_SetItemString(dict, "AS_gloss", Dtool_WrapValue(Shader::AS_gloss));
    PyDict_SetItemString(dict, "ASGloss", Dtool_WrapValue(Shader::AS_gloss));
    PyDict_SetItemString(dict, "AS_ramp", Dtool_WrapValue(Shader::AS_ramp));
    PyDict_SetItemString(dict, "ASRamp", Dtool_WrapValue(Shader::AS_ramp));
    PyDict_SetItemString(dict, "AS_shadow", Dtool_WrapValue(Shader::AS_shadow));
    PyDict_SetItemString(dict, "ASShadow", Dtool_WrapValue(Shader::AS_shadow));
    // enum Shader::AutoShaderBit;
    PyDict_SetItemString(dict, "bit_AutoShaderNormal", Dtool_WrapValue(Shader::bit_AutoShaderNormal));
    PyDict_SetItemString(dict, "BitAutoShaderNormal", Dtool_WrapValue(Shader::bit_AutoShaderNormal));
    PyDict_SetItemString(dict, "bit_AutoShaderGlow", Dtool_WrapValue(Shader::bit_AutoShaderGlow));
    PyDict_SetItemString(dict, "BitAutoShaderGlow", Dtool_WrapValue(Shader::bit_AutoShaderGlow));
    PyDict_SetItemString(dict, "bit_AutoShaderGloss", Dtool_WrapValue(Shader::bit_AutoShaderGloss));
    PyDict_SetItemString(dict, "BitAutoShaderGloss", Dtool_WrapValue(Shader::bit_AutoShaderGloss));
    PyDict_SetItemString(dict, "bit_AutoShaderRamp", Dtool_WrapValue(Shader::bit_AutoShaderRamp));
    PyDict_SetItemString(dict, "BitAutoShaderRamp", Dtool_WrapValue(Shader::bit_AutoShaderRamp));
    PyDict_SetItemString(dict, "bit_AutoShaderShadow", Dtool_WrapValue(Shader::bit_AutoShaderShadow));
    PyDict_SetItemString(dict, "BitAutoShaderShadow", Dtool_WrapValue(Shader::bit_AutoShaderShadow));
    if (PyType_Ready((PyTypeObject *)&Dtool_Shader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Shader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Shader);
  }
}

/**
 * Python method tables for ShaderBuffer (ShaderBuffer)
 */
static PyMethodDef Dtool_Methods_ShaderBuffer[] = {
  {"prepare", &Dtool_ShaderBuffer_prepare_1511, METH_O, (const char *)Dtool_ShaderBuffer_prepare_1511_comment},
  {"is_prepared", &Dtool_ShaderBuffer_is_prepared_1512, METH_O, (const char *)Dtool_ShaderBuffer_is_prepared_1512_comment},
  {"isPrepared", &Dtool_ShaderBuffer_is_prepared_1512, METH_O, (const char *)Dtool_ShaderBuffer_is_prepared_1512_comment},
  {"prepare_now", (PyCFunction) &Dtool_ShaderBuffer_prepare_now_1513, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderBuffer_prepare_now_1513_comment},
  {"prepareNow", (PyCFunction) &Dtool_ShaderBuffer_prepare_now_1513, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderBuffer_prepare_now_1513_comment},
  {"release", &Dtool_ShaderBuffer_release_1514, METH_O, (const char *)Dtool_ShaderBuffer_release_1514_comment},
  {"release_all", &Dtool_ShaderBuffer_release_all_1515, METH_NOARGS, (const char *)Dtool_ShaderBuffer_release_all_1515_comment},
  {"releaseAll", &Dtool_ShaderBuffer_release_all_1515, METH_NOARGS, (const char *)Dtool_ShaderBuffer_release_all_1515_comment},
  {"get_class_type", &Dtool_ShaderBuffer_get_class_type_1516, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderBuffer_get_class_type_1516_comment},
  {"getClassType", &Dtool_ShaderBuffer_get_class_type_1516, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderBuffer_get_class_type_1516_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_ShaderBuffer_upcast_to_TypedWritableReferenceCount_1497, METH_NOARGS, (const char *)Dtool_ShaderBuffer_upcast_to_TypedWritableReferenceCount_1497_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_ShaderBuffer_upcast_to_TypedWritableReferenceCount_1497, METH_NOARGS, (const char *)Dtool_ShaderBuffer_upcast_to_TypedWritableReferenceCount_1497_comment},
  {"upcast_to_Namable", &Dtool_ShaderBuffer_upcast_to_Namable_1499, METH_NOARGS, (const char *)Dtool_ShaderBuffer_upcast_to_Namable_1499_comment},
  {"upcastToNamable", &Dtool_ShaderBuffer_upcast_to_Namable_1499, METH_NOARGS, (const char *)Dtool_ShaderBuffer_upcast_to_Namable_1499_comment},
  {"upcast_to_GeomEnums", &Dtool_ShaderBuffer_upcast_to_GeomEnums_1501, METH_NOARGS, (const char *)Dtool_ShaderBuffer_upcast_to_GeomEnums_1501_comment},
  {"upcastToGeomEnums", &Dtool_ShaderBuffer_upcast_to_GeomEnums_1501, METH_NOARGS, (const char *)Dtool_ShaderBuffer_upcast_to_GeomEnums_1501_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ShaderBuffer[] = {
  {(char *)"data_size_bytes", &Dtool_ShaderBuffer_data_size_bytes_Getter, nullptr, nullptr, nullptr},
  {(char *)"usage_hint", &Dtool_ShaderBuffer_usage_hint_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ShaderBuffer = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShaderBuffer = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ShaderBuffer = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ShaderBuffer = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ShaderBuffer = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ShaderBuffer = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ShaderBuffer",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderBuffer,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ShaderBuffer,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShaderBuffer,
    &Dtool_SequenceMethods_ShaderBuffer,
    &Dtool_MappingMethods_ShaderBuffer,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ShaderBuffer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a generic buffer object that lives in graphics memory.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShaderBuffer,
    nullptr, // tp_members
    Dtool_Properties_ShaderBuffer,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShaderBuffer,
    PyType_GenericAlloc,
    Dtool_new_ShaderBuffer,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderBuffer,
  Dtool_UpcastInterface_ShaderBuffer,
  Dtool_DowncastInterface_ShaderBuffer,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShaderBuffer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_GeomEnums(nullptr);
    Dtool_ShaderBuffer._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable, (PyTypeObject *)&Dtool_GeomEnums);
    Dtool_ShaderBuffer._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShaderBuffer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderBuffer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderBuffer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderBuffer);
  }
}

/**
 * Python method tables for PreparedGraphicsObjects (PreparedGraphicsObjects)
 */
static PyMethodDef Dtool_Methods_PreparedGraphicsObjects[] = {
  {"get_name", &Dtool_PreparedGraphicsObjects_get_name_1518, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_name_1518_comment},
  {"getName", &Dtool_PreparedGraphicsObjects_get_name_1518, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_name_1518_comment},
  {"set_graphics_memory_limit", &Dtool_PreparedGraphicsObjects_set_graphics_memory_limit_1519, METH_O, (const char *)Dtool_PreparedGraphicsObjects_set_graphics_memory_limit_1519_comment},
  {"setGraphicsMemoryLimit", &Dtool_PreparedGraphicsObjects_set_graphics_memory_limit_1519, METH_O, (const char *)Dtool_PreparedGraphicsObjects_set_graphics_memory_limit_1519_comment},
  {"get_graphics_memory_limit", &Dtool_PreparedGraphicsObjects_get_graphics_memory_limit_1520, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_graphics_memory_limit_1520_comment},
  {"getGraphicsMemoryLimit", &Dtool_PreparedGraphicsObjects_get_graphics_memory_limit_1520, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_graphics_memory_limit_1520_comment},
  {"show_graphics_memory_lru", &Dtool_PreparedGraphicsObjects_show_graphics_memory_lru_1521, METH_O, (const char *)Dtool_PreparedGraphicsObjects_show_graphics_memory_lru_1521_comment},
  {"showGraphicsMemoryLru", &Dtool_PreparedGraphicsObjects_show_graphics_memory_lru_1521, METH_O, (const char *)Dtool_PreparedGraphicsObjects_show_graphics_memory_lru_1521_comment},
  {"show_residency_trackers", &Dtool_PreparedGraphicsObjects_show_residency_trackers_1522, METH_O, (const char *)Dtool_PreparedGraphicsObjects_show_residency_trackers_1522_comment},
  {"showResidencyTrackers", &Dtool_PreparedGraphicsObjects_show_residency_trackers_1522, METH_O, (const char *)Dtool_PreparedGraphicsObjects_show_residency_trackers_1522_comment},
  {"release_all", &Dtool_PreparedGraphicsObjects_release_all_1523, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_1523_comment},
  {"releaseAll", &Dtool_PreparedGraphicsObjects_release_all_1523, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_1523_comment},
  {"get_num_queued", &Dtool_PreparedGraphicsObjects_get_num_queued_1524, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_1524_comment},
  {"getNumQueued", &Dtool_PreparedGraphicsObjects_get_num_queued_1524, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_1524_comment},
  {"get_num_prepared", &Dtool_PreparedGraphicsObjects_get_num_prepared_1525, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_1525_comment},
  {"getNumPrepared", &Dtool_PreparedGraphicsObjects_get_num_prepared_1525, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_1525_comment},
  {"enqueue_texture", &Dtool_PreparedGraphicsObjects_enqueue_texture_1526, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_texture_1526_comment},
  {"enqueueTexture", &Dtool_PreparedGraphicsObjects_enqueue_texture_1526, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_texture_1526_comment},
  {"is_texture_queued", &Dtool_PreparedGraphicsObjects_is_texture_queued_1527, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_texture_queued_1527_comment},
  {"isTextureQueued", &Dtool_PreparedGraphicsObjects_is_texture_queued_1527, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_texture_queued_1527_comment},
  {"dequeue_texture", &Dtool_PreparedGraphicsObjects_dequeue_texture_1528, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_texture_1528_comment},
  {"dequeueTexture", &Dtool_PreparedGraphicsObjects_dequeue_texture_1528, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_texture_1528_comment},
  {"is_texture_prepared", &Dtool_PreparedGraphicsObjects_is_texture_prepared_1529, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_texture_prepared_1529_comment},
  {"isTexturePrepared", &Dtool_PreparedGraphicsObjects_is_texture_prepared_1529, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_texture_prepared_1529_comment},
  {"release_texture", &Dtool_PreparedGraphicsObjects_release_texture_1530, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_texture_1530_comment},
  {"releaseTexture", &Dtool_PreparedGraphicsObjects_release_texture_1530, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_texture_1530_comment},
  {"release_all_textures", &Dtool_PreparedGraphicsObjects_release_all_textures_1531, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_textures_1531_comment},
  {"releaseAllTextures", &Dtool_PreparedGraphicsObjects_release_all_textures_1531, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_textures_1531_comment},
  {"get_num_queued_textures", &Dtool_PreparedGraphicsObjects_get_num_queued_textures_1532, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_textures_1532_comment},
  {"getNumQueuedTextures", &Dtool_PreparedGraphicsObjects_get_num_queued_textures_1532, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_textures_1532_comment},
  {"get_num_prepared_textures", &Dtool_PreparedGraphicsObjects_get_num_prepared_textures_1533, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_textures_1533_comment},
  {"getNumPreparedTextures", &Dtool_PreparedGraphicsObjects_get_num_prepared_textures_1533, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_textures_1533_comment},
  {"prepare_texture_now", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_texture_now_1534, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_texture_now_1534_comment},
  {"prepareTextureNow", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_texture_now_1534, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_texture_now_1534_comment},
  {"enqueue_sampler", &Dtool_PreparedGraphicsObjects_enqueue_sampler_1535, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_sampler_1535_comment},
  {"enqueueSampler", &Dtool_PreparedGraphicsObjects_enqueue_sampler_1535, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_sampler_1535_comment},
  {"is_sampler_queued", &Dtool_PreparedGraphicsObjects_is_sampler_queued_1536, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_sampler_queued_1536_comment},
  {"isSamplerQueued", &Dtool_PreparedGraphicsObjects_is_sampler_queued_1536, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_sampler_queued_1536_comment},
  {"dequeue_sampler", &Dtool_PreparedGraphicsObjects_dequeue_sampler_1537, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_sampler_1537_comment},
  {"dequeueSampler", &Dtool_PreparedGraphicsObjects_dequeue_sampler_1537, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_sampler_1537_comment},
  {"is_sampler_prepared", &Dtool_PreparedGraphicsObjects_is_sampler_prepared_1538, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_sampler_prepared_1538_comment},
  {"isSamplerPrepared", &Dtool_PreparedGraphicsObjects_is_sampler_prepared_1538, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_sampler_prepared_1538_comment},
  {"release_sampler", &Dtool_PreparedGraphicsObjects_release_sampler_1539, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_sampler_1539_comment},
  {"releaseSampler", &Dtool_PreparedGraphicsObjects_release_sampler_1539, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_sampler_1539_comment},
  {"release_all_samplers", &Dtool_PreparedGraphicsObjects_release_all_samplers_1540, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_samplers_1540_comment},
  {"releaseAllSamplers", &Dtool_PreparedGraphicsObjects_release_all_samplers_1540, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_samplers_1540_comment},
  {"get_num_queued_samplers", &Dtool_PreparedGraphicsObjects_get_num_queued_samplers_1541, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_samplers_1541_comment},
  {"getNumQueuedSamplers", &Dtool_PreparedGraphicsObjects_get_num_queued_samplers_1541, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_samplers_1541_comment},
  {"get_num_prepared_samplers", &Dtool_PreparedGraphicsObjects_get_num_prepared_samplers_1542, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_samplers_1542_comment},
  {"getNumPreparedSamplers", &Dtool_PreparedGraphicsObjects_get_num_prepared_samplers_1542, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_samplers_1542_comment},
  {"enqueue_geom", &Dtool_PreparedGraphicsObjects_enqueue_geom_1544, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_geom_1544_comment},
  {"enqueueGeom", &Dtool_PreparedGraphicsObjects_enqueue_geom_1544, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_geom_1544_comment},
  {"is_geom_queued", &Dtool_PreparedGraphicsObjects_is_geom_queued_1545, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_geom_queued_1545_comment},
  {"isGeomQueued", &Dtool_PreparedGraphicsObjects_is_geom_queued_1545, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_geom_queued_1545_comment},
  {"dequeue_geom", &Dtool_PreparedGraphicsObjects_dequeue_geom_1546, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_geom_1546_comment},
  {"dequeueGeom", &Dtool_PreparedGraphicsObjects_dequeue_geom_1546, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_geom_1546_comment},
  {"is_geom_prepared", &Dtool_PreparedGraphicsObjects_is_geom_prepared_1547, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_geom_prepared_1547_comment},
  {"isGeomPrepared", &Dtool_PreparedGraphicsObjects_is_geom_prepared_1547, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_geom_prepared_1547_comment},
  {"release_geom", &Dtool_PreparedGraphicsObjects_release_geom_1548, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_geom_1548_comment},
  {"releaseGeom", &Dtool_PreparedGraphicsObjects_release_geom_1548, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_geom_1548_comment},
  {"release_all_geoms", &Dtool_PreparedGraphicsObjects_release_all_geoms_1549, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_geoms_1549_comment},
  {"releaseAllGeoms", &Dtool_PreparedGraphicsObjects_release_all_geoms_1549, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_geoms_1549_comment},
  {"get_num_queued_geoms", &Dtool_PreparedGraphicsObjects_get_num_queued_geoms_1550, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_geoms_1550_comment},
  {"getNumQueuedGeoms", &Dtool_PreparedGraphicsObjects_get_num_queued_geoms_1550, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_geoms_1550_comment},
  {"get_num_prepared_geoms", &Dtool_PreparedGraphicsObjects_get_num_prepared_geoms_1551, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_geoms_1551_comment},
  {"getNumPreparedGeoms", &Dtool_PreparedGraphicsObjects_get_num_prepared_geoms_1551, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_geoms_1551_comment},
  {"prepare_geom_now", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_geom_now_1552, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_geom_now_1552_comment},
  {"prepareGeomNow", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_geom_now_1552, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_geom_now_1552_comment},
  {"enqueue_shader", &Dtool_PreparedGraphicsObjects_enqueue_shader_1553, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_shader_1553_comment},
  {"enqueueShader", &Dtool_PreparedGraphicsObjects_enqueue_shader_1553, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_shader_1553_comment},
  {"is_shader_queued", &Dtool_PreparedGraphicsObjects_is_shader_queued_1554, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_shader_queued_1554_comment},
  {"isShaderQueued", &Dtool_PreparedGraphicsObjects_is_shader_queued_1554, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_shader_queued_1554_comment},
  {"dequeue_shader", &Dtool_PreparedGraphicsObjects_dequeue_shader_1555, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_shader_1555_comment},
  {"dequeueShader", &Dtool_PreparedGraphicsObjects_dequeue_shader_1555, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_shader_1555_comment},
  {"is_shader_prepared", &Dtool_PreparedGraphicsObjects_is_shader_prepared_1556, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_shader_prepared_1556_comment},
  {"isShaderPrepared", &Dtool_PreparedGraphicsObjects_is_shader_prepared_1556, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_shader_prepared_1556_comment},
  {"release_shader", &Dtool_PreparedGraphicsObjects_release_shader_1557, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_shader_1557_comment},
  {"releaseShader", &Dtool_PreparedGraphicsObjects_release_shader_1557, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_shader_1557_comment},
  {"release_all_shaders", &Dtool_PreparedGraphicsObjects_release_all_shaders_1558, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_shaders_1558_comment},
  {"releaseAllShaders", &Dtool_PreparedGraphicsObjects_release_all_shaders_1558, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_shaders_1558_comment},
  {"get_num_queued_shaders", &Dtool_PreparedGraphicsObjects_get_num_queued_shaders_1559, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_shaders_1559_comment},
  {"getNumQueuedShaders", &Dtool_PreparedGraphicsObjects_get_num_queued_shaders_1559, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_shaders_1559_comment},
  {"get_num_prepared_shaders", &Dtool_PreparedGraphicsObjects_get_num_prepared_shaders_1560, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_shaders_1560_comment},
  {"getNumPreparedShaders", &Dtool_PreparedGraphicsObjects_get_num_prepared_shaders_1560, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_shaders_1560_comment},
  {"prepare_shader_now", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_shader_now_1561, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_shader_now_1561_comment},
  {"prepareShaderNow", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_shader_now_1561, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_shader_now_1561_comment},
  {"enqueue_vertex_buffer", &Dtool_PreparedGraphicsObjects_enqueue_vertex_buffer_1562, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_vertex_buffer_1562_comment},
  {"enqueueVertexBuffer", &Dtool_PreparedGraphicsObjects_enqueue_vertex_buffer_1562, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_vertex_buffer_1562_comment},
  {"is_vertex_buffer_queued", &Dtool_PreparedGraphicsObjects_is_vertex_buffer_queued_1563, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_vertex_buffer_queued_1563_comment},
  {"isVertexBufferQueued", &Dtool_PreparedGraphicsObjects_is_vertex_buffer_queued_1563, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_vertex_buffer_queued_1563_comment},
  {"dequeue_vertex_buffer", &Dtool_PreparedGraphicsObjects_dequeue_vertex_buffer_1564, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_vertex_buffer_1564_comment},
  {"dequeueVertexBuffer", &Dtool_PreparedGraphicsObjects_dequeue_vertex_buffer_1564, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_vertex_buffer_1564_comment},
  {"is_vertex_buffer_prepared", &Dtool_PreparedGraphicsObjects_is_vertex_buffer_prepared_1565, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_vertex_buffer_prepared_1565_comment},
  {"isVertexBufferPrepared", &Dtool_PreparedGraphicsObjects_is_vertex_buffer_prepared_1565, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_vertex_buffer_prepared_1565_comment},
  {"release_vertex_buffer", &Dtool_PreparedGraphicsObjects_release_vertex_buffer_1566, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_vertex_buffer_1566_comment},
  {"releaseVertexBuffer", &Dtool_PreparedGraphicsObjects_release_vertex_buffer_1566, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_vertex_buffer_1566_comment},
  {"release_all_vertex_buffers", &Dtool_PreparedGraphicsObjects_release_all_vertex_buffers_1567, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_vertex_buffers_1567_comment},
  {"releaseAllVertexBuffers", &Dtool_PreparedGraphicsObjects_release_all_vertex_buffers_1567, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_vertex_buffers_1567_comment},
  {"get_num_queued_vertex_buffers", &Dtool_PreparedGraphicsObjects_get_num_queued_vertex_buffers_1568, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_vertex_buffers_1568_comment},
  {"getNumQueuedVertexBuffers", &Dtool_PreparedGraphicsObjects_get_num_queued_vertex_buffers_1568, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_vertex_buffers_1568_comment},
  {"get_num_prepared_vertex_buffers", &Dtool_PreparedGraphicsObjects_get_num_prepared_vertex_buffers_1569, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_vertex_buffers_1569_comment},
  {"getNumPreparedVertexBuffers", &Dtool_PreparedGraphicsObjects_get_num_prepared_vertex_buffers_1569, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_vertex_buffers_1569_comment},
  {"prepare_vertex_buffer_now", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_vertex_buffer_now_1570, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_vertex_buffer_now_1570_comment},
  {"prepareVertexBufferNow", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_vertex_buffer_now_1570, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_vertex_buffer_now_1570_comment},
  {"enqueue_index_buffer", &Dtool_PreparedGraphicsObjects_enqueue_index_buffer_1571, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_index_buffer_1571_comment},
  {"enqueueIndexBuffer", &Dtool_PreparedGraphicsObjects_enqueue_index_buffer_1571, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_index_buffer_1571_comment},
  {"is_index_buffer_queued", &Dtool_PreparedGraphicsObjects_is_index_buffer_queued_1572, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_index_buffer_queued_1572_comment},
  {"isIndexBufferQueued", &Dtool_PreparedGraphicsObjects_is_index_buffer_queued_1572, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_index_buffer_queued_1572_comment},
  {"dequeue_index_buffer", &Dtool_PreparedGraphicsObjects_dequeue_index_buffer_1573, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_index_buffer_1573_comment},
  {"dequeueIndexBuffer", &Dtool_PreparedGraphicsObjects_dequeue_index_buffer_1573, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_index_buffer_1573_comment},
  {"is_index_buffer_prepared", &Dtool_PreparedGraphicsObjects_is_index_buffer_prepared_1574, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_index_buffer_prepared_1574_comment},
  {"isIndexBufferPrepared", &Dtool_PreparedGraphicsObjects_is_index_buffer_prepared_1574, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_index_buffer_prepared_1574_comment},
  {"release_index_buffer", &Dtool_PreparedGraphicsObjects_release_index_buffer_1575, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_index_buffer_1575_comment},
  {"releaseIndexBuffer", &Dtool_PreparedGraphicsObjects_release_index_buffer_1575, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_index_buffer_1575_comment},
  {"release_all_index_buffers", &Dtool_PreparedGraphicsObjects_release_all_index_buffers_1576, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_index_buffers_1576_comment},
  {"releaseAllIndexBuffers", &Dtool_PreparedGraphicsObjects_release_all_index_buffers_1576, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_index_buffers_1576_comment},
  {"get_num_queued_index_buffers", &Dtool_PreparedGraphicsObjects_get_num_queued_index_buffers_1577, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_index_buffers_1577_comment},
  {"getNumQueuedIndexBuffers", &Dtool_PreparedGraphicsObjects_get_num_queued_index_buffers_1577, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_index_buffers_1577_comment},
  {"get_num_prepared_index_buffers", &Dtool_PreparedGraphicsObjects_get_num_prepared_index_buffers_1578, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_index_buffers_1578_comment},
  {"getNumPreparedIndexBuffers", &Dtool_PreparedGraphicsObjects_get_num_prepared_index_buffers_1578, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_index_buffers_1578_comment},
  {"prepare_index_buffer_now", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_index_buffer_now_1579, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_index_buffer_now_1579_comment},
  {"prepareIndexBufferNow", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_index_buffer_now_1579, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_index_buffer_now_1579_comment},
  {"enqueue_shader_buffer", &Dtool_PreparedGraphicsObjects_enqueue_shader_buffer_1580, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_shader_buffer_1580_comment},
  {"enqueueShaderBuffer", &Dtool_PreparedGraphicsObjects_enqueue_shader_buffer_1580, METH_O, (const char *)Dtool_PreparedGraphicsObjects_enqueue_shader_buffer_1580_comment},
  {"is_shader_buffer_queued", &Dtool_PreparedGraphicsObjects_is_shader_buffer_queued_1581, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_shader_buffer_queued_1581_comment},
  {"isShaderBufferQueued", &Dtool_PreparedGraphicsObjects_is_shader_buffer_queued_1581, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_shader_buffer_queued_1581_comment},
  {"dequeue_shader_buffer", &Dtool_PreparedGraphicsObjects_dequeue_shader_buffer_1582, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_shader_buffer_1582_comment},
  {"dequeueShaderBuffer", &Dtool_PreparedGraphicsObjects_dequeue_shader_buffer_1582, METH_O, (const char *)Dtool_PreparedGraphicsObjects_dequeue_shader_buffer_1582_comment},
  {"is_shader_buffer_prepared", &Dtool_PreparedGraphicsObjects_is_shader_buffer_prepared_1583, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_shader_buffer_prepared_1583_comment},
  {"isShaderBufferPrepared", &Dtool_PreparedGraphicsObjects_is_shader_buffer_prepared_1583, METH_O, (const char *)Dtool_PreparedGraphicsObjects_is_shader_buffer_prepared_1583_comment},
  {"release_shader_buffer", &Dtool_PreparedGraphicsObjects_release_shader_buffer_1584, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_shader_buffer_1584_comment},
  {"releaseShaderBuffer", &Dtool_PreparedGraphicsObjects_release_shader_buffer_1584, METH_O, (const char *)Dtool_PreparedGraphicsObjects_release_shader_buffer_1584_comment},
  {"release_all_shader_buffers", &Dtool_PreparedGraphicsObjects_release_all_shader_buffers_1585, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_shader_buffers_1585_comment},
  {"releaseAllShaderBuffers", &Dtool_PreparedGraphicsObjects_release_all_shader_buffers_1585, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_release_all_shader_buffers_1585_comment},
  {"get_num_queued_shader_buffers", &Dtool_PreparedGraphicsObjects_get_num_queued_shader_buffers_1586, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_shader_buffers_1586_comment},
  {"getNumQueuedShaderBuffers", &Dtool_PreparedGraphicsObjects_get_num_queued_shader_buffers_1586, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_queued_shader_buffers_1586_comment},
  {"get_num_prepared_shader_buffers", &Dtool_PreparedGraphicsObjects_get_num_prepared_shader_buffers_1587, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_shader_buffers_1587_comment},
  {"getNumPreparedShaderBuffers", &Dtool_PreparedGraphicsObjects_get_num_prepared_shader_buffers_1587, METH_NOARGS, (const char *)Dtool_PreparedGraphicsObjects_get_num_prepared_shader_buffers_1587_comment},
  {"prepare_shader_buffer_now", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_shader_buffer_now_1588, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_shader_buffer_now_1588_comment},
  {"prepareShaderBufferNow", (PyCFunction) &Dtool_PreparedGraphicsObjects_prepare_shader_buffer_now_1588, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PreparedGraphicsObjects_prepare_shader_buffer_now_1588_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PreparedGraphicsObjects = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PreparedGraphicsObjects = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PreparedGraphicsObjects = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PreparedGraphicsObjects = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PreparedGraphicsObjects = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PreparedGraphicsObjects = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PreparedGraphicsObjects",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PreparedGraphicsObjects,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PreparedGraphicsObjects,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PreparedGraphicsObjects,
    &Dtool_SequenceMethods_PreparedGraphicsObjects,
    &Dtool_MappingMethods_PreparedGraphicsObjects,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PreparedGraphicsObjects,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A table of objects that are saved within the graphics context for reference\n"
    " * by handle later.  Generally, this represents things like OpenGL texture\n"
    " * objects or display lists (or their equivalent on other platforms).\n"
    " *\n"
    " * This object simply records the pointers to the context objects created by\n"
    " * the individual GSG's; these context objects will contain enough information\n"
    " * to reference or release the actual object stored within the graphics\n"
    " * context.\n"
    " *\n"
    " * These tables may potentially be shared between related graphics contexts,\n"
    " * hence their storage here in a separate object rather than as a part of the\n"
    " * GraphicsStateGuardian.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PreparedGraphicsObjects,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PreparedGraphicsObjects,
    PyType_GenericAlloc,
    Dtool_new_PreparedGraphicsObjects,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PreparedGraphicsObjects,
  Dtool_UpcastInterface_PreparedGraphicsObjects,
  Dtool_DowncastInterface_PreparedGraphicsObjects,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PreparedGraphicsObjects(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PreparedGraphicsObjects._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_PreparedGraphicsObjects._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PreparedGraphicsObjects._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PreparedGraphicsObjects) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PreparedGraphicsObjects)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PreparedGraphicsObjects);
  }
}

/**
 * Python method tables for IndexBufferContext (IndexBufferContext)
 */
static PyMethodDef Dtool_Methods_IndexBufferContext[] = {
  {"get_data", &Dtool_IndexBufferContext_get_data_1594, METH_NOARGS, (const char *)Dtool_IndexBufferContext_get_data_1594_comment},
  {"getData", &Dtool_IndexBufferContext_get_data_1594, METH_NOARGS, (const char *)Dtool_IndexBufferContext_get_data_1594_comment},
  {"get_class_type", &Dtool_IndexBufferContext_get_class_type_1598, METH_NOARGS | METH_STATIC, (const char *)Dtool_IndexBufferContext_get_class_type_1598_comment},
  {"getClassType", &Dtool_IndexBufferContext_get_class_type_1598, METH_NOARGS | METH_STATIC, (const char *)Dtool_IndexBufferContext_get_class_type_1598_comment},
  {"upcast_to_BufferContext", &Dtool_IndexBufferContext_upcast_to_BufferContext_1590, METH_NOARGS, (const char *)Dtool_IndexBufferContext_upcast_to_BufferContext_1590_comment},
  {"upcastToBufferContext", &Dtool_IndexBufferContext_upcast_to_BufferContext_1590, METH_NOARGS, (const char *)Dtool_IndexBufferContext_upcast_to_BufferContext_1590_comment},
  {"upcast_to_AdaptiveLruPage", &Dtool_IndexBufferContext_upcast_to_AdaptiveLruPage_1592, METH_NOARGS, (const char *)Dtool_IndexBufferContext_upcast_to_AdaptiveLruPage_1592_comment},
  {"upcastToAdaptiveLruPage", &Dtool_IndexBufferContext_upcast_to_AdaptiveLruPage_1592, METH_NOARGS, (const char *)Dtool_IndexBufferContext_upcast_to_AdaptiveLruPage_1592_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_IndexBufferContext = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_IndexBufferContext = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_IndexBufferContext = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_IndexBufferContext = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_IndexBufferContext = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_IndexBufferContext = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.IndexBufferContext",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_IndexBufferContext,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_IndexBufferContext,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_IndexBufferContext,
    &Dtool_SequenceMethods_IndexBufferContext,
    &Dtool_MappingMethods_IndexBufferContext,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_IndexBufferContext,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special class object that holds all the information returned by a\n"
    " * particular GSG to indicate the vertex data array's internal context\n"
    " * identifier.\n"
    " *\n"
    " * This allows the GSG to cache the vertex data array in whatever way makes\n"
    " * sense.  For instance, DirectX can allocate a vertex buffer for the array.\n"
    " * OpenGL can create a buffer object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_IndexBufferContext,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_IndexBufferContext,
    PyType_GenericAlloc,
    Dtool_new_IndexBufferContext,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IndexBufferContext,
  Dtool_UpcastInterface_IndexBufferContext,
  Dtool_DowncastInterface_IndexBufferContext,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_IndexBufferContext(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BufferContext(nullptr);
    Dtool_PyModuleClassInit_AdaptiveLruPage(nullptr);
    Dtool_IndexBufferContext._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_BufferContext, (PyTypeObject *)&Dtool_AdaptiveLruPage);
    Dtool_IndexBufferContext._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_IndexBufferContext._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IndexBufferContext) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IndexBufferContext)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IndexBufferContext);
  }
}

/**
 * Python method tables for Lens (Lens)
 */
static PyMethodDef Dtool_Methods_Lens[] = {
  {"make_copy", &Dtool_Lens_make_copy_1602, METH_NOARGS, (const char *)Dtool_Lens_make_copy_1602_comment},
  {"makeCopy", &Dtool_Lens_make_copy_1602, METH_NOARGS, (const char *)Dtool_Lens_make_copy_1602_comment},
  {"extrude", (PyCFunction) &Dtool_Lens_extrude_1603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_extrude_1603_comment},
  {"extrude_depth", (PyCFunction) &Dtool_Lens_extrude_depth_1604, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_extrude_depth_1604_comment},
  {"extrudeDepth", (PyCFunction) &Dtool_Lens_extrude_depth_1604, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_extrude_depth_1604_comment},
  {"extrude_vec", (PyCFunction) &Dtool_Lens_extrude_vec_1605, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_extrude_vec_1605_comment},
  {"extrudeVec", (PyCFunction) &Dtool_Lens_extrude_vec_1605, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_extrude_vec_1605_comment},
  {"project", (PyCFunction) &Dtool_Lens_project_1606, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_project_1606_comment},
  {"set_change_event", &Dtool_Lens_set_change_event_1607, METH_O, (const char *)Dtool_Lens_set_change_event_1607_comment},
  {"setChangeEvent", &Dtool_Lens_set_change_event_1607, METH_O, (const char *)Dtool_Lens_set_change_event_1607_comment},
  {"get_change_event", &Dtool_Lens_get_change_event_1608, METH_NOARGS, (const char *)Dtool_Lens_get_change_event_1608_comment},
  {"getChangeEvent", &Dtool_Lens_get_change_event_1608, METH_NOARGS, (const char *)Dtool_Lens_get_change_event_1608_comment},
  {"set_coordinate_system", &Dtool_Lens_set_coordinate_system_1610, METH_O, (const char *)Dtool_Lens_set_coordinate_system_1610_comment},
  {"setCoordinateSystem", &Dtool_Lens_set_coordinate_system_1610, METH_O, (const char *)Dtool_Lens_set_coordinate_system_1610_comment},
  {"get_coordinate_system", &Dtool_Lens_get_coordinate_system_1611, METH_NOARGS, (const char *)Dtool_Lens_get_coordinate_system_1611_comment},
  {"getCoordinateSystem", &Dtool_Lens_get_coordinate_system_1611, METH_NOARGS, (const char *)Dtool_Lens_get_coordinate_system_1611_comment},
  {"clear", &Dtool_Lens_clear_1614, METH_NOARGS, (const char *)Dtool_Lens_clear_1614_comment},
  {"set_film_size", (PyCFunction) &Dtool_Lens_set_film_size_1615, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_film_size_1615_comment},
  {"setFilmSize", (PyCFunction) &Dtool_Lens_set_film_size_1615, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_film_size_1615_comment},
  {"get_film_size", &Dtool_Lens_get_film_size_1616, METH_NOARGS, (const char *)Dtool_Lens_get_film_size_1616_comment},
  {"getFilmSize", &Dtool_Lens_get_film_size_1616, METH_NOARGS, (const char *)Dtool_Lens_get_film_size_1616_comment},
  {"set_film_offset", (PyCFunction) &Dtool_Lens_set_film_offset_1621, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_film_offset_1621_comment},
  {"setFilmOffset", (PyCFunction) &Dtool_Lens_set_film_offset_1621, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_film_offset_1621_comment},
  {"get_film_offset", &Dtool_Lens_get_film_offset_1622, METH_NOARGS, (const char *)Dtool_Lens_get_film_offset_1622_comment},
  {"getFilmOffset", &Dtool_Lens_get_film_offset_1622, METH_NOARGS, (const char *)Dtool_Lens_get_film_offset_1622_comment},
  {"set_focal_length", &Dtool_Lens_set_focal_length_1627, METH_O, (const char *)Dtool_Lens_set_focal_length_1627_comment},
  {"setFocalLength", &Dtool_Lens_set_focal_length_1627, METH_O, (const char *)Dtool_Lens_set_focal_length_1627_comment},
  {"get_focal_length", &Dtool_Lens_get_focal_length_1628, METH_NOARGS, (const char *)Dtool_Lens_get_focal_length_1628_comment},
  {"getFocalLength", &Dtool_Lens_get_focal_length_1628, METH_NOARGS, (const char *)Dtool_Lens_get_focal_length_1628_comment},
  {"set_min_fov", &Dtool_Lens_set_min_fov_1630, METH_O, (const char *)Dtool_Lens_set_min_fov_1630_comment},
  {"setMinFov", &Dtool_Lens_set_min_fov_1630, METH_O, (const char *)Dtool_Lens_set_min_fov_1630_comment},
  {"set_fov", (PyCFunction) &Dtool_Lens_set_fov_1631, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_fov_1631_comment},
  {"setFov", (PyCFunction) &Dtool_Lens_set_fov_1631, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_fov_1631_comment},
  {"get_fov", &Dtool_Lens_get_fov_1632, METH_NOARGS, (const char *)Dtool_Lens_get_fov_1632_comment},
  {"getFov", &Dtool_Lens_get_fov_1632, METH_NOARGS, (const char *)Dtool_Lens_get_fov_1632_comment},
  {"get_hfov", &Dtool_Lens_get_hfov_1633, METH_NOARGS, (const char *)Dtool_Lens_get_hfov_1633_comment},
  {"getHfov", &Dtool_Lens_get_hfov_1633, METH_NOARGS, (const char *)Dtool_Lens_get_hfov_1633_comment},
  {"get_vfov", &Dtool_Lens_get_vfov_1634, METH_NOARGS, (const char *)Dtool_Lens_get_vfov_1634_comment},
  {"getVfov", &Dtool_Lens_get_vfov_1634, METH_NOARGS, (const char *)Dtool_Lens_get_vfov_1634_comment},
  {"get_min_fov", &Dtool_Lens_get_min_fov_1635, METH_NOARGS, (const char *)Dtool_Lens_get_min_fov_1635_comment},
  {"getMinFov", &Dtool_Lens_get_min_fov_1635, METH_NOARGS, (const char *)Dtool_Lens_get_min_fov_1635_comment},
  {"set_aspect_ratio", &Dtool_Lens_set_aspect_ratio_1638, METH_O, (const char *)Dtool_Lens_set_aspect_ratio_1638_comment},
  {"setAspectRatio", &Dtool_Lens_set_aspect_ratio_1638, METH_O, (const char *)Dtool_Lens_set_aspect_ratio_1638_comment},
  {"get_aspect_ratio", &Dtool_Lens_get_aspect_ratio_1639, METH_NOARGS, (const char *)Dtool_Lens_get_aspect_ratio_1639_comment},
  {"getAspectRatio", &Dtool_Lens_get_aspect_ratio_1639, METH_NOARGS, (const char *)Dtool_Lens_get_aspect_ratio_1639_comment},
  {"set_near", &Dtool_Lens_set_near_1641, METH_O, (const char *)Dtool_Lens_set_near_1641_comment},
  {"setNear", &Dtool_Lens_set_near_1641, METH_O, (const char *)Dtool_Lens_set_near_1641_comment},
  {"get_near", &Dtool_Lens_get_near_1642, METH_NOARGS, (const char *)Dtool_Lens_get_near_1642_comment},
  {"getNear", &Dtool_Lens_get_near_1642, METH_NOARGS, (const char *)Dtool_Lens_get_near_1642_comment},
  {"set_far", &Dtool_Lens_set_far_1643, METH_O, (const char *)Dtool_Lens_set_far_1643_comment},
  {"setFar", &Dtool_Lens_set_far_1643, METH_O, (const char *)Dtool_Lens_set_far_1643_comment},
  {"get_far", &Dtool_Lens_get_far_1644, METH_NOARGS, (const char *)Dtool_Lens_get_far_1644_comment},
  {"getFar", &Dtool_Lens_get_far_1644, METH_NOARGS, (const char *)Dtool_Lens_get_far_1644_comment},
  {"set_near_far", (PyCFunction) &Dtool_Lens_set_near_far_1645, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_near_far_1645_comment},
  {"setNearFar", (PyCFunction) &Dtool_Lens_set_near_far_1645, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_near_far_1645_comment},
  {"get_default_near", &Dtool_Lens_get_default_near_1648, METH_NOARGS | METH_STATIC, (const char *)Dtool_Lens_get_default_near_1648_comment},
  {"getDefaultNear", &Dtool_Lens_get_default_near_1648, METH_NOARGS | METH_STATIC, (const char *)Dtool_Lens_get_default_near_1648_comment},
  {"get_default_far", &Dtool_Lens_get_default_far_1649, METH_NOARGS | METH_STATIC, (const char *)Dtool_Lens_get_default_far_1649_comment},
  {"getDefaultFar", &Dtool_Lens_get_default_far_1649, METH_NOARGS | METH_STATIC, (const char *)Dtool_Lens_get_default_far_1649_comment},
  {"set_view_hpr", (PyCFunction) &Dtool_Lens_set_view_hpr_1650, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_view_hpr_1650_comment},
  {"setViewHpr", (PyCFunction) &Dtool_Lens_set_view_hpr_1650, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_view_hpr_1650_comment},
  {"get_view_hpr", &Dtool_Lens_get_view_hpr_1651, METH_NOARGS, (const char *)Dtool_Lens_get_view_hpr_1651_comment},
  {"getViewHpr", &Dtool_Lens_get_view_hpr_1651, METH_NOARGS, (const char *)Dtool_Lens_get_view_hpr_1651_comment},
  {"set_view_vector", (PyCFunction) &Dtool_Lens_set_view_vector_1656, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_view_vector_1656_comment},
  {"setViewVector", (PyCFunction) &Dtool_Lens_set_view_vector_1656, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_view_vector_1656_comment},
  {"get_view_vector", &Dtool_Lens_get_view_vector_1657, METH_NOARGS, (const char *)Dtool_Lens_get_view_vector_1657_comment},
  {"getViewVector", &Dtool_Lens_get_view_vector_1657, METH_NOARGS, (const char *)Dtool_Lens_get_view_vector_1657_comment},
  {"get_up_vector", &Dtool_Lens_get_up_vector_1658, METH_NOARGS, (const char *)Dtool_Lens_get_up_vector_1658_comment},
  {"getUpVector", &Dtool_Lens_get_up_vector_1658, METH_NOARGS, (const char *)Dtool_Lens_get_up_vector_1658_comment},
  {"get_nodal_point", &Dtool_Lens_get_nodal_point_1659, METH_NOARGS, (const char *)Dtool_Lens_get_nodal_point_1659_comment},
  {"getNodalPoint", &Dtool_Lens_get_nodal_point_1659, METH_NOARGS, (const char *)Dtool_Lens_get_nodal_point_1659_comment},
  {"set_interocular_distance", &Dtool_Lens_set_interocular_distance_1663, METH_O, (const char *)Dtool_Lens_set_interocular_distance_1663_comment},
  {"setInterocularDistance", &Dtool_Lens_set_interocular_distance_1663, METH_O, (const char *)Dtool_Lens_set_interocular_distance_1663_comment},
  {"get_interocular_distance", &Dtool_Lens_get_interocular_distance_1664, METH_NOARGS, (const char *)Dtool_Lens_get_interocular_distance_1664_comment},
  {"getInterocularDistance", &Dtool_Lens_get_interocular_distance_1664, METH_NOARGS, (const char *)Dtool_Lens_get_interocular_distance_1664_comment},
  {"set_convergence_distance", &Dtool_Lens_set_convergence_distance_1665, METH_O, (const char *)Dtool_Lens_set_convergence_distance_1665_comment},
  {"setConvergenceDistance", &Dtool_Lens_set_convergence_distance_1665, METH_O, (const char *)Dtool_Lens_set_convergence_distance_1665_comment},
  {"get_convergence_distance", &Dtool_Lens_get_convergence_distance_1666, METH_NOARGS, (const char *)Dtool_Lens_get_convergence_distance_1666_comment},
  {"getConvergenceDistance", &Dtool_Lens_get_convergence_distance_1666, METH_NOARGS, (const char *)Dtool_Lens_get_convergence_distance_1666_comment},
  {"set_view_mat", &Dtool_Lens_set_view_mat_1669, METH_O, (const char *)Dtool_Lens_set_view_mat_1669_comment},
  {"setViewMat", &Dtool_Lens_set_view_mat_1669, METH_O, (const char *)Dtool_Lens_set_view_mat_1669_comment},
  {"get_view_mat", &Dtool_Lens_get_view_mat_1670, METH_NOARGS, (const char *)Dtool_Lens_get_view_mat_1670_comment},
  {"getViewMat", &Dtool_Lens_get_view_mat_1670, METH_NOARGS, (const char *)Dtool_Lens_get_view_mat_1670_comment},
  {"clear_view_mat", &Dtool_Lens_clear_view_mat_1671, METH_NOARGS, (const char *)Dtool_Lens_clear_view_mat_1671_comment},
  {"clearViewMat", &Dtool_Lens_clear_view_mat_1671, METH_NOARGS, (const char *)Dtool_Lens_clear_view_mat_1671_comment},
  {"set_keystone", &Dtool_Lens_set_keystone_1676, METH_O, (const char *)Dtool_Lens_set_keystone_1676_comment},
  {"setKeystone", &Dtool_Lens_set_keystone_1676, METH_O, (const char *)Dtool_Lens_set_keystone_1676_comment},
  {"get_keystone", &Dtool_Lens_get_keystone_1677, METH_NOARGS, (const char *)Dtool_Lens_get_keystone_1677_comment},
  {"getKeystone", &Dtool_Lens_get_keystone_1677, METH_NOARGS, (const char *)Dtool_Lens_get_keystone_1677_comment},
  {"clear_keystone", &Dtool_Lens_clear_keystone_1678, METH_NOARGS, (const char *)Dtool_Lens_clear_keystone_1678_comment},
  {"clearKeystone", &Dtool_Lens_clear_keystone_1678, METH_NOARGS, (const char *)Dtool_Lens_clear_keystone_1678_comment},
  {"set_custom_film_mat", &Dtool_Lens_set_custom_film_mat_1680, METH_O, (const char *)Dtool_Lens_set_custom_film_mat_1680_comment},
  {"setCustomFilmMat", &Dtool_Lens_set_custom_film_mat_1680, METH_O, (const char *)Dtool_Lens_set_custom_film_mat_1680_comment},
  {"get_custom_film_mat", &Dtool_Lens_get_custom_film_mat_1681, METH_NOARGS, (const char *)Dtool_Lens_get_custom_film_mat_1681_comment},
  {"getCustomFilmMat", &Dtool_Lens_get_custom_film_mat_1681, METH_NOARGS, (const char *)Dtool_Lens_get_custom_film_mat_1681_comment},
  {"clear_custom_film_mat", &Dtool_Lens_clear_custom_film_mat_1682, METH_NOARGS, (const char *)Dtool_Lens_clear_custom_film_mat_1682_comment},
  {"clearCustomFilmMat", &Dtool_Lens_clear_custom_film_mat_1682, METH_NOARGS, (const char *)Dtool_Lens_clear_custom_film_mat_1682_comment},
  {"set_frustum_from_corners", (PyCFunction) &Dtool_Lens_set_frustum_from_corners_1684, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_frustum_from_corners_1684_comment},
  {"setFrustumFromCorners", (PyCFunction) &Dtool_Lens_set_frustum_from_corners_1684, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_set_frustum_from_corners_1684_comment},
  {"recompute_all", &Dtool_Lens_recompute_all_1685, METH_NOARGS, (const char *)Dtool_Lens_recompute_all_1685_comment},
  {"recomputeAll", &Dtool_Lens_recompute_all_1685, METH_NOARGS, (const char *)Dtool_Lens_recompute_all_1685_comment},
  {"is_linear", &Dtool_Lens_is_linear_1686, METH_NOARGS, (const char *)Dtool_Lens_is_linear_1686_comment},
  {"isLinear", &Dtool_Lens_is_linear_1686, METH_NOARGS, (const char *)Dtool_Lens_is_linear_1686_comment},
  {"is_perspective", &Dtool_Lens_is_perspective_1687, METH_NOARGS, (const char *)Dtool_Lens_is_perspective_1687_comment},
  {"isPerspective", &Dtool_Lens_is_perspective_1687, METH_NOARGS, (const char *)Dtool_Lens_is_perspective_1687_comment},
  {"is_orthographic", &Dtool_Lens_is_orthographic_1688, METH_NOARGS, (const char *)Dtool_Lens_is_orthographic_1688_comment},
  {"isOrthographic", &Dtool_Lens_is_orthographic_1688, METH_NOARGS, (const char *)Dtool_Lens_is_orthographic_1688_comment},
  {"make_geometry", &Dtool_Lens_make_geometry_1689, METH_NOARGS, (const char *)Dtool_Lens_make_geometry_1689_comment},
  {"makeGeometry", &Dtool_Lens_make_geometry_1689, METH_NOARGS, (const char *)Dtool_Lens_make_geometry_1689_comment},
  {"make_bounds", &Dtool_Lens_make_bounds_1690, METH_NOARGS, (const char *)Dtool_Lens_make_bounds_1690_comment},
  {"makeBounds", &Dtool_Lens_make_bounds_1690, METH_NOARGS, (const char *)Dtool_Lens_make_bounds_1690_comment},
  {"get_projection_mat", (PyCFunction) &Dtool_Lens_get_projection_mat_1691, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_get_projection_mat_1691_comment},
  {"getProjectionMat", (PyCFunction) &Dtool_Lens_get_projection_mat_1691, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_get_projection_mat_1691_comment},
  {"get_projection_mat_inv", (PyCFunction) &Dtool_Lens_get_projection_mat_inv_1692, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_get_projection_mat_inv_1692_comment},
  {"getProjectionMatInv", (PyCFunction) &Dtool_Lens_get_projection_mat_inv_1692, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_get_projection_mat_inv_1692_comment},
  {"get_film_mat", &Dtool_Lens_get_film_mat_1693, METH_NOARGS, (const char *)Dtool_Lens_get_film_mat_1693_comment},
  {"getFilmMat", &Dtool_Lens_get_film_mat_1693, METH_NOARGS, (const char *)Dtool_Lens_get_film_mat_1693_comment},
  {"get_film_mat_inv", &Dtool_Lens_get_film_mat_inv_1694, METH_NOARGS, (const char *)Dtool_Lens_get_film_mat_inv_1694_comment},
  {"getFilmMatInv", &Dtool_Lens_get_film_mat_inv_1694, METH_NOARGS, (const char *)Dtool_Lens_get_film_mat_inv_1694_comment},
  {"get_lens_mat", &Dtool_Lens_get_lens_mat_1695, METH_NOARGS, (const char *)Dtool_Lens_get_lens_mat_1695_comment},
  {"getLensMat", &Dtool_Lens_get_lens_mat_1695, METH_NOARGS, (const char *)Dtool_Lens_get_lens_mat_1695_comment},
  {"get_lens_mat_inv", &Dtool_Lens_get_lens_mat_inv_1696, METH_NOARGS, (const char *)Dtool_Lens_get_lens_mat_inv_1696_comment},
  {"getLensMatInv", &Dtool_Lens_get_lens_mat_inv_1696, METH_NOARGS, (const char *)Dtool_Lens_get_lens_mat_inv_1696_comment},
  {"output", &Dtool_Lens_output_1697, METH_O, (const char *)Dtool_Lens_output_1697_comment},
  {"write", (PyCFunction) &Dtool_Lens_write_1698, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Lens_write_1698_comment},
  {"get_last_change", &Dtool_Lens_get_last_change_1699, METH_NOARGS, (const char *)Dtool_Lens_get_last_change_1699_comment},
  {"getLastChange", &Dtool_Lens_get_last_change_1699, METH_NOARGS, (const char *)Dtool_Lens_get_last_change_1699_comment},
  {"get_class_type", &Dtool_Lens_get_class_type_1700, METH_NOARGS | METH_STATIC, (const char *)Dtool_Lens_get_class_type_1700_comment},
  {"getClassType", &Dtool_Lens_get_class_type_1700, METH_NOARGS | METH_STATIC, (const char *)Dtool_Lens_get_class_type_1700_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     Lens
//////////////////
static PyObject *Dtool_Repr_Lens(PyObject *self) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     Lens
//////////////////
static PyObject *Dtool_Str_Lens(PyObject *self) {
  Lens *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Lens, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_Lens[] = {
  {(char *)"change_event", &Dtool_Lens_change_event_Getter, &Dtool_Lens_change_event_Setter, nullptr, nullptr},
  {(char *)"coordinate_system", &Dtool_Lens_coordinate_system_Getter, &Dtool_Lens_coordinate_system_Setter, nullptr, nullptr},
  {(char *)"film_size", &Dtool_Lens_film_size_Getter, &Dtool_Lens_film_size_Setter, nullptr, nullptr},
  {(char *)"film_offset", &Dtool_Lens_film_offset_Getter, &Dtool_Lens_film_offset_Setter, nullptr, nullptr},
  {(char *)"focal_length", &Dtool_Lens_focal_length_Getter, &Dtool_Lens_focal_length_Setter, nullptr, nullptr},
  {(char *)"fov", &Dtool_Lens_fov_Getter, &Dtool_Lens_fov_Setter, nullptr, nullptr},
  {(char *)"min_fov", &Dtool_Lens_min_fov_Getter, &Dtool_Lens_min_fov_Setter, nullptr, nullptr},
  {(char *)"aspect_ratio", &Dtool_Lens_aspect_ratio_Getter, &Dtool_Lens_aspect_ratio_Setter, nullptr, nullptr},
  {(char *)"near", &Dtool_Lens_near_Getter, &Dtool_Lens_near_Setter, nullptr, nullptr},
  {(char *)"far", &Dtool_Lens_far_Getter, &Dtool_Lens_far_Setter, nullptr, nullptr},
  {(char *)"view_hpr", &Dtool_Lens_view_hpr_Getter, &Dtool_Lens_view_hpr_Setter, nullptr, nullptr},
  {(char *)"nodal_point", &Dtool_Lens_nodal_point_Getter, nullptr, nullptr, nullptr},
  {(char *)"interocular_distance", &Dtool_Lens_interocular_distance_Getter, &Dtool_Lens_interocular_distance_Setter, nullptr, nullptr},
  {(char *)"convergence_distance", &Dtool_Lens_convergence_distance_Getter, &Dtool_Lens_convergence_distance_Setter, nullptr, nullptr},
  {(char *)"view_mat", &Dtool_Lens_view_mat_Getter, &Dtool_Lens_view_mat_Setter, nullptr, nullptr},
  {(char *)"keystone", &Dtool_Lens_keystone_Getter, &Dtool_Lens_keystone_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Lens = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Lens = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Lens = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Lens = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Lens = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Lens = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Lens",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Lens,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Lens,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_Lens,
    &Dtool_NumberMethods_Lens,
    &Dtool_SequenceMethods_Lens,
    &Dtool_MappingMethods_Lens,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_Lens,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Lens,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for any number of different kinds of lenses, linear and\n"
    " * otherwise.  Presently, this includes perspective and orthographic lenses.\n"
    " *\n"
    " * A Lens object is the main part of a Camera node, which defines the\n"
    " * fundamental interface to point-of-view for rendering.  Lenses are also used\n"
    " * in other contexts, however; for instance, a Spotlight is also defined using\n"
    " * a lens.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Lens,
    nullptr, // tp_members
    Dtool_Properties_Lens,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Lens,
    PyType_GenericAlloc,
    Dtool_new_Lens,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Lens,
  Dtool_UpcastInterface_Lens,
  Dtool_DowncastInterface_Lens,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Lens(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_Lens._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_Lens._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(21);
    Dtool_Lens._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum Lens::StereoChannel;
    PyDict_SetItemString(dict, "SC_mono", Dtool_WrapValue(Lens::SC_mono));
    PyDict_SetItemString(dict, "SCMono", Dtool_WrapValue(Lens::SC_mono));
    PyDict_SetItemString(dict, "SC_left", Dtool_WrapValue(Lens::SC_left));
    PyDict_SetItemString(dict, "SCLeft", Dtool_WrapValue(Lens::SC_left));
    PyDict_SetItemString(dict, "SC_right", Dtool_WrapValue(Lens::SC_right));
    PyDict_SetItemString(dict, "SCRight", Dtool_WrapValue(Lens::SC_right));
    PyDict_SetItemString(dict, "SC_stereo", Dtool_WrapValue(Lens::SC_stereo));
    PyDict_SetItemString(dict, "SCStereo", Dtool_WrapValue(Lens::SC_stereo));
    // enum Lens::FromCorners;
    PyDict_SetItemString(dict, "FC_roll", Dtool_WrapValue(Lens::FC_roll));
    PyDict_SetItemString(dict, "FCRoll", Dtool_WrapValue(Lens::FC_roll));
    PyDict_SetItemString(dict, "FC_camera_plane", Dtool_WrapValue(Lens::FC_camera_plane));
    PyDict_SetItemString(dict, "FCCameraPlane", Dtool_WrapValue(Lens::FC_camera_plane));
    PyDict_SetItemString(dict, "FC_off_axis", Dtool_WrapValue(Lens::FC_off_axis));
    PyDict_SetItemString(dict, "FCOffAxis", Dtool_WrapValue(Lens::FC_off_axis));
    PyDict_SetItemString(dict, "FC_aspect_ratio", Dtool_WrapValue(Lens::FC_aspect_ratio));
    PyDict_SetItemString(dict, "FCAspectRatio", Dtool_WrapValue(Lens::FC_aspect_ratio));
    PyDict_SetItemString(dict, "FC_shear", Dtool_WrapValue(Lens::FC_shear));
    PyDict_SetItemString(dict, "FCShear", Dtool_WrapValue(Lens::FC_shear));
    PyDict_SetItemString(dict, "FC_keystone", Dtool_WrapValue(Lens::FC_keystone));
    PyDict_SetItemString(dict, "FCKeystone", Dtool_WrapValue(Lens::FC_keystone));
    if (PyType_Ready((PyTypeObject *)&Dtool_Lens) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Lens)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Lens);
  }
}

/**
 * Python method tables for Material (Material)
 */
static PyMethodDef Dtool_Methods_Material[] = {
  {"assign", &Dtool_Material_operator_1708, METH_O, (const char *)Dtool_Material_operator_1708_comment},
  {"get_default", &Dtool_Material_get_default_1710, METH_NOARGS | METH_STATIC, (const char *)Dtool_Material_get_default_1710_comment},
  {"getDefault", &Dtool_Material_get_default_1710, METH_NOARGS | METH_STATIC, (const char *)Dtool_Material_get_default_1710_comment},
  {"has_base_color", &Dtool_Material_has_base_color_1711, METH_NOARGS, (const char *)Dtool_Material_has_base_color_1711_comment},
  {"hasBaseColor", &Dtool_Material_has_base_color_1711, METH_NOARGS, (const char *)Dtool_Material_has_base_color_1711_comment},
  {"get_base_color", &Dtool_Material_get_base_color_1712, METH_NOARGS, (const char *)Dtool_Material_get_base_color_1712_comment},
  {"getBaseColor", &Dtool_Material_get_base_color_1712, METH_NOARGS, (const char *)Dtool_Material_get_base_color_1712_comment},
  {"set_base_color", &Dtool_Material_set_base_color_1713, METH_O, (const char *)Dtool_Material_set_base_color_1713_comment},
  {"setBaseColor", &Dtool_Material_set_base_color_1713, METH_O, (const char *)Dtool_Material_set_base_color_1713_comment},
  {"clear_base_color", &Dtool_Material_clear_base_color_1714, METH_NOARGS, (const char *)Dtool_Material_clear_base_color_1714_comment},
  {"clearBaseColor", &Dtool_Material_clear_base_color_1714, METH_NOARGS, (const char *)Dtool_Material_clear_base_color_1714_comment},
  {"has_ambient", &Dtool_Material_has_ambient_1715, METH_NOARGS, (const char *)Dtool_Material_has_ambient_1715_comment},
  {"hasAmbient", &Dtool_Material_has_ambient_1715, METH_NOARGS, (const char *)Dtool_Material_has_ambient_1715_comment},
  {"get_ambient", &Dtool_Material_get_ambient_1716, METH_NOARGS, (const char *)Dtool_Material_get_ambient_1716_comment},
  {"getAmbient", &Dtool_Material_get_ambient_1716, METH_NOARGS, (const char *)Dtool_Material_get_ambient_1716_comment},
  {"set_ambient", &Dtool_Material_set_ambient_1717, METH_O, (const char *)Dtool_Material_set_ambient_1717_comment},
  {"setAmbient", &Dtool_Material_set_ambient_1717, METH_O, (const char *)Dtool_Material_set_ambient_1717_comment},
  {"clear_ambient", &Dtool_Material_clear_ambient_1718, METH_NOARGS, (const char *)Dtool_Material_clear_ambient_1718_comment},
  {"clearAmbient", &Dtool_Material_clear_ambient_1718, METH_NOARGS, (const char *)Dtool_Material_clear_ambient_1718_comment},
  {"has_diffuse", &Dtool_Material_has_diffuse_1719, METH_NOARGS, (const char *)Dtool_Material_has_diffuse_1719_comment},
  {"hasDiffuse", &Dtool_Material_has_diffuse_1719, METH_NOARGS, (const char *)Dtool_Material_has_diffuse_1719_comment},
  {"get_diffuse", &Dtool_Material_get_diffuse_1720, METH_NOARGS, (const char *)Dtool_Material_get_diffuse_1720_comment},
  {"getDiffuse", &Dtool_Material_get_diffuse_1720, METH_NOARGS, (const char *)Dtool_Material_get_diffuse_1720_comment},
  {"set_diffuse", &Dtool_Material_set_diffuse_1721, METH_O, (const char *)Dtool_Material_set_diffuse_1721_comment},
  {"setDiffuse", &Dtool_Material_set_diffuse_1721, METH_O, (const char *)Dtool_Material_set_diffuse_1721_comment},
  {"clear_diffuse", &Dtool_Material_clear_diffuse_1722, METH_NOARGS, (const char *)Dtool_Material_clear_diffuse_1722_comment},
  {"clearDiffuse", &Dtool_Material_clear_diffuse_1722, METH_NOARGS, (const char *)Dtool_Material_clear_diffuse_1722_comment},
  {"has_specular", &Dtool_Material_has_specular_1723, METH_NOARGS, (const char *)Dtool_Material_has_specular_1723_comment},
  {"hasSpecular", &Dtool_Material_has_specular_1723, METH_NOARGS, (const char *)Dtool_Material_has_specular_1723_comment},
  {"get_specular", &Dtool_Material_get_specular_1724, METH_NOARGS, (const char *)Dtool_Material_get_specular_1724_comment},
  {"getSpecular", &Dtool_Material_get_specular_1724, METH_NOARGS, (const char *)Dtool_Material_get_specular_1724_comment},
  {"set_specular", &Dtool_Material_set_specular_1725, METH_O, (const char *)Dtool_Material_set_specular_1725_comment},
  {"setSpecular", &Dtool_Material_set_specular_1725, METH_O, (const char *)Dtool_Material_set_specular_1725_comment},
  {"clear_specular", &Dtool_Material_clear_specular_1726, METH_NOARGS, (const char *)Dtool_Material_clear_specular_1726_comment},
  {"clearSpecular", &Dtool_Material_clear_specular_1726, METH_NOARGS, (const char *)Dtool_Material_clear_specular_1726_comment},
  {"has_emission", &Dtool_Material_has_emission_1727, METH_NOARGS, (const char *)Dtool_Material_has_emission_1727_comment},
  {"hasEmission", &Dtool_Material_has_emission_1727, METH_NOARGS, (const char *)Dtool_Material_has_emission_1727_comment},
  {"get_emission", &Dtool_Material_get_emission_1728, METH_NOARGS, (const char *)Dtool_Material_get_emission_1728_comment},
  {"getEmission", &Dtool_Material_get_emission_1728, METH_NOARGS, (const char *)Dtool_Material_get_emission_1728_comment},
  {"set_emission", &Dtool_Material_set_emission_1729, METH_O, (const char *)Dtool_Material_set_emission_1729_comment},
  {"setEmission", &Dtool_Material_set_emission_1729, METH_O, (const char *)Dtool_Material_set_emission_1729_comment},
  {"clear_emission", &Dtool_Material_clear_emission_1730, METH_NOARGS, (const char *)Dtool_Material_clear_emission_1730_comment},
  {"clearEmission", &Dtool_Material_clear_emission_1730, METH_NOARGS, (const char *)Dtool_Material_clear_emission_1730_comment},
  {"get_shininess", &Dtool_Material_get_shininess_1731, METH_NOARGS, (const char *)Dtool_Material_get_shininess_1731_comment},
  {"getShininess", &Dtool_Material_get_shininess_1731, METH_NOARGS, (const char *)Dtool_Material_get_shininess_1731_comment},
  {"set_shininess", &Dtool_Material_set_shininess_1732, METH_O, (const char *)Dtool_Material_set_shininess_1732_comment},
  {"setShininess", &Dtool_Material_set_shininess_1732, METH_O, (const char *)Dtool_Material_set_shininess_1732_comment},
  {"has_roughness", &Dtool_Material_has_roughness_1733, METH_NOARGS, (const char *)Dtool_Material_has_roughness_1733_comment},
  {"hasRoughness", &Dtool_Material_has_roughness_1733, METH_NOARGS, (const char *)Dtool_Material_has_roughness_1733_comment},
  {"get_roughness", &Dtool_Material_get_roughness_1734, METH_NOARGS, (const char *)Dtool_Material_get_roughness_1734_comment},
  {"getRoughness", &Dtool_Material_get_roughness_1734, METH_NOARGS, (const char *)Dtool_Material_get_roughness_1734_comment},
  {"set_roughness", &Dtool_Material_set_roughness_1735, METH_O, (const char *)Dtool_Material_set_roughness_1735_comment},
  {"setRoughness", &Dtool_Material_set_roughness_1735, METH_O, (const char *)Dtool_Material_set_roughness_1735_comment},
  {"has_metallic", &Dtool_Material_has_metallic_1736, METH_NOARGS, (const char *)Dtool_Material_has_metallic_1736_comment},
  {"hasMetallic", &Dtool_Material_has_metallic_1736, METH_NOARGS, (const char *)Dtool_Material_has_metallic_1736_comment},
  {"get_metallic", &Dtool_Material_get_metallic_1737, METH_NOARGS, (const char *)Dtool_Material_get_metallic_1737_comment},
  {"getMetallic", &Dtool_Material_get_metallic_1737, METH_NOARGS, (const char *)Dtool_Material_get_metallic_1737_comment},
  {"set_metallic", &Dtool_Material_set_metallic_1738, METH_O, (const char *)Dtool_Material_set_metallic_1738_comment},
  {"setMetallic", &Dtool_Material_set_metallic_1738, METH_O, (const char *)Dtool_Material_set_metallic_1738_comment},
  {"clear_metallic", &Dtool_Material_clear_metallic_1739, METH_NOARGS, (const char *)Dtool_Material_clear_metallic_1739_comment},
  {"clearMetallic", &Dtool_Material_clear_metallic_1739, METH_NOARGS, (const char *)Dtool_Material_clear_metallic_1739_comment},
  {"has_refractive_index", &Dtool_Material_has_refractive_index_1740, METH_NOARGS, (const char *)Dtool_Material_has_refractive_index_1740_comment},
  {"hasRefractiveIndex", &Dtool_Material_has_refractive_index_1740, METH_NOARGS, (const char *)Dtool_Material_has_refractive_index_1740_comment},
  {"get_refractive_index", &Dtool_Material_get_refractive_index_1741, METH_NOARGS, (const char *)Dtool_Material_get_refractive_index_1741_comment},
  {"getRefractiveIndex", &Dtool_Material_get_refractive_index_1741, METH_NOARGS, (const char *)Dtool_Material_get_refractive_index_1741_comment},
  {"set_refractive_index", &Dtool_Material_set_refractive_index_1742, METH_O, (const char *)Dtool_Material_set_refractive_index_1742_comment},
  {"setRefractiveIndex", &Dtool_Material_set_refractive_index_1742, METH_O, (const char *)Dtool_Material_set_refractive_index_1742_comment},
  {"get_local", &Dtool_Material_get_local_1743, METH_NOARGS, (const char *)Dtool_Material_get_local_1743_comment},
  {"getLocal", &Dtool_Material_get_local_1743, METH_NOARGS, (const char *)Dtool_Material_get_local_1743_comment},
  {"set_local", &Dtool_Material_set_local_1744, METH_O, (const char *)Dtool_Material_set_local_1744_comment},
  {"setLocal", &Dtool_Material_set_local_1744, METH_O, (const char *)Dtool_Material_set_local_1744_comment},
  {"get_twoside", &Dtool_Material_get_twoside_1745, METH_NOARGS, (const char *)Dtool_Material_get_twoside_1745_comment},
  {"getTwoside", &Dtool_Material_get_twoside_1745, METH_NOARGS, (const char *)Dtool_Material_get_twoside_1745_comment},
  {"set_twoside", &Dtool_Material_set_twoside_1746, METH_O, (const char *)Dtool_Material_set_twoside_1746_comment},
  {"setTwoside", &Dtool_Material_set_twoside_1746, METH_O, (const char *)Dtool_Material_set_twoside_1746_comment},
  {"compare_to", &Dtool_Material_compare_to_1750, METH_O, (const char *)Dtool_Material_compare_to_1750_comment},
  {"compareTo", &Dtool_Material_compare_to_1750, METH_O, (const char *)Dtool_Material_compare_to_1750_comment},
  {"output", &Dtool_Material_output_1751, METH_O, (const char *)Dtool_Material_output_1751_comment},
  {"write", (PyCFunction) &Dtool_Material_write_1752, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Material_write_1752_comment},
  {"is_attrib_locked", &Dtool_Material_is_attrib_locked_1753, METH_NOARGS, (const char *)Dtool_Material_is_attrib_locked_1753_comment},
  {"isAttribLocked", &Dtool_Material_is_attrib_locked_1753, METH_NOARGS, (const char *)Dtool_Material_is_attrib_locked_1753_comment},
  {"set_attrib_lock", &Dtool_Material_set_attrib_lock_1754, METH_NOARGS, (const char *)Dtool_Material_set_attrib_lock_1754_comment},
  {"setAttribLock", &Dtool_Material_set_attrib_lock_1754, METH_NOARGS, (const char *)Dtool_Material_set_attrib_lock_1754_comment},
  {"get_class_type", &Dtool_Material_get_class_type_1766, METH_NOARGS | METH_STATIC, (const char *)Dtool_Material_get_class_type_1766_comment},
  {"getClassType", &Dtool_Material_get_class_type_1766, METH_NOARGS | METH_STATIC, (const char *)Dtool_Material_get_class_type_1766_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_Material_upcast_to_TypedWritableReferenceCount_1703, METH_NOARGS, (const char *)Dtool_Material_upcast_to_TypedWritableReferenceCount_1703_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_Material_upcast_to_TypedWritableReferenceCount_1703, METH_NOARGS, (const char *)Dtool_Material_upcast_to_TypedWritableReferenceCount_1703_comment},
  {"upcast_to_Namable", &Dtool_Material_upcast_to_Namable_1705, METH_NOARGS, (const char *)Dtool_Material_upcast_to_Namable_1705_comment},
  {"upcastToNamable", &Dtool_Material_upcast_to_Namable_1705, METH_NOARGS, (const char *)Dtool_Material_upcast_to_Namable_1705_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Material slot tp_compare -> compare_to
//////////////////
static int Dtool_Material_compare_to_1750_tp_compare(PyObject *self, PyObject *arg) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return -1;
  }

  // 1-int Material::compare_to(Material const &other) const
  Material const *arg_this = (Material *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Material, 1, "Material.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const Material*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(Material self, const Material other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     Material
//////////////////
static PyObject *Dtool_Repr_Material(PyObject *self) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     Material
//////////////////
static PyObject *Dtool_Str_Material(PyObject *self) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     Material
//////////////////
static PyObject *Dtool_RichCompare_Material(PyObject *self, PyObject *arg, int op) {
  Material *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Material, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool Material::operator ==(Material const &other) const
      Material const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Material);
      if (arg_this != nullptr) {
        bool return_value = ((*(const Material*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool Material::operator !=(Material const &other) const
      Material const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Material);
      if (arg_this != nullptr) {
        bool return_value = ((*(const Material*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool Material::operator <(Material const &other) const
      Material const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Material);
      if (arg_this != nullptr) {
        bool return_value = ((*(const Material*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_Material_compare_to_1750_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_Material[] = {
  {(char *)"base_color", &Dtool_Material_base_color_Getter, &Dtool_Material_base_color_Setter, nullptr, nullptr},
  {(char *)"ambient", &Dtool_Material_ambient_Getter, &Dtool_Material_ambient_Setter, nullptr, nullptr},
  {(char *)"diffuse", &Dtool_Material_diffuse_Getter, &Dtool_Material_diffuse_Setter, nullptr, nullptr},
  {(char *)"specular", &Dtool_Material_specular_Getter, &Dtool_Material_specular_Setter, nullptr, nullptr},
  {(char *)"emission", &Dtool_Material_emission_Getter, &Dtool_Material_emission_Setter, nullptr, nullptr},
  {(char *)"shininess", &Dtool_Material_shininess_Getter, &Dtool_Material_shininess_Setter, nullptr, nullptr},
  {(char *)"roughness", &Dtool_Material_roughness_Getter, &Dtool_Material_roughness_Setter, nullptr, nullptr},
  {(char *)"metallic", &Dtool_Material_metallic_Getter, &Dtool_Material_metallic_Setter, nullptr, nullptr},
  {(char *)"refractive_index", &Dtool_Material_refractive_index_Getter, &Dtool_Material_refractive_index_Setter, nullptr, nullptr},
  {(char *)"local", &Dtool_Material_local_Getter, &Dtool_Material_local_Setter, nullptr, nullptr},
  {(char *)"twoside", &Dtool_Material_twoside_Getter, &Dtool_Material_twoside_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Material = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Material = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Material = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Material = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Material = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Material = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Material",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Material,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Material,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_Material_compare_to_1750_tp_compare,
#endif
    &Dtool_Repr_Material,
    &Dtool_NumberMethods_Material,
    &Dtool_SequenceMethods_Material,
    &Dtool_MappingMethods_Material,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_Material,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Material,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines the way an object appears in the presence of lighting.  A material\n"
    " * is only necessary if lighting is to be enabled; otherwise, the material\n"
    " * isn't used.\n"
    " *\n"
    " * There are two workflows that are supported: the \"classic\" workflow of\n"
    " * providing separate ambient, diffuse and specular colors, and the\n"
    " * \"metalness\" workflow, in which a base color is specified along with a\n"
    " * \"metallic\" value that indicates whether the material is a metal or a\n"
    " * dielectric.\n"
    " *\n"
    " * The size of the specular highlight can be specified by either specifying\n"
    " * the specular exponent (shininess) or by specifying a roughness value that\n"
    " * in perceptually linear in the range of 0-1.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_Material,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Material,
    nullptr, // tp_members
    Dtool_Properties_Material,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Material,
    PyType_GenericAlloc,
    Dtool_new_Material,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Material,
  Dtool_UpcastInterface_Material,
  Dtool_DowncastInterface_Material,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Material(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_Material._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_Material._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Material._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Material) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Material)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Material);
  }
}

/**
 * Python method tables for MaterialPool (MaterialPool)
 */
static PyMethodDef Dtool_Methods_MaterialPool[] = {
  {"get_material", &Dtool_MaterialPool_get_material_1768, METH_O | METH_STATIC, (const char *)Dtool_MaterialPool_get_material_1768_comment},
  {"getMaterial", &Dtool_MaterialPool_get_material_1768, METH_O | METH_STATIC, (const char *)Dtool_MaterialPool_get_material_1768_comment},
  {"release_material", &Dtool_MaterialPool_release_material_1769, METH_O | METH_STATIC, (const char *)Dtool_MaterialPool_release_material_1769_comment},
  {"releaseMaterial", &Dtool_MaterialPool_release_material_1769, METH_O | METH_STATIC, (const char *)Dtool_MaterialPool_release_material_1769_comment},
  {"release_all_materials", &Dtool_MaterialPool_release_all_materials_1770, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialPool_release_all_materials_1770_comment},
  {"releaseAllMaterials", &Dtool_MaterialPool_release_all_materials_1770, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialPool_release_all_materials_1770_comment},
  {"garbage_collect", &Dtool_MaterialPool_garbage_collect_1771, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialPool_garbage_collect_1771_comment},
  {"garbageCollect", &Dtool_MaterialPool_garbage_collect_1771, METH_NOARGS | METH_STATIC, (const char *)Dtool_MaterialPool_garbage_collect_1771_comment},
  {"list_contents", &Dtool_MaterialPool_list_contents_1772, METH_O | METH_STATIC, (const char *)Dtool_MaterialPool_list_contents_1772_comment},
  {"listContents", &Dtool_MaterialPool_list_contents_1772, METH_O | METH_STATIC, (const char *)Dtool_MaterialPool_list_contents_1772_comment},
  {"write", &Dtool_MaterialPool_write_1773, METH_O | METH_STATIC, (const char *)Dtool_MaterialPool_write_1773_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     MaterialPool
//////////////////
static PyObject *Dtool_Str_MaterialPool(PyObject *self) {
  MaterialPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MaterialPool, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_MaterialPool = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_MaterialPool = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MaterialPool",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MaterialPool,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MaterialPool,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_MaterialPool,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The MaterialPool (there is only one in the universe) serves to unify\n"
    " * different pointers to the same Material, so we do not (a) waste memory with\n"
    " * many different Material objects that are all equivalent, and (b) waste time\n"
    " * switching the graphics engine between different Material states that are\n"
    " * really the same thing.\n"
    " *\n"
    " * The idea is to create a temporary Material representing the lighting state\n"
    " * you want to apply, then call get_material(), passing in your temporary\n"
    " * Material.  The return value will either be a new Material object, or it may\n"
    " * be the the same object you supplied; in either case, it will have the same\n"
    " * value.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MaterialPool,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MaterialPool,
    PyType_GenericAlloc,
    Dtool_new_MaterialPool,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MaterialPool,
  Dtool_UpcastInterface_MaterialPool,
  Dtool_DowncastInterface_MaterialPool,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MaterialPool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MaterialPool._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MaterialPool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MaterialPool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MaterialPool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MaterialPool);
  }
}

/**
 * Python method tables for MatrixLens (MatrixLens)
 */
static PyMethodDef Dtool_Methods_MatrixLens[] = {
  {"set_user_mat", &Dtool_MatrixLens_set_user_mat_1777, METH_O, (const char *)Dtool_MatrixLens_set_user_mat_1777_comment},
  {"setUserMat", &Dtool_MatrixLens_set_user_mat_1777, METH_O, (const char *)Dtool_MatrixLens_set_user_mat_1777_comment},
  {"get_user_mat", &Dtool_MatrixLens_get_user_mat_1778, METH_NOARGS, (const char *)Dtool_MatrixLens_get_user_mat_1778_comment},
  {"getUserMat", &Dtool_MatrixLens_get_user_mat_1778, METH_NOARGS, (const char *)Dtool_MatrixLens_get_user_mat_1778_comment},
  {"set_left_eye_mat", &Dtool_MatrixLens_set_left_eye_mat_1780, METH_O, (const char *)Dtool_MatrixLens_set_left_eye_mat_1780_comment},
  {"setLeftEyeMat", &Dtool_MatrixLens_set_left_eye_mat_1780, METH_O, (const char *)Dtool_MatrixLens_set_left_eye_mat_1780_comment},
  {"clear_left_eye_mat", &Dtool_MatrixLens_clear_left_eye_mat_1781, METH_NOARGS, (const char *)Dtool_MatrixLens_clear_left_eye_mat_1781_comment},
  {"clearLeftEyeMat", &Dtool_MatrixLens_clear_left_eye_mat_1781, METH_NOARGS, (const char *)Dtool_MatrixLens_clear_left_eye_mat_1781_comment},
  {"has_left_eye_mat", &Dtool_MatrixLens_has_left_eye_mat_1782, METH_NOARGS, (const char *)Dtool_MatrixLens_has_left_eye_mat_1782_comment},
  {"hasLeftEyeMat", &Dtool_MatrixLens_has_left_eye_mat_1782, METH_NOARGS, (const char *)Dtool_MatrixLens_has_left_eye_mat_1782_comment},
  {"get_left_eye_mat", &Dtool_MatrixLens_get_left_eye_mat_1783, METH_NOARGS, (const char *)Dtool_MatrixLens_get_left_eye_mat_1783_comment},
  {"getLeftEyeMat", &Dtool_MatrixLens_get_left_eye_mat_1783, METH_NOARGS, (const char *)Dtool_MatrixLens_get_left_eye_mat_1783_comment},
  {"set_right_eye_mat", &Dtool_MatrixLens_set_right_eye_mat_1784, METH_O, (const char *)Dtool_MatrixLens_set_right_eye_mat_1784_comment},
  {"setRightEyeMat", &Dtool_MatrixLens_set_right_eye_mat_1784, METH_O, (const char *)Dtool_MatrixLens_set_right_eye_mat_1784_comment},
  {"clear_right_eye_mat", &Dtool_MatrixLens_clear_right_eye_mat_1785, METH_NOARGS, (const char *)Dtool_MatrixLens_clear_right_eye_mat_1785_comment},
  {"clearRightEyeMat", &Dtool_MatrixLens_clear_right_eye_mat_1785, METH_NOARGS, (const char *)Dtool_MatrixLens_clear_right_eye_mat_1785_comment},
  {"has_right_eye_mat", &Dtool_MatrixLens_has_right_eye_mat_1786, METH_NOARGS, (const char *)Dtool_MatrixLens_has_right_eye_mat_1786_comment},
  {"hasRightEyeMat", &Dtool_MatrixLens_has_right_eye_mat_1786, METH_NOARGS, (const char *)Dtool_MatrixLens_has_right_eye_mat_1786_comment},
  {"get_right_eye_mat", &Dtool_MatrixLens_get_right_eye_mat_1787, METH_NOARGS, (const char *)Dtool_MatrixLens_get_right_eye_mat_1787_comment},
  {"getRightEyeMat", &Dtool_MatrixLens_get_right_eye_mat_1787, METH_NOARGS, (const char *)Dtool_MatrixLens_get_right_eye_mat_1787_comment},
  {"get_class_type", &Dtool_MatrixLens_get_class_type_1788, METH_NOARGS | METH_STATIC, (const char *)Dtool_MatrixLens_get_class_type_1788_comment},
  {"getClassType", &Dtool_MatrixLens_get_class_type_1788, METH_NOARGS | METH_STATIC, (const char *)Dtool_MatrixLens_get_class_type_1788_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_MatrixLens[] = {
  {(char *)"user_mat", &Dtool_MatrixLens_user_mat_Getter, &Dtool_MatrixLens_user_mat_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_MatrixLens = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MatrixLens = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MatrixLens = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MatrixLens = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MatrixLens = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MatrixLens = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MatrixLens",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MatrixLens,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MatrixLens,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MatrixLens,
    &Dtool_SequenceMethods_MatrixLens,
    &Dtool_MappingMethods_MatrixLens,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MatrixLens,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A completely generic linear lens.  This is provided for the benefit of low-\n"
    " * level code that wants to specify a perspective or orthographic frustum via\n"
    " * an explicit projection matrix, but not mess around with fov's or focal\n"
    " * lengths or any of that nonsense.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MatrixLens,
    nullptr, // tp_members
    Dtool_Properties_MatrixLens,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MatrixLens,
    PyType_GenericAlloc,
    Dtool_new_MatrixLens,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MatrixLens,
  Dtool_UpcastInterface_MatrixLens,
  Dtool_DowncastInterface_MatrixLens,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MatrixLens(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Lens(nullptr);
    Dtool_MatrixLens._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Lens);
    Dtool_MatrixLens._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MatrixLens._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MatrixLens) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MatrixLens)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MatrixLens);
  }
}

/**
 * Python method tables for OrthographicLens (OrthographicLens)
 */
static PyMethodDef Dtool_Methods_OrthographicLens[] = {
  {"get_class_type", &Dtool_OrthographicLens_get_class_type_1792, METH_NOARGS | METH_STATIC, (const char *)Dtool_OrthographicLens_get_class_type_1792_comment},
  {"getClassType", &Dtool_OrthographicLens_get_class_type_1792, METH_NOARGS | METH_STATIC, (const char *)Dtool_OrthographicLens_get_class_type_1792_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OrthographicLens = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OrthographicLens = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OrthographicLens = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OrthographicLens = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OrthographicLens = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OrthographicLens = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.OrthographicLens",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OrthographicLens,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OrthographicLens,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OrthographicLens,
    &Dtool_SequenceMethods_OrthographicLens,
    &Dtool_MappingMethods_OrthographicLens,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OrthographicLens,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An orthographic lens.  Although this kind of lens is linear, like a\n"
    " * PerspectiveLens, it doesn't respect field-of-view or focal length\n"
    " * parameters, and adjusting these will have no effect.  Instead, its field of\n"
    " * view is controlled by adjusting the film_size; the orthographic lens\n"
    " * represents a planar projection onto its imaginary film of the specified\n"
    " * size, hanging in space.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OrthographicLens,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OrthographicLens,
    PyType_GenericAlloc,
    Dtool_new_OrthographicLens,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OrthographicLens,
  Dtool_UpcastInterface_OrthographicLens,
  Dtool_DowncastInterface_OrthographicLens,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OrthographicLens(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Lens(nullptr);
    Dtool_OrthographicLens._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Lens);
    Dtool_OrthographicLens._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OrthographicLens._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OrthographicLens) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OrthographicLens)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OrthographicLens);
  }
}

/**
 * Python method tables for ParamTextureSampler (ParamTextureSampler)
 */
static PyMethodDef Dtool_Methods_ParamTextureSampler[] = {
  {"get_texture", &Dtool_ParamTextureSampler_get_texture_1797, METH_NOARGS, (const char *)Dtool_ParamTextureSampler_get_texture_1797_comment},
  {"getTexture", &Dtool_ParamTextureSampler_get_texture_1797, METH_NOARGS, (const char *)Dtool_ParamTextureSampler_get_texture_1797_comment},
  {"get_sampler", &Dtool_ParamTextureSampler_get_sampler_1798, METH_NOARGS, (const char *)Dtool_ParamTextureSampler_get_sampler_1798_comment},
  {"getSampler", &Dtool_ParamTextureSampler_get_sampler_1798, METH_NOARGS, (const char *)Dtool_ParamTextureSampler_get_sampler_1798_comment},
  {"get_class_type", &Dtool_ParamTextureSampler_get_class_type_1802, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamTextureSampler_get_class_type_1802_comment},
  {"getClassType", &Dtool_ParamTextureSampler_get_class_type_1802, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamTextureSampler_get_class_type_1802_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamTextureSampler[] = {
  {(char *)"texture", &Dtool_ParamTextureSampler_texture_Getter, nullptr, nullptr, nullptr},
  {(char *)"sampler", &Dtool_ParamTextureSampler_sampler_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamTextureSampler = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamTextureSampler = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamTextureSampler = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamTextureSampler = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamTextureSampler = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamTextureSampler = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamTextureSampler",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamTextureSampler,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamTextureSampler,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamTextureSampler,
    &Dtool_SequenceMethods_ParamTextureSampler,
    &Dtool_MappingMethods_ParamTextureSampler,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamTextureSampler,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class object for storing a pointer to a Texture along with a sampler\n"
    " * state that indicates how to to sample the given texture.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamTextureSampler,
    nullptr, // tp_members
    Dtool_Properties_ParamTextureSampler,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamTextureSampler,
    PyType_GenericAlloc,
    Dtool_new_ParamTextureSampler,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamTextureSampler,
  Dtool_UpcastInterface_ParamTextureSampler,
  Dtool_DowncastInterface_ParamTextureSampler,
  (CoerceFunction)Dtool_ConstCoerce_ParamTextureSampler,
  (CoerceFunction)Dtool_Coerce_ParamTextureSampler,
};

static void Dtool_PyModuleClassInit_ParamTextureSampler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ParamValueBase != nullptr);
    assert(Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit(nullptr);
    Dtool_ParamTextureSampler._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ParamValueBase);
    Dtool_ParamTextureSampler._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamTextureSampler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamTextureSampler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamTextureSampler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamTextureSampler);
  }
}

/**
 * Python method tables for ParamTextureImage (ParamTextureImage)
 */
static PyMethodDef Dtool_Methods_ParamTextureImage[] = {
  {"get_texture", &Dtool_ParamTextureImage_get_texture_1806, METH_NOARGS, (const char *)Dtool_ParamTextureImage_get_texture_1806_comment},
  {"getTexture", &Dtool_ParamTextureImage_get_texture_1806, METH_NOARGS, (const char *)Dtool_ParamTextureImage_get_texture_1806_comment},
  {"has_read_access", &Dtool_ParamTextureImage_has_read_access_1807, METH_NOARGS, (const char *)Dtool_ParamTextureImage_has_read_access_1807_comment},
  {"hasReadAccess", &Dtool_ParamTextureImage_has_read_access_1807, METH_NOARGS, (const char *)Dtool_ParamTextureImage_has_read_access_1807_comment},
  {"has_write_access", &Dtool_ParamTextureImage_has_write_access_1808, METH_NOARGS, (const char *)Dtool_ParamTextureImage_has_write_access_1808_comment},
  {"hasWriteAccess", &Dtool_ParamTextureImage_has_write_access_1808, METH_NOARGS, (const char *)Dtool_ParamTextureImage_has_write_access_1808_comment},
  {"get_bind_layered", &Dtool_ParamTextureImage_get_bind_layered_1809, METH_NOARGS, (const char *)Dtool_ParamTextureImage_get_bind_layered_1809_comment},
  {"getBindLayered", &Dtool_ParamTextureImage_get_bind_layered_1809, METH_NOARGS, (const char *)Dtool_ParamTextureImage_get_bind_layered_1809_comment},
  {"get_bind_level", &Dtool_ParamTextureImage_get_bind_level_1810, METH_NOARGS, (const char *)Dtool_ParamTextureImage_get_bind_level_1810_comment},
  {"getBindLevel", &Dtool_ParamTextureImage_get_bind_level_1810, METH_NOARGS, (const char *)Dtool_ParamTextureImage_get_bind_level_1810_comment},
  {"get_bind_layer", &Dtool_ParamTextureImage_get_bind_layer_1811, METH_NOARGS, (const char *)Dtool_ParamTextureImage_get_bind_layer_1811_comment},
  {"getBindLayer", &Dtool_ParamTextureImage_get_bind_layer_1811, METH_NOARGS, (const char *)Dtool_ParamTextureImage_get_bind_layer_1811_comment},
  {"get_class_type", &Dtool_ParamTextureImage_get_class_type_1817, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamTextureImage_get_class_type_1817_comment},
  {"getClassType", &Dtool_ParamTextureImage_get_class_type_1817, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamTextureImage_get_class_type_1817_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamTextureImage[] = {
  {(char *)"texture", &Dtool_ParamTextureImage_texture_Getter, nullptr, nullptr, nullptr},
  {(char *)"read_access", &Dtool_ParamTextureImage_read_access_Getter, nullptr, nullptr, nullptr},
  {(char *)"write_access", &Dtool_ParamTextureImage_write_access_Getter, nullptr, nullptr, nullptr},
  {(char *)"bind_level", &Dtool_ParamTextureImage_bind_level_Getter, nullptr, nullptr, nullptr},
  {(char *)"bind_layer", &Dtool_ParamTextureImage_bind_layer_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamTextureImage = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamTextureImage = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamTextureImage = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamTextureImage = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamTextureImage = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamTextureImage = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamTextureImage",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamTextureImage,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamTextureImage,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamTextureImage,
    &Dtool_SequenceMethods_ParamTextureImage,
    &Dtool_MappingMethods_ParamTextureImage,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamTextureImage,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class object for storing a pointer to a Texture along with a set of\n"
    " * properties that indicates which image to bind to a shader input.\n"
    " *\n"
    " * This class is useful for binding texture images to a shader, which is a\n"
    " * fairly esoteric feature.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamTextureImage,
    nullptr, // tp_members
    Dtool_Properties_ParamTextureImage,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamTextureImage,
    PyType_GenericAlloc,
    Dtool_new_ParamTextureImage,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamTextureImage,
  Dtool_UpcastInterface_ParamTextureImage,
  Dtool_DowncastInterface_ParamTextureImage,
  (CoerceFunction)Dtool_ConstCoerce_ParamTextureImage,
  (CoerceFunction)Dtool_Coerce_ParamTextureImage,
};

static void Dtool_PyModuleClassInit_ParamTextureImage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ParamValueBase != nullptr);
    assert(Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit(nullptr);
    Dtool_ParamTextureImage._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ParamValueBase);
    Dtool_ParamTextureImage._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamTextureImage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamTextureImage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamTextureImage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamTextureImage);
  }
}

/**
 * Python method tables for PerspectiveLens (PerspectiveLens)
 */
static PyMethodDef Dtool_Methods_PerspectiveLens[] = {
  {"get_class_type", &Dtool_PerspectiveLens_get_class_type_1821, METH_NOARGS | METH_STATIC, (const char *)Dtool_PerspectiveLens_get_class_type_1821_comment},
  {"getClassType", &Dtool_PerspectiveLens_get_class_type_1821, METH_NOARGS | METH_STATIC, (const char *)Dtool_PerspectiveLens_get_class_type_1821_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PerspectiveLens = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PerspectiveLens = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PerspectiveLens = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PerspectiveLens = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PerspectiveLens = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PerspectiveLens = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PerspectiveLens",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PerspectiveLens,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PerspectiveLens,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PerspectiveLens,
    &Dtool_SequenceMethods_PerspectiveLens,
    &Dtool_MappingMethods_PerspectiveLens,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PerspectiveLens,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A perspective-type lens: a normal camera.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PerspectiveLens,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PerspectiveLens,
    PyType_GenericAlloc,
    Dtool_new_PerspectiveLens,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PerspectiveLens,
  Dtool_UpcastInterface_PerspectiveLens,
  Dtool_DowncastInterface_PerspectiveLens,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PerspectiveLens(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Lens(nullptr);
    Dtool_PerspectiveLens._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Lens);
    Dtool_PerspectiveLens._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PerspectiveLens._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PerspectiveLens) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PerspectiveLens)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PerspectiveLens);
  }
}

/**
 * Python method tables for TextureReloadRequest (TextureReloadRequest)
 */
static PyMethodDef Dtool_Methods_TextureReloadRequest[] = {
  {"get_prepared_graphics_objects", &Dtool_TextureReloadRequest_get_prepared_graphics_objects_1825, METH_NOARGS, (const char *)Dtool_TextureReloadRequest_get_prepared_graphics_objects_1825_comment},
  {"getPreparedGraphicsObjects", &Dtool_TextureReloadRequest_get_prepared_graphics_objects_1825, METH_NOARGS, (const char *)Dtool_TextureReloadRequest_get_prepared_graphics_objects_1825_comment},
  {"get_texture", &Dtool_TextureReloadRequest_get_texture_1826, METH_NOARGS, (const char *)Dtool_TextureReloadRequest_get_texture_1826_comment},
  {"getTexture", &Dtool_TextureReloadRequest_get_texture_1826, METH_NOARGS, (const char *)Dtool_TextureReloadRequest_get_texture_1826_comment},
  {"get_allow_compressed", &Dtool_TextureReloadRequest_get_allow_compressed_1827, METH_NOARGS, (const char *)Dtool_TextureReloadRequest_get_allow_compressed_1827_comment},
  {"getAllowCompressed", &Dtool_TextureReloadRequest_get_allow_compressed_1827, METH_NOARGS, (const char *)Dtool_TextureReloadRequest_get_allow_compressed_1827_comment},
  {"is_ready", &Dtool_TextureReloadRequest_is_ready_1828, METH_NOARGS, (const char *)Dtool_TextureReloadRequest_is_ready_1828_comment},
  {"isReady", &Dtool_TextureReloadRequest_is_ready_1828, METH_NOARGS, (const char *)Dtool_TextureReloadRequest_is_ready_1828_comment},
  {"get_class_type", &Dtool_TextureReloadRequest_get_class_type_1830, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureReloadRequest_get_class_type_1830_comment},
  {"getClassType", &Dtool_TextureReloadRequest_get_class_type_1830, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureReloadRequest_get_class_type_1830_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_TextureReloadRequest[] = {
  {(char *)"texture", &Dtool_TextureReloadRequest_texture_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TextureReloadRequest = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextureReloadRequest = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TextureReloadRequest = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TextureReloadRequest = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TextureReloadRequest = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TextureReloadRequest = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextureReloadRequest",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextureReloadRequest,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TextureReloadRequest,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextureReloadRequest,
    &Dtool_SequenceMethods_TextureReloadRequest,
    &Dtool_MappingMethods_TextureReloadRequest,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TextureReloadRequest,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This loader request will call Texture::get_ram_image() in a sub-thread, to\n"
    " * force the texture's image to be re-read from disk.  It is used by\n"
    " * GraphicsStateGuardian::async_reload_texture(), when get_incomplete_render()\n"
    " * is true.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextureReloadRequest,
    nullptr, // tp_members
    Dtool_Properties_TextureReloadRequest,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextureReloadRequest,
    PyType_GenericAlloc,
    Dtool_new_TextureReloadRequest,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextureReloadRequest,
  Dtool_UpcastInterface_TextureReloadRequest,
  Dtool_DowncastInterface_TextureReloadRequest,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextureReloadRequest(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_AsyncTask != nullptr);
    assert(Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit(nullptr);
    Dtool_TextureReloadRequest._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_AsyncTask);
    Dtool_TextureReloadRequest._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextureReloadRequest._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextureReloadRequest) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextureReloadRequest)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextureReloadRequest);
  }
}

/**
 * Python method tables for TextureContext (TextureContext)
 */
static PyMethodDef Dtool_Methods_TextureContext[] = {
  {"get_texture", &Dtool_TextureContext_get_texture_1837, METH_NOARGS, (const char *)Dtool_TextureContext_get_texture_1837_comment},
  {"getTexture", &Dtool_TextureContext_get_texture_1837, METH_NOARGS, (const char *)Dtool_TextureContext_get_texture_1837_comment},
  {"get_view", &Dtool_TextureContext_get_view_1838, METH_NOARGS, (const char *)Dtool_TextureContext_get_view_1838_comment},
  {"getView", &Dtool_TextureContext_get_view_1838, METH_NOARGS, (const char *)Dtool_TextureContext_get_view_1838_comment},
  {"get_native_id", &Dtool_TextureContext_get_native_id_1839, METH_NOARGS, (const char *)Dtool_TextureContext_get_native_id_1839_comment},
  {"getNativeId", &Dtool_TextureContext_get_native_id_1839, METH_NOARGS, (const char *)Dtool_TextureContext_get_native_id_1839_comment},
  {"get_native_buffer_id", &Dtool_TextureContext_get_native_buffer_id_1840, METH_NOARGS, (const char *)Dtool_TextureContext_get_native_buffer_id_1840_comment},
  {"getNativeBufferId", &Dtool_TextureContext_get_native_buffer_id_1840, METH_NOARGS, (const char *)Dtool_TextureContext_get_native_buffer_id_1840_comment},
  {"was_modified", &Dtool_TextureContext_was_modified_1841, METH_NOARGS, (const char *)Dtool_TextureContext_was_modified_1841_comment},
  {"wasModified", &Dtool_TextureContext_was_modified_1841, METH_NOARGS, (const char *)Dtool_TextureContext_was_modified_1841_comment},
  {"was_properties_modified", &Dtool_TextureContext_was_properties_modified_1842, METH_NOARGS, (const char *)Dtool_TextureContext_was_properties_modified_1842_comment},
  {"wasPropertiesModified", &Dtool_TextureContext_was_properties_modified_1842, METH_NOARGS, (const char *)Dtool_TextureContext_was_properties_modified_1842_comment},
  {"was_image_modified", &Dtool_TextureContext_was_image_modified_1843, METH_NOARGS, (const char *)Dtool_TextureContext_was_image_modified_1843_comment},
  {"wasImageModified", &Dtool_TextureContext_was_image_modified_1843, METH_NOARGS, (const char *)Dtool_TextureContext_was_image_modified_1843_comment},
  {"was_simple_image_modified", &Dtool_TextureContext_was_simple_image_modified_1844, METH_NOARGS, (const char *)Dtool_TextureContext_was_simple_image_modified_1844_comment},
  {"wasSimpleImageModified", &Dtool_TextureContext_was_simple_image_modified_1844, METH_NOARGS, (const char *)Dtool_TextureContext_was_simple_image_modified_1844_comment},
  {"get_properties_modified", &Dtool_TextureContext_get_properties_modified_1845, METH_NOARGS, (const char *)Dtool_TextureContext_get_properties_modified_1845_comment},
  {"getPropertiesModified", &Dtool_TextureContext_get_properties_modified_1845, METH_NOARGS, (const char *)Dtool_TextureContext_get_properties_modified_1845_comment},
  {"get_image_modified", &Dtool_TextureContext_get_image_modified_1846, METH_NOARGS, (const char *)Dtool_TextureContext_get_image_modified_1846_comment},
  {"getImageModified", &Dtool_TextureContext_get_image_modified_1846, METH_NOARGS, (const char *)Dtool_TextureContext_get_image_modified_1846_comment},
  {"get_simple_image_modified", &Dtool_TextureContext_get_simple_image_modified_1847, METH_NOARGS, (const char *)Dtool_TextureContext_get_simple_image_modified_1847_comment},
  {"getSimpleImageModified", &Dtool_TextureContext_get_simple_image_modified_1847, METH_NOARGS, (const char *)Dtool_TextureContext_get_simple_image_modified_1847_comment},
  {"get_class_type", &Dtool_TextureContext_get_class_type_1848, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureContext_get_class_type_1848_comment},
  {"getClassType", &Dtool_TextureContext_get_class_type_1848, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureContext_get_class_type_1848_comment},
  {"upcast_to_BufferContext", &Dtool_TextureContext_upcast_to_BufferContext_1833, METH_NOARGS, (const char *)Dtool_TextureContext_upcast_to_BufferContext_1833_comment},
  {"upcastToBufferContext", &Dtool_TextureContext_upcast_to_BufferContext_1833, METH_NOARGS, (const char *)Dtool_TextureContext_upcast_to_BufferContext_1833_comment},
  {"upcast_to_AdaptiveLruPage", &Dtool_TextureContext_upcast_to_AdaptiveLruPage_1835, METH_NOARGS, (const char *)Dtool_TextureContext_upcast_to_AdaptiveLruPage_1835_comment},
  {"upcastToAdaptiveLruPage", &Dtool_TextureContext_upcast_to_AdaptiveLruPage_1835, METH_NOARGS, (const char *)Dtool_TextureContext_upcast_to_AdaptiveLruPage_1835_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TextureContext = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextureContext = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TextureContext = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TextureContext = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TextureContext = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TextureContext = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextureContext",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextureContext,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TextureContext,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextureContext,
    &Dtool_SequenceMethods_TextureContext,
    &Dtool_MappingMethods_TextureContext,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TextureContext,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special class object that holds all the information returned by a\n"
    " * particular GSG to indicate the texture's internal context identifier.\n"
    " *\n"
    " * Textures typically have an immediate-mode and a retained-mode operation.\n"
    " * When using textures in retained-mode (in response to Texture::prepare()),\n"
    " * the GSG will create some internal handle for the texture and store it here.\n"
    " * The texture stores all of these handles internally.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextureContext,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextureContext,
    PyType_GenericAlloc,
    Dtool_new_TextureContext,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextureContext,
  Dtool_UpcastInterface_TextureContext,
  Dtool_DowncastInterface_TextureContext,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextureContext(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BufferContext(nullptr);
    Dtool_PyModuleClassInit_AdaptiveLruPage(nullptr);
    Dtool_TextureContext._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_BufferContext, (PyTypeObject *)&Dtool_AdaptiveLruPage);
    Dtool_TextureContext._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextureContext._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextureContext) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextureContext)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextureContext);
  }
}

/**
 * Python method tables for ShaderContext (ShaderContext)
 */
static PyMethodDef Dtool_Methods_ShaderContext[] = {
  {"get_shader", &Dtool_ShaderContext_get_shader_1851, METH_NOARGS, (const char *)Dtool_ShaderContext_get_shader_1851_comment},
  {"getShader", &Dtool_ShaderContext_get_shader_1851, METH_NOARGS, (const char *)Dtool_ShaderContext_get_shader_1851_comment},
  {"get_class_type", &Dtool_ShaderContext_get_class_type_1854, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderContext_get_class_type_1854_comment},
  {"getClassType", &Dtool_ShaderContext_get_class_type_1854, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderContext_get_class_type_1854_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ShaderContext[] = {
  {(char *)"shader", &Dtool_ShaderContext_shader_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ShaderContext = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShaderContext = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ShaderContext = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ShaderContext = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ShaderContext = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ShaderContext = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ShaderContext",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderContext,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ShaderContext,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShaderContext,
    &Dtool_SequenceMethods_ShaderContext,
    &Dtool_MappingMethods_ShaderContext,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ShaderContext,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShaderContext,
    nullptr, // tp_members
    Dtool_Properties_ShaderContext,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShaderContext,
    PyType_GenericAlloc,
    Dtool_new_ShaderContext,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderContext,
  Dtool_UpcastInterface_ShaderContext,
  Dtool_DowncastInterface_ShaderContext,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShaderContext(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_SavedContext(nullptr);
    Dtool_ShaderContext._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_SavedContext);
    Dtool_ShaderContext._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShaderContext._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderContext) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderContext)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderContext);
  }
}

/**
 * Python method tables for UserVertexSlider (UserVertexSlider)
 */
static PyMethodDef Dtool_Methods_UserVertexSlider[] = {
  {"set_slider", &Dtool_UserVertexSlider_set_slider_1858, METH_O, (const char *)Dtool_UserVertexSlider_set_slider_1858_comment},
  {"setSlider", &Dtool_UserVertexSlider_set_slider_1858, METH_O, (const char *)Dtool_UserVertexSlider_set_slider_1858_comment},
  {"get_class_type", &Dtool_UserVertexSlider_get_class_type_1859, METH_NOARGS | METH_STATIC, (const char *)Dtool_UserVertexSlider_get_class_type_1859_comment},
  {"getClassType", &Dtool_UserVertexSlider_get_class_type_1859, METH_NOARGS | METH_STATIC, (const char *)Dtool_UserVertexSlider_get_class_type_1859_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_UserVertexSlider = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UserVertexSlider = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_UserVertexSlider = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_UserVertexSlider = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_UserVertexSlider = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_UserVertexSlider = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.UserVertexSlider",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_UserVertexSlider,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_UserVertexSlider,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_UserVertexSlider,
    &Dtool_SequenceMethods_UserVertexSlider,
    &Dtool_MappingMethods_UserVertexSlider,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_UserVertexSlider,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization on VertexSlider that allows the user to specify\n"
    " * any arbitrary slider valie he likes.  This is rarely used except for\n"
    " * testing.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_UserVertexSlider,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_UserVertexSlider,
    PyType_GenericAlloc,
    Dtool_new_UserVertexSlider,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UserVertexSlider,
  Dtool_UpcastInterface_UserVertexSlider,
  Dtool_DowncastInterface_UserVertexSlider,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_UserVertexSlider(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VertexSlider(nullptr);
    Dtool_UserVertexSlider._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VertexSlider);
    Dtool_UserVertexSlider._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_UserVertexSlider._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UserVertexSlider) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UserVertexSlider)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UserVertexSlider);
  }
}

/**
 * Python method tables for UserVertexTransform (UserVertexTransform)
 */
static PyMethodDef Dtool_Methods_UserVertexTransform[] = {
  {"get_name", &Dtool_UserVertexTransform_get_name_1863, METH_NOARGS, (const char *)Dtool_UserVertexTransform_get_name_1863_comment},
  {"getName", &Dtool_UserVertexTransform_get_name_1863, METH_NOARGS, (const char *)Dtool_UserVertexTransform_get_name_1863_comment},
  {"set_matrix", &Dtool_UserVertexTransform_set_matrix_1864, METH_O, (const char *)Dtool_UserVertexTransform_set_matrix_1864_comment},
  {"setMatrix", &Dtool_UserVertexTransform_set_matrix_1864, METH_O, (const char *)Dtool_UserVertexTransform_set_matrix_1864_comment},
  {"get_class_type", &Dtool_UserVertexTransform_get_class_type_1865, METH_NOARGS | METH_STATIC, (const char *)Dtool_UserVertexTransform_get_class_type_1865_comment},
  {"getClassType", &Dtool_UserVertexTransform_get_class_type_1865, METH_NOARGS | METH_STATIC, (const char *)Dtool_UserVertexTransform_get_class_type_1865_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_UserVertexTransform = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UserVertexTransform = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_UserVertexTransform = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_UserVertexTransform = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_UserVertexTransform = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_UserVertexTransform = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.UserVertexTransform",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_UserVertexTransform,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_UserVertexTransform,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_UserVertexTransform,
    &Dtool_SequenceMethods_UserVertexTransform,
    &Dtool_MappingMethods_UserVertexTransform,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_UserVertexTransform,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization on VertexTransform that allows the user to specify\n"
    " * any arbitrary transform matrix he likes.  This is rarely used except for\n"
    " * testing.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_UserVertexTransform,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_UserVertexTransform,
    PyType_GenericAlloc,
    Dtool_new_UserVertexTransform,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UserVertexTransform,
  Dtool_UpcastInterface_UserVertexTransform,
  Dtool_DowncastInterface_UserVertexTransform,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_UserVertexTransform(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VertexTransform(nullptr);
    Dtool_UserVertexTransform._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VertexTransform);
    Dtool_UserVertexTransform._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_UserVertexTransform._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UserVertexTransform) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UserVertexTransform)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UserVertexTransform);
  }
}

/**
 * Python method tables for VideoTexture (VideoTexture)
 */
static PyMethodDef Dtool_Methods_VideoTexture[] = {
  {"get_keep_ram_image", &Dtool_VideoTexture_get_keep_ram_image_1873, METH_NOARGS, (const char *)Dtool_VideoTexture_get_keep_ram_image_1873_comment},
  {"getKeepRamImage", &Dtool_VideoTexture_get_keep_ram_image_1873, METH_NOARGS, (const char *)Dtool_VideoTexture_get_keep_ram_image_1873_comment},
  {"get_video_width", &Dtool_VideoTexture_get_video_width_1874, METH_NOARGS, (const char *)Dtool_VideoTexture_get_video_width_1874_comment},
  {"getVideoWidth", &Dtool_VideoTexture_get_video_width_1874, METH_NOARGS, (const char *)Dtool_VideoTexture_get_video_width_1874_comment},
  {"get_video_height", &Dtool_VideoTexture_get_video_height_1875, METH_NOARGS, (const char *)Dtool_VideoTexture_get_video_height_1875_comment},
  {"getVideoHeight", &Dtool_VideoTexture_get_video_height_1875, METH_NOARGS, (const char *)Dtool_VideoTexture_get_video_height_1875_comment},
  {"get_class_type", &Dtool_VideoTexture_get_class_type_1878, METH_NOARGS | METH_STATIC, (const char *)Dtool_VideoTexture_get_class_type_1878_comment},
  {"getClassType", &Dtool_VideoTexture_get_class_type_1878, METH_NOARGS | METH_STATIC, (const char *)Dtool_VideoTexture_get_class_type_1878_comment},
  {"upcast_to_Texture", &Dtool_VideoTexture_upcast_to_Texture_1868, METH_NOARGS, (const char *)Dtool_VideoTexture_upcast_to_Texture_1868_comment},
  {"upcastToTexture", &Dtool_VideoTexture_upcast_to_Texture_1868, METH_NOARGS, (const char *)Dtool_VideoTexture_upcast_to_Texture_1868_comment},
  {"upcast_to_AnimInterface", &Dtool_VideoTexture_upcast_to_AnimInterface_1871, METH_NOARGS, (const char *)Dtool_VideoTexture_upcast_to_AnimInterface_1871_comment},
  {"upcastToAnimInterface", &Dtool_VideoTexture_upcast_to_AnimInterface_1871, METH_NOARGS, (const char *)Dtool_VideoTexture_upcast_to_AnimInterface_1871_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_VideoTexture[] = {
  {(char *)"video_width", &Dtool_VideoTexture_video_width_Getter, nullptr, nullptr, nullptr},
  {(char *)"video_height", &Dtool_VideoTexture_video_height_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_VideoTexture = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VideoTexture = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VideoTexture = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VideoTexture = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VideoTexture = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VideoTexture = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VideoTexture",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VideoTexture,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VideoTexture,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VideoTexture,
    &Dtool_SequenceMethods_VideoTexture,
    &Dtool_MappingMethods_VideoTexture,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VideoTexture,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The base class for a family of animated Textures that take their input from\n"
    " * a video source, such as a movie file.  These Textures may be stopped,\n"
    " * started, etc.  using the AnimInterface controls, similar to an animated\n"
    " * character.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VideoTexture,
    nullptr, // tp_members
    Dtool_Properties_VideoTexture,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VideoTexture,
    PyType_GenericAlloc,
    Dtool_new_VideoTexture,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VideoTexture,
  Dtool_UpcastInterface_VideoTexture,
  Dtool_DowncastInterface_VideoTexture,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VideoTexture(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Texture(nullptr);
    assert(Dtool_Ptr_AnimInterface != nullptr);
    assert(Dtool_Ptr_AnimInterface->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_AnimInterface->_Dtool_ModuleClassInit(nullptr);
    Dtool_VideoTexture._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_Texture, (PyTypeObject *)Dtool_Ptr_AnimInterface);
    Dtool_VideoTexture._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VideoTexture._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VideoTexture) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VideoTexture)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VideoTexture);
  }
}

/**
 * Python method tables for VertexBufferContext (VertexBufferContext)
 */
static PyMethodDef Dtool_Methods_VertexBufferContext[] = {
  {"get_data", &Dtool_VertexBufferContext_get_data_1885, METH_NOARGS, (const char *)Dtool_VertexBufferContext_get_data_1885_comment},
  {"getData", &Dtool_VertexBufferContext_get_data_1885, METH_NOARGS, (const char *)Dtool_VertexBufferContext_get_data_1885_comment},
  {"changed_size", &Dtool_VertexBufferContext_changed_size_1886, METH_O, (const char *)Dtool_VertexBufferContext_changed_size_1886_comment},
  {"changedSize", &Dtool_VertexBufferContext_changed_size_1886, METH_O, (const char *)Dtool_VertexBufferContext_changed_size_1886_comment},
  {"changed_usage_hint", &Dtool_VertexBufferContext_changed_usage_hint_1887, METH_O, (const char *)Dtool_VertexBufferContext_changed_usage_hint_1887_comment},
  {"changedUsageHint", &Dtool_VertexBufferContext_changed_usage_hint_1887, METH_O, (const char *)Dtool_VertexBufferContext_changed_usage_hint_1887_comment},
  {"was_modified", &Dtool_VertexBufferContext_was_modified_1888, METH_O, (const char *)Dtool_VertexBufferContext_was_modified_1888_comment},
  {"wasModified", &Dtool_VertexBufferContext_was_modified_1888, METH_O, (const char *)Dtool_VertexBufferContext_was_modified_1888_comment},
  {"get_class_type", &Dtool_VertexBufferContext_get_class_type_1889, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexBufferContext_get_class_type_1889_comment},
  {"getClassType", &Dtool_VertexBufferContext_get_class_type_1889, METH_NOARGS | METH_STATIC, (const char *)Dtool_VertexBufferContext_get_class_type_1889_comment},
  {"upcast_to_BufferContext", &Dtool_VertexBufferContext_upcast_to_BufferContext_1881, METH_NOARGS, (const char *)Dtool_VertexBufferContext_upcast_to_BufferContext_1881_comment},
  {"upcastToBufferContext", &Dtool_VertexBufferContext_upcast_to_BufferContext_1881, METH_NOARGS, (const char *)Dtool_VertexBufferContext_upcast_to_BufferContext_1881_comment},
  {"upcast_to_AdaptiveLruPage", &Dtool_VertexBufferContext_upcast_to_AdaptiveLruPage_1883, METH_NOARGS, (const char *)Dtool_VertexBufferContext_upcast_to_AdaptiveLruPage_1883_comment},
  {"upcastToAdaptiveLruPage", &Dtool_VertexBufferContext_upcast_to_AdaptiveLruPage_1883, METH_NOARGS, (const char *)Dtool_VertexBufferContext_upcast_to_AdaptiveLruPage_1883_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VertexBufferContext = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VertexBufferContext = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VertexBufferContext = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VertexBufferContext = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VertexBufferContext = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VertexBufferContext = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VertexBufferContext",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VertexBufferContext,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VertexBufferContext,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VertexBufferContext,
    &Dtool_SequenceMethods_VertexBufferContext,
    &Dtool_MappingMethods_VertexBufferContext,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VertexBufferContext,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special class object that holds all the information returned by a\n"
    " * particular GSG to indicate the vertex data array's internal context\n"
    " * identifier.\n"
    " *\n"
    " * This allows the GSG to cache the vertex data array in whatever way makes\n"
    " * sense.  For instance, DirectX can allocate a vertex buffer for the array.\n"
    " * OpenGL can create a buffer object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VertexBufferContext,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VertexBufferContext,
    PyType_GenericAlloc,
    Dtool_new_VertexBufferContext,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VertexBufferContext,
  Dtool_UpcastInterface_VertexBufferContext,
  Dtool_DowncastInterface_VertexBufferContext,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VertexBufferContext(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BufferContext(nullptr);
    Dtool_PyModuleClassInit_AdaptiveLruPage(nullptr);
    Dtool_VertexBufferContext._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_BufferContext, (PyTypeObject *)&Dtool_AdaptiveLruPage);
    Dtool_VertexBufferContext._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VertexBufferContext._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VertexBufferContext) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VertexBufferContext)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VertexBufferContext);
  }
}

/**
 * Python method tables for TextureCollection (TextureCollection)
 */
static PyMethodDef Dtool_Methods_TextureCollection[] = {
  {"assign", &Dtool_TextureCollection_operator_1893, METH_O, (const char *)Dtool_TextureCollection_operator_1893_comment},
  {"__reduce__", &Dtool_TextureCollection_reduce_1895, METH_NOARGS, (const char *)Dtool_TextureCollection_reduce_1895_comment},
  {"add_texture", &Dtool_TextureCollection_add_texture_1896, METH_O, (const char *)Dtool_TextureCollection_add_texture_1896_comment},
  {"addTexture", &Dtool_TextureCollection_add_texture_1896, METH_O, (const char *)Dtool_TextureCollection_add_texture_1896_comment},
  {"remove_texture", &Dtool_TextureCollection_remove_texture_1897, METH_O, (const char *)Dtool_TextureCollection_remove_texture_1897_comment},
  {"removeTexture", &Dtool_TextureCollection_remove_texture_1897, METH_O, (const char *)Dtool_TextureCollection_remove_texture_1897_comment},
  {"add_textures_from", &Dtool_TextureCollection_add_textures_from_1898, METH_O, (const char *)Dtool_TextureCollection_add_textures_from_1898_comment},
  {"addTexturesFrom", &Dtool_TextureCollection_add_textures_from_1898, METH_O, (const char *)Dtool_TextureCollection_add_textures_from_1898_comment},
  {"remove_textures_from", &Dtool_TextureCollection_remove_textures_from_1899, METH_O, (const char *)Dtool_TextureCollection_remove_textures_from_1899_comment},
  {"removeTexturesFrom", &Dtool_TextureCollection_remove_textures_from_1899, METH_O, (const char *)Dtool_TextureCollection_remove_textures_from_1899_comment},
  {"remove_duplicate_textures", &Dtool_TextureCollection_remove_duplicate_textures_1900, METH_NOARGS, (const char *)Dtool_TextureCollection_remove_duplicate_textures_1900_comment},
  {"removeDuplicateTextures", &Dtool_TextureCollection_remove_duplicate_textures_1900, METH_NOARGS, (const char *)Dtool_TextureCollection_remove_duplicate_textures_1900_comment},
  {"has_texture", &Dtool_TextureCollection_has_texture_1901, METH_O, (const char *)Dtool_TextureCollection_has_texture_1901_comment},
  {"hasTexture", &Dtool_TextureCollection_has_texture_1901, METH_O, (const char *)Dtool_TextureCollection_has_texture_1901_comment},
  {"clear", &Dtool_TextureCollection_clear_1902, METH_NOARGS, (const char *)Dtool_TextureCollection_clear_1902_comment},
  {"reserve", &Dtool_TextureCollection_reserve_1903, METH_O, (const char *)Dtool_TextureCollection_reserve_1903_comment},
  {"find_texture", &Dtool_TextureCollection_find_texture_1904, METH_O, (const char *)Dtool_TextureCollection_find_texture_1904_comment},
  {"findTexture", &Dtool_TextureCollection_find_texture_1904, METH_O, (const char *)Dtool_TextureCollection_find_texture_1904_comment},
  {"get_num_textures", &Dtool_TextureCollection_get_num_textures_1905, METH_NOARGS, (const char *)Dtool_TextureCollection_get_num_textures_1905_comment},
  {"getNumTextures", &Dtool_TextureCollection_get_num_textures_1905, METH_NOARGS, (const char *)Dtool_TextureCollection_get_num_textures_1905_comment},
  {"get_texture", &Dtool_TextureCollection_get_texture_1906, METH_O, (const char *)Dtool_TextureCollection_get_texture_1906_comment},
  {"getTexture", &Dtool_TextureCollection_get_texture_1906, METH_O, (const char *)Dtool_TextureCollection_get_texture_1906_comment},
  {"append", &Dtool_TextureCollection_append_1912, METH_O, (const char *)Dtool_TextureCollection_append_1912_comment},
  {"extend", &Dtool_TextureCollection_extend_1913, METH_O, (const char *)Dtool_TextureCollection_extend_1913_comment},
  {"output", &Dtool_TextureCollection_output_1914, METH_O, (const char *)Dtool_TextureCollection_output_1914_comment},
  {"write", (PyCFunction) &Dtool_TextureCollection_write_1915, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextureCollection_write_1915_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_textures", (PyCFunction) &MakeSeq_TextureCollection_get_textures, METH_NOARGS, nullptr},
  { "getTextures", (PyCFunction) &MakeSeq_TextureCollection_get_textures, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TextureCollection slot nb_add -> operator +
//////////////////
static PyObject *Dtool_TextureCollection_operator_1911_nb_add(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_TextureCollection, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline TextureCollection TextureCollection::operator +(TextureCollection const &other) const
  TextureCollection arg_local;
  TextureCollection const *arg_this = Dtool_Coerce_TextureCollection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TextureCollection.__add__", "TextureCollection");
  }
  TextureCollection *return_value = new TextureCollection(((*(const TextureCollection*)local_this).operator +)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureCollection, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TextureCollection slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_TextureCollection_operator_1910_nb_inplace_add(PyObject *self, PyObject *arg) {
  TextureCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_TextureCollection, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void TextureCollection::operator +=(TextureCollection const &other)
  TextureCollection arg_local;
  TextureCollection const *arg_this = Dtool_Coerce_TextureCollection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextureCollection.__iadd__", "TextureCollection");
    return nullptr;
  }
  ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TextureCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_TextureCollection_operator_1908_sq_item(PyObject *self, Py_ssize_t index) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureCollection, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "TextureCollection index out of range");
    return nullptr;
  }
  // 1-Texture *TextureCollection::operator [](int index) const
  Texture *return_value = ((*(const TextureCollection*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(TextureCollection self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TextureCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_TextureCollection_size_1909_sq_length(PyObject *self) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     TextureCollection
//////////////////
static PyObject *Dtool_Repr_TextureCollection(PyObject *self) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     TextureCollection
//////////////////
static PyObject *Dtool_Str_TextureCollection(PyObject *self) {
  TextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_TextureCollection = {
  &Dtool_TextureCollection_operator_1911_nb_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_TextureCollection_operator_1910_nb_inplace_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextureCollection = {
  &Dtool_TextureCollection_size_1909_sq_length,
  nullptr,
  nullptr,
  &Dtool_TextureCollection_operator_1908_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_TextureCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextureCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextureCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_TextureCollection,
    &Dtool_NumberMethods_TextureCollection,
    &Dtool_SequenceMethods_TextureCollection,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_TextureCollection,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Manages a list of Texture objects, as returned by\n"
    " * TexturePool::find_all_textures().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextureCollection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextureCollection,
    PyType_GenericAlloc,
    Dtool_new_TextureCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextureCollection,
  Dtool_UpcastInterface_TextureCollection,
  Dtool_DowncastInterface_TextureCollection,
  nullptr,
  (CoerceFunction)Dtool_Coerce_TextureCollection,
};

static void Dtool_PyModuleClassInit_TextureCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextureCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextureCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextureCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextureCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextureCollection);
  }
}

/**
 * Python method tables for TexturePool (TexturePool)
 */
static PyMethodDef Dtool_Methods_TexturePool[] = {
  {"has_texture", &Dtool_TexturePool_has_texture_1917, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_has_texture_1917_comment},
  {"hasTexture", &Dtool_TexturePool_has_texture_1917, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_has_texture_1917_comment},
  {"verify_texture", &Dtool_TexturePool_verify_texture_1918, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_verify_texture_1918_comment},
  {"verifyTexture", &Dtool_TexturePool_verify_texture_1918, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_verify_texture_1918_comment},
  {"load_texture", (PyCFunction) &Dtool_TexturePool_load_texture_1919, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexturePool_load_texture_1919_comment},
  {"loadTexture", (PyCFunction) &Dtool_TexturePool_load_texture_1919, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexturePool_load_texture_1919_comment},
  {"load_3d_texture", (PyCFunction) &Dtool_TexturePool_load_3d_texture_1920, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexturePool_load_3d_texture_1920_comment},
  {"load3dTexture", (PyCFunction) &Dtool_TexturePool_load_3d_texture_1920, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexturePool_load_3d_texture_1920_comment},
  {"load_2d_texture_array", (PyCFunction) &Dtool_TexturePool_load_2d_texture_array_1921, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexturePool_load_2d_texture_array_1921_comment},
  {"load2dTextureArray", (PyCFunction) &Dtool_TexturePool_load_2d_texture_array_1921, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexturePool_load_2d_texture_array_1921_comment},
  {"load_cube_map", (PyCFunction) &Dtool_TexturePool_load_cube_map_1922, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexturePool_load_cube_map_1922_comment},
  {"loadCubeMap", (PyCFunction) &Dtool_TexturePool_load_cube_map_1922, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexturePool_load_cube_map_1922_comment},
  {"get_normalization_cube_map", &Dtool_TexturePool_get_normalization_cube_map_1923, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_get_normalization_cube_map_1923_comment},
  {"getNormalizationCubeMap", &Dtool_TexturePool_get_normalization_cube_map_1923, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_get_normalization_cube_map_1923_comment},
  {"get_alpha_scale_map", &Dtool_TexturePool_get_alpha_scale_map_1924, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_get_alpha_scale_map_1924_comment},
  {"getAlphaScaleMap", &Dtool_TexturePool_get_alpha_scale_map_1924, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_get_alpha_scale_map_1924_comment},
  {"add_texture", &Dtool_TexturePool_add_texture_1925, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_add_texture_1925_comment},
  {"addTexture", &Dtool_TexturePool_add_texture_1925, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_add_texture_1925_comment},
  {"release_texture", &Dtool_TexturePool_release_texture_1926, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_release_texture_1926_comment},
  {"releaseTexture", &Dtool_TexturePool_release_texture_1926, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_release_texture_1926_comment},
  {"release_all_textures", &Dtool_TexturePool_release_all_textures_1927, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_release_all_textures_1927_comment},
  {"releaseAllTextures", &Dtool_TexturePool_release_all_textures_1927, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_release_all_textures_1927_comment},
  {"rehash", &Dtool_TexturePool_rehash_1928, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_rehash_1928_comment},
  {"garbage_collect", &Dtool_TexturePool_garbage_collect_1929, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_garbage_collect_1929_comment},
  {"garbageCollect", &Dtool_TexturePool_garbage_collect_1929, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_garbage_collect_1929_comment},
  {"list_contents", &Dtool_TexturePool_list_contents_1930, METH_VARARGS | METH_STATIC, (const char *)Dtool_TexturePool_list_contents_1930_comment},
  {"listContents", &Dtool_TexturePool_list_contents_1930, METH_VARARGS | METH_STATIC, (const char *)Dtool_TexturePool_list_contents_1930_comment},
  {"find_texture", &Dtool_TexturePool_find_texture_1931, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_find_texture_1931_comment},
  {"findTexture", &Dtool_TexturePool_find_texture_1931, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_find_texture_1931_comment},
  {"find_all_textures", (PyCFunction) &Dtool_TexturePool_find_all_textures_1932, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexturePool_find_all_textures_1932_comment},
  {"findAllTextures", (PyCFunction) &Dtool_TexturePool_find_all_textures_1932, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TexturePool_find_all_textures_1932_comment},
  {"set_fake_texture_image", &Dtool_TexturePool_set_fake_texture_image_1933, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_set_fake_texture_image_1933_comment},
  {"setFakeTextureImage", &Dtool_TexturePool_set_fake_texture_image_1933, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_set_fake_texture_image_1933_comment},
  {"clear_fake_texture_image", &Dtool_TexturePool_clear_fake_texture_image_1934, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_clear_fake_texture_image_1934_comment},
  {"clearFakeTextureImage", &Dtool_TexturePool_clear_fake_texture_image_1934, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_clear_fake_texture_image_1934_comment},
  {"has_fake_texture_image", &Dtool_TexturePool_has_fake_texture_image_1935, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_has_fake_texture_image_1935_comment},
  {"hasFakeTextureImage", &Dtool_TexturePool_has_fake_texture_image_1935, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_has_fake_texture_image_1935_comment},
  {"get_fake_texture_image", &Dtool_TexturePool_get_fake_texture_image_1936, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_get_fake_texture_image_1936_comment},
  {"getFakeTextureImage", &Dtool_TexturePool_get_fake_texture_image_1936, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePool_get_fake_texture_image_1936_comment},
  {"make_texture", &Dtool_TexturePool_make_texture_1937, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_make_texture_1937_comment},
  {"makeTexture", &Dtool_TexturePool_make_texture_1937, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_make_texture_1937_comment},
  {"write", &Dtool_TexturePool_write_1938, METH_O | METH_STATIC, (const char *)Dtool_TexturePool_write_1938_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     TexturePool
//////////////////
static PyObject *Dtool_Str_TexturePool(PyObject *self) {
  TexturePool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TexturePool, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_TexturePool = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TexturePool = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TexturePool",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TexturePool,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TexturePool,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_TexturePool,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the preferred interface for loading textures from image files.  It\n"
    " * unifies all references to the same filename, so that multiple models that\n"
    " * reference the same textures don't waste texture memory unnecessarily.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TexturePool,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TexturePool,
    PyType_GenericAlloc,
    Dtool_new_TexturePool,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TexturePool,
  Dtool_UpcastInterface_TexturePool,
  Dtool_DowncastInterface_TexturePool,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TexturePool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TexturePool._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TexturePool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TexturePool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TexturePool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TexturePool);
  }
}

/**
 * Python method tables for TexturePeeker (TexturePeeker)
 */
static PyMethodDef Dtool_Methods_TexturePeeker[] = {
  {"get_x_size", &Dtool_TexturePeeker_get_x_size_1941, METH_NOARGS, (const char *)Dtool_TexturePeeker_get_x_size_1941_comment},
  {"getXSize", &Dtool_TexturePeeker_get_x_size_1941, METH_NOARGS, (const char *)Dtool_TexturePeeker_get_x_size_1941_comment},
  {"get_y_size", &Dtool_TexturePeeker_get_y_size_1942, METH_NOARGS, (const char *)Dtool_TexturePeeker_get_y_size_1942_comment},
  {"getYSize", &Dtool_TexturePeeker_get_y_size_1942, METH_NOARGS, (const char *)Dtool_TexturePeeker_get_y_size_1942_comment},
  {"get_z_size", &Dtool_TexturePeeker_get_z_size_1943, METH_NOARGS, (const char *)Dtool_TexturePeeker_get_z_size_1943_comment},
  {"getZSize", &Dtool_TexturePeeker_get_z_size_1943, METH_NOARGS, (const char *)Dtool_TexturePeeker_get_z_size_1943_comment},
  {"has_pixel", (PyCFunction) &Dtool_TexturePeeker_has_pixel_1944, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePeeker_has_pixel_1944_comment},
  {"hasPixel", (PyCFunction) &Dtool_TexturePeeker_has_pixel_1944, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePeeker_has_pixel_1944_comment},
  {"lookup", (PyCFunction) &Dtool_TexturePeeker_lookup_1945, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePeeker_lookup_1945_comment},
  {"fetch_pixel", (PyCFunction) &Dtool_TexturePeeker_fetch_pixel_1946, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePeeker_fetch_pixel_1946_comment},
  {"fetchPixel", (PyCFunction) &Dtool_TexturePeeker_fetch_pixel_1946, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePeeker_fetch_pixel_1946_comment},
  {"lookup_bilinear", (PyCFunction) &Dtool_TexturePeeker_lookup_bilinear_1947, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePeeker_lookup_bilinear_1947_comment},
  {"lookupBilinear", (PyCFunction) &Dtool_TexturePeeker_lookup_bilinear_1947, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePeeker_lookup_bilinear_1947_comment},
  {"filter_rect", (PyCFunction) &Dtool_TexturePeeker_filter_rect_1948, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePeeker_filter_rect_1948_comment},
  {"filterRect", (PyCFunction) &Dtool_TexturePeeker_filter_rect_1948, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePeeker_filter_rect_1948_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TexturePeeker = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TexturePeeker = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TexturePeeker = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TexturePeeker = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TexturePeeker = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TexturePeeker = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TexturePeeker",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TexturePeeker,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TexturePeeker,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TexturePeeker,
    &Dtool_SequenceMethods_TexturePeeker,
    &Dtool_MappingMethods_TexturePeeker,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TexturePeeker,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An instance of this object is returned by Texture::peek().  This object\n"
    " * allows quick and easy inspection of a texture's texels by (u, v)\n"
    " * coordinates.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TexturePeeker,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TexturePeeker,
    PyType_GenericAlloc,
    Dtool_new_TexturePeeker,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TexturePeeker,
  Dtool_UpcastInterface_TexturePeeker,
  Dtool_DowncastInterface_TexturePeeker,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TexturePeeker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_TexturePeeker._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_TexturePeeker._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TexturePeeker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TexturePeeker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TexturePeeker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TexturePeeker);
  }
}

/**
 * Python method tables for TextureStagePool (TextureStagePool)
 */
static PyMethodDef Dtool_Methods_TextureStagePool[] = {
  {"get_stage", &Dtool_TextureStagePool_get_stage_1953, METH_O | METH_STATIC, (const char *)Dtool_TextureStagePool_get_stage_1953_comment},
  {"getStage", &Dtool_TextureStagePool_get_stage_1953, METH_O | METH_STATIC, (const char *)Dtool_TextureStagePool_get_stage_1953_comment},
  {"release_stage", &Dtool_TextureStagePool_release_stage_1954, METH_O | METH_STATIC, (const char *)Dtool_TextureStagePool_release_stage_1954_comment},
  {"releaseStage", &Dtool_TextureStagePool_release_stage_1954, METH_O | METH_STATIC, (const char *)Dtool_TextureStagePool_release_stage_1954_comment},
  {"release_all_stages", &Dtool_TextureStagePool_release_all_stages_1955, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStagePool_release_all_stages_1955_comment},
  {"releaseAllStages", &Dtool_TextureStagePool_release_all_stages_1955, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStagePool_release_all_stages_1955_comment},
  {"set_mode", &Dtool_TextureStagePool_set_mode_1956, METH_O | METH_STATIC, (const char *)Dtool_TextureStagePool_set_mode_1956_comment},
  {"setMode", &Dtool_TextureStagePool_set_mode_1956, METH_O | METH_STATIC, (const char *)Dtool_TextureStagePool_set_mode_1956_comment},
  {"get_mode", &Dtool_TextureStagePool_get_mode_1957, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStagePool_get_mode_1957_comment},
  {"getMode", &Dtool_TextureStagePool_get_mode_1957, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStagePool_get_mode_1957_comment},
  {"garbage_collect", &Dtool_TextureStagePool_garbage_collect_1959, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStagePool_garbage_collect_1959_comment},
  {"garbageCollect", &Dtool_TextureStagePool_garbage_collect_1959, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStagePool_garbage_collect_1959_comment},
  {"list_contents", &Dtool_TextureStagePool_list_contents_1960, METH_O | METH_STATIC, (const char *)Dtool_TextureStagePool_list_contents_1960_comment},
  {"listContents", &Dtool_TextureStagePool_list_contents_1960, METH_O | METH_STATIC, (const char *)Dtool_TextureStagePool_list_contents_1960_comment},
  {"write", &Dtool_TextureStagePool_write_1961, METH_O | METH_STATIC, (const char *)Dtool_TextureStagePool_write_1961_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     TextureStagePool
//////////////////
static PyObject *Dtool_Str_TextureStagePool(PyObject *self) {
  TextureStagePool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextureStagePool, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_TextureStagePool = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TextureStagePool = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextureStagePool",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextureStagePool,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextureStagePool,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_TextureStagePool,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The TextureStagePool (there is only one in the universe) serves to unify\n"
    " * different pointers to the same TextureStage, mainly to help developers use\n"
    " * a common pointer to access things that are loaded from different model\n"
    " * files.\n"
    " *\n"
    " * It runs in one of three different modes, according to set_mode().  See that\n"
    " * method for more information.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextureStagePool,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextureStagePool,
    PyType_GenericAlloc,
    Dtool_new_TextureStagePool,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextureStagePool,
  Dtool_UpcastInterface_TextureStagePool,
  Dtool_DowncastInterface_TextureStagePool,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextureStagePool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextureStagePool._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_TextureStagePool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TextureStagePool::Mode;
    PyDict_SetItemString(dict, "M_none", Dtool_WrapValue(TextureStagePool::M_none));
    PyDict_SetItemString(dict, "MNone", Dtool_WrapValue(TextureStagePool::M_none));
    PyDict_SetItemString(dict, "M_name", Dtool_WrapValue(TextureStagePool::M_name));
    PyDict_SetItemString(dict, "MName", Dtool_WrapValue(TextureStagePool::M_name));
    PyDict_SetItemString(dict, "M_unique", Dtool_WrapValue(TextureStagePool::M_unique));
    PyDict_SetItemString(dict, "MUnique", Dtool_WrapValue(TextureStagePool::M_unique));
    static const PyGetSetDef def_mode = {(char *)"mode", &Dtool_TextureStagePool_mode_Getter, &Dtool_TextureStagePool_mode_Setter, nullptr, nullptr};
    PyDict_SetItemString(dict, "mode", Dtool_NewStaticProperty(&Dtool_TextureStagePool._PyType, &def_mode));
    if (PyType_Ready((PyTypeObject *)&Dtool_TextureStagePool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextureStagePool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextureStagePool);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3gobj_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    InternalName::init_type();
    TypeHandle handle = InternalName::get_class_type();
    Dtool_InternalName._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_InternalName);
  }
  {
    GeomVertexArrayFormat::init_type();
    TypeHandle handle = GeomVertexArrayFormat::get_class_type();
    Dtool_GeomVertexArrayFormat._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomVertexArrayFormat);
  }
  {
    GeomVertexFormat::init_type();
    TypeHandle handle = GeomVertexFormat::get_class_type();
    Dtool_GeomVertexFormat._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomVertexFormat);
  }
  {
    VertexDataPage::init_type();
    TypeHandle handle = VertexDataPage::get_class_type();
    Dtool_VertexDataPage._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VertexDataPage);
  }
  {
    GeomVertexArrayData::init_type();
    TypeHandle handle = GeomVertexArrayData::get_class_type();
    Dtool_GeomVertexArrayData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomVertexArrayData);
  }
  {
    GeomVertexArrayDataHandle::init_type();
    TypeHandle handle = GeomVertexArrayDataHandle::get_class_type();
    Dtool_GeomVertexArrayDataHandle._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomVertexArrayDataHandle);
  }
  {
    VertexTransform::init_type();
    TypeHandle handle = VertexTransform::get_class_type();
    Dtool_VertexTransform._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VertexTransform);
  }
  {
    TransformTable::init_type();
    TypeHandle handle = TransformTable::get_class_type();
    Dtool_TransformTable._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TransformTable);
  }
  {
    TransformBlend::init_type();
    TypeHandle handle = TransformBlend::get_class_type();
    Dtool_TransformBlend._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TransformBlend);
  }
  {
    TransformBlendTable::init_type();
    TypeHandle handle = TransformBlendTable::get_class_type();
    Dtool_TransformBlendTable._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TransformBlendTable);
  }
  {
    VertexSlider::init_type();
    TypeHandle handle = VertexSlider::get_class_type();
    Dtool_VertexSlider._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VertexSlider);
  }
  {
    SliderTable::init_type();
    TypeHandle handle = SliderTable::get_class_type();
    Dtool_SliderTable._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_SliderTable);
  }
  {
    GeomVertexData::init_type();
    TypeHandle handle = GeomVertexData::get_class_type();
    Dtool_GeomVertexData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomVertexData);
  }
  {
    AnimateVerticesRequest::init_type();
    TypeHandle handle = AnimateVerticesRequest::get_class_type();
    Dtool_AnimateVerticesRequest._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimateVerticesRequest);
  }
  {
    SavedContext::init_type();
    TypeHandle handle = SavedContext::get_class_type();
    Dtool_SavedContext._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_SavedContext);
  }
  {
    BufferContext::init_type();
    TypeHandle handle = BufferContext::get_class_type();
    Dtool_BufferContext._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BufferContext);
  }
  {
    GeomPrimitive::init_type();
    TypeHandle handle = GeomPrimitive::get_class_type();
    Dtool_GeomPrimitive._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomPrimitive);
  }
  {
    TextureStage::init_type();
    TypeHandle handle = TextureStage::get_class_type();
    Dtool_TextureStage._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TextureStage);
  }
  {
    Geom::init_type();
    TypeHandle handle = Geom::get_class_type();
    Dtool_Geom._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Geom);
  }
  {
    GeomContext::init_type();
    TypeHandle handle = GeomContext::get_class_type();
    Dtool_GeomContext._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomContext);
  }
  {
    GeomLines::init_type();
    TypeHandle handle = GeomLines::get_class_type();
    Dtool_GeomLines._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomLines);
  }
  {
    GeomLinesAdjacency::init_type();
    TypeHandle handle = GeomLinesAdjacency::get_class_type();
    Dtool_GeomLinesAdjacency._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomLinesAdjacency);
  }
  {
    GeomLinestrips::init_type();
    TypeHandle handle = GeomLinestrips::get_class_type();
    Dtool_GeomLinestrips._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomLinestrips);
  }
  {
    GeomLinestripsAdjacency::init_type();
    TypeHandle handle = GeomLinestripsAdjacency::get_class_type();
    Dtool_GeomLinestripsAdjacency._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomLinestripsAdjacency);
  }
  {
    GeomPatches::init_type();
    TypeHandle handle = GeomPatches::get_class_type();
    Dtool_GeomPatches._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomPatches);
  }
  {
    GeomPoints::init_type();
    TypeHandle handle = GeomPoints::get_class_type();
    Dtool_GeomPoints._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomPoints);
  }
  {
    GeomTriangles::init_type();
    TypeHandle handle = GeomTriangles::get_class_type();
    Dtool_GeomTriangles._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomTriangles);
  }
  {
    GeomTrianglesAdjacency::init_type();
    TypeHandle handle = GeomTrianglesAdjacency::get_class_type();
    Dtool_GeomTrianglesAdjacency._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomTrianglesAdjacency);
  }
  {
    GeomTrifans::init_type();
    TypeHandle handle = GeomTrifans::get_class_type();
    Dtool_GeomTrifans._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomTrifans);
  }
  {
    GeomTristrips::init_type();
    TypeHandle handle = GeomTristrips::get_class_type();
    Dtool_GeomTristrips._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomTristrips);
  }
  {
    GeomTristripsAdjacency::init_type();
    TypeHandle handle = GeomTristripsAdjacency::get_class_type();
    Dtool_GeomTristripsAdjacency._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomTristripsAdjacency);
  }
  {
    SamplerState::init_type();
    TypeHandle handle = SamplerState::get_class_type();
    Dtool_SamplerState._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_SamplerState);
  }
  {
    Texture::init_type();
    TypeHandle handle = Texture::get_class_type();
    Dtool_Texture._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Texture);
  }
  {
    Shader::init_type();
    TypeHandle handle = Shader::get_class_type();
    Dtool_Shader._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Shader);
  }
  {
    ShaderBuffer::init_type();
    TypeHandle handle = ShaderBuffer::get_class_type();
    Dtool_ShaderBuffer._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ShaderBuffer);
  }
  {
    IndexBufferContext::init_type();
    TypeHandle handle = IndexBufferContext::get_class_type();
    Dtool_IndexBufferContext._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_IndexBufferContext);
  }
  {
    Lens::init_type();
    TypeHandle handle = Lens::get_class_type();
    Dtool_Lens._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Lens);
  }
  {
    Material::init_type();
    TypeHandle handle = Material::get_class_type();
    Dtool_Material._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Material);
  }
  {
    MatrixLens::init_type();
    TypeHandle handle = MatrixLens::get_class_type();
    Dtool_MatrixLens._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MatrixLens);
  }
  {
    OrthographicLens::init_type();
    TypeHandle handle = OrthographicLens::get_class_type();
    Dtool_OrthographicLens._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OrthographicLens);
  }
  {
    ParamTextureSampler::init_type();
    TypeHandle handle = ParamTextureSampler::get_class_type();
    Dtool_ParamTextureSampler._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamTextureSampler);
  }
  {
    ParamTextureImage::init_type();
    TypeHandle handle = ParamTextureImage::get_class_type();
    Dtool_ParamTextureImage._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamTextureImage);
  }
  {
    PerspectiveLens::init_type();
    TypeHandle handle = PerspectiveLens::get_class_type();
    Dtool_PerspectiveLens._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PerspectiveLens);
  }
  {
    TextureReloadRequest::init_type();
    TypeHandle handle = TextureReloadRequest::get_class_type();
    Dtool_TextureReloadRequest._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TextureReloadRequest);
  }
  {
    TextureContext::init_type();
    TypeHandle handle = TextureContext::get_class_type();
    Dtool_TextureContext._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TextureContext);
  }
  {
    ShaderContext::init_type();
    TypeHandle handle = ShaderContext::get_class_type();
    Dtool_ShaderContext._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ShaderContext);
  }
  {
    UserVertexSlider::init_type();
    TypeHandle handle = UserVertexSlider::get_class_type();
    Dtool_UserVertexSlider._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_UserVertexSlider);
  }
  {
    UserVertexTransform::init_type();
    TypeHandle handle = UserVertexTransform::get_class_type();
    Dtool_UserVertexTransform._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_UserVertexTransform);
  }
  {
    VideoTexture::init_type();
    TypeHandle handle = VideoTexture::get_class_type();
    Dtool_VideoTexture._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VideoTexture);
  }
  {
    VertexBufferContext::init_type();
    TypeHandle handle = VertexBufferContext::get_class_type();
    Dtool_VertexBufferContext._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VertexBufferContext);
  }
}

void Dtool_libp3gobj_BuildInstants(PyObject *module) {
  (void) module;
  // AdaptiveLru
  Dtool_PyModuleClassInit_AdaptiveLru(module);
  PyModule_AddObject(module, "AdaptiveLru", (PyObject *)&Dtool_AdaptiveLru);
  // AdaptiveLruPage
  Dtool_PyModuleClassInit_AdaptiveLruPage(module);
  PyModule_AddObject(module, "AdaptiveLruPage", (PyObject *)&Dtool_AdaptiveLruPage);
  // GeomEnums
  Dtool_PyModuleClassInit_GeomEnums(module);
  PyModule_AddObject(module, "GeomEnums", (PyObject *)&Dtool_GeomEnums);
  // GeomVertexAnimationSpec
  Dtool_PyModuleClassInit_GeomVertexAnimationSpec(module);
  PyModule_AddObject(module, "GeomVertexAnimationSpec", (PyObject *)&Dtool_GeomVertexAnimationSpec);
  // InternalName
  Dtool_PyModuleClassInit_InternalName(module);
  PyModule_AddObject(module, "InternalName", (PyObject *)&Dtool_InternalName);
  // GeomVertexColumn
  Dtool_PyModuleClassInit_GeomVertexColumn(module);
  PyModule_AddObject(module, "GeomVertexColumn", (PyObject *)&Dtool_GeomVertexColumn);
  // GeomVertexArrayFormat
  Dtool_PyModuleClassInit_GeomVertexArrayFormat(module);
  PyModule_AddObject(module, "GeomVertexArrayFormat", (PyObject *)&Dtool_GeomVertexArrayFormat);
  // GeomVertexFormat
  Dtool_PyModuleClassInit_GeomVertexFormat(module);
  PyModule_AddObject(module, "GeomVertexFormat", (PyObject *)&Dtool_GeomVertexFormat);
  // SimpleLru
  Dtool_PyModuleClassInit_SimpleLru(module);
  PyModule_AddObject(module, "SimpleLru", (PyObject *)&Dtool_SimpleLru);
  // SimpleLruPage
  Dtool_PyModuleClassInit_SimpleLruPage(module);
  PyModule_AddObject(module, "SimpleLruPage", (PyObject *)&Dtool_SimpleLruPage);
  // SimpleAllocator
  Dtool_PyModuleClassInit_SimpleAllocator(module);
  PyModule_AddObject(module, "SimpleAllocator", (PyObject *)&Dtool_SimpleAllocator);
  // SimpleAllocatorBlock
  Dtool_PyModuleClassInit_SimpleAllocatorBlock(module);
  PyModule_AddObject(module, "SimpleAllocatorBlock", (PyObject *)&Dtool_SimpleAllocatorBlock);
  // VertexDataSaveFile
  Dtool_PyModuleClassInit_VertexDataSaveFile(module);
  PyModule_AddObject(module, "VertexDataSaveFile", (PyObject *)&Dtool_VertexDataSaveFile);
  // VertexDataPage
  Dtool_PyModuleClassInit_VertexDataPage(module);
  PyModule_AddObject(module, "VertexDataPage", (PyObject *)&Dtool_VertexDataPage);
  // VertexDataBook
  Dtool_PyModuleClassInit_VertexDataBook(module);
  PyModule_AddObject(module, "VertexDataBook", (PyObject *)&Dtool_VertexDataBook);
  // VertexDataBlock
  Dtool_PyModuleClassInit_VertexDataBlock(module);
  PyModule_AddObject(module, "VertexDataBlock", (PyObject *)&Dtool_VertexDataBlock);
  // GeomVertexArrayData
  Dtool_PyModuleClassInit_GeomVertexArrayData(module);
  PyModule_AddObject(module, "GeomVertexArrayData", (PyObject *)&Dtool_GeomVertexArrayData);
  // GeomVertexArrayDataHandle
  Dtool_PyModuleClassInit_GeomVertexArrayDataHandle(module);
  PyModule_AddObject(module, "GeomVertexArrayDataHandle", (PyObject *)&Dtool_GeomVertexArrayDataHandle);
  // GeomCacheManager
  Dtool_PyModuleClassInit_GeomCacheManager(module);
  PyModule_AddObject(module, "GeomCacheManager", (PyObject *)&Dtool_GeomCacheManager);
  // VertexTransform
  Dtool_PyModuleClassInit_VertexTransform(module);
  PyModule_AddObject(module, "VertexTransform", (PyObject *)&Dtool_VertexTransform);
  // TransformTable
  Dtool_PyModuleClassInit_TransformTable(module);
  PyModule_AddObject(module, "TransformTable", (PyObject *)&Dtool_TransformTable);
  // TransformBlend
  Dtool_PyModuleClassInit_TransformBlend(module);
  PyModule_AddObject(module, "TransformBlend", (PyObject *)&Dtool_TransformBlend);
  // TransformBlendTable
  Dtool_PyModuleClassInit_TransformBlendTable(module);
  PyModule_AddObject(module, "TransformBlendTable", (PyObject *)&Dtool_TransformBlendTable);
  // VertexSlider
  Dtool_PyModuleClassInit_VertexSlider(module);
  PyModule_AddObject(module, "VertexSlider", (PyObject *)&Dtool_VertexSlider);
  // SliderTable
  Dtool_PyModuleClassInit_SliderTable(module);
  PyModule_AddObject(module, "SliderTable", (PyObject *)&Dtool_SliderTable);
  // GeomVertexData
  Dtool_PyModuleClassInit_GeomVertexData(module);
  PyModule_AddObject(module, "GeomVertexData", (PyObject *)&Dtool_GeomVertexData);
  // AnimateVerticesRequest
  Dtool_PyModuleClassInit_AnimateVerticesRequest(module);
  PyModule_AddObject(module, "AnimateVerticesRequest", (PyObject *)&Dtool_AnimateVerticesRequest);
  // SavedContext
  Dtool_PyModuleClassInit_SavedContext(module);
  PyModule_AddObject(module, "SavedContext", (PyObject *)&Dtool_SavedContext);
  // BufferContext
  Dtool_PyModuleClassInit_BufferContext(module);
  PyModule_AddObject(module, "BufferContext", (PyObject *)&Dtool_BufferContext);
  // GeomPrimitive
  Dtool_PyModuleClassInit_GeomPrimitive(module);
  PyModule_AddObject(module, "GeomPrimitive", (PyObject *)&Dtool_GeomPrimitive);
  // TextureStage
  Dtool_PyModuleClassInit_TextureStage(module);
  PyModule_AddObject(module, "TextureStage", (PyObject *)&Dtool_TextureStage);
  // Geom
  Dtool_PyModuleClassInit_Geom(module);
  PyModule_AddObject(module, "Geom", (PyObject *)&Dtool_Geom);
  // GeomContext
  Dtool_PyModuleClassInit_GeomContext(module);
  PyModule_AddObject(module, "GeomContext", (PyObject *)&Dtool_GeomContext);
  // GeomLines
  Dtool_PyModuleClassInit_GeomLines(module);
  PyModule_AddObject(module, "GeomLines", (PyObject *)&Dtool_GeomLines);
  // GeomLinesAdjacency
  Dtool_PyModuleClassInit_GeomLinesAdjacency(module);
  PyModule_AddObject(module, "GeomLinesAdjacency", (PyObject *)&Dtool_GeomLinesAdjacency);
  // GeomLinestrips
  Dtool_PyModuleClassInit_GeomLinestrips(module);
  PyModule_AddObject(module, "GeomLinestrips", (PyObject *)&Dtool_GeomLinestrips);
  // GeomLinestripsAdjacency
  Dtool_PyModuleClassInit_GeomLinestripsAdjacency(module);
  PyModule_AddObject(module, "GeomLinestripsAdjacency", (PyObject *)&Dtool_GeomLinestripsAdjacency);
  // GeomPatches
  Dtool_PyModuleClassInit_GeomPatches(module);
  PyModule_AddObject(module, "GeomPatches", (PyObject *)&Dtool_GeomPatches);
  // GeomPoints
  Dtool_PyModuleClassInit_GeomPoints(module);
  PyModule_AddObject(module, "GeomPoints", (PyObject *)&Dtool_GeomPoints);
  // GeomTriangles
  Dtool_PyModuleClassInit_GeomTriangles(module);
  PyModule_AddObject(module, "GeomTriangles", (PyObject *)&Dtool_GeomTriangles);
  // GeomTrianglesAdjacency
  Dtool_PyModuleClassInit_GeomTrianglesAdjacency(module);
  PyModule_AddObject(module, "GeomTrianglesAdjacency", (PyObject *)&Dtool_GeomTrianglesAdjacency);
  // GeomTrifans
  Dtool_PyModuleClassInit_GeomTrifans(module);
  PyModule_AddObject(module, "GeomTrifans", (PyObject *)&Dtool_GeomTrifans);
  // GeomTristrips
  Dtool_PyModuleClassInit_GeomTristrips(module);
  PyModule_AddObject(module, "GeomTristrips", (PyObject *)&Dtool_GeomTristrips);
  // GeomTristripsAdjacency
  Dtool_PyModuleClassInit_GeomTristripsAdjacency(module);
  PyModule_AddObject(module, "GeomTristripsAdjacency", (PyObject *)&Dtool_GeomTristripsAdjacency);
  // GeomVertexReader
  Dtool_PyModuleClassInit_GeomVertexReader(module);
  PyModule_AddObject(module, "GeomVertexReader", (PyObject *)&Dtool_GeomVertexReader);
  // GeomVertexWriter
  Dtool_PyModuleClassInit_GeomVertexWriter(module);
  PyModule_AddObject(module, "GeomVertexWriter", (PyObject *)&Dtool_GeomVertexWriter);
  // GeomVertexRewriter
  Dtool_PyModuleClassInit_GeomVertexRewriter(module);
  PyModule_AddObject(module, "GeomVertexRewriter", (PyObject *)&Dtool_GeomVertexRewriter);
  // SamplerState
  Dtool_PyModuleClassInit_SamplerState(module);
  PyModule_AddObject(module, "SamplerState", (PyObject *)&Dtool_SamplerState);
  // Texture
  Dtool_PyModuleClassInit_Texture(module);
  PyModule_AddObject(module, "Texture", (PyObject *)&Dtool_Texture);
  // Shader
  Dtool_PyModuleClassInit_Shader(module);
  PyModule_AddObject(module, "Shader", (PyObject *)&Dtool_Shader);
  // ShaderBuffer
  Dtool_PyModuleClassInit_ShaderBuffer(module);
  PyModule_AddObject(module, "ShaderBuffer", (PyObject *)&Dtool_ShaderBuffer);
  // PreparedGraphicsObjects
  Dtool_PyModuleClassInit_PreparedGraphicsObjects(module);
  PyModule_AddObject(module, "PreparedGraphicsObjects", (PyObject *)&Dtool_PreparedGraphicsObjects);
  // IndexBufferContext
  Dtool_PyModuleClassInit_IndexBufferContext(module);
  PyModule_AddObject(module, "IndexBufferContext", (PyObject *)&Dtool_IndexBufferContext);
  // Lens
  Dtool_PyModuleClassInit_Lens(module);
  PyModule_AddObject(module, "Lens", (PyObject *)&Dtool_Lens);
  // Material
  Dtool_PyModuleClassInit_Material(module);
  PyModule_AddObject(module, "Material", (PyObject *)&Dtool_Material);
  // MaterialPool
  Dtool_PyModuleClassInit_MaterialPool(module);
  PyModule_AddObject(module, "MaterialPool", (PyObject *)&Dtool_MaterialPool);
  // MatrixLens
  Dtool_PyModuleClassInit_MatrixLens(module);
  PyModule_AddObject(module, "MatrixLens", (PyObject *)&Dtool_MatrixLens);
  // OrthographicLens
  Dtool_PyModuleClassInit_OrthographicLens(module);
  PyModule_AddObject(module, "OrthographicLens", (PyObject *)&Dtool_OrthographicLens);
  // ParamTextureSampler
  Dtool_PyModuleClassInit_ParamTextureSampler(module);
  PyModule_AddObject(module, "ParamTextureSampler", (PyObject *)&Dtool_ParamTextureSampler);
  // ParamTextureImage
  Dtool_PyModuleClassInit_ParamTextureImage(module);
  PyModule_AddObject(module, "ParamTextureImage", (PyObject *)&Dtool_ParamTextureImage);
  // PerspectiveLens
  Dtool_PyModuleClassInit_PerspectiveLens(module);
  PyModule_AddObject(module, "PerspectiveLens", (PyObject *)&Dtool_PerspectiveLens);
  // TextureReloadRequest
  Dtool_PyModuleClassInit_TextureReloadRequest(module);
  PyModule_AddObject(module, "TextureReloadRequest", (PyObject *)&Dtool_TextureReloadRequest);
  // TextureContext
  Dtool_PyModuleClassInit_TextureContext(module);
  PyModule_AddObject(module, "TextureContext", (PyObject *)&Dtool_TextureContext);
  // ShaderContext
  Dtool_PyModuleClassInit_ShaderContext(module);
  PyModule_AddObject(module, "ShaderContext", (PyObject *)&Dtool_ShaderContext);
  // UserVertexSlider
  Dtool_PyModuleClassInit_UserVertexSlider(module);
  PyModule_AddObject(module, "UserVertexSlider", (PyObject *)&Dtool_UserVertexSlider);
  // UserVertexTransform
  Dtool_PyModuleClassInit_UserVertexTransform(module);
  PyModule_AddObject(module, "UserVertexTransform", (PyObject *)&Dtool_UserVertexTransform);
  // VideoTexture
  Dtool_PyModuleClassInit_VideoTexture(module);
  PyModule_AddObject(module, "VideoTexture", (PyObject *)&Dtool_VideoTexture);
  // VertexBufferContext
  Dtool_PyModuleClassInit_VertexBufferContext(module);
  PyModule_AddObject(module, "VertexBufferContext", (PyObject *)&Dtool_VertexBufferContext);
  // TextureCollection
  Dtool_PyModuleClassInit_TextureCollection(module);
  PyModule_AddObject(module, "TextureCollection", (PyObject *)&Dtool_TextureCollection);
  // TexturePool
  Dtool_PyModuleClassInit_TexturePool(module);
  PyModule_AddObject(module, "TexturePool", (PyObject *)&Dtool_TexturePool);
  // TexturePeeker
  Dtool_PyModuleClassInit_TexturePeeker(module);
  PyModule_AddObject(module, "TexturePeeker", (PyObject *)&Dtool_TexturePeeker);
  // TextureStagePool
  Dtool_PyModuleClassInit_TextureStagePool(module);
  PyModule_AddObject(module, "TextureStagePool", (PyObject *)&Dtool_TextureStagePool);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3gobj_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3gobj_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613183,  /* file_identifier */
  "libp3gobj",  /* library_name */
  "qQJq",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3gobj.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  3882  /* next_index */
};

Configure(_in_configure_libp3gobj);
ConfigureFn(_in_configure_libp3gobj) {
  interrogate_request_module(&_in_module_def);
}

