/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/nativenet -Ipanda/src/nativenet -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3nativenet_igate.cxx -od built/pandac/input/libp3nativenet.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/nativenet -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3nativenet buffered_datagramconnection.h buffered_datagramreader.h buffered_datagramwriter.h config_nativenet.h membuffer.h p3nativenet_composite1.cxx ringbuffer.h socket_address.h socket_base.h socket_fdset.h socket_ip.h socket_portable.h socket_selector.h socket_tcp.h socket_tcp_listen.h socket_udp.h socket_udp_incoming.h socket_udp_outgoing.h time_accumulator.h time_base.h time_clock.h time_general.h time_out.h time_span.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "buffered_datagramconnection.h"
#include "buffered_datagramreader.h"
#include "buffered_datagramwriter.h"
#include "config_nativenet.h"
#include "datagram.h"
#include "membuffer.h"
#include "pandabase.h"
#include "pvector.h"
#include "ringbuffer.h"
#include "socket_address.h"
#include "socket_base.h"
#include "socket_fdset.h"
#include "socket_ip.h"
#include "socket_portable.h"
#include "socket_selector.h"
#include "socket_tcp.h"
#include "socket_tcp_listen.h"
#include "socket_udp.h"
#include "socket_udp_incoming.h"
#include "socket_udp_outgoing.h"
#include "time_accumulator.h"
#include "time_base.h"
#include "time_clock.h"
#include "time_general.h"
#include "time_out.h"
#include "time_span.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class Socket_Address
 */
typedef Socket_Address Socket_Address_localtype;
Define_Module_Class(panda3d.core, Socket_Address, Socket_Address_localtype, Socket_Address);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_Address = &Dtool_Socket_Address;
static void Dtool_PyModuleClassInit_Socket_Address(PyObject *module);

/**
 * Forward declarations for top-level class Socket_IP
 */
typedef Socket_IP Socket_IP_localtype;
Define_Module_Class(panda3d.core, Socket_IP, Socket_IP_localtype, Socket_IP);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_IP = &Dtool_Socket_IP;
static void Dtool_PyModuleClassInit_Socket_IP(PyObject *module);
Socket_IP *Dtool_Coerce_Socket_IP(PyObject *args, Socket_IP &coerced);

/**
 * Forward declarations for top-level class Socket_TCP
 */
typedef Socket_TCP Socket_TCP_localtype;
Define_Module_Class(panda3d.core, Socket_TCP, Socket_TCP_localtype, Socket_TCP);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_TCP = &Dtool_Socket_TCP;
static void Dtool_PyModuleClassInit_Socket_TCP(PyObject *module);
Socket_TCP *Dtool_Coerce_Socket_TCP(PyObject *args, Socket_TCP &coerced);

/**
 * Forward declarations for top-level class Socket_TCP_Listen
 */
typedef Socket_TCP_Listen Socket_TCP_Listen_localtype;
Define_Module_Class(panda3d.core, Socket_TCP_Listen, Socket_TCP_Listen_localtype, Socket_TCP_Listen);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_TCP_Listen = &Dtool_Socket_TCP_Listen;
static void Dtool_PyModuleClassInit_Socket_TCP_Listen(PyObject *module);

/**
 * Forward declarations for top-level class Socket_UDP_Incoming
 */
typedef Socket_UDP_Incoming Socket_UDP_Incoming_localtype;
Define_Module_Class(panda3d.core, Socket_UDP_Incoming, Socket_UDP_Incoming_localtype, Socket_UDP_Incoming);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_UDP_Incoming = &Dtool_Socket_UDP_Incoming;
static void Dtool_PyModuleClassInit_Socket_UDP_Incoming(PyObject *module);

/**
 * Forward declarations for top-level class Socket_UDP_Outgoing
 */
typedef Socket_UDP_Outgoing Socket_UDP_Outgoing_localtype;
Define_Module_Class(panda3d.core, Socket_UDP_Outgoing, Socket_UDP_Outgoing_localtype, Socket_UDP_Outgoing);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_UDP_Outgoing = &Dtool_Socket_UDP_Outgoing;
static void Dtool_PyModuleClassInit_Socket_UDP_Outgoing(PyObject *module);

/**
 * Forward declarations for top-level class Socket_fdset
 */
typedef Socket_fdset Socket_fdset_localtype;
Define_Module_Class(panda3d.core, Socket_fdset, Socket_fdset_localtype, Socket_fdset);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_fdset = &Dtool_Socket_fdset;
static void Dtool_PyModuleClassInit_Socket_fdset(PyObject *module);

/**
 * Forward declarations for top-level class Buffered_DatagramConnection
 */
typedef Buffered_DatagramConnection Buffered_DatagramConnection_localtype;
Define_Module_Class(panda3d.core, Buffered_DatagramConnection, Buffered_DatagramConnection_localtype, Buffered_DatagramConnection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Buffered_DatagramConnection = &Dtool_Buffered_DatagramConnection;
static void Dtool_PyModuleClassInit_Buffered_DatagramConnection(PyObject *module);

/**
 * Forward declarations for top-level class Socket_UDP
 */
typedef Socket_UDP Socket_UDP_localtype;
Define_Module_Class(panda3d.core, Socket_UDP, Socket_UDP_localtype, Socket_UDP);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_UDP = &Dtool_Socket_UDP;
static void Dtool_PyModuleClassInit_Socket_UDP(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"Socket_Address", &Dtool_Socket_Address},
  {"Socket_IP", &Dtool_Socket_IP},
  {"Socket_TCP", &Dtool_Socket_TCP},
  {"Socket_TCP_Listen", &Dtool_Socket_TCP_Listen},
  {"Socket_UDP_Incoming", &Dtool_Socket_UDP_Incoming},
  {"Socket_UDP_Outgoing", &Dtool_Socket_UDP_Outgoing},
  {"Socket_fdset", &Dtool_Socket_fdset},
  {"Buffered_DatagramConnection", &Dtool_Buffered_DatagramConnection},
  {"Socket_UDP", &Dtool_Socket_UDP},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[0].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[1].type)
  {"Datagram", nullptr},
#define Dtool_Ptr_Datagram (imports[2].type)
  {nullptr, nullptr},
};
#endif

// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Datagram
#ifndef LINK_ALL_STATIC
inline static Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced) {
  nassertr(Dtool_Ptr_Datagram != nullptr, nullptr);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != nullptr, nullptr);
  return ((Datagram *(*)(PyObject *, Datagram &))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class Socket_Address
 */
/**
 * Python function wrapper for:
 * inline bool Socket_Address::set_any_IP(unsigned short int port)
 */
static PyObject *Dtool_Socket_Address_set_any_IP_4(PyObject *self, PyObject *arg) {
  Socket_Address *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.set_any_IP")) {
    return nullptr;
  }
  // 1-inline bool Socket_Address::set_any_IP(unsigned short int port)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    bool return_value = ((*local_this).set_any_IP)((unsigned short int)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_any_IP(const Socket_Address self, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_set_any_IP_4_comment =
  "C++ Interface:\n"
  "set_any_IP(const Socket_Address self, int port)\n"
  "\n"
  "/**\n"
  " * Set to any address and a specified port\n"
  " */";
#else
static const char *Dtool_Socket_Address_set_any_IP_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_Address::set_any_IPv6(unsigned short int port)
 */
static PyObject *Dtool_Socket_Address_set_any_IPv6_5(PyObject *self, PyObject *arg) {
  Socket_Address *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.set_any_IPv6")) {
    return nullptr;
  }
  // 1-inline bool Socket_Address::set_any_IPv6(unsigned short int port)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    bool return_value = ((*local_this).set_any_IPv6)((unsigned short int)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_any_IPv6(const Socket_Address self, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_set_any_IPv6_5_comment =
  "C++ Interface:\n"
  "set_any_IPv6(const Socket_Address self, int port)\n"
  "\n"
  "/**\n"
  " * Set to any IPv6 address and a specified port.\n"
  " */";
#else
static const char *Dtool_Socket_Address_set_any_IPv6_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_Address::set_port(unsigned short int port)
 */
static PyObject *Dtool_Socket_Address_set_port_6(PyObject *self, PyObject *arg) {
  Socket_Address *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.set_port")) {
    return nullptr;
  }
  // 1-inline bool Socket_Address::set_port(unsigned short int port)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    bool return_value = ((*local_this).set_port)((unsigned short int)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_port(const Socket_Address self, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_set_port_6_comment =
  "C++ Interface:\n"
  "set_port(const Socket_Address self, int port)\n"
  "\n"
  "/**\n"
  " * Set to a specified port\n"
  " */";
#else
static const char *Dtool_Socket_Address_set_port_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_Address::set_broadcast(unsigned short int port)
 */
static PyObject *Dtool_Socket_Address_set_broadcast_7(PyObject *self, PyObject *arg) {
  Socket_Address *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.set_broadcast")) {
    return nullptr;
  }
  // 1-inline bool Socket_Address::set_broadcast(unsigned short int port)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    bool return_value = ((*local_this).set_broadcast)((unsigned short int)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_broadcast(const Socket_Address self, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_set_broadcast_7_comment =
  "C++ Interface:\n"
  "set_broadcast(const Socket_Address self, int port)\n"
  "\n"
  "/**\n"
  " * Set to the broadcast address and a specified port\n"
  " */";
#else
static const char *Dtool_Socket_Address_set_broadcast_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Socket_Address::set_host(std::string const &hostname)
 * bool Socket_Address::set_host(std::string const &hostname, unsigned short int port)
 * inline bool Socket_Address::set_host(uint32_t ip4addr, unsigned short int port)
 */
static PyObject *Dtool_Socket_Address_set_host_8(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_Address *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.set_host")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "hostname")) {
        // 1-bool Socket_Address::set_host(std::string const &hostname)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          bool return_value = ((*local_this).set_host)(std::string(param1_str, param1_len));
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
  case 2:
    {
      {
        // -2 bool Socket_Address::set_host(std::string const &hostname, unsigned short int port)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        long param2;
        static const char *keyword_list[] = {"hostname", "port", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#l:set_host", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
#ifndef NDEBUG
          if (param2 < 0 || param2 > USHRT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for unsigned short integer",
                                param2);
          }
#endif
          bool return_value = ((*local_this).set_host)(std::string(param1_str, param1_len), (unsigned short int)param2);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool Socket_Address::set_host(uint32_t ip4addr, unsigned short int port)
        unsigned long param1;
        long param2;
        static const char *keyword_list[] = {"ip4addr", "port", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "kl:set_host", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (param1 > UINT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %lu out of range for unsigned integer",
                                param1);
          }
#endif
#ifndef NDEBUG
          if (param2 < 0 || param2 > USHRT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for unsigned short integer",
                                param2);
          }
#endif
          bool return_value = ((*local_this).set_host)((uint32_t)param1, (unsigned short int)param2);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      // No coercion possible: bool Socket_Address::set_host(std::string const &hostname, unsigned short int port)
      // No coercion possible: inline bool Socket_Address::set_host(uint32_t ip4addr, unsigned short int port)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_host() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_host(const Socket_Address self, str hostname)\n"
      "set_host(const Socket_Address self, str hostname, int port)\n"
      "set_host(const Socket_Address self, int ip4addr, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_set_host_8_comment =
  "C++ Interface:\n"
  "set_host(const Socket_Address self, str hostname)\n"
  "set_host(const Socket_Address self, str hostname, int port)\n"
  "set_host(const Socket_Address self, int ip4addr, int port)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " * This function will take a port and string-based TCP address and initialize\n"
  " * the address with this information.  Returns true on success; on failure, it\n"
  " * returns false and the address may be undefined.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Initializes the address from a string specifying both the address and port,\n"
  " * separated by a colon.  An IPv6 address must be enclosed in brackets.\n"
  " */";
#else
static const char *Dtool_Socket_Address_set_host_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Socket_Address::clear(void)
 */
static PyObject *Dtool_Socket_Address_clear_9(PyObject *self, PyObject *) {
  Socket_Address *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.clear")) {
    return nullptr;
  }
  // 1-inline void Socket_Address::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_clear_9_comment =
  "C++ Interface:\n"
  "clear(const Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Set the internal values to a suitable known value\n"
  " */";
#else
static const char *Dtool_Socket_Address_clear_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline sa_family_t Socket_Address::get_family(void) const
 */
static PyObject *Dtool_Socket_Address_get_family_10(PyObject *self, PyObject *) {
  Socket_Address *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Socket_Address)) {
    return nullptr;
  }
  // 1-inline sa_family_t Socket_Address::get_family(void) const
  sa_family_t return_value = ((*(const Socket_Address*)local_this).get_family)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_get_family_10_comment =
  "C++ Interface:\n"
  "get_family(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Returns AF_INET if this is an IPv4 address, or AF_INET6 if this is an IPv6\n"
  " * address.\n"
  " */";
#else
static const char *Dtool_Socket_Address_get_family_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned short int Socket_Address::get_port(void) const
 */
static PyObject *Dtool_Socket_Address_get_port_11(PyObject *self, PyObject *) {
  Socket_Address *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Socket_Address)) {
    return nullptr;
  }
  // 1-inline unsigned short int Socket_Address::get_port(void) const
  unsigned short int return_value = ((*(const Socket_Address*)local_this).get_port)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_get_port_11_comment =
  "C++ Interface:\n"
  "get_port(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Get the port portion as an integer\n"
  " */";
#else
static const char *Dtool_Socket_Address_get_port_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Socket_Address::get_ip(void) const
 */
static PyObject *Dtool_Socket_Address_get_ip_12(PyObject *self, PyObject *) {
  Socket_Address *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Socket_Address)) {
    return nullptr;
  }
  // 1-std::string Socket_Address::get_ip(void) const
  std::string return_value = ((*(const Socket_Address*)local_this).get_ip)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_get_ip_12_comment =
  "C++ Interface:\n"
  "get_ip(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Return the IP address portion in dot notation string.\n"
  " */";
#else
static const char *Dtool_Socket_Address_get_ip_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Socket_Address::get_ip_port(void) const
 */
static PyObject *Dtool_Socket_Address_get_ip_port_13(PyObject *self, PyObject *) {
  Socket_Address *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Socket_Address)) {
    return nullptr;
  }
  // 1-std::string Socket_Address::get_ip_port(void) const
  std::string return_value = ((*(const Socket_Address*)local_this).get_ip_port)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_get_ip_port_13_comment =
  "C++ Interface:\n"
  "get_ip_port(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Return the ip address/port in dot notation string.  If this is an IPv6\n"
  " * address, it will be enclosed in square brackets.\n"
  " */";
#else
static const char *Dtool_Socket_Address_get_ip_port_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * unsigned long int Socket_Address::GetIPAddressRaw(void) const
 */
static PyObject *Dtool_Socket_Address_GetIPAddressRaw_14(PyObject *self, PyObject *) {
  Socket_Address *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Socket_Address)) {
    return nullptr;
  }
  // 1-unsigned long int Socket_Address::GetIPAddressRaw(void) const
  unsigned long int return_value = ((*(const Socket_Address*)local_this).GetIPAddressRaw)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_GetIPAddressRaw_14_comment =
  "C++ Interface:\n"
  "GetIPAddressRaw(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Returns a raw 32-bit unsigned integer representing the IPv4 address.\n"
  " * @deprecated  Does not work with IPv6 addresses.\n"
  " */";
#else
static const char *Dtool_Socket_Address_GetIPAddressRaw_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_Address::is_any(void) const
 */
static PyObject *Dtool_Socket_Address_is_any_18(PyObject *self, PyObject *) {
  Socket_Address *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Socket_Address)) {
    return nullptr;
  }
  // 1-inline bool Socket_Address::is_any(void) const
  bool return_value = ((*(const Socket_Address*)local_this).is_any)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_is_any_18_comment =
  "C++ Interface:\n"
  "is_any(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * True if the address is zero.\n"
  " */";
#else
static const char *Dtool_Socket_Address_is_any_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_Address::is_mcast_range(void) const
 */
static PyObject *Dtool_Socket_Address_is_mcast_range_19(PyObject *self, PyObject *) {
  Socket_Address *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Socket_Address)) {
    return nullptr;
  }
  // 1-inline bool Socket_Address::is_mcast_range(void) const
  bool return_value = ((*(const Socket_Address*)local_this).is_mcast_range)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_is_mcast_range_19_comment =
  "C++ Interface:\n"
  "is_mcast_range(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * True if the address is in the multicast range.\n"
  " */";
#else
static const char *Dtool_Socket_Address_is_mcast_range_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Socket_Address::Socket_Address(Socket_Address const &inaddr)
 * inline explicit Socket_Address::Socket_Address(unsigned short int port = 0)
 */
static int Dtool_Init_Socket_Address(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit Socket_Address::Socket_Address(unsigned short int port)
      Socket_Address *return_value = new Socket_Address();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_Address, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Socket_Address::Socket_Address(Socket_Address const &inaddr)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "inaddr")) {
          Socket_Address const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Socket_Address);
          if (param0_this != nullptr) {
            Socket_Address *return_value = new Socket_Address(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_Address, true, false);
          }
        }
      }

      {
        // -2 inline explicit Socket_Address::Socket_Address(unsigned short int port)
        long param0;
        static const char *keyword_list[] = {"port", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "l:Socket_Address", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return -1;
          }
#endif
          Socket_Address *return_value = new Socket_Address((unsigned short int)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_Address, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline Socket_Address::Socket_Address(Socket_Address const &inaddr)
      // No coercion possible: inline explicit Socket_Address::Socket_Address(unsigned short int port)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_Address() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_Address()\n"
      "Socket_Address(const Socket_Address inaddr)\n"
      "Socket_Address(int port)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Socket_Address(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Socket_Address) {
    printf("Socket_Address ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Socket_Address *local_this = (Socket_Address *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Socket_Address) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Socket_Address(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Socket_Address) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Socket_IP
 */
/**
 * Python function wrapper for:
 * inline void Socket_IP::Close(void)
 */
static PyObject *Dtool_Socket_IP_Close_23(PyObject *self, PyObject *) {
  Socket_IP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.Close")) {
    return nullptr;
  }
  // 1-inline void Socket_IP::Close(void)
  ((*local_this).Close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_Close_23_comment =
  "C++ Interface:\n"
  "Close(const Socket_IP self)\n"
  "\n"
  "/**\n"
  " * Closes a socket if it is open (allocated).\n"
  " */";
#else
static const char *Dtool_Socket_IP_Close_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int Socket_IP::GetLastError(void)
 */
static PyObject *Dtool_Socket_IP_GetLastError_24(PyObject *, PyObject *) {
  // 1-static inline int Socket_IP::GetLastError(void)
  int return_value = (Socket_IP::GetLastError)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_GetLastError_24_comment =
  "C++ Interface:\n"
  "GetLastError()\n"
  "\n"
  "/**\n"
  " * Gets the last errcode from a socket operation.\n"
  " */";
#else
static const char *Dtool_Socket_IP_GetLastError_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_IP::SetNonBlocking(void)
 */
static PyObject *Dtool_Socket_IP_SetNonBlocking_25(PyObject *self, PyObject *) {
  Socket_IP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetNonBlocking")) {
    return nullptr;
  }
  // 1-inline int Socket_IP::SetNonBlocking(void)
  int return_value = ((*local_this).SetNonBlocking)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetNonBlocking_25_comment =
  "C++ Interface:\n"
  "SetNonBlocking(const Socket_IP self)\n"
  "\n"
  "/**\n"
  " * this function will throw a socket into non-blocking mode\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetNonBlocking_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_IP::SetBlocking(void)
 */
static PyObject *Dtool_Socket_IP_SetBlocking_26(PyObject *self, PyObject *) {
  Socket_IP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetBlocking")) {
    return nullptr;
  }
  // 1-inline int Socket_IP::SetBlocking(void)
  int return_value = ((*local_this).SetBlocking)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetBlocking_26_comment =
  "C++ Interface:\n"
  "SetBlocking(const Socket_IP self)\n"
  "\n"
  "/**\n"
  " * Set the socket to block on subsequent calls to socket functions that\n"
  " * address this socket\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetBlocking_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_IP::SetReuseAddress(bool flag = true)
 */
static PyObject *Dtool_Socket_IP_SetReuseAddress_27(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_IP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetReuseAddress")) {
    return nullptr;
  }
  // 1-inline bool Socket_IP::SetReuseAddress(bool flag = true)
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "flag")) {
    bool return_value = ((*local_this).SetReuseAddress)((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetReuseAddress(const Socket_IP self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetReuseAddress_27_comment =
  "C++ Interface:\n"
  "SetReuseAddress(const Socket_IP self, bool flag)\n"
  "\n"
  "/**\n"
  " * Informs a socket to reuse IP address as needed\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetReuseAddress_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_IP::SetV6Only(bool flag)
 */
static PyObject *Dtool_Socket_IP_SetV6Only_28(PyObject *self, PyObject *arg) {
  Socket_IP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetV6Only")) {
    return nullptr;
  }
  // 1-inline bool Socket_IP::SetV6Only(bool flag)
  bool return_value = ((*local_this).SetV6Only)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetV6Only(const Socket_IP self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetV6Only_28_comment =
  "C++ Interface:\n"
  "SetV6Only(const Socket_IP self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets a flag indicating whether this IPv6 socket should operate in\n"
  " * dual-stack mode or not.\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetV6Only_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_IP::Active(void)
 */
static PyObject *Dtool_Socket_IP_Active_29(PyObject *self, PyObject *) {
  Socket_IP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.Active")) {
    return nullptr;
  }
  // 1-inline bool Socket_IP::Active(void)
  bool return_value = ((*local_this).Active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_Active_29_comment =
  "C++ Interface:\n"
  "Active(const Socket_IP self)\n"
  "\n"
  "/**\n"
  " * Ask if the socket is open (allocated)\n"
  " */";
#else
static const char *Dtool_Socket_IP_Active_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_IP::SetRecvBufferSize(int size)
 */
static PyObject *Dtool_Socket_IP_SetRecvBufferSize_30(PyObject *self, PyObject *arg) {
  Socket_IP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetRecvBufferSize")) {
    return nullptr;
  }
  // 1-inline int Socket_IP::SetRecvBufferSize(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).SetRecvBufferSize)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetRecvBufferSize(const Socket_IP self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetRecvBufferSize_30_comment =
  "C++ Interface:\n"
  "SetRecvBufferSize(const Socket_IP self, int size)\n"
  "\n"
  "/**\n"
  " * Ok it sets the recv buffer size for both tcp and UDP\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetRecvBufferSize_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Socket_IP::SetSocket(SOCKET ins)
 */
static PyObject *Dtool_Socket_IP_SetSocket_31(PyObject *self, PyObject *arg) {
  Socket_IP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetSocket")) {
    return nullptr;
  }
  // 1-inline void Socket_IP::SetSocket(SOCKET ins)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    ((*local_this).SetSocket)((SOCKET)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetSocket(const Socket_IP self, int ins)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetSocket_31_comment =
  "C++ Interface:\n"
  "SetSocket(const Socket_IP self, int ins)\n"
  "\n"
  "/**\n"
  " * Assigns an existing socket to this class\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetSocket_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SOCKET Socket_IP::GetSocket(void)
 * inline SOCKET Socket_IP::GetSocket(void) const
 */
static PyObject *Dtool_Socket_IP_GetSocket_32(PyObject *self, PyObject *) {
  Socket_IP *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Socket_IP)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 inline SOCKET Socket_IP::GetSocket(void)
    SOCKET return_value = ((*local_this).GetSocket)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }

  {
    // -2 inline SOCKET Socket_IP::GetSocket(void) const
    SOCKET return_value = ((*(const Socket_IP*)local_this).GetSocket)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }

  // No coercion possible: inline SOCKET Socket_IP::GetSocket(void)
  // No coercion possible: inline SOCKET Socket_IP::GetSocket(void) const
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_GetSocket_32_comment =
  "C++ Interface:\n"
  "GetSocket(const Socket_IP self)\n"
  "GetSocket(Socket_IP self)\n"
  "\n"
  "/**\n"
  " * Gets the base socket type\n"
  " */\n"
  "\n"
  "/**\n"
  " * Get The RAW file id of the socket\n"
  " */";
#else
static const char *Dtool_Socket_IP_GetSocket_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Socket_Address Socket_IP::GetPeerName(void) const
 */
static PyObject *Dtool_Socket_IP_GetPeerName_33(PyObject *self, PyObject *) {
  Socket_IP *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Socket_IP)) {
    return nullptr;
  }
  // 1-inline Socket_Address Socket_IP::GetPeerName(void) const
  Socket_Address *return_value = new Socket_Address(((*(const Socket_IP*)local_this).GetPeerName)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Socket_Address, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_GetPeerName_33_comment =
  "C++ Interface:\n"
  "GetPeerName(Socket_IP self)\n"
  "\n"
  "/**\n"
  " * Wrapper on berkly getpeername...\n"
  " */";
#else
static const char *Dtool_Socket_IP_GetPeerName_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int Socket_IP::InitNetworkDriver(void)
 */
static PyObject *Dtool_Socket_IP_InitNetworkDriver_34(PyObject *, PyObject *) {
  // 1-static inline int Socket_IP::InitNetworkDriver(void)
  int return_value = (Socket_IP::InitNetworkDriver)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_InitNetworkDriver_34_comment =
  "C++ Interface:\n"
  "InitNetworkDriver()\n";
#else
static const char *Dtool_Socket_IP_InitNetworkDriver_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_IP::get_class_type(void)
 */
static PyObject *Dtool_Socket_IP_get_class_type_35(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_IP::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Socket_IP::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_get_class_type_35_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_IP_get_class_type_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Socket_IP::Socket_IP(void)
 * inline Socket_IP::Socket_IP(SOCKET in)
 */
static int Dtool_Init_Socket_IP(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Socket_IP::Socket_IP(void)
      Socket_IP *return_value = new Socket_IP();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_IP, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "in")) {
        // 1-inline Socket_IP::Socket_IP(SOCKET in)
        if (PyLongOrInt_Check(arg)) {
          unsigned long param0 = PyLong_AsUnsignedLong(arg);
          Socket_IP *return_value = new Socket_IP((SOCKET)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_IP, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_IP() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_IP()\n"
      "Socket_IP(int in)\n");
  }
  return -1;
}

Socket_IP *Dtool_Coerce_Socket_IP(PyObject *args, Socket_IP &coerced) {
  Socket_IP *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_Socket_IP)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const Socket_IP *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Socket_IP::Socket_IP(SOCKET in)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
      coerced = Socket_IP((SOCKET)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_Socket_IP(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Socket_IP) {
    printf("Socket_IP ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Socket_IP *local_this = (Socket_IP *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Socket_IP) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Socket_IP(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_IP*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Socket_TCP
 */
/**
 * Python function wrapper for:
 * inline int Socket_TCP::SetNoDelay(bool flag = true)
 */
static PyObject *Dtool_Socket_TCP_SetNoDelay_38(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_TCP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.SetNoDelay")) {
    return nullptr;
  }
  // 1-inline int Socket_TCP::SetNoDelay(bool flag = true)
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "flag")) {
    int return_value = ((*local_this).SetNoDelay)((PyObject_IsTrue(param1) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetNoDelay(const Socket_TCP self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_SetNoDelay_38_comment =
  "C++ Interface:\n"
  "SetNoDelay(const Socket_TCP self, bool flag)\n"
  "\n"
  "/**\n"
  " * Disable Nagle algorithm.  Don't delay send to coalesce packets\n"
  " */";
#else
static const char *Dtool_Socket_TCP_SetNoDelay_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_TCP::SetLinger(int interval_seconds = 0)
 */
static PyObject *Dtool_Socket_TCP_SetLinger_39(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_TCP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.SetLinger")) {
    return nullptr;
  }
  // 1-inline int Socket_TCP::SetLinger(int interval_seconds = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"interval_seconds", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:SetLinger", (char **)keyword_list, &param1)) {
    int return_value = ((*local_this).SetLinger)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetLinger(const Socket_TCP self, int interval_seconds)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_SetLinger_39_comment =
  "C++ Interface:\n"
  "SetLinger(const Socket_TCP self, int interval_seconds)\n"
  "\n"
  "/**\n"
  " * will control the behavior of SO_LINGER for a TCP socket\n"
  " */";
#else
static const char *Dtool_Socket_TCP_SetLinger_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_TCP::DontLinger(void)
 */
static PyObject *Dtool_Socket_TCP_DontLinger_40(PyObject *self, PyObject *) {
  Socket_TCP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.DontLinger")) {
    return nullptr;
  }
  // 1-inline int Socket_TCP::DontLinger(void)
  int return_value = ((*local_this).DontLinger)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_DontLinger_40_comment =
  "C++ Interface:\n"
  "DontLinger(const Socket_TCP self)\n"
  "\n"
  "/**\n"
  " * Turn off the linger flag.  The socket will quickly release buffered items\n"
  " * and free up OS resources.  You may lose a stream if you use this flag and\n"
  " * do not negotiate the close at the application layer.\n"
  " */";
#else
static const char *Dtool_Socket_TCP_DontLinger_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_TCP::SetSendBufferSize(int insize)
 */
static PyObject *Dtool_Socket_TCP_SetSendBufferSize_41(PyObject *self, PyObject *arg) {
  Socket_TCP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.SetSendBufferSize")) {
    return nullptr;
  }
  // 1-inline int Socket_TCP::SetSendBufferSize(int insize)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).SetSendBufferSize)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetSendBufferSize(const Socket_TCP self, int insize)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_SetSendBufferSize_41_comment =
  "C++ Interface:\n"
  "SetSendBufferSize(const Socket_TCP self, int insize)\n"
  "\n"
  "/**\n"
  " * Just like it sounds.  Sets a buffered socket recv buffer size.  This\n"
  " * function does not refuse ranges outside hard-coded OS limits\n"
  " */";
#else
static const char *Dtool_Socket_TCP_SetSendBufferSize_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_TCP::ActiveOpen(Socket_Address const &theaddress, bool setdelay)
 */
static PyObject *Dtool_Socket_TCP_ActiveOpen_42(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_TCP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.ActiveOpen")) {
    return nullptr;
  }
  // 1-inline bool Socket_TCP::ActiveOpen(Socket_Address const &theaddress, bool setdelay)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"theaddress", "setdelay", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:ActiveOpen", (char **)keyword_list, &param1, &param2)) {
    Socket_Address const *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Socket_Address, 1, "Socket_TCP.ActiveOpen", true, true);
    if (param1_this != nullptr) {
      bool return_value = ((*local_this).ActiveOpen)(*param1_this, (PyObject_IsTrue(param2) != 0));
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ActiveOpen(const Socket_TCP self, const Socket_Address theaddress, bool setdelay)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_ActiveOpen_42_comment =
  "C++ Interface:\n"
  "ActiveOpen(const Socket_TCP self, const Socket_Address theaddress, bool setdelay)\n"
  "\n"
  "// inline bool ActiveOpen(const Socket_Address &theaddress);\n"
  "\n"
  "/**\n"
  " * This function will try and set the socket up for active open to a specified\n"
  " * address and port provided by the input parameter\n"
  " */";
#else
static const char *Dtool_Socket_TCP_ActiveOpen_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_TCP::ActiveOpenNonBlocking(Socket_Address const &theaddress)
 */
static PyObject *Dtool_Socket_TCP_ActiveOpenNonBlocking_43(PyObject *self, PyObject *arg) {
  Socket_TCP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.ActiveOpenNonBlocking")) {
    return nullptr;
  }
  // 1-inline bool Socket_TCP::ActiveOpenNonBlocking(Socket_Address const &theaddress)
  Socket_Address const *arg_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Socket_Address, 1, "Socket_TCP.ActiveOpenNonBlocking", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).ActiveOpenNonBlocking)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ActiveOpenNonBlocking(const Socket_TCP self, const Socket_Address theaddress)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_ActiveOpenNonBlocking_43_comment =
  "C++ Interface:\n"
  "ActiveOpenNonBlocking(const Socket_TCP self, const Socket_Address theaddress)\n"
  "\n"
  "/**\n"
  " * This function will try and set the socket up for active open to a specified\n"
  " * address and port provided by the input parameter (non-blocking version)\n"
  " */";
#else
static const char *Dtool_Socket_TCP_ActiveOpenNonBlocking_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_TCP::ErrorIs_WouldBlocking(int err)
 */
static PyObject *Dtool_Socket_TCP_ErrorIs_WouldBlocking_44(PyObject *self, PyObject *arg) {
  Socket_TCP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.ErrorIs_WouldBlocking")) {
    return nullptr;
  }
  // 1-inline bool Socket_TCP::ErrorIs_WouldBlocking(int err)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).ErrorIs_WouldBlocking)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ErrorIs_WouldBlocking(const Socket_TCP self, int err)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_ErrorIs_WouldBlocking_44_comment =
  "C++ Interface:\n"
  "ErrorIs_WouldBlocking(const Socket_TCP self, int err)\n";
#else
static const char *Dtool_Socket_TCP_ErrorIs_WouldBlocking_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_TCP::ShutdownSend(void)
 */
static PyObject *Dtool_Socket_TCP_ShutdownSend_45(PyObject *self, PyObject *) {
  Socket_TCP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.ShutdownSend")) {
    return nullptr;
  }
  // 1-inline bool Socket_TCP::ShutdownSend(void)
  bool return_value = ((*local_this).ShutdownSend)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_ShutdownSend_45_comment =
  "C++ Interface:\n"
  "ShutdownSend(const Socket_TCP self)\n";
#else
static const char *Dtool_Socket_TCP_ShutdownSend_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_TCP::SendData(vector_uchar const &data)
 */
static PyObject *Dtool_Socket_TCP_SendData_46(PyObject *self, PyObject *arg) {
  Socket_TCP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.SendData")) {
    return nullptr;
  }
  // 1-inline int Socket_TCP::SendData(vector_uchar const &data)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    int return_value = ((*local_this).SendData)(vector_uchar(param1_str, param1_str + param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SendData(const Socket_TCP self, bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_SendData_46_comment =
  "C++ Interface:\n"
  "SendData(const Socket_TCP self, bytes data)\n"
  "\n"
  "/**\n"
  " * Ok Lets Send the Data - if error 0 if socket closed for write or lengh is 0\n"
  " * + bytes writen ( May be smaller than requested)\n"
  " */";
#else
static const char *Dtool_Socket_TCP_SendData_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Socket_TCP::RecvData(int max_len)
 */
static PyObject *Dtool_Socket_TCP_RecvData_47(PyObject *self, PyObject *arg) {
  Socket_TCP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.RecvData")) {
    return nullptr;
  }
  // 1-std::string Socket_TCP::RecvData(int max_len)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*local_this).RecvData)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "RecvData(const Socket_TCP self, int max_len)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_RecvData_47_comment =
  "C++ Interface:\n"
  "RecvData(const Socket_TCP self, int max_len)\n"
  "\n"
  "/**\n"
  " * Read the data from the connection - if error 0 if socket closed for read or\n"
  " * length is 0 + bytes read ( May be smaller than requested)\n"
  " */\n"
  "\n"
  "/**\n"
  " * Read the data from the connection - if error 0 if socket closed for read or\n"
  " * length is 0 + bytes read (May be smaller than requested)\n"
  " */";
#else
static const char *Dtool_Socket_TCP_RecvData_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_TCP::get_class_type(void)
 */
static PyObject *Dtool_Socket_TCP_get_class_type_48(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_TCP::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Socket_TCP::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_get_class_type_48_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_TCP_get_class_type_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Socket_TCP::Socket_TCP(void)
 * inline Socket_TCP::Socket_TCP(SOCKET )
 */
static int Dtool_Init_Socket_TCP(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Socket_TCP() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Socket_TCP::Socket_TCP(void)
      Socket_TCP *return_value = new Socket_TCP();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_TCP, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline Socket_TCP::Socket_TCP(SOCKET )
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        Socket_TCP *return_value = new Socket_TCP((SOCKET)param0);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_TCP, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_TCP() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_TCP()\n"
      "Socket_TCP(int param0)\n");
  }
  return -1;
}

Socket_TCP *Dtool_Coerce_Socket_TCP(PyObject *args, Socket_TCP &coerced) {
  Socket_TCP *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_Socket_TCP)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const Socket_TCP *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Socket_TCP::Socket_TCP(SOCKET )
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
      coerced = Socket_TCP((SOCKET)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_Socket_TCP(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Socket_TCP) {
    printf("Socket_TCP ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Socket_TCP *local_this = (Socket_TCP *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Socket_TCP) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Socket_TCP(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Socket_TCP) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Socket_TCP*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_TCP*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Socket_TCP_Listen
 */
/**
 * Python function wrapper for:
 * inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &address, int backlog_size = 1024)
 * inline bool Socket_TCP_Listen::OpenForListen(unsigned short int port, int backlog_size = 1024)
 */
static PyObject *Dtool_Socket_TCP_Listen_OpenForListen_52(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_TCP_Listen *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP_Listen, (void **)&local_this, "Socket_TCP_Listen.OpenForListen")) {
    return nullptr;
  }
  {
    // -2 inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &address, int backlog_size = 1024)
    PyObject *param1;
    int param2 = 1024;
    static const char *keyword_list[] = {"address", "backlog_size", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:OpenForListen", (char **)keyword_list, &param1, &param2)) {
      Socket_Address const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Socket_Address);
      if (param1_this != nullptr) {
        bool return_value = ((*local_this).OpenForListen)(*param1_this, (int)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Socket_TCP_Listen::OpenForListen(unsigned short int port, int backlog_size = 1024)
    long param1;
    int param2 = 1024;
    static const char *keyword_list[] = {"port", "backlog_size", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "l|i:OpenForListen", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
      if (param1 < 0 || param1 > USHRT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned short integer",
                            param1);
      }
#endif
      bool return_value = ((*local_this).OpenForListen)((unsigned short int)param1, (int)param2);
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &address, int backlog_size = 1024)
  // No coercion possible: inline bool Socket_TCP_Listen::OpenForListen(unsigned short int port, int backlog_size = 1024)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "OpenForListen(const Socket_TCP_Listen self, const Socket_Address address, int backlog_size)\n"
      "OpenForListen(const Socket_TCP_Listen self, int port, int backlog_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_Listen_OpenForListen_52_comment =
  "C++ Interface:\n"
  "OpenForListen(const Socket_TCP_Listen self, const Socket_Address address, int backlog_size)\n"
  "OpenForListen(const Socket_TCP_Listen self, int port, int backlog_size)\n"
  "\n"
  "/**\n"
  " * This function will initialize a listening Socket\n"
  " */\n"
  "\n"
  "/**\n"
  " * This function will initialize a listening Socket\n"
  " */";
#else
static const char *Dtool_Socket_TCP_Listen_OpenForListen_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_TCP_Listen::GetIncomingConnection(Socket_TCP &newsession, Socket_Address &address)
 */
static PyObject *Dtool_Socket_TCP_Listen_GetIncomingConnection_53(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_TCP_Listen *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP_Listen, (void **)&local_this, "Socket_TCP_Listen.GetIncomingConnection")) {
    return nullptr;
  }
  // 1-inline bool Socket_TCP_Listen::GetIncomingConnection(Socket_TCP &newsession, Socket_Address &address)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"newsession", "address", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:GetIncomingConnection", (char **)keyword_list, &param1, &param2)) {
    Socket_TCP param1_local;
    Socket_TCP *param1_this = Dtool_Coerce_Socket_TCP(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Socket_TCP_Listen.GetIncomingConnection", "Socket_TCP");
    }
    Socket_Address *param2_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Socket_Address, 2, "Socket_TCP_Listen.GetIncomingConnection", false, true);
    if (param2_this != nullptr) {
      bool return_value = ((*local_this).GetIncomingConnection)(*param1_this, *param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetIncomingConnection(const Socket_TCP_Listen self, Socket_TCP newsession, Socket_Address address)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_Listen_GetIncomingConnection_53_comment =
  "C++ Interface:\n"
  "GetIncomingConnection(const Socket_TCP_Listen self, Socket_TCP newsession, Socket_Address address)\n"
  "\n"
  "/**\n"
  " * This function is used to accept new connections\n"
  " */";
#else
static const char *Dtool_Socket_TCP_Listen_GetIncomingConnection_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_TCP_Listen::get_class_type(void)
 */
static PyObject *Dtool_Socket_TCP_Listen_get_class_type_54(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_TCP_Listen::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Socket_TCP_Listen::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_Listen_get_class_type_54_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_TCP_Listen_get_class_type_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Socket_TCP_Listen::Socket_TCP_Listen(void)
 */
static int Dtool_Init_Socket_TCP_Listen(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Socket_TCP_Listen() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Socket_TCP_Listen() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-Socket_TCP_Listen::Socket_TCP_Listen(void)
  Socket_TCP_Listen *return_value = new Socket_TCP_Listen();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_TCP_Listen, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_TCP_Listen()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Socket_TCP_Listen(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Socket_TCP_Listen) {
    printf("Socket_TCP_Listen ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Socket_TCP_Listen *local_this = (Socket_TCP_Listen *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Socket_TCP_Listen) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Socket_TCP_Listen(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Socket_TCP_Listen) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Socket_TCP_Listen*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_TCP_Listen*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Socket_UDP_Incoming
 */
/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Incoming::OpenForInput(Socket_Address const &address)
 * inline bool Socket_UDP_Incoming::OpenForInput(unsigned short int port)
 */
static PyObject *Dtool_Socket_UDP_Incoming_OpenForInput_57(PyObject *self, PyObject *arg) {
  Socket_UDP_Incoming *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Incoming, (void **)&local_this, "Socket_UDP_Incoming.OpenForInput")) {
    return nullptr;
  }
  {
    // -2 inline bool Socket_UDP_Incoming::OpenForInput(Socket_Address const &address)
    Socket_Address const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Socket_Address);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).OpenForInput)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool Socket_UDP_Incoming::OpenForInput(unsigned short int port)
    if (PyLongOrInt_Check(arg)) {
      long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param1 < 0 || param1 > USHRT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned short integer",
                            param1);
      }
#endif
      bool return_value = ((*local_this).OpenForInput)((unsigned short int)param1);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: inline bool Socket_UDP_Incoming::OpenForInput(Socket_Address const &address)
  // No coercion possible: inline bool Socket_UDP_Incoming::OpenForInput(unsigned short int port)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "OpenForInput(const Socket_UDP_Incoming self, const Socket_Address address)\n"
      "OpenForInput(const Socket_UDP_Incoming self, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_OpenForInput_57_comment =
  "C++ Interface:\n"
  "OpenForInput(const Socket_UDP_Incoming self, const Socket_Address address)\n"
  "OpenForInput(const Socket_UDP_Incoming self, int port)\n"
  "\n"
  "/**\n"
  " * Starts a UDP socket listening on a port\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts a UDP socket listening on a port\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Incoming_OpenForInput_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Incoming::OpenForInputMCast(Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_Incoming_OpenForInputMCast_58(PyObject *self, PyObject *arg) {
  Socket_UDP_Incoming *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Incoming, (void **)&local_this, "Socket_UDP_Incoming.OpenForInputMCast")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP_Incoming::OpenForInputMCast(Socket_Address const &address)
  Socket_Address const *arg_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Socket_Address, 1, "Socket_UDP_Incoming.OpenForInputMCast", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).OpenForInputMCast)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "OpenForInputMCast(const Socket_UDP_Incoming self, const Socket_Address address)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_OpenForInputMCast_58_comment =
  "C++ Interface:\n"
  "OpenForInputMCast(const Socket_UDP_Incoming self, const Socket_Address address)\n"
  "\n"
  "/**\n"
  " * Starts a UDP socket listening on a port\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Incoming_OpenForInputMCast_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Incoming::SendTo(char const *data, int len, Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_Incoming_SendTo_60(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_UDP_Incoming *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Incoming, (void **)&local_this, "Socket_UDP_Incoming.SendTo")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP_Incoming::SendTo(char const *data, int len, Socket_Address const &address)
  char const *param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"data", "len", "address", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ziO:SendTo", (char **)keyword_list, &param1, &param2, &param3)) {
    Socket_Address const *param3_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Socket_Address, 3, "Socket_UDP_Incoming.SendTo", true, true);
    if (param3_this != nullptr) {
      bool return_value = ((*local_this).SendTo)((char const *)param1, (int)param2, *param3_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SendTo(const Socket_UDP_Incoming self, str data, int len, const Socket_Address address)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_SendTo_60_comment =
  "C++ Interface:\n"
  "SendTo(const Socket_UDP_Incoming self, str data, int len, const Socket_Address address)\n"
  "\n"
  "/**\n"
  " * Send data to specified address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Incoming_SendTo_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Incoming::InitNoAddress(void)
 */
static PyObject *Dtool_Socket_UDP_Incoming_InitNoAddress_61(PyObject *self, PyObject *) {
  Socket_UDP_Incoming *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Incoming, (void **)&local_this, "Socket_UDP_Incoming.InitNoAddress")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP_Incoming::InitNoAddress(void)
  bool return_value = ((*local_this).InitNoAddress)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_InitNoAddress_61_comment =
  "C++ Interface:\n"
  "InitNoAddress(const Socket_UDP_Incoming self)\n"
  "\n"
  "/**\n"
  " * Set this socket to work without a bound external address.\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Incoming_InitNoAddress_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Incoming::SetToBroadCast(void)
 */
static PyObject *Dtool_Socket_UDP_Incoming_SetToBroadCast_62(PyObject *self, PyObject *) {
  Socket_UDP_Incoming *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Incoming, (void **)&local_this, "Socket_UDP_Incoming.SetToBroadCast")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP_Incoming::SetToBroadCast(void)
  bool return_value = ((*local_this).SetToBroadCast)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_SetToBroadCast_62_comment =
  "C++ Interface:\n"
  "SetToBroadCast(const Socket_UDP_Incoming self)\n"
  "\n"
  "/**\n"
  " * Flips the OS bits that allow for brodcast packets to come in on this port.\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Incoming_SetToBroadCast_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_UDP_Incoming::get_class_type(void)
 */
static PyObject *Dtool_Socket_UDP_Incoming_get_class_type_63(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_UDP_Incoming::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Socket_UDP_Incoming::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_get_class_type_63_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_UDP_Incoming_get_class_type_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Socket_UDP_Incoming::Socket_UDP_Incoming(void)
 */
static int Dtool_Init_Socket_UDP_Incoming(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Socket_UDP_Incoming() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Socket_UDP_Incoming() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline Socket_UDP_Incoming::Socket_UDP_Incoming(void)
  Socket_UDP_Incoming *return_value = new Socket_UDP_Incoming();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_UDP_Incoming, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_UDP_Incoming()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Socket_UDP_Incoming(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Socket_UDP_Incoming) {
    printf("Socket_UDP_Incoming ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Socket_UDP_Incoming *local_this = (Socket_UDP_Incoming *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Socket_UDP_Incoming) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Socket_UDP_Incoming(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Socket_UDP_Incoming) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Socket_UDP_Incoming*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_UDP_Incoming*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Socket_UDP_Outgoing
 */
/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Outgoing::InitToAddress(Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_InitToAddress_67(PyObject *self, PyObject *arg) {
  Socket_UDP_Outgoing *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Outgoing, (void **)&local_this, "Socket_UDP_Outgoing.InitToAddress")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP_Outgoing::InitToAddress(Socket_Address const &address)
  Socket_Address const *arg_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Socket_Address, 1, "Socket_UDP_Outgoing.InitToAddress", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).InitToAddress)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "InitToAddress(const Socket_UDP_Outgoing self, const Socket_Address address)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_InitToAddress_67_comment =
  "C++ Interface:\n"
  "InitToAddress(const Socket_UDP_Outgoing self, const Socket_Address address)\n"
  "\n"
  "// use this interface for a tagreted UDP connection\n"
  "\n"
  "/**\n"
  " * Connects the Socket to a specified address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Outgoing_InitToAddress_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Outgoing::Send(vector_uchar const &data)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_Send_68(PyObject *self, PyObject *arg) {
  Socket_UDP_Outgoing *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Outgoing, (void **)&local_this, "Socket_UDP_Outgoing.Send")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP_Outgoing::Send(vector_uchar const &data)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    bool return_value = ((*local_this).Send)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Send(const Socket_UDP_Outgoing self, bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_Send_68_comment =
  "C++ Interface:\n"
  "Send(const Socket_UDP_Outgoing self, bytes data)\n"
  "\n"
  "/**\n"
  " * Send data to connected address\n"
  " */\n"
  "\n"
  "/**\n"
  " * Send data to connected address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Outgoing_Send_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Outgoing::InitNoAddress(void)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_InitNoAddress_69(PyObject *self, PyObject *) {
  Socket_UDP_Outgoing *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Outgoing, (void **)&local_this, "Socket_UDP_Outgoing.InitNoAddress")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP_Outgoing::InitNoAddress(void)
  bool return_value = ((*local_this).InitNoAddress)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_InitNoAddress_69_comment =
  "C++ Interface:\n"
  "InitNoAddress(const Socket_UDP_Outgoing self)\n"
  "\n"
  "// use this interface for a none tagreted UDP connection\n"
  "\n"
  "/**\n"
  " * This will set a udp up for targeted sends.\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Outgoing_InitNoAddress_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Outgoing::SendTo(vector_uchar const &data, Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_SendTo_70(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_UDP_Outgoing *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Outgoing, (void **)&local_this, "Socket_UDP_Outgoing.SendTo")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP_Outgoing::SendTo(vector_uchar const &data, Socket_Address const &address)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"data", "address", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "" FMTCHAR_BYTES "#O:SendTo", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    Socket_Address const *param2_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Socket_Address, 2, "Socket_UDP_Outgoing.SendTo", true, true);
    if (param2_this != nullptr) {
      bool return_value = ((*local_this).SendTo)(vector_uchar(param1_str, param1_str + param1_len), *param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SendTo(const Socket_UDP_Outgoing self, bytes data, const Socket_Address address)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_SendTo_70_comment =
  "C++ Interface:\n"
  "SendTo(const Socket_UDP_Outgoing self, bytes data, const Socket_Address address)\n"
  "\n"
  "/**\n"
  " * Send data to specified address\n"
  " */\n"
  "\n"
  "/**\n"
  " * Send data to specified address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Outgoing_SendTo_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Outgoing::SetToBroadCast(void)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_SetToBroadCast_71(PyObject *self, PyObject *) {
  Socket_UDP_Outgoing *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Outgoing, (void **)&local_this, "Socket_UDP_Outgoing.SetToBroadCast")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP_Outgoing::SetToBroadCast(void)
  bool return_value = ((*local_this).SetToBroadCast)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_SetToBroadCast_71_comment =
  "C++ Interface:\n"
  "SetToBroadCast(const Socket_UDP_Outgoing self)\n"
  "\n"
  "/**\n"
  " * Ask the OS to let us receive broadcast packets on this port.\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Outgoing_SetToBroadCast_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_UDP_Outgoing::get_class_type(void)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_get_class_type_72(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_UDP_Outgoing::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Socket_UDP_Outgoing::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_get_class_type_72_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_UDP_Outgoing_get_class_type_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Socket_UDP_Outgoing::Socket_UDP_Outgoing(void)
 */
static int Dtool_Init_Socket_UDP_Outgoing(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Socket_UDP_Outgoing() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Socket_UDP_Outgoing() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline Socket_UDP_Outgoing::Socket_UDP_Outgoing(void)
  Socket_UDP_Outgoing *return_value = new Socket_UDP_Outgoing();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_UDP_Outgoing, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_UDP_Outgoing()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Socket_UDP_Outgoing(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Socket_UDP_Outgoing) {
    printf("Socket_UDP_Outgoing ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Socket_UDP_Outgoing *local_this = (Socket_UDP_Outgoing *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Socket_UDP_Outgoing) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Socket_UDP_Outgoing(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Socket_UDP_Outgoing) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Socket_UDP_Outgoing*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_UDP_Outgoing*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Socket_fdset
 */
/**
 * Python function wrapper for:
 * inline void Socket_fdset::setForSocket(Socket_IP const &incon)
 */
static PyObject *Dtool_Socket_fdset_setForSocket_76(PyObject *self, PyObject *arg) {
  Socket_fdset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_fdset, (void **)&local_this, "Socket_fdset.setForSocket")) {
    return nullptr;
  }
  // 1-inline void Socket_fdset::setForSocket(Socket_IP const &incon)
  Socket_IP arg_local;
  Socket_IP const *arg_this = Dtool_Coerce_Socket_IP(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Socket_fdset.setForSocket", "Socket_IP");
  }
  ((*local_this).setForSocket)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setForSocket(const Socket_fdset self, const Socket_IP incon)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_setForSocket_76_comment =
  "C++ Interface:\n"
  "setForSocket(const Socket_fdset self, const Socket_IP incon)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Socket_fdset_setForSocket_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_fdset::IsSetFor(Socket_IP const &incon) const
 */
static PyObject *Dtool_Socket_fdset_IsSetFor_77(PyObject *self, PyObject *arg) {
  Socket_fdset *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Socket_fdset)) {
    return nullptr;
  }
  // 1-inline bool Socket_fdset::IsSetFor(Socket_IP const &incon) const
  Socket_IP arg_local;
  Socket_IP const *arg_this = Dtool_Coerce_Socket_IP(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Socket_fdset.IsSetFor", "Socket_IP");
  }
  bool return_value = ((*(const Socket_fdset*)local_this).IsSetFor)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "IsSetFor(Socket_fdset self, const Socket_IP incon)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_IsSetFor_77_comment =
  "C++ Interface:\n"
  "IsSetFor(Socket_fdset self, const Socket_IP incon)\n"
  "\n"
  "/**\n"
  " * check to see if a socket object has been marked for reading\n"
  " */";
#else
static const char *Dtool_Socket_fdset_IsSetFor_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Rejected Remap [inline int Socket_fdset::WaitForRead(bool zeroFds, Time_Span const &timeout)]
 * inline int Socket_fdset::WaitForRead(bool zeroFds, uint32_t sleep_time = 4294967295)
 */
static PyObject *Dtool_Socket_fdset_WaitForRead_78(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_fdset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_fdset, (void **)&local_this, "Socket_fdset.WaitForRead")) {
    return nullptr;
  }
  // 1-inline int Socket_fdset::WaitForRead(bool zeroFds, uint32_t sleep_time = 4294967295)
  PyObject *param1;
  unsigned long param2 = 4294967295;
  static const char *keyword_list[] = {"zeroFds", "sleep_time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:WaitForRead", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    int return_value = ((*local_this).WaitForRead)((PyObject_IsTrue(param1) != 0), (uint32_t)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "WaitForRead(const Socket_fdset self, bool zeroFds, int sleep_time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_WaitForRead_78_comment =
  "C++ Interface:\n"
  "WaitForRead(const Socket_fdset self, bool zeroFds, int sleep_time)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Socket_fdset_WaitForRead_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_fdset::WaitForWrite(bool zeroFds, uint32_t sleep_time = 4294967295)
 */
static PyObject *Dtool_Socket_fdset_WaitForWrite_79(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_fdset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_fdset, (void **)&local_this, "Socket_fdset.WaitForWrite")) {
    return nullptr;
  }
  // 1-inline int Socket_fdset::WaitForWrite(bool zeroFds, uint32_t sleep_time = 4294967295)
  PyObject *param1;
  unsigned long param2 = 4294967295;
  static const char *keyword_list[] = {"zeroFds", "sleep_time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:WaitForWrite", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    int return_value = ((*local_this).WaitForWrite)((PyObject_IsTrue(param1) != 0), (uint32_t)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "WaitForWrite(const Socket_fdset self, bool zeroFds, int sleep_time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_WaitForWrite_79_comment =
  "C++ Interface:\n"
  "WaitForWrite(const Socket_fdset self, bool zeroFds, int sleep_time)\n"
  "\n"
  "/**\n"
  " * This is the function that will wait till one of the sockets is ready for\n"
  " * writing\n"
  " */";
#else
static const char *Dtool_Socket_fdset_WaitForWrite_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_fdset::WaitForError(bool zeroFds, uint32_t sleep_time = 4294967295)
 */
static PyObject *Dtool_Socket_fdset_WaitForError_80(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_fdset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_fdset, (void **)&local_this, "Socket_fdset.WaitForError")) {
    return nullptr;
  }
  // 1-inline int Socket_fdset::WaitForError(bool zeroFds, uint32_t sleep_time = 4294967295)
  PyObject *param1;
  unsigned long param2 = 4294967295;
  static const char *keyword_list[] = {"zeroFds", "sleep_time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:WaitForError", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    int return_value = ((*local_this).WaitForError)((PyObject_IsTrue(param1) != 0), (uint32_t)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "WaitForError(const Socket_fdset self, bool zeroFds, int sleep_time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_WaitForError_80_comment =
  "C++ Interface:\n"
  "WaitForError(const Socket_fdset self, bool zeroFds, int sleep_time)\n"
  "\n"
  "/**\n"
  " * This is the function that will wait till one of the sockets is in error\n"
  " * state\n"
  " */";
#else
static const char *Dtool_Socket_fdset_WaitForError_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Socket_fdset::clear(void)
 */
static PyObject *Dtool_Socket_fdset_clear_81(PyObject *self, PyObject *) {
  Socket_fdset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_fdset, (void **)&local_this, "Socket_fdset.clear")) {
    return nullptr;
  }
  // 1-inline void Socket_fdset::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_clear_81_comment =
  "C++ Interface:\n"
  "clear(const Socket_fdset self)\n"
  "\n"
  "/**\n"
  " * Marks the content as empty\n"
  " */";
#else
static const char *Dtool_Socket_fdset_clear_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Socket_fdset::Socket_fdset(void)
 * inline Socket_fdset::Socket_fdset(Socket_fdset const &) = default
 */
static int Dtool_Init_Socket_fdset(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Socket_fdset() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Socket_fdset::Socket_fdset(void)
      Socket_fdset *return_value = new Socket_fdset();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_fdset, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline Socket_fdset::Socket_fdset(Socket_fdset const &) = default
      Socket_fdset const *arg_this = (Socket_fdset *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Socket_fdset, 0, "Socket_fdset.Socket_fdset", true, true);
      if (arg_this != nullptr) {
        Socket_fdset *return_value = new Socket_fdset(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_fdset, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_fdset() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_fdset()\n"
      "Socket_fdset(const Socket_fdset param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Socket_fdset(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Socket_fdset) {
    printf("Socket_fdset ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Socket_fdset *local_this = (Socket_fdset *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Socket_fdset) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Socket_fdset(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Socket_fdset) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Buffered_DatagramConnection
 */
/**
 * Python function wrapper for:
 * inline bool Buffered_DatagramConnection::GetMessage(Datagram &val)
 */
static PyObject *Dtool_Buffered_DatagramConnection_GetMessage_84(PyObject *self, PyObject *arg) {
  Buffered_DatagramConnection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.GetMessage")) {
    return nullptr;
  }
  // 1-inline bool Buffered_DatagramConnection::GetMessage(Datagram &val)
  Datagram arg_local;
  Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Buffered_DatagramConnection.GetMessage", "Datagram");
  }
  bool return_value = ((*local_this).GetMessage)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetMessage(const Buffered_DatagramConnection self, Datagram val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_GetMessage_84_comment =
  "C++ Interface:\n"
  "GetMessage(const Buffered_DatagramConnection self, Datagram val)\n"
  "\n"
  "/**\n"
  " * Reads a message.  Returns false on failure.\n"
  " */";
#else
static const char *Dtool_Buffered_DatagramConnection_GetMessage_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Buffered_DatagramConnection::DoConnect(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_DoConnect_85(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.DoConnect")) {
    return nullptr;
  }
  // 1-inline bool Buffered_DatagramConnection::DoConnect(void)
  bool return_value = ((*local_this).DoConnect)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_DoConnect_85_comment =
  "C++ Interface:\n"
  "DoConnect(const Buffered_DatagramConnection self)\n"
  "\n"
  "// all the real state magic is in here";
#else
static const char *Dtool_Buffered_DatagramConnection_DoConnect_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Buffered_DatagramConnection::IsConnected(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_IsConnected_86(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.IsConnected")) {
    return nullptr;
  }
  // 1-inline bool Buffered_DatagramConnection::IsConnected(void)
  bool return_value = ((*local_this).IsConnected)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_IsConnected_86_comment =
  "C++ Interface:\n"
  "IsConnected(const Buffered_DatagramConnection self)\n"
  "\n"
  "// all the real state magic is in here";
#else
static const char *Dtool_Buffered_DatagramConnection_IsConnected_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Buffered_DatagramConnection::SendMessage(Datagram const &msg)
 */
static PyObject *Dtool_Buffered_DatagramConnection_SendMessage_88(PyObject *self, PyObject *arg) {
  Buffered_DatagramConnection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.SendMessage")) {
    return nullptr;
  }
  // 1-bool Buffered_DatagramConnection::SendMessage(Datagram const &msg)
  Datagram arg_local;
  Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Buffered_DatagramConnection.SendMessage", "Datagram");
  }
  bool return_value = ((*local_this).SendMessage)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SendMessage(const Buffered_DatagramConnection self, const Datagram msg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_SendMessage_88_comment =
  "C++ Interface:\n"
  "SendMessage(const Buffered_DatagramConnection self, const Datagram msg)\n"
  "\n"
  "// the reason thsi all exists\n"
  "\n"
  "/**\n"
  " * send the message\n"
  " */";
#else
static const char *Dtool_Buffered_DatagramConnection_SendMessage_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Buffered_DatagramConnection::Flush(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_Flush_89(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.Flush")) {
    return nullptr;
  }
  // 1-inline bool Buffered_DatagramConnection::Flush(void)
  bool return_value = ((*local_this).Flush)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_Flush_89_comment =
  "C++ Interface:\n"
  "Flush(const Buffered_DatagramConnection self)\n"
  "\n"
  "/**\n"
  " * Flush all writes.\n"
  " */";
#else
static const char *Dtool_Buffered_DatagramConnection_Flush_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Buffered_DatagramConnection::Reset(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_Reset_90(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.Reset")) {
    return nullptr;
  }
  // 1-inline void Buffered_DatagramConnection::Reset(void)
  ((*local_this).Reset)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_Reset_90_comment =
  "C++ Interface:\n"
  "Reset(const Buffered_DatagramConnection self)\n"
  "\n"
  "/**\n"
  " * Reset\n"
  " */";
#else
static const char *Dtool_Buffered_DatagramConnection_Reset_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Buffered_DatagramConnection::WaitForNetworkReadEvent(PN_stdfloat MaxTime)
 */
static PyObject *Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_91(PyObject *self, PyObject *arg) {
  Buffered_DatagramConnection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.WaitForNetworkReadEvent")) {
    return nullptr;
  }
  // 1-inline void Buffered_DatagramConnection::WaitForNetworkReadEvent(PN_stdfloat MaxTime)
  if (PyNumber_Check(arg)) {
    ((*local_this).WaitForNetworkReadEvent)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "WaitForNetworkReadEvent(const Buffered_DatagramConnection self, float MaxTime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_91_comment =
  "C++ Interface:\n"
  "WaitForNetworkReadEvent(const Buffered_DatagramConnection self, float MaxTime)\n";
#else
static const char *Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Buffered_DatagramConnection::AddressQueueSize(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_AddressQueueSize_92(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.AddressQueueSize")) {
    return nullptr;
  }
  // 1-inline std::size_t Buffered_DatagramConnection::AddressQueueSize(void)
  std::size_t return_value = ((*local_this).AddressQueueSize)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_AddressQueueSize_92_comment =
  "C++ Interface:\n"
  "AddressQueueSize(const Buffered_DatagramConnection self)\n"
  "\n"
  "// address queue stuff";
#else
static const char *Dtool_Buffered_DatagramConnection_AddressQueueSize_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Buffered_DatagramConnection::AddAddress(Socket_Address &inadr)
 */
static PyObject *Dtool_Buffered_DatagramConnection_AddAddress_93(PyObject *self, PyObject *arg) {
  Buffered_DatagramConnection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.AddAddress")) {
    return nullptr;
  }
  // 1-inline void Buffered_DatagramConnection::AddAddress(Socket_Address &inadr)
  Socket_Address *arg_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Socket_Address, 1, "Buffered_DatagramConnection.AddAddress", false, true);
  if (arg_this != nullptr) {
    ((*local_this).AddAddress)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "AddAddress(const Buffered_DatagramConnection self, Socket_Address inadr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_AddAddress_93_comment =
  "C++ Interface:\n"
  "AddAddress(const Buffered_DatagramConnection self, Socket_Address inadr)\n"
  "\n"
  "/**\n"
  " * must be called to set value to the server\n"
  " */";
#else
static const char *Dtool_Buffered_DatagramConnection_AddAddress_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Buffered_DatagramConnection::ClearAddresses(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_ClearAddresses_94(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.ClearAddresses")) {
    return nullptr;
  }
  // 1-inline void Buffered_DatagramConnection::ClearAddresses(void)
  ((*local_this).ClearAddresses)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_ClearAddresses_94_comment =
  "C++ Interface:\n"
  "ClearAddresses(const Buffered_DatagramConnection self)\n";
#else
static const char *Dtool_Buffered_DatagramConnection_ClearAddresses_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Buffered_DatagramConnection::get_class_type(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_get_class_type_95(PyObject *, PyObject *) {
  // 1-static TypeHandle Buffered_DatagramConnection::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Buffered_DatagramConnection::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_get_class_type_95_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Buffered_DatagramConnection_get_class_type_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline explicit Buffered_DatagramConnection::Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point)
 */
static int Dtool_Init_Buffered_DatagramConnection(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline explicit Buffered_DatagramConnection::Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point)
  int param0;
  int param1;
  int param2;
  static const char *keyword_list[] = {"rbufsize", "wbufsize", "write_flush_point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:Buffered_DatagramConnection", (char **)keyword_list, &param0, &param1, &param2)) {
    Buffered_DatagramConnection *return_value = new Buffered_DatagramConnection((int)param0, (int)param1, (int)param2);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Buffered_DatagramConnection, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Buffered_DatagramConnection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Buffered_DatagramConnection) {
    printf("Buffered_DatagramConnection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Buffered_DatagramConnection *local_this = (Buffered_DatagramConnection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Buffered_DatagramConnection) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *)(Socket_TCP *) local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_TCP) {
    return (Socket_TCP *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *)(Socket_TCP *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Buffered_DatagramConnection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Buffered_DatagramConnection) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Buffered_DatagramConnection*)other_this;
  }
  if (from_type == Dtool_Ptr_Socket_TCP) {
    Socket_TCP* other_this = (Socket_TCP*)from_this;
    return (Buffered_DatagramConnection*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Buffered_DatagramConnection*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Socket_UDP
 */
/**
 * Python function wrapper for:
 * inline bool Socket_UDP::InitToAddress(Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_InitToAddress_98(PyObject *self, PyObject *arg) {
  Socket_UDP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP, (void **)&local_this, "Socket_UDP.InitToAddress")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP::InitToAddress(Socket_Address const &address)
  Socket_Address const *arg_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Socket_Address, 1, "Socket_UDP.InitToAddress", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).InitToAddress)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "InitToAddress(const Socket_UDP self, const Socket_Address address)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_InitToAddress_98_comment =
  "C++ Interface:\n"
  "InitToAddress(const Socket_UDP self, const Socket_Address address)\n"
  "\n"
  "// use this interface for a tagreted UDP connection\n"
  "\n"
  "/**\n"
  " * Connects the socket to a Specified address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_InitToAddress_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP::Send(vector_uchar const &data)
 */
static PyObject *Dtool_Socket_UDP_Send_99(PyObject *self, PyObject *arg) {
  Socket_UDP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP, (void **)&local_this, "Socket_UDP.Send")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP::Send(vector_uchar const &data)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    bool return_value = ((*local_this).Send)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Send(const Socket_UDP self, bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Send_99_comment =
  "C++ Interface:\n"
  "Send(const Socket_UDP self, bytes data)\n"
  "\n"
  "/**\n"
  " * Send data to connected address\n"
  " */\n"
  "\n"
  "/**\n"
  " * Send data to connected address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Send_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP::SendTo(vector_uchar const &data, Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_SendTo_100(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_UDP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP, (void **)&local_this, "Socket_UDP.SendTo")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP::SendTo(vector_uchar const &data, Socket_Address const &address)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"data", "address", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "" FMTCHAR_BYTES "#O:SendTo", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    Socket_Address const *param2_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Socket_Address, 2, "Socket_UDP.SendTo", true, true);
    if (param2_this != nullptr) {
      bool return_value = ((*local_this).SendTo)(vector_uchar(param1_str, param1_str + param1_len), *param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SendTo(const Socket_UDP self, bytes data, const Socket_Address address)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_SendTo_100_comment =
  "C++ Interface:\n"
  "SendTo(const Socket_UDP self, bytes data, const Socket_Address address)\n"
  "\n"
  "/**\n"
  " * Send data to specified address\n"
  " */\n"
  "\n"
  "/**\n"
  " * Send data to specified address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_SendTo_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP::SetToBroadCast(void)
 */
static PyObject *Dtool_Socket_UDP_SetToBroadCast_101(PyObject *self, PyObject *) {
  Socket_UDP *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP, (void **)&local_this, "Socket_UDP.SetToBroadCast")) {
    return nullptr;
  }
  // 1-inline bool Socket_UDP::SetToBroadCast(void)
  bool return_value = ((*local_this).SetToBroadCast)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_SetToBroadCast_101_comment =
  "C++ Interface:\n"
  "SetToBroadCast(const Socket_UDP self)\n"
  "\n"
  "/**\n"
  " * Ask the OS to let us receive broadcast packets on this port.\n"
  " */";
#else
static const char *Dtool_Socket_UDP_SetToBroadCast_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_UDP::get_class_type(void)
 */
static PyObject *Dtool_Socket_UDP_get_class_type_102(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_UDP::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Socket_UDP::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_get_class_type_102_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_UDP_get_class_type_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Socket_UDP::Socket_UDP(void)
 */
static int Dtool_Init_Socket_UDP(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Socket_UDP() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Socket_UDP() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline Socket_UDP::Socket_UDP(void)
  Socket_UDP *return_value = new Socket_UDP();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_UDP, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_UDP()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Socket_UDP(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Socket_UDP) {
    printf("Socket_UDP ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Socket_UDP *local_this = (Socket_UDP *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Socket_UDP) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *)(Socket_UDP_Incoming *) local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_UDP_Incoming) {
    return (Socket_UDP_Incoming *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *)(Socket_UDP_Incoming *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Socket_UDP(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Socket_UDP) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Socket_UDP*)other_this;
  }
  if (from_type == Dtool_Ptr_Socket_UDP_Incoming) {
    Socket_UDP_Incoming* other_this = (Socket_UDP_Incoming*)from_this;
    return (Socket_UDP*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_UDP*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for Socket_Address (Socket_Address)
 */
static PyMethodDef Dtool_Methods_Socket_Address[] = {
  {"set_any_IP", &Dtool_Socket_Address_set_any_IP_4, METH_O, (const char *)Dtool_Socket_Address_set_any_IP_4_comment},
  {"setAnyIP", &Dtool_Socket_Address_set_any_IP_4, METH_O, (const char *)Dtool_Socket_Address_set_any_IP_4_comment},
  {"set_any_IPv6", &Dtool_Socket_Address_set_any_IPv6_5, METH_O, (const char *)Dtool_Socket_Address_set_any_IPv6_5_comment},
  {"setAnyIPv6", &Dtool_Socket_Address_set_any_IPv6_5, METH_O, (const char *)Dtool_Socket_Address_set_any_IPv6_5_comment},
  {"set_port", &Dtool_Socket_Address_set_port_6, METH_O, (const char *)Dtool_Socket_Address_set_port_6_comment},
  {"setPort", &Dtool_Socket_Address_set_port_6, METH_O, (const char *)Dtool_Socket_Address_set_port_6_comment},
  {"set_broadcast", &Dtool_Socket_Address_set_broadcast_7, METH_O, (const char *)Dtool_Socket_Address_set_broadcast_7_comment},
  {"setBroadcast", &Dtool_Socket_Address_set_broadcast_7, METH_O, (const char *)Dtool_Socket_Address_set_broadcast_7_comment},
  {"set_host", (PyCFunction) &Dtool_Socket_Address_set_host_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_Address_set_host_8_comment},
  {"setHost", (PyCFunction) &Dtool_Socket_Address_set_host_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_Address_set_host_8_comment},
  {"clear", &Dtool_Socket_Address_clear_9, METH_NOARGS, (const char *)Dtool_Socket_Address_clear_9_comment},
  {"get_family", &Dtool_Socket_Address_get_family_10, METH_NOARGS, (const char *)Dtool_Socket_Address_get_family_10_comment},
  {"getFamily", &Dtool_Socket_Address_get_family_10, METH_NOARGS, (const char *)Dtool_Socket_Address_get_family_10_comment},
  {"get_port", &Dtool_Socket_Address_get_port_11, METH_NOARGS, (const char *)Dtool_Socket_Address_get_port_11_comment},
  {"getPort", &Dtool_Socket_Address_get_port_11, METH_NOARGS, (const char *)Dtool_Socket_Address_get_port_11_comment},
  {"get_ip", &Dtool_Socket_Address_get_ip_12, METH_NOARGS, (const char *)Dtool_Socket_Address_get_ip_12_comment},
  {"getIp", &Dtool_Socket_Address_get_ip_12, METH_NOARGS, (const char *)Dtool_Socket_Address_get_ip_12_comment},
  {"get_ip_port", &Dtool_Socket_Address_get_ip_port_13, METH_NOARGS, (const char *)Dtool_Socket_Address_get_ip_port_13_comment},
  {"getIpPort", &Dtool_Socket_Address_get_ip_port_13, METH_NOARGS, (const char *)Dtool_Socket_Address_get_ip_port_13_comment},
  {"GetIPAddressRaw", &Dtool_Socket_Address_GetIPAddressRaw_14, METH_NOARGS, (const char *)Dtool_Socket_Address_GetIPAddressRaw_14_comment},
  {"is_any", &Dtool_Socket_Address_is_any_18, METH_NOARGS, (const char *)Dtool_Socket_Address_is_any_18_comment},
  {"isAny", &Dtool_Socket_Address_is_any_18, METH_NOARGS, (const char *)Dtool_Socket_Address_is_any_18_comment},
  {"is_mcast_range", &Dtool_Socket_Address_is_mcast_range_19, METH_NOARGS, (const char *)Dtool_Socket_Address_is_mcast_range_19_comment},
  {"isMcastRange", &Dtool_Socket_Address_is_mcast_range_19, METH_NOARGS, (const char *)Dtool_Socket_Address_is_mcast_range_19_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A rich comparison function
//     Socket_Address
//////////////////
static PyObject *Dtool_RichCompare_Socket_Address(PyObject *self, PyObject *arg, int op) {
  Socket_Address *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_Address, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool Socket_Address::operator ==(Socket_Address const &in) const
      Socket_Address const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Socket_Address);
      if (arg_this != nullptr) {
        bool return_value = ((*(const Socket_Address*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool Socket_Address::operator !=(Socket_Address const &in) const
      Socket_Address const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Socket_Address);
      if (arg_this != nullptr) {
        bool return_value = ((*(const Socket_Address*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool Socket_Address::operator <(Socket_Address const &in) const
      Socket_Address const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Socket_Address);
      if (arg_this != nullptr) {
        bool return_value = ((*(const Socket_Address*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_Socket_Address = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Socket_Address = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Socket_Address",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_Address,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_Socket_Address,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A simple place to store and manipulate tcp and port address for\n"
    " * communication layer\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_Socket_Address,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Socket_Address,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Socket_Address,
    PyType_GenericAlloc,
    Dtool_new_Socket_Address,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_Address,
  Dtool_UpcastInterface_Socket_Address,
  Dtool_DowncastInterface_Socket_Address,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Socket_Address(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Socket_Address._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Socket_Address._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_Address) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_Address)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_Address);
  }
}

/**
 * Python method tables for Socket_IP (Socket_IP)
 */
static PyMethodDef Dtool_Methods_Socket_IP[] = {
  {"Close", &Dtool_Socket_IP_Close_23, METH_NOARGS, (const char *)Dtool_Socket_IP_Close_23_comment},
  {"GetLastError", &Dtool_Socket_IP_GetLastError_24, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_IP_GetLastError_24_comment},
  {"SetNonBlocking", &Dtool_Socket_IP_SetNonBlocking_25, METH_NOARGS, (const char *)Dtool_Socket_IP_SetNonBlocking_25_comment},
  {"SetBlocking", &Dtool_Socket_IP_SetBlocking_26, METH_NOARGS, (const char *)Dtool_Socket_IP_SetBlocking_26_comment},
  {"SetReuseAddress", (PyCFunction) &Dtool_Socket_IP_SetReuseAddress_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_IP_SetReuseAddress_27_comment},
  {"SetV6Only", &Dtool_Socket_IP_SetV6Only_28, METH_O, (const char *)Dtool_Socket_IP_SetV6Only_28_comment},
  {"Active", &Dtool_Socket_IP_Active_29, METH_NOARGS, (const char *)Dtool_Socket_IP_Active_29_comment},
  {"SetRecvBufferSize", &Dtool_Socket_IP_SetRecvBufferSize_30, METH_O, (const char *)Dtool_Socket_IP_SetRecvBufferSize_30_comment},
  {"SetSocket", &Dtool_Socket_IP_SetSocket_31, METH_O, (const char *)Dtool_Socket_IP_SetSocket_31_comment},
  {"GetSocket", &Dtool_Socket_IP_GetSocket_32, METH_NOARGS, (const char *)Dtool_Socket_IP_GetSocket_32_comment},
  {"GetPeerName", &Dtool_Socket_IP_GetPeerName_33, METH_NOARGS, (const char *)Dtool_Socket_IP_GetPeerName_33_comment},
  {"InitNetworkDriver", &Dtool_Socket_IP_InitNetworkDriver_34, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_IP_InitNetworkDriver_34_comment},
  {"get_class_type", &Dtool_Socket_IP_get_class_type_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_IP_get_class_type_35_comment},
  {"getClassType", &Dtool_Socket_IP_get_class_type_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_IP_get_class_type_35_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Socket_IP = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_IP = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Socket_IP = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Socket_IP = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Socket_IP = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Socket_IP = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Socket_IP",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_IP,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Socket_IP,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Socket_IP,
    &Dtool_SequenceMethods_Socket_IP,
    &Dtool_MappingMethods_Socket_IP,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Socket_IP,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a INET domain Socket This call should be the\n"
    " * starting point for all other unix domain sockets.\n"
    " *\n"
    " * SocketIP |\n"
    " * ------------------------------------------------------------------- |\n"
    " * |                       |                           | SocketTCP\n"
    " * SocketTCP_Listen    SocketUDP_Incoming   SocketUDP_OutBound\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Socket_IP,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Socket_IP,
    PyType_GenericAlloc,
    Dtool_new_Socket_IP,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_IP,
  Dtool_UpcastInterface_Socket_IP,
  Dtool_DowncastInterface_Socket_IP,
  nullptr,
  (CoerceFunction)Dtool_Coerce_Socket_IP,
};

static void Dtool_PyModuleClassInit_Socket_IP(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_Socket_IP._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_Socket_IP._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Socket_IP._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_IP) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_IP)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_IP);
  }
}

/**
 * Python method tables for Socket_TCP (Socket_TCP)
 */
static PyMethodDef Dtool_Methods_Socket_TCP[] = {
  {"SetNoDelay", (PyCFunction) &Dtool_Socket_TCP_SetNoDelay_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_TCP_SetNoDelay_38_comment},
  {"SetLinger", (PyCFunction) &Dtool_Socket_TCP_SetLinger_39, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_TCP_SetLinger_39_comment},
  {"DontLinger", &Dtool_Socket_TCP_DontLinger_40, METH_NOARGS, (const char *)Dtool_Socket_TCP_DontLinger_40_comment},
  {"SetSendBufferSize", &Dtool_Socket_TCP_SetSendBufferSize_41, METH_O, (const char *)Dtool_Socket_TCP_SetSendBufferSize_41_comment},
  {"ActiveOpen", (PyCFunction) &Dtool_Socket_TCP_ActiveOpen_42, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_TCP_ActiveOpen_42_comment},
  {"ActiveOpenNonBlocking", &Dtool_Socket_TCP_ActiveOpenNonBlocking_43, METH_O, (const char *)Dtool_Socket_TCP_ActiveOpenNonBlocking_43_comment},
  {"ErrorIs_WouldBlocking", &Dtool_Socket_TCP_ErrorIs_WouldBlocking_44, METH_O, (const char *)Dtool_Socket_TCP_ErrorIs_WouldBlocking_44_comment},
  {"ErrorIsWouldBlocking", &Dtool_Socket_TCP_ErrorIs_WouldBlocking_44, METH_O, (const char *)Dtool_Socket_TCP_ErrorIs_WouldBlocking_44_comment},
  {"ShutdownSend", &Dtool_Socket_TCP_ShutdownSend_45, METH_NOARGS, (const char *)Dtool_Socket_TCP_ShutdownSend_45_comment},
  {"SendData", &Dtool_Socket_TCP_SendData_46, METH_O, (const char *)Dtool_Socket_TCP_SendData_46_comment},
  {"RecvData", &Dtool_Socket_TCP_RecvData_47, METH_O, (const char *)Dtool_Socket_TCP_RecvData_47_comment},
  {"get_class_type", &Dtool_Socket_TCP_get_class_type_48, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_TCP_get_class_type_48_comment},
  {"getClassType", &Dtool_Socket_TCP_get_class_type_48, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_TCP_get_class_type_48_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Socket_TCP = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_TCP = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Socket_TCP = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Socket_TCP = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Socket_TCP = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Socket_TCP = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Socket_TCP",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_TCP,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Socket_TCP,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Socket_TCP,
    &Dtool_SequenceMethods_Socket_TCP,
    &Dtool_MappingMethods_Socket_TCP,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Socket_TCP,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a TCP connected socket This class is pretty useless\n"
    " * by itself but it does hide some of the platform differences from machine to\n"
    " * machine\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Socket_TCP,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Socket_TCP,
    PyType_GenericAlloc,
    Dtool_new_Socket_TCP,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_TCP,
  Dtool_UpcastInterface_Socket_TCP,
  Dtool_DowncastInterface_Socket_TCP,
  nullptr,
  (CoerceFunction)Dtool_Coerce_Socket_TCP,
};

static void Dtool_PyModuleClassInit_Socket_TCP(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_IP(nullptr);
    Dtool_Socket_TCP._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_IP);
    Dtool_Socket_TCP._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Socket_TCP._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_TCP) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_TCP)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_TCP);
  }
}

/**
 * Python method tables for Socket_TCP_Listen (Socket_TCP_Listen)
 */
static PyMethodDef Dtool_Methods_Socket_TCP_Listen[] = {
  {"OpenForListen", (PyCFunction) &Dtool_Socket_TCP_Listen_OpenForListen_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_TCP_Listen_OpenForListen_52_comment},
  {"GetIncomingConnection", (PyCFunction) &Dtool_Socket_TCP_Listen_GetIncomingConnection_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_TCP_Listen_GetIncomingConnection_53_comment},
  {"get_class_type", &Dtool_Socket_TCP_Listen_get_class_type_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_TCP_Listen_get_class_type_54_comment},
  {"getClassType", &Dtool_Socket_TCP_Listen_get_class_type_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_TCP_Listen_get_class_type_54_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Socket_TCP_Listen = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_TCP_Listen = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Socket_TCP_Listen = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Socket_TCP_Listen = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Socket_TCP_Listen = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Socket_TCP_Listen = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Socket_TCP_Listen",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_TCP_Listen,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Socket_TCP_Listen,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Socket_TCP_Listen,
    &Dtool_SequenceMethods_Socket_TCP_Listen,
    &Dtool_MappingMethods_Socket_TCP_Listen,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Socket_TCP_Listen,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a TCP rendezvous socket\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Socket_TCP_Listen,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Socket_TCP_Listen,
    PyType_GenericAlloc,
    Dtool_new_Socket_TCP_Listen,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_TCP_Listen,
  Dtool_UpcastInterface_Socket_TCP_Listen,
  Dtool_DowncastInterface_Socket_TCP_Listen,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Socket_TCP_Listen(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_IP(nullptr);
    Dtool_Socket_TCP_Listen._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_IP);
    Dtool_Socket_TCP_Listen._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Socket_TCP_Listen._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_TCP_Listen) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_TCP_Listen)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_TCP_Listen);
  }
}

/**
 * Python method tables for Socket_UDP_Incoming (Socket_UDP_Incoming)
 */
static PyMethodDef Dtool_Methods_Socket_UDP_Incoming[] = {
  {"OpenForInput", &Dtool_Socket_UDP_Incoming_OpenForInput_57, METH_O, (const char *)Dtool_Socket_UDP_Incoming_OpenForInput_57_comment},
  {"OpenForInputMCast", &Dtool_Socket_UDP_Incoming_OpenForInputMCast_58, METH_O, (const char *)Dtool_Socket_UDP_Incoming_OpenForInputMCast_58_comment},
  {"SendTo", (PyCFunction) &Dtool_Socket_UDP_Incoming_SendTo_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_UDP_Incoming_SendTo_60_comment},
  {"InitNoAddress", &Dtool_Socket_UDP_Incoming_InitNoAddress_61, METH_NOARGS, (const char *)Dtool_Socket_UDP_Incoming_InitNoAddress_61_comment},
  {"SetToBroadCast", &Dtool_Socket_UDP_Incoming_SetToBroadCast_62, METH_NOARGS, (const char *)Dtool_Socket_UDP_Incoming_SetToBroadCast_62_comment},
  {"get_class_type", &Dtool_Socket_UDP_Incoming_get_class_type_63, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_Incoming_get_class_type_63_comment},
  {"getClassType", &Dtool_Socket_UDP_Incoming_get_class_type_63, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_Incoming_get_class_type_63_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Socket_UDP_Incoming = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_UDP_Incoming = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Socket_UDP_Incoming = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Socket_UDP_Incoming = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Socket_UDP_Incoming = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Socket_UDP_Incoming = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Socket_UDP_Incoming",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_UDP_Incoming,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Socket_UDP_Incoming,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Socket_UDP_Incoming,
    &Dtool_SequenceMethods_Socket_UDP_Incoming,
    &Dtool_MappingMethods_Socket_UDP_Incoming,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Socket_UDP_Incoming,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a UDP Reader\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Socket_UDP_Incoming,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Socket_UDP_Incoming,
    PyType_GenericAlloc,
    Dtool_new_Socket_UDP_Incoming,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_UDP_Incoming,
  Dtool_UpcastInterface_Socket_UDP_Incoming,
  Dtool_DowncastInterface_Socket_UDP_Incoming,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Socket_UDP_Incoming(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_IP(nullptr);
    Dtool_Socket_UDP_Incoming._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_IP);
    Dtool_Socket_UDP_Incoming._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Socket_UDP_Incoming._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_UDP_Incoming) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_UDP_Incoming)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_UDP_Incoming);
  }
}

/**
 * Python method tables for Socket_UDP_Outgoing (Socket_UDP_Outgoing)
 */
static PyMethodDef Dtool_Methods_Socket_UDP_Outgoing[] = {
  {"InitToAddress", &Dtool_Socket_UDP_Outgoing_InitToAddress_67, METH_O, (const char *)Dtool_Socket_UDP_Outgoing_InitToAddress_67_comment},
  {"Send", &Dtool_Socket_UDP_Outgoing_Send_68, METH_O, (const char *)Dtool_Socket_UDP_Outgoing_Send_68_comment},
  {"InitNoAddress", &Dtool_Socket_UDP_Outgoing_InitNoAddress_69, METH_NOARGS, (const char *)Dtool_Socket_UDP_Outgoing_InitNoAddress_69_comment},
  {"SendTo", (PyCFunction) &Dtool_Socket_UDP_Outgoing_SendTo_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_UDP_Outgoing_SendTo_70_comment},
  {"SetToBroadCast", &Dtool_Socket_UDP_Outgoing_SetToBroadCast_71, METH_NOARGS, (const char *)Dtool_Socket_UDP_Outgoing_SetToBroadCast_71_comment},
  {"get_class_type", &Dtool_Socket_UDP_Outgoing_get_class_type_72, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_Outgoing_get_class_type_72_comment},
  {"getClassType", &Dtool_Socket_UDP_Outgoing_get_class_type_72, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_Outgoing_get_class_type_72_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Socket_UDP_Outgoing = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_UDP_Outgoing = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Socket_UDP_Outgoing = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Socket_UDP_Outgoing = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Socket_UDP_Outgoing = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Socket_UDP_Outgoing = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Socket_UDP_Outgoing",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_UDP_Outgoing,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Socket_UDP_Outgoing,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Socket_UDP_Outgoing,
    &Dtool_SequenceMethods_Socket_UDP_Outgoing,
    &Dtool_MappingMethods_Socket_UDP_Outgoing,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Socket_UDP_Outgoing,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a UDP sending socket\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Socket_UDP_Outgoing,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Socket_UDP_Outgoing,
    PyType_GenericAlloc,
    Dtool_new_Socket_UDP_Outgoing,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_UDP_Outgoing,
  Dtool_UpcastInterface_Socket_UDP_Outgoing,
  Dtool_DowncastInterface_Socket_UDP_Outgoing,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Socket_UDP_Outgoing(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_IP(nullptr);
    Dtool_Socket_UDP_Outgoing._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_IP);
    Dtool_Socket_UDP_Outgoing._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Socket_UDP_Outgoing._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_UDP_Outgoing) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_UDP_Outgoing)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_UDP_Outgoing);
  }
}

/**
 * Python method tables for Socket_fdset (Socket_fdset)
 */
static PyMethodDef Dtool_Methods_Socket_fdset[] = {
  {"setForSocket", &Dtool_Socket_fdset_setForSocket_76, METH_O, (const char *)Dtool_Socket_fdset_setForSocket_76_comment},
  {"IsSetFor", &Dtool_Socket_fdset_IsSetFor_77, METH_O, (const char *)Dtool_Socket_fdset_IsSetFor_77_comment},
  {"WaitForRead", (PyCFunction) &Dtool_Socket_fdset_WaitForRead_78, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_fdset_WaitForRead_78_comment},
  {"WaitForWrite", (PyCFunction) &Dtool_Socket_fdset_WaitForWrite_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_fdset_WaitForWrite_79_comment},
  {"WaitForError", (PyCFunction) &Dtool_Socket_fdset_WaitForError_80, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_fdset_WaitForError_80_comment},
  {"clear", &Dtool_Socket_fdset_clear_81, METH_NOARGS, (const char *)Dtool_Socket_fdset_clear_81_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Socket_fdset = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Socket_fdset = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Socket_fdset",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_fdset,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Socket_fdset,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Socket_fdset,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Socket_fdset,
    PyType_GenericAlloc,
    Dtool_new_Socket_fdset,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_fdset,
  Dtool_UpcastInterface_Socket_fdset,
  Dtool_DowncastInterface_Socket_fdset,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Socket_fdset(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Socket_fdset._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Socket_fdset._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_fdset) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_fdset)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_fdset);
  }
}

/**
 * Python method tables for Buffered_DatagramConnection (Buffered_DatagramConnection)
 */
static PyMethodDef Dtool_Methods_Buffered_DatagramConnection[] = {
  {"GetMessage", &Dtool_Buffered_DatagramConnection_GetMessage_84, METH_O, (const char *)Dtool_Buffered_DatagramConnection_GetMessage_84_comment},
  {"DoConnect", &Dtool_Buffered_DatagramConnection_DoConnect_85, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_DoConnect_85_comment},
  {"IsConnected", &Dtool_Buffered_DatagramConnection_IsConnected_86, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_IsConnected_86_comment},
  {"SendMessage", &Dtool_Buffered_DatagramConnection_SendMessage_88, METH_O, (const char *)Dtool_Buffered_DatagramConnection_SendMessage_88_comment},
  {"Flush", &Dtool_Buffered_DatagramConnection_Flush_89, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_Flush_89_comment},
  {"Reset", &Dtool_Buffered_DatagramConnection_Reset_90, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_Reset_90_comment},
  {"WaitForNetworkReadEvent", &Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_91, METH_O, (const char *)Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_91_comment},
  {"AddressQueueSize", &Dtool_Buffered_DatagramConnection_AddressQueueSize_92, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_AddressQueueSize_92_comment},
  {"AddAddress", &Dtool_Buffered_DatagramConnection_AddAddress_93, METH_O, (const char *)Dtool_Buffered_DatagramConnection_AddAddress_93_comment},
  {"ClearAddresses", &Dtool_Buffered_DatagramConnection_ClearAddresses_94, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_ClearAddresses_94_comment},
  {"get_class_type", &Dtool_Buffered_DatagramConnection_get_class_type_95, METH_NOARGS | METH_STATIC, (const char *)Dtool_Buffered_DatagramConnection_get_class_type_95_comment},
  {"getClassType", &Dtool_Buffered_DatagramConnection_get_class_type_95, METH_NOARGS | METH_STATIC, (const char *)Dtool_Buffered_DatagramConnection_get_class_type_95_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Buffered_DatagramConnection = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Buffered_DatagramConnection = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Buffered_DatagramConnection = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Buffered_DatagramConnection = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Buffered_DatagramConnection = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Buffered_DatagramConnection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Buffered_DatagramConnection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Buffered_DatagramConnection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Buffered_DatagramConnection,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Buffered_DatagramConnection,
    &Dtool_SequenceMethods_Buffered_DatagramConnection,
    &Dtool_MappingMethods_Buffered_DatagramConnection,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Buffered_DatagramConnection,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// there are 3 states 1. Socket not even assigned,,,, 2. Socket Assigned and\n"
    "// trying to get a active connect open 3. Socket is open and  writable.. (\n"
    "// Fully powered up )...",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Buffered_DatagramConnection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Buffered_DatagramConnection,
    PyType_GenericAlloc,
    Dtool_new_Buffered_DatagramConnection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Buffered_DatagramConnection,
  Dtool_UpcastInterface_Buffered_DatagramConnection,
  Dtool_DowncastInterface_Buffered_DatagramConnection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Buffered_DatagramConnection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_TCP(nullptr);
    Dtool_Buffered_DatagramConnection._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_TCP);
    Dtool_Buffered_DatagramConnection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Buffered_DatagramConnection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Buffered_DatagramConnection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Buffered_DatagramConnection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Buffered_DatagramConnection);
  }
}

/**
 * Python method tables for Socket_UDP (Socket_UDP)
 */
static PyMethodDef Dtool_Methods_Socket_UDP[] = {
  {"InitToAddress", &Dtool_Socket_UDP_InitToAddress_98, METH_O, (const char *)Dtool_Socket_UDP_InitToAddress_98_comment},
  {"Send", &Dtool_Socket_UDP_Send_99, METH_O, (const char *)Dtool_Socket_UDP_Send_99_comment},
  {"SendTo", (PyCFunction) &Dtool_Socket_UDP_SendTo_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_UDP_SendTo_100_comment},
  {"SetToBroadCast", &Dtool_Socket_UDP_SetToBroadCast_101, METH_NOARGS, (const char *)Dtool_Socket_UDP_SetToBroadCast_101_comment},
  {"get_class_type", &Dtool_Socket_UDP_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_get_class_type_102_comment},
  {"getClassType", &Dtool_Socket_UDP_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_get_class_type_102_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Socket_UDP = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_UDP = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Socket_UDP = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Socket_UDP = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Socket_UDP = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Socket_UDP = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Socket_UDP",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_UDP,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Socket_UDP,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Socket_UDP,
    &Dtool_SequenceMethods_Socket_UDP,
    &Dtool_MappingMethods_Socket_UDP,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Socket_UDP,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a combination UDP Reader and Writer.  This\n"
    " * duplicates code from Socket_UDP_Outgoing, to avoid the problems of multiple\n"
    " * inheritance.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Socket_UDP,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Socket_UDP,
    PyType_GenericAlloc,
    Dtool_new_Socket_UDP,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_UDP,
  Dtool_UpcastInterface_Socket_UDP,
  Dtool_DowncastInterface_Socket_UDP,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Socket_UDP(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_UDP_Incoming(nullptr);
    Dtool_Socket_UDP._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_UDP_Incoming);
    Dtool_Socket_UDP._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Socket_UDP._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_UDP) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_UDP)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_UDP);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3nativenet_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    Socket_IP::init_type();
    TypeHandle handle = Socket_IP::get_class_type();
    Dtool_Socket_IP._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Socket_IP);
  }
  {
    Socket_TCP::init_type();
    TypeHandle handle = Socket_TCP::get_class_type();
    Dtool_Socket_TCP._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Socket_TCP);
  }
  {
    Socket_TCP_Listen::init_type();
    TypeHandle handle = Socket_TCP_Listen::get_class_type();
    Dtool_Socket_TCP_Listen._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Socket_TCP_Listen);
  }
  {
    Socket_UDP_Incoming::init_type();
    TypeHandle handle = Socket_UDP_Incoming::get_class_type();
    Dtool_Socket_UDP_Incoming._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Socket_UDP_Incoming);
  }
  {
    Socket_UDP_Outgoing::init_type();
    TypeHandle handle = Socket_UDP_Outgoing::get_class_type();
    Dtool_Socket_UDP_Outgoing._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Socket_UDP_Outgoing);
  }
  {
    Buffered_DatagramConnection::init_type();
    TypeHandle handle = Buffered_DatagramConnection::get_class_type();
    Dtool_Buffered_DatagramConnection._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Buffered_DatagramConnection);
  }
  {
    Socket_UDP::init_type();
    TypeHandle handle = Socket_UDP::get_class_type();
    Dtool_Socket_UDP._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Socket_UDP);
  }
}

void Dtool_libp3nativenet_BuildInstants(PyObject *module) {
  (void) module;
  // Socket_Address
  Dtool_PyModuleClassInit_Socket_Address(module);
  PyModule_AddObject(module, "Socket_Address", (PyObject *)&Dtool_Socket_Address);
  Py_INCREF(Dtool_Ptr_Socket_Address);
  PyModule_AddObject(module, "SocketAddress", (PyObject *)&Dtool_Socket_Address);
  // Socket_IP
  Dtool_PyModuleClassInit_Socket_IP(module);
  PyModule_AddObject(module, "Socket_IP", (PyObject *)&Dtool_Socket_IP);
  Py_INCREF(Dtool_Ptr_Socket_IP);
  PyModule_AddObject(module, "SocketIP", (PyObject *)&Dtool_Socket_IP);
  // Socket_TCP
  Dtool_PyModuleClassInit_Socket_TCP(module);
  PyModule_AddObject(module, "Socket_TCP", (PyObject *)&Dtool_Socket_TCP);
  Py_INCREF(Dtool_Ptr_Socket_TCP);
  PyModule_AddObject(module, "SocketTCP", (PyObject *)&Dtool_Socket_TCP);
  // Socket_TCP_Listen
  Dtool_PyModuleClassInit_Socket_TCP_Listen(module);
  PyModule_AddObject(module, "Socket_TCP_Listen", (PyObject *)&Dtool_Socket_TCP_Listen);
  Py_INCREF(Dtool_Ptr_Socket_TCP_Listen);
  PyModule_AddObject(module, "SocketTCPListen", (PyObject *)&Dtool_Socket_TCP_Listen);
  // Socket_UDP_Incoming
  Dtool_PyModuleClassInit_Socket_UDP_Incoming(module);
  PyModule_AddObject(module, "Socket_UDP_Incoming", (PyObject *)&Dtool_Socket_UDP_Incoming);
  Py_INCREF(Dtool_Ptr_Socket_UDP_Incoming);
  PyModule_AddObject(module, "SocketUDPIncoming", (PyObject *)&Dtool_Socket_UDP_Incoming);
  // Socket_UDP_Outgoing
  Dtool_PyModuleClassInit_Socket_UDP_Outgoing(module);
  PyModule_AddObject(module, "Socket_UDP_Outgoing", (PyObject *)&Dtool_Socket_UDP_Outgoing);
  Py_INCREF(Dtool_Ptr_Socket_UDP_Outgoing);
  PyModule_AddObject(module, "SocketUDPOutgoing", (PyObject *)&Dtool_Socket_UDP_Outgoing);
  // Socket_fdset
  Dtool_PyModuleClassInit_Socket_fdset(module);
  PyModule_AddObject(module, "Socket_fdset", (PyObject *)&Dtool_Socket_fdset);
  Py_INCREF(Dtool_Ptr_Socket_fdset);
  PyModule_AddObject(module, "SocketFdset", (PyObject *)&Dtool_Socket_fdset);
  // Buffered_DatagramConnection
  Dtool_PyModuleClassInit_Buffered_DatagramConnection(module);
  PyModule_AddObject(module, "Buffered_DatagramConnection", (PyObject *)&Dtool_Buffered_DatagramConnection);
  Py_INCREF(Dtool_Ptr_Buffered_DatagramConnection);
  PyModule_AddObject(module, "BufferedDatagramConnection", (PyObject *)&Dtool_Buffered_DatagramConnection);
  // Socket_UDP
  Dtool_PyModuleClassInit_Socket_UDP(module);
  PyModule_AddObject(module, "Socket_UDP", (PyObject *)&Dtool_Socket_UDP);
  Py_INCREF(Dtool_Ptr_Socket_UDP);
  PyModule_AddObject(module, "SocketUDP", (PyObject *)&Dtool_Socket_UDP);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3nativenet_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3nativenet_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613107,  /* file_identifier */
  "libp3nativenet",  /* library_name */
  "5qEC",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3nativenet.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  239  /* next_index */
};

Configure(_in_configure_libp3nativenet);
ConfigureFn(_in_configure_libp3nativenet) {
  interrogate_request_module(&_in_module_def);
}

