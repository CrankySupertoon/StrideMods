/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/text -Ipanda/src/text -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3text_igate.cxx -od built/pandac/input/libp3text.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/text -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -S/usr/include/freetype2 -S/usr/include/libpng16 -S/usr/include/harfbuzz -S/usr/include/glib-2.0 -S/usr/lib/glib-2.0/include -module panda3d.core -library libp3text config_text.h default_font.h dynamicTextFont.h dynamicTextGlyph.h dynamicTextPage.h fontPool.h geomTextGlyph.h p3text_composite1.cxx p3text_composite2.cxx staticTextFont.h textAssembler.h textFont.h textGlyph.h textGraphic.h textNode.h textProperties.h textPropertiesManager.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableFilename.h"
#include "configVariableInt.h"
#include "config_text.h"
#include "default_font.h"
#include "dynamicTextFont.h"
#include "dynamicTextGlyph.h"
#include "dynamicTextPage.h"
#include "filename.h"
#include "fontPool.h"
#include "freetypeFont.h"
#include <ft2build.h>
#include "geom.h"
#include "geomTextGlyph.h"
#include "lightMutex.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pmap.h"
#include "pvector.h"
#include "staticTextFont.h"
#include "textAssembler.h"
#include "textFont.h"
#include "textGlyph.h"
#include "textGraphic.h"
#include "textNode.h"
#include "textProperties.h"
#include "textPropertiesManager.h"
#include "texture.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class TextGlyph
 */
typedef TextGlyph TextGlyph_localtype;
Define_Module_ClassRef(panda3d.core, TextGlyph, TextGlyph_localtype, TextGlyph);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextGlyph = &Dtool_TextGlyph;
static void Dtool_PyModuleClassInit_TextGlyph(PyObject *module);

/**
 * Forward declarations for top-level class TextFont
 */
typedef TextFont TextFont_localtype;
Define_Module_ClassRef(panda3d.core, TextFont, TextFont_localtype, TextFont);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextFont = &Dtool_TextFont;
static void Dtool_PyModuleClassInit_TextFont(PyObject *module);

/**
 * Forward declarations for top-level class DynamicTextGlyph
 */
typedef DynamicTextGlyph DynamicTextGlyph_localtype;
Define_Module_ClassRef(panda3d.core, DynamicTextGlyph, DynamicTextGlyph_localtype, DynamicTextGlyph);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DynamicTextGlyph = &Dtool_DynamicTextGlyph;
static void Dtool_PyModuleClassInit_DynamicTextGlyph(PyObject *module);

/**
 * Forward declarations for top-level class DynamicTextPage
 */
typedef DynamicTextPage DynamicTextPage_localtype;
Define_Module_ClassRef(panda3d.core, DynamicTextPage, DynamicTextPage_localtype, DynamicTextPage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DynamicTextPage = &Dtool_DynamicTextPage;
static void Dtool_PyModuleClassInit_DynamicTextPage(PyObject *module);

/**
 * Forward declarations for top-level class DynamicTextFont
 */
typedef DynamicTextFont DynamicTextFont_localtype;
Define_Module_ClassRef(panda3d.core, DynamicTextFont, DynamicTextFont_localtype, DynamicTextFont);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DynamicTextFont = &Dtool_DynamicTextFont;
static void Dtool_PyModuleClassInit_DynamicTextFont(PyObject *module);
bool Dtool_ConstCoerce_DynamicTextFont(PyObject *args, CPT(DynamicTextFont) &coerced);
bool Dtool_Coerce_DynamicTextFont(PyObject *args, PT(DynamicTextFont) &coerced);

/**
 * Forward declarations for top-level class FontPool
 */
typedef FontPool FontPool_localtype;
Define_Module_Class(panda3d.core, FontPool, FontPool_localtype, FontPool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FontPool = &Dtool_FontPool;
static void Dtool_PyModuleClassInit_FontPool(PyObject *module);

/**
 * Forward declarations for top-level class GeomTextGlyph
 */
typedef GeomTextGlyph GeomTextGlyph_localtype;
Define_Module_ClassRef(panda3d.core, GeomTextGlyph, GeomTextGlyph_localtype, GeomTextGlyph);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomTextGlyph = &Dtool_GeomTextGlyph;
static void Dtool_PyModuleClassInit_GeomTextGlyph(PyObject *module);

/**
 * Forward declarations for top-level class StaticTextFont
 */
typedef StaticTextFont StaticTextFont_localtype;
Define_Module_ClassRef(panda3d.core, StaticTextFont, StaticTextFont_localtype, StaticTextFont);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StaticTextFont = &Dtool_StaticTextFont;
static void Dtool_PyModuleClassInit_StaticTextFont(PyObject *module);
bool Dtool_ConstCoerce_StaticTextFont(PyObject *args, CPT(StaticTextFont) &coerced);
bool Dtool_Coerce_StaticTextFont(PyObject *args, PT(StaticTextFont) &coerced);

/**
 * Forward declarations for top-level class TextProperties
 */
typedef TextProperties TextProperties_localtype;
Define_Module_Class(panda3d.core, TextProperties, TextProperties_localtype, TextProperties);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextProperties = &Dtool_TextProperties;
static void Dtool_PyModuleClassInit_TextProperties(PyObject *module);

/**
 * Forward declarations for top-level class TextGraphic
 */
typedef TextGraphic TextGraphic_localtype;
Define_Module_Class(panda3d.core, TextGraphic, TextGraphic_localtype, TextGraphic);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextGraphic = &Dtool_TextGraphic;
static void Dtool_PyModuleClassInit_TextGraphic(PyObject *module);

/**
 * Forward declarations for top-level class TextPropertiesManager
 */
typedef TextPropertiesManager TextPropertiesManager_localtype;
Define_Module_Class_Private(panda3d.core, TextPropertiesManager, TextPropertiesManager_localtype, TextPropertiesManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextPropertiesManager = &Dtool_TextPropertiesManager;
static void Dtool_PyModuleClassInit_TextPropertiesManager(PyObject *module);

/**
 * Forward declarations for top-level class TextAssembler
 */
typedef TextAssembler TextAssembler_localtype;
Define_Module_Class(panda3d.core, TextAssembler, TextAssembler_localtype, TextAssembler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextAssembler = &Dtool_TextAssembler;
static void Dtool_PyModuleClassInit_TextAssembler(PyObject *module);

/**
 * Forward declarations for top-level class TextNode
 */
typedef TextNode TextNode_localtype;
Define_Module_ClassRef(panda3d.core, TextNode, TextNode_localtype, TextNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextNode = &Dtool_TextNode;
static void Dtool_PyModuleClassInit_TextNode(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"TextGlyph", &Dtool_TextGlyph},
  {"TextFont", &Dtool_TextFont},
  {"DynamicTextGlyph", &Dtool_DynamicTextGlyph},
  {"DynamicTextPage", &Dtool_DynamicTextPage},
  {"DynamicTextFont", &Dtool_DynamicTextFont},
  {"FontPool", &Dtool_FontPool},
  {"GeomTextGlyph", &Dtool_GeomTextGlyph},
  {"StaticTextFont", &Dtool_StaticTextFont},
  {"TextProperties", &Dtool_TextProperties},
  {"TextGraphic", &Dtool_TextGraphic},
  {"TextPropertiesManager", &Dtool_TextPropertiesManager},
  {"TextAssembler", &Dtool_TextAssembler},
  {"TextNode", &Dtool_TextNode},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TextEncoder", nullptr},
#define Dtool_Ptr_TextEncoder (imports[2].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[3].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[4].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[5].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[6].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[7].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[8].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[9].type)
  {"CachedTypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_CachedTypedWritableReferenceCount (imports[10].type)
  {"LVecBase2f", nullptr},
#define Dtool_Ptr_LVecBase2f (imports[11].type)
  {"LVecBase2i", nullptr},
#define Dtool_Ptr_LVecBase2i (imports[12].type)
  {"LVector2f", nullptr},
#define Dtool_Ptr_LVector2f (imports[13].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[14].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[15].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[16].type)
  {"GeomEnums", nullptr},
#define Dtool_Ptr_GeomEnums (imports[17].type)
  {"Texture", nullptr},
#define Dtool_Ptr_Texture (imports[18].type)
  {"CopyOnWriteObject", nullptr},
#define Dtool_Ptr_CopyOnWriteObject (imports[19].type)
  {"Geom", nullptr},
#define Dtool_Ptr_Geom (imports[20].type)
  {"RenderState", nullptr},
#define Dtool_Ptr_RenderState (imports[21].type)
  {"FreetypeFont", nullptr},
#define Dtool_Ptr_FreetypeFont (imports[22].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[23].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[24].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TextEncoder
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TextEncoder;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextEncoder = &Dtool_TextEncoder;
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// CachedTypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CachedTypedWritableReferenceCount = &Dtool_CachedTypedWritableReferenceCount;
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LVector2f
#ifndef LINK_ALL_STATIC
inline static LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced) {
  nassertr(Dtool_Ptr_LVector2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector2f *(*)(PyObject *, LVector2f &))Dtool_Ptr_LVector2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2f = &Dtool_LVector2f;
extern LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// GeomEnums
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GeomEnums;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomEnums = &Dtool_GeomEnums;
#endif
// Texture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// CopyOnWriteObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CopyOnWriteObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CopyOnWriteObject = &Dtool_CopyOnWriteObject;
#endif
// Geom
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Geom;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Geom = &Dtool_Geom;
#endif
// RenderState
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced) {
  nassertr(Dtool_Ptr_RenderState != nullptr, false);
  nassertr(Dtool_Ptr_RenderState->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(RenderState) &))Dtool_Ptr_RenderState->_Dtool_ConstCoerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_RenderState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderState = &Dtool_RenderState;
extern bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced);
#endif
// FreetypeFont
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_FreetypeFont;
static struct Dtool_PyTypedObject *const Dtool_Ptr_FreetypeFont = &Dtool_FreetypeFont;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class TextGlyph
 */
/**
 * Python function wrapper for:
 * inline int TextGlyph::get_character(void) const
 */
static PyObject *Dtool_TextGlyph_get_character_3(PyObject *self, PyObject *) {
  TextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextGlyph)) {
    return nullptr;
  }
  // 1-inline int TextGlyph::get_character(void) const
  int return_value = ((*(const TextGlyph*)local_this).get_character)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_character_3_comment =
  "C++ Interface:\n"
  "get_character(TextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the Unicode value that corresponds to the character this glyph\n"
  " * represents.\n"
  " */";
#else
static const char *Dtool_TextGlyph_get_character_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextGlyph::has_quad(void) const
 */
static PyObject *Dtool_TextGlyph_has_quad_4(PyObject *self, PyObject *) {
  TextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextGlyph)) {
    return nullptr;
  }
  // 1-inline bool TextGlyph::has_quad(void) const
  bool return_value = ((*(const TextGlyph*)local_this).has_quad)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_has_quad_4_comment =
  "C++ Interface:\n"
  "has_quad(TextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns true if this glyph contains the definition for a simple quad,\n"
  " * rather than a more complex piece of geometry.\n"
  " *\n"
  " * You may still call get_geom() even if this returns true, which will\n"
  " * synthesize a Geom for this quad.\n"
  " */";
#else
static const char *Dtool_TextGlyph_has_quad_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextGlyph::get_quad(LVecBase4 &dimensions, LVecBase4 &texcoords) const
 */
static PyObject *Dtool_TextGlyph_get_quad_5(PyObject *self, PyObject *args, PyObject *kwds) {
  TextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextGlyph)) {
    return nullptr;
  }
  // 1-inline bool TextGlyph::get_quad(LVecBase4 &dimensions, LVecBase4 &texcoords) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"dimensions", "texcoords", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_quad", (char **)keyword_list, &param1, &param2)) {
    LVecBase4f param1_local;
    LVecBase4 *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TextGlyph.get_quad", "LVecBase4f");
    }
    LVecBase4f param2_local;
    LVecBase4 *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TextGlyph.get_quad", "LVecBase4f");
    }
    bool return_value = ((*(const TextGlyph*)local_this).get_quad)(*param1_this, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_quad(TextGlyph self, LVecBase4f dimensions, LVecBase4f texcoords)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_quad_5_comment =
  "C++ Interface:\n"
  "get_quad(TextGlyph self, LVecBase4f dimensions, LVecBase4f texcoords)\n"
  "\n"
  "/**\n"
  " * Assuming that this glyph is representable as a textured quad, returns its\n"
  " * dimensions and UV range.  Returns false if it is not representable as a\n"
  " * quad, or if it is whitespace.\n"
  " *\n"
  " * The order of the components is left, bottom, right, top.\n"
  " */";
#else
static const char *Dtool_TextGlyph_get_quad_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RenderState const *TextGlyph::get_state(void) const
 */
static PyObject *Dtool_TextGlyph_get_state_6(PyObject *self, PyObject *) {
  TextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextGlyph)) {
    return nullptr;
  }
  // 1-inline RenderState const *TextGlyph::get_state(void) const
  RenderState const *return_value = ((*(const TextGlyph*)local_this).get_state)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_state_6_comment =
  "C++ Interface:\n"
  "get_state(TextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the state in which the glyph should be rendered.\n"
  " */";
#else
static const char *Dtool_TextGlyph_get_state_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextGlyph::get_advance(void) const
 */
static PyObject *Dtool_TextGlyph_get_advance_7(PyObject *self, PyObject *) {
  TextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextGlyph)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextGlyph::get_advance(void) const
  PN_stdfloat return_value = ((*(const TextGlyph*)local_this).get_advance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_advance_7_comment =
  "C++ Interface:\n"
  "get_advance(TextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the distance by which the character pointer should be advanced\n"
  " * after placing this character; i.e.  the approximate width the character\n"
  " * takes up on the line.\n"
  " */";
#else
static const char *Dtool_TextGlyph_get_advance_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool TextGlyph::is_whitespace(void) const
 */
static PyObject *Dtool_TextGlyph_is_whitespace_17(PyObject *self, PyObject *) {
  TextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextGlyph)) {
    return nullptr;
  }
  // 1-virtual bool TextGlyph::is_whitespace(void) const
  bool return_value = ((*(const TextGlyph*)local_this).is_whitespace)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_is_whitespace_17_comment =
  "C++ Interface:\n"
  "is_whitespace(TextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns true if this glyph represents invisible whitespace, or false if it\n"
  " * corresponds to some visible character.\n"
  " */";
#else
static const char *Dtool_TextGlyph_is_whitespace_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< Geom > TextGlyph::get_geom(GeomEnums::UsageHint usage_hint) const
 */
static PyObject *Dtool_TextGlyph_get_geom_18(PyObject *self, PyObject *arg) {
  TextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextGlyph)) {
    return nullptr;
  }
  // 1-PointerTo< Geom > TextGlyph::get_geom(GeomEnums::UsageHint usage_hint) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< Geom > return_value = ((*(const TextGlyph*)local_this).get_geom)((GeomEnums::UsageHint)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    Geom *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geom(TextGlyph self, int usage_hint)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_geom_18_comment =
  "C++ Interface:\n"
  "get_geom(TextGlyph self, int usage_hint)\n"
  "\n"
  "/**\n"
  " * Returns a Geom that renders the particular glyph.  It will be generated if\n"
  " * necessary.\n"
  " *\n"
  " * This method will always return a copy of the Geom, so the caller is free to\n"
  " * modify it.\n"
  " */";
#else
static const char *Dtool_TextGlyph_get_geom_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextGlyph::get_class_type(void)
 */
static PyObject *Dtool_TextGlyph_get_class_type_19(PyObject *, PyObject *) {
  // 1-static TypeHandle TextGlyph::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TextGlyph::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_class_type_19_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextGlyph_get_class_type_19_comment = nullptr;
#endif

static PyObject *Dtool_TextGlyph_character_Getter(PyObject *self, void *) {
  const TextGlyph *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TextGlyph::get_character(void) const
  int return_value = ((*(const TextGlyph*)local_this).get_character)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TextGlyph_state_Getter(PyObject *self, void *) {
  const TextGlyph *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline RenderState const *TextGlyph::get_state(void) const
  RenderState const *return_value = ((*(const TextGlyph*)local_this).get_state)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_TextGlyph_advance_Getter(PyObject *self, void *) {
  const TextGlyph *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat TextGlyph::get_advance(void) const
  PN_stdfloat return_value = ((*(const TextGlyph*)local_this).get_advance)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_TextGlyph(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TextGlyph(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextGlyph) {
    printf("TextGlyph ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextGlyph *local_this = (TextGlyph *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextGlyph) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextGlyph(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextGlyph) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (TextGlyph*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextFont
 */
/**
 * Python function wrapper for:
 * virtual PointerTo< TextFont > TextFont::make_copy(void) const = 0
 */
static PyObject *Dtool_TextFont_make_copy_28(PyObject *self, PyObject *) {
  TextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextFont)) {
    return nullptr;
  }
  // 1-virtual PointerTo< TextFont > TextFont::make_copy(void) const = 0
  PointerTo< TextFont > return_value = ((*(const TextFont*)local_this).make_copy)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TextFont *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TextFont, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextFont_make_copy_28_comment =
  "C++ Interface:\n"
  "make_copy(TextFont self)\n";
#else
static const char *Dtool_TextFont_make_copy_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextFont::is_valid(void) const
 */
static PyObject *Dtool_TextFont_is_valid_29(PyObject *self, PyObject *) {
  TextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextFont)) {
    return nullptr;
  }
  // 1-inline bool TextFont::is_valid(void) const
  bool return_value = ((*(const TextFont*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextFont_is_valid_29_comment =
  "C++ Interface:\n"
  "is_valid(TextFont self)\n"
  "\n"
  "/**\n"
  " * Returns true if the font is valid and ready to use, false otherwise.\n"
  " */";
#else
static const char *Dtool_TextFont_is_valid_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextFont::get_line_height(void) const
 */
static PyObject *Dtool_TextFont_get_line_height_31(PyObject *self, PyObject *) {
  TextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextFont::get_line_height(void) const
  PN_stdfloat return_value = ((*(const TextFont*)local_this).get_line_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextFont_get_line_height_31_comment =
  "C++ Interface:\n"
  "get_line_height(TextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units high each line of text is.\n"
  " */";
#else
static const char *Dtool_TextFont_get_line_height_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextFont::set_line_height(PN_stdfloat line_height)
 */
static PyObject *Dtool_TextFont_set_line_height_32(PyObject *self, PyObject *arg) {
  TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.set_line_height")) {
    return nullptr;
  }
  // 1-inline void TextFont::set_line_height(PN_stdfloat line_height)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_line_height)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_line_height(const TextFont self, float line_height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextFont_set_line_height_32_comment =
  "C++ Interface:\n"
  "set_line_height(const TextFont self, float line_height)\n"
  "\n"
  "/**\n"
  " * Changes the number of units high each line of text is.\n"
  " */";
#else
static const char *Dtool_TextFont_set_line_height_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextFont::get_space_advance(void) const
 */
static PyObject *Dtool_TextFont_get_space_advance_36(PyObject *self, PyObject *) {
  TextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextFont::get_space_advance(void) const
  PN_stdfloat return_value = ((*(const TextFont*)local_this).get_space_advance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextFont_get_space_advance_36_comment =
  "C++ Interface:\n"
  "get_space_advance(TextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units wide a space is.\n"
  " */";
#else
static const char *Dtool_TextFont_get_space_advance_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextFont::set_space_advance(PN_stdfloat space_advance)
 */
static PyObject *Dtool_TextFont_set_space_advance_37(PyObject *self, PyObject *arg) {
  TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.set_space_advance")) {
    return nullptr;
  }
  // 1-inline void TextFont::set_space_advance(PN_stdfloat space_advance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_space_advance)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_space_advance(const TextFont self, float space_advance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextFont_set_space_advance_37_comment =
  "C++ Interface:\n"
  "set_space_advance(const TextFont self, float space_advance)\n"
  "\n"
  "/**\n"
  " * Changes the number of units wide a space is.\n"
  " */";
#else
static const char *Dtool_TextFont_set_space_advance_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< TextGlyph > TextFont::get_glyph(int character)
 */
static PyObject *Dtool_TextFont_get_glyph_39(PyObject *self, PyObject *arg) {
  TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.get_glyph")) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< TextGlyph > TextFont::get_glyph(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< TextGlyph > return_value = ((*local_this).get_glyph)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    TextGlyph const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TextGlyph, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_glyph(const TextFont self, int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextFont_get_glyph_39_comment =
  "C++ Interface:\n"
  "get_glyph(const TextFont self, int character)\n"
  "\n"
  "/**\n"
  " * Gets the glyph associated with the given character code, as well as an\n"
  " * optional scaling parameter that should be applied to the glyph's geometry\n"
  " * and advance parameters.  Returns the glyph on success.  On failure, it may\n"
  " * still return a printable glyph, or it may return NULL.\n"
  " */";
#else
static const char *Dtool_TextFont_get_glyph_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat TextFont::get_kerning(int first, int second) const
 */
static PyObject *Dtool_TextFont_get_kerning_40(PyObject *self, PyObject *args, PyObject *kwds) {
  TextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextFont)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat TextFont::get_kerning(int first, int second) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"first", "second", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_kerning", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = ((*(const TextFont*)local_this).get_kerning)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_kerning(TextFont self, int first, int second)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextFont_get_kerning_40_comment =
  "C++ Interface:\n"
  "get_kerning(TextFont self, int first, int second)\n"
  "\n"
  "/**\n"
  " * Returns the amount by which to offset the second glyph when it directly\n"
  " * follows the first glyph.  This is an additional offset that is added on top\n"
  " * of the advance.\n"
  " */";
#else
static const char *Dtool_TextFont_get_kerning_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void TextFont::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_TextFont_write_41(PyObject *self, PyObject *args, PyObject *kwds) {
  TextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextFont)) {
    return nullptr;
  }
  // 1-virtual void TextFont::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "TextFont.write", false, true);
    if (param1_this != nullptr) {
      ((*(const TextFont*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TextFont self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextFont_write_41_comment =
  "C++ Interface:\n"
  "write(TextFont self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextFont_write_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextFont::get_class_type(void)
 */
static PyObject *Dtool_TextFont_get_class_type_42(PyObject *, PyObject *) {
  // 1-static TypeHandle TextFont::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TextFont::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextFont_get_class_type_42_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextFont_get_class_type_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *TextFont::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_TextFont_upcast_to_TypedReferenceCount_21(PyObject *self, PyObject *) {
  TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.upcast_to_TypedReferenceCount")) {
    return nullptr;
  }
  // 1-TypedReferenceCount *TextFont::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextFont_upcast_to_TypedReferenceCount_21_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const TextFont self)\n"
  "\n"
  "upcast from TextFont to TypedReferenceCount";
#else
static const char *Dtool_TextFont_upcast_to_TypedReferenceCount_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *TextFont::upcast_to_Namable(void)
 */
static PyObject *Dtool_TextFont_upcast_to_Namable_24(PyObject *self, PyObject *) {
  TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *TextFont::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TextFont_upcast_to_Namable_24_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const TextFont self)\n"
  "\n"
  "upcast from TextFont to Namable";
#else
static const char *Dtool_TextFont_upcast_to_Namable_24_comment = nullptr;
#endif

static PyObject *Dtool_TextFont_valid_Getter(PyObject *self, void *) {
  const TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool TextFont::is_valid(void) const
  bool return_value = ((*(const TextFont*)local_this).is_valid)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TextFont_line_height_Getter(PyObject *self, void *) {
  const TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat TextFont::get_line_height(void) const
  PN_stdfloat return_value = ((*(const TextFont*)local_this).get_line_height)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextFont_line_height_Setter(PyObject *self, PyObject *arg, void *) {
  TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.line_height")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete line_height attribute");
    return -1;
  }
  // 1-inline void TextFont::set_line_height(PN_stdfloat line_height)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_line_height)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_line_height(const TextFont self, float line_height)\n");
  }
  return -1;
}

static PyObject *Dtool_TextFont_space_advance_Getter(PyObject *self, void *) {
  const TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat TextFont::get_space_advance(void) const
  PN_stdfloat return_value = ((*(const TextFont*)local_this).get_space_advance)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextFont_space_advance_Setter(PyObject *self, PyObject *arg, void *) {
  TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.space_advance")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete space_advance attribute");
    return -1;
  }
  // 1-inline void TextFont::set_space_advance(PN_stdfloat space_advance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_space_advance)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_space_advance(const TextFont self, float space_advance)\n");
  }
  return -1;
}

static int Dtool_Init_TextFont(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TextFont(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextFont) {
    printf("TextFont ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextFont *local_this = (TextFont *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextFont) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextFont(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextFont) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (TextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (TextFont*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DynamicTextGlyph
 */
/**
 * Python function wrapper for:
 * inline DynamicTextPage *DynamicTextGlyph::get_page(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_page_44(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextGlyph)) {
    return nullptr;
  }
  // 1-inline DynamicTextPage *DynamicTextGlyph::get_page(void) const
  DynamicTextPage *return_value = ((*(const DynamicTextGlyph*)local_this).get_page)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextPage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_page_44_comment =
  "C++ Interface:\n"
  "get_page(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the DynamicTextPage that this glyph is on.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_page_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextGlyph::intersects(int x, int y, int x_size, int y_size) const
 */
static PyObject *Dtool_DynamicTextGlyph_intersects_56(PyObject *self, PyObject *args, PyObject *kwds) {
  DynamicTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextGlyph)) {
    return nullptr;
  }
  // 1-inline bool DynamicTextGlyph::intersects(int x, int y, int x_size, int y_size) const
  int param1;
  int param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"x", "y", "x_size", "y_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:intersects", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    bool return_value = ((*(const DynamicTextGlyph*)local_this).intersects)((int)param1, (int)param2, (int)param3, (int)param4);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "intersects(DynamicTextGlyph self, int x, int y, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_intersects_56_comment =
  "C++ Interface:\n"
  "intersects(DynamicTextGlyph self, int x, int y, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Returns true if the particular position this glyph has been assigned to\n"
  " * overlaps the rectangle whose top left corner is at x, y and whose size is\n"
  " * given by x_size, y_size, or false otherwise.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_intersects_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_left(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_left_57(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextGlyph)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_left(void) const
  PN_stdfloat return_value = ((*(const DynamicTextGlyph*)local_this).get_left)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_left_57_comment =
  "C++ Interface:\n"
  "get_left(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_left_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_bottom(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_bottom_58(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextGlyph)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_bottom(void) const
  PN_stdfloat return_value = ((*(const DynamicTextGlyph*)local_this).get_bottom)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_bottom_58_comment =
  "C++ Interface:\n"
  "get_bottom(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_bottom_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_right(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_right_59(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextGlyph)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_right(void) const
  PN_stdfloat return_value = ((*(const DynamicTextGlyph*)local_this).get_right)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_right_59_comment =
  "C++ Interface:\n"
  "get_right(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_right_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_top(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_top_60(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextGlyph)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_top(void) const
  PN_stdfloat return_value = ((*(const DynamicTextGlyph*)local_this).get_top)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_top_60_comment =
  "C++ Interface:\n"
  "get_top(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_top_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_uv_left(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_uv_left_61(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextGlyph)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_uv_left(void) const
  PN_stdfloat return_value = ((*(const DynamicTextGlyph*)local_this).get_uv_left)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_uv_left_61_comment =
  "C++ Interface:\n"
  "get_uv_left(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_uv_left_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_uv_bottom(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_uv_bottom_62(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextGlyph)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_uv_bottom(void) const
  PN_stdfloat return_value = ((*(const DynamicTextGlyph*)local_this).get_uv_bottom)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_uv_bottom_62_comment =
  "C++ Interface:\n"
  "get_uv_bottom(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_uv_bottom_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_uv_right(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_uv_right_63(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextGlyph)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_uv_right(void) const
  PN_stdfloat return_value = ((*(const DynamicTextGlyph*)local_this).get_uv_right)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_uv_right_63_comment =
  "C++ Interface:\n"
  "get_uv_right(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_uv_right_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_uv_top(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_uv_top_64(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextGlyph)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_uv_top(void) const
  PN_stdfloat return_value = ((*(const DynamicTextGlyph*)local_this).get_uv_top)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_uv_top_64_comment =
  "C++ Interface:\n"
  "get_uv_top(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_uv_top_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DynamicTextGlyph::get_class_type(void)
 */
static PyObject *Dtool_DynamicTextGlyph_get_class_type_65(PyObject *, PyObject *) {
  // 1-static TypeHandle DynamicTextGlyph::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DynamicTextGlyph::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_class_type_65_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DynamicTextGlyph_get_class_type_65_comment = nullptr;
#endif

static PyObject *Dtool_DynamicTextGlyph_page_Getter(PyObject *self, void *) {
  const DynamicTextGlyph *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline DynamicTextPage *DynamicTextGlyph::get_page(void) const
  DynamicTextPage *return_value = ((*(const DynamicTextGlyph*)local_this).get_page)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextPage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Init_DynamicTextGlyph(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DynamicTextGlyph(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DynamicTextGlyph) {
    printf("DynamicTextGlyph ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DynamicTextGlyph *local_this = (DynamicTextGlyph *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DynamicTextGlyph) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(TextGlyph *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextGlyph) {
    return (TextGlyph *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(TextGlyph *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(TextGlyph *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DynamicTextGlyph(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DynamicTextGlyph) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DynamicTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TextGlyph) {
    TextGlyph* other_this = (TextGlyph*)from_this;
    return (DynamicTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DynamicTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (DynamicTextGlyph*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DynamicTextPage
 */
/**
 * Python function wrapper for:
 * inline LVecBase2i const &DynamicTextPage::get_size(void) const
 */
static PyObject *Dtool_DynamicTextPage_get_size_49(PyObject *self, PyObject *) {
  DynamicTextPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextPage)) {
    return nullptr;
  }
  // 1-inline LVecBase2i const &DynamicTextPage::get_size(void) const
  LVecBase2i const *return_value = &(((*(const DynamicTextPage*)local_this).get_size)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextPage_get_size_49_comment =
  "C++ Interface:\n"
  "get_size(DynamicTextPage self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the page (texture), in pixels.\n"
  " */";
#else
static const char *Dtool_DynamicTextPage_get_size_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextPage::get_x_size(void) const
 */
static PyObject *Dtool_DynamicTextPage_get_x_size_50(PyObject *self, PyObject *) {
  DynamicTextPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextPage)) {
    return nullptr;
  }
  // 1-inline int DynamicTextPage::get_x_size(void) const
  int return_value = ((*(const DynamicTextPage*)local_this).get_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextPage_get_x_size_50_comment =
  "C++ Interface:\n"
  "get_x_size(DynamicTextPage self)\n"
  "\n"
  "/**\n"
  " * Returns the x size of the page (texture), in pixels.\n"
  " */";
#else
static const char *Dtool_DynamicTextPage_get_x_size_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextPage::get_y_size(void) const
 */
static PyObject *Dtool_DynamicTextPage_get_y_size_51(PyObject *self, PyObject *) {
  DynamicTextPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextPage)) {
    return nullptr;
  }
  // 1-inline int DynamicTextPage::get_y_size(void) const
  int return_value = ((*(const DynamicTextPage*)local_this).get_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextPage_get_y_size_51_comment =
  "C++ Interface:\n"
  "get_y_size(DynamicTextPage self)\n"
  "\n"
  "/**\n"
  " * Returns the y size of the page (texture), in pixels.\n"
  " */";
#else
static const char *Dtool_DynamicTextPage_get_y_size_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextPage::is_empty(void) const
 */
static PyObject *Dtool_DynamicTextPage_is_empty_52(PyObject *self, PyObject *) {
  DynamicTextPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextPage)) {
    return nullptr;
  }
  // 1-inline bool DynamicTextPage::is_empty(void) const
  bool return_value = ((*(const DynamicTextPage*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextPage_is_empty_52_comment =
  "C++ Interface:\n"
  "is_empty(DynamicTextPage self)\n"
  "\n"
  "/**\n"
  " * Returns true if the page has no glyphs, false otherwise.\n"
  " */";
#else
static const char *Dtool_DynamicTextPage_is_empty_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DynamicTextPage::get_class_type(void)
 */
static PyObject *Dtool_DynamicTextPage_get_class_type_53(PyObject *, PyObject *) {
  // 1-static TypeHandle DynamicTextPage::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DynamicTextPage::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextPage_get_class_type_53_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DynamicTextPage_get_class_type_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DynamicTextPage::DynamicTextPage(DynamicTextPage const &) = default
 */
static int Dtool_Init_DynamicTextPage(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DynamicTextPage() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline DynamicTextPage::DynamicTextPage(DynamicTextPage const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    DynamicTextPage const *param0_this = (DynamicTextPage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_DynamicTextPage, 0, "DynamicTextPage.DynamicTextPage", true, true);
    if (param0_this != nullptr) {
      DynamicTextPage *return_value = new DynamicTextPage(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextPage, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DynamicTextPage(const DynamicTextPage param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DynamicTextPage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DynamicTextPage) {
    printf("DynamicTextPage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DynamicTextPage *local_this = (DynamicTextPage *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DynamicTextPage) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_Texture) {
    return (Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(Texture *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DynamicTextPage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DynamicTextPage) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (DynamicTextPage*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DynamicTextPage*)other_this;
  }
  if (from_type == Dtool_Ptr_Texture) {
    Texture* other_this = (Texture*)from_this;
    return (DynamicTextPage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DynamicTextPage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (DynamicTextPage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (DynamicTextPage*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DynamicTextFont
 */
/**
 * Python function wrapper for:
 * virtual PointerTo< TextFont > DynamicTextFont::make_copy(void) const
 */
static PyObject *Dtool_DynamicTextFont_make_copy_74(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-virtual PointerTo< TextFont > DynamicTextFont::make_copy(void) const
  PointerTo< TextFont > return_value = ((*(const DynamicTextFont*)local_this).make_copy)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TextFont *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TextFont, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_make_copy_74_comment =
  "C++ Interface:\n"
  "make_copy(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns a new copy of the same font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_make_copy_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &DynamicTextFont::get_name(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_name_75(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline std::string const &DynamicTextFont::get_name(void) const
  std::string const &return_value = ((*(const DynamicTextFont*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_name_75_comment =
  "C++ Interface:\n"
  "get_name(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Disambiguates the get_name() method between that inherited from TextFont\n"
  " * and that inherited from FreetypeFont.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_name_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextFont::set_point_size(PN_stdfloat point_size)
 */
static PyObject *Dtool_DynamicTextFont_set_point_size_76(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_point_size")) {
    return nullptr;
  }
  // 1-inline bool DynamicTextFont::set_point_size(PN_stdfloat point_size)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_point_size)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_size(const DynamicTextFont self, float point_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_point_size_76_comment =
  "C++ Interface:\n"
  "set_point_size(const DynamicTextFont self, float point_size)\n"
  "\n"
  "/**\n"
  " * Sets the point size of the font.  This controls the apparent size of the\n"
  " * font onscreen.  By convention, a 10 point font is about 1 screen unit high.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_point_size_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_point_size(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_point_size_77(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_point_size(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_point_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_point_size_77_comment =
  "C++ Interface:\n"
  "get_point_size(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the point size of the font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_point_size_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextFont::set_pixels_per_unit(PN_stdfloat pixels_per_unit)
 */
static PyObject *Dtool_DynamicTextFont_set_pixels_per_unit_79(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_pixels_per_unit")) {
    return nullptr;
  }
  // 1-inline bool DynamicTextFont::set_pixels_per_unit(PN_stdfloat pixels_per_unit)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_pixels_per_unit)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pixels_per_unit(const DynamicTextFont self, float pixels_per_unit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_pixels_per_unit_79_comment =
  "C++ Interface:\n"
  "set_pixels_per_unit(const DynamicTextFont self, float pixels_per_unit)\n"
  "\n"
  "/**\n"
  " * Set the resolution of the texture map, and hence the clarity of the\n"
  " * resulting font.  This sets the number of pixels in the texture map that are\n"
  " * used for each onscreen unit.\n"
  " *\n"
  " * Setting this number larger results in an easier to read font, but at the\n"
  " * cost of more texture memory.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_pixels_per_unit_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_pixels_per_unit(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_pixels_per_unit_80(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_pixels_per_unit(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_pixels_per_unit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_pixels_per_unit_80_comment =
  "C++ Interface:\n"
  "get_pixels_per_unit(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the resolution of the texture map.  See set_pixels_per_unit().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_pixels_per_unit_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextFont::set_scale_factor(PN_stdfloat scale_factor)
 */
static PyObject *Dtool_DynamicTextFont_set_scale_factor_82(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_scale_factor")) {
    return nullptr;
  }
  // 1-inline bool DynamicTextFont::set_scale_factor(PN_stdfloat scale_factor)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_scale_factor)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_factor(const DynamicTextFont self, float scale_factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_scale_factor_82_comment =
  "C++ Interface:\n"
  "set_scale_factor(const DynamicTextFont self, float scale_factor)\n"
  "\n"
  "/**\n"
  " * Sets the factor by which the font is rendered larger by the FreeType\n"
  " * library before being filtered down to its actual size in the texture as\n"
  " * specified by set_pixels_per_unit().  This may be set to a number larger\n"
  " * than 1.0 to improve the font's antialiasing (since FreeType doesn't really\n"
  " * do a swell job of antialiasing by itself).  There is some performance\n"
  " * implication for setting this different than 1.0, but it is probably small.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_scale_factor_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_scale_factor(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_scale_factor_83(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_scale_factor(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_scale_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_scale_factor_83_comment =
  "C++ Interface:\n"
  "get_scale_factor(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the antialiasing scale factor.  See set_scale_factor().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_scale_factor_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_native_antialias(bool native_antialias)
 */
static PyObject *Dtool_DynamicTextFont_set_native_antialias_85(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_native_antialias")) {
    return nullptr;
  }
  // 1-inline void DynamicTextFont::set_native_antialias(bool native_antialias)
  ((*local_this).set_native_antialias)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_native_antialias(const DynamicTextFont self, bool native_antialias)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_native_antialias_85_comment =
  "C++ Interface:\n"
  "set_native_antialias(const DynamicTextFont self, bool native_antialias)\n"
  "\n"
  "/**\n"
  " * Sets whether the Freetype library's built-in antialias mode is enabled.\n"
  " * There are two unrelated ways to achieve antialiasing: with Freetype's\n"
  " * native antialias mode, and with the use of a scale_factor greater than one.\n"
  " * By default, both modes are enabled.\n"
  " *\n"
  " * At low resolutions, some fonts may do better with one mode or the other.\n"
  " * In general, Freetype's native antialiasing will produce less blurry\n"
  " * results, but may introduce more artifacts.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_native_antialias_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextFont::get_native_antialias(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_native_antialias_86(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline bool DynamicTextFont::get_native_antialias(void) const
  bool return_value = ((*(const DynamicTextFont*)local_this).get_native_antialias)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_native_antialias_86_comment =
  "C++ Interface:\n"
  "get_native_antialias(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns whether Freetype's built-in antialias mode is enabled.  See\n"
  " * set_native_antialias().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_native_antialias_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextFont::get_font_pixel_size(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_font_pixel_size_88(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline int DynamicTextFont::get_font_pixel_size(void) const
  int return_value = ((*(const DynamicTextFont*)local_this).get_font_pixel_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_font_pixel_size_88_comment =
  "C++ Interface:\n"
  "get_font_pixel_size(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * This is used to report whether the requested pixel size is being only\n"
  " * approximated by a fixed-pixel-size font.  This returns 0 in the normal\n"
  " * case, in which a scalable font is used, or the fixed-pixel-size font has\n"
  " * exactly the requested pixel size.\n"
  " *\n"
  " * If this returns non-zero, it is the pixel size of the font that we are\n"
  " * using to approximate our desired size.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_font_pixel_size_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_line_height(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_line_height_90(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_line_height(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_line_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_line_height_90_comment =
  "C++ Interface:\n"
  "get_line_height(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units high each line of text is.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_line_height_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_space_advance(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_space_advance_91(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_space_advance(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_space_advance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_space_advance_91_comment =
  "C++ Interface:\n"
  "get_space_advance(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units wide a space is.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_space_advance_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_texture_margin(int texture_margin)
 */
static PyObject *Dtool_DynamicTextFont_set_texture_margin_92(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_texture_margin")) {
    return nullptr;
  }
  // 1-inline void DynamicTextFont::set_texture_margin(int texture_margin)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_texture_margin)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_margin(const DynamicTextFont self, int texture_margin)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_texture_margin_92_comment =
  "C++ Interface:\n"
  "set_texture_margin(const DynamicTextFont self, int texture_margin)\n"
  "\n"
  "/**\n"
  " * Sets the number of pixels of padding that is added around the border of\n"
  " * each glyph before adding it to the texture map.  This reduces the bleed in\n"
  " * from neighboring glyphs in the texture map.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_texture_margin_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextFont::get_texture_margin(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_texture_margin_93(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline int DynamicTextFont::get_texture_margin(void) const
  int return_value = ((*(const DynamicTextFont*)local_this).get_texture_margin)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_texture_margin_93_comment =
  "C++ Interface:\n"
  "get_texture_margin(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pixels of padding that is added around the border of\n"
  " * each glyph in the texture map.  See set_texture_margin().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_texture_margin_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_poly_margin(PN_stdfloat poly_margin)
 */
static PyObject *Dtool_DynamicTextFont_set_poly_margin_94(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_poly_margin")) {
    return nullptr;
  }
  // 1-inline void DynamicTextFont::set_poly_margin(PN_stdfloat poly_margin)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_poly_margin)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_poly_margin(const DynamicTextFont self, float poly_margin)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_poly_margin_94_comment =
  "C++ Interface:\n"
  "set_poly_margin(const DynamicTextFont self, float poly_margin)\n"
  "\n"
  "/**\n"
  " * Sets the number of pixels of padding that is included around each glyph in\n"
  " * the generated polygons.  This helps prevent the edges of the glyphs from\n"
  " * being cut off at small minifications.  It is not related to the amount of\n"
  " * extra pixels reserved in the texture map (but it should be set somewhat\n"
  " * smaller than this number, which is controlled by set_texture_margin(), to\n"
  " * prevent bleed-in from neighboring letters in the texture).\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_poly_margin_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_poly_margin(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_poly_margin_95(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_poly_margin(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_poly_margin)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_poly_margin_95_comment =
  "C++ Interface:\n"
  "get_poly_margin(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pixels of padding that is included around each glyph\n"
  " * in the generated polygons.  See set_poly_margin().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_poly_margin_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_page_size(LVecBase2i const &page_size)
 * inline void DynamicTextFont::set_page_size(int x_size, int y_size)
 */
static PyObject *Dtool_DynamicTextFont_set_page_size_98(PyObject *self, PyObject *args, PyObject *kwds) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_page_size")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "page_size")) {
        // 1-inline void DynamicTextFont::set_page_size(LVecBase2i const &page_size)
        LVecBase2i arg_local;
        LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_page_size", "LVecBase2i");
        }
        ((*local_this).set_page_size)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void DynamicTextFont::set_page_size(int x_size, int y_size)
      int param1;
      int param2;
      static const char *keyword_list[] = {"x_size", "y_size", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_page_size", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_page_size)((int)param1, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_page_size() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_page_size(const DynamicTextFont self, const LVecBase2i page_size)\n"
      "set_page_size(const DynamicTextFont self, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_page_size_98_comment =
  "C++ Interface:\n"
  "set_page_size(const DynamicTextFont self, const LVecBase2i page_size)\n"
  "set_page_size(const DynamicTextFont self, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Sets the x, y size of the textures that are created for the\n"
  " * DynamicTextFont.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the x, y size of the textures that are created for the\n"
  " * DynamicTextFont.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_page_size_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i const &DynamicTextFont::get_page_size(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_page_size_99(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline LVecBase2i const &DynamicTextFont::get_page_size(void) const
  LVecBase2i const *return_value = &(((*(const DynamicTextFont*)local_this).get_page_size)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_page_size_99_comment =
  "C++ Interface:\n"
  "get_page_size(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the textures that are created for the DynamicTextFont.\n"
  " * See set_page_size().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_page_size_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextFont::get_page_x_size(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_page_x_size_100(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline int DynamicTextFont::get_page_x_size(void) const
  int return_value = ((*(const DynamicTextFont*)local_this).get_page_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_page_x_size_100_comment =
  "C++ Interface:\n"
  "get_page_x_size(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the x size of the textures that are created for the\n"
  " * DynamicTextFont.  See set_page_size().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_page_x_size_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextFont::get_page_y_size(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_page_y_size_101(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline int DynamicTextFont::get_page_y_size(void) const
  int return_value = ((*(const DynamicTextFont*)local_this).get_page_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_page_y_size_101_comment =
  "C++ Interface:\n"
  "get_page_y_size(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the y size of the textures that are created for the\n"
  " * DynamicTextFont.  See set_page_size().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_page_y_size_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_minfilter(SamplerState::FilterType filter)
 */
static PyObject *Dtool_DynamicTextFont_set_minfilter_105(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_minfilter")) {
    return nullptr;
  }
  // 1-inline void DynamicTextFont::set_minfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_minfilter)((SamplerState::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_minfilter(const DynamicTextFont self, int filter)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_minfilter_105_comment =
  "C++ Interface:\n"
  "set_minfilter(const DynamicTextFont self, int filter)\n"
  "\n"
  "/**\n"
  " * Sets the filter type used when minimizing the textures created for this\n"
  " * font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_minfilter_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::FilterType DynamicTextFont::get_minfilter(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_minfilter_106(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline SamplerState::FilterType DynamicTextFont::get_minfilter(void) const
  SamplerState::FilterType return_value = ((*(const DynamicTextFont*)local_this).get_minfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_minfilter_106_comment =
  "C++ Interface:\n"
  "get_minfilter(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the filter type used when minimizing the textures created for this\n"
  " * font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_minfilter_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_magfilter(SamplerState::FilterType filter)
 */
static PyObject *Dtool_DynamicTextFont_set_magfilter_107(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_magfilter")) {
    return nullptr;
  }
  // 1-inline void DynamicTextFont::set_magfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_magfilter)((SamplerState::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_magfilter(const DynamicTextFont self, int filter)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_magfilter_107_comment =
  "C++ Interface:\n"
  "set_magfilter(const DynamicTextFont self, int filter)\n"
  "\n"
  "/**\n"
  " * Sets the filter type used when enlarging the textures created for this\n"
  " * font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_magfilter_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::FilterType DynamicTextFont::get_magfilter(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_magfilter_108(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline SamplerState::FilterType DynamicTextFont::get_magfilter(void) const
  SamplerState::FilterType return_value = ((*(const DynamicTextFont*)local_this).get_magfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_magfilter_108_comment =
  "C++ Interface:\n"
  "get_magfilter(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the filter type used when enlarging the textures created for this\n"
  " * font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_magfilter_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_anisotropic_degree(int anisotropic_degree)
 */
static PyObject *Dtool_DynamicTextFont_set_anisotropic_degree_109(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_anisotropic_degree")) {
    return nullptr;
  }
  // 1-inline void DynamicTextFont::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_anisotropic_degree)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const DynamicTextFont self, int anisotropic_degree)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_anisotropic_degree_109_comment =
  "C++ Interface:\n"
  "set_anisotropic_degree(const DynamicTextFont self, int anisotropic_degree)\n"
  "\n"
  "/**\n"
  " * Enables or disables anisotropic filtering on the textures created for this\n"
  " * font.  The default value is specified by the text-anisotropic-degree\n"
  " * variable.  See Texture::set_anisotropic_degree().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_anisotropic_degree_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextFont::get_anisotropic_degree(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_anisotropic_degree_110(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline int DynamicTextFont::get_anisotropic_degree(void) const
  int return_value = ((*(const DynamicTextFont*)local_this).get_anisotropic_degree)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_anisotropic_degree_110_comment =
  "C++ Interface:\n"
  "get_anisotropic_degree(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the current anisotropic degree for textures created for this font.\n"
  " * See set_anisotropic_degree().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_anisotropic_degree_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_render_mode(TextFont::RenderMode render_mode)
 */
static PyObject *Dtool_DynamicTextFont_set_render_mode_116(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_render_mode")) {
    return nullptr;
  }
  // 1-inline void DynamicTextFont::set_render_mode(TextFont::RenderMode render_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_render_mode)((TextFont::RenderMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_mode(const DynamicTextFont self, int render_mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_render_mode_116_comment =
  "C++ Interface:\n"
  "set_render_mode(const DynamicTextFont self, int render_mode)\n"
  "\n"
  "/**\n"
  " * Specifies the way the glyphs on this particular font are generated.  The\n"
  " * default is RM_texture, which is the only mode supported for bitmap fonts.\n"
  " * Other modes are possible for most modern fonts.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_render_mode_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextFont::RenderMode DynamicTextFont::get_render_mode(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_render_mode_117(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline TextFont::RenderMode DynamicTextFont::get_render_mode(void) const
  TextFont::RenderMode return_value = ((*(const DynamicTextFont*)local_this).get_render_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_render_mode_117_comment =
  "C++ Interface:\n"
  "get_render_mode(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the way the glyphs on this particular font are generated.  See\n"
  " * set_render_mode().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_render_mode_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_fg(LColor const &fg)
 */
static PyObject *Dtool_DynamicTextFont_set_fg_119(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_fg")) {
    return nullptr;
  }
  // 1-inline void DynamicTextFont::set_fg(LColor const &fg)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_fg", "LVecBase4f");
  }
  ((*local_this).set_fg)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fg(const DynamicTextFont self, const LVecBase4f fg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_fg_119_comment =
  "C++ Interface:\n"
  "set_fg(const DynamicTextFont self, const LVecBase4f fg)\n"
  "\n"
  "/**\n"
  " * Changes the color of the foreground pixels of the font as they are rendered\n"
  " * into the font texture.  The default is (1, 1, 1, 1), or opaque white, which\n"
  " * allows text created with the font to be colored individually.  Normally,\n"
  " * you would not change this unless you really need a particular color effect\n"
  " * to appear in the font itself.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_fg_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &DynamicTextFont::get_fg(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_fg_120(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline LColor const &DynamicTextFont::get_fg(void) const
  LColor const *return_value = &(((*(const DynamicTextFont*)local_this).get_fg)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_fg_120_comment =
  "C++ Interface:\n"
  "get_fg(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the color of the foreground pixels of the font as they are rendered\n"
  " * into the font texture.  See set_fg().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_fg_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_bg(LColor const &bg)
 */
static PyObject *Dtool_DynamicTextFont_set_bg_121(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_bg")) {
    return nullptr;
  }
  // 1-inline void DynamicTextFont::set_bg(LColor const &bg)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_bg", "LVecBase4f");
  }
  ((*local_this).set_bg)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bg(const DynamicTextFont self, const LVecBase4f bg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_bg_121_comment =
  "C++ Interface:\n"
  "set_bg(const DynamicTextFont self, const LVecBase4f bg)\n"
  "\n"
  "/**\n"
  " * Changes the color of the background pixels of the font as they are rendered\n"
  " * into the font texture.  The default is (1, 1, 1, 0), or transparent white,\n"
  " * which allows text created with the font to be colored individually.  (Note\n"
  " * that it should not generally be (0, 0, 0, 0), which would tend to bleed\n"
  " * into the foreground color, unless you have also specified a outline color\n"
  " * of (0, 0, 0, 1)) .\n"
  " *\n"
  " * Normally, you would not change this unless you really need a particular\n"
  " * color effect to appear in the font itself.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_bg_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &DynamicTextFont::get_bg(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_bg_122(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline LColor const &DynamicTextFont::get_bg(void) const
  LColor const *return_value = &(((*(const DynamicTextFont*)local_this).get_bg)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_bg_122_comment =
  "C++ Interface:\n"
  "get_bg(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the color of the background pixels of the font as they are rendered\n"
  " * into the font texture.  See set_bg().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_bg_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_outline(LColor const &outline_color, PN_stdfloat outline_width, PN_stdfloat outline_feather)
 */
static PyObject *Dtool_DynamicTextFont_set_outline_123(PyObject *self, PyObject *args, PyObject *kwds) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_outline")) {
    return nullptr;
  }
  // 1-inline void DynamicTextFont::set_outline(LColor const &outline_color, PN_stdfloat outline_width, PN_stdfloat outline_feather)
  PyObject *param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"outline_color", "outline_width", "outline_feather", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:set_outline", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase4f param1_local;
    LColor const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "DynamicTextFont.set_outline", "LVecBase4f");
    }
    ((*local_this).set_outline)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_outline(const DynamicTextFont self, const LVecBase4f outline_color, float outline_width, float outline_feather)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_outline_123_comment =
  "C++ Interface:\n"
  "set_outline(const DynamicTextFont self, const LVecBase4f outline_color, float outline_width, float outline_feather)\n"
  "\n"
  "/**\n"
  " * Sets up the font to have an outline around each font letter.  This is\n"
  " * achieved via a Gaussian post-process as each letter is generated; there is\n"
  " * some runtime cost for this effect, but it is minimal as each letter is\n"
  " * normally generated only once and then cached.\n"
  " *\n"
  " * The color is the desired color of the outline, width is the number of\n"
  " * points beyond the letter that the outline extends (a typical font is 10\n"
  " * points high), and feather is a number in the range 0.0 .. 1.0 that controls\n"
  " * the softness of the outline.  Set the width to 0.0 to disable the outline.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_outline_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &DynamicTextFont::get_outline_color(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_outline_color_124(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline LColor const &DynamicTextFont::get_outline_color(void) const
  LColor const *return_value = &(((*(const DynamicTextFont*)local_this).get_outline_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_outline_color_124_comment =
  "C++ Interface:\n"
  "get_outline_color(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the color of the outline pixels of the font as they are rendered\n"
  " * into the font texture.  See set_outline().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_outline_color_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_outline_width(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_outline_width_125(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_outline_width(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_outline_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_outline_width_125_comment =
  "C++ Interface:\n"
  "get_outline_width(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the width of the outline pixels of the font, as the number of\n"
  " * points beyond each letter.  See set_outline().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_outline_width_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_outline_feather(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_outline_feather_126(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_outline_feather(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_outline_feather)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_outline_feather_126_comment =
  "C++ Interface:\n"
  "get_outline_feather(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the softness of the outline pixels of the font, as a value in the\n"
  " * range 0.0 to 1.0. See set_outline().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_outline_feather_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture::Format DynamicTextFont::get_tex_format(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_tex_format_127(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-inline Texture::Format DynamicTextFont::get_tex_format(void) const
  Texture::Format return_value = ((*(const DynamicTextFont*)local_this).get_tex_format)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_tex_format_127_comment =
  "C++ Interface:\n"
  "get_tex_format(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the texture format used to render the individual pages.  This is\n"
  " * set automatically according to the colors selected.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_tex_format_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DynamicTextFont::get_num_pages(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_num_pages_136(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-int DynamicTextFont::get_num_pages(void) const
  int return_value = ((*(const DynamicTextFont*)local_this).get_num_pages)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_num_pages_136_comment =
  "C++ Interface:\n"
  "get_num_pages(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pages associated with the font.  Initially, the font\n"
  " * has zero pages; when the first piece of text is rendered with the font, it\n"
  " * will add additional pages as needed.  Each page is a Texture object that\n"
  " * contains the images for each of the glyphs currently in use somewhere.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_num_pages_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DynamicTextPage *DynamicTextFont::get_page(int n) const
 */
static PyObject *Dtool_DynamicTextFont_get_page_137(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-DynamicTextPage *DynamicTextFont::get_page(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DynamicTextPage *return_value = ((*(const DynamicTextFont*)local_this).get_page)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextPage, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_page(DynamicTextFont self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_page_137_comment =
  "C++ Interface:\n"
  "get_page(DynamicTextFont self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth page associated with the font.  Initially, the font has\n"
  " * zero pages; when the first piece of text is rendered with the font, it will\n"
  " * add additional pages as needed.  Each page is a Texture object that\n"
  " * contains the images for each of the glyphs currently in use somewhere.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_page_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DynamicTextFont::garbage_collect(void)
 */
static PyObject *Dtool_DynamicTextFont_garbage_collect_140(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.garbage_collect")) {
    return nullptr;
  }
  // 1-int DynamicTextFont::garbage_collect(void)
  int return_value = ((*local_this).garbage_collect)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_garbage_collect_140_comment =
  "C++ Interface:\n"
  "garbage_collect(const DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Removes all of the glyphs from the font that are no longer being used by\n"
  " * any Geoms.  Returns the number of glyphs removed.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_garbage_collect_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DynamicTextFont::clear(void)
 */
static PyObject *Dtool_DynamicTextFont_clear_141(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.clear")) {
    return nullptr;
  }
  // 1-void DynamicTextFont::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_clear_141_comment =
  "C++ Interface:\n"
  "clear(const DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Drops all the glyphs out of the cache and frees any association with any\n"
  " * previously-generated pages.\n"
  " *\n"
  " * Calling this frequently can result in wasted texture memory, as any\n"
  " * previously rendered text will still keep a pointer to the old, previously-\n"
  " * generated pages.  As long as the previously rendered text remains around,\n"
  " * the old pages will also remain around.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_clear_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DynamicTextFont::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_DynamicTextFont_write_142(PyObject *self, PyObject *args, PyObject *kwds) {
  DynamicTextFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DynamicTextFont)) {
    return nullptr;
  }
  // 1-virtual void DynamicTextFont::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DynamicTextFont.write", false, true);
    if (param1_this != nullptr) {
      ((*(const DynamicTextFont*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DynamicTextFont self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_write_142_comment =
  "C++ Interface:\n"
  "write(DynamicTextFont self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_write_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DynamicTextFont::get_class_type(void)
 */
static PyObject *Dtool_DynamicTextFont_get_class_type_143(PyObject *, PyObject *) {
  // 1-static TypeHandle DynamicTextFont::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DynamicTextFont::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_class_type_143_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DynamicTextFont_get_class_type_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextFont *DynamicTextFont::upcast_to_TextFont(void)
 */
static PyObject *Dtool_DynamicTextFont_upcast_to_TextFont_67(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.upcast_to_TextFont")) {
    return nullptr;
  }
  // 1-TextFont *DynamicTextFont::upcast_to_TextFont(void)
  TextFont *return_value = (TextFont *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_upcast_to_TextFont_67_comment =
  "C++ Interface:\n"
  "upcast_to_TextFont(const DynamicTextFont self)\n"
  "\n"
  "upcast from DynamicTextFont to TextFont";
#else
static const char *Dtool_DynamicTextFont_upcast_to_TextFont_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * FreetypeFont *DynamicTextFont::upcast_to_FreetypeFont(void)
 */
static PyObject *Dtool_DynamicTextFont_upcast_to_FreetypeFont_70(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.upcast_to_FreetypeFont")) {
    return nullptr;
  }
  // 1-FreetypeFont *DynamicTextFont::upcast_to_FreetypeFont(void)
  FreetypeFont *return_value = (FreetypeFont *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_FreetypeFont, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_upcast_to_FreetypeFont_70_comment =
  "C++ Interface:\n"
  "upcast_to_FreetypeFont(const DynamicTextFont self)\n"
  "\n"
  "upcast from DynamicTextFont to FreetypeFont";
#else
static const char *Dtool_DynamicTextFont_upcast_to_FreetypeFont_70_comment = nullptr;
#endif

static PyObject *Dtool_DynamicTextFont_point_size_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat DynamicTextFont::get_point_size(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_point_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_point_size_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.point_size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete point_size attribute");
    return -1;
  }
  // 1-inline bool DynamicTextFont::set_point_size(PN_stdfloat point_size)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_point_size)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (return_value) ? 0 : -1;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point_size(const DynamicTextFont self, float point_size)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_pixels_per_unit_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat DynamicTextFont::get_pixels_per_unit(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_pixels_per_unit)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_pixels_per_unit_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.pixels_per_unit")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete pixels_per_unit attribute");
    return -1;
  }
  // 1-inline bool DynamicTextFont::set_pixels_per_unit(PN_stdfloat pixels_per_unit)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_pixels_per_unit)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (return_value) ? 0 : -1;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pixels_per_unit(const DynamicTextFont self, float pixels_per_unit)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_scale_factor_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat DynamicTextFont::get_scale_factor(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_scale_factor)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_scale_factor_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.scale_factor")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete scale_factor attribute");
    return -1;
  }
  // 1-inline bool DynamicTextFont::set_scale_factor(PN_stdfloat scale_factor)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_scale_factor)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (return_value) ? 0 : -1;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scale_factor(const DynamicTextFont self, float scale_factor)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_native_antialias_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool DynamicTextFont::get_native_antialias(void) const
  bool return_value = ((*(const DynamicTextFont*)local_this).get_native_antialias)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_native_antialias_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.native_antialias")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete native_antialias attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_native_antialias(bool native_antialias)
  ((*local_this).set_native_antialias)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_native_antialias(const DynamicTextFont self, bool native_antialias)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_font_pixel_size_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int DynamicTextFont::get_font_pixel_size(void) const
  int return_value = ((*(const DynamicTextFont*)local_this).get_font_pixel_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_DynamicTextFont_texture_margin_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int DynamicTextFont::get_texture_margin(void) const
  int return_value = ((*(const DynamicTextFont*)local_this).get_texture_margin)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_texture_margin_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.texture_margin")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete texture_margin attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_texture_margin(int texture_margin)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_texture_margin)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texture_margin(const DynamicTextFont self, int texture_margin)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_poly_margin_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat DynamicTextFont::get_poly_margin(void) const
  PN_stdfloat return_value = ((*(const DynamicTextFont*)local_this).get_poly_margin)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_poly_margin_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.poly_margin")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete poly_margin attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_poly_margin(PN_stdfloat poly_margin)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_poly_margin)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_poly_margin(const DynamicTextFont self, float poly_margin)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_page_size_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2i const &DynamicTextFont::get_page_size(void) const
  LVecBase2i const *return_value = &(((*(const DynamicTextFont*)local_this).get_page_size)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

static int Dtool_DynamicTextFont_page_size_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.page_size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete page_size attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_page_size(LVecBase2i const &page_size)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_page_size", "LVecBase2i");
    return -1;
  }
  ((*local_this).set_page_size)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_page_size(const DynamicTextFont self, const LVecBase2i page_size)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_minfilter_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::FilterType DynamicTextFont::get_minfilter(void) const
  SamplerState::FilterType return_value = ((*(const DynamicTextFont*)local_this).get_minfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_minfilter_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.minfilter")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete minfilter attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_minfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_minfilter)((SamplerState::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_minfilter(const DynamicTextFont self, int filter)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_magfilter_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SamplerState::FilterType DynamicTextFont::get_magfilter(void) const
  SamplerState::FilterType return_value = ((*(const DynamicTextFont*)local_this).get_magfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_magfilter_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.magfilter")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete magfilter attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_magfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_magfilter)((SamplerState::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_magfilter(const DynamicTextFont self, int filter)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_anisotropic_degree_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int DynamicTextFont::get_anisotropic_degree(void) const
  int return_value = ((*(const DynamicTextFont*)local_this).get_anisotropic_degree)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_anisotropic_degree_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.anisotropic_degree")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete anisotropic_degree attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_anisotropic_degree)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const DynamicTextFont self, int anisotropic_degree)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_render_mode_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline TextFont::RenderMode DynamicTextFont::get_render_mode(void) const
  TextFont::RenderMode return_value = ((*(const DynamicTextFont*)local_this).get_render_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_render_mode_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.render_mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete render_mode attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_render_mode(TextFont::RenderMode render_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_render_mode)((TextFont::RenderMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_render_mode(const DynamicTextFont self, int render_mode)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_fg_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor const &DynamicTextFont::get_fg(void) const
  LColor const *return_value = &(((*(const DynamicTextFont*)local_this).get_fg)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_DynamicTextFont_fg_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.fg")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete fg attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_fg(LColor const &fg)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_fg", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_fg)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fg(const DynamicTextFont self, const LVecBase4f fg)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_bg_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor const &DynamicTextFont::get_bg(void) const
  LColor const *return_value = &(((*(const DynamicTextFont*)local_this).get_bg)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_DynamicTextFont_bg_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.bg")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bg attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_bg(LColor const &bg)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_bg", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_bg)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bg(const DynamicTextFont self, const LVecBase4f bg)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_tex_format_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture::Format DynamicTextFont::get_tex_format(void) const
  Texture::Format return_value = ((*(const DynamicTextFont*)local_this).get_tex_format)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property DynamicTextFont::pages
 */
static Py_ssize_t Dtool_DynamicTextFont_pages_Len(PyObject *self) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_pages)();
}

/**
 * sequence getter for property DynamicTextFont::pages
 */
static PyObject *Dtool_DynamicTextFont_pages_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_pages)()) {
    PyErr_SetString(PyExc_IndexError, "DynamicTextFont.pages[] index out of range");
    return nullptr;
  }
  // 1-DynamicTextPage *DynamicTextFont::get_page(int n) const
  DynamicTextPage *return_value = ((*(const DynamicTextFont*)local_this).get_page)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextPage, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_page(DynamicTextFont self, index)\n");
  }
}

static PyObject *Dtool_DynamicTextFont_pages_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "DynamicTextFont.pages");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_DynamicTextFont_pages_Len;
    wrap->_getitem_func = &Dtool_DynamicTextFont_pages_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * DynamicTextFont::DynamicTextFont(DynamicTextFont const &copy)
 * DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index = 0)
 * DynamicTextFont::DynamicTextFont(char const *font_data, int data_length, int face_index)
 */
static int Dtool_Init_DynamicTextFont(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "font_filename")) {
          Filename const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
          if (param0_this != nullptr) {
            DynamicTextFont *return_value = new DynamicTextFont(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
          }
        }
      }

      {
        // -2 DynamicTextFont::DynamicTextFont(DynamicTextFont const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          DynamicTextFont const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_DynamicTextFont);
          if (param0_this != nullptr) {
            DynamicTextFont *return_value = new DynamicTextFont(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
          }
        }
      }

      {
        // -2 DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "font_filename")) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          if ((param0_this != nullptr)) {
            DynamicTextFont *return_value = new DynamicTextFont(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
          }
        }
      }

      {
        // -2 DynamicTextFont::DynamicTextFont(DynamicTextFont const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          CPT(DynamicTextFont) param0_this;
          if (Dtool_ConstCoerce_DynamicTextFont(param0, param0_this)) {
            DynamicTextFont *return_value = new DynamicTextFont(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
          }
        }
      }

    }
    break;
  case 2:
    {
      // 1-DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"font_filename", "face_index", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:DynamicTextFont", (char **)keyword_list, &param0, &param1)) {
        Filename param0_local;
        Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "DynamicTextFont.DynamicTextFont", "Filename");
          return -1;
        }
        DynamicTextFont *return_value = new DynamicTextFont(*param0_this, (int)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-DynamicTextFont::DynamicTextFont(char const *font_data, int data_length, int face_index)
      char const *param0;
      int param1;
      int param2;
      static const char *keyword_list[] = {"font_data", "data_length", "face_index", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "zii:DynamicTextFont", (char **)keyword_list, &param0, &param1, &param2)) {
        DynamicTextFont *return_value = new DynamicTextFont((char const *)param0, (int)param1, (int)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DynamicTextFont() takes 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DynamicTextFont(const Filename font_filename)\n"
      "DynamicTextFont(const DynamicTextFont copy)\n"
      "DynamicTextFont(const Filename font_filename, int face_index)\n"
      "DynamicTextFont(str font_data, int data_length, int face_index)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_DynamicTextFont(PyObject *args, CPT(DynamicTextFont) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_DynamicTextFont)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
    Filename const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
    if (arg_this != nullptr) {
      DynamicTextFont *return_value = new DynamicTextFont(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
        PyObject *param0;
        int param1;
        if (PyArg_ParseTuple(args, "Oi:DynamicTextFont", &param0, &param1)) {
          Filename const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
          if (param0_this != nullptr) {
            DynamicTextFont *return_value = new DynamicTextFont(*param0_this, (int)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-DynamicTextFont::DynamicTextFont(char const *font_data, int data_length, int face_index)
        char const *param0;
        int param1;
        int param2;
        if (PyArg_ParseTuple(args, "zii:DynamicTextFont", &param0, &param1, &param2)) {
          DynamicTextFont *return_value = new DynamicTextFont((char const *)param0, (int)param1, (int)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_DynamicTextFont(PyObject *args, PT(DynamicTextFont) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_DynamicTextFont)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
    Filename const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
    if (arg_this != nullptr) {
      DynamicTextFont *return_value = new DynamicTextFont(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
        PyObject *param0;
        int param1;
        if (PyArg_ParseTuple(args, "Oi:DynamicTextFont", &param0, &param1)) {
          Filename const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
          if (param0_this != nullptr) {
            DynamicTextFont *return_value = new DynamicTextFont(*param0_this, (int)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-DynamicTextFont::DynamicTextFont(char const *font_data, int data_length, int face_index)
        char const *param0;
        int param1;
        int param2;
        if (PyArg_ParseTuple(args, "zii:DynamicTextFont", &param0, &param1, &param2)) {
          DynamicTextFont *return_value = new DynamicTextFont((char const *)param0, (int)param1, (int)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_DynamicTextFont_get_pages(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_pages)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_DynamicTextFont_get_page_137(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_DynamicTextFont(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DynamicTextFont) {
    printf("DynamicTextFont ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DynamicTextFont *local_this = (DynamicTextFont *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DynamicTextFont) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_FreetypeFont) {
    return (FreetypeFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextFont) {
    return (TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(TextFont *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DynamicTextFont(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DynamicTextFont) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_FreetypeFont) {
    FreetypeFont* other_this = (FreetypeFont*)from_this;
    return (DynamicTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DynamicTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TextFont) {
    TextFont* other_this = (TextFont*)from_this;
    return (DynamicTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DynamicTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (DynamicTextFont*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class FontPool
 */
/**
 * Python function wrapper for:
 * static inline bool FontPool::has_font(std::string const &filename)
 */
static PyObject *Dtool_FontPool_has_font_145(PyObject *, PyObject *arg) {
  // 1-static inline bool FontPool::has_font(std::string const &filename)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    bool return_value = (FontPool::has_font)(std::string(param0_str, param0_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_font(str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_has_font_145_comment =
  "C++ Interface:\n"
  "has_font(str filename)\n"
  "\n"
  "/**\n"
  " * Returns true if the font has ever been loaded, false otherwise.\n"
  " */";
#else
static const char *Dtool_FontPool_has_font_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool FontPool::verify_font(std::string const &filename)
 */
static PyObject *Dtool_FontPool_verify_font_146(PyObject *, PyObject *arg) {
  // 1-static inline bool FontPool::verify_font(std::string const &filename)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    bool return_value = (FontPool::verify_font)(std::string(param0_str, param0_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "verify_font(str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_verify_font_146_comment =
  "C++ Interface:\n"
  "verify_font(str filename)\n"
  "\n"
  "/**\n"
  " * Loads the given filename up into a font, if it has not already been loaded,\n"
  " * and returns true to indicate success, or false to indicate failure.  If\n"
  " * this returns true, it is guaranteed that a subsequent call to load_font()\n"
  " * with the same font name will return a valid Font pointer.\n"
  " */";
#else
static const char *Dtool_FontPool_verify_font_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline TextFont *FontPool::load_font(std::string const &filename)
 */
static PyObject *Dtool_FontPool_load_font_147(PyObject *, PyObject *arg) {
  // 1-static inline TextFont *FontPool::load_font(std::string const &filename)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    TextFont *return_value = (FontPool::load_font)(std::string(param0_str, param0_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_font(str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_load_font_147_comment =
  "C++ Interface:\n"
  "load_font(str filename)\n"
  "\n"
  "/**\n"
  " * Loads the given filename up into a font, if it has not already been loaded,\n"
  " * and returns the new font.  If a font with the same filename was previously\n"
  " * loaded, returns that one instead.  If the font file cannot be found,\n"
  " * returns NULL.\n"
  " */";
#else
static const char *Dtool_FontPool_load_font_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void FontPool::add_font(std::string const &filename, TextFont *font)
 */
static PyObject *Dtool_FontPool_add_font_148(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline void FontPool::add_font(std::string const &filename, TextFont *font)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  PyObject *param1;
  static const char *keyword_list[] = {"filename", "font", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:add_font", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    TextFont *param1_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextFont, 1, "FontPool.add_font", false, true);
    if (param1_this != nullptr) {
      (FontPool::add_font)(std::string(param0_str, param0_len), param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_font(str filename, TextFont font)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_add_font_148_comment =
  "C++ Interface:\n"
  "add_font(str filename, TextFont font)\n"
  "\n"
  "/**\n"
  " * Adds the indicated already-loaded font to the pool.  The font will always\n"
  " * replace any previously-loaded font in the pool that had the same filename.\n"
  " */";
#else
static const char *Dtool_FontPool_add_font_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void FontPool::release_font(std::string const &filename)
 */
static PyObject *Dtool_FontPool_release_font_149(PyObject *, PyObject *arg) {
  // 1-static inline void FontPool::release_font(std::string const &filename)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    (FontPool::release_font)(std::string(param0_str, param0_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_font(str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_release_font_149_comment =
  "C++ Interface:\n"
  "release_font(str filename)\n"
  "\n"
  "/**\n"
  " * Removes the indicated font from the pool, indicating it will never be\n"
  " * loaded again; the font may then be freed.  If this function is never\n"
  " * called, a reference count will be maintained on every font every loaded,\n"
  " * and fonts will never be freed.\n"
  " */";
#else
static const char *Dtool_FontPool_release_font_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void FontPool::release_all_fonts(void)
 */
static PyObject *Dtool_FontPool_release_all_fonts_150(PyObject *, PyObject *) {
  // 1-static inline void FontPool::release_all_fonts(void)
  (FontPool::release_all_fonts)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FontPool_release_all_fonts_150_comment =
  "C++ Interface:\n"
  "release_all_fonts()\n"
  "\n"
  "/**\n"
  " * Releases all fonts in the pool and restores the pool to the empty state.\n"
  " */";
#else
static const char *Dtool_FontPool_release_all_fonts_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int FontPool::garbage_collect(void)
 */
static PyObject *Dtool_FontPool_garbage_collect_151(PyObject *, PyObject *) {
  // 1-static inline int FontPool::garbage_collect(void)
  int return_value = (FontPool::garbage_collect)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FontPool_garbage_collect_151_comment =
  "C++ Interface:\n"
  "garbage_collect()\n"
  "\n"
  "/**\n"
  " * Releases only those fonts in the pool that have a reference count of\n"
  " * exactly 1; i.e.  only those fonts that are not being used outside of the\n"
  " * pool.  Returns the number of fonts released.\n"
  " */";
#else
static const char *Dtool_FontPool_garbage_collect_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void FontPool::list_contents(std::ostream &out)
 */
static PyObject *Dtool_FontPool_list_contents_152(PyObject *, PyObject *arg) {
  // 1-static inline void FontPool::list_contents(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "FontPool.list_contents", false, true);
  if (arg_this != nullptr) {
    (FontPool::list_contents)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_contents(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_list_contents_152_comment =
  "C++ Interface:\n"
  "list_contents(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the font pool to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_FontPool_list_contents_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void FontPool::write(std::ostream &out)
 */
static PyObject *Dtool_FontPool_write_153(PyObject *, PyObject *arg) {
  // 1-static void FontPool::write(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "FontPool.write", false, true);
  if (arg_this != nullptr) {
    (FontPool::write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_write_153_comment =
  "C++ Interface:\n"
  "write(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the font pool to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_FontPool_write_153_comment = nullptr;
#endif

static int Dtool_Init_FontPool(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_FontPool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FontPool) {
    printf("FontPool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FontPool *local_this = (FontPool *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FontPool) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FontPool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FontPool) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeomTextGlyph
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomTextGlyph::get_class_type(void)
 */
static PyObject *Dtool_GeomTextGlyph_get_class_type_157(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomTextGlyph::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeomTextGlyph::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomTextGlyph_get_class_type_157_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomTextGlyph_get_class_type_157_comment = nullptr;
#endif

static int Dtool_Init_GeomTextGlyph(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GeomTextGlyph(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeomTextGlyph) {
    printf("GeomTextGlyph ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeomTextGlyph *local_this = (GeomTextGlyph *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeomTextGlyph) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_Geom) {
    return (Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(Geom *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeomTextGlyph(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeomTextGlyph) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_Geom) {
    Geom* other_this = (Geom*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class StaticTextFont
 */
/**
 * Python function wrapper for:
 * static TypeHandle StaticTextFont::get_class_type(void)
 */
static PyObject *Dtool_StaticTextFont_get_class_type_160(PyObject *, PyObject *) {
  // 1-static TypeHandle StaticTextFont::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((StaticTextFont::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_StaticTextFont_get_class_type_160_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_StaticTextFont_get_class_type_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs = ::CS_default)
 */
static int Dtool_Init_StaticTextFont(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs = ::CS_default)
  PyObject *param0;
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"font_def", "cs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:StaticTextFont", (char **)keyword_list, &param0, &param1)) {
    PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "StaticTextFont.StaticTextFont", false, true);
    if (param0_this != nullptr) {
      StaticTextFont *return_value = new StaticTextFont(param0_this, (CoordinateSystem)param1);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StaticTextFont, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StaticTextFont(PandaNode font_def, int cs)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_StaticTextFont(PyObject *args, CPT(StaticTextFont) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_StaticTextFont)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs)
    PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 0, "StaticTextFont.StaticTextFont", false, false);
    if (arg_this != nullptr) {
      StaticTextFont *return_value = new StaticTextFont(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:StaticTextFont", &param0, &param1)) {
        PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "StaticTextFont.StaticTextFont", false, false);
        if (param0_this != nullptr) {
          StaticTextFont *return_value = new StaticTextFont(param0_this, (CoordinateSystem)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_StaticTextFont(PyObject *args, PT(StaticTextFont) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_StaticTextFont)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs)
    PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 0, "StaticTextFont.StaticTextFont", false, false);
    if (arg_this != nullptr) {
      StaticTextFont *return_value = new StaticTextFont(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:StaticTextFont", &param0, &param1)) {
        PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "StaticTextFont.StaticTextFont", false, false);
        if (param0_this != nullptr) {
          StaticTextFont *return_value = new StaticTextFont(param0_this, (CoordinateSystem)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_StaticTextFont(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_StaticTextFont) {
    printf("StaticTextFont ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  StaticTextFont *local_this = (StaticTextFont *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_StaticTextFont) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextFont) {
    return (TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(TextFont *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_StaticTextFont(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_StaticTextFont) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (StaticTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (StaticTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TextFont) {
    TextFont* other_this = (TextFont*)from_this;
    return (StaticTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (StaticTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (StaticTextFont*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextProperties
 */
/**
 * Python function wrapper for:
 * void TextProperties::operator =(TextProperties const &copy)
 */
static PyObject *Dtool_TextProperties_operator_166(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.assign")) {
    return nullptr;
  }
  // 1-void TextProperties::operator =(TextProperties const &copy)
  TextProperties const *arg_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextProperties, 1, "TextProperties.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    TextProperties *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TextProperties self, const TextProperties copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_operator_166_comment =
  "C++ Interface:\n"
  "assign(const TextProperties self, const TextProperties copy)\n";
#else
static const char *Dtool_TextProperties_operator_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextProperties::clear(void)
 */
static PyObject *Dtool_TextProperties_clear_169(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear")) {
    return nullptr;
  }
  // 1-void TextProperties::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_169_comment =
  "C++ Interface:\n"
  "clear(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Unsets all properties that have been specified so far, and resets the\n"
  " * TextProperties structure to its initial empty state.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::is_any_specified(void) const
 */
static PyObject *Dtool_TextProperties_is_any_specified_170(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::is_any_specified(void) const
  bool return_value = ((*(const TextProperties*)local_this).is_any_specified)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_is_any_specified_170_comment =
  "C++ Interface:\n"
  "is_any_specified(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if any properties have been specified, false otherwise.\n"
  " */";
#else
static const char *Dtool_TextProperties_is_any_specified_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void TextProperties::set_default_font(TextFont *)
 */
static PyObject *Dtool_TextProperties_set_default_font_171(PyObject *, PyObject *arg) {
  // 1-static inline void TextProperties::set_default_font(TextFont *)
  TextFont *arg_this = (TextFont *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextFont, 0, "TextProperties.set_default_font", false, true);
  if (arg_this != nullptr) {
    (TextProperties::set_default_font)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_font(TextFont param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_default_font_171_comment =
  "C++ Interface:\n"
  "set_default_font(TextFont param0)\n"
  "\n"
  "/**\n"
  " * Specifies the default font to be used for any TextNode whose font is\n"
  " * uninitialized or NULL.  See set_font().\n"
  " */";
#else
static const char *Dtool_TextProperties_set_default_font_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline TextFont *TextProperties::get_default_font(void)
 */
static PyObject *Dtool_TextProperties_get_default_font_172(PyObject *, PyObject *) {
  // 1-static inline TextFont *TextProperties::get_default_font(void)
  TextFont *return_value = (TextProperties::get_default_font)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_default_font_172_comment =
  "C++ Interface:\n"
  "get_default_font()\n"
  "\n"
  "/**\n"
  " * Specifies the default font to be used for any TextNode whose font is\n"
  " * uninitialized or NULL.  See set_font().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_default_font_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_font(TextFont *font)
 */
static PyObject *Dtool_TextProperties_set_font_173(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_font")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_font(TextFont *font)
  TextFont *arg_this = (TextFont *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextFont, 1, "TextProperties.set_font", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_font)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_font(const TextProperties self, TextFont font)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_font_173_comment =
  "C++ Interface:\n"
  "set_font(const TextProperties self, TextFont font)\n"
  "\n"
  "/**\n"
  " * Sets the font that will be used when making text.  If this is set to NULL,\n"
  " * the default font will be used, which can be set via set_default_font().\n"
  " */";
#else
static const char *Dtool_TextProperties_set_font_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_font(void)
 */
static PyObject *Dtool_TextProperties_clear_font_174(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_font")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_font(void)
  ((*local_this).clear_font)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_font_174_comment =
  "C++ Interface:\n"
  "clear_font(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Restores the default font to the text.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_font_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_font(void) const
 */
static PyObject *Dtool_TextProperties_has_font_175(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_font(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_font)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_font_175_comment =
  "C++ Interface:\n"
  "has_font(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_font_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextFont *TextProperties::get_font(void) const
 */
static PyObject *Dtool_TextProperties_get_font_176(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline TextFont *TextProperties::get_font(void) const
  TextFont *return_value = ((*(const TextProperties*)local_this).get_font)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_font_176_comment =
  "C++ Interface:\n"
  "get_font(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the font currently in use, if any.  If no font is in use, this\n"
  " * returns the default font.\n"
  " */";
#else
static const char *Dtool_TextProperties_get_font_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_small_caps(bool small_caps)
 */
static PyObject *Dtool_TextProperties_set_small_caps_177(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_small_caps")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_small_caps(bool small_caps)
  ((*local_this).set_small_caps)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_small_caps(const TextProperties self, bool small_caps)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_small_caps_177_comment =
  "C++ Interface:\n"
  "set_small_caps(const TextProperties self, bool small_caps)\n"
  "\n"
  "/**\n"
  " * Sets the small_caps flag.  When this is set, lowercase letters are\n"
  " * generated as scaled-down versions of their uppercase equivalents.  This is\n"
  " * particularly useful to set for fonts that do not have lowercase letters.\n"
  " *\n"
  " * It is also a good idea to set this for a (dynamic) font that has already\n"
  " * implemented lowercase letters as scaled-down versions of their uppercase\n"
  " * equivalents, since without this flag the texture memory may needlessly\n"
  " * duplicate equivalent glyphs for upper and lowercase letters.  Setting this\n"
  " * flag causes the texture memory to share the mixed-case letters.\n"
  " *\n"
  " * The amount by which the lowercase letters are scaled is specified by\n"
  " * set_small_caps_scale().\n"
  " */";
#else
static const char *Dtool_TextProperties_set_small_caps_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_small_caps(void)
 */
static PyObject *Dtool_TextProperties_clear_small_caps_178(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_small_caps")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_small_caps(void)
  ((*local_this).clear_small_caps)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_small_caps_178_comment =
  "C++ Interface:\n"
  "clear_small_caps(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_small_caps_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_small_caps(void) const
 */
static PyObject *Dtool_TextProperties_has_small_caps_179(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_small_caps(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_small_caps)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_small_caps_179_comment =
  "C++ Interface:\n"
  "has_small_caps(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_small_caps_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::get_small_caps(void) const
 */
static PyObject *Dtool_TextProperties_get_small_caps_180(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::get_small_caps(void) const
  bool return_value = ((*(const TextProperties*)local_this).get_small_caps)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_small_caps_180_comment =
  "C++ Interface:\n"
  "get_small_caps(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the small_caps flag.  See set_small_caps().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_small_caps_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_small_caps_scale(PN_stdfloat small_caps_scale)
 */
static PyObject *Dtool_TextProperties_set_small_caps_scale_181(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_small_caps_scale")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_small_caps_scale(PN_stdfloat small_caps_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_small_caps_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_small_caps_scale(const TextProperties self, float small_caps_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_small_caps_scale_181_comment =
  "C++ Interface:\n"
  "set_small_caps_scale(const TextProperties self, float small_caps_scale)\n"
  "\n"
  "/**\n"
  " * Sets the scale factor applied to lowercase letters from their uppercase\n"
  " * equivalents, when the small_caps flag is in effect.  See set_small_caps().\n"
  " * Normally, this will be a number less than one.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_small_caps_scale_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_small_caps_scale(void)
 */
static PyObject *Dtool_TextProperties_clear_small_caps_scale_182(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_small_caps_scale")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_small_caps_scale(void)
  ((*local_this).clear_small_caps_scale)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_small_caps_scale_182_comment =
  "C++ Interface:\n"
  "clear_small_caps_scale(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_small_caps_scale_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_small_caps_scale(void) const
 */
static PyObject *Dtool_TextProperties_has_small_caps_scale_183(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_small_caps_scale(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_small_caps_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_small_caps_scale_183_comment =
  "C++ Interface:\n"
  "has_small_caps_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_small_caps_scale_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_small_caps_scale(void) const
 */
static PyObject *Dtool_TextProperties_get_small_caps_scale_184(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextProperties::get_small_caps_scale(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_small_caps_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_small_caps_scale_184_comment =
  "C++ Interface:\n"
  "get_small_caps_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the scale factor applied to lowercase letters from their uppercase\n"
  " * equivalents, when the small_caps flag is in effect.  See set_small_caps()\n"
  " * and set_small_caps_scale().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_small_caps_scale_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_slant(PN_stdfloat slant)
 */
static PyObject *Dtool_TextProperties_set_slant_185(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_slant")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_slant(PN_stdfloat slant)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_slant)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slant(const TextProperties self, float slant)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_slant_185_comment =
  "C++ Interface:\n"
  "set_slant(const TextProperties self, float slant)\n"
  "\n"
  "/**\n"
  " * Specifies the factor by which the text slants to the right.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_slant_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_slant(void)
 */
static PyObject *Dtool_TextProperties_clear_slant_186(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_slant")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_slant(void)
  ((*local_this).clear_slant)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_slant_186_comment =
  "C++ Interface:\n"
  "clear_slant(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_slant_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_slant(void) const
 */
static PyObject *Dtool_TextProperties_has_slant_187(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_slant(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_slant)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_slant_187_comment =
  "C++ Interface:\n"
  "has_slant(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_slant_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_slant(void) const
 */
static PyObject *Dtool_TextProperties_get_slant_188(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextProperties::get_slant(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_slant)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_slant_188_comment =
  "C++ Interface:\n"
  "get_slant(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the factor by which the text is specified to slant to the right.\n"
  " */";
#else
static const char *Dtool_TextProperties_get_slant_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_underscore(bool underscore)
 */
static PyObject *Dtool_TextProperties_set_underscore_189(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_underscore")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_underscore(bool underscore)
  ((*local_this).set_underscore)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_underscore(const TextProperties self, bool underscore)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_underscore_189_comment =
  "C++ Interface:\n"
  "set_underscore(const TextProperties self, bool underscore)\n"
  "\n"
  "/**\n"
  " * Sets the underscore flag.  When this is set, the text is underscored with a\n"
  " * one-pixel line the same color as the text foreground, drawn at the\n"
  " * baseline.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_underscore_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_underscore(void)
 */
static PyObject *Dtool_TextProperties_clear_underscore_190(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_underscore")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_underscore(void)
  ((*local_this).clear_underscore)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_underscore_190_comment =
  "C++ Interface:\n"
  "clear_underscore(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_underscore_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_underscore(void) const
 */
static PyObject *Dtool_TextProperties_has_underscore_191(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_underscore(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_underscore)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_underscore_191_comment =
  "C++ Interface:\n"
  "has_underscore(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_underscore_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::get_underscore(void) const
 */
static PyObject *Dtool_TextProperties_get_underscore_192(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::get_underscore(void) const
  bool return_value = ((*(const TextProperties*)local_this).get_underscore)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_underscore_192_comment =
  "C++ Interface:\n"
  "get_underscore(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the underscore flag.  See set_underscore().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_underscore_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_underscore_height(PN_stdfloat underscore_height)
 */
static PyObject *Dtool_TextProperties_set_underscore_height_193(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_underscore_height")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_underscore_height(PN_stdfloat underscore_height)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_underscore_height)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_underscore_height(const TextProperties self, float underscore_height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_underscore_height_193_comment =
  "C++ Interface:\n"
  "set_underscore_height(const TextProperties self, float underscore_height)\n"
  "\n"
  "/**\n"
  " * Specifies the vertical height of the underscore, relative to the text\n"
  " * baseline.  This only has meaning if the underscore mode is enabled with\n"
  " * set_underscore().\n"
  " */";
#else
static const char *Dtool_TextProperties_set_underscore_height_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_underscore_height(void)
 */
static PyObject *Dtool_TextProperties_clear_underscore_height_194(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_underscore_height")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_underscore_height(void)
  ((*local_this).clear_underscore_height)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_underscore_height_194_comment =
  "C++ Interface:\n"
  "clear_underscore_height(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_underscore_height_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_underscore_height(void) const
 */
static PyObject *Dtool_TextProperties_has_underscore_height_195(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_underscore_height(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_underscore_height)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_underscore_height_195_comment =
  "C++ Interface:\n"
  "has_underscore_height(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_underscore_height_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_underscore_height(void) const
 */
static PyObject *Dtool_TextProperties_get_underscore_height_196(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextProperties::get_underscore_height(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_underscore_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_underscore_height_196_comment =
  "C++ Interface:\n"
  "get_underscore_height(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the vertical height of the underscore; see set_underscore_height().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_underscore_height_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_align(TextProperties::Alignment align_type)
 */
static PyObject *Dtool_TextProperties_set_align_197(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_align")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_align(TextProperties::Alignment align_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_align)((TextProperties::Alignment)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_align(const TextProperties self, int align_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_align_197_comment =
  "C++ Interface:\n"
  "set_align(const TextProperties self, int align_type)\n"
  "\n"
  "/**\n"
  " * Specifies the alignment of the text within its margins.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_align_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_align(void)
 */
static PyObject *Dtool_TextProperties_clear_align_198(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_align")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_align(void)
  ((*local_this).clear_align)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_align_198_comment =
  "C++ Interface:\n"
  "clear_align(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Restores the default alignment of the text.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_align_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_align(void) const
 */
static PyObject *Dtool_TextProperties_has_align_199(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_align(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_align)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_align_199_comment =
  "C++ Interface:\n"
  "has_align(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_align_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextProperties::Alignment TextProperties::get_align(void) const
 */
static PyObject *Dtool_TextProperties_get_align_200(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline TextProperties::Alignment TextProperties::get_align(void) const
  TextProperties::Alignment return_value = ((*(const TextProperties*)local_this).get_align)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_align_200_comment =
  "C++ Interface:\n"
  "get_align(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_get_align_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_indent(PN_stdfloat indent)
 */
static PyObject *Dtool_TextProperties_set_indent_201(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_indent")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_indent(PN_stdfloat indent)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_indent)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_indent(const TextProperties self, float indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_indent_201_comment =
  "C++ Interface:\n"
  "set_indent(const TextProperties self, float indent)\n"
  "\n"
  "/**\n"
  " * Specifies the amount of extra space that is inserted before the first\n"
  " * character of each line.  This can be thought of as a left margin.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_indent_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_indent(void)
 */
static PyObject *Dtool_TextProperties_clear_indent_202(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_indent")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_indent(void)
  ((*local_this).clear_indent)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_indent_202_comment =
  "C++ Interface:\n"
  "clear_indent(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the indent setting from the text.  Text will be as wide as it is.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_indent_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_indent(void) const
 */
static PyObject *Dtool_TextProperties_has_indent_203(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_indent(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_indent)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_indent_203_comment =
  "C++ Interface:\n"
  "has_indent(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_indent_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_indent(void) const
 */
static PyObject *Dtool_TextProperties_get_indent_204(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextProperties::get_indent(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_indent)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_indent_204_comment =
  "C++ Interface:\n"
  "get_indent(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_get_indent_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_wordwrap(PN_stdfloat wordwrap)
 */
static PyObject *Dtool_TextProperties_set_wordwrap_205(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_wordwrap")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_wordwrap(PN_stdfloat wordwrap)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_wordwrap)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wordwrap(const TextProperties self, float wordwrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_wordwrap_205_comment =
  "C++ Interface:\n"
  "set_wordwrap(const TextProperties self, float wordwrap)\n"
  "\n"
  "/**\n"
  " * Sets the text up to automatically wordwrap when it exceeds the indicated\n"
  " * width.  This can be thought of as a right margin or margin width.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_wordwrap_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_wordwrap(void)
 */
static PyObject *Dtool_TextProperties_clear_wordwrap_206(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_wordwrap")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_wordwrap(void)
  ((*local_this).clear_wordwrap)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_wordwrap_206_comment =
  "C++ Interface:\n"
  "clear_wordwrap(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the wordwrap setting from the text.  Text will be as wide as it is.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_wordwrap_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_wordwrap(void) const
 */
static PyObject *Dtool_TextProperties_has_wordwrap_207(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_wordwrap(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_wordwrap)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_wordwrap_207_comment =
  "C++ Interface:\n"
  "has_wordwrap(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_wordwrap_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_wordwrap(void) const
 */
static PyObject *Dtool_TextProperties_get_wordwrap_208(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextProperties::get_wordwrap(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_wordwrap)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_wordwrap_208_comment =
  "C++ Interface:\n"
  "get_wordwrap(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_get_wordwrap_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace)
 */
static PyObject *Dtool_TextProperties_set_preserve_trailing_whitespace_209(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_preserve_trailing_whitespace")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace)
  ((*local_this).set_preserve_trailing_whitespace)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_preserve_trailing_whitespace(const TextProperties self, bool preserve_trailing_whitespace)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_preserve_trailing_whitespace_209_comment =
  "C++ Interface:\n"
  "set_preserve_trailing_whitespace(const TextProperties self, bool preserve_trailing_whitespace)\n"
  "\n"
  "/**\n"
  " * Sets the preserve_trailing_whitespace flag.  When this is set, trailing\n"
  " * whitespace at the end of the line is not stripped when the text is\n"
  " * wordwrapped (it is stripped by default).  Since the trailing whitespace is\n"
  " * invisible, this is important primarily for determining the proper width of\n"
  " * a frame or card behind the text.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_preserve_trailing_whitespace_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_preserve_trailing_whitespace(void)
 */
static PyObject *Dtool_TextProperties_clear_preserve_trailing_whitespace_210(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_preserve_trailing_whitespace")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_preserve_trailing_whitespace(void)
  ((*local_this).clear_preserve_trailing_whitespace)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_preserve_trailing_whitespace_210_comment =
  "C++ Interface:\n"
  "clear_preserve_trailing_whitespace(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_preserve_trailing_whitespace_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_preserve_trailing_whitespace(void) const
 */
static PyObject *Dtool_TextProperties_has_preserve_trailing_whitespace_211(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_preserve_trailing_whitespace(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_preserve_trailing_whitespace)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_preserve_trailing_whitespace_211_comment =
  "C++ Interface:\n"
  "has_preserve_trailing_whitespace(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_preserve_trailing_whitespace_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::get_preserve_trailing_whitespace(void) const
 */
static PyObject *Dtool_TextProperties_get_preserve_trailing_whitespace_212(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::get_preserve_trailing_whitespace(void) const
  bool return_value = ((*(const TextProperties*)local_this).get_preserve_trailing_whitespace)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_preserve_trailing_whitespace_212_comment =
  "C++ Interface:\n"
  "get_preserve_trailing_whitespace(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the preserve_trailing_whitespace flag.  See\n"
  " * set_preserve_trailing_whitespace().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_preserve_trailing_whitespace_212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_text_color(LColor const &text_color)
 * inline void TextProperties::set_text_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextProperties_set_text_color_213(PyObject *self, PyObject *args, PyObject *kwds) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_text_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "text_color")) {
        // 1-inline void TextProperties::set_text_color(LColor const &text_color)
        LVecBase4f arg_local;
        LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_text_color", "LVecBase4f");
        }
        ((*local_this).set_text_color)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void TextProperties::set_text_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_text_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_text_color)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_text_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text_color(const TextProperties self, const LVecBase4f text_color)\n"
      "set_text_color(const TextProperties self, float r, float g, float b, float a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_text_color_213_comment =
  "C++ Interface:\n"
  "set_text_color(const TextProperties self, const LVecBase4f text_color)\n"
  "set_text_color(const TextProperties self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_set_text_color_213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_text_color(void)
 */
static PyObject *Dtool_TextProperties_clear_text_color_214(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_text_color")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_text_color(void)
  ((*local_this).clear_text_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_text_color_214_comment =
  "C++ Interface:\n"
  "clear_text_color(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the text color specification; the text will be colored whatever it\n"
  " * was in the source font file.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_text_color_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_text_color(void) const
 */
static PyObject *Dtool_TextProperties_has_text_color_215(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_text_color(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_text_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_text_color_215_comment =
  "C++ Interface:\n"
  "has_text_color(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_text_color_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor TextProperties::get_text_color(void) const
 */
static PyObject *Dtool_TextProperties_get_text_color_216(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline LColor TextProperties::get_text_color(void) const
  LColor *return_value = new LColor(((*(const TextProperties*)local_this).get_text_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_text_color_216_comment =
  "C++ Interface:\n"
  "get_text_color(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_get_text_color_216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_shadow_color(LColor const &shadow_color)
 * inline void TextProperties::set_shadow_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextProperties_set_shadow_color_217(PyObject *self, PyObject *args, PyObject *kwds) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_shadow_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "shadow_color")) {
        // 1-inline void TextProperties::set_shadow_color(LColor const &shadow_color)
        LVecBase4f arg_local;
        LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_shadow_color", "LVecBase4f");
        }
        ((*local_this).set_shadow_color)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void TextProperties::set_shadow_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_shadow_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_shadow_color)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shadow_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_color(const TextProperties self, const LVecBase4f shadow_color)\n"
      "set_shadow_color(const TextProperties self, float r, float g, float b, float a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_shadow_color_217_comment =
  "C++ Interface:\n"
  "set_shadow_color(const TextProperties self, const LVecBase4f shadow_color)\n"
  "set_shadow_color(const TextProperties self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_set_shadow_color_217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_shadow_color(void)
 */
static PyObject *Dtool_TextProperties_clear_shadow_color_218(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_shadow_color")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_shadow_color(void)
  ((*local_this).clear_shadow_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_shadow_color_218_comment =
  "C++ Interface:\n"
  "clear_shadow_color(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the shadow color specification.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_shadow_color_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_shadow_color(void) const
 */
static PyObject *Dtool_TextProperties_has_shadow_color_219(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_shadow_color(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_shadow_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_shadow_color_219_comment =
  "C++ Interface:\n"
  "has_shadow_color(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_shadow_color_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor TextProperties::get_shadow_color(void) const
 */
static PyObject *Dtool_TextProperties_get_shadow_color_220(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline LColor TextProperties::get_shadow_color(void) const
  LColor *return_value = new LColor(((*(const TextProperties*)local_this).get_shadow_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_shadow_color_220_comment =
  "C++ Interface:\n"
  "get_shadow_color(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_get_shadow_color_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_shadow(LVecBase2 const &shadow_offset)
 * inline void TextProperties::set_shadow(PN_stdfloat xoffset, PN_stdfloat yoffset)
 */
static PyObject *Dtool_TextProperties_set_shadow_221(PyObject *self, PyObject *args, PyObject *kwds) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_shadow")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "shadow_offset")) {
        // 1-inline void TextProperties::set_shadow(LVecBase2 const &shadow_offset)
        LVecBase2f arg_local;
        LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_shadow", "LVecBase2f");
        }
        ((*local_this).set_shadow)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void TextProperties::set_shadow(PN_stdfloat xoffset, PN_stdfloat yoffset)
      float param1;
      float param2;
      static const char *keyword_list[] = {"xoffset", "yoffset", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_shadow", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_shadow)((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shadow() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow(const TextProperties self, const LVecBase2f shadow_offset)\n"
      "set_shadow(const TextProperties self, float xoffset, float yoffset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_shadow_221_comment =
  "C++ Interface:\n"
  "set_shadow(const TextProperties self, const LVecBase2f shadow_offset)\n"
  "set_shadow(const TextProperties self, float xoffset, float yoffset)\n"
  "\n"
  "/**\n"
  " * Specifies that the text should be drawn with a shadow, by creating a second\n"
  " * copy of the text and offsetting it slightly behind the first.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies that the text should be drawn with a shadow, by creating a second\n"
  " * copy of the text and offsetting it slightly behind the first.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_shadow_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_shadow(void)
 */
static PyObject *Dtool_TextProperties_clear_shadow_222(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_shadow")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_shadow(void)
  ((*local_this).clear_shadow)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_shadow_222_comment =
  "C++ Interface:\n"
  "clear_shadow(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Specifies that a shadow will not be drawn behind the text.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_shadow_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_shadow(void) const
 */
static PyObject *Dtool_TextProperties_has_shadow_223(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_shadow(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_shadow)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_shadow_223_comment =
  "C++ Interface:\n"
  "has_shadow(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_shadow_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 TextProperties::get_shadow(void) const
 */
static PyObject *Dtool_TextProperties_get_shadow_224(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline LVector2 TextProperties::get_shadow(void) const
  LVector2 *return_value = new LVector2(((*(const TextProperties*)local_this).get_shadow)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_shadow_224_comment =
  "C++ Interface:\n"
  "get_shadow(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the offset of the shadow as set by set_shadow().  It is an error to\n"
  " * call this if has_shadow() is false.\n"
  " */";
#else
static const char *Dtool_TextProperties_get_shadow_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_bin(std::string const &bin)
 */
static PyObject *Dtool_TextProperties_set_bin_225(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_bin")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_bin(std::string const &bin)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_bin)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin(const TextProperties self, str bin)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_bin_225_comment =
  "C++ Interface:\n"
  "set_bin(const TextProperties self, str bin)\n"
  "\n"
  "/**\n"
  " * Names the CullBin that the text geometry should be assigned to.  If this is\n"
  " * set, then a CullBinAttrib will be created to explicitly place each\n"
  " * component in the named bin.\n"
  " *\n"
  " * The draw_order value will also be passed to each CullBinAttrib as\n"
  " * appropriate; this is particularly useful if this names a CullBinFixed, e.g.\n"
  " * \"fixed\".\n"
  " */";
#else
static const char *Dtool_TextProperties_set_bin_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_bin(void)
 */
static PyObject *Dtool_TextProperties_clear_bin_226(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_bin")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_bin(void)
  ((*local_this).clear_bin)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_bin_226_comment =
  "C++ Interface:\n"
  "clear_bin(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the effect of a previous call to set_bin().  Text will be drawn in\n"
  " * whatever bin it would like to be drawn in, with no explicit ordering.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_bin_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_bin(void) const
 */
static PyObject *Dtool_TextProperties_has_bin_227(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_bin(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_bin)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_bin_227_comment =
  "C++ Interface:\n"
  "has_bin(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if an explicit drawing bin has been set via set_bin(), false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_TextProperties_has_bin_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &TextProperties::get_bin(void) const
 */
static PyObject *Dtool_TextProperties_get_bin_228(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline std::string const &TextProperties::get_bin(void) const
  std::string const &return_value = ((*(const TextProperties*)local_this).get_bin)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_bin_228_comment =
  "C++ Interface:\n"
  "get_bin(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the drawing bin set with set_bin(), or empty string if no bin has\n"
  " * been set.\n"
  " */";
#else
static const char *Dtool_TextProperties_get_bin_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextProperties::set_draw_order(int draw_order)
 */
static PyObject *Dtool_TextProperties_set_draw_order_229(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_draw_order")) {
    return nullptr;
  }
  // 1-inline int TextProperties::set_draw_order(int draw_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).set_draw_order)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_draw_order(const TextProperties self, int draw_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_draw_order_229_comment =
  "C++ Interface:\n"
  "set_draw_order(const TextProperties self, int draw_order)\n"
  "\n"
  "/**\n"
  " * Sets the drawing order of text created by the TextNode.  This is actually\n"
  " * the draw order of the card and frame.  The shadow is drawn at\n"
  " * _draw_order+1, and the text at _draw_order+2.\n"
  " *\n"
  " * This affects the sorting order assigned to the nodes as they are created,\n"
  " * and also is passed to whatever bin may be assigned via set_bin().\n"
  " *\n"
  " * The return value is the first unused draw_order number, e.g.  _draw_order +\n"
  " * 3.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_draw_order_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_draw_order(void)
 */
static PyObject *Dtool_TextProperties_clear_draw_order_230(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_draw_order")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_draw_order(void)
  ((*local_this).clear_draw_order)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_draw_order_230_comment =
  "C++ Interface:\n"
  "clear_draw_order(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_draw_order_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_draw_order(void) const
 */
static PyObject *Dtool_TextProperties_has_draw_order_231(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_draw_order(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_draw_order)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_draw_order_231_comment =
  "C++ Interface:\n"
  "has_draw_order(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_draw_order_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextProperties::get_draw_order(void) const
 */
static PyObject *Dtool_TextProperties_get_draw_order_232(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline int TextProperties::get_draw_order(void) const
  int return_value = ((*(const TextProperties*)local_this).get_draw_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_draw_order_232_comment =
  "C++ Interface:\n"
  "get_draw_order(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the drawing order set with set_draw_order().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_draw_order_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_tab_width(PN_stdfloat tab_width)
 */
static PyObject *Dtool_TextProperties_set_tab_width_233(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_tab_width")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_tab_width(PN_stdfloat tab_width)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_tab_width)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tab_width(const TextProperties self, float tab_width)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_tab_width_233_comment =
  "C++ Interface:\n"
  "set_tab_width(const TextProperties self, float tab_width)\n"
  "\n"
  "/**\n"
  " * Sets the width of each tab stop, in screen units.  A tab character embedded\n"
  " * in the text will advance the horizontal position to the next tab stop.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_tab_width_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_tab_width(void)
 */
static PyObject *Dtool_TextProperties_clear_tab_width_234(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_tab_width")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_tab_width(void)
  ((*local_this).clear_tab_width)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_tab_width_234_comment =
  "C++ Interface:\n"
  "clear_tab_width(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_tab_width_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_tab_width(void) const
 */
static PyObject *Dtool_TextProperties_has_tab_width_235(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_tab_width(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_tab_width)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_tab_width_235_comment =
  "C++ Interface:\n"
  "has_tab_width(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_tab_width_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_tab_width(void) const
 */
static PyObject *Dtool_TextProperties_get_tab_width_236(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextProperties::get_tab_width(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_tab_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_tab_width_236_comment =
  "C++ Interface:\n"
  "get_tab_width(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the width set via set_tab_width().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_tab_width_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_glyph_scale(PN_stdfloat glyph_scale)
 */
static PyObject *Dtool_TextProperties_set_glyph_scale_237(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_glyph_scale")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_glyph_scale(PN_stdfloat glyph_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_glyph_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_glyph_scale(const TextProperties self, float glyph_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_glyph_scale_237_comment =
  "C++ Interface:\n"
  "set_glyph_scale(const TextProperties self, float glyph_scale)\n"
  "\n"
  "/**\n"
  " * Specifies the factor by which to scale each letter of the text as it is\n"
  " * placed, in addition to any scales inherited from the node or from\n"
  " * set_text_scale(). This can be used (possibly in conjunction with\n"
  " * set_glyph_shift()) to implement superscripting or subscripting.\n"
  " *\n"
  " * The glyph scale is cumulative when applied to nested TextProperties.  It is\n"
  " * intended primarily for implementing superscripts, not for scaling the text\n"
  " * in general.  See also set_text_scale(), which is intended primarily for\n"
  " * scaling the text in general, and is not cumulative.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_glyph_scale_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_glyph_scale(void)
 */
static PyObject *Dtool_TextProperties_clear_glyph_scale_238(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_glyph_scale")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_glyph_scale(void)
  ((*local_this).clear_glyph_scale)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_glyph_scale_238_comment =
  "C++ Interface:\n"
  "clear_glyph_scale(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_glyph_scale_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_glyph_scale(void) const
 */
static PyObject *Dtool_TextProperties_has_glyph_scale_239(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_glyph_scale(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_glyph_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_glyph_scale_239_comment =
  "C++ Interface:\n"
  "has_glyph_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_glyph_scale_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_glyph_scale(void) const
 */
static PyObject *Dtool_TextProperties_get_glyph_scale_240(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextProperties::get_glyph_scale(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_glyph_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_glyph_scale_240_comment =
  "C++ Interface:\n"
  "get_glyph_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the scale factor of each letter as specified by set_glyph_scale().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_glyph_scale_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_glyph_shift(PN_stdfloat glyph_shift)
 */
static PyObject *Dtool_TextProperties_set_glyph_shift_241(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_glyph_shift")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_glyph_shift(PN_stdfloat glyph_shift)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_glyph_shift)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_glyph_shift(const TextProperties self, float glyph_shift)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_glyph_shift_241_comment =
  "C++ Interface:\n"
  "set_glyph_shift(const TextProperties self, float glyph_shift)\n"
  "\n"
  "/**\n"
  " * Specifies a vertical amount to shift each letter of the text as it is\n"
  " * placed.  This can be used (possibly in conjunction with set_glyph_scale())\n"
  " * to implement superscripting or subscripting.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_glyph_shift_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_glyph_shift(void)
 */
static PyObject *Dtool_TextProperties_clear_glyph_shift_242(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_glyph_shift")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_glyph_shift(void)
  ((*local_this).clear_glyph_shift)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_glyph_shift_242_comment =
  "C++ Interface:\n"
  "clear_glyph_shift(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_glyph_shift_242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_glyph_shift(void) const
 */
static PyObject *Dtool_TextProperties_has_glyph_shift_243(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_glyph_shift(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_glyph_shift)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_glyph_shift_243_comment =
  "C++ Interface:\n"
  "has_glyph_shift(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_glyph_shift_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_glyph_shift(void) const
 */
static PyObject *Dtool_TextProperties_get_glyph_shift_244(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextProperties::get_glyph_shift(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_glyph_shift)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_glyph_shift_244_comment =
  "C++ Interface:\n"
  "get_glyph_shift(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the vertical shift of each letter as specified by\n"
  " * set_glyph_shift().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_glyph_shift_244_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_text_scale(PN_stdfloat text_scale)
 */
static PyObject *Dtool_TextProperties_set_text_scale_245(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_text_scale")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_text_scale(PN_stdfloat text_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_text_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text_scale(const TextProperties self, float text_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_text_scale_245_comment =
  "C++ Interface:\n"
  "set_text_scale(const TextProperties self, float text_scale)\n"
  "\n"
  "/**\n"
  " * Specifies the factor by which to scale the text, in addition to any\n"
  " * scalings imposed by the node, as well as in addition to the glyph scale.\n"
  " *\n"
  " * The text scale is not cumulative when applied to nested TextProperties.\n"
  " * See also set_glyph_scale(), which is cumulative.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_text_scale_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_text_scale(void)
 */
static PyObject *Dtool_TextProperties_clear_text_scale_246(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_text_scale")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_text_scale(void)
  ((*local_this).clear_text_scale)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_text_scale_246_comment =
  "C++ Interface:\n"
  "clear_text_scale(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_text_scale_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_text_scale(void) const
 */
static PyObject *Dtool_TextProperties_has_text_scale_247(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_text_scale(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_text_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_text_scale_247_comment =
  "C++ Interface:\n"
  "has_text_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_text_scale_247_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_text_scale(void) const
 */
static PyObject *Dtool_TextProperties_get_text_scale_248(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextProperties::get_text_scale(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_text_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_text_scale_248_comment =
  "C++ Interface:\n"
  "get_text_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the scale factor of the text as specified by set_text_scale().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_text_scale_248_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_direction(TextProperties::Direction direction)
 */
static PyObject *Dtool_TextProperties_set_direction_249(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_direction")) {
    return nullptr;
  }
  // 1-inline void TextProperties::set_direction(TextProperties::Direction direction)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_direction)((TextProperties::Direction)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_direction(const TextProperties self, int direction)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_direction_249_comment =
  "C++ Interface:\n"
  "set_direction(const TextProperties self, int direction)\n"
  "\n"
  "/**\n"
  " * Specifies the text direction.  If none is specified, it will be guessed\n"
  " * based on the contents of the string.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_TextProperties_set_direction_249_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_direction(void)
 */
static PyObject *Dtool_TextProperties_clear_direction_250(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_direction")) {
    return nullptr;
  }
  // 1-inline void TextProperties::clear_direction(void)
  ((*local_this).clear_direction)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_direction_250_comment =
  "C++ Interface:\n"
  "clear_direction(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Clears the text direction setting.  If no text direction is specified, it\n"
  " * will be guessed based on the contents of the string.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_direction_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_direction(void) const
 */
static PyObject *Dtool_TextProperties_has_direction_251(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline bool TextProperties::has_direction(void) const
  bool return_value = ((*(const TextProperties*)local_this).has_direction)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_direction_251_comment =
  "C++ Interface:\n"
  "has_direction(TextProperties self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_TextProperties_has_direction_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextProperties::Direction TextProperties::get_direction(void) const
 */
static PyObject *Dtool_TextProperties_get_direction_252(PyObject *self, PyObject *) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-inline TextProperties::Direction TextProperties::get_direction(void) const
  TextProperties::Direction return_value = ((*(const TextProperties*)local_this).get_direction)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_direction_252_comment =
  "C++ Interface:\n"
  "get_direction(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the direction of the text as specified by set_direction().\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_TextProperties_get_direction_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextProperties::add_properties(TextProperties const &other)
 */
static PyObject *Dtool_TextProperties_add_properties_253(PyObject *self, PyObject *arg) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.add_properties")) {
    return nullptr;
  }
  // 1-void TextProperties::add_properties(TextProperties const &other)
  TextProperties const *arg_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextProperties, 1, "TextProperties.add_properties", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_properties)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_properties(const TextProperties self, const TextProperties other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_add_properties_253_comment =
  "C++ Interface:\n"
  "add_properties(const TextProperties self, const TextProperties other)\n"
  "\n"
  "/**\n"
  " * Sets any properties that are explicitly specified in other on this object.\n"
  " * Leaves other properties unchanged.\n"
  " */";
#else
static const char *Dtool_TextProperties_add_properties_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextProperties::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_TextProperties_write_254(PyObject *self, PyObject *args, PyObject *kwds) {
  TextProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextProperties)) {
    return nullptr;
  }
  // 1-void TextProperties::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "TextProperties.write", false, true);
    if (param1_this != nullptr) {
      ((*(const TextProperties*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TextProperties self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_write_254_comment =
  "C++ Interface:\n"
  "write(TextProperties self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_write_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextProperties::get_class_type(void)
 */
static PyObject *Dtool_TextProperties_get_class_type_281(PyObject *, PyObject *) {
  // 1-static TypeHandle TextProperties::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TextProperties::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_class_type_281_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextProperties_get_class_type_281_comment = nullptr;
#endif

static PyObject *Dtool_TextProperties_font_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_font()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TextFont *TextProperties::get_font(void) const
  TextFont *return_value = ((*(const TextProperties*)local_this).get_font)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_TextProperties_font_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.font")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete font attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_font();
    return 0;
  }
  // 1-inline void TextProperties::set_font(TextFont *font)
  TextFont *arg_this = (TextFont *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextFont, 1, "TextProperties.set_font", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_font)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_font(const TextProperties self, TextFont font)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_small_caps_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_small_caps()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextProperties::get_small_caps(void) const
  bool return_value = ((*(const TextProperties*)local_this).get_small_caps)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_small_caps_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.small_caps")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete small_caps attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_small_caps();
    return 0;
  }
  // 1-inline void TextProperties::set_small_caps(bool small_caps)
  ((*local_this).set_small_caps)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_small_caps(const TextProperties self, bool small_caps)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_small_caps_scale_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_small_caps_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_small_caps_scale(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_small_caps_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_small_caps_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.small_caps_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete small_caps_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_small_caps_scale();
    return 0;
  }
  // 1-inline void TextProperties::set_small_caps_scale(PN_stdfloat small_caps_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_small_caps_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_small_caps_scale(const TextProperties self, float small_caps_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_slant_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_slant()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_slant(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_slant)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_slant_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.slant")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete slant attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_slant();
    return 0;
  }
  // 1-inline void TextProperties::set_slant(PN_stdfloat slant)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_slant)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_slant(const TextProperties self, float slant)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_underscore_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_underscore()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextProperties::get_underscore(void) const
  bool return_value = ((*(const TextProperties*)local_this).get_underscore)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_underscore_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.underscore")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete underscore attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_underscore();
    return 0;
  }
  // 1-inline void TextProperties::set_underscore(bool underscore)
  ((*local_this).set_underscore)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_underscore(const TextProperties self, bool underscore)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_underscore_height_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_underscore_height()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_underscore_height(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_underscore_height)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_underscore_height_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.underscore_height")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete underscore_height attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_underscore_height();
    return 0;
  }
  // 1-inline void TextProperties::set_underscore_height(PN_stdfloat underscore_height)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_underscore_height)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_underscore_height(const TextProperties self, float underscore_height)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_align_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_align()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TextProperties::Alignment TextProperties::get_align(void) const
  TextProperties::Alignment return_value = ((*(const TextProperties*)local_this).get_align)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_align_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.align")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete align attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_align();
    return 0;
  }
  // 1-inline void TextProperties::set_align(TextProperties::Alignment align_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_align)((TextProperties::Alignment)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_align(const TextProperties self, int align_type)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_indent_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_indent()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_indent(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_indent)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_indent_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.indent")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete indent attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_indent();
    return 0;
  }
  // 1-inline void TextProperties::set_indent(PN_stdfloat indent)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_indent)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_indent(const TextProperties self, float indent)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_wordwrap_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_wordwrap()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_wordwrap(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_wordwrap)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_wordwrap_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.wordwrap")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wordwrap attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_wordwrap();
    return 0;
  }
  // 1-inline void TextProperties::set_wordwrap(PN_stdfloat wordwrap)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_wordwrap)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wordwrap(const TextProperties self, float wordwrap)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_preserve_trailing_whitespace_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_preserve_trailing_whitespace()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextProperties::get_preserve_trailing_whitespace(void) const
  bool return_value = ((*(const TextProperties*)local_this).get_preserve_trailing_whitespace)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_preserve_trailing_whitespace_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.preserve_trailing_whitespace")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete preserve_trailing_whitespace attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_preserve_trailing_whitespace();
    return 0;
  }
  // 1-inline void TextProperties::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace)
  ((*local_this).set_preserve_trailing_whitespace)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_preserve_trailing_whitespace(const TextProperties self, bool preserve_trailing_whitespace)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_text_color_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_text_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor TextProperties::get_text_color(void) const
  LColor *return_value = new LColor(((*(const TextProperties*)local_this).get_text_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextProperties_text_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.text_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete text_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_text_color();
    return 0;
  }
  // 1-inline void TextProperties::set_text_color(LColor const &text_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_text_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_text_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_text_color(const TextProperties self, const LVecBase4f text_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_shadow_color_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_shadow_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor TextProperties::get_shadow_color(void) const
  LColor *return_value = new LColor(((*(const TextProperties*)local_this).get_shadow_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextProperties_shadow_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.shadow_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete shadow_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_shadow_color();
    return 0;
  }
  // 1-inline void TextProperties::set_shadow_color(LColor const &shadow_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_shadow_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_shadow_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow_color(const TextProperties self, const LVecBase4f shadow_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_shadow_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_shadow()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LVector2 TextProperties::get_shadow(void) const
  LVector2 *return_value = new LVector2(((*(const TextProperties*)local_this).get_shadow)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

static int Dtool_TextProperties_shadow_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.shadow")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete shadow attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_shadow();
    return 0;
  }
  // 1-inline void TextProperties::set_shadow(LVecBase2 const &shadow_offset)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_shadow", "LVecBase2f");
    return -1;
  }
  ((*local_this).set_shadow)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow(const TextProperties self, const LVecBase2f shadow_offset)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_bin_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_bin()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline std::string const &TextProperties::get_bin(void) const
  std::string const &return_value = ((*(const TextProperties*)local_this).get_bin)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_bin_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.bin")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bin attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_bin();
    return 0;
  }
  // 1-inline void TextProperties::set_bin(std::string const &bin)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_bin)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bin(const TextProperties self, str bin)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_draw_order_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_draw_order()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int TextProperties::get_draw_order(void) const
  int return_value = ((*(const TextProperties*)local_this).get_draw_order)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_draw_order_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.draw_order")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete draw_order attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_draw_order();
    return 0;
  }
  // 1-inline int TextProperties::set_draw_order(int draw_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    int return_value = ((*local_this).set_draw_order)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return return_value;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_draw_order(const TextProperties self, int draw_order)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_tab_width_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_tab_width()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_tab_width(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_tab_width)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_tab_width_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.tab_width")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete tab_width attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_tab_width();
    return 0;
  }
  // 1-inline void TextProperties::set_tab_width(PN_stdfloat tab_width)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_tab_width)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tab_width(const TextProperties self, float tab_width)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_glyph_scale_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_glyph_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_glyph_scale(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_glyph_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_glyph_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.glyph_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete glyph_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_glyph_scale();
    return 0;
  }
  // 1-inline void TextProperties::set_glyph_scale(PN_stdfloat glyph_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_glyph_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_glyph_scale(const TextProperties self, float glyph_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_glyph_shift_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_glyph_shift()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_glyph_shift(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_glyph_shift)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_glyph_shift_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.glyph_shift")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete glyph_shift attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_glyph_shift();
    return 0;
  }
  // 1-inline void TextProperties::set_glyph_shift(PN_stdfloat glyph_shift)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_glyph_shift)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_glyph_shift(const TextProperties self, float glyph_shift)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_text_scale_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_text_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_text_scale(void) const
  PN_stdfloat return_value = ((*(const TextProperties*)local_this).get_text_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_text_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.text_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete text_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_text_scale();
    return 0;
  }
  // 1-inline void TextProperties::set_text_scale(PN_stdfloat text_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_text_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_text_scale(const TextProperties self, float text_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_direction_Getter(PyObject *self, void *) {
  const TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_direction()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TextProperties::Direction TextProperties::get_direction(void) const
  TextProperties::Direction return_value = ((*(const TextProperties*)local_this).get_direction)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_direction_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.direction")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete direction attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_direction();
    return 0;
  }
  // 1-inline void TextProperties::set_direction(TextProperties::Direction direction)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_direction)((TextProperties::Direction)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_direction(const TextProperties self, int direction)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * TextProperties::TextProperties(void)
 * TextProperties::TextProperties(TextProperties const &copy)
 */
static int Dtool_Init_TextProperties(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TextProperties::TextProperties(void)
      TextProperties *return_value = new TextProperties();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextProperties, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-TextProperties::TextProperties(TextProperties const &copy)
        TextProperties const *arg_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextProperties, 0, "TextProperties.TextProperties", true, true);
        if (arg_this != nullptr) {
          TextProperties *return_value = new TextProperties(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextProperties, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextProperties() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextProperties()\n"
      "TextProperties(const TextProperties copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextProperties(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextProperties) {
    printf("TextProperties ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextProperties *local_this = (TextProperties *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextProperties) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextProperties(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextProperties) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextGraphic
 */
/**
 * Python function wrapper for:
 * inline NodePath TextGraphic::get_model(void) const
 */
static PyObject *Dtool_TextGraphic_get_model_285(PyObject *self, PyObject *) {
  TextGraphic *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextGraphic)) {
    return nullptr;
  }
  // 1-inline NodePath TextGraphic::get_model(void) const
  NodePath *return_value = new NodePath(((*(const TextGraphic*)local_this).get_model)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_get_model_285_comment =
  "C++ Interface:\n"
  "get_model(TextGraphic self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath associated with the graphic, that renders the desired\n"
  " * image.\n"
  " */";
#else
static const char *Dtool_TextGraphic_get_model_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextGraphic::set_model(NodePath const &model)
 */
static PyObject *Dtool_TextGraphic_set_model_286(PyObject *self, PyObject *arg) {
  TextGraphic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.set_model")) {
    return nullptr;
  }
  // 1-inline void TextGraphic::set_model(NodePath const &model)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "TextGraphic.set_model", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_model)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_model(const TextGraphic self, const NodePath model)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_set_model_286_comment =
  "C++ Interface:\n"
  "set_model(const TextGraphic self, const NodePath model)\n"
  "\n"
  "/**\n"
  " * Changes the NodePath associated with the graphic.  This NodePath should\n"
  " * contain geometry that will render the desired graphic image.\n"
  " */";
#else
static const char *Dtool_TextGraphic_set_model_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextGraphic::get_frame(void) const
 */
static PyObject *Dtool_TextGraphic_get_frame_289(PyObject *self, PyObject *) {
  TextGraphic *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextGraphic)) {
    return nullptr;
  }
  // 1-inline LVecBase4 TextGraphic::get_frame(void) const
  LVecBase4 *return_value = new LVecBase4(((*(const TextGraphic*)local_this).get_frame)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_get_frame_289_comment =
  "C++ Interface:\n"
  "get_frame(TextGraphic self)\n"
  "\n"
  "/**\n"
  " * Returns the frame specified for the graphic.  This is the amount of space\n"
  " * that will be reserved for the graphic when it is embedded in a text\n"
  " * paragraph, in the form (left, right, bottom, top).\n"
  " *\n"
  " * The actual graphic, as rendered by the NodePath specified via set_model(),\n"
  " * should more or less fit within this rectangle.  It is not required to fit\n"
  " * completely within it, but if it does not, it may visually overlap with\n"
  " * nearby text.\n"
  " */";
#else
static const char *Dtool_TextGraphic_get_frame_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextGraphic::set_frame(LVecBase4 const &frame)
 * inline void TextGraphic::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_TextGraphic_set_frame_290(PyObject *self, PyObject *args, PyObject *kwds) {
  TextGraphic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.set_frame")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "frame")) {
        // 1-inline void TextGraphic::set_frame(LVecBase4 const &frame)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "TextGraphic.set_frame", "LVecBase4f");
        }
        ((*local_this).set_frame)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void TextGraphic::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"left", "right", "bottom", "top", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_frame)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_frame() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame(const TextGraphic self, const LVecBase4f frame)\n"
      "set_frame(const TextGraphic self, float left, float right, float bottom, float top)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_set_frame_290_comment =
  "C++ Interface:\n"
  "set_frame(const TextGraphic self, const LVecBase4f frame)\n"
  "set_frame(const TextGraphic self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Specifies the (left, right, bottom, top) bounding frame for the graphic.\n"
  " * See get_frame().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies the (left, right, bottom, top) bounding frame for the graphic.\n"
  " * See get_frame().\n"
  " */";
#else
static const char *Dtool_TextGraphic_set_frame_290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextGraphic::get_instance_flag(void) const
 */
static PyObject *Dtool_TextGraphic_get_instance_flag_293(PyObject *self, PyObject *) {
  TextGraphic *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextGraphic)) {
    return nullptr;
  }
  // 1-inline bool TextGraphic::get_instance_flag(void) const
  bool return_value = ((*(const TextGraphic*)local_this).get_instance_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_get_instance_flag_293_comment =
  "C++ Interface:\n"
  "get_instance_flag(TextGraphic self)\n"
  "\n"
  "/**\n"
  " * Returns the instance_flag.  See set_instance_flag().\n"
  " */";
#else
static const char *Dtool_TextGraphic_get_instance_flag_293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextGraphic::set_instance_flag(bool instance_flag)
 */
static PyObject *Dtool_TextGraphic_set_instance_flag_294(PyObject *self, PyObject *arg) {
  TextGraphic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.set_instance_flag")) {
    return nullptr;
  }
  // 1-inline void TextGraphic::set_instance_flag(bool instance_flag)
  ((*local_this).set_instance_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_instance_flag(const TextGraphic self, bool instance_flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_set_instance_flag_294_comment =
  "C++ Interface:\n"
  "set_instance_flag(const TextGraphic self, bool instance_flag)\n"
  "\n"
  "/**\n"
  " * Sets the instance_flag.  When this is true, the graphic is directly\n"
  " * instanced to the scene graph whenever it appears; when it is false, the\n"
  " * graphic is copied.  The default is false, which is best for most\n"
  " * applications.  You might need to set it true for special kinds of\n"
  " * \"graphics\" like interactive elements, for instance a PGEntry.\n"
  " */";
#else
static const char *Dtool_TextGraphic_set_instance_flag_294_comment = nullptr;
#endif

static PyObject *Dtool_TextGraphic_model_Getter(PyObject *self, void *) {
  const TextGraphic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGraphic, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath TextGraphic::get_model(void) const
  NodePath *return_value = new NodePath(((*(const TextGraphic*)local_this).get_model)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

static int Dtool_TextGraphic_model_Setter(PyObject *self, PyObject *arg, void *) {
  TextGraphic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.model")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete model attribute");
    return -1;
  }
  // 1-inline void TextGraphic::set_model(NodePath const &model)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "TextGraphic.set_model", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_model)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_model(const TextGraphic self, const NodePath model)\n");
  }
  return -1;
}

static PyObject *Dtool_TextGraphic_frame_Getter(PyObject *self, void *) {
  const TextGraphic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGraphic, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase4 TextGraphic::get_frame(void) const
  LVecBase4 *return_value = new LVecBase4(((*(const TextGraphic*)local_this).get_frame)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextGraphic_frame_Setter(PyObject *self, PyObject *arg, void *) {
  TextGraphic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.frame")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete frame attribute");
    return -1;
  }
  // 1-inline void TextGraphic::set_frame(LVecBase4 const &frame)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextGraphic.set_frame", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_frame)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame(const TextGraphic self, const LVecBase4f frame)\n");
  }
  return -1;
}

static PyObject *Dtool_TextGraphic_instance_flag_Getter(PyObject *self, void *) {
  const TextGraphic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGraphic, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool TextGraphic::get_instance_flag(void) const
  bool return_value = ((*(const TextGraphic*)local_this).get_instance_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextGraphic_instance_flag_Setter(PyObject *self, PyObject *arg, void *) {
  TextGraphic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.instance_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete instance_flag attribute");
    return -1;
  }
  // 1-inline void TextGraphic::set_instance_flag(bool instance_flag)
  ((*local_this).set_instance_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_instance_flag(const TextGraphic self, bool instance_flag)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline TextGraphic::TextGraphic(void)
 * inline explicit TextGraphic::TextGraphic(NodePath const &model, LVecBase4 const &frame)
 * inline explicit TextGraphic::TextGraphic(NodePath const &model, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 * inline TextGraphic::TextGraphic(TextGraphic const &) = default
 */
static int Dtool_Init_TextGraphic(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TextGraphic::TextGraphic(void)
      TextGraphic *return_value = new TextGraphic();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextGraphic, true, false);
    }
    break;
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline TextGraphic::TextGraphic(TextGraphic const &) = default
      TextGraphic const *arg_this = (TextGraphic *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextGraphic, 0, "TextGraphic.TextGraphic", true, true);
      if (arg_this != nullptr) {
        TextGraphic *return_value = new TextGraphic(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextGraphic, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-inline explicit TextGraphic::TextGraphic(NodePath const &model, LVecBase4 const &frame)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"model", "frame", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:TextGraphic", (char **)keyword_list, &param0, &param1)) {
        NodePath const *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "TextGraphic.TextGraphic", true, true);
        LVecBase4f param1_local;
        LVecBase4 const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "TextGraphic.TextGraphic", "LVecBase4f");
          return -1;
        }
        if (param0_this != nullptr) {
          TextGraphic *return_value = new TextGraphic(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextGraphic, true, false);
        }
      }
    }
    break;
  case 5:
    {
      // 1-inline explicit TextGraphic::TextGraphic(NodePath const &model, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      PyObject *param0;
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"model", "left", "right", "bottom", "top", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offff:TextGraphic", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        NodePath const *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "TextGraphic.TextGraphic", true, true);
        if (param0_this != nullptr) {
          TextGraphic *return_value = new TextGraphic(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextGraphic, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextGraphic() takes 0, 1, 2 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextGraphic()\n"
      "TextGraphic(const TextGraphic param0)\n"
      "TextGraphic(const NodePath model, const LVecBase4f frame)\n"
      "TextGraphic(const NodePath model, float left, float right, float bottom, float top)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextGraphic(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextGraphic) {
    printf("TextGraphic ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextGraphic *local_this = (TextGraphic *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextGraphic) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextGraphic(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextGraphic) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextPropertiesManager
 */
/**
 * Python function wrapper for:
 * void TextPropertiesManager::set_properties(std::string const &name, TextProperties const &properties)
 */
static PyObject *Dtool_TextPropertiesManager_set_properties_298(PyObject *self, PyObject *args, PyObject *kwds) {
  TextPropertiesManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.set_properties")) {
    return nullptr;
  }
  // 1-void TextPropertiesManager::set_properties(std::string const &name, TextProperties const &properties)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "properties", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_properties", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    TextProperties const *param2_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextProperties, 2, "TextPropertiesManager.set_properties", true, true);
    if (param2_this != nullptr) {
      ((*local_this).set_properties)(std::string(param1_str, param1_len), *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_properties(const TextPropertiesManager self, str name, const TextProperties properties)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_set_properties_298_comment =
  "C++ Interface:\n"
  "set_properties(const TextPropertiesManager self, str name, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Defines the TextProperties associated with the indicated name.  When the\n"
  " * name is subsequently encountered in text embedded between \\1 characters in\n"
  " * a TextNode string, the following text will be rendered with these\n"
  " * properties.\n"
  " *\n"
  " * If there was already a TextProperties structure associated with this name,\n"
  " * it is quietly replaced with the new definition.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_set_properties_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextProperties TextPropertiesManager::get_properties(std::string const &name)
 */
static PyObject *Dtool_TextPropertiesManager_get_properties_299(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.get_properties")) {
    return nullptr;
  }
  // 1-TextProperties TextPropertiesManager::get_properties(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    TextProperties *return_value = new TextProperties(((*local_this).get_properties)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_properties(const TextPropertiesManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_get_properties_299_comment =
  "C++ Interface:\n"
  "get_properties(const TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the TextProperties associated with the indicated name.  If there\n"
  " * was not previously a TextProperties associated with this name, a warning is\n"
  " * printed and then a default TextProperties structure is associated with the\n"
  " * name, and returned.\n"
  " *\n"
  " * Call has_properties() instead to check whether a particular name has been\n"
  " * defined.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_get_properties_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextPropertiesManager::has_properties(std::string const &name) const
 */
static PyObject *Dtool_TextPropertiesManager_has_properties_300(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextPropertiesManager)) {
    return nullptr;
  }
  // 1-bool TextPropertiesManager::has_properties(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const TextPropertiesManager*)local_this).has_properties)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_properties(TextPropertiesManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_has_properties_300_comment =
  "C++ Interface:\n"
  "has_properties(TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if a TextProperties structure has been associated with the\n"
  " * indicated name, false otherwise.  Normally this means set_properties() has\n"
  " * been called with this name, but because get_properties() will implicitly\n"
  " * create a default TextProperties structure, it may also mean simply that\n"
  " * get_properties() has been called with the indicated name.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_has_properties_300_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextPropertiesManager::clear_properties(std::string const &name)
 */
static PyObject *Dtool_TextPropertiesManager_clear_properties_301(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.clear_properties")) {
    return nullptr;
  }
  // 1-void TextPropertiesManager::clear_properties(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).clear_properties)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_properties(const TextPropertiesManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_clear_properties_301_comment =
  "C++ Interface:\n"
  "clear_properties(const TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Removes the named TextProperties structure from the manager.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_clear_properties_301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextPropertiesManager::set_graphic(std::string const &name, NodePath const &model)
 * void TextPropertiesManager::set_graphic(std::string const &name, TextGraphic const &graphic)
 */
static PyObject *Dtool_TextPropertiesManager_set_graphic_302(PyObject *self, PyObject *args, PyObject *kwds) {
  TextPropertiesManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.set_graphic")) {
    return nullptr;
  }
  {
    // -2 void TextPropertiesManager::set_graphic(std::string const &name, NodePath const &model)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    PyObject *param2;
    static const char *keyword_list[] = {"name", "model", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_graphic", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      NodePath const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_NodePath);
      if (param2_this != nullptr) {
        ((*local_this).set_graphic)(std::string(param1_str, param1_len), *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void TextPropertiesManager::set_graphic(std::string const &name, TextGraphic const &graphic)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    PyObject *param2;
    static const char *keyword_list[] = {"name", "graphic", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_graphic", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      TextGraphic const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_TextGraphic);
      if (param2_this != nullptr) {
        ((*local_this).set_graphic)(std::string(param1_str, param1_len), *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void TextPropertiesManager::set_graphic(std::string const &name, NodePath const &model)
  // No coercion possible: void TextPropertiesManager::set_graphic(std::string const &name, TextGraphic const &graphic)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_graphic(const TextPropertiesManager self, str name, const NodePath model)\n"
      "set_graphic(const TextPropertiesManager self, str name, const TextGraphic graphic)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_set_graphic_302_comment =
  "C++ Interface:\n"
  "set_graphic(const TextPropertiesManager self, str name, const NodePath model)\n"
  "set_graphic(const TextPropertiesManager self, str name, const TextGraphic graphic)\n"
  "\n"
  "/**\n"
  " * Defines the TextGraphic associated with the indicated name.  When the name\n"
  " * is subsequently encountered in text embedded between \\5 characters in a\n"
  " * TextNode string, the specified graphic will be embedded in the text at that\n"
  " * point.\n"
  " *\n"
  " * If there was already a TextGraphic structure associated with this name, it\n"
  " * is quietly replaced with the new definition.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of set_graphic implicitly creates a frame for the model using\n"
  " * the model's actual computed bounding volume, as derived from\n"
  " * NodePath::calc_tight_bounds().  Create a TextGraphic object first if you\n"
  " * want to have explicit control of the frame.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_set_graphic_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextGraphic TextPropertiesManager::get_graphic(std::string const &name)
 */
static PyObject *Dtool_TextPropertiesManager_get_graphic_303(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.get_graphic")) {
    return nullptr;
  }
  // 1-TextGraphic TextPropertiesManager::get_graphic(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    TextGraphic *return_value = new TextGraphic(((*local_this).get_graphic)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextGraphic, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_graphic(const TextPropertiesManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_get_graphic_303_comment =
  "C++ Interface:\n"
  "get_graphic(const TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the TextGraphic associated with the indicated name.  If there was\n"
  " * not previously a TextGraphic associated with this name, a warning is\n"
  " * printed and then a default TextGraphic structure is associated with the\n"
  " * name, and returned.\n"
  " *\n"
  " * Call has_graphic() instead to check whether a particular name has been\n"
  " * defined.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_get_graphic_303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextPropertiesManager::has_graphic(std::string const &name) const
 */
static PyObject *Dtool_TextPropertiesManager_has_graphic_304(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextPropertiesManager)) {
    return nullptr;
  }
  // 1-bool TextPropertiesManager::has_graphic(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const TextPropertiesManager*)local_this).has_graphic)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_graphic(TextPropertiesManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_has_graphic_304_comment =
  "C++ Interface:\n"
  "has_graphic(TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if a TextGraphic structure has been associated with the\n"
  " * indicated name, false otherwise.  Normally this means set_graphic() has\n"
  " * been called with this name, but because get_graphic() will implicitly\n"
  " * create a default TextGraphic structure, it may also mean simply that\n"
  " * get_graphic() has been called with the indicated name.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_has_graphic_304_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextPropertiesManager::clear_graphic(std::string const &name)
 */
static PyObject *Dtool_TextPropertiesManager_clear_graphic_305(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.clear_graphic")) {
    return nullptr;
  }
  // 1-void TextPropertiesManager::clear_graphic(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).clear_graphic)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_graphic(const TextPropertiesManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_clear_graphic_305_comment =
  "C++ Interface:\n"
  "clear_graphic(const TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Removes the named TextGraphic structure from the manager.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_clear_graphic_305_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextPropertiesManager::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_TextPropertiesManager_write_306(PyObject *self, PyObject *args, PyObject *kwds) {
  TextPropertiesManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextPropertiesManager)) {
    return nullptr;
  }
  // 1-void TextPropertiesManager::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "TextPropertiesManager.write", false, true);
    if (param1_this != nullptr) {
      ((*(const TextPropertiesManager*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TextPropertiesManager self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_write_306_comment =
  "C++ Interface:\n"
  "write(TextPropertiesManager self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_write_306_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextPropertiesManager *TextPropertiesManager::get_global_ptr(void)
 */
static PyObject *Dtool_TextPropertiesManager_get_global_ptr_307(PyObject *, PyObject *) {
  // 1-static TextPropertiesManager *TextPropertiesManager::get_global_ptr(void)
  TextPropertiesManager *return_value = (TextPropertiesManager::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextPropertiesManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_get_global_ptr_307_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the global TextPropertiesManager object.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_get_global_ptr_307_comment = nullptr;
#endif

static int Dtool_Init_TextPropertiesManager(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TextPropertiesManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextPropertiesManager) {
    printf("TextPropertiesManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextPropertiesManager *local_this = (TextPropertiesManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextPropertiesManager) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextPropertiesManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextPropertiesManager) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextAssembler
 */
/**
 * Python function wrapper for:
 * void TextAssembler::operator =(TextAssembler const &copy)
 */
static PyObject *Dtool_TextAssembler_operator_310(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.assign")) {
    return nullptr;
  }
  // 1-void TextAssembler::operator =(TextAssembler const &copy)
  TextAssembler const *arg_this = (TextAssembler *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextAssembler, 1, "TextAssembler.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    TextAssembler *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextAssembler, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TextAssembler self, const TextAssembler copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_operator_310_comment =
  "C++ Interface:\n"
  "assign(const TextAssembler self, const TextAssembler copy)\n";
#else
static const char *Dtool_TextAssembler_operator_310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TextAssembler::clear(void)
 */
static PyObject *Dtool_TextAssembler_clear_312(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.clear")) {
    return nullptr;
  }
  // 1-void TextAssembler::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_clear_312_comment =
  "C++ Interface:\n"
  "clear(const TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Reinitializes the contents of the TextAssembler.\n"
  " */";
#else
static const char *Dtool_TextAssembler_clear_312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextAssembler::set_usage_hint(GeomEnums::UsageHint usage_hint)
 */
static PyObject *Dtool_TextAssembler_set_usage_hint_313(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_usage_hint")) {
    return nullptr;
  }
  // 1-inline void TextAssembler::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_usage_hint)((GeomEnums::UsageHint)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const TextAssembler self, int usage_hint)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_usage_hint_313_comment =
  "C++ Interface:\n"
  "set_usage_hint(const TextAssembler self, int usage_hint)\n"
  "\n"
  "/**\n"
  " * Specifies the UsageHint that will be applied to generated geometry.  The\n"
  " * default is UH_static, which is probably the right setting, but if you know\n"
  " * the TextNode's geometry will have a short lifespan, it may be better to set\n"
  " * it to UH_stream.  See geomEnums.h.\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_usage_hint_313_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::UsageHint TextAssembler::get_usage_hint(void) const
 */
static PyObject *Dtool_TextAssembler_get_usage_hint_314(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline GeomEnums::UsageHint TextAssembler::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const TextAssembler*)local_this).get_usage_hint)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_usage_hint_314_comment =
  "C++ Interface:\n"
  "get_usage_hint(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the UsageHint that will be applied to generated geometry.  See\n"
  " * set_usage_hint().\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_usage_hint_314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextAssembler::set_max_rows(int max_rows)
 */
static PyObject *Dtool_TextAssembler_set_max_rows_315(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_max_rows")) {
    return nullptr;
  }
  // 1-inline void TextAssembler::set_max_rows(int max_rows)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_max_rows)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_rows(const TextAssembler self, int max_rows)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_max_rows_315_comment =
  "C++ Interface:\n"
  "set_max_rows(const TextAssembler self, int max_rows)\n"
  "\n"
  "/**\n"
  " * If max_rows is greater than zero, no more than max_rows will be accepted.\n"
  " * Text beyond that will be truncated.\n"
  " *\n"
  " * Setting this will not truncate text immediately.  You must follow this up\n"
  " * with a call to set_wtext() to truncate the existing text.\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_max_rows_315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::get_max_rows(void) const
 */
static PyObject *Dtool_TextAssembler_get_max_rows_316(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline int TextAssembler::get_max_rows(void) const
  int return_value = ((*(const TextAssembler*)local_this).get_max_rows)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_max_rows_316_comment =
  "C++ Interface:\n"
  "get_max_rows(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * If max_rows is greater than zero, no more than max_rows will be accepted.\n"
  " * Text beyond that will be truncated.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_max_rows_316_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextAssembler::set_dynamic_merge(bool dynamic_merge)
 */
static PyObject *Dtool_TextAssembler_set_dynamic_merge_317(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_dynamic_merge")) {
    return nullptr;
  }
  // 1-inline void TextAssembler::set_dynamic_merge(bool dynamic_merge)
  ((*local_this).set_dynamic_merge)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dynamic_merge(const TextAssembler self, bool dynamic_merge)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_dynamic_merge_317_comment =
  "C++ Interface:\n"
  "set_dynamic_merge(const TextAssembler self, bool dynamic_merge)\n"
  "\n"
  "/**\n"
  " * Sets the dynamic_merge flag.  See TextNode::set_flatten_flags().\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_dynamic_merge_317_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextAssembler::get_dynamic_merge(void) const
 */
static PyObject *Dtool_TextAssembler_get_dynamic_merge_318(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline bool TextAssembler::get_dynamic_merge(void) const
  bool return_value = ((*(const TextAssembler*)local_this).get_dynamic_merge)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_dynamic_merge_318_comment =
  "C++ Interface:\n"
  "get_dynamic_merge(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the dynamic_merge flag.  See TextNode::set_flatten_flags().\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_dynamic_merge_318_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextAssembler::set_multiline_mode(bool flag)
 */
static PyObject *Dtool_TextAssembler_set_multiline_mode_319(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_multiline_mode")) {
    return nullptr;
  }
  // 1-inline void TextAssembler::set_multiline_mode(bool flag)
  ((*local_this).set_multiline_mode)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_multiline_mode(const TextAssembler self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_multiline_mode_319_comment =
  "C++ Interface:\n"
  "set_multiline_mode(const TextAssembler self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the multiline mode flag.  Set the multiline mode to allow text to\n"
  " * wrap.  It defaults to true.\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_multiline_mode_319_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextAssembler::get_multiline_mode(void) const
 */
static PyObject *Dtool_TextAssembler_get_multiline_mode_320(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline bool TextAssembler::get_multiline_mode(void) const
  bool return_value = ((*(const TextAssembler*)local_this).get_multiline_mode)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_multiline_mode_320_comment =
  "C++ Interface:\n"
  "get_multiline_mode(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the multline_mode flag.  See TextNode::set_multiline_mode().\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_multiline_mode_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextAssembler::set_properties(TextProperties const &properties)
 */
static PyObject *Dtool_TextAssembler_set_properties_321(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_properties")) {
    return nullptr;
  }
  // 1-inline void TextAssembler::set_properties(TextProperties const &properties)
  TextProperties const *arg_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextProperties, 1, "TextAssembler.set_properties", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_properties)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_properties(const TextAssembler self, const TextProperties properties)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_properties_321_comment =
  "C++ Interface:\n"
  "set_properties(const TextAssembler self, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Specifies the default TextProperties that are applied to the text in the\n"
  " * absence of any nested property change sequences.\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_properties_321_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextProperties const &TextAssembler::get_properties(void) const
 * inline TextProperties const &TextAssembler::get_properties(int n) const
 * inline TextProperties const &TextAssembler::get_properties(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_properties_322(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TextProperties const &TextAssembler::get_properties(void) const
      TextProperties const *return_value = &(((*(const TextAssembler*)local_this).get_properties)());
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, true);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "n")) {
        // 1-inline TextProperties const &TextAssembler::get_properties(int n) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          TextProperties const *return_value = &(((*(const TextAssembler*)local_this).get_properties)((int)arg_val));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, true);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline TextProperties const &TextAssembler::get_properties(int r, int c) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"r", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_properties", (char **)keyword_list, &param1, &param2)) {
        TextProperties const *return_value = &(((*(const TextAssembler*)local_this).get_properties)((int)param1, (int)param2));
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, true);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_properties() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_properties(TextAssembler self)\n"
      "get_properties(TextAssembler self, int n)\n"
      "get_properties(TextAssembler self, int r, int c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_properties_322_comment =
  "C++ Interface:\n"
  "get_properties(TextAssembler self)\n"
  "get_properties(TextAssembler self, int n)\n"
  "get_properties(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the default TextProperties that are applied to the text in the\n"
  " * absence of any nested property change sequences.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the TextProperties in effect for the object at the indicated\n"
  " * position in the pre-wordwrapped string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the TextProperties in effect for the object at the indicated\n"
  " * position in the indicated row.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_properties_322_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextAssembler::set_wtext(std::wstring const &wtext)
 */
static PyObject *Dtool_TextAssembler_set_wtext_323(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_wtext")) {
    return nullptr;
  }
  // 1-bool TextAssembler::set_wtext(std::wstring const &wtext)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  if (PyArg_Parse(arg, "U:set_wtext", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    bool return_value = ((*local_this).set_wtext)(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wtext(const TextAssembler self, unicode wtext)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_wtext_323_comment =
  "C++ Interface:\n"
  "set_wtext(const TextAssembler self, unicode wtext)\n"
  "\n"
  "/**\n"
  " * Accepts a new text string and associated properties structure, and\n"
  " * precomputes the wordwrapping layout appropriately.  After this call,\n"
  " * get_wordwrapped_wtext() and get_num_rows() can be called.\n"
  " *\n"
  " * The return value is true if all the text is accepted, or false if some was\n"
  " * truncated (see set_max_rows()).\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_wtext_323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextAssembler::set_wsubstr(std::wstring const &wtext, int start, int count)
 */
static PyObject *Dtool_TextAssembler_set_wsubstr_324(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_wsubstr")) {
    return nullptr;
  }
  // 1-bool TextAssembler::set_wsubstr(std::wstring const &wtext, int start, int count)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  int param2;
  int param3;
  static const char *keyword_list[] = {"wtext", "start", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Uii:set_wsubstr", (char **)keyword_list, &param1, &param2, &param3)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    bool return_value = ((*local_this).set_wsubstr)(std::wstring(param1_str, param1_len), (int)param2, (int)param3);
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wsubstr(const TextAssembler self, unicode wtext, int start, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_wsubstr_324_comment =
  "C++ Interface:\n"
  "set_wsubstr(const TextAssembler self, unicode wtext, int start, int count)\n"
  "\n"
  "/**\n"
  " * Replaces the 'count' characters from 'start' of the current text with the\n"
  " * indicated replacement text.  If the replacement text does not have count\n"
  " * characters, the length of the string will be changed accordingly.\n"
  " *\n"
  " * The substring may include nested formatting characters, but they must be\n"
  " * self-contained and self-closed.  The formatting characters are not\n"
  " * literally saved in the internal string; they are parsed at the time of the\n"
  " * set_wsubstr() call.\n"
  " *\n"
  " * The return value is true if all the text is accepted, or false if some was\n"
  " * truncated (see set_max_rows()).\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_wsubstr_324_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::wstring TextAssembler::get_plain_wtext(void) const
 */
static PyObject *Dtool_TextAssembler_get_plain_wtext_325(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-std::wstring TextAssembler::get_plain_wtext(void) const
  std::wstring return_value = ((*(const TextAssembler*)local_this).get_plain_wtext)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_plain_wtext_325_comment =
  "C++ Interface:\n"
  "get_plain_wtext(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns a wstring that represents the contents of the text, without any\n"
  " * embedded properties characters.  If there is an embedded graphic object, a\n"
  " * zero value is inserted in that position.\n"
  " *\n"
  " * This string has the same length as get_num_characters(), and the characters\n"
  " * in this string correspond one-to-one with the characters returned by\n"
  " * get_character(n).\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_plain_wtext_325_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::wstring TextAssembler::get_wordwrapped_plain_wtext(void) const
 */
static PyObject *Dtool_TextAssembler_get_wordwrapped_plain_wtext_326(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-std::wstring TextAssembler::get_wordwrapped_plain_wtext(void) const
  std::wstring return_value = ((*(const TextAssembler*)local_this).get_wordwrapped_plain_wtext)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_wordwrapped_plain_wtext_326_comment =
  "C++ Interface:\n"
  "get_wordwrapped_plain_wtext(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns a wstring that represents the contents of the text, with newlines\n"
  " * inserted according to the wordwrapping.  The string will contain no\n"
  " * embedded properties characters.  If there is an embedded graphic object, a\n"
  " * zero value is inserted in that position.\n"
  " *\n"
  " * This string has the same number of newline characters as get_num_rows(),\n"
  " * and the characters in this string correspond one-to-one with the characters\n"
  " * returned by get_character(r, c).\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_wordwrapped_plain_wtext_326_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::wstring TextAssembler::get_wtext(void) const
 */
static PyObject *Dtool_TextAssembler_get_wtext_327(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-std::wstring TextAssembler::get_wtext(void) const
  std::wstring return_value = ((*(const TextAssembler*)local_this).get_wtext)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_wtext_327_comment =
  "C++ Interface:\n"
  "get_wtext(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns a wstring that represents the contents of the text.\n"
  " *\n"
  " * The string will contain embedded properties characters, which may not\n"
  " * exactly match the embedded properties characters of the original string,\n"
  " * but it will encode the same way.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_wtext_327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::wstring TextAssembler::get_wordwrapped_wtext(void) const
 */
static PyObject *Dtool_TextAssembler_get_wordwrapped_wtext_328(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-std::wstring TextAssembler::get_wordwrapped_wtext(void) const
  std::wstring return_value = ((*(const TextAssembler*)local_this).get_wordwrapped_wtext)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_wordwrapped_wtext_328_comment =
  "C++ Interface:\n"
  "get_wordwrapped_wtext(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns a wstring that represents the contents of the text, with newlines\n"
  " * inserted according to the wordwrapping.\n"
  " *\n"
  " * The string will contain embedded properties characters, which may not\n"
  " * exactly match the embedded properties characters of the original string,\n"
  " * but it will encode the same way.\n"
  " *\n"
  " * Embedded properties characters will be closed before every newline, then\n"
  " * reopened (if necessary) on the subsequent character following the newline.\n"
  " * This means it will be safe to divide the text up at the newline characters\n"
  " * and treat each line as an independent piece.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_wordwrapped_wtext_328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::calc_r(int n) const
 */
static PyObject *Dtool_TextAssembler_calc_r_330(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline int TextAssembler::calc_r(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const TextAssembler*)local_this).calc_r)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_r(TextAssembler self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_calc_r_330_comment =
  "C++ Interface:\n"
  "calc_r(TextAssembler self, int n)\n"
  "\n"
  "/**\n"
  " * Computes the row index of the nth character or graphic object in the text\n"
  " * and returns it.\n"
  " *\n"
  " * If the nth character is not a normal printable character with a position in\n"
  " * the wordwrapped string, returns -1 (for instance, a soft-hyphen character,\n"
  " * or a newline character, may not have a corresponding position).\n"
  " */";
#else
static const char *Dtool_TextAssembler_calc_r_330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::calc_c(int n) const
 */
static PyObject *Dtool_TextAssembler_calc_c_331(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline int TextAssembler::calc_c(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const TextAssembler*)local_this).calc_c)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_c(TextAssembler self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_calc_c_331_comment =
  "C++ Interface:\n"
  "calc_c(TextAssembler self, int n)\n"
  "\n"
  "/**\n"
  " * Computes the column index of the nth character or graphic object in the\n"
  " * text and returns it.\n"
  " *\n"
  " * If the nth character is not a normal printable character with a position in\n"
  " * the wordwrapped string, returns -1 (for instance, a soft-hyphen character,\n"
  " * or a newline character, may not have a corresponding position).\n"
  " */";
#else
static const char *Dtool_TextAssembler_calc_c_331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TextAssembler::calc_index(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_calc_index_332(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-int TextAssembler::calc_index(int r, int c) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"r", "c", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:calc_index", (char **)keyword_list, &param1, &param2)) {
    int return_value = ((*(const TextAssembler*)local_this).calc_index)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_index(TextAssembler self, int r, int c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_calc_index_332_comment =
  "C++ Interface:\n"
  "calc_index(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Computes the character index of the character at the rth row and cth column\n"
  " * position.  This is the inverse of calc_r_c().\n"
  " *\n"
  " * It is legal for c to exceed the index number of the last column by 1, and\n"
  " * it is legal for r to exceed the index number of the last row by 1, if c is\n"
  " * 0.\n"
  " */";
#else
static const char *Dtool_TextAssembler_calc_index_332_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::get_num_characters(void) const
 */
static PyObject *Dtool_TextAssembler_get_num_characters_333(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline int TextAssembler::get_num_characters(void) const
  int return_value = ((*(const TextAssembler*)local_this).get_num_characters)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_num_characters_333_comment =
  "C++ Interface:\n"
  "get_num_characters(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the number of characters of text, before wordwrapping.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_num_characters_333_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline wchar_t TextAssembler::get_character(int n) const
 * inline wchar_t TextAssembler::get_character(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_character_334(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "n")) {
        // 1-inline wchar_t TextAssembler::get_character(int n) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          wchar_t return_value = ((*(const TextAssembler*)local_this).get_character)((int)arg_val);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline wchar_t TextAssembler::get_character(int r, int c) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"r", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_character", (char **)keyword_list, &param1, &param2)) {
        wchar_t return_value = ((*(const TextAssembler*)local_this).get_character)((int)param1, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_character() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_character(TextAssembler self, int n)\n"
      "get_character(TextAssembler self, int r, int c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_character_334_comment =
  "C++ Interface:\n"
  "get_character(TextAssembler self, int n)\n"
  "get_character(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the character at the indicated position in the pre-wordwrapped\n"
  " * string.  If the object at this position is a graphic object instead of a\n"
  " * character, returns 0.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the character at the indicated position in the indicated row.  If\n"
  " * the object at this position is a graphic object instead of a character,\n"
  " * returns 0.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_character_334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextGraphic const *TextAssembler::get_graphic(int n) const
 * inline TextGraphic const *TextAssembler::get_graphic(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_graphic_335(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "n")) {
        // 1-inline TextGraphic const *TextAssembler::get_graphic(int n) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          TextGraphic const *return_value = ((*(const TextAssembler*)local_this).get_graphic)((int)arg_val);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextGraphic, false, true);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline TextGraphic const *TextAssembler::get_graphic(int r, int c) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"r", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_graphic", (char **)keyword_list, &param1, &param2)) {
        TextGraphic const *return_value = ((*(const TextAssembler*)local_this).get_graphic)((int)param1, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextGraphic, false, true);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_graphic() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_graphic(TextAssembler self, int n)\n"
      "get_graphic(TextAssembler self, int r, int c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_graphic_335_comment =
  "C++ Interface:\n"
  "get_graphic(TextAssembler self, int n)\n"
  "get_graphic(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the graphic object at the indicated position in the pre-wordwrapped\n"
  " * string.  If the object at this position is a character instead of a graphic\n"
  " * object, returns NULL.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the graphic object at the indicated position in the indicated row.\n"
  " * If the object at this position is a character instead of a graphic object,\n"
  " * returns NULL.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_graphic_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextAssembler::get_width(int n) const
 * inline PN_stdfloat TextAssembler::get_width(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_width_336(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "n")) {
        // 1-inline PN_stdfloat TextAssembler::get_width(int n) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          PN_stdfloat return_value = ((*(const TextAssembler*)local_this).get_width)((int)arg_val);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline PN_stdfloat TextAssembler::get_width(int r, int c) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"r", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_width", (char **)keyword_list, &param1, &param2)) {
        PN_stdfloat return_value = ((*(const TextAssembler*)local_this).get_width)((int)param1, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_width() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_width(TextAssembler self, int n)\n"
      "get_width(TextAssembler self, int r, int c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_width_336_comment =
  "C++ Interface:\n"
  "get_width(TextAssembler self, int n)\n"
  "get_width(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the width of the character or object at the indicated position in\n"
  " * the pre-wordwrapped string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the width of the character or object at the indicated position in\n"
  " * the indicated row.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_width_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::get_num_rows(void) const
 */
static PyObject *Dtool_TextAssembler_get_num_rows_337(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline int TextAssembler::get_num_rows(void) const
  int return_value = ((*(const TextAssembler*)local_this).get_num_rows)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_num_rows_337_comment =
  "C++ Interface:\n"
  "get_num_rows(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the number of rows of text after it has all been wordwrapped and\n"
  " * assembled.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_num_rows_337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::get_num_cols(int r) const
 */
static PyObject *Dtool_TextAssembler_get_num_cols_338(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline int TextAssembler::get_num_cols(int r) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const TextAssembler*)local_this).get_num_cols)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_cols(TextAssembler self, int r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_num_cols_338_comment =
  "C++ Interface:\n"
  "get_num_cols(TextAssembler self, int r)\n"
  "\n"
  "/**\n"
  " * Returns the number of characters and/or graphic objects in the nth row.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_num_cols_338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat TextAssembler::get_xpos(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_xpos_339(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-PN_stdfloat TextAssembler::get_xpos(int r, int c) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"r", "c", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_xpos", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = ((*(const TextAssembler*)local_this).get_xpos)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xpos(TextAssembler self, int r, int c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_xpos_339_comment =
  "C++ Interface:\n"
  "get_xpos(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the x position of the origin of the character or graphic object at\n"
  " * the indicated position in the indicated row.\n"
  " *\n"
  " * It is legal for c to exceed the index number of the last column by 1, and\n"
  " * it is legal for r to exceed the index number of the last row by 1, if c is\n"
  " * 0.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_xpos_339_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextAssembler::get_ypos(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_ypos_340(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextAssembler::get_ypos(int r, int c) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"r", "c", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_ypos", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = ((*(const TextAssembler*)local_this).get_ypos)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ypos(TextAssembler self, int r, int c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_ypos_340_comment =
  "C++ Interface:\n"
  "get_ypos(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the y position of the origin of all of the characters or graphic\n"
  " * objects in the indicated row.\n"
  " *\n"
  " * It is legal for r to exceed the index number of the last row by 1.  The\n"
  " * value of c is presently ignored.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_ypos_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > TextAssembler::assemble_text(void)
 */
static PyObject *Dtool_TextAssembler_assemble_text_341(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.assemble_text")) {
    return nullptr;
  }
  // 1-PointerTo< PandaNode > TextAssembler::assemble_text(void)
  PointerTo< PandaNode > return_value = ((*local_this).assemble_text)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  PandaNode *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_assemble_text_341_comment =
  "C++ Interface:\n"
  "assemble_text(const TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Actually assembles all of the text into a GeomNode, and returns the node\n"
  " * (or possibly a parent of the node, to keep the shadow separate).  Once this\n"
  " * has been called, you may query the extents of the text via get_ul(),\n"
  " * get_lr().\n"
  " */";
#else
static const char *Dtool_TextAssembler_assemble_text_341_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 const &TextAssembler::get_ul(void) const
 */
static PyObject *Dtool_TextAssembler_get_ul_342(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline LVector2 const &TextAssembler::get_ul(void) const
  LVector2 const *return_value = &(((*(const TextAssembler*)local_this).get_ul)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_ul_342_comment =
  "C++ Interface:\n"
  "get_ul(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the upper-left corner of the assembled text, in 2-d text\n"
  " * coordinates.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_ul_342_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 const &TextAssembler::get_lr(void) const
 */
static PyObject *Dtool_TextAssembler_get_lr_343(PyObject *self, PyObject *) {
  TextAssembler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextAssembler)) {
    return nullptr;
  }
  // 1-inline LVector2 const &TextAssembler::get_lr(void) const
  LVector2 const *return_value = &(((*(const TextAssembler*)local_this).get_lr)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_lr_343_comment =
  "C++ Interface:\n"
  "get_lr(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the lower-right corner of the assembled text, in 2-d text\n"
  " * coordinates.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_lr_343_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PN_stdfloat TextAssembler::calc_width(TextGraphic const *graphic, TextProperties const &properties)
 * static PN_stdfloat TextAssembler::calc_width(wchar_t character, TextProperties const &properties)
 */
static PyObject *Dtool_TextAssembler_calc_width_344(PyObject *, PyObject *args, PyObject *kwds) {
  {
    // -2 static PN_stdfloat TextAssembler::calc_width(TextGraphic const *graphic, TextProperties const &properties)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"graphic", "properties", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:calc_width", (char **)keyword_list, &param0, &param1)) {
      TextGraphic const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TextGraphic);
      TextProperties const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_TextProperties);
      if (param0_this != nullptr && param1_this != nullptr) {
        PN_stdfloat return_value = (TextAssembler::calc_width)(param0_this, *param1_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 static PN_stdfloat TextAssembler::calc_width(wchar_t character, TextProperties const &properties)
#if PY_VERSION_HEX >= 0x03020000
    PyObject *param0;
#else
    PyUnicodeObject *param0;
#endif
    PyObject *param1;
    static const char *keyword_list[] = {"character", "properties", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "UO:calc_width", (char **)keyword_list, &param0, &param1)) {
      wchar_t param0_chars[2];
      TextProperties const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_TextProperties);
      if (PyUnicode_AsWideChar(param0, param0_chars, 2) == 1 && param1_this != nullptr) {
        PN_stdfloat return_value = (TextAssembler::calc_width)(param0_chars[0], *param1_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: static PN_stdfloat TextAssembler::calc_width(TextGraphic const *graphic, TextProperties const &properties)
  // No coercion possible: static PN_stdfloat TextAssembler::calc_width(wchar_t character, TextProperties const &properties)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_width(const TextGraphic graphic, const TextProperties properties)\n"
      "calc_width(unicode char character, const TextProperties properties)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_calc_width_344_comment =
  "C++ Interface:\n"
  "calc_width(const TextGraphic graphic, const TextProperties properties)\n"
  "calc_width(unicode char character, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Returns the width of a single character, according to its associated font.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the width of a single character, according to its associated font.\n"
  " * This also correctly calculates the width of cheesy ligatures and accented\n"
  " * characters, which may not exist in the font as such.\n"
  " *\n"
  " * This does not take kerning into account, however.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the width of a single TextGraphic image.\n"
  " */";
#else
static const char *Dtool_TextAssembler_calc_width_344_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool TextAssembler::has_exact_character(wchar_t character, TextProperties const &properties)
 */
static PyObject *Dtool_TextAssembler_has_exact_character_345(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static bool TextAssembler::has_exact_character(wchar_t character, TextProperties const &properties)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param0;
#else
  PyUnicodeObject *param0;
#endif
  PyObject *param1;
  static const char *keyword_list[] = {"character", "properties", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "UO:has_exact_character", (char **)keyword_list, &param0, &param1)) {
    wchar_t param0_chars[2];
    TextProperties const *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextProperties, 1, "TextAssembler.has_exact_character", true, true);
    if (PyUnicode_AsWideChar(param0, param0_chars, 2) == 1 && param1_this != nullptr) {
      bool return_value = (TextAssembler::has_exact_character)(param0_chars[0], *param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_exact_character(unicode char character, const TextProperties properties)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_has_exact_character_345_comment =
  "C++ Interface:\n"
  "has_exact_character(unicode char character, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Returns true if the named character exists in the font exactly as named,\n"
  " * false otherwise.  Note that because Panda can assemble glyphs together\n"
  " * automatically using cheesy accent marks, this is not a reliable indicator\n"
  " * of whether a suitable glyph can be rendered for the character.  For that,\n"
  " * use has_character() instead.\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), but returns false for characters that would render with\n"
  " * the \"invalid glyph\".  It also returns false for characters that would be\n"
  " * synthesized within Panda, but see has_character().\n"
  " */";
#else
static const char *Dtool_TextAssembler_has_exact_character_345_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool TextAssembler::has_character(wchar_t character, TextProperties const &properties)
 */
static PyObject *Dtool_TextAssembler_has_character_346(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static bool TextAssembler::has_character(wchar_t character, TextProperties const &properties)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param0;
#else
  PyUnicodeObject *param0;
#endif
  PyObject *param1;
  static const char *keyword_list[] = {"character", "properties", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "UO:has_character", (char **)keyword_list, &param0, &param1)) {
    wchar_t param0_chars[2];
    TextProperties const *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextProperties, 1, "TextAssembler.has_character", true, true);
    if (PyUnicode_AsWideChar(param0, param0_chars, 2) == 1 && param1_this != nullptr) {
      bool return_value = (TextAssembler::has_character)(param0_chars[0], *param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_character(unicode char character, const TextProperties properties)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_has_character_346_comment =
  "C++ Interface:\n"
  "has_character(unicode char character, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Returns true if the named character exists in the font or can be\n"
  " * synthesized by Panda, false otherwise.  (Panda can synthesize some accented\n"
  " * characters by combining similar-looking glyphs from the font.)\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), but returns false for characters that would render with\n"
  " * the \"invalid glyph\".\n"
  " */";
#else
static const char *Dtool_TextAssembler_has_character_346_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool TextAssembler::is_whitespace(wchar_t character, TextProperties const &properties)
 */
static PyObject *Dtool_TextAssembler_is_whitespace_347(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static bool TextAssembler::is_whitespace(wchar_t character, TextProperties const &properties)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param0;
#else
  PyUnicodeObject *param0;
#endif
  PyObject *param1;
  static const char *keyword_list[] = {"character", "properties", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "UO:is_whitespace", (char **)keyword_list, &param0, &param1)) {
    wchar_t param0_chars[2];
    TextProperties const *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextProperties, 1, "TextAssembler.is_whitespace", true, true);
    if (PyUnicode_AsWideChar(param0, param0_chars, 2) == 1 && param1_this != nullptr) {
      bool return_value = (TextAssembler::is_whitespace)(param0_chars[0], *param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_whitespace(unicode char character, const TextProperties properties)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_is_whitespace_347_comment =
  "C++ Interface:\n"
  "is_whitespace(unicode char character, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character represents whitespace in the font,\n"
  " * or false if anything visible will be rendered for it.\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), and returns false for any other characters, including\n"
  " * characters that do not exist in the font (these would be rendered with the\n"
  " * \"invalid glyph\", which is visible).\n"
  " *\n"
  " * Note that this function can be reliably used to identify Unicode whitespace\n"
  " * characters only if the font has all of the whitespace characters defined.\n"
  " * It will return false for any character not in the font, even if it is an\n"
  " * official Unicode whitespace character.\n"
  " */";
#else
static const char *Dtool_TextAssembler_is_whitespace_347_comment = nullptr;
#endif

static PyObject *Dtool_TextAssembler_usage_hint_Getter(PyObject *self, void *) {
  const TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::UsageHint TextAssembler::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const TextAssembler*)local_this).get_usage_hint)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextAssembler_usage_hint_Setter(PyObject *self, PyObject *arg, void *) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.usage_hint")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete usage_hint attribute");
    return -1;
  }
  // 1-inline void TextAssembler::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_usage_hint)((GeomEnums::UsageHint)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const TextAssembler self, int usage_hint)\n");
  }
  return -1;
}

static PyObject *Dtool_TextAssembler_max_rows_Getter(PyObject *self, void *) {
  const TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TextAssembler::get_max_rows(void) const
  int return_value = ((*(const TextAssembler*)local_this).get_max_rows)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextAssembler_max_rows_Setter(PyObject *self, PyObject *arg, void *) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.max_rows")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_rows attribute");
    return -1;
  }
  // 1-inline void TextAssembler::set_max_rows(int max_rows)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_max_rows)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_rows(const TextAssembler self, int max_rows)\n");
  }
  return -1;
}

static PyObject *Dtool_TextAssembler_dynamic_merge_Getter(PyObject *self, void *) {
  const TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool TextAssembler::get_dynamic_merge(void) const
  bool return_value = ((*(const TextAssembler*)local_this).get_dynamic_merge)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextAssembler_dynamic_merge_Setter(PyObject *self, PyObject *arg, void *) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.dynamic_merge")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete dynamic_merge attribute");
    return -1;
  }
  // 1-inline void TextAssembler::set_dynamic_merge(bool dynamic_merge)
  ((*local_this).set_dynamic_merge)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dynamic_merge(const TextAssembler self, bool dynamic_merge)\n");
  }
  return -1;
}

static PyObject *Dtool_TextAssembler_multiline_mode_Getter(PyObject *self, void *) {
  const TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool TextAssembler::get_multiline_mode(void) const
  bool return_value = ((*(const TextAssembler*)local_this).get_multiline_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextAssembler_multiline_mode_Setter(PyObject *self, PyObject *arg, void *) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.multiline_mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete multiline_mode attribute");
    return -1;
  }
  // 1-inline void TextAssembler::set_multiline_mode(bool flag)
  ((*local_this).set_multiline_mode)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_multiline_mode(const TextAssembler self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_TextAssembler_properties_Getter(PyObject *self, void *) {
  const TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline TextProperties const &TextAssembler::get_properties(void) const
  TextProperties const *return_value = &(((*(const TextAssembler*)local_this).get_properties)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, true);
}

static int Dtool_TextAssembler_properties_Setter(PyObject *self, PyObject *arg, void *) {
  TextAssembler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.properties")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete properties attribute");
    return -1;
  }
  // 1-inline void TextAssembler::set_properties(TextProperties const &properties)
  TextProperties const *arg_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextProperties, 1, "TextAssembler.set_properties", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_properties)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_properties(const TextAssembler self, const TextProperties properties)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * TextAssembler::TextAssembler(TextAssembler const &copy)
 * explicit TextAssembler::TextAssembler(TextEncoder *encoder)
 */
static int Dtool_Init_TextAssembler(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TextAssembler() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 TextAssembler::TextAssembler(TextAssembler const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      TextAssembler const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TextAssembler);
      if (param0_this != nullptr) {
        TextAssembler *return_value = new TextAssembler(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextAssembler, true, false);
      }
    }
  }

  {
    // -2 explicit TextAssembler::TextAssembler(TextEncoder *encoder)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "encoder")) {
      TextEncoder *param0_this = (TextEncoder *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TextEncoder, 0, "TextAssembler.TextAssembler", false, false);
      if (param0_this != nullptr) {
        TextAssembler *return_value = new TextAssembler(param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextAssembler, true, false);
      }
    }
  }

  // No coercion possible: TextAssembler::TextAssembler(TextAssembler const &copy)
  // No coercion possible: explicit TextAssembler::TextAssembler(TextEncoder *encoder)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextAssembler(const TextAssembler copy)\n"
      "TextAssembler(TextEncoder encoder)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextAssembler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextAssembler) {
    printf("TextAssembler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextAssembler *local_this = (TextAssembler *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextAssembler) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextAssembler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextAssembler) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextNode
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_line_height(void) const
 */
static PyObject *Dtool_TextNode_get_line_height_368(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextNode::get_line_height(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_line_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_line_height_368_comment =
  "C++ Interface:\n"
  "get_line_height(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units high each line of text is.  This is based on\n"
  " * the font.  Note that it is possible for the text to include nested font\n"
  " * change commands, in which case the value of this method is questionable.\n"
  " */";
#else
static const char *Dtool_TextNode_get_line_height_368_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_max_rows(int max_rows)
 */
static PyObject *Dtool_TextNode_set_max_rows_369(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_max_rows")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_max_rows(int max_rows)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_max_rows)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_rows(const TextNode self, int max_rows)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_max_rows_369_comment =
  "C++ Interface:\n"
  "set_max_rows(const TextNode self, int max_rows)\n"
  "\n"
  "/**\n"
  " * Sets the maximum number of rows that may be formatted by the TextNode.  If\n"
  " * more text than this is attempted, it will be truncated and has_overflow()\n"
  " * will return true.\n"
  " */";
#else
static const char *Dtool_TextNode_set_max_rows_369_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_max_rows(void)
 */
static PyObject *Dtool_TextNode_clear_max_rows_370(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_max_rows")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_max_rows(void)
  ((*local_this).clear_max_rows)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_max_rows_370_comment =
  "C++ Interface:\n"
  "clear_max_rows(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Resets the TextNode's default behavior of not limiting the number of rows\n"
  " * of text.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_max_rows_370_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_max_rows(void) const
 */
static PyObject *Dtool_TextNode_has_max_rows_371(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline bool TextNode::has_max_rows(void) const
  bool return_value = ((*(const TextNode*)local_this).has_max_rows)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_max_rows_371_comment =
  "C++ Interface:\n"
  "has_max_rows(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if a limit on the height of the TextNode has been set via\n"
  " * set_max_rows(), false otherwise.\n"
  " */";
#else
static const char *Dtool_TextNode_has_max_rows_371_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextNode::get_max_rows(void) const
 */
static PyObject *Dtool_TextNode_get_max_rows_372(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline int TextNode::get_max_rows(void) const
  int return_value = ((*(const TextNode*)local_this).get_max_rows)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_max_rows_372_comment =
  "C++ Interface:\n"
  "get_max_rows(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the limit on the height of the TextNode specified by\n"
  " * set_max_rows().\n"
  " */";
#else
static const char *Dtool_TextNode_get_max_rows_372_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_overflow(void) const
 */
static PyObject *Dtool_TextNode_has_overflow_373(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline bool TextNode::has_overflow(void) const
  bool return_value = ((*(const TextNode*)local_this).has_overflow)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_overflow_373_comment =
  "C++ Interface:\n"
  "has_overflow(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the last text set on the text node exceeded the max_rows\n"
  " * constraint, or false if it all fit.\n"
  " */";
#else
static const char *Dtool_TextNode_has_overflow_373_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_frame_color(LColor const &frame_color)
 * inline void TextNode::set_frame_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextNode_set_frame_color_374(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_frame_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "frame_color")) {
        // 1-inline void TextNode::set_frame_color(LColor const &frame_color)
        LVecBase4f arg_local;
        LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_frame_color", "LVecBase4f");
        }
        ((*local_this).set_frame_color)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void TextNode::set_frame_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_frame_color)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_frame_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_color(const TextNode self, const LVecBase4f frame_color)\n"
      "set_frame_color(const TextNode self, float r, float g, float b, float a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_frame_color_374_comment =
  "C++ Interface:\n"
  "set_frame_color(const TextNode self, const LVecBase4f frame_color)\n"
  "set_frame_color(const TextNode self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_frame_color_374_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor TextNode::get_frame_color(void) const
 */
static PyObject *Dtool_TextNode_get_frame_color_375(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline LColor TextNode::get_frame_color(void) const
  LColor *return_value = new LColor(((*(const TextNode*)local_this).get_frame_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_frame_color_375_comment =
  "C++ Interface:\n"
  "get_frame_color(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_frame_color_375_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_border(PN_stdfloat size, PN_stdfloat uv_portion)
 */
static PyObject *Dtool_TextNode_set_card_border_376(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_border")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_card_border(PN_stdfloat size, PN_stdfloat uv_portion)
  float param1;
  float param2;
  static const char *keyword_list[] = {"size", "uv_portion", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_card_border", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_card_border)((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_border(const TextNode self, float size, float uv_portion)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_border_376_comment =
  "C++ Interface:\n"
  "set_card_border(const TextNode self, float size, float uv_portion)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_border_376_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_card_border(void)
 */
static PyObject *Dtool_TextNode_clear_card_border_377(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_card_border")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_card_border(void)
  ((*local_this).clear_card_border)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_card_border_377_comment =
  "C++ Interface:\n"
  "clear_card_border(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_card_border_377_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_card_border_size(void) const
 */
static PyObject *Dtool_TextNode_get_card_border_size_378(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextNode::get_card_border_size(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_card_border_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_border_size_378_comment =
  "C++ Interface:\n"
  "get_card_border_size(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_border_size_378_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_card_border_uv_portion(void) const
 */
static PyObject *Dtool_TextNode_get_card_border_uv_portion_379(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextNode::get_card_border_uv_portion(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_card_border_uv_portion)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_border_uv_portion_379_comment =
  "C++ Interface:\n"
  "get_card_border_uv_portion(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_border_uv_portion_379_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_card_border(void) const
 */
static PyObject *Dtool_TextNode_has_card_border_380(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline bool TextNode::has_card_border(void) const
  bool return_value = ((*(const TextNode*)local_this).has_card_border)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_card_border_380_comment =
  "C++ Interface:\n"
  "has_card_border(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_has_card_border_380_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_color(LColor const &card_color)
 * inline void TextNode::set_card_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextNode_set_card_color_381(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "card_color")) {
        // 1-inline void TextNode::set_card_color(LColor const &card_color)
        LVecBase4f arg_local;
        LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_card_color", "LVecBase4f");
        }
        ((*local_this).set_card_color)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void TextNode::set_card_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_card_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_card_color)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_card_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_color(const TextNode self, const LVecBase4f card_color)\n"
      "set_card_color(const TextNode self, float r, float g, float b, float a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_color_381_comment =
  "C++ Interface:\n"
  "set_card_color(const TextNode self, const LVecBase4f card_color)\n"
  "set_card_color(const TextNode self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_color_381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor TextNode::get_card_color(void) const
 */
static PyObject *Dtool_TextNode_get_card_color_382(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline LColor TextNode::get_card_color(void) const
  LColor *return_value = new LColor(((*(const TextNode*)local_this).get_card_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_color_382_comment =
  "C++ Interface:\n"
  "get_card_color(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_color_382_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_texture(Texture *card_texture)
 */
static PyObject *Dtool_TextNode_set_card_texture_383(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_texture")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_card_texture(Texture *card_texture)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "TextNode.set_card_texture", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_card_texture)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_texture(const TextNode self, Texture card_texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_texture_383_comment =
  "C++ Interface:\n"
  "set_card_texture(const TextNode self, Texture card_texture)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_texture_383_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_card_texture(void)
 */
static PyObject *Dtool_TextNode_clear_card_texture_384(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_card_texture")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_card_texture(void)
  ((*local_this).clear_card_texture)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_card_texture_384_comment =
  "C++ Interface:\n"
  "clear_card_texture(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_card_texture_384_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_card_texture(void) const
 */
static PyObject *Dtool_TextNode_has_card_texture_385(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline bool TextNode::has_card_texture(void) const
  bool return_value = ((*(const TextNode*)local_this).has_card_texture)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_card_texture_385_comment =
  "C++ Interface:\n"
  "has_card_texture(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_has_card_texture_385_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *TextNode::get_card_texture(void) const
 */
static PyObject *Dtool_TextNode_get_card_texture_386(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline Texture *TextNode::get_card_texture(void) const
  Texture *return_value = ((*(const TextNode*)local_this).get_card_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_texture_386_comment =
  "C++ Interface:\n"
  "get_card_texture(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_texture_386_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_frame_as_margin(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_TextNode_set_frame_as_margin_387(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_frame_as_margin")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_frame_as_margin(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"left", "right", "bottom", "top", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame_as_margin", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_frame_as_margin)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_as_margin(const TextNode self, float left, float right, float bottom, float top)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_frame_as_margin_387_comment =
  "C++ Interface:\n"
  "set_frame_as_margin(const TextNode self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Specifies that a border will be drawn around the text when it is next\n"
  " * created.  The parameters are the amount of additional padding to insert\n"
  " * between the frame and the text in each dimension, and all should generally\n"
  " * be positive.\n"
  " */";
#else
static const char *Dtool_TextNode_set_frame_as_margin_387_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_frame_actual(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_TextNode_set_frame_actual_388(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_frame_actual")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_frame_actual(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"left", "right", "bottom", "top", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame_actual", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_frame_actual)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_actual(const TextNode self, float left, float right, float bottom, float top)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_frame_actual_388_comment =
  "C++ Interface:\n"
  "set_frame_actual(const TextNode self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Similar to set_frame_as_margin, except the frame is specified in actual\n"
  " * coordinate units (relative to the text's origin), irrespective of the size\n"
  " * of the text.  The left and bottom coordinates should generally be negative,\n"
  " * while the right and top coordinates should generally be positive.\n"
  " */";
#else
static const char *Dtool_TextNode_set_frame_actual_388_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_frame(void)
 */
static PyObject *Dtool_TextNode_clear_frame_389(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_frame")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_frame(void)
  ((*local_this).clear_frame)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_frame_389_comment =
  "C++ Interface:\n"
  "clear_frame(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Specifies that a border will not be drawn around the text.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_frame_389_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_frame(void) const
 */
static PyObject *Dtool_TextNode_has_frame_390(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline bool TextNode::has_frame(void) const
  bool return_value = ((*(const TextNode*)local_this).has_frame)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_frame_390_comment =
  "C++ Interface:\n"
  "has_frame(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_has_frame_390_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::is_frame_as_margin(void) const
 */
static PyObject *Dtool_TextNode_is_frame_as_margin_391(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline bool TextNode::is_frame_as_margin(void) const
  bool return_value = ((*(const TextNode*)local_this).is_frame_as_margin)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_is_frame_as_margin_391_comment =
  "C++ Interface:\n"
  "is_frame_as_margin(TextNode self)\n"
  "\n"
  "/**\n"
  " * If this is true, the frame was set via a call to set_frame_as_margin(), and\n"
  " * the dimension of the frame as returned by get_frame_as_set() represent a\n"
  " * margin all around the text.  If false, then the frame was set via a call to\n"
  " * set_frame_actual(), and the dimensions of the frame as returned by\n"
  " * get_frame_as_set() are relative to the text's origin.\n"
  " */";
#else
static const char *Dtool_TextNode_is_frame_as_margin_391_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextNode::get_frame_as_set(void) const
 */
static PyObject *Dtool_TextNode_get_frame_as_set_392(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline LVecBase4 TextNode::get_frame_as_set(void) const
  LVecBase4 *return_value = new LVecBase4(((*(const TextNode*)local_this).get_frame_as_set)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_frame_as_set_392_comment =
  "C++ Interface:\n"
  "get_frame_as_set(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the dimensions of the frame as set by set_frame_as_margin() or\n"
  " * set_frame_actual().  Use is_frame_actual() to determine how to interpret\n"
  " * the values returned by this function.  It is an error to call this if\n"
  " * has_frame() is false.\n"
  " */";
#else
static const char *Dtool_TextNode_get_frame_as_set_392_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextNode::get_frame_actual(void) const
 */
static PyObject *Dtool_TextNode_get_frame_actual_393(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline LVecBase4 TextNode::get_frame_actual(void) const
  LVecBase4 *return_value = new LVecBase4(((*(const TextNode*)local_this).get_frame_actual)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_frame_actual_393_comment =
  "C++ Interface:\n"
  "get_frame_actual(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the actual dimensions of the frame around the text.  If the frame\n"
  " * was set via set_frame_as_margin(), the result returned by this function\n"
  " * reflects the size of the current text; if the frame was set via\n"
  " * set_frame_actual(), this returns the values actually set.\n"
  " *\n"
  " * If the text has no frame at all, this returns the dimensions of the text\n"
  " * itself, as if the frame were set with a margin of 0, 0, 0, 0.\n"
  " */";
#else
static const char *Dtool_TextNode_get_frame_actual_393_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_frame_line_width(PN_stdfloat line_width)
 */
static PyObject *Dtool_TextNode_set_frame_line_width_394(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_frame_line_width")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_frame_line_width(PN_stdfloat line_width)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_frame_line_width)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_line_width(const TextNode self, float line_width)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_frame_line_width_394_comment =
  "C++ Interface:\n"
  "set_frame_line_width(const TextNode self, float line_width)\n"
  "\n"
  "/**\n"
  " * Specifies the thickness of the lines that will be used to draw the frame.\n"
  " */";
#else
static const char *Dtool_TextNode_set_frame_line_width_394_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_frame_line_width(void) const
 */
static PyObject *Dtool_TextNode_get_frame_line_width_395(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextNode::get_frame_line_width(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_frame_line_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_frame_line_width_395_comment =
  "C++ Interface:\n"
  "get_frame_line_width(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the thickness of the lines that will be used to draw the frame.\n"
  " */";
#else
static const char *Dtool_TextNode_get_frame_line_width_395_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_frame_corners(bool corners)
 */
static PyObject *Dtool_TextNode_set_frame_corners_396(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_frame_corners")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_frame_corners(bool corners)
  ((*local_this).set_frame_corners)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_corners(const TextNode self, bool corners)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_frame_corners_396_comment =
  "C++ Interface:\n"
  "set_frame_corners(const TextNode self, bool corners)\n"
  "\n"
  "/**\n"
  " * Enables or disables the drawing of corners for the frame.  These are extra\n"
  " * points drawn at each of the four corners, to soften the ugly edges\n"
  " * generated when the line width is greater than one.\n"
  " */";
#else
static const char *Dtool_TextNode_set_frame_corners_396_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::get_frame_corners(void) const
 */
static PyObject *Dtool_TextNode_get_frame_corners_397(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline bool TextNode::get_frame_corners(void) const
  bool return_value = ((*(const TextNode*)local_this).get_frame_corners)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_frame_corners_397_comment =
  "C++ Interface:\n"
  "get_frame_corners(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_frame_corners_397_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_as_margin(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_TextNode_set_card_as_margin_398(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_as_margin")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_card_as_margin(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"left", "right", "bottom", "top", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_card_as_margin", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_card_as_margin)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_as_margin(const TextNode self, float left, float right, float bottom, float top)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_as_margin_398_comment =
  "C++ Interface:\n"
  "set_card_as_margin(const TextNode self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Specifies that a (possibly opaque or semitransparent) card will be held\n"
  " * behind the text when it is next created.  Like set_frame_as_margin, the\n"
  " * parameters are the amount of additional padding to insert around the text\n"
  " * in each dimension, and all should generally be positive.\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_as_margin_398_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_actual(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_TextNode_set_card_actual_399(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_actual")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_card_actual(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"left", "right", "bottom", "top", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_card_actual", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_card_actual)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_actual(const TextNode self, float left, float right, float bottom, float top)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_actual_399_comment =
  "C++ Interface:\n"
  "set_card_actual(const TextNode self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Similar to set_card_as_margin, except the card is specified in actual\n"
  " * coordinate units (relative to the text's origin), irrespective of the size\n"
  " * of the text.  The left and bottom coordinates should generally be negative,\n"
  " * while the right and top coordinates should generally be positive.\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_actual_399_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_decal(bool card_decal)
 */
static PyObject *Dtool_TextNode_set_card_decal_400(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_decal")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_card_decal(bool card_decal)
  ((*local_this).set_card_decal)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_decal(const TextNode self, bool card_decal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_decal_400_comment =
  "C++ Interface:\n"
  "set_card_decal(const TextNode self, bool card_decal)\n"
  "\n"
  "/**\n"
  " * Sets the card_decal flag.  When this is true, the text is decalled onto the\n"
  " * card, which is necessary if the TextNode is to be rendered in the 3-d world\n"
  " * without putting it in a bin.\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_decal_400_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_card(void)
 */
static PyObject *Dtool_TextNode_clear_card_401(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_card")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_card(void)
  ((*local_this).clear_card)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_card_401_comment =
  "C++ Interface:\n"
  "clear_card(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Specifies that a card will not be drawn behind the text.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_card_401_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_card(void) const
 */
static PyObject *Dtool_TextNode_has_card_402(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline bool TextNode::has_card(void) const
  bool return_value = ((*(const TextNode*)local_this).has_card)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_card_402_comment =
  "C++ Interface:\n"
  "has_card(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_has_card_402_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::get_card_decal(void) const
 */
static PyObject *Dtool_TextNode_get_card_decal_403(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline bool TextNode::get_card_decal(void) const
  bool return_value = ((*(const TextNode*)local_this).get_card_decal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_decal_403_comment =
  "C++ Interface:\n"
  "get_card_decal(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the card_decal flag.  See set_card_decal().\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_decal_403_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::is_card_as_margin(void) const
 */
static PyObject *Dtool_TextNode_is_card_as_margin_404(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline bool TextNode::is_card_as_margin(void) const
  bool return_value = ((*(const TextNode*)local_this).is_card_as_margin)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_is_card_as_margin_404_comment =
  "C++ Interface:\n"
  "is_card_as_margin(TextNode self)\n"
  "\n"
  "/**\n"
  " * If this is true, the card was set via a call to set_card_as_margin(), and\n"
  " * the dimension of the card as returned by get_card_as_set() represent a\n"
  " * margin all around the text.  If false, then the card was set via a call to\n"
  " * set_card_actual(), and the dimensions of the card as returned by\n"
  " * get_card_as_set() are relative to the text's origin.\n"
  " */";
#else
static const char *Dtool_TextNode_is_card_as_margin_404_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextNode::get_card_as_set(void) const
 */
static PyObject *Dtool_TextNode_get_card_as_set_405(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline LVecBase4 TextNode::get_card_as_set(void) const
  LVecBase4 *return_value = new LVecBase4(((*(const TextNode*)local_this).get_card_as_set)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_as_set_405_comment =
  "C++ Interface:\n"
  "get_card_as_set(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the dimensions of the card as set by set_card_as_margin() or\n"
  " * set_card_actual().  Use is_card_actual() to determine how to interpret the\n"
  " * values returned by this function.  It is an error to call this if\n"
  " * has_card() is false.\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_as_set_405_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextNode::get_card_actual(void) const
 */
static PyObject *Dtool_TextNode_get_card_actual_406(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline LVecBase4 TextNode::get_card_actual(void) const
  LVecBase4 *return_value = new LVecBase4(((*(const TextNode*)local_this).get_card_actual)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_actual_406_comment =
  "C++ Interface:\n"
  "get_card_actual(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the actual dimensions of the card around the text.  If the card was\n"
  " * set via set_card_as_margin(), the result returned by this function reflects\n"
  " * the size of the current text; if the card was set via set_card_actual(),\n"
  " * this returns the values actually set.\n"
  " *\n"
  " * If the text has no card at all, this returns the dimensions of the text\n"
  " * itself, as if the card were set with a margin of 0, 0, 0, 0.\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_actual_406_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextNode::get_card_transformed(void) const
 */
static PyObject *Dtool_TextNode_get_card_transformed_407(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline LVecBase4 TextNode::get_card_transformed(void) const
  LVecBase4 *return_value = new LVecBase4(((*(const TextNode*)local_this).get_card_transformed)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_transformed_407_comment =
  "C++ Interface:\n"
  "get_card_transformed(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the actual card dimensions, transformed by the matrix set by\n"
  " * set_transform().  This returns the card dimensions in actual coordinates as\n"
  " * seen by the rest of the world.  Also see get_upper_left_3d() and\n"
  " * get_lower_right_3d().\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_transformed_407_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_transform(LMatrix4 const &transform)
 */
static PyObject *Dtool_TextNode_set_transform_408(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_transform")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_transform(LMatrix4 const &transform)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_transform", "LMatrix4f");
  }
  ((*local_this).set_transform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform(const TextNode self, const LMatrix4f transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_transform_408_comment =
  "C++ Interface:\n"
  "set_transform(const TextNode self, const LMatrix4f transform)\n"
  "\n"
  "/**\n"
  " * Sets an additional transform that is applied to the entire text paragraph.\n"
  " */";
#else
static const char *Dtool_TextNode_set_transform_408_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 TextNode::get_transform(void) const
 */
static PyObject *Dtool_TextNode_get_transform_409(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4 TextNode::get_transform(void) const
  LMatrix4 *return_value = new LMatrix4(((*(const TextNode*)local_this).get_transform)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_transform_409_comment =
  "C++ Interface:\n"
  "get_transform(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_transform_409_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_TextNode_set_coordinate_system_410(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_coordinate_system")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_coordinate_system)((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const TextNode self, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_coordinate_system_410_comment =
  "C++ Interface:\n"
  "set_coordinate_system(const TextNode self, int cs)\n"
  "\n"
  "/**\n"
  " * Specifies the coordinate system in which the text will be generated.\n"
  " */";
#else
static const char *Dtool_TextNode_set_coordinate_system_410_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem TextNode::get_coordinate_system(void) const
 */
static PyObject *Dtool_TextNode_get_coordinate_system_411(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline CoordinateSystem TextNode::get_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const TextNode*)local_this).get_coordinate_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_coordinate_system_411_comment =
  "C++ Interface:\n"
  "get_coordinate_system(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_coordinate_system_411_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_usage_hint(GeomEnums::UsageHint usage_hint)
 */
static PyObject *Dtool_TextNode_set_usage_hint_412(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_usage_hint")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_usage_hint)((GeomEnums::UsageHint)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const TextNode self, int usage_hint)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_usage_hint_412_comment =
  "C++ Interface:\n"
  "set_usage_hint(const TextNode self, int usage_hint)\n"
  "\n"
  "/**\n"
  " * Specifies the UsageHint that will be applied to generated geometry.  The\n"
  " * default is UH_static, which is probably the right setting, but if you know\n"
  " * the TextNode's geometry will have a short lifespan, it may be better to set\n"
  " * it to UH_stream.  See geomEnums.h.\n"
  " */";
#else
static const char *Dtool_TextNode_set_usage_hint_412_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::UsageHint TextNode::get_usage_hint(void) const
 */
static PyObject *Dtool_TextNode_get_usage_hint_413(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline GeomEnums::UsageHint TextNode::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const TextNode*)local_this).get_usage_hint)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_usage_hint_413_comment =
  "C++ Interface:\n"
  "get_usage_hint(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the UsageHint that will be applied to generated geometry.  See\n"
  " * set_usage_hint().\n"
  " */";
#else
static const char *Dtool_TextNode_get_usage_hint_413_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_flatten_flags(int flatten_flags)
 */
static PyObject *Dtool_TextNode_set_flatten_flags_414(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_flatten_flags")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_flatten_flags(int flatten_flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_flatten_flags)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flatten_flags(const TextNode self, int flatten_flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_flatten_flags_414_comment =
  "C++ Interface:\n"
  "set_flatten_flags(const TextNode self, int flatten_flags)\n"
  "\n"
  "/**\n"
  " * Sets the flatten flags.  This should be a union of the\n"
  " * TextNode::FlattenFlags options.  This controls the degree of flattening\n"
  " * performed on the TextNode's internal geometry (i.e.  the scene graph\n"
  " * returned by generate()) each time the text is changed.  In general, more\n"
  " * flattening means a more optimal result, but it will take more time to\n"
  " * generate.\n"
  " *\n"
  " * The choice may be any of these three:\n"
  " *\n"
  " * FF_none - No flatten operation is called.  The letters are left as\n"
  " * independent Geoms.\n"
  " *\n"
  " * FF_light - A flatten_light() operation is called.  The attributes are\n"
  " * applied to the vertices, but no nodes are removed.\n"
  " *\n"
  " * FF_medium - A flatten_medium() operation is called.  The attributes are\n"
  " * applied to the vertices, and a few trivial nodes are removed.\n"
  " *\n"
  " * FF_strong - A flatten_strong() operation is called.  The attributes are\n"
  " * applied to the vertices, and the resulting nodes are aggressively combined\n"
  " * into as few nodes as possible.\n"
  " *\n"
  " * In addition to the above choices, you may optionally include the following\n"
  " * flag:\n"
  " *\n"
  " * FF_dynamic_merge - Copy the geoms into a single GeomVertexData as we go,\n"
  " * instead of relying on the flatten operation at the end.  This pre-flattens\n"
  " * the text considerably, and may obviate the need for flatten altogether; it\n"
  " * also tends to improve performance considerably even if you do call flatten.\n"
  " * However, it is not as fast as not calling flatten at all.\n"
  " *\n"
  " * The default is taken from the text-flatten and text-dynamic-merge config\n"
  " * variables.\n"
  " */";
#else
static const char *Dtool_TextNode_set_flatten_flags_414_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextNode::get_flatten_flags(void) const
 */
static PyObject *Dtool_TextNode_get_flatten_flags_415(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline int TextNode::get_flatten_flags(void) const
  int return_value = ((*(const TextNode*)local_this).get_flatten_flags)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_flatten_flags_415_comment =
  "C++ Interface:\n"
  "get_flatten_flags(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the flatten flags.  See set_flatten_flags().\n"
  " */";
#else
static const char *Dtool_TextNode_get_flatten_flags_415_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_font(TextFont *font)
 */
static PyObject *Dtool_TextNode_set_font_416(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_font")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_font(TextFont *font)
  TextFont *arg_this = (TextFont *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextFont, 1, "TextNode.set_font", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_font)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_font(const TextNode self, TextFont font)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_font_416_comment =
  "C++ Interface:\n"
  "set_font(const TextNode self, TextFont font)\n"
  "\n"
  "/**\n"
  " * Sets the font that will be used when making text.  If this is set to NULL,\n"
  " * the default font will be used, which can be set via set_default_font().\n"
  " */";
#else
static const char *Dtool_TextNode_set_font_416_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_font(void)
 */
static PyObject *Dtool_TextNode_clear_font_417(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_font")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_font(void)
  ((*local_this).clear_font)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_font_417_comment =
  "C++ Interface:\n"
  "clear_font(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Resets the font to the default font.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_font_417_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_small_caps(bool small_caps)
 */
static PyObject *Dtool_TextNode_set_small_caps_418(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_small_caps")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_small_caps(bool small_caps)
  ((*local_this).set_small_caps)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_small_caps(const TextNode self, bool small_caps)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_small_caps_418_comment =
  "C++ Interface:\n"
  "set_small_caps(const TextNode self, bool small_caps)\n"
  "\n"
  "/**\n"
  " * Sets the small_caps flag.  When this is set, lowercase letters are\n"
  " * generated as scaled-down versions of their uppercase equivalents.  This is\n"
  " * particularly useful to set for fonts that do not have lowercase letters.\n"
  " *\n"
  " * It is also a good idea to set this for a (dynamic) font that has already\n"
  " * implemented lowercase letters as scaled-down versions of their uppercase\n"
  " * equivalents, since without this flag the texture memory may needlessly\n"
  " * duplicate equivalent glyphs for upper and lowercase letters.  Setting this\n"
  " * flag causes the texture memory to share the mixed-case letters.\n"
  " *\n"
  " * The amount by which the lowercase letters are scaled is specified by\n"
  " * set_small_caps_scale().\n"
  " */";
#else
static const char *Dtool_TextNode_set_small_caps_418_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_small_caps(void)
 */
static PyObject *Dtool_TextNode_clear_small_caps_419(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_small_caps")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_small_caps(void)
  ((*local_this).clear_small_caps)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_small_caps_419_comment =
  "C++ Interface:\n"
  "clear_small_caps(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_small_caps_419_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_small_caps_scale(PN_stdfloat small_caps_scale)
 */
static PyObject *Dtool_TextNode_set_small_caps_scale_420(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_small_caps_scale")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_small_caps_scale(PN_stdfloat small_caps_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_small_caps_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_small_caps_scale(const TextNode self, float small_caps_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_small_caps_scale_420_comment =
  "C++ Interface:\n"
  "set_small_caps_scale(const TextNode self, float small_caps_scale)\n"
  "\n"
  "/**\n"
  " * Sets the scale factor applied to lowercase letters from their uppercase\n"
  " * equivalents, when the small_caps flag is in effect.  See set_small_caps().\n"
  " * Normally, this will be a number less than one.\n"
  " */";
#else
static const char *Dtool_TextNode_set_small_caps_scale_420_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_small_caps_scale(void)
 */
static PyObject *Dtool_TextNode_clear_small_caps_scale_421(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_small_caps_scale")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_small_caps_scale(void)
  ((*local_this).clear_small_caps_scale)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_small_caps_scale_421_comment =
  "C++ Interface:\n"
  "clear_small_caps_scale(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_small_caps_scale_421_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_slant(PN_stdfloat slant)
 */
static PyObject *Dtool_TextNode_set_slant_422(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_slant")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_slant(PN_stdfloat slant)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_slant)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slant(const TextNode self, float slant)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_slant_422_comment =
  "C++ Interface:\n"
  "set_slant(const TextNode self, float slant)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_slant_422_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_slant(void)
 */
static PyObject *Dtool_TextNode_clear_slant_423(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_slant")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_slant(void)
  ((*local_this).clear_slant)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_slant_423_comment =
  "C++ Interface:\n"
  "clear_slant(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_slant_423_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_align(TextProperties::Alignment align_type)
 */
static PyObject *Dtool_TextNode_set_align_424(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_align")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_align(TextProperties::Alignment align_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_align)((TextProperties::Alignment)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_align(const TextNode self, int align_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_align_424_comment =
  "C++ Interface:\n"
  "set_align(const TextNode self, int align_type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_align_424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_align(void)
 */
static PyObject *Dtool_TextNode_clear_align_425(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_align")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_align(void)
  ((*local_this).clear_align)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_align_425_comment =
  "C++ Interface:\n"
  "clear_align(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_align_425_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_indent(PN_stdfloat indent)
 */
static PyObject *Dtool_TextNode_set_indent_426(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_indent")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_indent(PN_stdfloat indent)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_indent)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_indent(const TextNode self, float indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_indent_426_comment =
  "C++ Interface:\n"
  "set_indent(const TextNode self, float indent)\n"
  "\n"
  "/**\n"
  " * Specifies the amount of extra space that is inserted before the first\n"
  " * character of each line.  This can be thought of as a left margin.\n"
  " */";
#else
static const char *Dtool_TextNode_set_indent_426_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_indent(void)
 */
static PyObject *Dtool_TextNode_clear_indent_427(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_indent")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_indent(void)
  ((*local_this).clear_indent)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_indent_427_comment =
  "C++ Interface:\n"
  "clear_indent(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_indent_427_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_wordwrap(PN_stdfloat wordwrap)
 */
static PyObject *Dtool_TextNode_set_wordwrap_428(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_wordwrap")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_wordwrap(PN_stdfloat wordwrap)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_wordwrap)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wordwrap(const TextNode self, float wordwrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_wordwrap_428_comment =
  "C++ Interface:\n"
  "set_wordwrap(const TextNode self, float wordwrap)\n"
  "\n"
  "/**\n"
  " * Sets the text up to automatically wordwrap when it exceeds the indicated\n"
  " * width.  This can be thought of as a right margin or margin width.\n"
  " */";
#else
static const char *Dtool_TextNode_set_wordwrap_428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_wordwrap(void)
 */
static PyObject *Dtool_TextNode_clear_wordwrap_429(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_wordwrap")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_wordwrap(void)
  ((*local_this).clear_wordwrap)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_wordwrap_429_comment =
  "C++ Interface:\n"
  "clear_wordwrap(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Removes the wordwrap setting from the TextNode.  Text will be as wide as it\n"
  " * is.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_wordwrap_429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_text_color(LColor const &text_color)
 * inline void TextNode::set_text_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextNode_set_text_color_430(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_text_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "text_color")) {
        // 1-inline void TextNode::set_text_color(LColor const &text_color)
        LVecBase4f arg_local;
        LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_text_color", "LVecBase4f");
        }
        ((*local_this).set_text_color)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void TextNode::set_text_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_text_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_text_color)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_text_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text_color(const TextNode self, const LVecBase4f text_color)\n"
      "set_text_color(const TextNode self, float r, float g, float b, float a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_text_color_430_comment =
  "C++ Interface:\n"
  "set_text_color(const TextNode self, const LVecBase4f text_color)\n"
  "set_text_color(const TextNode self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_text_color_430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_text_color(void)
 */
static PyObject *Dtool_TextNode_clear_text_color_431(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_text_color")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_text_color(void)
  ((*local_this).clear_text_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_text_color_431_comment =
  "C++ Interface:\n"
  "clear_text_color(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Removes the text color specification; the text will be colored whatever it\n"
  " * was in the source font file.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_text_color_431_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_shadow_color(LColor const &shadow_color)
 * inline void TextNode::set_shadow_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextNode_set_shadow_color_432(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_shadow_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "shadow_color")) {
        // 1-inline void TextNode::set_shadow_color(LColor const &shadow_color)
        LVecBase4f arg_local;
        LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_shadow_color", "LVecBase4f");
        }
        ((*local_this).set_shadow_color)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void TextNode::set_shadow_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_shadow_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_shadow_color)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shadow_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_color(const TextNode self, const LVecBase4f shadow_color)\n"
      "set_shadow_color(const TextNode self, float r, float g, float b, float a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_shadow_color_432_comment =
  "C++ Interface:\n"
  "set_shadow_color(const TextNode self, const LVecBase4f shadow_color)\n"
  "set_shadow_color(const TextNode self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_shadow_color_432_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_shadow_color(void)
 */
static PyObject *Dtool_TextNode_clear_shadow_color_433(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_shadow_color")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_shadow_color(void)
  ((*local_this).clear_shadow_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_shadow_color_433_comment =
  "C++ Interface:\n"
  "clear_shadow_color(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_shadow_color_433_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_shadow(LVecBase2 const &shadow_offset)
 * inline void TextNode::set_shadow(PN_stdfloat xoffset, PN_stdfloat yoffset)
 */
static PyObject *Dtool_TextNode_set_shadow_434(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_shadow")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "shadow_offset")) {
        // 1-inline void TextNode::set_shadow(LVecBase2 const &shadow_offset)
        LVecBase2f arg_local;
        LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_shadow", "LVecBase2f");
        }
        ((*local_this).set_shadow)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void TextNode::set_shadow(PN_stdfloat xoffset, PN_stdfloat yoffset)
      float param1;
      float param2;
      static const char *keyword_list[] = {"xoffset", "yoffset", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_shadow", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_shadow)((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shadow() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow(const TextNode self, const LVecBase2f shadow_offset)\n"
      "set_shadow(const TextNode self, float xoffset, float yoffset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_shadow_434_comment =
  "C++ Interface:\n"
  "set_shadow(const TextNode self, const LVecBase2f shadow_offset)\n"
  "set_shadow(const TextNode self, float xoffset, float yoffset)\n"
  "\n"
  "/**\n"
  " * Specifies that the text should be drawn with a shadow, by creating a second\n"
  " * copy of the text and offsetting it slightly behind the first.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies that the text should be drawn with a shadow, by creating a second\n"
  " * copy of the text and offsetting it slightly behind the first.\n"
  " */";
#else
static const char *Dtool_TextNode_set_shadow_434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_shadow(void)
 */
static PyObject *Dtool_TextNode_clear_shadow_435(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_shadow")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_shadow(void)
  ((*local_this).clear_shadow)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_shadow_435_comment =
  "C++ Interface:\n"
  "clear_shadow(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Specifies that a shadow will not be drawn behind the text.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_shadow_435_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_bin(std::string const &bin)
 */
static PyObject *Dtool_TextNode_set_bin_436(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_bin")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_bin(std::string const &bin)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_bin)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin(const TextNode self, str bin)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_bin_436_comment =
  "C++ Interface:\n"
  "set_bin(const TextNode self, str bin)\n"
  "\n"
  "/**\n"
  " * Names the GeomBin that the TextNode geometry should be assigned to.  If\n"
  " * this is set, then a GeomBinTransition will be created to explicitly place\n"
  " * each component in the named bin.\n"
  " *\n"
  " * The draw_order value will also be passed to each GeomBinTransition as\n"
  " * appropriate; this is particularly useful if this names a GeomBinFixed, e.g.\n"
  " * \"fixed\".\n"
  " */";
#else
static const char *Dtool_TextNode_set_bin_436_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_bin(void)
 */
static PyObject *Dtool_TextNode_clear_bin_437(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_bin")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_bin(void)
  ((*local_this).clear_bin)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_bin_437_comment =
  "C++ Interface:\n"
  "clear_bin(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Removes the effect of a previous call to set_bin().  Text will be drawn in\n"
  " * whatever bin it would like to be drawn in, with no explicit ordering.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_bin_437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextNode::set_draw_order(int draw_order)
 */
static PyObject *Dtool_TextNode_set_draw_order_438(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_draw_order")) {
    return nullptr;
  }
  // 1-inline int TextNode::set_draw_order(int draw_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).set_draw_order)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_draw_order(const TextNode self, int draw_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_draw_order_438_comment =
  "C++ Interface:\n"
  "set_draw_order(const TextNode self, int draw_order)\n"
  "\n"
  "/**\n"
  " * Sets the drawing order of text created by the TextMaker.  This is actually\n"
  " * the draw order of the card and frame.  The shadow is drawn at\n"
  " * _draw_order+1, and the text at _draw_order+2.\n"
  " *\n"
  " * This affects the sorting order assigned to the arcs as they are created,\n"
  " * and also is passed to whatever bin may be assigned via set_bin().\n"
  " *\n"
  " * The return value is the first unused draw_order number, e.g.  _draw_order +\n"
  " * 3.\n"
  " */";
#else
static const char *Dtool_TextNode_set_draw_order_438_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_draw_order(void)
 */
static PyObject *Dtool_TextNode_clear_draw_order_439(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_draw_order")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_draw_order(void)
  ((*local_this).clear_draw_order)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_draw_order_439_comment =
  "C++ Interface:\n"
  "clear_draw_order(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_draw_order_439_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_tab_width(PN_stdfloat tab_width)
 */
static PyObject *Dtool_TextNode_set_tab_width_440(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_tab_width")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_tab_width(PN_stdfloat tab_width)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_tab_width)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tab_width(const TextNode self, float tab_width)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_tab_width_440_comment =
  "C++ Interface:\n"
  "set_tab_width(const TextNode self, float tab_width)\n"
  "\n"
  "/**\n"
  " * Sets the width of each tab stop, in screen units.  A tab character embedded\n"
  " * in the text will advance the horizontal position to the next tab stop.\n"
  " */";
#else
static const char *Dtool_TextNode_set_tab_width_440_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_tab_width(void)
 */
static PyObject *Dtool_TextNode_clear_tab_width_441(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_tab_width")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_tab_width(void)
  ((*local_this).clear_tab_width)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_tab_width_441_comment =
  "C++ Interface:\n"
  "clear_tab_width(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_tab_width_441_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_glyph_scale(PN_stdfloat glyph_scale)
 */
static PyObject *Dtool_TextNode_set_glyph_scale_442(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_glyph_scale")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_glyph_scale(PN_stdfloat glyph_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_glyph_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_glyph_scale(const TextNode self, float glyph_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_glyph_scale_442_comment =
  "C++ Interface:\n"
  "set_glyph_scale(const TextNode self, float glyph_scale)\n"
  "\n"
  "/**\n"
  " * Specifies the factor by which to scale each letter of the text as it is\n"
  " * placed.  This can be used (possibly in conjunction with set_glyph_shift())\n"
  " * to implement superscripting or subscripting.\n"
  " */";
#else
static const char *Dtool_TextNode_set_glyph_scale_442_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_glyph_scale(void)
 */
static PyObject *Dtool_TextNode_clear_glyph_scale_443(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_glyph_scale")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_glyph_scale(void)
  ((*local_this).clear_glyph_scale)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_glyph_scale_443_comment =
  "C++ Interface:\n"
  "clear_glyph_scale(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_glyph_scale_443_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_glyph_shift(PN_stdfloat glyph_shift)
 */
static PyObject *Dtool_TextNode_set_glyph_shift_444(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_glyph_shift")) {
    return nullptr;
  }
  // 1-inline void TextNode::set_glyph_shift(PN_stdfloat glyph_shift)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_glyph_shift)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_glyph_shift(const TextNode self, float glyph_shift)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_glyph_shift_444_comment =
  "C++ Interface:\n"
  "set_glyph_shift(const TextNode self, float glyph_shift)\n"
  "\n"
  "/**\n"
  " * Specifies a vertical amount to shift each letter of the text as it is\n"
  " * placed.  This can be used (possibly in conjunction with set_glyph_scale())\n"
  " * to implement superscripting or subscripting.\n"
  " */";
#else
static const char *Dtool_TextNode_set_glyph_shift_444_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_glyph_shift(void)
 */
static PyObject *Dtool_TextNode_clear_glyph_shift_445(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_glyph_shift")) {
    return nullptr;
  }
  // 1-inline void TextNode::clear_glyph_shift(void)
  ((*local_this).clear_glyph_shift)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_glyph_shift_445_comment =
  "C++ Interface:\n"
  "clear_glyph_shift(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_glyph_shift_445_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string TextNode::get_wordwrapped_text(void) const
 */
static PyObject *Dtool_TextNode_get_wordwrapped_text_446(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline std::string TextNode::get_wordwrapped_text(void) const
  std::string return_value = ((*(const TextNode*)local_this).get_wordwrapped_text)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_wordwrapped_text_446_comment =
  "C++ Interface:\n"
  "get_wordwrapped_text(TextNode self)\n"
  "\n"
  "// After the text has been set, you can query this to determine how it will\n"
  "// be wordwrapped.\n"
  "\n"
  "/**\n"
  " * Returns a string that represents the contents of the text, as it has been\n"
  " * formatted by wordwrap rules.\n"
  " *\n"
  " * In earlier versions, this did not contain any embedded special characters\n"
  " * like \\1 or \\3; now it does.\n"
  " */";
#else
static const char *Dtool_TextNode_get_wordwrapped_text_446_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::calc_width(std::string const &line) const
 * PN_stdfloat TextNode::calc_width(std::wstring const &line) const
 * PN_stdfloat TextNode::calc_width(wchar_t character) const
 */
static PyObject *Dtool_TextNode_calc_width_447(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  {
    // -2 PN_stdfloat TextNode::calc_width(std::wstring const &line) const
#if PY_VERSION_HEX >= 0x03020000
    PyObject *param1;
#else
    PyUnicodeObject *param1;
#endif
    if (PyArg_Parse(arg, "U:calc_width", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
      Py_ssize_t param1_len;
      wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
      Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
      wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
      PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
      PN_stdfloat return_value = ((*(const TextNode*)local_this).calc_width)(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
      PyMem_Free(param1_str);
#endif
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline PN_stdfloat TextNode::calc_width(std::string const &line) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      PN_stdfloat return_value = ((*(const TextNode*)local_this).calc_width)(std::string(param1_str, param1_len));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 PN_stdfloat TextNode::calc_width(wchar_t character) const
#if PY_VERSION_HEX >= 0x03020000
    PyObject *param1;
#else
    PyUnicodeObject *param1;
#endif
    if (PyArg_Parse(arg, "U:calc_width", &param1)) {
      wchar_t param1_chars[2];
      if (PyUnicode_AsWideChar(param1, param1_chars, 2) == 1) {
        PN_stdfloat return_value = ((*(const TextNode*)local_this).calc_width)(param1_chars[0]);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: PN_stdfloat TextNode::calc_width(std::wstring const &line) const
  // No coercion possible: inline PN_stdfloat TextNode::calc_width(std::string const &line) const
  // No coercion possible: PN_stdfloat TextNode::calc_width(wchar_t character) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_width(TextNode self, unicode line)\n"
      "calc_width(TextNode self, str line)\n"
      "calc_width(TextNode self, unicode char character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_calc_width_447_comment =
  "C++ Interface:\n"
  "calc_width(TextNode self, unicode line)\n"
  "calc_width(TextNode self, str line)\n"
  "calc_width(TextNode self, unicode char character)\n"
  "\n"
  "// These methods calculate the width of a single character or a line of text\n"
  "// in the current font.\n"
  "\n"
  "/**\n"
  " * Returns the width of a line of text of arbitrary characters.  The line\n"
  " * should not include the newline character.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the width of a single character of the font, or 0.0 if the\n"
  " * character is not known.  This may be a wide character (greater than 255).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the width of a line of text of arbitrary characters.  The line\n"
  " * should not include the newline character or any embedded control characters\n"
  " * like \\1 or \\3.\n"
  " */";
#else
static const char *Dtool_TextNode_calc_width_447_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextNode::has_exact_character(wchar_t character) const
 */
static PyObject *Dtool_TextNode_has_exact_character_448(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-bool TextNode::has_exact_character(wchar_t character) const
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  if (PyArg_Parse(arg, "U:has_exact_character", &param1)) {
    wchar_t param1_chars[2];
    if (PyUnicode_AsWideChar(param1, param1_chars, 2) == 1) {
      bool return_value = ((*(const TextNode*)local_this).has_exact_character)(param1_chars[0]);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_exact_character(TextNode self, unicode char character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_exact_character_448_comment =
  "C++ Interface:\n"
  "has_exact_character(TextNode self, unicode char character)\n"
  "\n"
  "/**\n"
  " * Returns true if the named character exists in the font exactly as named,\n"
  " * false otherwise.  Note that because Panda can assemble glyphs together\n"
  " * automatically using cheesy accent marks, this is not a reliable indicator\n"
  " * of whether a suitable glyph can be rendered for the character.  For that,\n"
  " * use has_character() instead.\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), but returns false for characters that would render with\n"
  " * the \"invalid glyph\".  It also returns false for characters that would be\n"
  " * synthesized within Panda, but see has_character().\n"
  " */";
#else
static const char *Dtool_TextNode_has_exact_character_448_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextNode::has_character(wchar_t character) const
 */
static PyObject *Dtool_TextNode_has_character_449(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-bool TextNode::has_character(wchar_t character) const
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  if (PyArg_Parse(arg, "U:has_character", &param1)) {
    wchar_t param1_chars[2];
    if (PyUnicode_AsWideChar(param1, param1_chars, 2) == 1) {
      bool return_value = ((*(const TextNode*)local_this).has_character)(param1_chars[0]);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_character(TextNode self, unicode char character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_character_449_comment =
  "C++ Interface:\n"
  "has_character(TextNode self, unicode char character)\n"
  "\n"
  "/**\n"
  " * Returns true if the named character exists in the font or can be\n"
  " * synthesized by Panda, false otherwise.  (Panda can synthesize some accented\n"
  " * characters by combining similar-looking glyphs from the font.)\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), but returns false for characters that would render with\n"
  " * the \"invalid glyph\".\n"
  " */";
#else
static const char *Dtool_TextNode_has_character_449_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TextNode::is_whitespace(wchar_t character) const
 */
static PyObject *Dtool_TextNode_is_whitespace_450(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-bool TextNode::is_whitespace(wchar_t character) const
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  if (PyArg_Parse(arg, "U:is_whitespace", &param1)) {
    wchar_t param1_chars[2];
    if (PyUnicode_AsWideChar(param1, param1_chars, 2) == 1) {
      bool return_value = ((*(const TextNode*)local_this).is_whitespace)(param1_chars[0]);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_whitespace(TextNode self, unicode char character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_is_whitespace_450_comment =
  "C++ Interface:\n"
  "is_whitespace(TextNode self, unicode char character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character represents whitespace in the font,\n"
  " * or false if anything visible will be rendered for it.\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), and returns false for any other characters, including\n"
  " * characters that do not exist in the font (these would be rendered with the\n"
  " * \"invalid glyph\", which is visible).\n"
  " *\n"
  " * Note that this function can be reliably used to identify Unicode whitespace\n"
  " * characters only if the font has all of the whitespace characters defined.\n"
  " * It will return false for any character not in the font, even if it is an\n"
  " * official Unicode whitespace character.\n"
  " */";
#else
static const char *Dtool_TextNode_is_whitespace_450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring TextNode::get_wordwrapped_wtext(void) const
 */
static PyObject *Dtool_TextNode_get_wordwrapped_wtext_451(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline std::wstring TextNode::get_wordwrapped_wtext(void) const
  std::wstring return_value = ((*(const TextNode*)local_this).get_wordwrapped_wtext)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_wordwrapped_wtext_451_comment =
  "C++ Interface:\n"
  "get_wordwrapped_wtext(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns a wstring that represents the contents of the text, as it has been\n"
  " * formatted by wordwrap rules.\n"
  " *\n"
  " * In earlier versions, this did not contain any embedded special characters\n"
  " * like \\1 or \\3; now it does.\n"
  " */";
#else
static const char *Dtool_TextNode_get_wordwrapped_wtext_451_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void TextNode::output(std::ostream &out) const
 */
static PyObject *Dtool_TextNode_output_452(PyObject *self, PyObject *arg) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-virtual void TextNode::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "TextNode.output", false, true);
  if (arg_this != nullptr) {
    ((*(const TextNode*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(TextNode self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_output_452_comment =
  "C++ Interface:\n"
  "output(TextNode self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_output_452_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void TextNode::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_TextNode_write_453(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-virtual void TextNode::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "TextNode.write", false, true);
    if (param1_this != nullptr) {
      ((*(const TextNode*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TextNode self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_write_453_comment =
  "C++ Interface:\n"
  "write(TextNode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_write_453_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_left(void) const
 */
static PyObject *Dtool_TextNode_get_left_454(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextNode::get_left(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_left)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_left_454_comment =
  "C++ Interface:\n"
  "get_left(TextNode self)\n"
  "\n"
  "// The following functions return information about the text that was last\n"
  "// built (and is currently visible).\n"
  "\n"
  "/**\n"
  " * Returns the leftmost extent of the text in local 2-d coordinates,\n"
  " * unmodified by the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_left_454_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_right(void) const
 */
static PyObject *Dtool_TextNode_get_right_455(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextNode::get_right(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_right)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_right_455_comment =
  "C++ Interface:\n"
  "get_right(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the rightmost extent of the text in local 2-d coordinates,\n"
  " * unmodified by the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_right_455_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_bottom(void) const
 */
static PyObject *Dtool_TextNode_get_bottom_456(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextNode::get_bottom(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_bottom)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_bottom_456_comment =
  "C++ Interface:\n"
  "get_bottom(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the bottommost extent of the text in local 2-d coordinates,\n"
  " * unmodified by the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_bottom_456_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_top(void) const
 */
static PyObject *Dtool_TextNode_get_top_457(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextNode::get_top(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_top)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_top_457_comment =
  "C++ Interface:\n"
  "get_top(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the topmost extent of the text in local 2-d coordinates, unmodified\n"
  " * by the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_top_457_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_height(void) const
 */
static PyObject *Dtool_TextNode_get_height_458(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextNode::get_height(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_height_458_comment =
  "C++ Interface:\n"
  "get_height(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the net height of the text in local 2-d coordinates.\n"
  " */";
#else
static const char *Dtool_TextNode_get_height_458_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_width(void) const
 */
static PyObject *Dtool_TextNode_get_width_459(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat TextNode::get_width(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_width_459_comment =
  "C++ Interface:\n"
  "get_width(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the net width of the text in local 2-d coordinates.\n"
  " */";
#else
static const char *Dtool_TextNode_get_width_459_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 TextNode::get_upper_left_3d(void) const
 */
static PyObject *Dtool_TextNode_get_upper_left_3d_460(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline LPoint3 TextNode::get_upper_left_3d(void) const
  LPoint3 *return_value = new LPoint3(((*(const TextNode*)local_this).get_upper_left_3d)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_upper_left_3d_460_comment =
  "C++ Interface:\n"
  "get_upper_left_3d(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the upper-left extent of the text object, after it has been\n"
  " * transformed into 3-d space by applying the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_upper_left_3d_460_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 TextNode::get_lower_right_3d(void) const
 */
static PyObject *Dtool_TextNode_get_lower_right_3d_461(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline LPoint3 TextNode::get_lower_right_3d(void) const
  LPoint3 *return_value = new LPoint3(((*(const TextNode*)local_this).get_lower_right_3d)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_lower_right_3d_461_comment =
  "C++ Interface:\n"
  "get_lower_right_3d(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the lower-right extent of the text object, after it has been\n"
  " * transformed into 3-d space by applying the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_lower_right_3d_461_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextNode::get_num_rows(void) const
 */
static PyObject *Dtool_TextNode_get_num_rows_462(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-inline int TextNode::get_num_rows(void) const
  int return_value = ((*(const TextNode*)local_this).get_num_rows)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_num_rows_462_comment =
  "C++ Interface:\n"
  "get_num_rows(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of rows of text that were generated.  This counts word-\n"
  " * wrapped rows as well as rows generated due to embedded newlines.\n"
  " */";
#else
static const char *Dtool_TextNode_get_num_rows_462_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< PandaNode > TextNode::generate(void)
 */
static PyObject *Dtool_TextNode_generate_463(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.generate")) {
    return nullptr;
  }
  // 1-inline PointerTo< PandaNode > TextNode::generate(void)
  PointerTo< PandaNode > return_value = ((*local_this).generate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  PandaNode *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextNode_generate_463_comment =
  "C++ Interface:\n"
  "generate(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Generates the text, according to the parameters indicated within the\n"
  " * TextNode, and returns a Node that may be parented within the tree to\n"
  " * represent it.\n"
  " */";
#else
static const char *Dtool_TextNode_generate_463_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::update(void)
 */
static PyObject *Dtool_TextNode_update_464(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.update")) {
    return nullptr;
  }
  // 1-inline void TextNode::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_update_464_comment =
  "C++ Interface:\n"
  "update(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Can be called after the TextNode has been fully configured, to force the\n"
  " * node to recompute its text immediately, rather than waiting for it to be\n"
  " * drawn.  This call is optional.\n"
  " */";
#else
static const char *Dtool_TextNode_update_464_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::force_update(void)
 */
static PyObject *Dtool_TextNode_force_update_465(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.force_update")) {
    return nullptr;
  }
  // 1-inline void TextNode::force_update(void)
  ((*local_this).force_update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_force_update_465_comment =
  "C++ Interface:\n"
  "force_update(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Forces the TextNode to recompute itself now, even if it believes nothing\n"
  " * has changed.  Normally, this should not need to be called, but it may be\n"
  " * useful if some properties change outside of the TextNode's knowledge (for\n"
  " * instance, within the font).\n"
  " */";
#else
static const char *Dtool_TextNode_force_update_465_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > TextNode::get_internal_geom(void) const
 */
static PyObject *Dtool_TextNode_get_internal_geom_466(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextNode)) {
    return nullptr;
  }
  // 1-PointerTo< PandaNode > TextNode::get_internal_geom(void) const
  PointerTo< PandaNode > return_value = ((*(const TextNode*)local_this).get_internal_geom)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  PandaNode *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_internal_geom_466_comment =
  "C++ Interface:\n"
  "get_internal_geom(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the actual node that is used internally to render the text, if the\n"
  " * TextNode is parented within the scene graph.\n"
  " *\n"
  " * In general, you should not call this method.  Call generate() instead if\n"
  " * you want to get a handle to geometry that represents the text.  This method\n"
  " * is provided as a debugging aid only.\n"
  " */";
#else
static const char *Dtool_TextNode_get_internal_geom_466_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextNode::get_class_type(void)
 */
static PyObject *Dtool_TextNode_get_class_type_546(PyObject *, PyObject *) {
  // 1-static TypeHandle TextNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TextNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_class_type_546_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextNode_get_class_type_546_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PandaNode *TextNode::upcast_to_PandaNode(void)
 */
static PyObject *Dtool_TextNode_upcast_to_PandaNode_358(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.upcast_to_PandaNode")) {
    return nullptr;
  }
  // 1-PandaNode *TextNode::upcast_to_PandaNode(void)
  PandaNode *return_value = (PandaNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextNode_upcast_to_PandaNode_358_comment =
  "C++ Interface:\n"
  "upcast_to_PandaNode(const TextNode self)\n"
  "\n"
  "upcast from TextNode to PandaNode";
#else
static const char *Dtool_TextNode_upcast_to_PandaNode_358_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextEncoder *TextNode::upcast_to_TextEncoder(void)
 */
static PyObject *Dtool_TextNode_upcast_to_TextEncoder_361(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.upcast_to_TextEncoder")) {
    return nullptr;
  }
  // 1-TextEncoder *TextNode::upcast_to_TextEncoder(void)
  TextEncoder *return_value = (TextEncoder *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextEncoder, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_upcast_to_TextEncoder_361_comment =
  "C++ Interface:\n"
  "upcast_to_TextEncoder(const TextNode self)\n"
  "\n"
  "upcast from TextNode to TextEncoder";
#else
static const char *Dtool_TextNode_upcast_to_TextEncoder_361_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TextProperties *TextNode::upcast_to_TextProperties(void)
 */
static PyObject *Dtool_TextNode_upcast_to_TextProperties_363(PyObject *self, PyObject *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.upcast_to_TextProperties")) {
    return nullptr;
  }
  // 1-TextProperties *TextNode::upcast_to_TextProperties(void)
  TextProperties *return_value = (TextProperties *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_upcast_to_TextProperties_363_comment =
  "C++ Interface:\n"
  "upcast_to_TextProperties(const TextNode self)\n"
  "\n"
  "upcast from TextNode to TextProperties";
#else
static const char *Dtool_TextNode_upcast_to_TextProperties_363_comment = nullptr;
#endif

static PyObject *Dtool_TextNode_max_rows_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TextNode::get_max_rows(void) const
  int return_value = ((*(const TextNode*)local_this).get_max_rows)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_max_rows_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.max_rows")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_rows attribute");
    return -1;
  }
  // 1-inline void TextNode::set_max_rows(int max_rows)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_max_rows)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_rows(const TextNode self, int max_rows)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_frame_color_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor TextNode::get_frame_color(void) const
  LColor *return_value = new LColor(((*(const TextNode*)local_this).get_frame_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextNode_frame_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.frame_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete frame_color attribute");
    return -1;
  }
  // 1-inline void TextNode::set_frame_color(LColor const &frame_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_frame_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_frame_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_color(const TextNode self, const LVecBase4f frame_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_card_color_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor TextNode::get_card_color(void) const
  LColor *return_value = new LColor(((*(const TextNode*)local_this).get_card_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextNode_card_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.card_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete card_color attribute");
    return -1;
  }
  // 1-inline void TextNode::set_card_color(LColor const &card_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_card_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_card_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_card_color(const TextNode self, const LVecBase4f card_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_card_texture_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture *TextNode::get_card_texture(void) const
  Texture *return_value = ((*(const TextNode*)local_this).get_card_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_TextNode_card_texture_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.card_texture")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete card_texture attribute");
    return -1;
  }
  // 1-inline void TextNode::set_card_texture(Texture *card_texture)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "TextNode.set_card_texture", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_card_texture)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_card_texture(const TextNode self, Texture card_texture)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_frame_line_width_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat TextNode::get_frame_line_width(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_frame_line_width)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_frame_line_width_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.frame_line_width")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete frame_line_width attribute");
    return -1;
  }
  // 1-inline void TextNode::set_frame_line_width(PN_stdfloat line_width)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_frame_line_width)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_line_width(const TextNode self, float line_width)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_frame_corners_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool TextNode::get_frame_corners(void) const
  bool return_value = ((*(const TextNode*)local_this).get_frame_corners)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_frame_corners_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.frame_corners")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete frame_corners attribute");
    return -1;
  }
  // 1-inline void TextNode::set_frame_corners(bool corners)
  ((*local_this).set_frame_corners)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_corners(const TextNode self, bool corners)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_transform_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LMatrix4 TextNode::get_transform(void) const
  LMatrix4 *return_value = new LMatrix4(((*(const TextNode*)local_this).get_transform)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

static int Dtool_TextNode_transform_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.transform")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete transform attribute");
    return -1;
  }
  // 1-inline void TextNode::set_transform(LMatrix4 const &transform)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_transform", "LMatrix4f");
    return -1;
  }
  ((*local_this).set_transform)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_transform(const TextNode self, const LMatrix4f transform)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_coordinate_system_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CoordinateSystem TextNode::get_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const TextNode*)local_this).get_coordinate_system)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_coordinate_system_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.coordinate_system")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete coordinate_system attribute");
    return -1;
  }
  // 1-inline void TextNode::set_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_coordinate_system)((CoordinateSystem)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const TextNode self, int cs)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_usage_hint_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GeomEnums::UsageHint TextNode::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = ((*(const TextNode*)local_this).get_usage_hint)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_usage_hint_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.usage_hint")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete usage_hint attribute");
    return -1;
  }
  // 1-inline void TextNode::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_usage_hint)((GeomEnums::UsageHint)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const TextNode self, int usage_hint)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_flatten_flags_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TextNode::get_flatten_flags(void) const
  int return_value = ((*(const TextNode*)local_this).get_flatten_flags)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_flatten_flags_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.flatten_flags")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete flatten_flags attribute");
    return -1;
  }
  // 1-inline void TextNode::set_flatten_flags(int flatten_flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_flatten_flags)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_flatten_flags(const TextNode self, int flatten_flags)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_font_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_font()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TextFont *TextNode::get_font(void) const
  TextFont *return_value = ((*(const TextNode*)local_this).get_font)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_TextNode_font_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.font")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete font attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_font();
    return 0;
  }
  // 1-inline void TextNode::set_font(TextFont *font)
  TextFont *arg_this = (TextFont *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextFont, 1, "TextNode.set_font", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_font)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_font(const TextNode self, TextFont font)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_small_caps_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_small_caps()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextNode::get_small_caps(void) const
  bool return_value = ((*(const TextNode*)local_this).get_small_caps)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_small_caps_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.small_caps")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete small_caps attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_small_caps();
    return 0;
  }
  // 1-inline void TextNode::set_small_caps(bool small_caps)
  ((*local_this).set_small_caps)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_small_caps(const TextNode self, bool small_caps)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_small_caps_scale_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_small_caps_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_small_caps_scale(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_small_caps_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_small_caps_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.small_caps_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete small_caps_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_small_caps_scale();
    return 0;
  }
  // 1-inline void TextNode::set_small_caps_scale(PN_stdfloat small_caps_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_small_caps_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_small_caps_scale(const TextNode self, float small_caps_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_slant_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_slant()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_slant(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_slant)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_slant_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.slant")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete slant attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_slant();
    return 0;
  }
  // 1-inline void TextNode::set_slant(PN_stdfloat slant)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_slant)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_slant(const TextNode self, float slant)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_underscore_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_underscore()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextNode::get_underscore(void) const
  bool return_value = ((*(const TextNode*)local_this).get_underscore)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_underscore_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.underscore")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete underscore attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_underscore();
    return 0;
  }
  // 1-inline void TextNode::set_underscore(bool underscore)
  ((*local_this).set_underscore)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_underscore(const TextNode self, bool underscore)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_underscore_height_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_underscore_height()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_underscore_height(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_underscore_height)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_underscore_height_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.underscore_height")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete underscore_height attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_underscore_height();
    return 0;
  }
  // 1-inline void TextNode::set_underscore_height(PN_stdfloat underscore_height)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_underscore_height)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_underscore_height(const TextNode self, float underscore_height)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_align_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_align()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TextProperties::Alignment TextNode::get_align(void) const
  TextProperties::Alignment return_value = ((*(const TextNode*)local_this).get_align)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_align_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.align")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete align attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_align();
    return 0;
  }
  // 1-inline void TextNode::set_align(TextProperties::Alignment align_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_align)((TextProperties::Alignment)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_align(const TextNode self, int align_type)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_indent_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_indent()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_indent(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_indent)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_indent_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.indent")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete indent attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_indent();
    return 0;
  }
  // 1-inline void TextNode::set_indent(PN_stdfloat indent)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_indent)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_indent(const TextNode self, float indent)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_wordwrap_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_wordwrap()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_wordwrap(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_wordwrap)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_wordwrap_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.wordwrap")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wordwrap attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_wordwrap();
    return 0;
  }
  // 1-inline void TextNode::set_wordwrap(PN_stdfloat wordwrap)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_wordwrap)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wordwrap(const TextNode self, float wordwrap)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_preserve_trailing_whitespace_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_preserve_trailing_whitespace()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextNode::get_preserve_trailing_whitespace(void) const
  bool return_value = ((*(const TextNode*)local_this).get_preserve_trailing_whitespace)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_preserve_trailing_whitespace_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.preserve_trailing_whitespace")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete preserve_trailing_whitespace attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_preserve_trailing_whitespace();
    return 0;
  }
  // 1-inline void TextNode::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace)
  ((*local_this).set_preserve_trailing_whitespace)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_preserve_trailing_whitespace(const TextNode self, bool preserve_trailing_whitespace)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_text_color_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_text_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor TextNode::get_text_color(void) const
  LColor *return_value = new LColor(((*(const TextNode*)local_this).get_text_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextNode_text_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.text_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete text_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_text_color();
    return 0;
  }
  // 1-inline void TextNode::set_text_color(LColor const &text_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_text_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_text_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_text_color(const TextNode self, const LVecBase4f text_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_shadow_color_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_shadow_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor TextNode::get_shadow_color(void) const
  LColor *return_value = new LColor(((*(const TextNode*)local_this).get_shadow_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextNode_shadow_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.shadow_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete shadow_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_shadow_color();
    return 0;
  }
  // 1-inline void TextNode::set_shadow_color(LColor const &shadow_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_shadow_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_shadow_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow_color(const TextNode self, const LVecBase4f shadow_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_shadow_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_shadow()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LVector2 TextNode::get_shadow(void) const
  LVector2 *return_value = new LVector2(((*(const TextNode*)local_this).get_shadow)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

static int Dtool_TextNode_shadow_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.shadow")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete shadow attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_shadow();
    return 0;
  }
  // 1-inline void TextNode::set_shadow(LVecBase2 const &shadow_offset)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_shadow", "LVecBase2f");
    return -1;
  }
  ((*local_this).set_shadow)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow(const TextNode self, const LVecBase2f shadow_offset)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_bin_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_bin()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline std::string const &TextNode::get_bin(void) const
  std::string const &return_value = ((*(const TextNode*)local_this).get_bin)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_bin_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.bin")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bin attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_bin();
    return 0;
  }
  // 1-inline void TextNode::set_bin(std::string const &bin)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_bin)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bin(const TextNode self, str bin)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_draw_order_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_draw_order()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int TextNode::get_draw_order(void) const
  int return_value = ((*(const TextNode*)local_this).get_draw_order)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_draw_order_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.draw_order")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete draw_order attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_draw_order();
    return 0;
  }
  // 1-inline int TextNode::set_draw_order(int draw_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    int return_value = ((*local_this).set_draw_order)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return return_value;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_draw_order(const TextNode self, int draw_order)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_tab_width_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_tab_width()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_tab_width(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_tab_width)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_tab_width_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.tab_width")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete tab_width attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_tab_width();
    return 0;
  }
  // 1-inline void TextNode::set_tab_width(PN_stdfloat tab_width)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_tab_width)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tab_width(const TextNode self, float tab_width)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_glyph_scale_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_glyph_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_glyph_scale(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_glyph_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_glyph_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.glyph_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete glyph_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_glyph_scale();
    return 0;
  }
  // 1-inline void TextNode::set_glyph_scale(PN_stdfloat glyph_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_glyph_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_glyph_scale(const TextNode self, float glyph_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_glyph_shift_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_glyph_shift()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_glyph_shift(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_glyph_shift)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_glyph_shift_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.glyph_shift")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete glyph_shift attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_glyph_shift();
    return 0;
  }
  // 1-inline void TextNode::set_glyph_shift(PN_stdfloat glyph_shift)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_glyph_shift)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_glyph_shift(const TextNode self, float glyph_shift)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_text_scale_Getter(PyObject *self, void *) {
  const TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_text_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_text_scale(void) const
  PN_stdfloat return_value = ((*(const TextNode*)local_this).get_text_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_text_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.text_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete text_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_text_scale();
    return 0;
  }
  // 1-inline void TextNode::set_text_scale(PN_stdfloat text_scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_text_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_text_scale(const TextNode self, float text_scale)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit TextNode::TextNode(std::string const &name)
 * explicit TextNode::TextNode(std::string const &name, TextProperties const &copy)
 */
static int Dtool_Init_TextNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
        // 1-explicit TextNode::TextNode(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          TextNode *return_value = new TextNode(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextNode, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-explicit TextNode::TextNode(std::string const &name, TextProperties const &copy)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"name", "copy", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:TextNode", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        TextProperties const *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextProperties, 1, "TextNode.TextNode", true, true);
        if (param1_this != nullptr) {
          TextNode *return_value = new TextNode(std::string(param0_str, param0_len), *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextNode() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextNode(str name)\n"
      "TextNode(str name, const TextProperties copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextNode) {
    printf("TextNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextNode *local_this = (TextNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextEncoder) {
    return (TextEncoder *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextProperties) {
    return (TextProperties *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TextEncoder) {
    TextEncoder* other_this = (TextEncoder*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TextProperties) {
    TextProperties* other_this = (TextProperties*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TextNode*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for TextGlyph (TextGlyph)
 */
static PyMethodDef Dtool_Methods_TextGlyph[] = {
  {"get_character", &Dtool_TextGlyph_get_character_3, METH_NOARGS, (const char *)Dtool_TextGlyph_get_character_3_comment},
  {"getCharacter", &Dtool_TextGlyph_get_character_3, METH_NOARGS, (const char *)Dtool_TextGlyph_get_character_3_comment},
  {"has_quad", &Dtool_TextGlyph_has_quad_4, METH_NOARGS, (const char *)Dtool_TextGlyph_has_quad_4_comment},
  {"hasQuad", &Dtool_TextGlyph_has_quad_4, METH_NOARGS, (const char *)Dtool_TextGlyph_has_quad_4_comment},
  {"get_quad", (PyCFunction) &Dtool_TextGlyph_get_quad_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextGlyph_get_quad_5_comment},
  {"getQuad", (PyCFunction) &Dtool_TextGlyph_get_quad_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextGlyph_get_quad_5_comment},
  {"get_state", &Dtool_TextGlyph_get_state_6, METH_NOARGS, (const char *)Dtool_TextGlyph_get_state_6_comment},
  {"getState", &Dtool_TextGlyph_get_state_6, METH_NOARGS, (const char *)Dtool_TextGlyph_get_state_6_comment},
  {"get_advance", &Dtool_TextGlyph_get_advance_7, METH_NOARGS, (const char *)Dtool_TextGlyph_get_advance_7_comment},
  {"getAdvance", &Dtool_TextGlyph_get_advance_7, METH_NOARGS, (const char *)Dtool_TextGlyph_get_advance_7_comment},
  {"is_whitespace", &Dtool_TextGlyph_is_whitespace_17, METH_NOARGS, (const char *)Dtool_TextGlyph_is_whitespace_17_comment},
  {"isWhitespace", &Dtool_TextGlyph_is_whitespace_17, METH_NOARGS, (const char *)Dtool_TextGlyph_is_whitespace_17_comment},
  {"get_geom", &Dtool_TextGlyph_get_geom_18, METH_O, (const char *)Dtool_TextGlyph_get_geom_18_comment},
  {"getGeom", &Dtool_TextGlyph_get_geom_18, METH_O, (const char *)Dtool_TextGlyph_get_geom_18_comment},
  {"get_class_type", &Dtool_TextGlyph_get_class_type_19, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextGlyph_get_class_type_19_comment},
  {"getClassType", &Dtool_TextGlyph_get_class_type_19, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextGlyph_get_class_type_19_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_TextGlyph[] = {
  {(char *)"character", &Dtool_TextGlyph_character_Getter, nullptr, nullptr, nullptr},
  {(char *)"state", &Dtool_TextGlyph_state_Getter, nullptr, nullptr, nullptr},
  {(char *)"advance", &Dtool_TextGlyph_advance_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TextGlyph = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextGlyph = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TextGlyph = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TextGlyph = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TextGlyph = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TextGlyph = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextGlyph",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextGlyph,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TextGlyph,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextGlyph,
    &Dtool_SequenceMethods_TextGlyph,
    &Dtool_MappingMethods_TextGlyph,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TextGlyph,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A representation of a single glyph (character) from a font.  This is a\n"
    " * piece of renderable geometry of some kind.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextGlyph,
    nullptr, // tp_members
    Dtool_Properties_TextGlyph,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextGlyph,
    PyType_GenericAlloc,
    Dtool_new_TextGlyph,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextGlyph,
  Dtool_UpcastInterface_TextGlyph,
  Dtool_DowncastInterface_TextGlyph,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextGlyph(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_TextGlyph._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_TextGlyph._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextGlyph._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextGlyph) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextGlyph)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextGlyph);
  }
}

/**
 * Python method tables for TextFont (TextFont)
 */
static PyMethodDef Dtool_Methods_TextFont[] = {
  {"make_copy", &Dtool_TextFont_make_copy_28, METH_NOARGS, (const char *)Dtool_TextFont_make_copy_28_comment},
  {"makeCopy", &Dtool_TextFont_make_copy_28, METH_NOARGS, (const char *)Dtool_TextFont_make_copy_28_comment},
  {"is_valid", &Dtool_TextFont_is_valid_29, METH_NOARGS, (const char *)Dtool_TextFont_is_valid_29_comment},
  {"isValid", &Dtool_TextFont_is_valid_29, METH_NOARGS, (const char *)Dtool_TextFont_is_valid_29_comment},
  {"get_line_height", &Dtool_TextFont_get_line_height_31, METH_NOARGS, (const char *)Dtool_TextFont_get_line_height_31_comment},
  {"getLineHeight", &Dtool_TextFont_get_line_height_31, METH_NOARGS, (const char *)Dtool_TextFont_get_line_height_31_comment},
  {"set_line_height", &Dtool_TextFont_set_line_height_32, METH_O, (const char *)Dtool_TextFont_set_line_height_32_comment},
  {"setLineHeight", &Dtool_TextFont_set_line_height_32, METH_O, (const char *)Dtool_TextFont_set_line_height_32_comment},
  {"get_space_advance", &Dtool_TextFont_get_space_advance_36, METH_NOARGS, (const char *)Dtool_TextFont_get_space_advance_36_comment},
  {"getSpaceAdvance", &Dtool_TextFont_get_space_advance_36, METH_NOARGS, (const char *)Dtool_TextFont_get_space_advance_36_comment},
  {"set_space_advance", &Dtool_TextFont_set_space_advance_37, METH_O, (const char *)Dtool_TextFont_set_space_advance_37_comment},
  {"setSpaceAdvance", &Dtool_TextFont_set_space_advance_37, METH_O, (const char *)Dtool_TextFont_set_space_advance_37_comment},
  {"get_glyph", &Dtool_TextFont_get_glyph_39, METH_O, (const char *)Dtool_TextFont_get_glyph_39_comment},
  {"getGlyph", &Dtool_TextFont_get_glyph_39, METH_O, (const char *)Dtool_TextFont_get_glyph_39_comment},
  {"get_kerning", (PyCFunction) &Dtool_TextFont_get_kerning_40, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextFont_get_kerning_40_comment},
  {"getKerning", (PyCFunction) &Dtool_TextFont_get_kerning_40, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextFont_get_kerning_40_comment},
  {"write", (PyCFunction) &Dtool_TextFont_write_41, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextFont_write_41_comment},
  {"get_class_type", &Dtool_TextFont_get_class_type_42, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextFont_get_class_type_42_comment},
  {"getClassType", &Dtool_TextFont_get_class_type_42, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextFont_get_class_type_42_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_TextFont_upcast_to_TypedReferenceCount_21, METH_NOARGS, (const char *)Dtool_TextFont_upcast_to_TypedReferenceCount_21_comment},
  {"upcastToTypedReferenceCount", &Dtool_TextFont_upcast_to_TypedReferenceCount_21, METH_NOARGS, (const char *)Dtool_TextFont_upcast_to_TypedReferenceCount_21_comment},
  {"upcast_to_Namable", &Dtool_TextFont_upcast_to_Namable_24, METH_NOARGS, (const char *)Dtool_TextFont_upcast_to_Namable_24_comment},
  {"upcastToNamable", &Dtool_TextFont_upcast_to_Namable_24, METH_NOARGS, (const char *)Dtool_TextFont_upcast_to_Namable_24_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TextFont slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_TextFont_operator_typecast_bool_30_nb_bool(PyObject *self) {
  TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
//  A __str__ function
//     TextFont
//////////////////
static PyObject *Dtool_Str_TextFont(PyObject *self) {
  TextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_TextFont[] = {
  {(char *)"valid", &Dtool_TextFont_valid_Getter, nullptr, nullptr, nullptr},
  {(char *)"line_height", &Dtool_TextFont_line_height_Getter, &Dtool_TextFont_line_height_Setter, nullptr, nullptr},
  {(char *)"space_advance", &Dtool_TextFont_space_advance_Getter, &Dtool_TextFont_space_advance_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TextFont = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_TextFont_operator_typecast_bool_30_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextFont = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TextFont = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TextFont = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TextFont = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TextFont = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextFont",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextFont,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TextFont,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextFont,
    &Dtool_SequenceMethods_TextFont,
    &Dtool_MappingMethods_TextFont,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_TextFont,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TextFont,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An encapsulation of a font; i.e.  a set of glyphs that may be assembled\n"
    " * together by a TextNode to represent a string of text.\n"
    " *\n"
    " * This is just an abstract interface; see StaticTextFont or DynamicTextFont\n"
    " * for an actual implementation.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextFont,
    nullptr, // tp_members
    Dtool_Properties_TextFont,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextFont,
    PyType_GenericAlloc,
    Dtool_new_TextFont,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextFont,
  Dtool_UpcastInterface_TextFont,
  Dtool_DowncastInterface_TextFont,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextFont(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_TextFont._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_TextFont._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(15);
    Dtool_TextFont._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TextFont::RenderMode;
    PyDict_SetItemString(dict, "RM_texture", Dtool_WrapValue(TextFont::RM_texture));
    PyDict_SetItemString(dict, "RMTexture", Dtool_WrapValue(TextFont::RM_texture));
    PyDict_SetItemString(dict, "RM_wireframe", Dtool_WrapValue(TextFont::RM_wireframe));
    PyDict_SetItemString(dict, "RMWireframe", Dtool_WrapValue(TextFont::RM_wireframe));
    PyDict_SetItemString(dict, "RM_polygon", Dtool_WrapValue(TextFont::RM_polygon));
    PyDict_SetItemString(dict, "RMPolygon", Dtool_WrapValue(TextFont::RM_polygon));
    PyDict_SetItemString(dict, "RM_extruded", Dtool_WrapValue(TextFont::RM_extruded));
    PyDict_SetItemString(dict, "RMExtruded", Dtool_WrapValue(TextFont::RM_extruded));
    PyDict_SetItemString(dict, "RM_solid", Dtool_WrapValue(TextFont::RM_solid));
    PyDict_SetItemString(dict, "RMSolid", Dtool_WrapValue(TextFont::RM_solid));
    PyDict_SetItemString(dict, "RM_distance_field", Dtool_WrapValue(TextFont::RM_distance_field));
    PyDict_SetItemString(dict, "RMDistanceField", Dtool_WrapValue(TextFont::RM_distance_field));
    PyDict_SetItemString(dict, "RM_invalid", Dtool_WrapValue(TextFont::RM_invalid));
    PyDict_SetItemString(dict, "RMInvalid", Dtool_WrapValue(TextFont::RM_invalid));
    if (PyType_Ready((PyTypeObject *)&Dtool_TextFont) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextFont)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextFont);
  }
}

/**
 * Python method tables for DynamicTextGlyph (DynamicTextGlyph)
 */
static PyMethodDef Dtool_Methods_DynamicTextGlyph[] = {
  {"get_page", &Dtool_DynamicTextGlyph_get_page_44, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_page_44_comment},
  {"getPage", &Dtool_DynamicTextGlyph_get_page_44, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_page_44_comment},
  {"intersects", (PyCFunction) &Dtool_DynamicTextGlyph_intersects_56, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextGlyph_intersects_56_comment},
  {"get_left", &Dtool_DynamicTextGlyph_get_left_57, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_left_57_comment},
  {"getLeft", &Dtool_DynamicTextGlyph_get_left_57, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_left_57_comment},
  {"get_bottom", &Dtool_DynamicTextGlyph_get_bottom_58, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_bottom_58_comment},
  {"getBottom", &Dtool_DynamicTextGlyph_get_bottom_58, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_bottom_58_comment},
  {"get_right", &Dtool_DynamicTextGlyph_get_right_59, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_right_59_comment},
  {"getRight", &Dtool_DynamicTextGlyph_get_right_59, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_right_59_comment},
  {"get_top", &Dtool_DynamicTextGlyph_get_top_60, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_top_60_comment},
  {"getTop", &Dtool_DynamicTextGlyph_get_top_60, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_top_60_comment},
  {"get_uv_left", &Dtool_DynamicTextGlyph_get_uv_left_61, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_left_61_comment},
  {"getUvLeft", &Dtool_DynamicTextGlyph_get_uv_left_61, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_left_61_comment},
  {"get_uv_bottom", &Dtool_DynamicTextGlyph_get_uv_bottom_62, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_bottom_62_comment},
  {"getUvBottom", &Dtool_DynamicTextGlyph_get_uv_bottom_62, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_bottom_62_comment},
  {"get_uv_right", &Dtool_DynamicTextGlyph_get_uv_right_63, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_right_63_comment},
  {"getUvRight", &Dtool_DynamicTextGlyph_get_uv_right_63, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_right_63_comment},
  {"get_uv_top", &Dtool_DynamicTextGlyph_get_uv_top_64, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_top_64_comment},
  {"getUvTop", &Dtool_DynamicTextGlyph_get_uv_top_64, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_top_64_comment},
  {"get_class_type", &Dtool_DynamicTextGlyph_get_class_type_65, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextGlyph_get_class_type_65_comment},
  {"getClassType", &Dtool_DynamicTextGlyph_get_class_type_65, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextGlyph_get_class_type_65_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_DynamicTextGlyph[] = {
  {(char *)"page", &Dtool_DynamicTextGlyph_page_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DynamicTextGlyph = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DynamicTextGlyph = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DynamicTextGlyph = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DynamicTextGlyph = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DynamicTextGlyph = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DynamicTextGlyph = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DynamicTextGlyph",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DynamicTextGlyph,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DynamicTextGlyph,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DynamicTextGlyph,
    &Dtool_SequenceMethods_DynamicTextGlyph,
    &Dtool_MappingMethods_DynamicTextGlyph,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DynamicTextGlyph,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialization on TextGlyph that is generated and stored by a\n"
    " * DynamicTextFont.  This keeps some additional information, such as where the\n"
    " * glyph appears on a texture map.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DynamicTextGlyph,
    nullptr, // tp_members
    Dtool_Properties_DynamicTextGlyph,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DynamicTextGlyph,
    PyType_GenericAlloc,
    Dtool_new_DynamicTextGlyph,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DynamicTextGlyph,
  Dtool_UpcastInterface_DynamicTextGlyph,
  Dtool_DowncastInterface_DynamicTextGlyph,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DynamicTextGlyph(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TextGlyph(nullptr);
    Dtool_DynamicTextGlyph._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TextGlyph);
    Dtool_DynamicTextGlyph._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DynamicTextGlyph._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DynamicTextGlyph) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DynamicTextGlyph)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DynamicTextGlyph);
  }
}

/**
 * Python method tables for DynamicTextPage (DynamicTextPage)
 */
static PyMethodDef Dtool_Methods_DynamicTextPage[] = {
  {"get_size", &Dtool_DynamicTextPage_get_size_49, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_size_49_comment},
  {"getSize", &Dtool_DynamicTextPage_get_size_49, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_size_49_comment},
  {"get_x_size", &Dtool_DynamicTextPage_get_x_size_50, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_x_size_50_comment},
  {"getXSize", &Dtool_DynamicTextPage_get_x_size_50, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_x_size_50_comment},
  {"get_y_size", &Dtool_DynamicTextPage_get_y_size_51, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_y_size_51_comment},
  {"getYSize", &Dtool_DynamicTextPage_get_y_size_51, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_y_size_51_comment},
  {"is_empty", &Dtool_DynamicTextPage_is_empty_52, METH_NOARGS, (const char *)Dtool_DynamicTextPage_is_empty_52_comment},
  {"isEmpty", &Dtool_DynamicTextPage_is_empty_52, METH_NOARGS, (const char *)Dtool_DynamicTextPage_is_empty_52_comment},
  {"get_class_type", &Dtool_DynamicTextPage_get_class_type_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextPage_get_class_type_53_comment},
  {"getClassType", &Dtool_DynamicTextPage_get_class_type_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextPage_get_class_type_53_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DynamicTextPage = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DynamicTextPage = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DynamicTextPage = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DynamicTextPage = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DynamicTextPage = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DynamicTextPage = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DynamicTextPage",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DynamicTextPage,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DynamicTextPage,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DynamicTextPage,
    &Dtool_SequenceMethods_DynamicTextPage,
    &Dtool_MappingMethods_DynamicTextPage,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DynamicTextPage,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single \"page\" of a DynamicTextFont.  This is a single texture that holds\n"
    " * a number of glyphs for rendering.  The font starts out with one page, and\n"
    " * will add more as it needs them.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DynamicTextPage,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DynamicTextPage,
    PyType_GenericAlloc,
    Dtool_new_DynamicTextPage,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DynamicTextPage,
  Dtool_UpcastInterface_DynamicTextPage,
  Dtool_DowncastInterface_DynamicTextPage,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DynamicTextPage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Texture != nullptr);
    assert(Dtool_Ptr_Texture->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Texture->_Dtool_ModuleClassInit(nullptr);
    Dtool_DynamicTextPage._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Texture);
    Dtool_DynamicTextPage._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DynamicTextPage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DynamicTextPage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DynamicTextPage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DynamicTextPage);
  }
}

/**
 * Python method tables for DynamicTextFont (DynamicTextFont)
 */
static PyMethodDef Dtool_Methods_DynamicTextFont[] = {
  {"make_copy", &Dtool_DynamicTextFont_make_copy_74, METH_NOARGS, (const char *)Dtool_DynamicTextFont_make_copy_74_comment},
  {"makeCopy", &Dtool_DynamicTextFont_make_copy_74, METH_NOARGS, (const char *)Dtool_DynamicTextFont_make_copy_74_comment},
  {"get_name", &Dtool_DynamicTextFont_get_name_75, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_name_75_comment},
  {"getName", &Dtool_DynamicTextFont_get_name_75, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_name_75_comment},
  {"set_point_size", &Dtool_DynamicTextFont_set_point_size_76, METH_O, (const char *)Dtool_DynamicTextFont_set_point_size_76_comment},
  {"setPointSize", &Dtool_DynamicTextFont_set_point_size_76, METH_O, (const char *)Dtool_DynamicTextFont_set_point_size_76_comment},
  {"get_point_size", &Dtool_DynamicTextFont_get_point_size_77, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_point_size_77_comment},
  {"getPointSize", &Dtool_DynamicTextFont_get_point_size_77, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_point_size_77_comment},
  {"set_pixels_per_unit", &Dtool_DynamicTextFont_set_pixels_per_unit_79, METH_O, (const char *)Dtool_DynamicTextFont_set_pixels_per_unit_79_comment},
  {"setPixelsPerUnit", &Dtool_DynamicTextFont_set_pixels_per_unit_79, METH_O, (const char *)Dtool_DynamicTextFont_set_pixels_per_unit_79_comment},
  {"get_pixels_per_unit", &Dtool_DynamicTextFont_get_pixels_per_unit_80, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_pixels_per_unit_80_comment},
  {"getPixelsPerUnit", &Dtool_DynamicTextFont_get_pixels_per_unit_80, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_pixels_per_unit_80_comment},
  {"set_scale_factor", &Dtool_DynamicTextFont_set_scale_factor_82, METH_O, (const char *)Dtool_DynamicTextFont_set_scale_factor_82_comment},
  {"setScaleFactor", &Dtool_DynamicTextFont_set_scale_factor_82, METH_O, (const char *)Dtool_DynamicTextFont_set_scale_factor_82_comment},
  {"get_scale_factor", &Dtool_DynamicTextFont_get_scale_factor_83, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_scale_factor_83_comment},
  {"getScaleFactor", &Dtool_DynamicTextFont_get_scale_factor_83, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_scale_factor_83_comment},
  {"set_native_antialias", &Dtool_DynamicTextFont_set_native_antialias_85, METH_O, (const char *)Dtool_DynamicTextFont_set_native_antialias_85_comment},
  {"setNativeAntialias", &Dtool_DynamicTextFont_set_native_antialias_85, METH_O, (const char *)Dtool_DynamicTextFont_set_native_antialias_85_comment},
  {"get_native_antialias", &Dtool_DynamicTextFont_get_native_antialias_86, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_native_antialias_86_comment},
  {"getNativeAntialias", &Dtool_DynamicTextFont_get_native_antialias_86, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_native_antialias_86_comment},
  {"get_font_pixel_size", &Dtool_DynamicTextFont_get_font_pixel_size_88, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_font_pixel_size_88_comment},
  {"getFontPixelSize", &Dtool_DynamicTextFont_get_font_pixel_size_88, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_font_pixel_size_88_comment},
  {"get_line_height", &Dtool_DynamicTextFont_get_line_height_90, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_line_height_90_comment},
  {"getLineHeight", &Dtool_DynamicTextFont_get_line_height_90, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_line_height_90_comment},
  {"get_space_advance", &Dtool_DynamicTextFont_get_space_advance_91, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_space_advance_91_comment},
  {"getSpaceAdvance", &Dtool_DynamicTextFont_get_space_advance_91, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_space_advance_91_comment},
  {"set_texture_margin", &Dtool_DynamicTextFont_set_texture_margin_92, METH_O, (const char *)Dtool_DynamicTextFont_set_texture_margin_92_comment},
  {"setTextureMargin", &Dtool_DynamicTextFont_set_texture_margin_92, METH_O, (const char *)Dtool_DynamicTextFont_set_texture_margin_92_comment},
  {"get_texture_margin", &Dtool_DynamicTextFont_get_texture_margin_93, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_texture_margin_93_comment},
  {"getTextureMargin", &Dtool_DynamicTextFont_get_texture_margin_93, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_texture_margin_93_comment},
  {"set_poly_margin", &Dtool_DynamicTextFont_set_poly_margin_94, METH_O, (const char *)Dtool_DynamicTextFont_set_poly_margin_94_comment},
  {"setPolyMargin", &Dtool_DynamicTextFont_set_poly_margin_94, METH_O, (const char *)Dtool_DynamicTextFont_set_poly_margin_94_comment},
  {"get_poly_margin", &Dtool_DynamicTextFont_get_poly_margin_95, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_poly_margin_95_comment},
  {"getPolyMargin", &Dtool_DynamicTextFont_get_poly_margin_95, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_poly_margin_95_comment},
  {"set_page_size", (PyCFunction) &Dtool_DynamicTextFont_set_page_size_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextFont_set_page_size_98_comment},
  {"setPageSize", (PyCFunction) &Dtool_DynamicTextFont_set_page_size_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextFont_set_page_size_98_comment},
  {"get_page_size", &Dtool_DynamicTextFont_get_page_size_99, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_size_99_comment},
  {"getPageSize", &Dtool_DynamicTextFont_get_page_size_99, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_size_99_comment},
  {"get_page_x_size", &Dtool_DynamicTextFont_get_page_x_size_100, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_x_size_100_comment},
  {"getPageXSize", &Dtool_DynamicTextFont_get_page_x_size_100, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_x_size_100_comment},
  {"get_page_y_size", &Dtool_DynamicTextFont_get_page_y_size_101, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_y_size_101_comment},
  {"getPageYSize", &Dtool_DynamicTextFont_get_page_y_size_101, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_y_size_101_comment},
  {"set_minfilter", &Dtool_DynamicTextFont_set_minfilter_105, METH_O, (const char *)Dtool_DynamicTextFont_set_minfilter_105_comment},
  {"setMinfilter", &Dtool_DynamicTextFont_set_minfilter_105, METH_O, (const char *)Dtool_DynamicTextFont_set_minfilter_105_comment},
  {"get_minfilter", &Dtool_DynamicTextFont_get_minfilter_106, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_minfilter_106_comment},
  {"getMinfilter", &Dtool_DynamicTextFont_get_minfilter_106, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_minfilter_106_comment},
  {"set_magfilter", &Dtool_DynamicTextFont_set_magfilter_107, METH_O, (const char *)Dtool_DynamicTextFont_set_magfilter_107_comment},
  {"setMagfilter", &Dtool_DynamicTextFont_set_magfilter_107, METH_O, (const char *)Dtool_DynamicTextFont_set_magfilter_107_comment},
  {"get_magfilter", &Dtool_DynamicTextFont_get_magfilter_108, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_magfilter_108_comment},
  {"getMagfilter", &Dtool_DynamicTextFont_get_magfilter_108, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_magfilter_108_comment},
  {"set_anisotropic_degree", &Dtool_DynamicTextFont_set_anisotropic_degree_109, METH_O, (const char *)Dtool_DynamicTextFont_set_anisotropic_degree_109_comment},
  {"setAnisotropicDegree", &Dtool_DynamicTextFont_set_anisotropic_degree_109, METH_O, (const char *)Dtool_DynamicTextFont_set_anisotropic_degree_109_comment},
  {"get_anisotropic_degree", &Dtool_DynamicTextFont_get_anisotropic_degree_110, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_anisotropic_degree_110_comment},
  {"getAnisotropicDegree", &Dtool_DynamicTextFont_get_anisotropic_degree_110, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_anisotropic_degree_110_comment},
  {"set_render_mode", &Dtool_DynamicTextFont_set_render_mode_116, METH_O, (const char *)Dtool_DynamicTextFont_set_render_mode_116_comment},
  {"setRenderMode", &Dtool_DynamicTextFont_set_render_mode_116, METH_O, (const char *)Dtool_DynamicTextFont_set_render_mode_116_comment},
  {"get_render_mode", &Dtool_DynamicTextFont_get_render_mode_117, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_render_mode_117_comment},
  {"getRenderMode", &Dtool_DynamicTextFont_get_render_mode_117, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_render_mode_117_comment},
  {"set_fg", &Dtool_DynamicTextFont_set_fg_119, METH_O, (const char *)Dtool_DynamicTextFont_set_fg_119_comment},
  {"setFg", &Dtool_DynamicTextFont_set_fg_119, METH_O, (const char *)Dtool_DynamicTextFont_set_fg_119_comment},
  {"get_fg", &Dtool_DynamicTextFont_get_fg_120, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_fg_120_comment},
  {"getFg", &Dtool_DynamicTextFont_get_fg_120, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_fg_120_comment},
  {"set_bg", &Dtool_DynamicTextFont_set_bg_121, METH_O, (const char *)Dtool_DynamicTextFont_set_bg_121_comment},
  {"setBg", &Dtool_DynamicTextFont_set_bg_121, METH_O, (const char *)Dtool_DynamicTextFont_set_bg_121_comment},
  {"get_bg", &Dtool_DynamicTextFont_get_bg_122, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_bg_122_comment},
  {"getBg", &Dtool_DynamicTextFont_get_bg_122, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_bg_122_comment},
  {"set_outline", (PyCFunction) &Dtool_DynamicTextFont_set_outline_123, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextFont_set_outline_123_comment},
  {"setOutline", (PyCFunction) &Dtool_DynamicTextFont_set_outline_123, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextFont_set_outline_123_comment},
  {"get_outline_color", &Dtool_DynamicTextFont_get_outline_color_124, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_color_124_comment},
  {"getOutlineColor", &Dtool_DynamicTextFont_get_outline_color_124, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_color_124_comment},
  {"get_outline_width", &Dtool_DynamicTextFont_get_outline_width_125, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_width_125_comment},
  {"getOutlineWidth", &Dtool_DynamicTextFont_get_outline_width_125, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_width_125_comment},
  {"get_outline_feather", &Dtool_DynamicTextFont_get_outline_feather_126, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_feather_126_comment},
  {"getOutlineFeather", &Dtool_DynamicTextFont_get_outline_feather_126, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_feather_126_comment},
  {"get_tex_format", &Dtool_DynamicTextFont_get_tex_format_127, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_tex_format_127_comment},
  {"getTexFormat", &Dtool_DynamicTextFont_get_tex_format_127, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_tex_format_127_comment},
  {"get_num_pages", &Dtool_DynamicTextFont_get_num_pages_136, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_num_pages_136_comment},
  {"getNumPages", &Dtool_DynamicTextFont_get_num_pages_136, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_num_pages_136_comment},
  {"get_page", &Dtool_DynamicTextFont_get_page_137, METH_O, (const char *)Dtool_DynamicTextFont_get_page_137_comment},
  {"getPage", &Dtool_DynamicTextFont_get_page_137, METH_O, (const char *)Dtool_DynamicTextFont_get_page_137_comment},
  {"garbage_collect", &Dtool_DynamicTextFont_garbage_collect_140, METH_NOARGS, (const char *)Dtool_DynamicTextFont_garbage_collect_140_comment},
  {"garbageCollect", &Dtool_DynamicTextFont_garbage_collect_140, METH_NOARGS, (const char *)Dtool_DynamicTextFont_garbage_collect_140_comment},
  {"clear", &Dtool_DynamicTextFont_clear_141, METH_NOARGS, (const char *)Dtool_DynamicTextFont_clear_141_comment},
  {"write", (PyCFunction) &Dtool_DynamicTextFont_write_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextFont_write_142_comment},
  {"get_class_type", &Dtool_DynamicTextFont_get_class_type_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextFont_get_class_type_143_comment},
  {"getClassType", &Dtool_DynamicTextFont_get_class_type_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextFont_get_class_type_143_comment},
  {"upcast_to_TextFont", &Dtool_DynamicTextFont_upcast_to_TextFont_67, METH_NOARGS, (const char *)Dtool_DynamicTextFont_upcast_to_TextFont_67_comment},
  {"upcastToTextFont", &Dtool_DynamicTextFont_upcast_to_TextFont_67, METH_NOARGS, (const char *)Dtool_DynamicTextFont_upcast_to_TextFont_67_comment},
  {"upcast_to_FreetypeFont", &Dtool_DynamicTextFont_upcast_to_FreetypeFont_70, METH_NOARGS, (const char *)Dtool_DynamicTextFont_upcast_to_FreetypeFont_70_comment},
  {"upcastToFreetypeFont", &Dtool_DynamicTextFont_upcast_to_FreetypeFont_70, METH_NOARGS, (const char *)Dtool_DynamicTextFont_upcast_to_FreetypeFont_70_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_pages", (PyCFunction) &MakeSeq_DynamicTextFont_get_pages, METH_NOARGS, nullptr},
  { "getPages", (PyCFunction) &MakeSeq_DynamicTextFont_get_pages, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     DynamicTextFont
//////////////////
static PyObject *Dtool_Str_DynamicTextFont(PyObject *self) {
  DynamicTextFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_DynamicTextFont[] = {
  {(char *)"point_size", &Dtool_DynamicTextFont_point_size_Getter, &Dtool_DynamicTextFont_point_size_Setter, nullptr, nullptr},
  {(char *)"pixels_per_unit", &Dtool_DynamicTextFont_pixels_per_unit_Getter, &Dtool_DynamicTextFont_pixels_per_unit_Setter, nullptr, nullptr},
  {(char *)"scale_factor", &Dtool_DynamicTextFont_scale_factor_Getter, &Dtool_DynamicTextFont_scale_factor_Setter, nullptr, nullptr},
  {(char *)"native_antialias", &Dtool_DynamicTextFont_native_antialias_Getter, &Dtool_DynamicTextFont_native_antialias_Setter, nullptr, nullptr},
  {(char *)"font_pixel_size", &Dtool_DynamicTextFont_font_pixel_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"texture_margin", &Dtool_DynamicTextFont_texture_margin_Getter, &Dtool_DynamicTextFont_texture_margin_Setter, nullptr, nullptr},
  {(char *)"poly_margin", &Dtool_DynamicTextFont_poly_margin_Getter, &Dtool_DynamicTextFont_poly_margin_Setter, nullptr, nullptr},
  {(char *)"page_size", &Dtool_DynamicTextFont_page_size_Getter, &Dtool_DynamicTextFont_page_size_Setter, nullptr, nullptr},
  {(char *)"minfilter", &Dtool_DynamicTextFont_minfilter_Getter, &Dtool_DynamicTextFont_minfilter_Setter, nullptr, nullptr},
  {(char *)"magfilter", &Dtool_DynamicTextFont_magfilter_Getter, &Dtool_DynamicTextFont_magfilter_Setter, nullptr, nullptr},
  {(char *)"anisotropic_degree", &Dtool_DynamicTextFont_anisotropic_degree_Getter, &Dtool_DynamicTextFont_anisotropic_degree_Setter, nullptr, nullptr},
  {(char *)"render_mode", &Dtool_DynamicTextFont_render_mode_Getter, &Dtool_DynamicTextFont_render_mode_Setter, nullptr, nullptr},
  {(char *)"fg", &Dtool_DynamicTextFont_fg_Getter, &Dtool_DynamicTextFont_fg_Setter, nullptr, nullptr},
  {(char *)"bg", &Dtool_DynamicTextFont_bg_Getter, &Dtool_DynamicTextFont_bg_Setter, nullptr, nullptr},
  {(char *)"tex_format", &Dtool_DynamicTextFont_tex_format_Getter, nullptr, nullptr, nullptr},
  {(char *)"pages", &Dtool_DynamicTextFont_pages_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DynamicTextFont = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DynamicTextFont = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DynamicTextFont = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DynamicTextFont = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DynamicTextFont = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DynamicTextFont = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DynamicTextFont",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DynamicTextFont,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DynamicTextFont,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DynamicTextFont,
    &Dtool_SequenceMethods_DynamicTextFont,
    &Dtool_MappingMethods_DynamicTextFont,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_DynamicTextFont,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DynamicTextFont,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A DynamicTextFont is a special TextFont object that rasterizes its glyphs\n"
    " * from a standard font file (e.g.  a TTF file) on the fly.  It requires the\n"
    " * FreeType 2.0 library (or any higher, backward-compatible version).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DynamicTextFont,
    nullptr, // tp_members
    Dtool_Properties_DynamicTextFont,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DynamicTextFont,
    PyType_GenericAlloc,
    Dtool_new_DynamicTextFont,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DynamicTextFont,
  Dtool_UpcastInterface_DynamicTextFont,
  Dtool_DowncastInterface_DynamicTextFont,
  (CoerceFunction)Dtool_ConstCoerce_DynamicTextFont,
  (CoerceFunction)Dtool_Coerce_DynamicTextFont,
};

static void Dtool_PyModuleClassInit_DynamicTextFont(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TextFont(nullptr);
    assert(Dtool_Ptr_FreetypeFont != nullptr);
    assert(Dtool_Ptr_FreetypeFont->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_FreetypeFont->_Dtool_ModuleClassInit(nullptr);
    Dtool_DynamicTextFont._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_TextFont, (PyTypeObject *)Dtool_Ptr_FreetypeFont);
    Dtool_DynamicTextFont._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DynamicTextFont._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DynamicTextFont) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DynamicTextFont)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DynamicTextFont);
  }
}

/**
 * Python method tables for FontPool (FontPool)
 */
static PyMethodDef Dtool_Methods_FontPool[] = {
  {"has_font", &Dtool_FontPool_has_font_145, METH_O | METH_STATIC, (const char *)Dtool_FontPool_has_font_145_comment},
  {"hasFont", &Dtool_FontPool_has_font_145, METH_O | METH_STATIC, (const char *)Dtool_FontPool_has_font_145_comment},
  {"verify_font", &Dtool_FontPool_verify_font_146, METH_O | METH_STATIC, (const char *)Dtool_FontPool_verify_font_146_comment},
  {"verifyFont", &Dtool_FontPool_verify_font_146, METH_O | METH_STATIC, (const char *)Dtool_FontPool_verify_font_146_comment},
  {"load_font", &Dtool_FontPool_load_font_147, METH_O | METH_STATIC, (const char *)Dtool_FontPool_load_font_147_comment},
  {"loadFont", &Dtool_FontPool_load_font_147, METH_O | METH_STATIC, (const char *)Dtool_FontPool_load_font_147_comment},
  {"add_font", (PyCFunction) &Dtool_FontPool_add_font_148, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_FontPool_add_font_148_comment},
  {"addFont", (PyCFunction) &Dtool_FontPool_add_font_148, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_FontPool_add_font_148_comment},
  {"release_font", &Dtool_FontPool_release_font_149, METH_O | METH_STATIC, (const char *)Dtool_FontPool_release_font_149_comment},
  {"releaseFont", &Dtool_FontPool_release_font_149, METH_O | METH_STATIC, (const char *)Dtool_FontPool_release_font_149_comment},
  {"release_all_fonts", &Dtool_FontPool_release_all_fonts_150, METH_NOARGS | METH_STATIC, (const char *)Dtool_FontPool_release_all_fonts_150_comment},
  {"releaseAllFonts", &Dtool_FontPool_release_all_fonts_150, METH_NOARGS | METH_STATIC, (const char *)Dtool_FontPool_release_all_fonts_150_comment},
  {"garbage_collect", &Dtool_FontPool_garbage_collect_151, METH_NOARGS | METH_STATIC, (const char *)Dtool_FontPool_garbage_collect_151_comment},
  {"garbageCollect", &Dtool_FontPool_garbage_collect_151, METH_NOARGS | METH_STATIC, (const char *)Dtool_FontPool_garbage_collect_151_comment},
  {"list_contents", &Dtool_FontPool_list_contents_152, METH_O | METH_STATIC, (const char *)Dtool_FontPool_list_contents_152_comment},
  {"listContents", &Dtool_FontPool_list_contents_152, METH_O | METH_STATIC, (const char *)Dtool_FontPool_list_contents_152_comment},
  {"write", &Dtool_FontPool_write_153, METH_O | METH_STATIC, (const char *)Dtool_FontPool_write_153_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     FontPool
//////////////////
static PyObject *Dtool_Str_FontPool(PyObject *self) {
  FontPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FontPool, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_FontPool = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_FontPool = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.FontPool",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FontPool,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_FontPool,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_FontPool,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the preferred interface for loading fonts for the TextNode system.\n"
    " * It is similar to ModelPool and TexturePool in that it unifies references to\n"
    " * the same filename.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FontPool,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FontPool,
    PyType_GenericAlloc,
    Dtool_new_FontPool,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FontPool,
  Dtool_UpcastInterface_FontPool,
  Dtool_DowncastInterface_FontPool,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_FontPool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_FontPool._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_FontPool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FontPool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FontPool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FontPool);
  }
}

/**
 * Python method tables for GeomTextGlyph (GeomTextGlyph)
 */
static PyMethodDef Dtool_Methods_GeomTextGlyph[] = {
  {"get_class_type", &Dtool_GeomTextGlyph_get_class_type_157, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTextGlyph_get_class_type_157_comment},
  {"getClassType", &Dtool_GeomTextGlyph_get_class_type_157, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTextGlyph_get_class_type_157_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeomTextGlyph = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomTextGlyph = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeomTextGlyph = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeomTextGlyph = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeomTextGlyph = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeomTextGlyph = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeomTextGlyph",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomTextGlyph,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeomTextGlyph,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeomTextGlyph,
    &Dtool_SequenceMethods_GeomTextGlyph,
    &Dtool_MappingMethods_GeomTextGlyph,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeomTextGlyph,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization on Geom for containing a primitive intended to\n"
    " * represent a TextGlyph.  Its sole purpose is to maintain the geom count on\n"
    " * the glyph, so we can determine the actual usage count on a dynamic glyph\n"
    " * (and thus know when it is safe to recycle the glyph).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeomTextGlyph,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeomTextGlyph,
    PyType_GenericAlloc,
    Dtool_new_GeomTextGlyph,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomTextGlyph,
  Dtool_UpcastInterface_GeomTextGlyph,
  Dtool_DowncastInterface_GeomTextGlyph,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeomTextGlyph(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Geom != nullptr);
    assert(Dtool_Ptr_Geom->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Geom->_Dtool_ModuleClassInit(nullptr);
    Dtool_GeomTextGlyph._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Geom);
    Dtool_GeomTextGlyph._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeomTextGlyph._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomTextGlyph) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomTextGlyph)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomTextGlyph);
  }
}

/**
 * Python method tables for StaticTextFont (StaticTextFont)
 */
static PyMethodDef Dtool_Methods_StaticTextFont[] = {
  {"get_class_type", &Dtool_StaticTextFont_get_class_type_160, METH_NOARGS | METH_STATIC, (const char *)Dtool_StaticTextFont_get_class_type_160_comment},
  {"getClassType", &Dtool_StaticTextFont_get_class_type_160, METH_NOARGS | METH_STATIC, (const char *)Dtool_StaticTextFont_get_class_type_160_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_StaticTextFont = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_StaticTextFont = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_StaticTextFont = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_StaticTextFont = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_StaticTextFont = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_StaticTextFont = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.StaticTextFont",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_StaticTextFont,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_StaticTextFont,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_StaticTextFont,
    &Dtool_SequenceMethods_StaticTextFont,
    &Dtool_MappingMethods_StaticTextFont,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_StaticTextFont,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A StaticTextFont is loaded up from a model that was previously generated\n"
    " * via egg-mkfont, and contains all of its glyphs already generated and\n"
    " * available for use.  It doesn't require linking with any external libraries\n"
    " * like FreeType.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_StaticTextFont,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_StaticTextFont,
    PyType_GenericAlloc,
    Dtool_new_StaticTextFont,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StaticTextFont,
  Dtool_UpcastInterface_StaticTextFont,
  Dtool_DowncastInterface_StaticTextFont,
  (CoerceFunction)Dtool_ConstCoerce_StaticTextFont,
  (CoerceFunction)Dtool_Coerce_StaticTextFont,
};

static void Dtool_PyModuleClassInit_StaticTextFont(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TextFont(nullptr);
    Dtool_StaticTextFont._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TextFont);
    Dtool_StaticTextFont._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_StaticTextFont._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StaticTextFont) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StaticTextFont)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StaticTextFont);
  }
}

/**
 * Python method tables for TextProperties (TextProperties)
 */
static PyMethodDef Dtool_Methods_TextProperties[] = {
  {"assign", &Dtool_TextProperties_operator_166, METH_O, (const char *)Dtool_TextProperties_operator_166_comment},
  {"clear", &Dtool_TextProperties_clear_169, METH_NOARGS, (const char *)Dtool_TextProperties_clear_169_comment},
  {"is_any_specified", &Dtool_TextProperties_is_any_specified_170, METH_NOARGS, (const char *)Dtool_TextProperties_is_any_specified_170_comment},
  {"isAnySpecified", &Dtool_TextProperties_is_any_specified_170, METH_NOARGS, (const char *)Dtool_TextProperties_is_any_specified_170_comment},
  {"set_default_font", &Dtool_TextProperties_set_default_font_171, METH_O | METH_STATIC, (const char *)Dtool_TextProperties_set_default_font_171_comment},
  {"setDefaultFont", &Dtool_TextProperties_set_default_font_171, METH_O | METH_STATIC, (const char *)Dtool_TextProperties_set_default_font_171_comment},
  {"get_default_font", &Dtool_TextProperties_get_default_font_172, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextProperties_get_default_font_172_comment},
  {"getDefaultFont", &Dtool_TextProperties_get_default_font_172, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextProperties_get_default_font_172_comment},
  {"set_font", &Dtool_TextProperties_set_font_173, METH_O, (const char *)Dtool_TextProperties_set_font_173_comment},
  {"setFont", &Dtool_TextProperties_set_font_173, METH_O, (const char *)Dtool_TextProperties_set_font_173_comment},
  {"clear_font", &Dtool_TextProperties_clear_font_174, METH_NOARGS, (const char *)Dtool_TextProperties_clear_font_174_comment},
  {"clearFont", &Dtool_TextProperties_clear_font_174, METH_NOARGS, (const char *)Dtool_TextProperties_clear_font_174_comment},
  {"has_font", &Dtool_TextProperties_has_font_175, METH_NOARGS, (const char *)Dtool_TextProperties_has_font_175_comment},
  {"hasFont", &Dtool_TextProperties_has_font_175, METH_NOARGS, (const char *)Dtool_TextProperties_has_font_175_comment},
  {"get_font", &Dtool_TextProperties_get_font_176, METH_NOARGS, (const char *)Dtool_TextProperties_get_font_176_comment},
  {"getFont", &Dtool_TextProperties_get_font_176, METH_NOARGS, (const char *)Dtool_TextProperties_get_font_176_comment},
  {"set_small_caps", &Dtool_TextProperties_set_small_caps_177, METH_O, (const char *)Dtool_TextProperties_set_small_caps_177_comment},
  {"setSmallCaps", &Dtool_TextProperties_set_small_caps_177, METH_O, (const char *)Dtool_TextProperties_set_small_caps_177_comment},
  {"clear_small_caps", &Dtool_TextProperties_clear_small_caps_178, METH_NOARGS, (const char *)Dtool_TextProperties_clear_small_caps_178_comment},
  {"clearSmallCaps", &Dtool_TextProperties_clear_small_caps_178, METH_NOARGS, (const char *)Dtool_TextProperties_clear_small_caps_178_comment},
  {"has_small_caps", &Dtool_TextProperties_has_small_caps_179, METH_NOARGS, (const char *)Dtool_TextProperties_has_small_caps_179_comment},
  {"hasSmallCaps", &Dtool_TextProperties_has_small_caps_179, METH_NOARGS, (const char *)Dtool_TextProperties_has_small_caps_179_comment},
  {"get_small_caps", &Dtool_TextProperties_get_small_caps_180, METH_NOARGS, (const char *)Dtool_TextProperties_get_small_caps_180_comment},
  {"getSmallCaps", &Dtool_TextProperties_get_small_caps_180, METH_NOARGS, (const char *)Dtool_TextProperties_get_small_caps_180_comment},
  {"set_small_caps_scale", &Dtool_TextProperties_set_small_caps_scale_181, METH_O, (const char *)Dtool_TextProperties_set_small_caps_scale_181_comment},
  {"setSmallCapsScale", &Dtool_TextProperties_set_small_caps_scale_181, METH_O, (const char *)Dtool_TextProperties_set_small_caps_scale_181_comment},
  {"clear_small_caps_scale", &Dtool_TextProperties_clear_small_caps_scale_182, METH_NOARGS, (const char *)Dtool_TextProperties_clear_small_caps_scale_182_comment},
  {"clearSmallCapsScale", &Dtool_TextProperties_clear_small_caps_scale_182, METH_NOARGS, (const char *)Dtool_TextProperties_clear_small_caps_scale_182_comment},
  {"has_small_caps_scale", &Dtool_TextProperties_has_small_caps_scale_183, METH_NOARGS, (const char *)Dtool_TextProperties_has_small_caps_scale_183_comment},
  {"hasSmallCapsScale", &Dtool_TextProperties_has_small_caps_scale_183, METH_NOARGS, (const char *)Dtool_TextProperties_has_small_caps_scale_183_comment},
  {"get_small_caps_scale", &Dtool_TextProperties_get_small_caps_scale_184, METH_NOARGS, (const char *)Dtool_TextProperties_get_small_caps_scale_184_comment},
  {"getSmallCapsScale", &Dtool_TextProperties_get_small_caps_scale_184, METH_NOARGS, (const char *)Dtool_TextProperties_get_small_caps_scale_184_comment},
  {"set_slant", &Dtool_TextProperties_set_slant_185, METH_O, (const char *)Dtool_TextProperties_set_slant_185_comment},
  {"setSlant", &Dtool_TextProperties_set_slant_185, METH_O, (const char *)Dtool_TextProperties_set_slant_185_comment},
  {"clear_slant", &Dtool_TextProperties_clear_slant_186, METH_NOARGS, (const char *)Dtool_TextProperties_clear_slant_186_comment},
  {"clearSlant", &Dtool_TextProperties_clear_slant_186, METH_NOARGS, (const char *)Dtool_TextProperties_clear_slant_186_comment},
  {"has_slant", &Dtool_TextProperties_has_slant_187, METH_NOARGS, (const char *)Dtool_TextProperties_has_slant_187_comment},
  {"hasSlant", &Dtool_TextProperties_has_slant_187, METH_NOARGS, (const char *)Dtool_TextProperties_has_slant_187_comment},
  {"get_slant", &Dtool_TextProperties_get_slant_188, METH_NOARGS, (const char *)Dtool_TextProperties_get_slant_188_comment},
  {"getSlant", &Dtool_TextProperties_get_slant_188, METH_NOARGS, (const char *)Dtool_TextProperties_get_slant_188_comment},
  {"set_underscore", &Dtool_TextProperties_set_underscore_189, METH_O, (const char *)Dtool_TextProperties_set_underscore_189_comment},
  {"setUnderscore", &Dtool_TextProperties_set_underscore_189, METH_O, (const char *)Dtool_TextProperties_set_underscore_189_comment},
  {"clear_underscore", &Dtool_TextProperties_clear_underscore_190, METH_NOARGS, (const char *)Dtool_TextProperties_clear_underscore_190_comment},
  {"clearUnderscore", &Dtool_TextProperties_clear_underscore_190, METH_NOARGS, (const char *)Dtool_TextProperties_clear_underscore_190_comment},
  {"has_underscore", &Dtool_TextProperties_has_underscore_191, METH_NOARGS, (const char *)Dtool_TextProperties_has_underscore_191_comment},
  {"hasUnderscore", &Dtool_TextProperties_has_underscore_191, METH_NOARGS, (const char *)Dtool_TextProperties_has_underscore_191_comment},
  {"get_underscore", &Dtool_TextProperties_get_underscore_192, METH_NOARGS, (const char *)Dtool_TextProperties_get_underscore_192_comment},
  {"getUnderscore", &Dtool_TextProperties_get_underscore_192, METH_NOARGS, (const char *)Dtool_TextProperties_get_underscore_192_comment},
  {"set_underscore_height", &Dtool_TextProperties_set_underscore_height_193, METH_O, (const char *)Dtool_TextProperties_set_underscore_height_193_comment},
  {"setUnderscoreHeight", &Dtool_TextProperties_set_underscore_height_193, METH_O, (const char *)Dtool_TextProperties_set_underscore_height_193_comment},
  {"clear_underscore_height", &Dtool_TextProperties_clear_underscore_height_194, METH_NOARGS, (const char *)Dtool_TextProperties_clear_underscore_height_194_comment},
  {"clearUnderscoreHeight", &Dtool_TextProperties_clear_underscore_height_194, METH_NOARGS, (const char *)Dtool_TextProperties_clear_underscore_height_194_comment},
  {"has_underscore_height", &Dtool_TextProperties_has_underscore_height_195, METH_NOARGS, (const char *)Dtool_TextProperties_has_underscore_height_195_comment},
  {"hasUnderscoreHeight", &Dtool_TextProperties_has_underscore_height_195, METH_NOARGS, (const char *)Dtool_TextProperties_has_underscore_height_195_comment},
  {"get_underscore_height", &Dtool_TextProperties_get_underscore_height_196, METH_NOARGS, (const char *)Dtool_TextProperties_get_underscore_height_196_comment},
  {"getUnderscoreHeight", &Dtool_TextProperties_get_underscore_height_196, METH_NOARGS, (const char *)Dtool_TextProperties_get_underscore_height_196_comment},
  {"set_align", &Dtool_TextProperties_set_align_197, METH_O, (const char *)Dtool_TextProperties_set_align_197_comment},
  {"setAlign", &Dtool_TextProperties_set_align_197, METH_O, (const char *)Dtool_TextProperties_set_align_197_comment},
  {"clear_align", &Dtool_TextProperties_clear_align_198, METH_NOARGS, (const char *)Dtool_TextProperties_clear_align_198_comment},
  {"clearAlign", &Dtool_TextProperties_clear_align_198, METH_NOARGS, (const char *)Dtool_TextProperties_clear_align_198_comment},
  {"has_align", &Dtool_TextProperties_has_align_199, METH_NOARGS, (const char *)Dtool_TextProperties_has_align_199_comment},
  {"hasAlign", &Dtool_TextProperties_has_align_199, METH_NOARGS, (const char *)Dtool_TextProperties_has_align_199_comment},
  {"get_align", &Dtool_TextProperties_get_align_200, METH_NOARGS, (const char *)Dtool_TextProperties_get_align_200_comment},
  {"getAlign", &Dtool_TextProperties_get_align_200, METH_NOARGS, (const char *)Dtool_TextProperties_get_align_200_comment},
  {"set_indent", &Dtool_TextProperties_set_indent_201, METH_O, (const char *)Dtool_TextProperties_set_indent_201_comment},
  {"setIndent", &Dtool_TextProperties_set_indent_201, METH_O, (const char *)Dtool_TextProperties_set_indent_201_comment},
  {"clear_indent", &Dtool_TextProperties_clear_indent_202, METH_NOARGS, (const char *)Dtool_TextProperties_clear_indent_202_comment},
  {"clearIndent", &Dtool_TextProperties_clear_indent_202, METH_NOARGS, (const char *)Dtool_TextProperties_clear_indent_202_comment},
  {"has_indent", &Dtool_TextProperties_has_indent_203, METH_NOARGS, (const char *)Dtool_TextProperties_has_indent_203_comment},
  {"hasIndent", &Dtool_TextProperties_has_indent_203, METH_NOARGS, (const char *)Dtool_TextProperties_has_indent_203_comment},
  {"get_indent", &Dtool_TextProperties_get_indent_204, METH_NOARGS, (const char *)Dtool_TextProperties_get_indent_204_comment},
  {"getIndent", &Dtool_TextProperties_get_indent_204, METH_NOARGS, (const char *)Dtool_TextProperties_get_indent_204_comment},
  {"set_wordwrap", &Dtool_TextProperties_set_wordwrap_205, METH_O, (const char *)Dtool_TextProperties_set_wordwrap_205_comment},
  {"setWordwrap", &Dtool_TextProperties_set_wordwrap_205, METH_O, (const char *)Dtool_TextProperties_set_wordwrap_205_comment},
  {"clear_wordwrap", &Dtool_TextProperties_clear_wordwrap_206, METH_NOARGS, (const char *)Dtool_TextProperties_clear_wordwrap_206_comment},
  {"clearWordwrap", &Dtool_TextProperties_clear_wordwrap_206, METH_NOARGS, (const char *)Dtool_TextProperties_clear_wordwrap_206_comment},
  {"has_wordwrap", &Dtool_TextProperties_has_wordwrap_207, METH_NOARGS, (const char *)Dtool_TextProperties_has_wordwrap_207_comment},
  {"hasWordwrap", &Dtool_TextProperties_has_wordwrap_207, METH_NOARGS, (const char *)Dtool_TextProperties_has_wordwrap_207_comment},
  {"get_wordwrap", &Dtool_TextProperties_get_wordwrap_208, METH_NOARGS, (const char *)Dtool_TextProperties_get_wordwrap_208_comment},
  {"getWordwrap", &Dtool_TextProperties_get_wordwrap_208, METH_NOARGS, (const char *)Dtool_TextProperties_get_wordwrap_208_comment},
  {"set_preserve_trailing_whitespace", &Dtool_TextProperties_set_preserve_trailing_whitespace_209, METH_O, (const char *)Dtool_TextProperties_set_preserve_trailing_whitespace_209_comment},
  {"setPreserveTrailingWhitespace", &Dtool_TextProperties_set_preserve_trailing_whitespace_209, METH_O, (const char *)Dtool_TextProperties_set_preserve_trailing_whitespace_209_comment},
  {"clear_preserve_trailing_whitespace", &Dtool_TextProperties_clear_preserve_trailing_whitespace_210, METH_NOARGS, (const char *)Dtool_TextProperties_clear_preserve_trailing_whitespace_210_comment},
  {"clearPreserveTrailingWhitespace", &Dtool_TextProperties_clear_preserve_trailing_whitespace_210, METH_NOARGS, (const char *)Dtool_TextProperties_clear_preserve_trailing_whitespace_210_comment},
  {"has_preserve_trailing_whitespace", &Dtool_TextProperties_has_preserve_trailing_whitespace_211, METH_NOARGS, (const char *)Dtool_TextProperties_has_preserve_trailing_whitespace_211_comment},
  {"hasPreserveTrailingWhitespace", &Dtool_TextProperties_has_preserve_trailing_whitespace_211, METH_NOARGS, (const char *)Dtool_TextProperties_has_preserve_trailing_whitespace_211_comment},
  {"get_preserve_trailing_whitespace", &Dtool_TextProperties_get_preserve_trailing_whitespace_212, METH_NOARGS, (const char *)Dtool_TextProperties_get_preserve_trailing_whitespace_212_comment},
  {"getPreserveTrailingWhitespace", &Dtool_TextProperties_get_preserve_trailing_whitespace_212, METH_NOARGS, (const char *)Dtool_TextProperties_get_preserve_trailing_whitespace_212_comment},
  {"set_text_color", (PyCFunction) &Dtool_TextProperties_set_text_color_213, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_text_color_213_comment},
  {"setTextColor", (PyCFunction) &Dtool_TextProperties_set_text_color_213, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_text_color_213_comment},
  {"clear_text_color", &Dtool_TextProperties_clear_text_color_214, METH_NOARGS, (const char *)Dtool_TextProperties_clear_text_color_214_comment},
  {"clearTextColor", &Dtool_TextProperties_clear_text_color_214, METH_NOARGS, (const char *)Dtool_TextProperties_clear_text_color_214_comment},
  {"has_text_color", &Dtool_TextProperties_has_text_color_215, METH_NOARGS, (const char *)Dtool_TextProperties_has_text_color_215_comment},
  {"hasTextColor", &Dtool_TextProperties_has_text_color_215, METH_NOARGS, (const char *)Dtool_TextProperties_has_text_color_215_comment},
  {"get_text_color", &Dtool_TextProperties_get_text_color_216, METH_NOARGS, (const char *)Dtool_TextProperties_get_text_color_216_comment},
  {"getTextColor", &Dtool_TextProperties_get_text_color_216, METH_NOARGS, (const char *)Dtool_TextProperties_get_text_color_216_comment},
  {"set_shadow_color", (PyCFunction) &Dtool_TextProperties_set_shadow_color_217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_shadow_color_217_comment},
  {"setShadowColor", (PyCFunction) &Dtool_TextProperties_set_shadow_color_217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_shadow_color_217_comment},
  {"clear_shadow_color", &Dtool_TextProperties_clear_shadow_color_218, METH_NOARGS, (const char *)Dtool_TextProperties_clear_shadow_color_218_comment},
  {"clearShadowColor", &Dtool_TextProperties_clear_shadow_color_218, METH_NOARGS, (const char *)Dtool_TextProperties_clear_shadow_color_218_comment},
  {"has_shadow_color", &Dtool_TextProperties_has_shadow_color_219, METH_NOARGS, (const char *)Dtool_TextProperties_has_shadow_color_219_comment},
  {"hasShadowColor", &Dtool_TextProperties_has_shadow_color_219, METH_NOARGS, (const char *)Dtool_TextProperties_has_shadow_color_219_comment},
  {"get_shadow_color", &Dtool_TextProperties_get_shadow_color_220, METH_NOARGS, (const char *)Dtool_TextProperties_get_shadow_color_220_comment},
  {"getShadowColor", &Dtool_TextProperties_get_shadow_color_220, METH_NOARGS, (const char *)Dtool_TextProperties_get_shadow_color_220_comment},
  {"set_shadow", (PyCFunction) &Dtool_TextProperties_set_shadow_221, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_shadow_221_comment},
  {"setShadow", (PyCFunction) &Dtool_TextProperties_set_shadow_221, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_shadow_221_comment},
  {"clear_shadow", &Dtool_TextProperties_clear_shadow_222, METH_NOARGS, (const char *)Dtool_TextProperties_clear_shadow_222_comment},
  {"clearShadow", &Dtool_TextProperties_clear_shadow_222, METH_NOARGS, (const char *)Dtool_TextProperties_clear_shadow_222_comment},
  {"has_shadow", &Dtool_TextProperties_has_shadow_223, METH_NOARGS, (const char *)Dtool_TextProperties_has_shadow_223_comment},
  {"hasShadow", &Dtool_TextProperties_has_shadow_223, METH_NOARGS, (const char *)Dtool_TextProperties_has_shadow_223_comment},
  {"get_shadow", &Dtool_TextProperties_get_shadow_224, METH_NOARGS, (const char *)Dtool_TextProperties_get_shadow_224_comment},
  {"getShadow", &Dtool_TextProperties_get_shadow_224, METH_NOARGS, (const char *)Dtool_TextProperties_get_shadow_224_comment},
  {"set_bin", &Dtool_TextProperties_set_bin_225, METH_O, (const char *)Dtool_TextProperties_set_bin_225_comment},
  {"setBin", &Dtool_TextProperties_set_bin_225, METH_O, (const char *)Dtool_TextProperties_set_bin_225_comment},
  {"clear_bin", &Dtool_TextProperties_clear_bin_226, METH_NOARGS, (const char *)Dtool_TextProperties_clear_bin_226_comment},
  {"clearBin", &Dtool_TextProperties_clear_bin_226, METH_NOARGS, (const char *)Dtool_TextProperties_clear_bin_226_comment},
  {"has_bin", &Dtool_TextProperties_has_bin_227, METH_NOARGS, (const char *)Dtool_TextProperties_has_bin_227_comment},
  {"hasBin", &Dtool_TextProperties_has_bin_227, METH_NOARGS, (const char *)Dtool_TextProperties_has_bin_227_comment},
  {"get_bin", &Dtool_TextProperties_get_bin_228, METH_NOARGS, (const char *)Dtool_TextProperties_get_bin_228_comment},
  {"getBin", &Dtool_TextProperties_get_bin_228, METH_NOARGS, (const char *)Dtool_TextProperties_get_bin_228_comment},
  {"set_draw_order", &Dtool_TextProperties_set_draw_order_229, METH_O, (const char *)Dtool_TextProperties_set_draw_order_229_comment},
  {"setDrawOrder", &Dtool_TextProperties_set_draw_order_229, METH_O, (const char *)Dtool_TextProperties_set_draw_order_229_comment},
  {"clear_draw_order", &Dtool_TextProperties_clear_draw_order_230, METH_NOARGS, (const char *)Dtool_TextProperties_clear_draw_order_230_comment},
  {"clearDrawOrder", &Dtool_TextProperties_clear_draw_order_230, METH_NOARGS, (const char *)Dtool_TextProperties_clear_draw_order_230_comment},
  {"has_draw_order", &Dtool_TextProperties_has_draw_order_231, METH_NOARGS, (const char *)Dtool_TextProperties_has_draw_order_231_comment},
  {"hasDrawOrder", &Dtool_TextProperties_has_draw_order_231, METH_NOARGS, (const char *)Dtool_TextProperties_has_draw_order_231_comment},
  {"get_draw_order", &Dtool_TextProperties_get_draw_order_232, METH_NOARGS, (const char *)Dtool_TextProperties_get_draw_order_232_comment},
  {"getDrawOrder", &Dtool_TextProperties_get_draw_order_232, METH_NOARGS, (const char *)Dtool_TextProperties_get_draw_order_232_comment},
  {"set_tab_width", &Dtool_TextProperties_set_tab_width_233, METH_O, (const char *)Dtool_TextProperties_set_tab_width_233_comment},
  {"setTabWidth", &Dtool_TextProperties_set_tab_width_233, METH_O, (const char *)Dtool_TextProperties_set_tab_width_233_comment},
  {"clear_tab_width", &Dtool_TextProperties_clear_tab_width_234, METH_NOARGS, (const char *)Dtool_TextProperties_clear_tab_width_234_comment},
  {"clearTabWidth", &Dtool_TextProperties_clear_tab_width_234, METH_NOARGS, (const char *)Dtool_TextProperties_clear_tab_width_234_comment},
  {"has_tab_width", &Dtool_TextProperties_has_tab_width_235, METH_NOARGS, (const char *)Dtool_TextProperties_has_tab_width_235_comment},
  {"hasTabWidth", &Dtool_TextProperties_has_tab_width_235, METH_NOARGS, (const char *)Dtool_TextProperties_has_tab_width_235_comment},
  {"get_tab_width", &Dtool_TextProperties_get_tab_width_236, METH_NOARGS, (const char *)Dtool_TextProperties_get_tab_width_236_comment},
  {"getTabWidth", &Dtool_TextProperties_get_tab_width_236, METH_NOARGS, (const char *)Dtool_TextProperties_get_tab_width_236_comment},
  {"set_glyph_scale", &Dtool_TextProperties_set_glyph_scale_237, METH_O, (const char *)Dtool_TextProperties_set_glyph_scale_237_comment},
  {"setGlyphScale", &Dtool_TextProperties_set_glyph_scale_237, METH_O, (const char *)Dtool_TextProperties_set_glyph_scale_237_comment},
  {"clear_glyph_scale", &Dtool_TextProperties_clear_glyph_scale_238, METH_NOARGS, (const char *)Dtool_TextProperties_clear_glyph_scale_238_comment},
  {"clearGlyphScale", &Dtool_TextProperties_clear_glyph_scale_238, METH_NOARGS, (const char *)Dtool_TextProperties_clear_glyph_scale_238_comment},
  {"has_glyph_scale", &Dtool_TextProperties_has_glyph_scale_239, METH_NOARGS, (const char *)Dtool_TextProperties_has_glyph_scale_239_comment},
  {"hasGlyphScale", &Dtool_TextProperties_has_glyph_scale_239, METH_NOARGS, (const char *)Dtool_TextProperties_has_glyph_scale_239_comment},
  {"get_glyph_scale", &Dtool_TextProperties_get_glyph_scale_240, METH_NOARGS, (const char *)Dtool_TextProperties_get_glyph_scale_240_comment},
  {"getGlyphScale", &Dtool_TextProperties_get_glyph_scale_240, METH_NOARGS, (const char *)Dtool_TextProperties_get_glyph_scale_240_comment},
  {"set_glyph_shift", &Dtool_TextProperties_set_glyph_shift_241, METH_O, (const char *)Dtool_TextProperties_set_glyph_shift_241_comment},
  {"setGlyphShift", &Dtool_TextProperties_set_glyph_shift_241, METH_O, (const char *)Dtool_TextProperties_set_glyph_shift_241_comment},
  {"clear_glyph_shift", &Dtool_TextProperties_clear_glyph_shift_242, METH_NOARGS, (const char *)Dtool_TextProperties_clear_glyph_shift_242_comment},
  {"clearGlyphShift", &Dtool_TextProperties_clear_glyph_shift_242, METH_NOARGS, (const char *)Dtool_TextProperties_clear_glyph_shift_242_comment},
  {"has_glyph_shift", &Dtool_TextProperties_has_glyph_shift_243, METH_NOARGS, (const char *)Dtool_TextProperties_has_glyph_shift_243_comment},
  {"hasGlyphShift", &Dtool_TextProperties_has_glyph_shift_243, METH_NOARGS, (const char *)Dtool_TextProperties_has_glyph_shift_243_comment},
  {"get_glyph_shift", &Dtool_TextProperties_get_glyph_shift_244, METH_NOARGS, (const char *)Dtool_TextProperties_get_glyph_shift_244_comment},
  {"getGlyphShift", &Dtool_TextProperties_get_glyph_shift_244, METH_NOARGS, (const char *)Dtool_TextProperties_get_glyph_shift_244_comment},
  {"set_text_scale", &Dtool_TextProperties_set_text_scale_245, METH_O, (const char *)Dtool_TextProperties_set_text_scale_245_comment},
  {"setTextScale", &Dtool_TextProperties_set_text_scale_245, METH_O, (const char *)Dtool_TextProperties_set_text_scale_245_comment},
  {"clear_text_scale", &Dtool_TextProperties_clear_text_scale_246, METH_NOARGS, (const char *)Dtool_TextProperties_clear_text_scale_246_comment},
  {"clearTextScale", &Dtool_TextProperties_clear_text_scale_246, METH_NOARGS, (const char *)Dtool_TextProperties_clear_text_scale_246_comment},
  {"has_text_scale", &Dtool_TextProperties_has_text_scale_247, METH_NOARGS, (const char *)Dtool_TextProperties_has_text_scale_247_comment},
  {"hasTextScale", &Dtool_TextProperties_has_text_scale_247, METH_NOARGS, (const char *)Dtool_TextProperties_has_text_scale_247_comment},
  {"get_text_scale", &Dtool_TextProperties_get_text_scale_248, METH_NOARGS, (const char *)Dtool_TextProperties_get_text_scale_248_comment},
  {"getTextScale", &Dtool_TextProperties_get_text_scale_248, METH_NOARGS, (const char *)Dtool_TextProperties_get_text_scale_248_comment},
  {"set_direction", &Dtool_TextProperties_set_direction_249, METH_O, (const char *)Dtool_TextProperties_set_direction_249_comment},
  {"setDirection", &Dtool_TextProperties_set_direction_249, METH_O, (const char *)Dtool_TextProperties_set_direction_249_comment},
  {"clear_direction", &Dtool_TextProperties_clear_direction_250, METH_NOARGS, (const char *)Dtool_TextProperties_clear_direction_250_comment},
  {"clearDirection", &Dtool_TextProperties_clear_direction_250, METH_NOARGS, (const char *)Dtool_TextProperties_clear_direction_250_comment},
  {"has_direction", &Dtool_TextProperties_has_direction_251, METH_NOARGS, (const char *)Dtool_TextProperties_has_direction_251_comment},
  {"hasDirection", &Dtool_TextProperties_has_direction_251, METH_NOARGS, (const char *)Dtool_TextProperties_has_direction_251_comment},
  {"get_direction", &Dtool_TextProperties_get_direction_252, METH_NOARGS, (const char *)Dtool_TextProperties_get_direction_252_comment},
  {"getDirection", &Dtool_TextProperties_get_direction_252, METH_NOARGS, (const char *)Dtool_TextProperties_get_direction_252_comment},
  {"add_properties", &Dtool_TextProperties_add_properties_253, METH_O, (const char *)Dtool_TextProperties_add_properties_253_comment},
  {"addProperties", &Dtool_TextProperties_add_properties_253, METH_O, (const char *)Dtool_TextProperties_add_properties_253_comment},
  {"write", (PyCFunction) &Dtool_TextProperties_write_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_write_254_comment},
  {"get_class_type", &Dtool_TextProperties_get_class_type_281, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextProperties_get_class_type_281_comment},
  {"getClassType", &Dtool_TextProperties_get_class_type_281, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextProperties_get_class_type_281_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     TextProperties
//////////////////
static PyObject *Dtool_Str_TextProperties(PyObject *self) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     TextProperties
//////////////////
static PyObject *Dtool_RichCompare_TextProperties(PyObject *self, PyObject *arg, int op) {
  TextProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-bool TextProperties::operator ==(TextProperties const &other) const
      TextProperties const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TextProperties);
      if (arg_this != nullptr) {
        bool return_value = ((*(const TextProperties*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool TextProperties::operator !=(TextProperties const &other) const
      TextProperties const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TextProperties);
      if (arg_this != nullptr) {
        bool return_value = ((*(const TextProperties*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_TextProperties[] = {
  {(char *)"font", &Dtool_TextProperties_font_Getter, &Dtool_TextProperties_font_Setter, nullptr, nullptr},
  {(char *)"small_caps", &Dtool_TextProperties_small_caps_Getter, &Dtool_TextProperties_small_caps_Setter, nullptr, nullptr},
  {(char *)"small_caps_scale", &Dtool_TextProperties_small_caps_scale_Getter, &Dtool_TextProperties_small_caps_scale_Setter, nullptr, nullptr},
  {(char *)"slant", &Dtool_TextProperties_slant_Getter, &Dtool_TextProperties_slant_Setter, nullptr, nullptr},
  {(char *)"underscore", &Dtool_TextProperties_underscore_Getter, &Dtool_TextProperties_underscore_Setter, nullptr, nullptr},
  {(char *)"underscore_height", &Dtool_TextProperties_underscore_height_Getter, &Dtool_TextProperties_underscore_height_Setter, nullptr, nullptr},
  {(char *)"align", &Dtool_TextProperties_align_Getter, &Dtool_TextProperties_align_Setter, nullptr, nullptr},
  {(char *)"indent", &Dtool_TextProperties_indent_Getter, &Dtool_TextProperties_indent_Setter, nullptr, nullptr},
  {(char *)"wordwrap", &Dtool_TextProperties_wordwrap_Getter, &Dtool_TextProperties_wordwrap_Setter, nullptr, nullptr},
  {(char *)"preserve_trailing_whitespace", &Dtool_TextProperties_preserve_trailing_whitespace_Getter, &Dtool_TextProperties_preserve_trailing_whitespace_Setter, nullptr, nullptr},
  {(char *)"text_color", &Dtool_TextProperties_text_color_Getter, &Dtool_TextProperties_text_color_Setter, nullptr, nullptr},
  {(char *)"shadow_color", &Dtool_TextProperties_shadow_color_Getter, &Dtool_TextProperties_shadow_color_Setter, nullptr, nullptr},
  {(char *)"shadow", &Dtool_TextProperties_shadow_Getter, &Dtool_TextProperties_shadow_Setter, nullptr, nullptr},
  {(char *)"bin", &Dtool_TextProperties_bin_Getter, &Dtool_TextProperties_bin_Setter, nullptr, nullptr},
  {(char *)"draw_order", &Dtool_TextProperties_draw_order_Getter, &Dtool_TextProperties_draw_order_Setter, nullptr, nullptr},
  {(char *)"tab_width", &Dtool_TextProperties_tab_width_Getter, &Dtool_TextProperties_tab_width_Setter, nullptr, nullptr},
  {(char *)"glyph_scale", &Dtool_TextProperties_glyph_scale_Getter, &Dtool_TextProperties_glyph_scale_Setter, nullptr, nullptr},
  {(char *)"glyph_shift", &Dtool_TextProperties_glyph_shift_Getter, &Dtool_TextProperties_glyph_shift_Setter, nullptr, nullptr},
  {(char *)"text_scale", &Dtool_TextProperties_text_scale_Getter, &Dtool_TextProperties_text_scale_Setter, nullptr, nullptr},
  {(char *)"direction", &Dtool_TextProperties_direction_Getter, &Dtool_TextProperties_direction_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TextProperties = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TextProperties = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextProperties",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextProperties,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_TextProperties,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_TextProperties,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines the set of visual properties that may be assigned to the\n"
    " * individual characters of the text.  (Properties which affect the overall\n"
    " * block of text can only be specified on the TextNode directly).\n"
    " *\n"
    " * Typically, there is just one set of properties on a given block of text,\n"
    " * which is set directly on the TextNode (TextNode inherits from\n"
    " * TextProperties). That makes all of the text within a particular block have\n"
    " * the same appearance.\n"
    " *\n"
    " * This separate class exists in order to implement multiple different kinds\n"
    " * of text appearing within one block.  The text string itself may reference a\n"
    " * TextProperties structure by name using the \\1 and \\2 tokens embedded within\n"
    " * the string; each nested TextProperties structure modifies the appearance of\n"
    " * subsequent text within the block.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_TextProperties,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextProperties,
    nullptr, // tp_members
    Dtool_Properties_TextProperties,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextProperties,
    PyType_GenericAlloc,
    Dtool_new_TextProperties,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextProperties,
  Dtool_UpcastInterface_TextProperties,
  Dtool_DowncastInterface_TextProperties,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextProperties(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextProperties._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(17);
    Dtool_TextProperties._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TextProperties::Alignment;
    PyDict_SetItemString(dict, "A_left", Dtool_WrapValue(TextProperties::A_left));
    PyDict_SetItemString(dict, "ALeft", Dtool_WrapValue(TextProperties::A_left));
    PyDict_SetItemString(dict, "A_right", Dtool_WrapValue(TextProperties::A_right));
    PyDict_SetItemString(dict, "ARight", Dtool_WrapValue(TextProperties::A_right));
    PyDict_SetItemString(dict, "A_center", Dtool_WrapValue(TextProperties::A_center));
    PyDict_SetItemString(dict, "ACenter", Dtool_WrapValue(TextProperties::A_center));
    PyDict_SetItemString(dict, "A_boxed_left", Dtool_WrapValue(TextProperties::A_boxed_left));
    PyDict_SetItemString(dict, "ABoxedLeft", Dtool_WrapValue(TextProperties::A_boxed_left));
    PyDict_SetItemString(dict, "A_boxed_right", Dtool_WrapValue(TextProperties::A_boxed_right));
    PyDict_SetItemString(dict, "ABoxedRight", Dtool_WrapValue(TextProperties::A_boxed_right));
    PyDict_SetItemString(dict, "A_boxed_center", Dtool_WrapValue(TextProperties::A_boxed_center));
    PyDict_SetItemString(dict, "ABoxedCenter", Dtool_WrapValue(TextProperties::A_boxed_center));
    // enum TextProperties::Direction;
    PyDict_SetItemString(dict, "D_ltr", Dtool_WrapValue(TextProperties::D_ltr));
    PyDict_SetItemString(dict, "DLtr", Dtool_WrapValue(TextProperties::D_ltr));
    PyDict_SetItemString(dict, "D_rtl", Dtool_WrapValue(TextProperties::D_rtl));
    PyDict_SetItemString(dict, "DRtl", Dtool_WrapValue(TextProperties::D_rtl));
    if (PyType_Ready((PyTypeObject *)&Dtool_TextProperties) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextProperties)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextProperties);
  }
}

/**
 * Python method tables for TextGraphic (TextGraphic)
 */
static PyMethodDef Dtool_Methods_TextGraphic[] = {
  {"get_model", &Dtool_TextGraphic_get_model_285, METH_NOARGS, (const char *)Dtool_TextGraphic_get_model_285_comment},
  {"getModel", &Dtool_TextGraphic_get_model_285, METH_NOARGS, (const char *)Dtool_TextGraphic_get_model_285_comment},
  {"set_model", &Dtool_TextGraphic_set_model_286, METH_O, (const char *)Dtool_TextGraphic_set_model_286_comment},
  {"setModel", &Dtool_TextGraphic_set_model_286, METH_O, (const char *)Dtool_TextGraphic_set_model_286_comment},
  {"get_frame", &Dtool_TextGraphic_get_frame_289, METH_NOARGS, (const char *)Dtool_TextGraphic_get_frame_289_comment},
  {"getFrame", &Dtool_TextGraphic_get_frame_289, METH_NOARGS, (const char *)Dtool_TextGraphic_get_frame_289_comment},
  {"set_frame", (PyCFunction) &Dtool_TextGraphic_set_frame_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextGraphic_set_frame_290_comment},
  {"setFrame", (PyCFunction) &Dtool_TextGraphic_set_frame_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextGraphic_set_frame_290_comment},
  {"get_instance_flag", &Dtool_TextGraphic_get_instance_flag_293, METH_NOARGS, (const char *)Dtool_TextGraphic_get_instance_flag_293_comment},
  {"getInstanceFlag", &Dtool_TextGraphic_get_instance_flag_293, METH_NOARGS, (const char *)Dtool_TextGraphic_get_instance_flag_293_comment},
  {"set_instance_flag", &Dtool_TextGraphic_set_instance_flag_294, METH_O, (const char *)Dtool_TextGraphic_set_instance_flag_294_comment},
  {"setInstanceFlag", &Dtool_TextGraphic_set_instance_flag_294, METH_O, (const char *)Dtool_TextGraphic_set_instance_flag_294_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_TextGraphic[] = {
  {(char *)"model", &Dtool_TextGraphic_model_Getter, &Dtool_TextGraphic_model_Setter, nullptr, nullptr},
  {(char *)"frame", &Dtool_TextGraphic_frame_Getter, &Dtool_TextGraphic_frame_Setter, nullptr, nullptr},
  {(char *)"instance_flag", &Dtool_TextGraphic_instance_flag_Getter, &Dtool_TextGraphic_instance_flag_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TextGraphic = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TextGraphic = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextGraphic",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextGraphic,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextGraphic,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines a special model that has been constructed for the purposes of\n"
    " * embedding an arbitrary graphic image within a text paragraph.\n"
    " *\n"
    " * It can be any arbitrary model, though it should be built along the same\n"
    " * scale as the text, and it should probably be at least mostly two-\n"
    " * dimensional.  Typically, this means it should be constructed in the X-Z\n"
    " * plane, and it should have a maximum vertical (Z) height of 1.0.\n"
    " *\n"
    " * The frame specifies an arbitrary bounding volume in the form (left, right,\n"
    " * bottom, top).  This indicates the amount of space that will be reserved\n"
    " * within the paragraph.  The actual model is not actually required to fit\n"
    " * within this rectangle, but if it does not, it may visually overlap with\n"
    " * nearby text.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextGraphic,
    nullptr, // tp_members
    Dtool_Properties_TextGraphic,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextGraphic,
    PyType_GenericAlloc,
    Dtool_new_TextGraphic,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextGraphic,
  Dtool_UpcastInterface_TextGraphic,
  Dtool_DowncastInterface_TextGraphic,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextGraphic(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextGraphic._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextGraphic._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextGraphic) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextGraphic)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextGraphic);
  }
}

/**
 * Python method tables for TextPropertiesManager (TextPropertiesManager)
 */
static PyMethodDef Dtool_Methods_TextPropertiesManager[] = {
  {"set_properties", (PyCFunction) &Dtool_TextPropertiesManager_set_properties_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextPropertiesManager_set_properties_298_comment},
  {"setProperties", (PyCFunction) &Dtool_TextPropertiesManager_set_properties_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextPropertiesManager_set_properties_298_comment},
  {"get_properties", &Dtool_TextPropertiesManager_get_properties_299, METH_O, (const char *)Dtool_TextPropertiesManager_get_properties_299_comment},
  {"getProperties", &Dtool_TextPropertiesManager_get_properties_299, METH_O, (const char *)Dtool_TextPropertiesManager_get_properties_299_comment},
  {"has_properties", &Dtool_TextPropertiesManager_has_properties_300, METH_O, (const char *)Dtool_TextPropertiesManager_has_properties_300_comment},
  {"hasProperties", &Dtool_TextPropertiesManager_has_properties_300, METH_O, (const char *)Dtool_TextPropertiesManager_has_properties_300_comment},
  {"clear_properties", &Dtool_TextPropertiesManager_clear_properties_301, METH_O, (const char *)Dtool_TextPropertiesManager_clear_properties_301_comment},
  {"clearProperties", &Dtool_TextPropertiesManager_clear_properties_301, METH_O, (const char *)Dtool_TextPropertiesManager_clear_properties_301_comment},
  {"set_graphic", (PyCFunction) &Dtool_TextPropertiesManager_set_graphic_302, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextPropertiesManager_set_graphic_302_comment},
  {"setGraphic", (PyCFunction) &Dtool_TextPropertiesManager_set_graphic_302, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextPropertiesManager_set_graphic_302_comment},
  {"get_graphic", &Dtool_TextPropertiesManager_get_graphic_303, METH_O, (const char *)Dtool_TextPropertiesManager_get_graphic_303_comment},
  {"getGraphic", &Dtool_TextPropertiesManager_get_graphic_303, METH_O, (const char *)Dtool_TextPropertiesManager_get_graphic_303_comment},
  {"has_graphic", &Dtool_TextPropertiesManager_has_graphic_304, METH_O, (const char *)Dtool_TextPropertiesManager_has_graphic_304_comment},
  {"hasGraphic", &Dtool_TextPropertiesManager_has_graphic_304, METH_O, (const char *)Dtool_TextPropertiesManager_has_graphic_304_comment},
  {"clear_graphic", &Dtool_TextPropertiesManager_clear_graphic_305, METH_O, (const char *)Dtool_TextPropertiesManager_clear_graphic_305_comment},
  {"clearGraphic", &Dtool_TextPropertiesManager_clear_graphic_305, METH_O, (const char *)Dtool_TextPropertiesManager_clear_graphic_305_comment},
  {"write", (PyCFunction) &Dtool_TextPropertiesManager_write_306, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextPropertiesManager_write_306_comment},
  {"get_global_ptr", &Dtool_TextPropertiesManager_get_global_ptr_307, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextPropertiesManager_get_global_ptr_307_comment},
  {"getGlobalPtr", &Dtool_TextPropertiesManager_get_global_ptr_307, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextPropertiesManager_get_global_ptr_307_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     TextPropertiesManager
//////////////////
static PyObject *Dtool_Str_TextPropertiesManager(PyObject *self) {
  TextPropertiesManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextPropertiesManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_TextPropertiesManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TextPropertiesManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextPropertiesManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextPropertiesManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextPropertiesManager,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_TextPropertiesManager,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines all of the TextProperties structures that might be referenced\n"
    " * by name from an embedded text string.\n"
    " *\n"
    " * A text string, as rendered by a TextNode, can contain embedded references\n"
    " * to one of the TextProperties defined here, by enclosing the name between \\1\n"
    " * (ASCII 0x01) characters; this causes a \"push\" to the named state.  All text\n"
    " * following the closing \\1 character will then be rendered in the new state.\n"
    " * The next \\2 (ASCII 0x02) character will then restore the previous state for\n"
    " * subsequent text.\n"
    " *\n"
    " * For instance, \"x\\1up\\1n\\2 + y\" indicates that the character \"x\" will be\n"
    " * rendered in the normal state, the character \"n\" will be rendered in the\n"
    " * \"up\" state, and then \" + y\" will be rendered in the normal state again.\n"
    " *\n"
    " * This can also be used to define arbitrary models that can serve as embedded\n"
    " * graphic images in a text paragraph.  This works similarly; the convention\n"
    " * is to create a TextGraphic that describes the graphic image, and then\n"
    " * associate it here via the set_graphic() call.  Then \"\\5name\\5\" will embed\n"
    " * the named graphic.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextPropertiesManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextPropertiesManager,
    PyType_GenericAlloc,
    Dtool_new_TextPropertiesManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextPropertiesManager,
  Dtool_UpcastInterface_TextPropertiesManager,
  Dtool_DowncastInterface_TextPropertiesManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextPropertiesManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextPropertiesManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextPropertiesManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextPropertiesManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextPropertiesManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextPropertiesManager);
  }
}

/**
 * Python method tables for TextAssembler (TextAssembler)
 */
static PyMethodDef Dtool_Methods_TextAssembler[] = {
  {"assign", &Dtool_TextAssembler_operator_310, METH_O, (const char *)Dtool_TextAssembler_operator_310_comment},
  {"clear", &Dtool_TextAssembler_clear_312, METH_NOARGS, (const char *)Dtool_TextAssembler_clear_312_comment},
  {"set_usage_hint", &Dtool_TextAssembler_set_usage_hint_313, METH_O, (const char *)Dtool_TextAssembler_set_usage_hint_313_comment},
  {"setUsageHint", &Dtool_TextAssembler_set_usage_hint_313, METH_O, (const char *)Dtool_TextAssembler_set_usage_hint_313_comment},
  {"get_usage_hint", &Dtool_TextAssembler_get_usage_hint_314, METH_NOARGS, (const char *)Dtool_TextAssembler_get_usage_hint_314_comment},
  {"getUsageHint", &Dtool_TextAssembler_get_usage_hint_314, METH_NOARGS, (const char *)Dtool_TextAssembler_get_usage_hint_314_comment},
  {"set_max_rows", &Dtool_TextAssembler_set_max_rows_315, METH_O, (const char *)Dtool_TextAssembler_set_max_rows_315_comment},
  {"setMaxRows", &Dtool_TextAssembler_set_max_rows_315, METH_O, (const char *)Dtool_TextAssembler_set_max_rows_315_comment},
  {"get_max_rows", &Dtool_TextAssembler_get_max_rows_316, METH_NOARGS, (const char *)Dtool_TextAssembler_get_max_rows_316_comment},
  {"getMaxRows", &Dtool_TextAssembler_get_max_rows_316, METH_NOARGS, (const char *)Dtool_TextAssembler_get_max_rows_316_comment},
  {"set_dynamic_merge", &Dtool_TextAssembler_set_dynamic_merge_317, METH_O, (const char *)Dtool_TextAssembler_set_dynamic_merge_317_comment},
  {"setDynamicMerge", &Dtool_TextAssembler_set_dynamic_merge_317, METH_O, (const char *)Dtool_TextAssembler_set_dynamic_merge_317_comment},
  {"get_dynamic_merge", &Dtool_TextAssembler_get_dynamic_merge_318, METH_NOARGS, (const char *)Dtool_TextAssembler_get_dynamic_merge_318_comment},
  {"getDynamicMerge", &Dtool_TextAssembler_get_dynamic_merge_318, METH_NOARGS, (const char *)Dtool_TextAssembler_get_dynamic_merge_318_comment},
  {"set_multiline_mode", &Dtool_TextAssembler_set_multiline_mode_319, METH_O, (const char *)Dtool_TextAssembler_set_multiline_mode_319_comment},
  {"setMultilineMode", &Dtool_TextAssembler_set_multiline_mode_319, METH_O, (const char *)Dtool_TextAssembler_set_multiline_mode_319_comment},
  {"get_multiline_mode", &Dtool_TextAssembler_get_multiline_mode_320, METH_NOARGS, (const char *)Dtool_TextAssembler_get_multiline_mode_320_comment},
  {"getMultilineMode", &Dtool_TextAssembler_get_multiline_mode_320, METH_NOARGS, (const char *)Dtool_TextAssembler_get_multiline_mode_320_comment},
  {"set_properties", &Dtool_TextAssembler_set_properties_321, METH_O, (const char *)Dtool_TextAssembler_set_properties_321_comment},
  {"setProperties", &Dtool_TextAssembler_set_properties_321, METH_O, (const char *)Dtool_TextAssembler_set_properties_321_comment},
  {"get_properties", (PyCFunction) &Dtool_TextAssembler_get_properties_322, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_properties_322_comment},
  {"getProperties", (PyCFunction) &Dtool_TextAssembler_get_properties_322, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_properties_322_comment},
  {"set_wtext", &Dtool_TextAssembler_set_wtext_323, METH_O, (const char *)Dtool_TextAssembler_set_wtext_323_comment},
  {"setWtext", &Dtool_TextAssembler_set_wtext_323, METH_O, (const char *)Dtool_TextAssembler_set_wtext_323_comment},
  {"set_wsubstr", (PyCFunction) &Dtool_TextAssembler_set_wsubstr_324, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_set_wsubstr_324_comment},
  {"setWsubstr", (PyCFunction) &Dtool_TextAssembler_set_wsubstr_324, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_set_wsubstr_324_comment},
  {"get_plain_wtext", &Dtool_TextAssembler_get_plain_wtext_325, METH_NOARGS, (const char *)Dtool_TextAssembler_get_plain_wtext_325_comment},
  {"getPlainWtext", &Dtool_TextAssembler_get_plain_wtext_325, METH_NOARGS, (const char *)Dtool_TextAssembler_get_plain_wtext_325_comment},
  {"get_wordwrapped_plain_wtext", &Dtool_TextAssembler_get_wordwrapped_plain_wtext_326, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wordwrapped_plain_wtext_326_comment},
  {"getWordwrappedPlainWtext", &Dtool_TextAssembler_get_wordwrapped_plain_wtext_326, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wordwrapped_plain_wtext_326_comment},
  {"get_wtext", &Dtool_TextAssembler_get_wtext_327, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wtext_327_comment},
  {"getWtext", &Dtool_TextAssembler_get_wtext_327, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wtext_327_comment},
  {"get_wordwrapped_wtext", &Dtool_TextAssembler_get_wordwrapped_wtext_328, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wordwrapped_wtext_328_comment},
  {"getWordwrappedWtext", &Dtool_TextAssembler_get_wordwrapped_wtext_328, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wordwrapped_wtext_328_comment},
  {"calc_r", &Dtool_TextAssembler_calc_r_330, METH_O, (const char *)Dtool_TextAssembler_calc_r_330_comment},
  {"calcR", &Dtool_TextAssembler_calc_r_330, METH_O, (const char *)Dtool_TextAssembler_calc_r_330_comment},
  {"calc_c", &Dtool_TextAssembler_calc_c_331, METH_O, (const char *)Dtool_TextAssembler_calc_c_331_comment},
  {"calcC", &Dtool_TextAssembler_calc_c_331, METH_O, (const char *)Dtool_TextAssembler_calc_c_331_comment},
  {"calc_index", (PyCFunction) &Dtool_TextAssembler_calc_index_332, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_calc_index_332_comment},
  {"calcIndex", (PyCFunction) &Dtool_TextAssembler_calc_index_332, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_calc_index_332_comment},
  {"get_num_characters", &Dtool_TextAssembler_get_num_characters_333, METH_NOARGS, (const char *)Dtool_TextAssembler_get_num_characters_333_comment},
  {"getNumCharacters", &Dtool_TextAssembler_get_num_characters_333, METH_NOARGS, (const char *)Dtool_TextAssembler_get_num_characters_333_comment},
  {"get_character", (PyCFunction) &Dtool_TextAssembler_get_character_334, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_character_334_comment},
  {"getCharacter", (PyCFunction) &Dtool_TextAssembler_get_character_334, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_character_334_comment},
  {"get_graphic", (PyCFunction) &Dtool_TextAssembler_get_graphic_335, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_graphic_335_comment},
  {"getGraphic", (PyCFunction) &Dtool_TextAssembler_get_graphic_335, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_graphic_335_comment},
  {"get_width", (PyCFunction) &Dtool_TextAssembler_get_width_336, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_width_336_comment},
  {"getWidth", (PyCFunction) &Dtool_TextAssembler_get_width_336, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_width_336_comment},
  {"get_num_rows", &Dtool_TextAssembler_get_num_rows_337, METH_NOARGS, (const char *)Dtool_TextAssembler_get_num_rows_337_comment},
  {"getNumRows", &Dtool_TextAssembler_get_num_rows_337, METH_NOARGS, (const char *)Dtool_TextAssembler_get_num_rows_337_comment},
  {"get_num_cols", &Dtool_TextAssembler_get_num_cols_338, METH_O, (const char *)Dtool_TextAssembler_get_num_cols_338_comment},
  {"getNumCols", &Dtool_TextAssembler_get_num_cols_338, METH_O, (const char *)Dtool_TextAssembler_get_num_cols_338_comment},
  {"get_xpos", (PyCFunction) &Dtool_TextAssembler_get_xpos_339, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_xpos_339_comment},
  {"getXpos", (PyCFunction) &Dtool_TextAssembler_get_xpos_339, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_xpos_339_comment},
  {"get_ypos", (PyCFunction) &Dtool_TextAssembler_get_ypos_340, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_ypos_340_comment},
  {"getYpos", (PyCFunction) &Dtool_TextAssembler_get_ypos_340, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_ypos_340_comment},
  {"assemble_text", &Dtool_TextAssembler_assemble_text_341, METH_NOARGS, (const char *)Dtool_TextAssembler_assemble_text_341_comment},
  {"assembleText", &Dtool_TextAssembler_assemble_text_341, METH_NOARGS, (const char *)Dtool_TextAssembler_assemble_text_341_comment},
  {"get_ul", &Dtool_TextAssembler_get_ul_342, METH_NOARGS, (const char *)Dtool_TextAssembler_get_ul_342_comment},
  {"getUl", &Dtool_TextAssembler_get_ul_342, METH_NOARGS, (const char *)Dtool_TextAssembler_get_ul_342_comment},
  {"get_lr", &Dtool_TextAssembler_get_lr_343, METH_NOARGS, (const char *)Dtool_TextAssembler_get_lr_343_comment},
  {"getLr", &Dtool_TextAssembler_get_lr_343, METH_NOARGS, (const char *)Dtool_TextAssembler_get_lr_343_comment},
  {"calc_width", (PyCFunction) &Dtool_TextAssembler_calc_width_344, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_calc_width_344_comment},
  {"calcWidth", (PyCFunction) &Dtool_TextAssembler_calc_width_344, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_calc_width_344_comment},
  {"has_exact_character", (PyCFunction) &Dtool_TextAssembler_has_exact_character_345, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_has_exact_character_345_comment},
  {"hasExactCharacter", (PyCFunction) &Dtool_TextAssembler_has_exact_character_345, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_has_exact_character_345_comment},
  {"has_character", (PyCFunction) &Dtool_TextAssembler_has_character_346, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_has_character_346_comment},
  {"hasCharacter", (PyCFunction) &Dtool_TextAssembler_has_character_346, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_has_character_346_comment},
  {"is_whitespace", (PyCFunction) &Dtool_TextAssembler_is_whitespace_347, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_is_whitespace_347_comment},
  {"isWhitespace", (PyCFunction) &Dtool_TextAssembler_is_whitespace_347, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_is_whitespace_347_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_TextAssembler[] = {
  {(char *)"usage_hint", &Dtool_TextAssembler_usage_hint_Getter, &Dtool_TextAssembler_usage_hint_Setter, nullptr, nullptr},
  {(char *)"max_rows", &Dtool_TextAssembler_max_rows_Getter, &Dtool_TextAssembler_max_rows_Setter, nullptr, nullptr},
  {(char *)"dynamic_merge", &Dtool_TextAssembler_dynamic_merge_Getter, &Dtool_TextAssembler_dynamic_merge_Setter, nullptr, nullptr},
  {(char *)"multiline_mode", &Dtool_TextAssembler_multiline_mode_Getter, &Dtool_TextAssembler_multiline_mode_Setter, nullptr, nullptr},
  {(char *)"properties", &Dtool_TextAssembler_properties_Getter, &Dtool_TextAssembler_properties_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TextAssembler = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TextAssembler = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextAssembler",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextAssembler,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextAssembler,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is not normally used directly by user code, but is used by the\n"
    " * TextNode to lay out a block of text and convert it into rows of Geoms\n"
    " * according to the TextProperties.  However, user code may take advantage of\n"
    " * it, if desired, for very low-level text operations.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextAssembler,
    nullptr, // tp_members
    Dtool_Properties_TextAssembler,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextAssembler,
    PyType_GenericAlloc,
    Dtool_new_TextAssembler,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextAssembler,
  Dtool_UpcastInterface_TextAssembler,
  Dtool_DowncastInterface_TextAssembler,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextAssembler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextAssembler._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextAssembler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextAssembler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextAssembler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextAssembler);
  }
}

/**
 * Python method tables for TextNode (TextNode)
 */
static PyMethodDef Dtool_Methods_TextNode[] = {
  {"get_line_height", &Dtool_TextNode_get_line_height_368, METH_NOARGS, (const char *)Dtool_TextNode_get_line_height_368_comment},
  {"getLineHeight", &Dtool_TextNode_get_line_height_368, METH_NOARGS, (const char *)Dtool_TextNode_get_line_height_368_comment},
  {"set_max_rows", &Dtool_TextNode_set_max_rows_369, METH_O, (const char *)Dtool_TextNode_set_max_rows_369_comment},
  {"setMaxRows", &Dtool_TextNode_set_max_rows_369, METH_O, (const char *)Dtool_TextNode_set_max_rows_369_comment},
  {"clear_max_rows", &Dtool_TextNode_clear_max_rows_370, METH_NOARGS, (const char *)Dtool_TextNode_clear_max_rows_370_comment},
  {"clearMaxRows", &Dtool_TextNode_clear_max_rows_370, METH_NOARGS, (const char *)Dtool_TextNode_clear_max_rows_370_comment},
  {"has_max_rows", &Dtool_TextNode_has_max_rows_371, METH_NOARGS, (const char *)Dtool_TextNode_has_max_rows_371_comment},
  {"hasMaxRows", &Dtool_TextNode_has_max_rows_371, METH_NOARGS, (const char *)Dtool_TextNode_has_max_rows_371_comment},
  {"get_max_rows", &Dtool_TextNode_get_max_rows_372, METH_NOARGS, (const char *)Dtool_TextNode_get_max_rows_372_comment},
  {"getMaxRows", &Dtool_TextNode_get_max_rows_372, METH_NOARGS, (const char *)Dtool_TextNode_get_max_rows_372_comment},
  {"has_overflow", &Dtool_TextNode_has_overflow_373, METH_NOARGS, (const char *)Dtool_TextNode_has_overflow_373_comment},
  {"hasOverflow", &Dtool_TextNode_has_overflow_373, METH_NOARGS, (const char *)Dtool_TextNode_has_overflow_373_comment},
  {"set_frame_color", (PyCFunction) &Dtool_TextNode_set_frame_color_374, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_color_374_comment},
  {"setFrameColor", (PyCFunction) &Dtool_TextNode_set_frame_color_374, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_color_374_comment},
  {"get_frame_color", &Dtool_TextNode_get_frame_color_375, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_color_375_comment},
  {"getFrameColor", &Dtool_TextNode_get_frame_color_375, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_color_375_comment},
  {"set_card_border", (PyCFunction) &Dtool_TextNode_set_card_border_376, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_border_376_comment},
  {"setCardBorder", (PyCFunction) &Dtool_TextNode_set_card_border_376, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_border_376_comment},
  {"clear_card_border", &Dtool_TextNode_clear_card_border_377, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_border_377_comment},
  {"clearCardBorder", &Dtool_TextNode_clear_card_border_377, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_border_377_comment},
  {"get_card_border_size", &Dtool_TextNode_get_card_border_size_378, METH_NOARGS, (const char *)Dtool_TextNode_get_card_border_size_378_comment},
  {"getCardBorderSize", &Dtool_TextNode_get_card_border_size_378, METH_NOARGS, (const char *)Dtool_TextNode_get_card_border_size_378_comment},
  {"get_card_border_uv_portion", &Dtool_TextNode_get_card_border_uv_portion_379, METH_NOARGS, (const char *)Dtool_TextNode_get_card_border_uv_portion_379_comment},
  {"getCardBorderUvPortion", &Dtool_TextNode_get_card_border_uv_portion_379, METH_NOARGS, (const char *)Dtool_TextNode_get_card_border_uv_portion_379_comment},
  {"has_card_border", &Dtool_TextNode_has_card_border_380, METH_NOARGS, (const char *)Dtool_TextNode_has_card_border_380_comment},
  {"hasCardBorder", &Dtool_TextNode_has_card_border_380, METH_NOARGS, (const char *)Dtool_TextNode_has_card_border_380_comment},
  {"set_card_color", (PyCFunction) &Dtool_TextNode_set_card_color_381, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_color_381_comment},
  {"setCardColor", (PyCFunction) &Dtool_TextNode_set_card_color_381, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_color_381_comment},
  {"get_card_color", &Dtool_TextNode_get_card_color_382, METH_NOARGS, (const char *)Dtool_TextNode_get_card_color_382_comment},
  {"getCardColor", &Dtool_TextNode_get_card_color_382, METH_NOARGS, (const char *)Dtool_TextNode_get_card_color_382_comment},
  {"set_card_texture", &Dtool_TextNode_set_card_texture_383, METH_O, (const char *)Dtool_TextNode_set_card_texture_383_comment},
  {"setCardTexture", &Dtool_TextNode_set_card_texture_383, METH_O, (const char *)Dtool_TextNode_set_card_texture_383_comment},
  {"clear_card_texture", &Dtool_TextNode_clear_card_texture_384, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_texture_384_comment},
  {"clearCardTexture", &Dtool_TextNode_clear_card_texture_384, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_texture_384_comment},
  {"has_card_texture", &Dtool_TextNode_has_card_texture_385, METH_NOARGS, (const char *)Dtool_TextNode_has_card_texture_385_comment},
  {"hasCardTexture", &Dtool_TextNode_has_card_texture_385, METH_NOARGS, (const char *)Dtool_TextNode_has_card_texture_385_comment},
  {"get_card_texture", &Dtool_TextNode_get_card_texture_386, METH_NOARGS, (const char *)Dtool_TextNode_get_card_texture_386_comment},
  {"getCardTexture", &Dtool_TextNode_get_card_texture_386, METH_NOARGS, (const char *)Dtool_TextNode_get_card_texture_386_comment},
  {"set_frame_as_margin", (PyCFunction) &Dtool_TextNode_set_frame_as_margin_387, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_as_margin_387_comment},
  {"setFrameAsMargin", (PyCFunction) &Dtool_TextNode_set_frame_as_margin_387, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_as_margin_387_comment},
  {"set_frame_actual", (PyCFunction) &Dtool_TextNode_set_frame_actual_388, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_actual_388_comment},
  {"setFrameActual", (PyCFunction) &Dtool_TextNode_set_frame_actual_388, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_actual_388_comment},
  {"clear_frame", &Dtool_TextNode_clear_frame_389, METH_NOARGS, (const char *)Dtool_TextNode_clear_frame_389_comment},
  {"clearFrame", &Dtool_TextNode_clear_frame_389, METH_NOARGS, (const char *)Dtool_TextNode_clear_frame_389_comment},
  {"has_frame", &Dtool_TextNode_has_frame_390, METH_NOARGS, (const char *)Dtool_TextNode_has_frame_390_comment},
  {"hasFrame", &Dtool_TextNode_has_frame_390, METH_NOARGS, (const char *)Dtool_TextNode_has_frame_390_comment},
  {"is_frame_as_margin", &Dtool_TextNode_is_frame_as_margin_391, METH_NOARGS, (const char *)Dtool_TextNode_is_frame_as_margin_391_comment},
  {"isFrameAsMargin", &Dtool_TextNode_is_frame_as_margin_391, METH_NOARGS, (const char *)Dtool_TextNode_is_frame_as_margin_391_comment},
  {"get_frame_as_set", &Dtool_TextNode_get_frame_as_set_392, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_as_set_392_comment},
  {"getFrameAsSet", &Dtool_TextNode_get_frame_as_set_392, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_as_set_392_comment},
  {"get_frame_actual", &Dtool_TextNode_get_frame_actual_393, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_actual_393_comment},
  {"getFrameActual", &Dtool_TextNode_get_frame_actual_393, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_actual_393_comment},
  {"set_frame_line_width", &Dtool_TextNode_set_frame_line_width_394, METH_O, (const char *)Dtool_TextNode_set_frame_line_width_394_comment},
  {"setFrameLineWidth", &Dtool_TextNode_set_frame_line_width_394, METH_O, (const char *)Dtool_TextNode_set_frame_line_width_394_comment},
  {"get_frame_line_width", &Dtool_TextNode_get_frame_line_width_395, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_line_width_395_comment},
  {"getFrameLineWidth", &Dtool_TextNode_get_frame_line_width_395, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_line_width_395_comment},
  {"set_frame_corners", &Dtool_TextNode_set_frame_corners_396, METH_O, (const char *)Dtool_TextNode_set_frame_corners_396_comment},
  {"setFrameCorners", &Dtool_TextNode_set_frame_corners_396, METH_O, (const char *)Dtool_TextNode_set_frame_corners_396_comment},
  {"get_frame_corners", &Dtool_TextNode_get_frame_corners_397, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_corners_397_comment},
  {"getFrameCorners", &Dtool_TextNode_get_frame_corners_397, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_corners_397_comment},
  {"set_card_as_margin", (PyCFunction) &Dtool_TextNode_set_card_as_margin_398, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_as_margin_398_comment},
  {"setCardAsMargin", (PyCFunction) &Dtool_TextNode_set_card_as_margin_398, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_as_margin_398_comment},
  {"set_card_actual", (PyCFunction) &Dtool_TextNode_set_card_actual_399, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_actual_399_comment},
  {"setCardActual", (PyCFunction) &Dtool_TextNode_set_card_actual_399, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_actual_399_comment},
  {"set_card_decal", &Dtool_TextNode_set_card_decal_400, METH_O, (const char *)Dtool_TextNode_set_card_decal_400_comment},
  {"setCardDecal", &Dtool_TextNode_set_card_decal_400, METH_O, (const char *)Dtool_TextNode_set_card_decal_400_comment},
  {"clear_card", &Dtool_TextNode_clear_card_401, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_401_comment},
  {"clearCard", &Dtool_TextNode_clear_card_401, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_401_comment},
  {"has_card", &Dtool_TextNode_has_card_402, METH_NOARGS, (const char *)Dtool_TextNode_has_card_402_comment},
  {"hasCard", &Dtool_TextNode_has_card_402, METH_NOARGS, (const char *)Dtool_TextNode_has_card_402_comment},
  {"get_card_decal", &Dtool_TextNode_get_card_decal_403, METH_NOARGS, (const char *)Dtool_TextNode_get_card_decal_403_comment},
  {"getCardDecal", &Dtool_TextNode_get_card_decal_403, METH_NOARGS, (const char *)Dtool_TextNode_get_card_decal_403_comment},
  {"is_card_as_margin", &Dtool_TextNode_is_card_as_margin_404, METH_NOARGS, (const char *)Dtool_TextNode_is_card_as_margin_404_comment},
  {"isCardAsMargin", &Dtool_TextNode_is_card_as_margin_404, METH_NOARGS, (const char *)Dtool_TextNode_is_card_as_margin_404_comment},
  {"get_card_as_set", &Dtool_TextNode_get_card_as_set_405, METH_NOARGS, (const char *)Dtool_TextNode_get_card_as_set_405_comment},
  {"getCardAsSet", &Dtool_TextNode_get_card_as_set_405, METH_NOARGS, (const char *)Dtool_TextNode_get_card_as_set_405_comment},
  {"get_card_actual", &Dtool_TextNode_get_card_actual_406, METH_NOARGS, (const char *)Dtool_TextNode_get_card_actual_406_comment},
  {"getCardActual", &Dtool_TextNode_get_card_actual_406, METH_NOARGS, (const char *)Dtool_TextNode_get_card_actual_406_comment},
  {"get_card_transformed", &Dtool_TextNode_get_card_transformed_407, METH_NOARGS, (const char *)Dtool_TextNode_get_card_transformed_407_comment},
  {"getCardTransformed", &Dtool_TextNode_get_card_transformed_407, METH_NOARGS, (const char *)Dtool_TextNode_get_card_transformed_407_comment},
  {"set_transform", &Dtool_TextNode_set_transform_408, METH_O, (const char *)Dtool_TextNode_set_transform_408_comment},
  {"setTransform", &Dtool_TextNode_set_transform_408, METH_O, (const char *)Dtool_TextNode_set_transform_408_comment},
  {"get_transform", &Dtool_TextNode_get_transform_409, METH_NOARGS, (const char *)Dtool_TextNode_get_transform_409_comment},
  {"getTransform", &Dtool_TextNode_get_transform_409, METH_NOARGS, (const char *)Dtool_TextNode_get_transform_409_comment},
  {"set_coordinate_system", &Dtool_TextNode_set_coordinate_system_410, METH_O, (const char *)Dtool_TextNode_set_coordinate_system_410_comment},
  {"setCoordinateSystem", &Dtool_TextNode_set_coordinate_system_410, METH_O, (const char *)Dtool_TextNode_set_coordinate_system_410_comment},
  {"get_coordinate_system", &Dtool_TextNode_get_coordinate_system_411, METH_NOARGS, (const char *)Dtool_TextNode_get_coordinate_system_411_comment},
  {"getCoordinateSystem", &Dtool_TextNode_get_coordinate_system_411, METH_NOARGS, (const char *)Dtool_TextNode_get_coordinate_system_411_comment},
  {"set_usage_hint", &Dtool_TextNode_set_usage_hint_412, METH_O, (const char *)Dtool_TextNode_set_usage_hint_412_comment},
  {"setUsageHint", &Dtool_TextNode_set_usage_hint_412, METH_O, (const char *)Dtool_TextNode_set_usage_hint_412_comment},
  {"get_usage_hint", &Dtool_TextNode_get_usage_hint_413, METH_NOARGS, (const char *)Dtool_TextNode_get_usage_hint_413_comment},
  {"getUsageHint", &Dtool_TextNode_get_usage_hint_413, METH_NOARGS, (const char *)Dtool_TextNode_get_usage_hint_413_comment},
  {"set_flatten_flags", &Dtool_TextNode_set_flatten_flags_414, METH_O, (const char *)Dtool_TextNode_set_flatten_flags_414_comment},
  {"setFlattenFlags", &Dtool_TextNode_set_flatten_flags_414, METH_O, (const char *)Dtool_TextNode_set_flatten_flags_414_comment},
  {"get_flatten_flags", &Dtool_TextNode_get_flatten_flags_415, METH_NOARGS, (const char *)Dtool_TextNode_get_flatten_flags_415_comment},
  {"getFlattenFlags", &Dtool_TextNode_get_flatten_flags_415, METH_NOARGS, (const char *)Dtool_TextNode_get_flatten_flags_415_comment},
  {"set_font", &Dtool_TextNode_set_font_416, METH_O, (const char *)Dtool_TextNode_set_font_416_comment},
  {"setFont", &Dtool_TextNode_set_font_416, METH_O, (const char *)Dtool_TextNode_set_font_416_comment},
  {"clear_font", &Dtool_TextNode_clear_font_417, METH_NOARGS, (const char *)Dtool_TextNode_clear_font_417_comment},
  {"clearFont", &Dtool_TextNode_clear_font_417, METH_NOARGS, (const char *)Dtool_TextNode_clear_font_417_comment},
  {"set_small_caps", &Dtool_TextNode_set_small_caps_418, METH_O, (const char *)Dtool_TextNode_set_small_caps_418_comment},
  {"setSmallCaps", &Dtool_TextNode_set_small_caps_418, METH_O, (const char *)Dtool_TextNode_set_small_caps_418_comment},
  {"clear_small_caps", &Dtool_TextNode_clear_small_caps_419, METH_NOARGS, (const char *)Dtool_TextNode_clear_small_caps_419_comment},
  {"clearSmallCaps", &Dtool_TextNode_clear_small_caps_419, METH_NOARGS, (const char *)Dtool_TextNode_clear_small_caps_419_comment},
  {"set_small_caps_scale", &Dtool_TextNode_set_small_caps_scale_420, METH_O, (const char *)Dtool_TextNode_set_small_caps_scale_420_comment},
  {"setSmallCapsScale", &Dtool_TextNode_set_small_caps_scale_420, METH_O, (const char *)Dtool_TextNode_set_small_caps_scale_420_comment},
  {"clear_small_caps_scale", &Dtool_TextNode_clear_small_caps_scale_421, METH_NOARGS, (const char *)Dtool_TextNode_clear_small_caps_scale_421_comment},
  {"clearSmallCapsScale", &Dtool_TextNode_clear_small_caps_scale_421, METH_NOARGS, (const char *)Dtool_TextNode_clear_small_caps_scale_421_comment},
  {"set_slant", &Dtool_TextNode_set_slant_422, METH_O, (const char *)Dtool_TextNode_set_slant_422_comment},
  {"setSlant", &Dtool_TextNode_set_slant_422, METH_O, (const char *)Dtool_TextNode_set_slant_422_comment},
  {"clear_slant", &Dtool_TextNode_clear_slant_423, METH_NOARGS, (const char *)Dtool_TextNode_clear_slant_423_comment},
  {"clearSlant", &Dtool_TextNode_clear_slant_423, METH_NOARGS, (const char *)Dtool_TextNode_clear_slant_423_comment},
  {"set_align", &Dtool_TextNode_set_align_424, METH_O, (const char *)Dtool_TextNode_set_align_424_comment},
  {"setAlign", &Dtool_TextNode_set_align_424, METH_O, (const char *)Dtool_TextNode_set_align_424_comment},
  {"clear_align", &Dtool_TextNode_clear_align_425, METH_NOARGS, (const char *)Dtool_TextNode_clear_align_425_comment},
  {"clearAlign", &Dtool_TextNode_clear_align_425, METH_NOARGS, (const char *)Dtool_TextNode_clear_align_425_comment},
  {"set_indent", &Dtool_TextNode_set_indent_426, METH_O, (const char *)Dtool_TextNode_set_indent_426_comment},
  {"setIndent", &Dtool_TextNode_set_indent_426, METH_O, (const char *)Dtool_TextNode_set_indent_426_comment},
  {"clear_indent", &Dtool_TextNode_clear_indent_427, METH_NOARGS, (const char *)Dtool_TextNode_clear_indent_427_comment},
  {"clearIndent", &Dtool_TextNode_clear_indent_427, METH_NOARGS, (const char *)Dtool_TextNode_clear_indent_427_comment},
  {"set_wordwrap", &Dtool_TextNode_set_wordwrap_428, METH_O, (const char *)Dtool_TextNode_set_wordwrap_428_comment},
  {"setWordwrap", &Dtool_TextNode_set_wordwrap_428, METH_O, (const char *)Dtool_TextNode_set_wordwrap_428_comment},
  {"clear_wordwrap", &Dtool_TextNode_clear_wordwrap_429, METH_NOARGS, (const char *)Dtool_TextNode_clear_wordwrap_429_comment},
  {"clearWordwrap", &Dtool_TextNode_clear_wordwrap_429, METH_NOARGS, (const char *)Dtool_TextNode_clear_wordwrap_429_comment},
  {"set_text_color", (PyCFunction) &Dtool_TextNode_set_text_color_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_text_color_430_comment},
  {"setTextColor", (PyCFunction) &Dtool_TextNode_set_text_color_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_text_color_430_comment},
  {"clear_text_color", &Dtool_TextNode_clear_text_color_431, METH_NOARGS, (const char *)Dtool_TextNode_clear_text_color_431_comment},
  {"clearTextColor", &Dtool_TextNode_clear_text_color_431, METH_NOARGS, (const char *)Dtool_TextNode_clear_text_color_431_comment},
  {"set_shadow_color", (PyCFunction) &Dtool_TextNode_set_shadow_color_432, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_shadow_color_432_comment},
  {"setShadowColor", (PyCFunction) &Dtool_TextNode_set_shadow_color_432, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_shadow_color_432_comment},
  {"clear_shadow_color", &Dtool_TextNode_clear_shadow_color_433, METH_NOARGS, (const char *)Dtool_TextNode_clear_shadow_color_433_comment},
  {"clearShadowColor", &Dtool_TextNode_clear_shadow_color_433, METH_NOARGS, (const char *)Dtool_TextNode_clear_shadow_color_433_comment},
  {"set_shadow", (PyCFunction) &Dtool_TextNode_set_shadow_434, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_shadow_434_comment},
  {"setShadow", (PyCFunction) &Dtool_TextNode_set_shadow_434, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_shadow_434_comment},
  {"clear_shadow", &Dtool_TextNode_clear_shadow_435, METH_NOARGS, (const char *)Dtool_TextNode_clear_shadow_435_comment},
  {"clearShadow", &Dtool_TextNode_clear_shadow_435, METH_NOARGS, (const char *)Dtool_TextNode_clear_shadow_435_comment},
  {"set_bin", &Dtool_TextNode_set_bin_436, METH_O, (const char *)Dtool_TextNode_set_bin_436_comment},
  {"setBin", &Dtool_TextNode_set_bin_436, METH_O, (const char *)Dtool_TextNode_set_bin_436_comment},
  {"clear_bin", &Dtool_TextNode_clear_bin_437, METH_NOARGS, (const char *)Dtool_TextNode_clear_bin_437_comment},
  {"clearBin", &Dtool_TextNode_clear_bin_437, METH_NOARGS, (const char *)Dtool_TextNode_clear_bin_437_comment},
  {"set_draw_order", &Dtool_TextNode_set_draw_order_438, METH_O, (const char *)Dtool_TextNode_set_draw_order_438_comment},
  {"setDrawOrder", &Dtool_TextNode_set_draw_order_438, METH_O, (const char *)Dtool_TextNode_set_draw_order_438_comment},
  {"clear_draw_order", &Dtool_TextNode_clear_draw_order_439, METH_NOARGS, (const char *)Dtool_TextNode_clear_draw_order_439_comment},
  {"clearDrawOrder", &Dtool_TextNode_clear_draw_order_439, METH_NOARGS, (const char *)Dtool_TextNode_clear_draw_order_439_comment},
  {"set_tab_width", &Dtool_TextNode_set_tab_width_440, METH_O, (const char *)Dtool_TextNode_set_tab_width_440_comment},
  {"setTabWidth", &Dtool_TextNode_set_tab_width_440, METH_O, (const char *)Dtool_TextNode_set_tab_width_440_comment},
  {"clear_tab_width", &Dtool_TextNode_clear_tab_width_441, METH_NOARGS, (const char *)Dtool_TextNode_clear_tab_width_441_comment},
  {"clearTabWidth", &Dtool_TextNode_clear_tab_width_441, METH_NOARGS, (const char *)Dtool_TextNode_clear_tab_width_441_comment},
  {"set_glyph_scale", &Dtool_TextNode_set_glyph_scale_442, METH_O, (const char *)Dtool_TextNode_set_glyph_scale_442_comment},
  {"setGlyphScale", &Dtool_TextNode_set_glyph_scale_442, METH_O, (const char *)Dtool_TextNode_set_glyph_scale_442_comment},
  {"clear_glyph_scale", &Dtool_TextNode_clear_glyph_scale_443, METH_NOARGS, (const char *)Dtool_TextNode_clear_glyph_scale_443_comment},
  {"clearGlyphScale", &Dtool_TextNode_clear_glyph_scale_443, METH_NOARGS, (const char *)Dtool_TextNode_clear_glyph_scale_443_comment},
  {"set_glyph_shift", &Dtool_TextNode_set_glyph_shift_444, METH_O, (const char *)Dtool_TextNode_set_glyph_shift_444_comment},
  {"setGlyphShift", &Dtool_TextNode_set_glyph_shift_444, METH_O, (const char *)Dtool_TextNode_set_glyph_shift_444_comment},
  {"clear_glyph_shift", &Dtool_TextNode_clear_glyph_shift_445, METH_NOARGS, (const char *)Dtool_TextNode_clear_glyph_shift_445_comment},
  {"clearGlyphShift", &Dtool_TextNode_clear_glyph_shift_445, METH_NOARGS, (const char *)Dtool_TextNode_clear_glyph_shift_445_comment},
  {"get_wordwrapped_text", &Dtool_TextNode_get_wordwrapped_text_446, METH_NOARGS, (const char *)Dtool_TextNode_get_wordwrapped_text_446_comment},
  {"getWordwrappedText", &Dtool_TextNode_get_wordwrapped_text_446, METH_NOARGS, (const char *)Dtool_TextNode_get_wordwrapped_text_446_comment},
  {"calc_width", &Dtool_TextNode_calc_width_447, METH_O, (const char *)Dtool_TextNode_calc_width_447_comment},
  {"calcWidth", &Dtool_TextNode_calc_width_447, METH_O, (const char *)Dtool_TextNode_calc_width_447_comment},
  {"has_exact_character", &Dtool_TextNode_has_exact_character_448, METH_O, (const char *)Dtool_TextNode_has_exact_character_448_comment},
  {"hasExactCharacter", &Dtool_TextNode_has_exact_character_448, METH_O, (const char *)Dtool_TextNode_has_exact_character_448_comment},
  {"has_character", &Dtool_TextNode_has_character_449, METH_O, (const char *)Dtool_TextNode_has_character_449_comment},
  {"hasCharacter", &Dtool_TextNode_has_character_449, METH_O, (const char *)Dtool_TextNode_has_character_449_comment},
  {"is_whitespace", &Dtool_TextNode_is_whitespace_450, METH_O, (const char *)Dtool_TextNode_is_whitespace_450_comment},
  {"isWhitespace", &Dtool_TextNode_is_whitespace_450, METH_O, (const char *)Dtool_TextNode_is_whitespace_450_comment},
  {"get_wordwrapped_wtext", &Dtool_TextNode_get_wordwrapped_wtext_451, METH_NOARGS, (const char *)Dtool_TextNode_get_wordwrapped_wtext_451_comment},
  {"getWordwrappedWtext", &Dtool_TextNode_get_wordwrapped_wtext_451, METH_NOARGS, (const char *)Dtool_TextNode_get_wordwrapped_wtext_451_comment},
  {"output", &Dtool_TextNode_output_452, METH_O, (const char *)Dtool_TextNode_output_452_comment},
  {"write", (PyCFunction) &Dtool_TextNode_write_453, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_write_453_comment},
  {"get_left", &Dtool_TextNode_get_left_454, METH_NOARGS, (const char *)Dtool_TextNode_get_left_454_comment},
  {"getLeft", &Dtool_TextNode_get_left_454, METH_NOARGS, (const char *)Dtool_TextNode_get_left_454_comment},
  {"get_right", &Dtool_TextNode_get_right_455, METH_NOARGS, (const char *)Dtool_TextNode_get_right_455_comment},
  {"getRight", &Dtool_TextNode_get_right_455, METH_NOARGS, (const char *)Dtool_TextNode_get_right_455_comment},
  {"get_bottom", &Dtool_TextNode_get_bottom_456, METH_NOARGS, (const char *)Dtool_TextNode_get_bottom_456_comment},
  {"getBottom", &Dtool_TextNode_get_bottom_456, METH_NOARGS, (const char *)Dtool_TextNode_get_bottom_456_comment},
  {"get_top", &Dtool_TextNode_get_top_457, METH_NOARGS, (const char *)Dtool_TextNode_get_top_457_comment},
  {"getTop", &Dtool_TextNode_get_top_457, METH_NOARGS, (const char *)Dtool_TextNode_get_top_457_comment},
  {"get_height", &Dtool_TextNode_get_height_458, METH_NOARGS, (const char *)Dtool_TextNode_get_height_458_comment},
  {"getHeight", &Dtool_TextNode_get_height_458, METH_NOARGS, (const char *)Dtool_TextNode_get_height_458_comment},
  {"get_width", &Dtool_TextNode_get_width_459, METH_NOARGS, (const char *)Dtool_TextNode_get_width_459_comment},
  {"getWidth", &Dtool_TextNode_get_width_459, METH_NOARGS, (const char *)Dtool_TextNode_get_width_459_comment},
  {"get_upper_left_3d", &Dtool_TextNode_get_upper_left_3d_460, METH_NOARGS, (const char *)Dtool_TextNode_get_upper_left_3d_460_comment},
  {"getUpperLeft3d", &Dtool_TextNode_get_upper_left_3d_460, METH_NOARGS, (const char *)Dtool_TextNode_get_upper_left_3d_460_comment},
  {"get_lower_right_3d", &Dtool_TextNode_get_lower_right_3d_461, METH_NOARGS, (const char *)Dtool_TextNode_get_lower_right_3d_461_comment},
  {"getLowerRight3d", &Dtool_TextNode_get_lower_right_3d_461, METH_NOARGS, (const char *)Dtool_TextNode_get_lower_right_3d_461_comment},
  {"get_num_rows", &Dtool_TextNode_get_num_rows_462, METH_NOARGS, (const char *)Dtool_TextNode_get_num_rows_462_comment},
  {"getNumRows", &Dtool_TextNode_get_num_rows_462, METH_NOARGS, (const char *)Dtool_TextNode_get_num_rows_462_comment},
  {"generate", &Dtool_TextNode_generate_463, METH_NOARGS, (const char *)Dtool_TextNode_generate_463_comment},
  {"update", &Dtool_TextNode_update_464, METH_NOARGS, (const char *)Dtool_TextNode_update_464_comment},
  {"force_update", &Dtool_TextNode_force_update_465, METH_NOARGS, (const char *)Dtool_TextNode_force_update_465_comment},
  {"forceUpdate", &Dtool_TextNode_force_update_465, METH_NOARGS, (const char *)Dtool_TextNode_force_update_465_comment},
  {"get_internal_geom", &Dtool_TextNode_get_internal_geom_466, METH_NOARGS, (const char *)Dtool_TextNode_get_internal_geom_466_comment},
  {"getInternalGeom", &Dtool_TextNode_get_internal_geom_466, METH_NOARGS, (const char *)Dtool_TextNode_get_internal_geom_466_comment},
  {"get_class_type", &Dtool_TextNode_get_class_type_546, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextNode_get_class_type_546_comment},
  {"getClassType", &Dtool_TextNode_get_class_type_546, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextNode_get_class_type_546_comment},
  {"upcast_to_PandaNode", &Dtool_TextNode_upcast_to_PandaNode_358, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_PandaNode_358_comment},
  {"upcastToPandaNode", &Dtool_TextNode_upcast_to_PandaNode_358, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_PandaNode_358_comment},
  {"upcast_to_TextEncoder", &Dtool_TextNode_upcast_to_TextEncoder_361, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_TextEncoder_361_comment},
  {"upcastToTextEncoder", &Dtool_TextNode_upcast_to_TextEncoder_361, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_TextEncoder_361_comment},
  {"upcast_to_TextProperties", &Dtool_TextNode_upcast_to_TextProperties_363, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_TextProperties_363_comment},
  {"upcastToTextProperties", &Dtool_TextNode_upcast_to_TextProperties_363, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_TextProperties_363_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     TextNode
//////////////////
static PyObject *Dtool_Repr_TextNode(PyObject *self) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     TextNode
//////////////////
static PyObject *Dtool_Str_TextNode(PyObject *self) {
  TextNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_TextNode[] = {
  {(char *)"max_rows", &Dtool_TextNode_max_rows_Getter, &Dtool_TextNode_max_rows_Setter, nullptr, nullptr},
  {(char *)"frame_color", &Dtool_TextNode_frame_color_Getter, &Dtool_TextNode_frame_color_Setter, nullptr, nullptr},
  {(char *)"card_color", &Dtool_TextNode_card_color_Getter, &Dtool_TextNode_card_color_Setter, nullptr, nullptr},
  {(char *)"card_texture", &Dtool_TextNode_card_texture_Getter, &Dtool_TextNode_card_texture_Setter, nullptr, nullptr},
  {(char *)"frame_line_width", &Dtool_TextNode_frame_line_width_Getter, &Dtool_TextNode_frame_line_width_Setter, nullptr, nullptr},
  {(char *)"frame_corners", &Dtool_TextNode_frame_corners_Getter, &Dtool_TextNode_frame_corners_Setter, nullptr, nullptr},
  {(char *)"transform", &Dtool_TextNode_transform_Getter, &Dtool_TextNode_transform_Setter, nullptr, nullptr},
  {(char *)"coordinate_system", &Dtool_TextNode_coordinate_system_Getter, &Dtool_TextNode_coordinate_system_Setter, nullptr, nullptr},
  {(char *)"usage_hint", &Dtool_TextNode_usage_hint_Getter, &Dtool_TextNode_usage_hint_Setter, nullptr, nullptr},
  {(char *)"flatten_flags", &Dtool_TextNode_flatten_flags_Getter, &Dtool_TextNode_flatten_flags_Setter, nullptr, nullptr},
  {(char *)"font", &Dtool_TextNode_font_Getter, &Dtool_TextNode_font_Setter, (char *)
    "/**\n"
    " * Returns the font currently in use, if any.  If no font is in use, this\n"
    " * returns the default font.\n"
    " */",
    nullptr},
  {(char *)"small_caps", &Dtool_TextNode_small_caps_Getter, &Dtool_TextNode_small_caps_Setter, (char *)
    "/**\n"
    " * Returns the small_caps flag.  See set_small_caps().\n"
    " */",
    nullptr},
  {(char *)"small_caps_scale", &Dtool_TextNode_small_caps_scale_Getter, &Dtool_TextNode_small_caps_scale_Setter, (char *)
    "/**\n"
    " * Returns the scale factor applied to lowercase letters from their uppercase\n"
    " * equivalents, when the small_caps flag is in effect.  See set_small_caps()\n"
    " * and set_small_caps_scale().\n"
    " */",
    nullptr},
  {(char *)"slant", &Dtool_TextNode_slant_Getter, &Dtool_TextNode_slant_Setter, (char *)
    "/**\n"
    " * Returns the factor by which the text is specified to slant to the right.\n"
    " */",
    nullptr},
  {(char *)"underscore", &Dtool_TextNode_underscore_Getter, &Dtool_TextNode_underscore_Setter, (char *)
    "/**\n"
    " * Returns the underscore flag.  See set_underscore().\n"
    " */",
    nullptr},
  {(char *)"underscore_height", &Dtool_TextNode_underscore_height_Getter, &Dtool_TextNode_underscore_height_Setter, (char *)
    "/**\n"
    " * Returns the vertical height of the underscore; see set_underscore_height().\n"
    " */",
    nullptr},
  {(char *)"align", &Dtool_TextNode_align_Getter, &Dtool_TextNode_align_Setter, (char *)
    "/**\n"
    " *\n"
    " */",
    nullptr},
  {(char *)"indent", &Dtool_TextNode_indent_Getter, &Dtool_TextNode_indent_Setter, (char *)
    "/**\n"
    " *\n"
    " */",
    nullptr},
  {(char *)"wordwrap", &Dtool_TextNode_wordwrap_Getter, &Dtool_TextNode_wordwrap_Setter, (char *)
    "/**\n"
    " *\n"
    " */",
    nullptr},
  {(char *)"preserve_trailing_whitespace", &Dtool_TextNode_preserve_trailing_whitespace_Getter, &Dtool_TextNode_preserve_trailing_whitespace_Setter, (char *)
    "/**\n"
    " * Returns the preserve_trailing_whitespace flag.  See\n"
    " * set_preserve_trailing_whitespace().\n"
    " */",
    nullptr},
  {(char *)"text_color", &Dtool_TextNode_text_color_Getter, &Dtool_TextNode_text_color_Setter, (char *)
    "/**\n"
    " *\n"
    " */",
    nullptr},
  {(char *)"shadow_color", &Dtool_TextNode_shadow_color_Getter, &Dtool_TextNode_shadow_color_Setter, (char *)
    "/**\n"
    " *\n"
    " */",
    nullptr},
  {(char *)"shadow", &Dtool_TextNode_shadow_Getter, &Dtool_TextNode_shadow_Setter, (char *)
    "/**\n"
    " * Returns the offset of the shadow as set by set_shadow().  It is an error to\n"
    " * call this if has_shadow() is false.\n"
    " */",
    nullptr},
  {(char *)"bin", &Dtool_TextNode_bin_Getter, &Dtool_TextNode_bin_Setter, (char *)
    "/**\n"
    " * Returns the drawing bin set with set_bin(), or empty string if no bin has\n"
    " * been set.\n"
    " */",
    nullptr},
  {(char *)"draw_order", &Dtool_TextNode_draw_order_Getter, &Dtool_TextNode_draw_order_Setter, (char *)
    "/**\n"
    " * Returns the drawing order set with set_draw_order().\n"
    " */",
    nullptr},
  {(char *)"tab_width", &Dtool_TextNode_tab_width_Getter, &Dtool_TextNode_tab_width_Setter, (char *)
    "/**\n"
    " * Returns the width set via set_tab_width().\n"
    " */",
    nullptr},
  {(char *)"glyph_scale", &Dtool_TextNode_glyph_scale_Getter, &Dtool_TextNode_glyph_scale_Setter, (char *)
    "/**\n"
    " * Returns the scale factor of each letter as specified by set_glyph_scale().\n"
    " */",
    nullptr},
  {(char *)"glyph_shift", &Dtool_TextNode_glyph_shift_Getter, &Dtool_TextNode_glyph_shift_Setter, (char *)
    "/**\n"
    " * Returns the vertical shift of each letter as specified by\n"
    " * set_glyph_shift().\n"
    " */",
    nullptr},
  {(char *)"text_scale", &Dtool_TextNode_text_scale_Getter, &Dtool_TextNode_text_scale_Setter, (char *)
    "/**\n"
    " * Returns the scale factor of the text as specified by set_text_scale().\n"
    " */",
    nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TextNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TextNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TextNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TextNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TextNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TextNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TextNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_TextNode,
    &Dtool_NumberMethods_TextNode,
    &Dtool_SequenceMethods_TextNode,
    &Dtool_MappingMethods_TextNode,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_TextNode,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TextNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The primary interface to this module.  This class does basic text assembly;\n"
    " * given a string of text and a TextFont object, it creates a piece of\n"
    " * geometry that may be placed in the 3-d or 2-d world to represent the\n"
    " * indicated text.\n"
    " *\n"
    " * The TextNode may be used in one of two ways.  Naively, it may simply be\n"
    " * parented directly into the scene graph and rendered as if it were a\n"
    " * GeomNode; in this mode, the actual polygon geometry that renders the text\n"
    " * is not directly visible or accessible, but remains hidden within the\n"
    " * TextNode.\n"
    " *\n"
    " * The second way TextNode may be used is as a text generator.  To use it in\n"
    " * this way, do not parent the TextNode to the scene graph; instead, set the\n"
    " * properties of the text and call generate() to return an ordinary node,\n"
    " * containing ordinary geometry, which you may use however you like.  Each\n"
    " * time you call generate() a new node is returned.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextNode,
    nullptr, // tp_members
    Dtool_Properties_TextNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextNode,
    PyType_GenericAlloc,
    Dtool_new_TextNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextNode,
  Dtool_UpcastInterface_TextNode,
  Dtool_DowncastInterface_TextNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_TextEncoder != nullptr);
    assert(Dtool_Ptr_TextEncoder->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TextEncoder->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_TextProperties(nullptr);
    Dtool_TextNode._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)Dtool_Ptr_PandaNode, (PyTypeObject *)Dtool_Ptr_TextEncoder, (PyTypeObject *)&Dtool_TextProperties);
    Dtool_TextNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_TextNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TextNode::FlattenFlags;
    PyDict_SetItemString(dict, "FF_none", Dtool_WrapValue(TextNode::FF_none));
    PyDict_SetItemString(dict, "FFNone", Dtool_WrapValue(TextNode::FF_none));
    PyDict_SetItemString(dict, "FF_light", Dtool_WrapValue(TextNode::FF_light));
    PyDict_SetItemString(dict, "FFLight", Dtool_WrapValue(TextNode::FF_light));
    PyDict_SetItemString(dict, "FF_medium", Dtool_WrapValue(TextNode::FF_medium));
    PyDict_SetItemString(dict, "FFMedium", Dtool_WrapValue(TextNode::FF_medium));
    PyDict_SetItemString(dict, "FF_strong", Dtool_WrapValue(TextNode::FF_strong));
    PyDict_SetItemString(dict, "FFStrong", Dtool_WrapValue(TextNode::FF_strong));
    PyDict_SetItemString(dict, "FF_dynamic_merge", Dtool_WrapValue(TextNode::FF_dynamic_merge));
    PyDict_SetItemString(dict, "FFDynamicMerge", Dtool_WrapValue(TextNode::FF_dynamic_merge));
    if (PyType_Ready((PyTypeObject *)&Dtool_TextNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextNode);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3text_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    TextGlyph::init_type();
    TypeHandle handle = TextGlyph::get_class_type();
    Dtool_TextGlyph._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TextGlyph);
  }
  {
    TextFont::init_type();
    TypeHandle handle = TextFont::get_class_type();
    Dtool_TextFont._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TextFont);
  }
  {
    DynamicTextGlyph::init_type();
    TypeHandle handle = DynamicTextGlyph::get_class_type();
    Dtool_DynamicTextGlyph._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DynamicTextGlyph);
  }
  {
    DynamicTextPage::init_type();
    TypeHandle handle = DynamicTextPage::get_class_type();
    Dtool_DynamicTextPage._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DynamicTextPage);
  }
  {
    DynamicTextFont::init_type();
    TypeHandle handle = DynamicTextFont::get_class_type();
    Dtool_DynamicTextFont._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DynamicTextFont);
  }
  {
    GeomTextGlyph::init_type();
    TypeHandle handle = GeomTextGlyph::get_class_type();
    Dtool_GeomTextGlyph._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeomTextGlyph);
  }
  {
    StaticTextFont::init_type();
    TypeHandle handle = StaticTextFont::get_class_type();
    Dtool_StaticTextFont._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_StaticTextFont);
  }
  {
    TextProperties::init_type();
    TypeHandle handle = TextProperties::get_class_type();
    Dtool_TextProperties._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TextProperties);
  }
  {
    TextNode::init_type();
    TypeHandle handle = TextNode::get_class_type();
    Dtool_TextNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TextNode);
  }
}

void Dtool_libp3text_BuildInstants(PyObject *module) {
  (void) module;
  // TextGlyph
  Dtool_PyModuleClassInit_TextGlyph(module);
  PyModule_AddObject(module, "TextGlyph", (PyObject *)&Dtool_TextGlyph);
  // TextFont
  Dtool_PyModuleClassInit_TextFont(module);
  PyModule_AddObject(module, "TextFont", (PyObject *)&Dtool_TextFont);
  // DynamicTextGlyph
  Dtool_PyModuleClassInit_DynamicTextGlyph(module);
  PyModule_AddObject(module, "DynamicTextGlyph", (PyObject *)&Dtool_DynamicTextGlyph);
  // DynamicTextPage
  Dtool_PyModuleClassInit_DynamicTextPage(module);
  PyModule_AddObject(module, "DynamicTextPage", (PyObject *)&Dtool_DynamicTextPage);
  // DynamicTextFont
  Dtool_PyModuleClassInit_DynamicTextFont(module);
  PyModule_AddObject(module, "DynamicTextFont", (PyObject *)&Dtool_DynamicTextFont);
  // FontPool
  Dtool_PyModuleClassInit_FontPool(module);
  PyModule_AddObject(module, "FontPool", (PyObject *)&Dtool_FontPool);
  // GeomTextGlyph
  Dtool_PyModuleClassInit_GeomTextGlyph(module);
  PyModule_AddObject(module, "GeomTextGlyph", (PyObject *)&Dtool_GeomTextGlyph);
  // StaticTextFont
  Dtool_PyModuleClassInit_StaticTextFont(module);
  PyModule_AddObject(module, "StaticTextFont", (PyObject *)&Dtool_StaticTextFont);
  // TextProperties
  Dtool_PyModuleClassInit_TextProperties(module);
  PyModule_AddObject(module, "TextProperties", (PyObject *)&Dtool_TextProperties);
  // TextGraphic
  Dtool_PyModuleClassInit_TextGraphic(module);
  PyModule_AddObject(module, "TextGraphic", (PyObject *)&Dtool_TextGraphic);
  // TextPropertiesManager
  Dtool_PyModuleClassInit_TextPropertiesManager(module);
  PyModule_AddObject(module, "TextPropertiesManager", (PyObject *)&Dtool_TextPropertiesManager);
  // TextAssembler
  Dtool_PyModuleClassInit_TextAssembler(module);
  PyModule_AddObject(module, "TextAssembler", (PyObject *)&Dtool_TextAssembler);
  // TextNode
  Dtool_PyModuleClassInit_TextNode(module);
  PyModule_AddObject(module, "TextNode", (PyObject *)&Dtool_TextNode);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3text_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3text_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613679,  /* file_identifier */
  "libp3text",  /* library_name */
  "z_GL",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3text.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1007  /* next_index */
};

Configure(_in_configure_libp3text);
ConfigureFn(_in_configure_libp3text) {
  interrogate_request_module(&_in_module_def);
}

